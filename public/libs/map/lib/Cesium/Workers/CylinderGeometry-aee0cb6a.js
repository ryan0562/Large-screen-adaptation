define(["exports","./GeometryOffsetAttribute-24539cee","./Transforms-0513682f","./Matrix2-860854d4","./ComponentDatatype-8f55628c","./CylinderGeometryLibrary-31943ac1","./when-4bbc8319","./RuntimeError-1349fdaf","./GeometryAttribute-51279fbd","./GeometryAttributes-7827a6c2","./IndexDatatype-1d853600","./VertexFormat-b8b51b88"],(function(t,e,o,n,a,r,i,s,m,u,c,l){"use strict";const d=new n.Cartesian2,f=new n.Cartesian3,p=new n.Cartesian3,y=new n.Cartesian3,b=new n.Cartesian3;function h(t){const e=(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT)).length,o=t.topRadius,n=t.bottomRadius,a=i.defaultValue(t.vertexFormat,l.VertexFormat.DEFAULT),r=i.defaultValue(t.slices,128);this._length=e,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=l.VertexFormat.clone(a),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry",this._showBottom=i.defaultValue(t.showBottom,1)}h.packedLength=l.VertexFormat.packedLength+5,h.pack=function(t,e,o){return o=i.defaultValue(o,0),l.VertexFormat.pack(t._vertexFormat,e,o),o+=l.VertexFormat.packedLength,e[o++]=t._length,e[o++]=t._topRadius,e[o++]=t._bottomRadius,e[o++]=t._slices,e[o++]=t._showBottom,e[o]=i.defaultValue(t._offsetAttribute,-1),e};const A=new l.VertexFormat,_={vertexFormat:A,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0,showBottom:void 0};let x;h.unpack=function(t,e,o){e=i.defaultValue(e,0);const n=l.VertexFormat.unpack(t,e,A);e+=l.VertexFormat.packedLength;const a=t[e++],r=t[e++],s=t[e++],m=t[e++],u=t[e];return i.defined(o)?(o._vertexFormat=l.VertexFormat.clone(n,o._vertexFormat),o._length=a,o._topRadius=r,o._bottomRadius=s,o._slices=m,o._showBottom=showBottom,o._offsetAttribute=-1===u?void 0:u,o):(_.length=a,_.topRadius=r,_.bottomRadius=s,_.slices=m,_.showBottom=showBottom,_.offsetAttribute=-1===u?void 0:u,new h(_))},h.createGeometry=function(t){let s=t._length;const l=t._topRadius,h=t._bottomRadius,A=t._vertexFormat,_=t._slices;if(s<=0||l<0||h<0||0===l&&0===h)return;const x=_+_,g=_+x,w=x+x,F=r.CylinderGeometryLibrary.computePositions(s,l,h,_,!0),v=A.st?new Float32Array(2*w):void 0,C=A.normal?new Float32Array(3*w):void 0,G=A.tangent?new Float32Array(3*w):void 0,R=A.bitangent?new Float32Array(3*w):void 0;let V;const D=A.normal||A.tangent||A.bitangent;if(D){const t=A.tangent||A.bitangent;let e=0,o=0,r=0;const i=Math.atan2(h-l,s),m=f;m.z=Math.sin(i);const u=Math.cos(i);let c=y,d=p;for(V=0;V<_;V++){const i=V/_*a.CesiumMath.TWO_PI,s=u*Math.cos(i),l=u*Math.sin(i);D&&(m.x=s,m.y=l,t&&(c=n.Cartesian3.normalize(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,m,c),c)),A.normal&&(C[e++]=m.x,C[e++]=m.y,C[e++]=m.z,C[e++]=m.x,C[e++]=m.y,C[e++]=m.z),A.tangent&&(G[o++]=c.x,G[o++]=c.y,G[o++]=c.z,G[o++]=c.x,G[o++]=c.y,G[o++]=c.z),A.bitangent&&(d=n.Cartesian3.normalize(n.Cartesian3.cross(m,c,d),d),R[r++]=d.x,R[r++]=d.y,R[r++]=d.z,R[r++]=d.x,R[r++]=d.y,R[r++]=d.z))}for(V=0;V<_;V++)A.normal&&(C[e++]=0,C[e++]=0,C[e++]=-1),A.tangent&&(G[o++]=1,G[o++]=0,G[o++]=0),A.bitangent&&(R[r++]=0,R[r++]=-1,R[r++]=0);for(V=0;V<_;V++)A.normal&&(C[e++]=0,C[e++]=0,C[e++]=1),A.tangent&&(G[o++]=1,G[o++]=0,G[o++]=0),A.bitangent&&(R[r++]=0,R[r++]=1,R[r++]=0)}const T=12*_-12,O=c.IndexDatatype.createTypedArray(w,T);let L=0,B=0;for(V=0;V<_-1;V++)O[L++]=B,O[L++]=B+2,O[L++]=B+3,O[L++]=B,O[L++]=B+3,O[L++]=B+1,B+=2;for(O[L++]=x-2,O[L++]=0,O[L++]=1,O[L++]=x-2,O[L++]=1,O[L++]=x-1,V=1;V<_-1;V++)O[L++]=x+V+1,O[L++]=x+V,O[L++]=x;for(V=1;V<_-1;V++)O[L++]=g,O[L++]=g+V,O[L++]=g+V+1;let P=0;if(A.st){const t=Math.max(l,h);for(V=0;V<w;V++){const e=n.Cartesian3.fromArray(F,3*V,b);v[P++]=(e.x+t)/(2*t),v[P++]=(e.y+t)/(2*t)}}const E=new u.GeometryAttributes;A.position&&(E.position=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F})),A.normal&&(E.normal=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),A.tangent&&(E.tangent=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),A.bitangent&&(E.bitangent=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),A.st&&(E.st=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:v})),d.x=.5*s,d.y=Math.max(h,l);const M=new o.BoundingSphere(n.Cartesian3.ZERO,n.Cartesian2.magnitude(d));if(i.defined(t._offsetAttribute)){s=F.length;const o=new Uint8Array(s/3),n=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(o,n),E.applyOffset=new m.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}return new m.Geometry({attributes:E,indices:O,primitiveType:m.PrimitiveType.TRIANGLES,boundingSphere:M,offsetAttribute:t._offsetAttribute})},h.getUnitCylinder=function(){return i.defined(x)||(x=h.createGeometry(new h({topRadius:1,bottomRadius:1,length:1,vertexFormat:l.VertexFormat.POSITION_ONLY}))),x},t.CylinderGeometry=h}));
