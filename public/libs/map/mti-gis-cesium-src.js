/**
* @preserve
* mti-gis-cesium-v1.0.0-beta.7, 一个基于Cesium的GIS封装库
* dev+g0e095ee(2022-10-14 17:19:14 +0800)
* (c) 2010-2022 新智道枢
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@turf/turf'), require('cesium'), require('echarts')) :
  typeof define === 'function' && define.amd ? define(['exports', '@turf/turf', 'cesium', 'echarts'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mtiMap3d = {}, global.turf, global.Cesium, global.echarts));
})(this, (function (exports, Turf, Cesium, echarts) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var Turf__namespace = /*#__PURE__*/_interopNamespace(Turf);
  var Cesium__namespace = /*#__PURE__*/_interopNamespace(Cesium);
  var echarts__namespace = /*#__PURE__*/_interopNamespace(echarts);

  var ProjUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get getProjection () { return getProjection; },
    get CoordinateDecryptType () { return CoordinateDecryptType; },
    get register () { return register; },
    get transformToDataProjection () { return transformToDataProjection; },
    get transformToProjection () { return transformToProjection; },
    get transform () { return transform$3; },
    get transformInternal () { return transformInternal; },
    get WGStoGCJ () { return WGStoGCJ; },
    get GCJtoWGS () { return GCJtoWGS; },
    get GCJtoBD () { return GCJtoBD; },
    get BDtoGCJ () { return BDtoGCJ; },
    get WGStoBD () { return WGStoBD; },
    get BDtoWGS () { return BDtoWGS; },
    get transformGeoJsonFeature () { return transformGeoJsonFeature; },
    get transformGeoJsonGeometryCoordinates () { return transformGeoJsonGeometryCoordinates; },
    get dataOffset () { return dataOffset; }
  });

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$2 = "@charset \"UTF-8\";\n.mti-gis-overlay-tooltip {\n  position: absolute;\n}\n.mti-gis-overlay-tooltip .tooltip-container {\n  border-radius: 4px;\n  padding: 10px;\n  z-index: 2000;\n  font-size: 12px;\n  line-height: 1.2;\n  min-width: 10px;\n  word-wrap: break-word;\n}\n.mti-gis-overlay-tooltip .tooltip-container .popper-arrow,\n.mti-gis-overlay-tooltip .tooltip-container .popper-arrow:after {\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n  border-color: transparent;\n  border-style: solid;\n  border-width: 6px;\n}\n.mti-gis-overlay-tooltip .is-dark {\n  background: #303133;\n  color: #fff;\n}\n.mti-gis-overlay-tooltip .is-light {\n  background: #fff;\n  color: #303133;\n  border: 1px solid #303133;\n}\n.mti-gis-overlay-tooltip div[class~=is-top] {\n  margin-bottom: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-top] .popper-arrow {\n  bottom: 1px;\n  border-bottom-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-top is-dark\"] .popper-arrow {\n  border-top-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-top is-light\"] .popper-arrow {\n  border-top-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-bottom] {\n  margin-top: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-bottom] .popper-arrow {\n  top: 1px;\n  border-top-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-bottom is-dark\"] .popper-arrow {\n  border-bottom-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-bottom is-light\"] .popper-arrow {\n  border-bottom-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-left] {\n  margin-right: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-left] .popper-arrow {\n  right: 1px;\n  border-right-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-left is-dark\"] .popper-arrow {\n  border-left-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-left is-light\"] .popper-arrow {\n  border-left-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-right] {\n  margin-left: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-right] .popper-arrow {\n  left: 1px;\n  border-left-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-right is-dark\"] .popper-arrow {\n  border-right-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-right is-light\"] .popper-arrow {\n  border-right-color: #fff;\n}\n\n.mti-gis-overlay .context-menu {\n  font-size: 12px;\n  box-shadow: 0px 0px 5px 0px;\n  text-align: center;\n  width: 130px;\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  user-select: none;\n}\n.mti-gis-overlay .context-menu .item {\n  cursor: pointer;\n  height: 34px;\n  line-height: 34px;\n  list-style: none;\n}\n.mti-gis-overlay .context-menu .item::before {\n  content: \"☆\";\n  position: absolute;\n  left: 10px;\n}\n.mti-gis-overlay .context-menu .item:last-child {\n  border-bottom: none;\n  height: 35px;\n  line-height: 35px;\n}\n.mti-gis-overlay .dark .item {\n  color: #fff;\n  background-color: #303133;\n  border-bottom: 1px solid #606266;\n}\n.mti-gis-overlay .dark .item:hover {\n  background-color: #606266;\n}\n.mti-gis-overlay .light .item {\n  color: #303133;\n  background-color: #fff;\n  border-bottom: 1px solid #eee;\n}\n.mti-gis-overlay .light .item:hover {\n  background-color: #eee;\n}\n\n.gis-widget-coordinate {\n  position: absolute;\n  bottom: 0px;\n  right: 10px;\n  color: white;\n  z-index: 10;\n  font-size: 12px;\n}\n\n.mti-measure-tool {\n  position: absolute;\n  padding: 1px 1px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  font-size: 12px;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-move {\n  position: absolute;\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: left;\n  white-space: nowrap;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  font-size: 12px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-move .tool-tip {\n  color: #7a7a7a;\n}\n\n.mti-measure-tool-move span .measure-result {\n  color: #ff6319;\n}\n\n.mti-measure-tool-overlay-label {\n  border: 1px solid #7a7a7a;\n  border-radius: 4px;\n  color: #7a7a7a;\n  font-size: 12px;\n  padding: 1px 4px;\n  background-color: #ffffff;\n}\n\n.mti-measure-tool-area-overlay-label {\n  font-size: 12px;\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  background-color: #ffffff;\n  border: 1px solid #ff0103;\n  color: #333333;\n}\n\n.mti-measure-tool-end-overlay-label {\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  font-size: 12px;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-end-overlay-label .measure-end-label {\n  color: #ff6319;\n}\n\n/* 右键菜单组件 */\n#mti-contextmenu {\n  background: #15191bd1;\n  border: 1px solid #0da4a9;\n  min-width: 110px;\n  box-shadow: 1px 1px 2px 1px rgba(255, 255, 255, 0.3);\n}\n\n#mti-contextmenu ul,\n#mti-contextmenu li {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  color: #a1afaf;\n}\n\n.mti-contextmenu {\n  background: #15191bd1;\n  min-width: 110px;\n  font-size: 12px;\n}\n\n.mti-contextmenu a {\n  border-bottom: 1px solid rgba(5, 99, 98, 0.82);\n  padding: 5px 15px;\n  transition: background-color 0.15s;\n  display: block;\n  clear: both;\n  font-weight: 400;\n  line-height: 1.6;\n  white-space: nowrap;\n  color: #a1afaf;\n  text-decoration: none;\n}\n\n.mti-contextmenu li:last-child a {\n  border-bottom: none;\n}\n\n.mti-contextmenu a:hover {\n  background-color: #444d59;\n  color: #fff;\n}\n\n.ole-scale-line-control {\n  position: absolute;\n  bottom: 0.5em;\n  left: 0.5em;\n  border-radius: 4px;\n  padding: 2px;\n  transition: 0.3s;\n}\n\n.ole-scale-line-control .ole-scale-line-control-inner {\n  border: 2px solid #2d2922;\n  border-top: none;\n  color: #2d2922;\n  font-size: 12px;\n  text-align: center;\n  height: 10px;\n  line-height: 0px;\n  font-family: \"Microsoft YaHei\";\n  margin: 1px;\n  will-change: contents, width;\n}\n\n.mti-gis-ol-scale-line {\n  position: absolute;\n  left: 10px;\n  bottom: 10px;\n}\n\n.mti-gis-ol-scale-line-text {\n  text-align: center;\n  font-size: 10px;\n}\n\n.mti-gis-ol-scale-line-line {\n  position: relative;\n  height: 8px;\n}\n\n.mti-gis-ol-scale-line-line > div {\n  box-sizing: content-box !important;\n  position: absolute;\n  background-color: #333;\n  overflow: hidden;\n}\n\n.mti-gis-ol-scale-line-edgeleft,\n.mti-gis-ol-scale-line-edgeright {\n  width: 1px;\n  height: 6px;\n  border: solid 1px #fff;\n}\n\n.mti-gis-ol-scale-line-middle {\n  height: 2px;\n  left: 2px;\n  top: 2px;\n  border-top: solid 1px #fff;\n  border-bottom: solid 1px #fff;\n}\n\n.p-helper-circle-point-div {\n  width: 60px;\n  height: 22px;\n  opacity: 0.8;\n}\n\n.p-helper-control-point-div {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  border-color: red;\n  background-color: red;\n  opacity: 0.8;\n}\n\n.p-helper-lbutton-point-div {\n  width: 30px;\n  height: 100%;\n  cursor: move;\n  float: left;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAeCAYAAADQBxWhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMkZCRkJBNUYxODAxMUU5QTRBRkFGRjVBQjEyN0EzQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMkZCRkJBNkYxODAxMUU5QTRBRkFGRjVBQjEyN0EzQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUyRkJGQkEzRjE4MDExRTlBNEFGQUZGNUFCMTI3QTNDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUyRkJGQkE0RjE4MDExRTlBNEFGQUZGNUFCMTI3QTNDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+sycNXwAAA+xJREFUeNq8l11MW2UYx/+n57SkX4MOSrXANlSKxYld1xa22GAhNFISUNMsSDTBxTs/oolyQ0i4kHjhx4UmuzCacKESnTHqDEOXTF2iYILxxlgSs/oBWtrSln5u7drz+pxOFoEhtGt9kt70nL6/Pl//53k5j8eD3YzjODDGkM1mFbFYbKhQKNxfX19/XK1WH1EoFLUoz1LCbk9kMhkymUxtJBJ5rqGh4cn+/v7mrq4umEwmGAwGELhMJrTCzbyTLBAInFIqla+NjY01Dw8Po7W1FRWypLAdSCHEysrKGzab7Znx8XF0dHSg0iZsB66urr7n9XpHJycnwfM8qmE3oFLBkIdvSsCpqSlU02SbRbO2tua1Wq1PVxtY5ElhTafTaiqamenp6apAKIhboVJYqS1eGB0dVbe0tFQMJIrAzPs5vPx6dgcUfX19cpfLFQ2FQqwS9legwM68nWXuR1IMtRvM0ZvY/kpCiEajnoGBAZ1er78lz5Z+zOPjz/K48E0ev1wWqU6uf99slO2sXmqTB7u7u8uGfT5PsHM5XFooIBBkRZhaCRw183C7BDw0KN8JJYnrbGtrKwm0EWc4d/4aPvzkGr7/oYB4kg6i5jtyiMNJOw+PW45B+igUu/SpRqM5vN/QpjMMZ97J4SzBfvtdhFQfSiWHY52yoleDbgF3m/YWFEEul9fuV7yDYYaXXs1CqwEOHpThUBOHF5+tQb9LKF0c9msqylXbHTJEogxXswyZqwwXL+Ux92UeV66wfZ/DUz6fopl6QKVS7fmyRs3B5RRQr+OwHmH4ySfi6++uQy98lccff4pQ0zHG2//Tlxx6e3u/9fl8JfdjPCGydz/IsqGRFDOY4kx5W5ypm+LsTmuCjZxOs9mzWZZMiTf7aYLXarV2i8Via29vLykvNTUcOu/h8ahXUWwPQc4QizGshRgu/yrii4t5fDqXh1hgsB3bkvMcbzQaBdLdEVKmsnv1Lsrz0IAczhMCajUctRBDmMLv94vYSIg4/VjN1vBWWgYlC4ZE9tZMlll7ksz9cJKJ4rbwms1mMRgMkrPKB+x2e0XEXk0Fd9zC4/FTcljvE2DQy/DPFlT0tDjaaMN7ZXZ2Nk1DvKIjTaXiYLmXv6HDW0YbiUOaNr8nJiYm8H+Y1KfFVYXk8Ofl5WX9+vq6o6enp5rMHL8p9lKYqX3mFhcXzeFw+KjT6SyuMVWFbu5KBP5oYWGhYWlpySEt1rc6Z/eEboLr6urO+/1+3/z8/IlkMnlA2uh1Ol3FoNxud5l/XSuel64V1E5NDocDknI1NjbSSFOWHX6uhAvUMG0ZJ+kP2Gk4HKaRqKXn5VBTfwswAHSScicWQmgwAAAAAElFTkSuQmCC) no-repeat;\n}\n\n.p-helper-rbutton-point-div {\n  width: 30px;\n  height: 100%;\n  cursor: move;\n  float: left;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAeCAYAAADQBxWhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6REU3NTczRjBGMTgwMTFFOTk0NTlERTJDNEY1RUMzRDgiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6REU3NTczRUZGMTgwMTFFOTk0NTlERTJDNEY1RUMzRDgiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZBOTRBQjUwRjE3QzExRTk5N0Y4OTdEODI4RkYyMjg2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZBOTRBQjUxRjE3QzExRTk5N0Y4OTdEODI4RkYyMjg2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YlDwwAAA9pJREFUeNq8V2tom2UUfr5cSbLVpiVb6EULzm1ECk5QLILYVocW5+bSKQQsrCqIWP/on9k/XWkR+0PFqfhjlSFTcW2FVN1mRzdkm70k68akjU2RtjTb7C1t2lyay/cdzzstdE3D0izZ8yfwfnx5vnPe55zzHMlut98EsAUZIBaLBUKh0MT8/PwVtVp9yWw2d+v1+pgkSSCilO9J4XCYkCGYENPT0/B6vRgYGIDb7fbNzc0dLyws/MxoNAYURdmYlL9oiX+3IgsYHx+H0+lEV1eXLxKJvG+1Wk+J8/VRZ5V0FSMjI2hraxORHystLX2PU38HsQo5gM1mQ3t7O2praxt8Pt93sixD3HNOSQVEdE1NTWChOqampo6tjTQn6V2Puro6DA8PHyoqKuoU4rojUqLckLa2tsJgMJxgtZtEmpNIP/okihPfx5BC7RmBxQSHw2Hiev7gdppFemkNnqxaIjywSHsPBumr41G6eUumbGBmZoYqKyv91dXV2iQhlRT9d+QaknGkeQUvO8L48OgK3FcT9xStxWJBRUWF2e/316hZYUf4TL/6cE+5BqXFKoQjgH+BcGua0O+W8VtvAteuy6xKCTt3ZCZ67n7o7e1dTErvKqJRop9+jtGbDSGyPbVExuIA6bYHyLIjQC+9FqRvf4jSwqKyqRR7PB6qqqq6nFbJ/OWV8WtPAj0XEvB4FUQiBFHqZQ+pcOiAFu+8oYPJKN01UhYS6uvrb6SMNBV6zsfp+QNB2vXEMhXbApT3YID+nkhPbNyPiZvFsibd+xDRXbgo42JfAuEVwkqUMO8nPLpbDaNhc3d7V1Kh2tPnEjj/ewJ/ehQsBQlbOJXlNhXeel2PV1/RwbpNlfYojMfjgQ1JgyHCL2ficJ5JwHVNxj+sYEUG8vKAmmoNE2mx70Ut8rZKm4pwdnYWwWBwMon062+iaD8Zx8SkgjiXpsydqdgq4Zmn1bDv0+GF5zQZ1+rY2Bh4yF9P+oeTp2JwX1GQb5aw6xEV9j6rgX2/Fo+Vq++5Hfb394vpc1azvvcK6T++R423D+uwv0aLbRYpK/1XpLavr2+hoKDgdBLpx0cN2PmwCkajlNVJ09HRIer085KSkvh9mac8xMWUCWm12u1s2EIq3Ac0NjaKvnvYZDKFxGjLOWlzczOGhoa+ZGfYsWpJNbkiE2aspaUFnZ2dP/IQf3etAc8J6RoL+gUTNqy3oFklFWa7u7tbRHfbbJeVlW1otjX8MCPlivvhd8E2BKOjoxgcHITL5brx/1rxaX5+fuq1ItMFir9e4ea9zKqcZCIXp/APXqCc6SxQ/wowAHXm3jQy9m6CAAAAAElFTkSuQmCC) no-repeat;\n}\n\n.cesium-credit-logoContainer {\n  visibility: hidden;\n}\n\n.cesium-viewer-overlay-container-stopevent > * {\n  pointer-events: auto;\n}\n\n.cesium-viewer-overlay-container-stopevent,\n.cesium-viewer-overlay-container {\n  user-select: none;\n  overflow: hidden;\n  pointer-events: none;\n  position: absolute;\n  z-index: 0;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n\n.mti-gis-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n/* 军事标会提示信息框 */\n.mti3d-tips {\n  position: absolute;\n  z-index: 9998;\n  min-height: 10px;\n  min-width: 100px;\n  background-color: rgba(0, 0, 0, 0.75);\n  border-radius: 14px;\n  white-space: nowrap;\n  color: #c7cece;\n  font-size: 12px;\n  padding: 3px 8px 3px 12px;\n  user-select: none;\n}\n\n.mti3d-tips::after {\n  position: absolute;\n  z-index: 999;\n  top: 50%;\n  left: -3px;\n  margin-top: -4px;\n  content: \"\";\n  width: 8px;\n  height: 8px;\n  background-color: black;\n  box-sizing: border-box;\n  transform: rotate(-45deg);\n  box-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3);\n}\n\n/**\n  popup style created by qzj\n*/\n.mti-gis-cesium-popups .info-popup {\n  position: absolute;\n  z-index: 9;\n  left: 0;\n  top: 0;\n  margin: 0;\n  user-select: none;\n}\n.mti-gis-cesium-popups .info-box {\n  position: relative;\n  height: auto;\n  padding: 0;\n}";
  styleInject(css_248z$2);

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal$1 || freeSelf || Function('return this')();

  var root$2 = root$1;

  /** Built-in value references. */
  var Symbol$2 = root$2.Symbol;

  var Symbol$3 = Symbol$2;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$a.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$a.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$9.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$b(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject$b(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$2['__core-js_shared__'];

  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$8 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$8.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$b(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var Map$2 = getNative(root$2, 'Map');

  var Map$3 = Map$2;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$7.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$6.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$3 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$3 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  var defineProperty$3 = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var defineProperty$4 = defineProperty$3;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty$4) {
      defineProperty$4(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  var baseFor$1 = baseFor;

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root$2.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */
  var Uint8Array$1 = root$2.Uint8Array;

  var Uint8Array$2 = Uint8Array$1;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Built-in value references. */
  var objectCreate$1 = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$b(proto)) {
        return {};
      }
      if (objectCreate$1) {
        return objectCreate$1(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  var baseCreate$1 = baseCreate;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  var getPrototype$1 = getPrototype;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

    return value === proto;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate$1(getPrototype$1(object))
      : {};
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$1;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$4.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments$1 = isArguments;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$2 = Array.isArray;

  var isArray$3 = isArray$2;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$1(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength$1(value.length) && !isFunction$1(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer = moduleExports$1 ? root$2.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  var isBuffer$1 = isBuffer;

  /** `Object#toString` result references. */
  var objectTag$1 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$3 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$3.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto = getPrototype$1(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength$1(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal$1.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  var nodeUtil$1 = nodeUtil;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  var isTypedArray$1 = isTypedArray;

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$2.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$1.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$3(value),
        isArg = !isArr && isArguments$1(value),
        isBuff = !isArr && !isArg && isBuffer$1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$b(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray$3(srcValue),
          isBuff = !isArr && isBuffer$1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$3(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
        newValue = objValue;
        if (isArguments$1(objValue)) {
          newValue = toPlainObject(objValue);
        }
        else if (!isObject$b(objValue) || isFunction$1(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor$1(source, function(srcValue, key) {
      stack || (stack = new Stack);
      if (isObject$b(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$2(value) {
    return value;
  }

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply$5(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply$5(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty$4 ? identity$2 : function(func, string) {
    return defineProperty$4(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  var baseSetToString$1 = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString$1);

  var setToString$1 = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString$1(overRest(func, start, identity$2), func + '');
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject$b(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge$1 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  var merge$2 = merge$1;

  var GeoJsonGeometryType;
  (function (GeoJsonGeometryType) {
      GeoJsonGeometryType["POINT"] = "Point";
      GeoJsonGeometryType["MULTI_POINT"] = "MultiPoint";
      GeoJsonGeometryType["LINE_STRING"] = "LineString";
      GeoJsonGeometryType["MULTI_LINE_STRING"] = "MultiLineString";
      GeoJsonGeometryType["POLYGON"] = "Polygon";
      GeoJsonGeometryType["MULTI_POLYGON"] = "MultiPolygon";
  })(GeoJsonGeometryType || (GeoJsonGeometryType = {}));
  var FeatureType;
  (function (FeatureType) {
      FeatureType["CIRCLE"] = "Circle";
  })(FeatureType || (FeatureType = {}));
  var GeoJsonType;
  (function (GeoJsonType) {
      GeoJsonType["FEATURE"] = "Feature";
      GeoJsonType["FEATURE_COLLECTION"] = "FeatureCollection";
  })(GeoJsonType || (GeoJsonType = {}));
  /**
   * 互联网地图类型
   * @enum {number}
   * @ignore
   */
  var MapType;
  (function (MapType) {
      MapType["VECTOR"] = "vec";
      MapType["IMAGE"] = "img";
      MapType["TERRAIN"] = "ter";
      MapType["LABEL"] = "label"; // 注记
  })(MapType || (MapType = {}));
  /**
   * 百度地图风格枚举
   */
  var BDMapType;
  (function (BDMapType) {
      BDMapType["IMAGE"] = "img";
      BDMapType["LABEL"] = "label";
      BDMapType["VEC"] = "vec";
      BDMapType["TRAFFIC"] = "traffic";
  })(BDMapType || (BDMapType = {}));
  /**
   *  切片方案类型
   * @enum {number}
   * @ignore
   */
  var TilingSchemeType;
  (function (TilingSchemeType) {
      TilingSchemeType["MERCATOR"] = "mercator";
      TilingSchemeType["GEOGRAPHIC"] = "geographic";
  })(TilingSchemeType || (TilingSchemeType = {}));
  /**
   * 锚点方位
   *
   * @enum {number}
   */
  var Positioning;
  (function (Positioning) {
      Positioning["BOTTOM_LEFT"] = "bottom-left";
      Positioning["BOTTOM_CENTER"] = "bottom-center";
      Positioning["BOTTOM_RIGHT"] = "bottom-right";
      Positioning["CENTER_LEFT"] = "center-left";
      Positioning["CENTER_CENTER"] = "center-center";
      Positioning["CENTER_RIGHT"] = "center-right";
      Positioning["TOP_LEFT"] = "top-left";
      Positioning["TOP_CENTER"] = "top-center";
      Positioning["TOP_RIGHT"] = "top-right";
  })(Positioning || (Positioning = {}));
  /**
   * 经纬度偏移加密类型
   */
  var CoordinateDecryptType;
  (function (CoordinateDecryptType) {
      /**
       * WGS84转到国测局02
       */
      CoordinateDecryptType["WGS_TO_GCJ"] = "WGStoGCJ";
      /**
       * 国测局02转到WGS84
       */
      CoordinateDecryptType["GCJ_TO_WGS"] = "GCJtoWGS";
      /**
       * 国测局02转到百度
       */
      CoordinateDecryptType["GCJ_TO_BD"] = "GCJtoBD";
      /**
       * 百度转到国测局02
       */
      CoordinateDecryptType["BD_TO_GCJ"] = "BDtoGCJ";
      /**
       * WGS84转到百度
       */
      CoordinateDecryptType["WGS_TO_BD"] = "WGStoBD";
      /**
       * 百度转到WGS84
       */
      CoordinateDecryptType["BD_TO_WGS"] = "BDtoWGS";
  })(CoordinateDecryptType || (CoordinateDecryptType = {}));
  var BaseEventType;
  (function (BaseEventType) {
      //----------------通用鼠标事件-------------------
      BaseEventType["CLICK"] = "click";
      BaseEventType["DOUBLE_CLICK"] = "doubleclick";
      BaseEventType["MOUSE_DOWN"] = "mousedown";
      BaseEventType["MOUSE_UP"] = "mouseup";
      BaseEventType["RIGHT_CLICK"] = "rightclick";
      BaseEventType["MOUSE_MOVE"] = "mousemove";
      BaseEventType["PICK"] = "pick";
      BaseEventType["DOUBLE_PICK"] = "doublepick";
      BaseEventType["RIGHT_PICK"] = "rightpick";
      //----------------------------------------------
      BaseEventType["ZOOM_CHANGED"] = "zoomchanged";
      BaseEventType["CENTER_CHANGED"] = "centerchanged";
      BaseEventType["MOVE_START"] = "movestart";
      BaseEventType["MOVE_END"] = "moveend";
      //----------------地球对象事件-------------------
      BaseEventType["ADD_LAYER"] = "addlayer";
      BaseEventType["REMOVE_LAYER"] = "removelayer";
      BaseEventType["ADD_MODEL"] = "addmodel";
      BaseEventType["REMOVE_MODEL"] = "removemodel";
      BaseEventType["ADD_OVERLAY"] = "addoverlay";
      BaseEventType["REMOVE_OVERLAY"] = "removeoverlay";
      BaseEventType["ADD_COMPONENT"] = "addcomponent";
      BaseEventType["ADD_PARTICLE"] = "addparticle";
      BaseEventType["REMOVE_COMPONENT"] = "removecomponent";
      BaseEventType["REMOVE_PARTICLE"] = "removeparticle";
      BaseEventType["CAMERA_CHANGED"] = "camerachanged";
      BaseEventType["CAMERA_MOVE_END"] = "cameramoveend";
      BaseEventType["CAMERA_MOVE_START"] = "cameramovestart";
      //---------------------------------------
      //----------------矢量图层事件-----------------------
      BaseEventType["ADD_FEATURE"] = "addfeature";
      BaseEventType["ADD_FEATURES"] = "addfeatures";
      BaseEventType["REMOVE_FEATURE"] = "removefeature";
      BaseEventType["STYLE_CHANGED"] = "stylechanged";
      //----------------------------------------
      //-----------------覆盖物相关事件----------------------
      BaseEventType["POST_RENDER"] = "postrender";
      //---------------------------------------
      //------------------绘制组件--------------------
      BaseEventType["DRAW_START"] = "drawstart";
      BaseEventType["DRAW_END"] = "drawend";
      //-------------------军事标绘组件
      BaseEventType["EDIT_START"] = "editstart";
      BaseEventType["EDIT_END"] = "editend";
      //----------周边搜索-------------
      BaseEventType["RADIUS_CHANGE"] = "radiuschange";
      //------------历史轨迹-----------------
      BaseEventType["TRACK_MOVE"] = "trackmove";
      BaseEventType["TRACK_MOVE_END"] = "trackmoveend";
      //---------------------------------------
      BaseEventType["FLY_END"] = "flyend";
      BaseEventType["FLY_START"] = "flystart";
      //-----------------模型调整器----------------------
      BaseEventType["MOVE"] = "move";
      BaseEventType["ROTATE_START"] = "rotatestart";
      BaseEventType["ROTATE"] = "rotate";
      BaseEventType["ROTATE_END"] = "rotateend";
      BaseEventType["SCALE_START"] = "scalestart";
      BaseEventType["SCALE"] = "scale";
      BaseEventType["SCALE_END"] = "scaleend";
      //----------------------------------------------
      //------------------右键菜单---------------------
      BaseEventType["SHOW"] = "show";
      BaseEventType["HIDE"] = "hide";
      //-----------------------------------------------------
      BaseEventType["MEASURE_END"] = "measureend";
      //-------------------------------------------------
      BaseEventType["TRANSLATION_END"] = "translationend";
      //----------------------------------------------
      BaseEventType["CHANGE"] = "change";
      BaseEventType["ERROR"] = "error";
      BaseEventType["BLUR"] = "blur";
      BaseEventType["CLEAR"] = "clear";
      BaseEventType["DRAGENTER"] = "dragenter";
      BaseEventType["DRAGOVER"] = "dragover";
      BaseEventType["DROP"] = "drop";
      BaseEventType["FOCUS"] = "focus";
      BaseEventType["KEYDOWN"] = "keydown";
      BaseEventType["KEYPRESS"] = "keypress";
      BaseEventType["LOAD"] = "load";
      BaseEventType["RESIZE"] = "resize";
      BaseEventType["TOUCHMOVE"] = "touchmove";
      BaseEventType["WHEEL"] = "wheel";
  })(BaseEventType || (BaseEventType = {}));

  /**
   * 高度定位时的参考方式
   */
  var HeightReference;
  (function (HeightReference) {
      /**
       * 绝对高度
       */
      HeightReference[HeightReference["NONE"] = 0] = "NONE";
      /**
       * 贴紧地形
       */
      HeightReference[HeightReference["CLAMP_TO_GROUND"] = 1] = "CLAMP_TO_GROUND";
      /**
       * 地形之上的高度
       */
      HeightReference[HeightReference["RELATIVE_TO_GROUND"] = 2] = "RELATIVE_TO_GROUND";
  })(HeightReference || (HeightReference = {}));
  /**
   * 样式类别
   */
  var StyleItemType;
  (function (StyleItemType) {
      /**
       * 图片渲染点
       */
      StyleItemType["ICON"] = "icon";
      /**
       * 文字标注
       */
      StyleItemType["LABEL"] = "label";
      /**
       * 颜色渲染
       */
      StyleItemType["COLOR"] = "color";
      /**
       * 图片填充渲染
       */
      StyleItemType["IMAGE"] = "image";
      StyleItemType["POLYLINE_ARROW"] = "polylineArrow";
      StyleItemType["ARROW_LINE"] = "arrowLine";
      /**
       * 发光线
       */
      StyleItemType["POLYLINE_GLOW"] = "polylineGlow";
      StyleItemType["POLYLINE_OUTLINE"] = "polylineOutline";
      StyleItemType["POLYGON_ENTITY"] = "polygonEntity";
      StyleItemType["ELLIPSE_ENTITY"] = "ellipseEntity";
      /**
       * 模型渲染点
       */
      StyleItemType["MODEL"] = "model";
      StyleItemType["MODEL_ENTITY"] = "modelEntity";
      /**
       * 水面
       */
      StyleItemType["WATER"] = "water";
      StyleItemType["POLYGON"] = "polygon";
      /**
       * 点要素 圆圈
       */
      StyleItemType["CIRCLE"] = "circle";
      /**
       * 二维自定义渲染器
       */
      StyleItemType["RENDERER"] = "renderer";
      /**
       * 流动渲染
       */
      StyleItemType["FLOW"] = "flow";
      /**
       * 闪烁渲染
       */
      StyleItemType["LINEAR_GRADIENT"] = "linearGradient";
      /**
       * 直线流动渲染
       */
      StyleItemType["LINEAR_FOW"] = "linearFlow";
      /**
       * 箭头流动渲染
       */
      StyleItemType["ARROW_FOW"] = "arrowFlow";
      /**
       * 径向渐变
       */
      StyleItemType["RADIAL_GRADIENT"] = "radialGradient";
      /**
       * 扩散波纹
       */
      StyleItemType["RIPPLE"] = "ripple";
      /**
       * 旋转
       */
      StyleItemType["ROTATE"] = "rotate";
  })(StyleItemType || (StyleItemType = {}));

  var Style = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get HeightReference () { return HeightReference; },
    get StyleItemType () { return StyleItemType; },
    get Positioning () { return Positioning; }
  });

  var _a$2, _b$1;
  var PROJECTION_NAME = Symbol.for("Projection");
  var WGS84_PROJECTION_NAME = "EPSG:4326";
  var WEB_MERCATOR_PROJECTION_NAME = "EPSG:3857";
  var PUBLIC_CONFIG = (_a$2 = {},
      _a$2[PROJECTION_NAME] = WEB_MERCATOR_PROJECTION_NAME,
      Object.defineProperty(_a$2, "projection", {
          get: function () {
              // @ts-ignore
              return WGS84_PROJECTION_NAME ;
          },
          set: function (projection) {
              this[PROJECTION_NAME] = projection;
          },
          enumerable: false,
          configurable: true
      }),
      _a$2.dataProjection = WGS84_PROJECTION_NAME,
      _a$2.key = {
          tKey: "461d3e793f21ff8d082b522a788b4f8b"
      },
      _a$2.zoom = 3,
      _a$2);
  /**
   * 修改当前全局配置
   *
   * @param {object} [options] 全局配置
   */
  function set$2(options) {
      merge$2(PUBLIC_CONFIG, options);
  }
  /**
   * 获取当前全局配置
   */
  function get$5() {
      return JSON.parse(JSON.stringify(PUBLIC_CONFIG));
  }
  var DEFAULT_STYLE_ITEM = (_b$1 = {},
      _b$1[StyleItemType.IMAGE] = {
          entity: true,
          transparent: true
      },
      _b$1[StyleItemType.ICON] = {
          entity: true,
          positioning: Positioning.BOTTOM_CENTER,
          rotated: false
      },
      _b$1[StyleItemType.LABEL] = {
          entity: true,
          font: "10px sans-serif",
          showBackground: false,
          outlineWidth: 0,
          outlineColor: "rgba(255,255,255,1)",
          fillColor: "rgba(255,255,255,1)",
          backgroundColor: "rgba(255,255,255,1)",
          positioning: Positioning.CENTER_CENTER,
          style: 2,
          backgroundPadding: [0, 0],
          offset: [0, 0]
      },
      _b$1[StyleItemType.CIRCLE] = {
          entity: true,
          radius: 5,
          fillColor: "yellow",
          outlineColor: "red",
          outlineWidth: 1
      },
      _b$1[StyleItemType.COLOR] = {
          entity: true,
          width: 1,
          fillColor: "rgba(255,0,0,0.2)",
          borderColor: "rgba(255,0,0,0.8)"
      },
      _b$1[StyleItemType.RADIAL_GRADIENT] = {
          entity: true,
          width: 0,
          borderColor: "rgba(255,0,0,0.8)",
          get gradientStep() {
              return [
                  [0, "rgba(255,0,0,0)"],
                  [0.5, "rgba(255,0,0,0.5)"],
                  [1, "rgba(255,0,0,1)"]
              ];
          }
      },
      _b$1[StyleItemType.LINEAR_GRADIENT] = {
          entity: true,
          horizontalDirection: false,
          reverse: false,
          duration: 0,
          get stop() {
              return [
                  [0, "rgba(255,0,0,0)"],
                  [0.5, "rgba(255,0,0,0.5)"],
                  [1, "rgba(255,0,0,1)"]
              ];
          }
      },
      _b$1[StyleItemType.LINEAR_FOW] = {
          entity: true
      },
      _b$1[StyleItemType.WATER] = {
          isSurface: true,
          baseWaterColor: "rgba(51,76.5,153,1)",
          animationSpeed: 0.01,
          frequency: 1000.0,
          amplitude: 10,
          flat: false,
          normalMap: "data:image/png;base64,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"
      },
      _b$1[StyleItemType.MODEL] = {
          entity: true,
          orientation: [0, 0, 0]
      },
      _b$1[StyleItemType.RIPPLE] = {
          entity: true,
          duration: 3,
          color: "rgba(255,0,0,1)",
          image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAVFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////8wXzyWAAAAHHRSTlMABAgMSRgTEDYxHDsgQCQsKERMUFhkcFxUYGxoc2Qx5gAASRpJREFUeNrsnGtz2jAQReuWvps+DBQI//9/FldjX6+PVqtSZhKMrmknIaT9cM5eyebxpqWlpWX16S634ai4DUfLOjJi//vF+P30zSzmR+mvbvrVJsR9xVAfj39N4j9a02rhXqI59rhfp4JqoTXCa8wcusjfOKqDpsDryggmRv+25qiqg7Y9eA1JHIQ+5F4ZqkANWhG8eGaDXwZ/fQIR3rQzhRdLcYNfw/0djliEVgWvJNXsCTyO8YEatCZ48aD2S+wD7LEKWQtaE7xQNPox+xj8x+mITaixoJ0dILfG7ww+yHu86wIl6i1o+JEbDz8HH+yruH9AakygBjkH2obghvGv54fsgbw21AESoAnQA21DcGMFOPqEr6GPub9fxDeBdUALuqUC7cnEW84+m5/wOfYF4nF8DSiBiqD1wO3TOfQFn/QD8FeLUJBADlCC9hTitcMf0ufgR+S/hAk8gAWBA+21BNeHCz/g5we/Dvs3c+huX4WSBIEDrQb+Y/g5+0qZ/YL3PN+/FYJO8C1gEdCB9kLDKzwIZ5/0HfTiKvjfMxnuLqgACdQExR6QAm1XWPmyHh9/Ffw8eYH++b0meQ1cCdgDgwJtN/CvKdHn7As+2BvwYm/yQzcTiOBa4C4GcqBdG6hK6sY6/M7ogz24T+DdSI2FCbAgXwRhDbQK8EL8pC/8DnygJ/T66HehASSwDrAG2magSD7EH9In/Bz4z7XJigAJ6AB7YFKgbQbi4Sd+v/oBn+wL4D99/pRNwQRYQAmy+4HWAtdNP7f9Af0sewO9OpQha0HgQHk30N5thLU/GH7Qx+iDfRb81zAQIWsBioAOsAZaC2D6ve7n8JO+B5/oif1pOJS/3yMZDRwJ4ABqoLWAP/zh9Gv4ffqGfZa8gP96QnB/1gNjgeeAagAtQAUe98WknQzwpp/DT/qED/QGcVWeciL4EtAB1oDfAo/bAfHaz+H36GfZk/vm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"
      },
      _b$1[StyleItemType.ROTATE] = {
          entity: true,
          color: "rgba(255,255,255,1)",
          duration: 3,
          reverse: false
      },
      _b$1);
  var VECTOR_LAYER_STYLE = {
      get default() {
          return [
              {
                  type: StyleItemType.CIRCLE
              },
              {
                  type: StyleItemType.COLOR
              }
          ];
      }
  };
  var DEFAULT_ClUSTER_STYLE_ITEM = [
      {
          condition: function (feature) {
              return !feature.properties.cluster;
          },
          style: [
              {
                  type: StyleItemType.CIRCLE,
                  fillColor: "yellow",
                  outlineColor: "red",
                  outlineWidth: 1
              }
          ]
      },
      {
          condition: function (feature) {
              return feature.properties.cluster;
          },
          style: [
              {
                  type: StyleItemType.LABEL,
                  text: "{point_count}",
                  font: "bold 16px 微软雅黑",
                  eyeOffset: [0, 0, -5],
                  offset: [0, -25],
                  fillColor: "#fff",
                  scale: 0.8
              },
              {
                  type: StyleItemType.ICON,
                  image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAkFBMVEVHcEytj07QezOlklW8iEPEgzzChD6fmmCxjUvIgDm4ikXGgjupkVK5iUWmk1THgTqqkVHjaiahlV+vjk29h0Gfl1WqkFCnk1PpZCPqYSLMfjafm1yklVa0jEjKfzeklFW3ikbBhT66iUSnklTecCngbijWdy+pklPccivGgjvHgTq3ikbvUyPvVCLvViLuWSJVSoNWAAAALHRSTlMAZ+Y1scrHA37Wo9FUqETUWfsXdLkMX0z+/t4SIZLaLaHCrDz4+e5S9dDTn+/uy4kAAAHISURBVEjHnZaHcoMwDIYFYZhVssMIMzvB8P5vV9lpmpKFK90xzvDFkfg1AJ5tw4LKy5Mk96qAbUDBvtzwXDO/SG07LXxWn0P3awDRLC8b9ZdGmWdpH5CVZWr287KtmdbqDbJwnZm8WQf6Lu447+KdHqzl0sxxF6+YkWlMxc9eji3nvJGGN+2xFJtPDXP0zPgOExcjugE34zwyxBPm+I/M0hnjeTx5RK7YRD50ln3m4AhP5+0LRGLtXMTJOfT8kfvo/A0jNtPlXn/8WpjCn/1bRGJ74Zd5j2FpyH2ajyb3Mspf5YQY6/kAgxT6NQ1vmrLwmy7bYajF6M2sH72ZeJoMMkhN8EXzqkMhR0OBQcoQkpYeeTbYkRoU4aue8MrN8FBikHIBMjwgxA+2VYW2KIQQc/uEudA2itZippw2wGqAgKtCPACoGQRsWAx9WbAAKsySnTq0w8yrwCsA4kbZYoDCgzwF6NShDiDNIcEKwNUhjlUkoUGkv0cKhAj5Vj3kWxly0scVMrqoQxcpI5JgSalBS0JSupMKC62EkYolrSyTGgCt1Vybmv25qdkPTY3WPmmNmjYS3IeP8h/DB23MoQ1UxNGNOCSqjaPfoIkZyxIzEcUAAAAASUVORK5CYII="
              }
          ]
      }
  ];
  var CIRCLE_SEARCH_STYLE = {
      get linkedLine() {
          return [
              { type: StyleItemType.COLOR, width: 2, borderColor: "yellow", lineCap: "butt", entity: true, lineDash: [5] }
          ];
      },
      get centerPoint() {
          return [{ type: StyleItemType.CIRCLE, zIndex: 1 }];
      },
      get dragPoint() {
          return [{ type: StyleItemType.CIRCLE, zIndex: 1 }];
      },
      get circle() {
          return [
              {
                  type: StyleItemType.RADIAL_GRADIENT,
                  entity: true
              }
          ];
      }
  };
  var DRAW_STYLE = {
      get point() {
          return [
              {
                  type: StyleItemType.CIRCLE,
                  entity: true,
                  radius: 5,
                  fillColor: "yellow",
                  outlineColor: "red",
                  outlineWidth: 1
              }
          ];
      },
      get polyline() {
          return [
              {
                  type: StyleItemType.COLOR,
                  entity: true,
                  width: 2,
                  lineCap: "butt",
                  lineDash: [5],
                  borderColor: "rgba(255,0,0,1)"
              }
          ];
      },
      get polygon() {
          return [
              {
                  type: StyleItemType.COLOR,
                  entity: true,
                  width: 4,
                  fillColor: "rgba(255,0,0,0.2)",
                  borderColor: "rgba(255,0,0,0.8)",
                  lineCap: "butt",
                  lineDash: [5]
              }
          ];
      }
  };
  var Measure_STYLE = {
      draw: [
          {
              type: StyleItemType.CIRCLE,
              fillColor: "rgba(255, 255, 255, 0.8)",
              strokeColor: "rgba(255, 0, 0, 1)",
              radius: 4,
              entity: true
          },
          {
              type: StyleItemType.COLOR,
              width: 4,
              borderColor: "rgba(255,0,0,0.5)",
              entity: true,
              lineCap: "butt",
              lineDash: [5]
          },
          {
              width: 4,
              borderColor: "rgba(255,0,0,0.5)",
              lineCap: "butt",
              lineDash: [5],
              type: StyleItemType.COLOR,
              fillColor: "rgba(255,0,0,0.3)",
              entity: true
          }
      ],
      finsh: [
          {
              type: StyleItemType.CIRCLE,
              fillColor: "rgba(255, 255, 255, 0.8)",
              strokeColor: "rgba(255, 0, 0, 1)",
              radius: 4
          },
          {
              type: StyleItemType.COLOR,
              borderColor: "rgba(255,0,0,0.5)",
              width: 4,
              entity: true
          },
          {
              type: StyleItemType.COLOR,
              fillColor: "rgba(255,0,0,0.2)",
              entity: true,
              width: 4
          }
      ]
  };
  [
      {
          type: StyleItemType.CIRCLE,
          fillColor: "red",
          strokeColor: "red",
          radius: 5,
          entity: true
      },
      {
          type: StyleItemType.LABEL,
          // text: "点击插入节点，拖拽编辑节点",
          font: "bold 16px 微软雅黑",
          pixelOffset: [-14, 0],
          eyeOffset: [0, 0, -5],
          offset: [0, -40],
          fillColor: "#fff",
          scale: 0.8
      },
      {
          type: StyleItemType.COLOR,
          width: 4,
          borderColor: "rgba(255,0,0,0.5)",
          material: "rgba(255,0,0,0.5)",
          entity: true
      },
      {
          type: StyleItemType.COLOR,
          fillColor: "rgba(255,0,0,0.3)",
          material: "rgba(255,0,0,0.3)",
          entity: true
      }
  ];
  var AREA_STYLE = {
      get outlineStyle() {
          return [
              {
                  type: StyleItemType.POLYLINE_GLOW,
                  color: "rgb(255,0,0)",
                  width: 10,
                  glowPower: 0.1
              }
          ];
      },
      get contentStyle() {
          return [
              {
                  type: StyleItemType.COLOR,
                  fillColor: "rgba(0,255,255,0.1)",
                  extrudedHeight: 5000
              }
          ];
      },
      get contentOutlineStyle() {
          return [
              {
                  type: StyleItemType.COLOR,
                  borderColor: "rgba(0,255,255,1)",
                  width: 2
              }
          ];
      },
      get contentLabelStyle() {
          return [
              {
                  type: StyleItemType.LABEL,
                  text: "{name}",
                  font: "bold 10px serif"
              }
          ];
      }
  };

  var index$7 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get: get$5,
    set: set$2
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics$1(d, b);
  };

  function __extends$3(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics$1(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign$1.apply(this, arguments);
  };

  function __awaiter$8(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator$1(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray$1(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  function globals(defs) {
    defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
  }

  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_GRIDSHIFT = 3;
  var PJD_WGS84 = 4; // WGS84 or equivalent
  var PJD_NODATUM = 5; // WGS84 or equivalent
  var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
  var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
  var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
  var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
  var HALF_PI = Math.PI/2;
  // ellipoid pj_set_ell.c
  var SIXTH = 0.1666666666666666667;
  /* 1/6 */
  var RA4 = 0.04722222222222222222;
  /* 17/360 */
  var RA6 = 0.02215608465608465608;
  var EPSLN = 1.0e-10;
  // you'd think you could use Number.EPSILON above but that makes
  // Mollweide get into an infinate loop.

  var D2R$1 = 0.01745329251994329577;
  var R2D = 57.29577951308232088;
  var FORTPI = Math.PI/4;
  var TWO_PI = Math.PI * 2;
  // SPI is slightly greater than Math.PI, so values that exceed the -180..180
  // degree range by a tiny amount don't get wrapped. This prevents points that
  // have drifted from their original location along the 180th meridian (due to
  // floating point error) from changing their sign.
  var SPI = 3.14159265359;

  var exports$3 = {};

  exports$3.greenwich = 0.0; //"0dE",
  exports$3.lisbon = -9.131906111111; //"9d07'54.862\"W",
  exports$3.paris = 2.337229166667; //"2d20'14.025\"E",
  exports$3.bogota = -74.080916666667; //"74d04'51.3\"W",
  exports$3.madrid = -3.687938888889; //"3d41'16.58\"W",
  exports$3.rome = 12.452333333333; //"12d27'8.4\"E",
  exports$3.bern = 7.439583333333; //"7d26'22.5\"E",
  exports$3.jakarta = 106.807719444444; //"106d48'27.79\"E",
  exports$3.ferro = -17.666666666667; //"17d40'W",
  exports$3.brussels = 4.367975; //"4d22'4.71\"E",
  exports$3.stockholm = 18.058277777778; //"18d3'29.8\"E",
  exports$3.athens = 23.7163375; //"23d42'58.815\"E",
  exports$3.oslo = 10.722916666667; //"10d43'22.5\"E"

  var units = {
    ft: {to_meter: 0.3048},
    'us-ft': {to_meter: 1200 / 3937}
  };

  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match$1(obj, key) {
    if (obj[key]) {
      return obj[key];
    }
    var keys = Object.keys(obj);
    var lkey = key.toLowerCase().replace(ignoredChar, '');
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, '');
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }

  function projStr(defData) {
    var self = {};
    var paramObj = defData.split('+').map(function(v) {
      return v.trim();
    }).filter(function(a) {
      return a;
    }).reduce(function(p, a) {
      var split = a.split('=');
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
      proj: 'projName',
      datum: 'datumCode',
      rf: function(v) {
        self.rf = parseFloat(v);
      },
      lat_0: function(v) {
        self.lat0 = v * D2R$1;
      },
      lat_1: function(v) {
        self.lat1 = v * D2R$1;
      },
      lat_2: function(v) {
        self.lat2 = v * D2R$1;
      },
      lat_ts: function(v) {
        self.lat_ts = v * D2R$1;
      },
      lon_0: function(v) {
        self.long0 = v * D2R$1;
      },
      lon_1: function(v) {
        self.long1 = v * D2R$1;
      },
      lon_2: function(v) {
        self.long2 = v * D2R$1;
      },
      alpha: function(v) {
        self.alpha = parseFloat(v) * D2R$1;
      },
      gamma: function(v) {
        self.rectified_grid_angle = parseFloat(v);
      },
      lonc: function(v) {
        self.longc = v * D2R$1;
      },
      x_0: function(v) {
        self.x0 = parseFloat(v);
      },
      y_0: function(v) {
        self.y0 = parseFloat(v);
      },
      k_0: function(v) {
        self.k0 = parseFloat(v);
      },
      k: function(v) {
        self.k0 = parseFloat(v);
      },
      a: function(v) {
        self.a = parseFloat(v);
      },
      b: function(v) {
        self.b = parseFloat(v);
      },
      r_a: function() {
        self.R_A = true;
      },
      zone: function(v) {
        self.zone = parseInt(v, 10);
      },
      south: function() {
        self.utmSouth = true;
      },
      towgs84: function(v) {
        self.datum_params = v.split(",").map(function(a) {
          return parseFloat(a);
        });
      },
      to_meter: function(v) {
        self.to_meter = parseFloat(v);
      },
      units: function(v) {
        self.units = v;
        var unit = match$1(units, v);
        if (unit) {
          self.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function(v) {
        self.from_greenwich = v * D2R$1;
      },
      pm: function(v) {
        var pm = match$1(exports$3, v);
        self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$1;
      },
      nadgrids: function(v) {
        if (v === '@null') {
          self.datumCode = 'none';
        }
        else {
          self.nadgrids = v;
        }
      },
      axis: function(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self.axis = v;
        }
      },
      approx: function() {
        self.approx = true;
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params) {
        paramOutname = params[paramName];
        if (typeof paramOutname === 'function') {
          paramOutname(paramVal);
        }
        else {
          self[paramOutname] = paramVal;
        }
      }
      else {
        self[paramName] = paramVal;
      }
    }
    if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
      self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
  }

  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace$1 = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84_]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  // const ignoredChar = /[\s_\-\/\(\)]/g;
  function Parser$2(text) {
    if (typeof text !== 'string') {
      throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser$2.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace$1.test(char)) {
        if (this.place >= this.text.length) {
          return;
        }
        char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(char);
      case KEYWORD:
        return this.keyword(char)
      case QUOTED:
        return this.quoted(char);
      case AFTERQUOTE:
        return this.afterquote(char);
      case NUMBER:
        return this.number(char);
      case ENDED:
        return;
    }
  };
  Parser$2.prototype.afterquote = function(char) {
    if (char === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(char)) {
      this.word = this.word.trim();
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
  };
  Parser$2.prototype.afterItem = function(char) {
    if (char === ',') {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (char === ']') {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }

      return;
    }
  };
  Parser$2.prototype.number = function(char) {
    if (digets.test(char)) {
      this.word += char;
      return;
    }
    if (endThings.test(char)) {
      this.word = parseFloat(this.word);
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
  };
  Parser$2.prototype.quoted = function(char) {
    if (char === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += char;
    return;
  };
  Parser$2.prototype.keyword = function(char) {
    if (keyword.test(char)) {
      this.word += char;
      return;
    }
    if (char === '[') {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
  };
  Parser$2.prototype.neutral = function(char) {
    if (latin.test(char)) {
      this.word = char;
      this.state = KEYWORD;
      return;
    }
    if (char === '"') {
      this.word = '';
      this.state = QUOTED;
      return;
    }
    if (digets.test(char)) {
      this.word = char;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
  };
  Parser$2.prototype.output = function() {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
  };

  function parseString(txt) {
    var parser = new Parser$2(txt);
    return parser.output();
  }

  function mapit(obj, key, value) {
    if (Array.isArray(key)) {
      value.unshift(key);
      key = null;
    }
    var thing = key ? {} : obj;

    var out = value.reduce(function(newObj, item) {
      sExpr(item, newObj);
      return newObj
    }, thing);
    if (key) {
      obj[key] = out;
    }
  }

  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
        return;
      }
      obj[key] = v[0];
      return;
    }
    if (!v.length) {
      obj[key] = true;
      return;
    }
    if (key === 'TOWGS84') {
      obj[key] = v;
      return;
    }
    if (key === 'AXIS') {
      if (!(key in obj)) {
        obj[key] = [];
      }
      obj[key].push(v);
      return;
    }
    if (!Array.isArray(key)) {
      obj[key] = {};
    }

    var i;
    switch (key) {
      case 'UNIT':
      case 'PRIMEM':
      case 'VERT_DATUM':
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key]);
        }
        return;
      case 'SPHEROID':
      case 'ELLIPSOID':
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key]);
        }
        return;
      case 'PROJECTEDCRS':
      case 'PROJCRS':
      case 'GEOGCS':
      case 'GEOCCS':
      case 'PROJCS':
      case 'LOCAL_CS':
      case 'GEODCRS':
      case 'GEODETICCRS':
      case 'GEODETICDATUM':
      case 'EDATUM':
      case 'ENGINEERINGDATUM':
      case 'VERT_CS':
      case 'VERTCRS':
      case 'VERTICALCRS':
      case 'COMPD_CS':
      case 'COMPOUNDCRS':
      case 'ENGINEERINGCRS':
      case 'ENGCRS':
      case 'FITTED_CS':
      case 'LOCAL_DATUM':
      case 'DATUM':
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key]);
          }
        }
        return mapit(obj, key, v);
    }
  }

  var D2R = 0.01745329251994329577;



  function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && (inName in obj)) {
      obj[outName] = obj[inName];
      if (params.length === 3) {
        obj[outName] = params[2](obj[outName]);
      }
    }
  }

  function d2r(input) {
    return input * D2R;
  }

  function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
      wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
      wkt.projName = 'identity';
      wkt.local = true;
    } else {
      if (typeof wkt.PROJECTION === 'object') {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = '';
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
        if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
          axisOrder += 'n';
        } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
          axisOrder += 's';
        } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
          axisOrder += 'e';
        } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
          axisOrder += 'w';
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += 'u';
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === 'metre') {
        wkt.units = 'meter';
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === 'GEOGCS') {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
      geogcs = wkt;
    }
    if (geogcs) {
      //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
      //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
      //}
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === 'd_') {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
        wkt.datumCode = 'nzgd49';
      }
      if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
        if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
          wkt.sphere = true;
        }
        wkt.datumCode = 'wgs84';
      }
      if (wkt.datumCode.slice(-6) === '_ferro') {
        wkt.datumCode = wkt.datumCode.slice(0, - 6);
      }
      if (wkt.datumCode.slice(-8) === '_jakarta') {
        wkt.datumCode = wkt.datumCode.slice(0, - 8);
      }
      if (~wkt.datumCode.indexOf('belge')) {
        wkt.datumCode = 'rnb72';
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
        if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
          wkt.ellps = 'intl';
        }

        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }

      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf('osgb_1936')) {
        wkt.datumCode = 'osgb36';
      }
      if (~wkt.datumCode.indexOf('osni_1952')) {
        wkt.datumCode = 'osni52';
      }
      if (~wkt.datumCode.indexOf('tm65')
        || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
        wkt.datumCode = 'ire65';
      }
      if (wkt.datumCode === 'ch1903+') {
        wkt.datumCode = 'ch1903';
      }
      if (~wkt.datumCode.indexOf('israel')) {
        wkt.datumCode = 'isr93';
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }

    function toMeter(input) {
      var ratio = wkt.to_meter || 1;
      return input * ratio;
    }
    var renamer = function(a) {
      return rename(wkt, a);
    };
    var list = [
      ['standard_parallel_1', 'Standard_Parallel_1'],
      ['standard_parallel_1', 'Latitude of 1st standard parallel'],
      ['standard_parallel_2', 'Standard_Parallel_2'],
      ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
      ['false_easting', 'False_Easting'],
      ['false_easting', 'False easting'],
      ['false-easting', 'Easting at false origin'],
      ['false_northing', 'False_Northing'],
      ['false_northing', 'False northing'],
      ['false_northing', 'Northing at false origin'],
      ['central_meridian', 'Central_Meridian'],
      ['central_meridian', 'Longitude of natural origin'],
      ['central_meridian', 'Longitude of false origin'],
      ['latitude_of_origin', 'Latitude_Of_Origin'],
      ['latitude_of_origin', 'Central_Parallel'],
      ['latitude_of_origin', 'Latitude of natural origin'],
      ['latitude_of_origin', 'Latitude of false origin'],
      ['scale_factor', 'Scale_Factor'],
      ['k0', 'scale_factor'],
      ['latitude_of_center', 'Latitude_Of_Center'],
      ['latitude_of_center', 'Latitude_of_center'],
      ['lat0', 'latitude_of_center', d2r],
      ['longitude_of_center', 'Longitude_Of_Center'],
      ['longitude_of_center', 'Longitude_of_center'],
      ['longc', 'longitude_of_center', d2r],
      ['x0', 'false_easting', toMeter],
      ['y0', 'false_northing', toMeter],
      ['long0', 'central_meridian', d2r],
      ['lat0', 'latitude_of_origin', d2r],
      ['lat0', 'standard_parallel_1', d2r],
      ['lat1', 'standard_parallel_1', d2r],
      ['lat2', 'standard_parallel_2', d2r],
      ['azimuth', 'Azimuth'],
      ['alpha', 'azimuth', d2r],
      ['srsCode', 'name']
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  function wkt(wkt) {
    var lisp = parseString(wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift(['name', name]);
    lisp.unshift(['type', type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  }

  function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === 'string') {
        if (def.charAt(0) === '+') {
          defs[name] = projStr(arguments[1]);
        }
        else {
          defs[name] = wkt(arguments[1]);
        }
      } else {
        defs[name] = def;
      }
    }
    else if (arguments.length === 1) {
      if (Array.isArray(name)) {
        return name.map(function(v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          }
          else {
            defs(v);
          }
        });
      }
      else if (typeof name === 'string') {
        if (name in defs) {
          return defs[name];
        }
      }
      else if ('EPSG' in name) {
        defs['EPSG:' + name.EPSG] = name;
      }
      else if ('ESRI' in name) {
        defs['ESRI:' + name.ESRI] = name;
      }
      else if ('IAU2000' in name) {
        defs['IAU2000:' + name.IAU2000] = name;
      }
      else {
        console.log(name);
      }
      return;
    }


  }
  globals(defs);

  function testObj(code){
    return typeof code === 'string';
  }
  function testDef(code){
    return code in defs;
  }
  var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
  function testWKT(code){
    return codeWords.some(function (word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ['3857', '900913', '3785', '102113'];
  function checkMercator(item) {
    var auth = match$1(item, 'authority');
    if (!auth) {
      return;
    }
    var code = match$1(auth, 'epsg');
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match$1(item, 'extension');
    if (!ext) {
      return;
    }
    return match$1(ext, 'proj4');
  }
  function testProj(code){
    return code[0] === '+';
  }
  function parse$3(code){
    if (testObj(code)) {
      //check to see if this is a WKT string
      if (testDef(code)) {
        return defs[code];
      }
      if (testWKT(code)) {
        var out = wkt(code);
        // test of spetial case, due to this being a very common and often malformed
        if (checkMercator(out)) {
          return defs['EPSG:3857'];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return projStr(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return projStr(code);
      }
    }else {
      return code;
    }
  }

  function extend$1(destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
      return destination;
    }
    for (property in source) {
      value = source[property];
      if (value !== undefined) {
        destination[property] = value;
      }
    }
    return destination;
  }

  function msfnz(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / (Math.sqrt(1 - con * con));
  }

  function sign(x) {
    return x<0 ? -1 : 1;
  }

  function adjust_lon(x) {
    return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
  }

  function tsfnz(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow(((1 - con) / (1 + con)), com);
    return (Math.tan(0.5 * (HALF_PI - phi)) / con);
  }

  function phi2z(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
  }

  function init$u() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if(!('x0' in this)){
      this.x0 = 0;
    }
    if(!('y0' in this)){
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      }
      else {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }
    else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        }
        else {
          this.k0 = 1;
        }
      }
    }
  }

  /* Mercator forward equations--mapping lat,long to x,y
    --------------------------------------------------*/

  function forward$t(p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
      return null;
    }

    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    }
    else {
      if (this.sphere) {
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      }
      else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz(this.e, lat, sinphi);
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x;
      p.y = y;
      return p;
    }
  }

  /* Mercator inverse equations--mapping x,y to lat/long
    --------------------------------------------------*/
  function inverse$t(p) {

    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;

    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    }
    else {
      var ts = Math.exp(-y / (this.a * this.k0));
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$v = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc = {
    init: init$u,
    forward: forward$t,
    inverse: inverse$t,
    names: names$v
  };

  function init$t() {
    //no-op for longlat
  }

  function identity$1(pt) {
    return pt;
  }
  var names$u = ["longlat", "identity"];
  var longlat = {
    init: init$t,
    forward: identity$1,
    inverse: identity$1,
    names: names$u
  };

  var projs = [merc, longlat];
  var names$t = {};
  var projStore = [];

  function add$2(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function(n) {
      names$t[n.toLowerCase()] = len;
    });
    return this;
  }

  function get$4(name) {
    if (!name) {
      return false;
    }
    var n = name.toLowerCase();
    if (typeof names$t[n] !== 'undefined' && projStore[names$t[n]]) {
      return projStore[names$t[n]];
    }
  }

  function start() {
    projs.forEach(add$2);
  }
  var projections = {
    start: start,
    add: add$2,
    get: get$4
  };

  var exports$2 = {};
  exports$2.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };

  exports$2.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };

  exports$2.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };

  exports$2.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };

  exports$2.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
  };

  exports$2.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };

  exports$2.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };

  exports$2.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
  };

  exports$2.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };

  exports$2.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };

  exports$2.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
  };

  exports$2.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };

  exports$2.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };

  exports$2.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
  };

  exports$2.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };

  exports$2.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };

  exports$2.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };

  exports$2.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };

  exports$2.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };

  exports$2.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };

  exports$2.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };

  exports$2.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };

  exports$2.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };

  exports$2.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };

  exports$2.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };

  exports$2.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };

  exports$2.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };

  exports$2.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };

  exports$2.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
  };

  exports$2.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
  };

  exports$2.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };

  exports$2.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };

  exports$2.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
  };

  exports$2.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
  };

  exports$2.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
  };

  exports$2.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };

  exports$2.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
  };

  exports$2.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
  };

  exports$2.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
  };

  exports$2.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
  };

  exports$2.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
  };

  var WGS84 = exports$2.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };

  exports$2.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
  };

  function eccentricity(a, b, rf, R_A) {
    var a2 = a * a; // used in geocentric
    var b2 = b * b; // used in geocentric
    var es = (a2 - b2) / a2; // e ^ 2
    var e = 0;
    if (R_A) {
      a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a2 = a * a;
      es = 0;
    } else {
      e = Math.sqrt(es); // eccentricity
    }
    var ep2 = (a2 - b2) / b2; // used in geocentric
    return {
      es: es,
      e: e,
      ep2: ep2
    };
  }
  function sphere(a, b, rf, ellps, sphere) {
    if (!a) { // do we have an ellipsoid?
      var ellipse = match$1(exports$2, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }

    if (rf && !b) {
      b = (1.0 - 1.0 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
      sphere = true;
      b = a;
    }
    return {
      a: a,
      b: b,
      rf: rf,
      sphere: sphere
    };
  }

  var exports$1 = {};
  exports$1.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };

  exports$1.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };

  exports$1.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };

  exports$1.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };

  exports$1.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };

  exports$1.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };

  exports$1.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };

  exports$1.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };

  exports$1.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };

  exports$1.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };

  exports$1.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };

  exports$1.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };

  exports$1.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };

  exports$1.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  };

  exports$1.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  };

  exports$1.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  };

  exports$1.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };

  function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
    var out = {};

    if (datumCode === undefined || datumCode === 'none') {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }

    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
        }
      }
    }

    if (nadgrids) {
      out.datum_type = PJD_GRIDSHIFT;
      out.grids = nadgrids;
    }
    out.a = a; //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }

  /**
   * Resources for details of NTv2 file formats:
   * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
   * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
   */

  var loadedNadgrids = {};

  /**
   * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
   * as an ArrayBuffer.
   */
  function nadgrid(key, data) {
    var view = new DataView(data);
    var isLittleEndian = detectLittleEndian(view);
    var header = readHeader(view, isLittleEndian);
    if (header.nSubgrids > 1) {
      console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
    }
    var subgrids = readSubgrids(view, header, isLittleEndian);
    var nadgrid = {header: header, subgrids: subgrids};
    loadedNadgrids[key] = nadgrid;
    return nadgrid;
  }

  /**
   * Given a proj4 value for nadgrids, return an array of loaded grids
   */
  function getNadgrids(nadgrids) {
    // Format details: http://proj.maptools.org/gen_parms.html
    if (nadgrids === undefined) { return null; }
    var grids = nadgrids.split(',');
    return grids.map(parseNadgridString);
  }

  function parseNadgridString(value) {
    if (value.length === 0) {
      return null;
    }
    var optional = value[0] === '@';
    if (optional) {
      value = value.slice(1);
    }
    if (value === 'null') {
      return {name: 'null', mandatory: !optional, grid: null, isNull: true};
    }
    return {
      name: value,
      mandatory: !optional,
      grid: loadedNadgrids[value] || null,
      isNull: false
    };
  }

  function secondsToRadians(seconds) {
    return (seconds / 3600) * Math.PI / 180;
  }

  function detectLittleEndian(view) {
    var nFields = view.getInt32(8, false);
    if (nFields === 11) {
      return false;
    }
    nFields = view.getInt32(8, true);
    if (nFields !== 11) {
      console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
    }
    return true;
  }

  function readHeader(view, isLittleEndian) {
    return {
      nFields: view.getInt32(8, isLittleEndian),
      nSubgridFields: view.getInt32(24, isLittleEndian),
      nSubgrids: view.getInt32(40, isLittleEndian),
      shiftType: decodeString(view, 56, 56 + 8).trim(),
      fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
      fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
      toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
      toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
    };
  }

  function decodeString(view, start, end) {
    return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
  }

  function readSubgrids(view, header, isLittleEndian) {
    var gridOffset = 176;
    var grids = [];
    for (var i = 0; i < header.nSubgrids; i++) {
      var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
      var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
      var lngColumnCount = Math.round(
        1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
      var latColumnCount = Math.round(
        1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
      // Proj4 operates on radians whereas the coordinates are in seconds in the grid
      grids.push({
        ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
        del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
        lim: [lngColumnCount, latColumnCount],
        count: subHeader.gridNodeCount,
        cvs: mapNodes(nodes)
      });
    }
    return grids;
  }

  function mapNodes(nodes) {
    return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
  }

  function readGridHeader(view, offset, isLittleEndian) {
    return {
      name: decodeString(view, offset + 8, offset + 16).trim(),
      parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
      lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
      upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
      lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
      upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
      latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
      longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
      gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
    };
  }

  function readGridNodes(view, offset, gridHeader, isLittleEndian) {
    var nodesOffset = offset + 176;
    var gridRecordLength = 16;
    var gridShiftRecords = [];
    for (var i = 0; i < gridHeader.gridNodeCount; i++) {
      var record = {
        latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
        longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
        latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
        longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
      };
      gridShiftRecords.push(record);
    }
    return gridShiftRecords;
  }

  function Projection$2(srsCode,callback) {
    if (!(this instanceof Projection$2)) {
      return new Projection$2(srsCode);
    }
    callback = callback || function(error){
      if(error){
        throw error;
      }
    };
    var json = parse$3(srsCode);
    if(typeof json !== 'object'){
      callback(srsCode);
      return;
    }
    var ourProj = Projection$2.projections.get(json.projName);
    if(!ourProj){
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
      var datumDef = match$1(exports$1, json.datumCode);
      if (datumDef) {
        json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1.0;
    json.axis = json.axis || 'enu';
    json.ellps = json.ellps || 'wgs84';
    json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var nadgrids = getNadgrids(json.nadgrids);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
      nadgrids);

    extend$1(this, json); // transfer everything over from the projection because we don't know what we'll need
    extend$1(this, ourProj); // transfer all the methods from the projection

    // copy the 4 things over we calulated in deriveConstants.sphere
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;

    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;

    // add in the datum object
    this.datum = datumObj;

    // init the projection
    this.init();

    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);

  }
  Projection$2.projections = projections;
  Projection$2.projections.start();

  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
      // the tolerance for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
    } else if (source.datum_type === PJD_7PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
    } else {
      return true; // datums are equal
    }
  } // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  function geodeticToGeocentric(p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return { x: -Infinity, y: -Infinity, z: p.z };
    } else if (Latitude > HALF_PI) {
      /* Latitude out of range */
      return { x: Infinity, y: Infinity, z: p.z };
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: ((Rn * (1 - es)) + Height) * Sin_Lat
    };
  } // cs_geodetic_to_geocentric()

  function geocentricToGeodetic(p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / a < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
    CPHI0 = ST * (1.0 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

      RK = es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  } // cs_geocentric_to_geodetic()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)


  /** point object, nothing fancy, just allows values to be
      passed back and forth by reference rather than by value.
      Other point classes may be used as long as they have
      x and y properties, which will get modified in the transform method.
  */
  function geocentricToWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2],
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  } // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  function geocentricFromWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2],
      };

    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    } //cs_geocentric_from_wgs84()
  }

  function checkParams(type) {
    return (type === PJD_3PARAM || type === PJD_7PARAM);
  }

  function datum_transform(source, dest, point) {
    // Short cut if the datums are identical.
    if (compareDatums(source, dest)) {
      return point; // in this case, zero is sucess,
      // whereas cs_compare_datums returns 1 to indicate TRUE
      // confusing, should fix this
    }

    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point;
    }

    // If this datum requires grid shifts, then apply it to geodetic coordinates.
    var source_a = source.a;
    var source_es = source.es;
    if (source.datum_type === PJD_GRIDSHIFT) {
      var gridShiftCode = applyGridShift(source, false, point);
      if (gridShiftCode !== 0) {
        return undefined;
      }
      source_a = SRS_WGS84_SEMIMAJOR;
      source_es = SRS_WGS84_ESQUARED;
    }

    var dest_a = dest.a;
    var dest_b = dest.b;
    var dest_es = dest.es;
    if (dest.datum_type === PJD_GRIDSHIFT) {
      dest_a = SRS_WGS84_SEMIMAJOR;
      dest_b = SRS_WGS84_SEMIMINOR;
      dest_es = SRS_WGS84_ESQUARED;
    }

    // Do we need to go through geocentric coordinates?
    if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
      return point;
    }

    // Convert to geocentric coordinates.
    point = geodeticToGeocentric(point, source_es, source_a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
      point = geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

    if (dest.datum_type === PJD_GRIDSHIFT) {
      var destGridShiftResult = applyGridShift(dest, true, point);
      if (destGridShiftResult !== 0) {
        return undefined;
      }
    }

    return point;
  }

  function applyGridShift(source, inverse, point) {
    if (source.grids === null || source.grids.length === 0) {
      console.log('Grid shift grids not found');
      return -1;
    }
    var input = {x: -point.x, y: point.y};
    var output = {x: Number.NaN, y: Number.NaN};
    var attemptedGrids = [];
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrid = grid.grid.subgrids[0];
      // skip tables that don't match our point at all
      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
      var minX = subgrid.ll[0] - epsilon;
      var minY = subgrid.ll[1] - epsilon;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
        continue;
      }
      output = applySubgridShift(input, inverse, subgrid);
      if (!isNaN(output.x)) {
        break;
      }
    }
    if (isNaN(output.x)) {
      console.log("Failed to find a grid shift table for location '"+
        -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
      return -1;
    }
    point.x = -output.x;
    point.y = output.y;
    return 0;
  }

  function applySubgridShift(pin, inverse, ct) {
    var val = {x: Number.NaN, y: Number.NaN};
    if (isNaN(pin.x)) { return val; }
    var tb = {x: pin.x, y: pin.y};
    tb.x -= ct.ll[0];
    tb.y -= ct.ll[1];
    tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
    var t = nadInterpolate(tb, ct);
    if (inverse) {
      if (isNaN(t.x)) {
        return val;
      }
      t.x = tb.x - t.x;
      t.y = tb.y - t.y;
      var i = 9, tol = 1e-12;
      var dif, del;
      do {
        del = nadInterpolate(t, ct);
        if (isNaN(del.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
        t.x += dif.x;
        t.y += dif.y;
      } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
      if (i < 0) {
        console.log("Inverse grid shift iterator failed to converge.");
        return val;
      }
      val.x = adjust_lon(t.x + ct.ll[0]);
      val.y = t.y + ct.ll[1];
    } else {
      if (!isNaN(t.x)) {
        val.x = pin.x + t.x;
        val.y = pin.y + t.y;
      }
    }
    return val;
  }

  function nadInterpolate(pin, ct) {
    var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
    var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
    var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
    var val= {x: Number.NaN, y: Number.NaN};
    var inx;
    if (indx.x < 0 || indx.x >= ct.lim[0]) {
      return val;
    }
    if (indx.y < 0 || indx.y >= ct.lim[1]) {
      return val;
    }
    inx = (indx.y * ct.lim[0]) + indx.x;
    var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx++;
    var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx += ct.lim[0];
    var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx--;
    var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
      m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
    val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
    val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
    return val;
  }

  function adjust_axis(crs, denorm, point) {
    var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point.z === undefined) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = 'x';
        } else {
          t = 'y';
        }

      }
      else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = 'y';
        } else {
          t = 'x';
        }
      }
      else {
        v = zin;
        t = 'z';
      }
      switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;
      case 'w':
        out[t] = -v;
        break;
      case 'n':
        out[t] = v;
        break;
      case 's':
        out[t] = -v;
        break;
      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }
        break;
      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }
        break;
      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
      }
    }
    return out;
  }

  function common (array){
    var out = {
      x: array[0],
      y: array[1]
    };
    if (array.length>2) {
      out.z = array[2];
    }
    if (array.length>3) {
      out.m = array[3];
    }
    return out;
  }

  function checkSanity (point) {
    checkCoord(point.x);
    checkCoord(point.y);
  }
  function checkCoord(num) {
    if (typeof Number.isFinite === 'function') {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError('coordinates must be finite numbers');
    }
    if (typeof num !== 'number' || num !== num || !isFinite(num)) {
      throw new TypeError('coordinates must be finite numbers');
    }
  }

  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
  }

  function transform$5(source, dest, point, enforceAxis) {
    var wgs84;
    if (Array.isArray(point)) {
      point = common(point);
    }
    checkSanity(point);
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs84 = new Projection$2('WGS84');
      point = transform$5(source, wgs84, point, enforceAxis);
      source = wgs84;
    }
    // DGR, 2010/11/12
    if (enforceAxis && source.axis !== 'enu') {
      point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
      point = {
        x: point.x * D2R$1,
        y: point.y * D2R$1,
        z: point.z || 0
      };
    } else {
      if (source.to_meter) {
        point = {
          x: point.x * source.to_meter,
          y: point.y * source.to_meter,
          z: point.z || 0
        };
      }
      point = source.inverse(point); // Convert Cartesian to longlat
      if (!point) {
        return;
      }
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
      point.x += source.from_greenwich;
    }

    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);
    if (!point) {
      return;
    }

    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
      point = {
        x: point.x - dest.from_greenwich,
        y: point.y,
        z: point.z || 0
      };
    }

    if (dest.projName === 'longlat') {
      // convert radians to decimal degrees
      point = {
        x: point.x * R2D,
        y: point.y * R2D,
        z: point.z || 0
      };
    } else { // else project
      point = dest.forward(point);
      if (dest.to_meter) {
        point = {
          x: point.x / dest.to_meter,
          y: point.y / dest.to_meter,
          z: point.z || 0
        };
      }
    }

    // DGR, 2010/11/12
    if (enforceAxis && dest.axis !== 'enu') {
      return adjust_axis(dest, true, point);
    }

    return point;
  }

  var wgs84 = Projection$2('WGS84');

  function transformer(from, to, coords, enforceAxis) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform$5(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
      if (coords.length > 2) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (typeof transformedArray.z === 'number') {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform$5(from, to, coords, enforceAxis);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function (key) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (key === 'x' || key === 'y' || key === 'z') {
            return;
          }
        } else {
          if (key === 'x' || key === 'y') {
            return;
          }
        }
        out[key] = coords[key];
      });
      return out;
    }
  }

  function checkProj(item) {
    if (item instanceof Projection$2) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Projection$2(item);
  }

  function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function (coords, enforceAxis) {
          return transformer(fromProj, toProj, coords, enforceAxis);
        },
        inverse: function (coords, enforceAxis) {
          return transformer(toProj, fromProj, coords, enforceAxis);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }

  /**
   * UTM zones are grouped, and assigned to one of a group of 6
   * sets.
   *
   * {int} @private
   */
  var NUM_100K_SETS = 6;

  /**
   * The column letters (for easting) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

  /**
   * The row letters (for northing) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

  var A$2 = 65; // A
  var I$1 = 73; // I
  var O$2 = 79; // O
  var V$2 = 86; // V
  var Z$2 = 90; // Z
  var mgrs = {
    forward: forward$s,
    inverse: inverse$s,
    toPoint: toPoint
  };
  /**
   * Conversion of lat/lon to MGRS.
   *
   * @param {object} ll Object literal with lat and lon properties on a
   *     WGS84 ellipsoid.
   * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
   *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
   * @return {string} the MGRS string for the given location and accuracy.
   */
  function forward$s(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode$2(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }
  /**
   * Conversion of MGRS to lat/lon.
   *
   * @param {string} mgrs MGRS string.
   * @return {array} An array with left (longitude), bottom (latitude), right
   *     (longitude) and top (latitude) values in WGS84, representing the
   *     bounding box for the provided MGRS reference.
   */
  function inverse$s(mgrs) {
    var bbox = UTMtoLL(decode$4(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
    }
    return [bbox.left, bbox.bottom, bbox.right, bbox.top];
  }
  function toPoint(mgrs) {
    var bbox = UTMtoLL(decode$4(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat];
    }
    return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
  }/**
   * Conversion from degrees to radians.
   *
   * @private
   * @param {number} deg the angle in degrees.
   * @return {number} the angle in radians.
   */
  function degToRad(deg) {
    return (deg * (Math.PI / 180.0));
  }

  /**
   * Conversion from radians to degrees.
   *
   * @private
   * @param {number} rad the angle in radians.
   * @return {number} the angle in degrees.
   */
  function radToDeg(rad) {
    return (180.0 * (rad / Math.PI));
  }

  /**
   * Converts a set of Longitude and Latitude co-ordinates to UTM
   * using the WGS84 ellipsoid.
   *
   * @private
   * @param {object} ll Object literal with lat and lon properties
   *     representing the WGS84 coordinate to be converted.
   * @return {object} Object literal containing the UTM value with easting,
   *     northing, zoneNumber and zoneLetter properties, and an optional
   *     accuracy property in digits. Returns null if the conversion failed.
   */
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;

    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
      ZoneNumber = 60;
    }

    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
      ZoneNumber = 32;
    }

    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
      if (Long >= 0.0 && Long < 9.0) {
        ZoneNumber = 31;
      }
      else if (Long >= 9.0 && Long < 21.0) {
        ZoneNumber = 33;
      }
      else if (Long >= 21.0 && Long < 33.0) {
        ZoneNumber = 35;
      }
      else if (Long >= 33.0 && Long < 42.0) {
        ZoneNumber = 37;
      }
    }

    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);

    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

    var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

    var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
    if (Lat < 0.0) {
      UTMNorthing += 10000000.0; //10000000 meter offset for
      // southern hemisphere
    }

    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }

  /**
   * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
   * class where the Zone can be specified as a single string eg."60N" which
   * is then broken down into the ZoneNumber and ZoneLetter.
   *
   * @private
   * @param {object} utm An object literal with northing, easting, zoneNumber
   *     and zoneLetter properties. If an optional accuracy property is
   *     provided (in meters), a bounding box will be returned instead of
   *     latitude and longitude.
   * @return {object} An object literal containing either lat and lon values
   *     (if no accuracy was provided), or top, right, bottom and left values
   *     for the bounding box calculated according to the provided accuracy.
   *     Returns null if the conversion failed.
   */
  function UTMtoLL(utm) {

    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }

    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;

    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;

    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
      y -= 10000000.0; // remove 10,000,000 meter offset used
      // for southern hemisphere
    }

    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);

    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);

    var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);

    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);

    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    }
    else {
      result = {
        lat: lat,
        lon: lon
      };
    }
    return result;
  }

  /**
   * Calculates the MGRS letter designator for the given latitude.
   *
   * @private
   * @param {number} lat The latitude in WGS84 to get the letter designator
   *     for.
   * @return {char} The letter designator.
   */
  function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';

    if ((84 >= lat) && (lat >= 72)) {
      LetterDesignator = 'X';
    }
    else if ((72 > lat) && (lat >= 64)) {
      LetterDesignator = 'W';
    }
    else if ((64 > lat) && (lat >= 56)) {
      LetterDesignator = 'V';
    }
    else if ((56 > lat) && (lat >= 48)) {
      LetterDesignator = 'U';
    }
    else if ((48 > lat) && (lat >= 40)) {
      LetterDesignator = 'T';
    }
    else if ((40 > lat) && (lat >= 32)) {
      LetterDesignator = 'S';
    }
    else if ((32 > lat) && (lat >= 24)) {
      LetterDesignator = 'R';
    }
    else if ((24 > lat) && (lat >= 16)) {
      LetterDesignator = 'Q';
    }
    else if ((16 > lat) && (lat >= 8)) {
      LetterDesignator = 'P';
    }
    else if ((8 > lat) && (lat >= 0)) {
      LetterDesignator = 'N';
    }
    else if ((0 > lat) && (lat >= -8)) {
      LetterDesignator = 'M';
    }
    else if ((-8 > lat) && (lat >= -16)) {
      LetterDesignator = 'L';
    }
    else if ((-16 > lat) && (lat >= -24)) {
      LetterDesignator = 'K';
    }
    else if ((-24 > lat) && (lat >= -32)) {
      LetterDesignator = 'J';
    }
    else if ((-32 > lat) && (lat >= -40)) {
      LetterDesignator = 'H';
    }
    else if ((-40 > lat) && (lat >= -48)) {
      LetterDesignator = 'G';
    }
    else if ((-48 > lat) && (lat >= -56)) {
      LetterDesignator = 'F';
    }
    else if ((-56 > lat) && (lat >= -64)) {
      LetterDesignator = 'E';
    }
    else if ((-64 > lat) && (lat >= -72)) {
      LetterDesignator = 'D';
    }
    else if ((-72 > lat) && (lat >= -80)) {
      LetterDesignator = 'C';
    }
    return LetterDesignator;
  }

  /**
   * Encodes a UTM location as MGRS string.
   *
   * @private
   * @param {object} utm An object literal with easting, northing,
   *     zoneLetter, zoneNumber
   * @param {number} accuracy Accuracy in digits (1-5).
   * @return {string} MGRS string for the given UTM location.
   */
  function encode$2(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }

  /**
   * Get the two letter 100k designator for a given UTM easting,
   * northing and zone number value.
   *
   * @private
   * @param {number} easting
   * @param {number} northing
   * @param {number} zoneNumber
   * @return the two letter 100k designator for the given UTM location.
   */
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }

  /**
   * Given a UTM zone number, figure out the MGRS 100K set it is in.
   *
   * @private
   * @param {number} i An UTM zone number.
   * @return {number} the 100k set the UTM zone is in.
   */
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }

    return setParm;
  }

  /**
   * Get the two-letter MGRS 100k designator given information
   * translated from the UTM northing, easting and zone number.
   *
   * @private
   * @param {number} column the column index as it relates to the MGRS
   *        100k set spreadsheet, created from the UTM easting.
   *        Values are 1-8.
   * @param {number} row the row index as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM northing value. Values
   *        are from 0-19.
   * @param {number} parm the set block, as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM zone. Values are from
   *        1-60.
   * @return two letter MGRS 100k code.
   */
  function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;

    if (colInt > Z$2) {
      colInt = colInt - Z$2 + A$2 - 1;
      rollover = true;
    }

    if (colInt === I$1 || (colOrigin < I$1 && colInt > I$1) || ((colInt > I$1 || colOrigin < I$1) && rollover)) {
      colInt++;
    }

    if (colInt === O$2 || (colOrigin < O$2 && colInt > O$2) || ((colInt > O$2 || colOrigin < O$2) && rollover)) {
      colInt++;

      if (colInt === I$1) {
        colInt++;
      }
    }

    if (colInt > Z$2) {
      colInt = colInt - Z$2 + A$2 - 1;
    }

    if (rowInt > V$2) {
      rowInt = rowInt - V$2 + A$2 - 1;
      rollover = true;
    }
    else {
      rollover = false;
    }

    if (((rowInt === I$1) || ((rowOrigin < I$1) && (rowInt > I$1))) || (((rowInt > I$1) || (rowOrigin < I$1)) && rollover)) {
      rowInt++;
    }

    if (((rowInt === O$2) || ((rowOrigin < O$2) && (rowInt > O$2))) || (((rowInt > O$2) || (rowOrigin < O$2)) && rollover)) {
      rowInt++;

      if (rowInt === I$1) {
        rowInt++;
      }
    }

    if (rowInt > V$2) {
      rowInt = rowInt - V$2 + A$2 - 1;
    }

    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }

  /**
   * Decode the UTM parameters from a MGRS string.
   *
   * @private
   * @param {string} mgrsString an UPPERCASE coordinate string is expected.
   * @return {object} An object literal with easting, northing, zoneLetter,
   *     zoneNumber and accuracy (in meters) properties.
   */
  function decode$4(mgrsString) {

    if (mgrsString && mgrsString.length === 0) {
      throw ("MGRSPoint coverting from nothing");
    }

    var length = mgrsString.length;

    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;

    // get Zone number
    while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }
      sb += testChar;
      i++;
    }

    var zoneNumber = parseInt(sb, 10);

    if (i === 0 || i + 3 > length) {
      // A good MGRS string has to be 4-5 digits long,
      // ##AAA/#AAA at least.
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }

    var zoneLetter = mgrsString.charAt(i++);

    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
      throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
    }

    hunK = mgrsString.substring(i, i += 2);

    var set = get100kSetForZone(zoneNumber);

    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);

    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?

    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2000000;
    }

    // calculate the char index for easting/northing separator
    var remainder = length - i;

    if (remainder % 2 !== 0) {
      throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
    }

    var sep = remainder / 2;

    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 100000.0 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }

    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;

    return {
      easting: easting,
      northing: northing,
      zoneLetter: zoneLetter,
      zoneNumber: zoneNumber,
      accuracy: accuracyBonus
    };
  }

  /**
   * Given the first letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the easting value that
   * should be added to the other, secondary easting value.
   *
   * @private
   * @param {char} e The first letter from a two-letter MGRS 100´k zone.
   * @param {number} set The MGRS table set for the zone number.
   * @return {number} The easting value for the given letter and set.
   */
  function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;

    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I$1) {
        curCol++;
      }
      if (curCol === O$2) {
        curCol++;
      }
      if (curCol > Z$2) {
        if (rewindMarker) {
          throw ("Bad character: " + e);
        }
        curCol = A$2;
        rewindMarker = true;
      }
      eastingValue += 100000.0;
    }

    return eastingValue;
  }

  /**
   * Given the second letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the northing value that
   * should be added to the other, secondary northing value. You have to
   * remember that Northings are determined from the equator, and the vertical
   * cycle of letters mean a 2000000 additional northing meters. This happens
   * approx. every 18 degrees of latitude. This method does *NOT* count any
   * additional northings. You have to figure out how many 2000000 meters need
   * to be added for the zone letter of the MGRS coordinate.
   *
   * @private
   * @param {char} n Second letter of the MGRS 100k zone
   * @param {number} set The MGRS table set number, which is dependent on the
   *     UTM zone number.
   * @return {number} The northing value for the given letter and set.
   */
  function getNorthingFromChar(n, set) {

    if (n > 'V') {
      throw ("MGRSPoint given invalid Northing " + n);
    }

    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;

    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I$1) {
        curRow++;
      }
      if (curRow === O$2) {
        curRow++;
      }
      // fixing a bug making whole application hang in this loop
      // when 'n' is a wrong character
      if (curRow > V$2) {
        if (rewindMarker) { // making sure that this loop ends
          throw ("Bad character: " + n);
        }
        curRow = A$2;
        rewindMarker = true;
      }
      northingValue += 100000.0;
    }

    return northingValue;
  }

  /**
   * The function getMinNorthing returns the minimum northing value of a MGRS
   * zone.
   *
   * Ported from Geotrans' c Lattitude_Band_Value structure table.
   *
   * @private
   * @param {char} zoneLetter The MGRS zone to get the min northing for.
   * @return {number}
   */
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
    }
    if (northing >= 0.0) {
      return northing;
    }
    else {
      throw ("Invalid zone letter: " + zoneLetter);
    }

  }

  function Point$2(x, y, z) {
    if (!(this instanceof Point$2)) {
      return new Point$2(x, y, z);
    }
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2] || 0.0;
    } else if(typeof x === 'object') {
      this.x = x.x;
      this.y = x.y;
      this.z = x.z || 0.0;
    } else if (typeof x === 'string' && typeof y === 'undefined') {
      var coords = x.split(',');
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0.0;
    } else {
      this.x = x;
      this.y = y;
      this.z = z || 0.0;
    }
    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
  }

  Point$2.fromMGRS = function(mgrsStr) {
    return new Point$2(toPoint(mgrsStr));
  };
  Point$2.prototype.toMGRS = function(accuracy) {
    return forward$s([this.x, this.y], accuracy);
  };

  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.01302083333333333333;
  var C48 = 0.00712076822916666666;
  var C66 = 0.36458333333333333333;
  var C68 = 0.00569661458333333333;
  var C88 = 0.3076171875;

  function pj_enfn(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  }

  function pj_mlfn(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
  }

  var MAX_ITER$3 = 20;

  function pj_inv_mlfn(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER$3; i; --i) { /* rarely goes over 2 iterations */
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
      //phi -= t * (t * Math.sqrt(t)) * k;
      t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    //..reportError("cass:pj_inv_mlfn: Convergence error");
    return phi;
  }

  // Heavily based on this tmerc projection implementation

  function init$s() {
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    if (this.es) {
      this.en = pj_enfn(this.es);
      this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }

  /**
      Transverse Mercator Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$r(p) {
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var con;
    var x, y;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);

    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);

      if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
        return (93);
      }
      else {
        x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y);

        if (b >= 1) {
          if ((b - 1) > EPSLN) {
            return (93);
          }
          else {
            y = 0;
          }
        }
        else {
          y = Math.acos(y);
        }

        if (lat < 0) {
          y = -y;
        }

        y = this.a * this.k0 * (y - this.lat0) + this.y0;
      }
    }
    else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

      x = this.a * (this.k0 * al * (1 +
        als / 6 * (1 - t + c +
        als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
        als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
        this.x0;

      y = this.a * (this.k0 * (ml - this.ml0 +
        sin_phi * delta_lon * al / 2 * (1 +
        als / 12 * (5 - t + 9 * c + 4 * cs +
        als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
        als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
        this.y0;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  /**
      Transverse Mercator Inverse  -  x/y to long/lat
    */
  function inverse$r(p) {
    var con, phi;
    var lat, lon;
    var x = (p.x - this.x0) * (1 / this.a);
    var y = (p.y - this.y0) * (1 / this.a);

    if (!this.es) {
      var f = Math.exp(x / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp = this.lat0 + y / this.k0;
      var h = Math.cos(temp);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);

      if (y < 0) {
        lat = -lat;
      }

      if ((g === 0) && (h === 0)) {
        lon = 0;
      }
      else {
        lon = adjust_lon(Math.atan2(g, h) + this.long0);
      }
    }
    else { // ellipsoidal form
      con = this.ml0 + y / this.k0;
      phi = pj_inv_mlfn(con, this.es, this.en);

      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;

        lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
          ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
          ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
          ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

        lon = adjust_lon(this.long0 + (d * (1 -
          ds / 6 * (1 + 2 * t + c -
          ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
          ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
      }
      else {
        lat = HALF_PI * sign(y);
        lon = 0;
      }
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$s = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  var tmerc = {
    init: init$s,
    forward: forward$r,
    inverse: inverse$r,
    names: names$s
  };

  function sinh(x) {
    var r = Math.exp(x);
    r = (r - 1 / r) / 2;
    return r;
  }

  function hypot(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    var a = Math.max(x, y);
    var b = Math.min(x, y) / (a ? a : 1);

    return a * Math.sqrt(1 + Math.pow(b, 2));
  }

  function log1py(x) {
    var y = 1 + x;
    var z = y - 1;

    return z === 0 ? x : x * Math.log(y) / z;
  }

  function asinhy(x) {
    var y = Math.abs(x);
    y = log1py(y * (1 + y / (hypot(1, y) + 1)));

    return x < 0 ? -y : y;
  }

  function gatg(pp, B) {
    var cos_2B = 2 * Math.cos(2 * B);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;

    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }

    return (B + h * Math.sin(2 * B));
  }

  function clens(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;

    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }

    return Math.sin(arg_r) * hr;
  }

  function cosh$1(x) {
    var r = Math.exp(x);
    r = (r + 1 / r) / 2;
    return r;
  }

  function clens_cmplx(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh(arg_i);
    var cosh_arg_i = cosh$1(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;

    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }

    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;

    return [r * hr - i * hi, r * hi + i * hr];
  }

  // Heavily based on this etmerc projection implementation

  function init$r() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    }
    if (this.approx) {
      // When '+approx' is set, use tmerc instead
      tmerc.init.apply(this);
      this.forward = tmerc.forward;
      this.inverse = tmerc.inverse;
    }

    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];

    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;

    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
    this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);

    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

    this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);

    var Z = gatg(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
  }

  function forward$q(p) {
    var Ce = adjust_lon(p.x - this.long0);
    var Cn = p.y;

    Cn = gatg(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy(Math.tan(Ce));

    var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];

    var x;
    var y;

    if (Math.abs(Ce) <= 2.623395162778) {
      x = this.a * (this.Qn * Ce) + this.x0;
      y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    }
    else {
      x = Infinity;
      y = Infinity;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  function inverse$q(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);

    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;

    var lon;
    var lat;

    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh(Ce));

      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

      lon = adjust_lon(Ce + this.long0);
      lat = gatg(this.cgb, Cn);
    }
    else {
      lon = Infinity;
      lat = Infinity;
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$r = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var etmerc = {
    init: init$r,
    forward: forward$q,
    inverse: inverse$q,
    names: names$r
  };

  function adjust_zone(zone, lon) {
    if (zone === undefined) {
      zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  }

  var dependsOn = 'etmerc';


  function init$q() {
    var zone = adjust_zone(this.zone, this.long0);
    if (zone === undefined) {
      throw new Error('unknown utm zone');
    }
    this.lat0 = 0;
    this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R$1;
    this.x0 = 500000;
    this.y0 = this.utmSouth ? 10000000 : 0;
    this.k0 = 0.9996;

    etmerc.init.apply(this);
    this.forward = etmerc.forward;
    this.inverse = etmerc.inverse;
  }

  var names$q = ["Universal Transverse Mercator System", "utm"];
  var utm = {
    init: init$q,
    names: names$q,
    dependsOn: dependsOn
  };

  function srat(esinp, exp) {
    return (Math.pow((1 - esinp) / (1 + esinp), exp));
  }

  var MAX_ITER$2 = 20;

  function init$p() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
  }

  function forward$p(p) {
    var lon = p.x;
    var lat = p.y;

    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }

  function inverse$p(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER$2; i > 0; --i) {
      lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    /* convergence failed */
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$p = ["gauss"];
  var gauss = {
    init: init$p,
    forward: forward$p,
    inverse: inverse$p,
    names: names$p
  };

  function init$o() {
    gauss.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }

  function forward$o(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon(p.x - this.long0);
    gauss.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }

  function inverse$o(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;
    if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    gauss.inverse.apply(this, [p]);
    p.x = adjust_lon(p.x + this.long0);
    return p;
  }

  var names$o = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
  var sterea = {
    init: init$o,
    forward: forward$o,
    inverse: inverse$o,
    names: names$o
  };

  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
  }

  function init$n() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
      }
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          //North pole
          //trace('stere:north pole');
          this.con = 1;
        }
        else {
          //South pole
          //trace('stere:south pole');
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }

  // Stereographic forward equations--mapping lat,long to x,y
  function forward$n(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon(lon - this.long0);

    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      //case of the origine point
      //trace('stere:this is the origin point');
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      //trace('stere:sphere case');
      A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    }
    else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        //trace(p.toString());
        return p;
      }
      else if (Math.abs(this.sinlat0) < EPSLN) {
        //Eq
        //trace('stere:equateur');
        A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A * sinX;
      }
      else {
        //other case
        //trace('stere:normal case');
        A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A * cosX * Math.sin(dlon) + this.x0;
    }
    //trace(p.toString());
    return p;
  }

  //* Stereographic inverse equations--mapping x,y to lat/long
  function inverse$n(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        }
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          //trace(p.toString());
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z(this.e, ts);
        lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        }
        else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;

    //trace(p.toString());
    return p;

  }

  var names$n = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere = {
    init: init$n,
    forward: forward$n,
    inverse: inverse$n,
    names: names$n,
    ssfn_: ssfn_
  };

  /*
    references:
      Formules et constantes pour le Calcul pour la
      projection cylindrique conforme à axe oblique et pour la transformation entre
      des systèmes de référence.
      http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
    */

  function init$m() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e2 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e2);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }

  function forward$m(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;

    // spheric latitude
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

    // spheric longitude
    var I = this.alpha * (p.x - this.lambda0);

    // psoeudo equatorial rotation
    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }

  function inverse$m(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;

    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

    var lambda = this.lambda0 + I / this.alpha;

    var S = 0;
    var phy = b;
    var prevPhy = -1000;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 0.0000001) {
      if (++iteration > 20) {
        //...reportError("omercFwdInfinity");
        return;
      }
      //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }

    p.x = lambda;
    p.y = phy;
    return p;
  }

  var names$m = ["somerc"];
  var somerc = {
    init: init$m,
    forward: forward$m,
    inverse: inverse$m,
    names: names$m
  };

  var TOL = 1e-7;

  function isTypeA(P) {
    var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
    var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
    
    return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
  }


  /* Initialize the Oblique Mercator  projection
      ------------------------------------------*/
  function init$l() {  
    var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
      gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
    
    // only Type A uses the no_off or no_uoff property
    // https://github.com/OSGeo/proj.4/issues/104
    this.no_off = isTypeA(this);
    this.no_rot = 'no_rot' in this;
    
    var alp = false;
    if ("alpha" in this) {
      alp = true;
    }

    var gam = false;
    if ("rectified_grid_angle" in this) {
      gam = true;
    }

    if (alp) {
      alpha_c = this.alpha;
    }
    
    if (gam) {
      gamma = (this.rectified_grid_angle * D2R$1);
    }
    
    if (alp || gam) {
      lamc = this.longc;
    } else {
      lam1 = this.long1;
      phi1 = this.lat1;
      lam2 = this.long2;
      phi2 = this.lat2;
      
      if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
          Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
          Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
        throw new Error();
      }
    }
    
    var one_es = 1.0 - this.es;
    com = Math.sqrt(one_es);
    
    if (Math.abs(this.lat0) > EPSLN) {
      sinph0 = Math.sin(this.lat0);
      cosph0 = Math.cos(this.lat0);
      con = 1 - this.es * sinph0 * sinph0;
      this.B = cosph0 * cosph0;
      this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
      this.A = this.B * this.k0 * com / con;
      D = this.B * com / (cosph0 * Math.sqrt(con));
      F = D * D -1;
      
      if (F <= 0) {
        F = 0;
      } else {
        F = Math.sqrt(F);
        if (this.lat0 < 0) {
          F = -F;
        }
      }
      
      this.E = F += D;
      this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
    } else {
      this.B = 1 / com;
      this.A = this.k0;
      this.E = D = F = 1;
    }
    
    if (alp || gam) {
      if (alp) {
        gamma0 = Math.asin(Math.sin(alpha_c) / D);
        if (!gam) {
          gamma = alpha_c;
        }
      } else {
        gamma0 = gamma;
        alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
    } else {
      H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
      L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
      F = this.E / H;
      p = (L - H) / (L + H);
      J = this.E * this.E;
      J = (J - L * H) / (J + L * H);
      con = lam1 - lam2;
      
      if (con < -Math.pi) {
        lam2 -=TWO_PI;
      } else if (con > Math.pi) {
        lam2 += TWO_PI;
      }
      
      this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
      gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
      gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    
    this.singam = Math.sin(gamma0);
    this.cosgam = Math.cos(gamma0);
    this.sinrot = Math.sin(gamma);
    this.cosrot = Math.cos(gamma);
    
    this.rB = 1 / this.B;
    this.ArB = this.A * this.rB;
    this.BrA = 1 / this.ArB;
    this.A * this.B;
    
    if (this.no_off) {
      this.u_0 = 0;
    } else {
      this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
      
      if (this.lat0 < 0) {
        this.u_0 = - this.u_0;
      }  
    }
      
    F = 0.5 * gamma0;
    this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
    this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
  }


  /* Oblique Mercator forward equations--mapping lat,long to x,y
      ----------------------------------------------------------*/
  function forward$l(p) {
    var coords = {};
    var S, T, U, V, W, temp, u, v;
    p.x = p.x - this.lam0;
    
    if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
      W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
      
      temp = 1 / W;
      S = 0.5 * (W - temp);
      T = 0.5 * (W + temp);
      V = Math.sin(this.B * p.x);
      U = (S * this.singam - V * this.cosgam) / T;
          
      if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
        throw new Error();
      }
      
      v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
      temp = Math.cos(this.B * p.x);
      
      if (Math.abs(temp) < TOL) {
        u = this.A * p.x;
      } else {
        u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
      }    
    } else {
      v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
      u = this.ArB * p.y;
    }
       
    if (this.no_rot) {
      coords.x = u;
      coords.y = v;
    } else {
      u -= this.u_0;
      coords.x = v * this.cosrot + u * this.sinrot;
      coords.y = u * this.cosrot - v * this.sinrot;
    }
    
    coords.x = (this.a * coords.x + this.x0);
    coords.y = (this.a * coords.y + this.y0);
    
    return coords;
  }

  function inverse$l(p) {
    var u, v, Qp, Sp, Tp, Vp, Up;
    var coords = {};
    
    p.x = (p.x - this.x0) * (1.0 / this.a);
    p.y = (p.y - this.y0) * (1.0 / this.a);

    if (this.no_rot) {
      v = p.y;
      u = p.x;
    } else {
      v = p.x * this.cosrot - p.y * this.sinrot;
      u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
    }
    
    Qp = Math.exp(-this.BrA * v);
    Sp = 0.5 * (Qp - 1 / Qp);
    Tp = 0.5 * (Qp + 1 / Qp);
    Vp = Math.sin(this.BrA * u);
    Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
    
    if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
      coords.x = 0;
      coords.y = Up < 0 ? -HALF_PI : HALF_PI;
    } else {
      coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
      coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
      
      if (coords.y === Infinity) {
        throw new Error();
      }
          
      coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
    }
    
    coords.x += this.lam0;
    
    return coords;
  }

  var names$l = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  var omerc = {
    init: init$l,
    forward: forward$l,
    inverse: inverse$l,
    names: names$l
  };

  function init$k() {
    
    //double lat0;                    /* the reference latitude               */
    //double long0;                   /* the reference longitude              */
    //double lat1;                    /* first standard parallel              */
    //double lat2;                    /* second standard parallel             */
    //double r_maj;                   /* major axis                           */
    //double r_min;                   /* minor axis                           */
    //double false_east;              /* x offset in meters                   */
    //double false_north;             /* y offset in meters                   */
    
    //the above value can be set with proj4.defs
    //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    if (!this.lat2) {
      this.lat2 = this.lat1;
    } //if lat2 is not defined
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }

    var temp = this.b / this.a;
    this.e = Math.sqrt(1 - temp * temp);

    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz(this.e, sin1, cos1);
    var ts1 = tsfnz(this.e, this.lat1, sin1);

    var sin2 = Math.sin(this.lat2);
    var cos2 = Math.cos(this.lat2);
    var ms2 = msfnz(this.e, sin2, cos2);
    var ts2 = tsfnz(this.e, this.lat2, sin2);

    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    }
    else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }

  // Lambert Conformal conic forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$k(p) {

    var lon = p.x;
    var lat = p.y;

    // singular cases :
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign(lat) * (HALF_PI - 2 * EPSLN);
    }

    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    }
    else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

    return p;
  }

  // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$k(p) {

    var rh1, con, ts;
    var lat, lon;
    var x = (p.x - this.x0) / this.k0;
    var y = (this.rh - (p.y - this.y0) / this.k0);
    if (this.ns > 0) {
      rh1 = Math.sqrt(x * x + y * y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(x * x + y * y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2((con * x), (con * y));
    }
    if ((rh1 !== 0) || (this.ns > 0)) {
      con = 1 / this.ns;
      ts = Math.pow((rh1 / (this.a * this.f0)), con);
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    else {
      lat = -HALF_PI;
    }
    lon = adjust_lon(theta / this.ns + this.long0);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$k = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc"
  ];

  var lcc = {
    init: init$k,
    forward: forward$k,
    inverse: inverse$k,
    names: names$k
  };

  function init$j() {
    this.a = 6377397.155;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    /* if scale not set default to 0.9999 */
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448; /* 45 */
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }

  /* ellipsoid */
  /* calculate xy from lat/lon */
  /* Constants, identical to inverse transform function */
  function forward$j(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    /* Transformation */
    gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;

    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return (p);
  }

  /* calculate lat/lon from xy */
  function inverse$j(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;

    /* Transformation */
    /* revert y, x*/
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 0.0000000001) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }

    return (p);
  }

  var names$j = ["Krovak", "krovak"];
  var krovak = {
    init: init$j,
    forward: forward$j,
    inverse: inverse$j,
    names: names$j
  };

  function mlfn(e0, e1, e2, e3, phi) {
    return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
  }

  function e0fn(x) {
    return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
  }

  function e1fn(x) {
    return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
  }

  function e2fn(x) {
    return (0.05859375 * x * x * (1 + 0.75 * x));
  }

  function e3fn(x) {
    return (x * x * x * (35 / 3072));
  }

  function gN(a, e, sinphi) {
    var temp = e * sinphi;
    return a / Math.sqrt(1 - temp * temp);
  }

  function adjust_lat(x) {
    return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
  }

  function imlfn(ml, e0, e1, e2, e3) {
    var phi;
    var dphi;

    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
    return NaN;
  }

  function init$i() {
    if (!this.sphere) {
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }

  /* Cassini forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$i(p) {

    /* Forward equations
        -----------------*/
    var x, y;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);

    if (this.sphere) {
      x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    }
    else {
      //ellipsoid
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

      x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


    }

    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$i(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var phi, lam;

    if (this.sphere) {
      var dd = y + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x));
      lam = Math.atan2(Math.tan(x), Math.cos(dd));
    }
    else {
      /* ellipsoid */
      var ml1 = this.ml0 / this.a + y;
      var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN(this.a, this.e, Math.sin(phi1));

      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

    }

    p.x = adjust_lon(lam + this.long0);
    p.y = adjust_lat(phi);
    return p;

  }

  var names$i = ["Cassini", "Cassini_Soldner", "cass"];
  var cass = {
    init: init$i,
    forward: forward$i,
    inverse: inverse$i,
    names: names$i
  };

  function qsfnz(eccent, sinphi) {
    var con;
    if (eccent > 1.0e-7) {
      con = eccent * sinphi;
      return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
    }
    else {
      return (2 * sinphi);
    }
  }

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  var S_POLE = 1;

  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;

  /* Initialize the Lambert Azimuthal Equal Area projection
    ------------------------------------------------------*/
  function init$h() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    }
    else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    }
    else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;

      this.qp = qsfnz(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
      }
    }
    else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }

  /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$h(p) {

    /* Forward equations
        -----------------*/
    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;

    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y <= EPSLN) {
          return null;
        }
        y = Math.sqrt(2 / y);
        x = y * cosphi * Math.sin(lam);
        y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y = FORTPI - phi * 0.5;
        y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
        x = y * Math.sin(lam);
        y *= coslam;
      }
    }
    else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        }
        else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * ((this.mode === this.S_POLE) ? b : -b);
        }
        else {
          x = y = 0;
        }
        break;
      }
    }

    p.x = this.a * x + this.x0;
    p.y = this.a * y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$h(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0,
        rh, sinz = 0;

      rh = Math.sqrt(x * x + y * y);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
      case this.EQUIT:
        phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
      }
      lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
    }
    else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x /= this.dd;
        y *= this.dd;
        rho = Math.sqrt(x * x + y * y);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x *= (sCe = Math.sin(sCe));
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
        }
        else {
          ab = y * sCe / rho;
          q = this.qp * ab;
          y = rho * cCe;
        }
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y = -y;
        }
        q = (x * x + y * y);
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x, y);
      phi = authlat(Math.asin(ab), this.apa);
    }

    p.x = adjust_lon(this.long0 + lam);
    p.y = phi;
    return p;
  }

  /* determine latitude from authalic latitude */
  var P00 = 0.33333333333333333333;

  var P01 = 0.17222222222222222222;
  var P02 = 0.10257936507936507936;
  var P10 = 0.06388888888888888888;
  var P11 = 0.06640211640211640211;
  var P20 = 0.01641501294219154443;

  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }

  function authlat(beta, APA) {
    var t = beta + beta;
    return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
  }

  var names$h = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea = {
    init: init$h,
    forward: forward$h,
    inverse: inverse$h,
    names: names$h,
    S_POLE: S_POLE,
    N_POLE: N_POLE,
    EQUIT: EQUIT,
    OBLIQ: OBLIQ
  };

  function asinz(x) {
    if (Math.abs(x) > 1) {
      x = (x > 1) ? 1 : -1;
    }
    return Math.asin(x);
  }

  function init$g() {

    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);

    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    }
    else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }

  /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
    -------------------------------------------------------------------*/
  function forward$g(p) {

    var lon = p.x;
    var lat = p.y;

    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);

    var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon(lon - this.long0);
    var x = rh1 * Math.sin(theta) + this.x0;
    var y = this.rh - rh1 * Math.cos(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$g(p) {
    var rh1, qs, con, theta, lon, lat;

    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    }
    else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }

    lon = adjust_lon(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }

  /* Function to compute phi1, the latitude for the inverse of the
     Albers Conical Equal-Area projection.
  -------------------------------------------*/
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }

    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }

  var names$g = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea = {
    init: init$g,
    forward: forward$g,
    inverse: inverse$g,
    names: names$g,
    phi1z: phi1z
  };

  /*
    reference:
      Wolfram Mathworld "Gnomonic Projection"
      http://mathworld.wolfram.com/GnomonicProjection.html
      Accessed: 12th November 2009
    */
  function init$f() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    // Approximation for projecting points to the horizon (infinity)
    this.infinity_dist = 1000 * this.a;
    this.rc = 1;
  }

  /* Gnomonic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$f(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g;
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    }
    else {

      // Point is in the opposing hemisphere and is unprojectable
      // We still need to return a reasonable point, so we project
      // to infinity, on a bearing
      // equivalent to the northern hemisphere equivalent
      // This is a reasonable approximation for short shapes and lines that
      // straddle the horizon.

      x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$f(p) {
    var rh; /* Rho */
    var sinc, cosc;
    var c;
    var lon, lat;

    /* Inverse equations
        -----------------*/
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;

    if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);

      lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon(this.long0 + lon);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$f = ["gnom"];
  var gnom = {
    init: init$f,
    forward: forward$f,
    inverse: inverse$f,
    names: names$f
  };

  function iqsfnz(eccent, q) {
    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
      if (q < 0) {
        return (-1 * HALF_PI);
      }
      else {
        return HALF_PI;
      }
    }
    //var phi = 0.5* q/(1-eccent*eccent);
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
    return NaN;
  }

  /*
    reference:
      "Cartographic Projection Procedures for the UNIX Environment-
      A User's Manual" by Gerald I. Evenden,
      USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  */
  function init$e() {
    //no-op
    if (!this.sphere) {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }

  /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$e(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    }
    else {
      var qs = qsfnz(this.e, Math.sin(lat));
      x = this.x0 + this.a * this.k0 * dlon;
      y = this.y0 + this.a * qs * 0.5 / this.k0;
    }

    p.x = x;
    p.y = y;
    return p;
  }

  /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$e(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;

    if (this.sphere) {
      lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
      lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
    }
    else {
      lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$e = ["cea"];
  var cea = {
    init: init$e,
    forward: forward$e,
    inverse: inverse$e,
    names: names$e
  };

  function init$d() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

    this.rc = Math.cos(this.lat_ts);
  }

  // forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$d(p) {

    var lon = p.x;
    var lat = p.y;

    var dlon = adjust_lon(lon - this.long0);
    var dlat = adjust_lat(lat - this.lat0);
    p.x = this.x0 + (this.a * dlon * this.rc);
    p.y = this.y0 + (this.a * dlat);
    return p;
  }

  // inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$d(p) {

    var x = p.x;
    var y = p.y;

    p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
    p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
    return p;
  }

  var names$d = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc = {
    init: init$d,
    forward: forward$d,
    inverse: inverse$d,
    names: names$d
  };

  var MAX_ITER$1 = 20;

  function init$c() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
  }

  /* Polyconic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$c(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y, el;
    var dlon = adjust_lon(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.a * this.lat0;
      }
      else {
        x = this.a * Math.sin(el) / Math.tan(lat);
        y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    }
    else {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.ml0;
      }
      else {
        var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x = nl * Math.sin(el);
        y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }

    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$c(p) {
    var lon, lat, x, y, i;
    var al, bl;
    var phi, dphi;
    x = p.x - this.x0;
    y = p.y - this.y0;

    if (this.sphere) {
      if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon(x / this.a + this.long0);
        lat = 0;
      }
      else {
        al = this.lat0 + y / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER$1; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
      }
    }
    else {
      if (Math.abs(y + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon(this.long0 + x / this.a);
      }
      else {

        al = (this.ml0 + y) / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER$1; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }

        //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$c = ["Polyconic", "poly"];
  var poly = {
    init: init$c,
    forward: forward$c,
    inverse: inverse$c,
    names: names$c
  };

  function init$b() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -0.0055161;
    this.A[7] = 0.0026906;
    this.A[8] = -0.001333;
    this.A[9] = 0.00067;
    this.A[10] = -0.00034;

    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 0.003371507;
    this.B_re[3] = -0.001541739;
    this.B_im[3] = 0.041058560;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;

    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -0.007809598;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;

    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 0.007317;
    this.D[7] = 0.01220;
    this.D[8] = 0.00394;
    this.D[9] = -0.0013;
  }

  /**
      New Zealand Map Grid Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$b(p) {
    var n;
    var lon = p.x;
    var lat = p.y;

    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;

    // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
    // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
    var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1; // d_phi^0

    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }

    // 2. Calculate theta
    var th_re = d_psi;
    var th_im = d_lambda;

    // 3. Calculate z
    var th_n_re = 1;
    var th_n_im = 0; // theta^0
    var th_n_re1;
    var th_n_im1;

    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }

    // 4. Calculate easting and northing
    p.x = (z_im * this.a) + this.x0;
    p.y = (z_re * this.a) + this.y0;

    return p;
  }

  /**
      New Zealand Map Grid Inverse  -  x/y to long/lat
    */
  function inverse$b(p) {
    var n;
    var x = p.x;
    var y = p.y;

    var delta_x = x - this.x0;
    var delta_y = y - this.y0;

    // 1. Calculate z
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;

    // 2a. Calculate theta - first approximation gives km accuracy
    var z_n_re = 1;
    var z_n_im = 0; // z^0
    var z_n_re1;
    var z_n_im1;

    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }

    // 2b. Iterate to refine the accuracy of the calculation
    //        0 iterations gives km accuracy
    //        1 iteration gives m accuracy -- good enough for most mapping applications
    //        2 iterations bives mm accuracy
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;

      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      // Complex division
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }

    // 3. Calculate d_phi              ...                                    // and d_lambda
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1; // d_psi^0

    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }

    // 4. Calculate latitude and longitude
    // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
    var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
    var lon = this.long0 + d_lambda;

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$b = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg = {
    init: init$b,
    forward: forward$b,
    inverse: inverse$b,
    names: names$b
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */


  /* Initialize the Miller Cylindrical projection
    -------------------------------------------*/
  function init$a() {
    //no-op
  }

  /* Miller Cylindrical forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$a(p) {
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x = this.x0 + this.a * dlon;
    var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

    p.x = x;
    p.y = y;
    return p;
  }

  /* Miller Cylindrical inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$a(p) {
    p.x -= this.x0;
    p.y -= this.y0;

    var lon = adjust_lon(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$a = ["Miller_Cylindrical", "mill"];
  var mill = {
    init: init$a,
    forward: forward$a,
    inverse: inverse$a,
    names: names$a
  };

  var MAX_ITER = 20;


  function init$9() {
    /* Place parameters in static storage for common use
      -------------------------------------------------*/


    if (!this.sphere) {
      this.en = pj_enfn(this.es);
    }
    else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }

  }

  /* Sinusoidal forward equations--mapping lat,long to x,y
    -----------------------------------------------------*/
  function forward$9(p) {
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
      -----------------*/
    lon = adjust_lon(lon - this.long0);

    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      }
      else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER; i; --i) {
          var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V;
          if (Math.abs(V) < EPSLN) {
            break;
          }
        }
      }
      x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y = this.a * this.C_y * lat;

    }
    else {

      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y = this.a * pj_mlfn(lat, s, c, this.en);
      x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$9(p) {
    var lat, temp, lon, s;

    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;

    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
      }
      else if (this.n !== 1) {
        lat = asinz(Math.sin(lat) / this.n);
      }
      lon = adjust_lon(lon + this.long0);
      lat = adjust_lat(lat);
    }
    else {
      lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        //temp = this.long0 + p.x / (this.a * Math.cos(lat));
        lon = adjust_lon(temp);
      }
      else if ((s - EPSLN) < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$9 = ["Sinusoidal", "sinu"];
  var sinu = {
    init: init$9,
    forward: forward$9,
    inverse: inverse$9,
    names: names$9
  };

  function init$8() {}
  /* Mollweide forward equations--mapping lat,long to x,y
      ----------------------------------------------------*/
  function forward$8(p) {

    /* Forward equations
        -----------------*/
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);

    /* Iterate using the Newton-Raphson method to find theta
        -----------------------------------------------------*/
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;

    /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
         this is done here because of precision problems with "cos(theta)"
         --------------------------------------------------------------------------*/
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$8(p) {
    var theta;
    var arg;

    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);

    /* Because of division by zero problems, 'arg' can not be 1.  Therefore
         a number very close to one is used instead.
         -------------------------------------------------------------------*/
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
    if (lon < (-Math.PI)) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$8 = ["Mollweide", "moll"];
  var moll = {
    init: init$8,
    forward: forward$8,
    inverse: inverse$8,
    names: names$8
  };

  function init$7() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);

    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);

    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    }
    else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }

  /* Equidistant Conic forward equations--mapping lat,long to x,y
    -----------------------------------------------------------*/
  function forward$7(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;

    /* Forward equations
        -----------------*/
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    }
    else {
      var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    var x = this.x0 + rh1 * Math.sin(theta);
    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x;
    p.y = y;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$7(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }

    if (this.sphere) {
      lon = adjust_lon(this.long0 + theta / this.ns);
      lat = adjust_lat(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }

  }

  var names$7 = ["Equidistant_Conic", "eqdc"];
  var eqdc = {
    init: init$7,
    forward: forward$7,
    inverse: inverse$7,
    names: names$7
  };

  /* Initialize the Van Der Grinten projection
    ----------------------------------------*/
  function init$6() {
    //this.R = 6370997; //Radius of earth
    this.R = this.a;
  }

  function forward$6(p) {

    var lon = p.x;
    var lat = p.y;

    /* Forward equations
      -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x, y;

    if (Math.abs(lat) <= EPSLN) {
      x = this.x0 + this.R * dlon;
      y = this.y0;
    }
    var theta = asinz(2 * Math.abs(lat / Math.PI));
    if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
      x = this.x0;
      if (lat >= 0) {
        y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      }
      else {
        y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
      //  return(OK);
    }
    var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);

    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x = this.x0 + con;
    //con = Math.abs(con / (Math.PI * this.R));
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 + con;
    }
    else {
      //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 - con;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Van Der Grinten inverse equations--mapping x,y to lat/long
    ---------------------------------------------------------*/
  function inverse$6(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;

    /* inverse equations
      -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = ((3 * d) / a1) / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      }
      else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }

    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$6 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg = {
    init: init$6,
    forward: forward$6,
    inverse: inverse$6,
    names: names$6
  };

  function init$5() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }

  function forward$5(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon(lon - this.long0);
    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      }
      else {
        //default case
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      }
      else {
        //Default case
        tanphi = sinphi / cosphi;
        Nl1 = gN(this.a, this.e, this.sin_p12);
        Nl = gN(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }


  }

  function inverse$5(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > (2 * HALF_PI * this.a)) {
        return;
      }
      z = rh / this.a;

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      }
      else {
        lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
          }
          else {
            lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
          }
        }
        else {
          /*con = cosz - this.sin_p12 * Math.sin(lat);
          if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
            //no-op, just keep the lon value as is
          } else {
            var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
            lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
          }*/
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;

        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        //default case
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A = -tmp * tmp / (1 - this.es);
        B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
        F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }

  }

  var names$5 = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd = {
    init: init$5,
    forward: forward$5,
    inverse: inverse$5,
    names: names$5
  };

  function init$4() {
    //double temp;      /* temporary variable    */

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }

  /* Orthographic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$4(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g, x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.a * ksp * cosphi * Math.sin(dlon);
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$4(p) {
    var rh; /* height above ellipsoid      */
    var z; /* angle          */
    var sinz, cosz; /* sin of z and cos of z      */
    var con;
    var lon, lat;
    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z = asinz(rh / this.a);

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
      }
      else {
        lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$4 = ["ortho"];
  var ortho = {
    init: init$4,
    forward: forward$4,
    inverse: inverse$4,
    names: names$4
  };

  // QSC projection rewritten from the original PROJ4

  /* constants */
  var FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
  };

  var AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
  };

  function init$3() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";

    /* Determine the cube face from the center of projection. */
    if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }

    /* Fill in useful values for the ellipsoid <-> sphere shift
     * described in [LK12]. */
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }

  // QSC forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$3(p) {
    var xy = {x: 0, y: 0};
    var lat, lon;
    var theta, phi;
    var t, mu;
    /* nu; */
    var area = {value: 0};

    // move lon according to projection's lon
    p.x -= this.long0;

    /* Convert the geodetic latitude to a geocentric latitude.
     * This corresponds to the shift from the ellipsoid to the sphere
     * described in [LK12]. */
    if (this.es !== 0) {//if (P->es != 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }

    /* Convert the input lat, lon into theta, phi as used by QSC.
     * This depends on the cube face and the area on it.
     * For the top and bottom face, we can compute theta and phi
     * directly from phi, lam. For the other faces, we must use
     * unit sphere cartesian coordinates as an intermediate step. */
    lon = p.x; //lon = lp.lam;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_1;
        theta = (lon > 0.0 ? lon - SPI : lon + SPI);
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;

      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;

      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area);
      } else {
        /* Impossible */
        phi = theta = 0;
        area.value = AREA_ENUM.AREA_0;
      }
    }

    /* Compute mu and nu for the area of definition.
     * For mu, see Eq. (3-21) in [OL76], but note the typos:
     * compare with Eq. (3-14). For nu, see Eq. (3-38). */
    mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

    /* Apply the result to the real area. */
    if (area.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }

    /* Now compute x, y from mu and nu */
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;

    p.x = xy.x;
    p.y = xy.y;
    return p;
  }

  // QSC inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$3(p) {
    var lp = {lam: 0, phi: 0};
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area = {value: 0};

    /* de-offset */
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    /* Convert the input x, y to the mu and nu angles as used by QSC.
     * This depends on the area of the cube face. */
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
      area.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_2;
      mu = (mu < 0.0 ? mu + SPI : mu - SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }

    /* Compute phi and theta for the area of definition.
     * The inverse projection is not described in the original paper, but some
     * good hints can be found here (as of 2011-12-14):
     * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
     * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
    t = (SPI / 12) * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > +1) {
      cosphi = +1;
    }

    /* Apply the result to the real area on the cube face.
     * For the top and bottom face, we can compute phi and lam directly.
     * For the other faces, we must use unit sphere cartesian coordinates
     * as an intermediate step. */
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = theta;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
      }
    } else {
      /* Compute phi and lam via cartesian unit sphere coordinates. */
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      /* Rotate q,r,s into the correct area. */
      if (area.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      /* Rotate q,r,s into the correct cube face. */
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      /* Now compute phi and lam from the unit sphere coordinates. */
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }

    /* Apply the shift from the sphere to the ellipsoid as described
     * in [LK12]. */
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = (lp.phi < 0 ? 1 : 0);
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }

    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }

  /* Helper function for forward projection: compute the theta angle
   * and determine the area number. */
  function qsc_fwd_equat_face_theta(phi, y, x, area) {
    var theta;
    if (phi < EPSLN) {
      area.value = AREA_ENUM.AREA_0;
      theta = 0.0;
    } else {
      theta = Math.atan2(y, x);
      if (Math.abs(theta) <= FORTPI) {
        area.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }

  /* Helper function: shift the longitude. */
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }

  var names$3 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc = {
    init: init$3,
    forward: forward$3,
    inverse: inverse$3,
    names: names$3
  };

  // Robinson projection

  var COEFS_X = [
      [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
      [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
      [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
      [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
      [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
      [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
      [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
      [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
      [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
      [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
      [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
      [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
      [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
      [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
      [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
      [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
      [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
      [0.5722, -0.00906601, 0.000182, 6.24051e-06],
      [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
  ];

  var COEFS_Y = [
      [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
      [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
      [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
      [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
      [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
      [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
      [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
      [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
      [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
      [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
      [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
      [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
      [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
      [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
      [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
      [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
      [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
      [0.9761, 0.00616527, -0.000256, -4.2106e-06],
      [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
  ];

  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D/5; // rad to 5-degree interval
  var RC1 = 1/C1;
  var NODES = 18;

  var poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
  };

  var poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
  };

  function newton_rapshon(f_df, start, max_err, iters) {
      var x = start;
      for (; iters; --iters) {
          var upd = f_df(x);
          x -= upd;
          if (Math.abs(upd) < max_err) {
              break;
          }
      }
      return x;
  }

  function init$2() {
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.long0 = this.long0 || 0;
      this.es = 0;
      this.title = this.title || "Robinson";
  }

  function forward$2(ll) {
      var lon = adjust_lon(ll.x - this.long0);

      var dphi = Math.abs(ll.y);
      var i = Math.floor(dphi * C1);
      if (i < 0) {
          i = 0;
      } else if (i >= NODES) {
          i = NODES - 1;
      }
      dphi = R2D * (dphi - RC1 * i);
      var xy = {
          x: poly3_val(COEFS_X[i], dphi) * lon,
          y: poly3_val(COEFS_Y[i], dphi)
      };
      if (ll.y < 0) {
          xy.y = -xy.y;
      }

      xy.x = xy.x * this.a * FXC + this.x0;
      xy.y = xy.y * this.a * FYC + this.y0;
      return xy;
  }

  function inverse$2(xy) {
      var ll = {
          x: (xy.x - this.x0) / (this.a * FXC),
          y: Math.abs(xy.y - this.y0) / (this.a * FYC)
      };

      if (ll.y >= 1) { // pathologic case
          ll.x /= COEFS_X[NODES][0];
          ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
      } else {
          // find table interval
          var i = Math.floor(ll.y * NODES);
          if (i < 0) {
              i = 0;
          } else if (i >= NODES) {
              i = NODES - 1;
          }
          for (;;) {
              if (COEFS_Y[i][0] > ll.y) {
                  --i;
              } else if (COEFS_Y[i+1][0] <= ll.y) {
                  ++i;
              } else {
                  break;
              }
          }
          // linear interpolation in 5 degree interval
          var coefs = COEFS_Y[i];
          var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
          // find t so that poly3_val(coefs, t) = ll.y
          t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
          }, t, EPSLN, 100);

          ll.x /= poly3_val(COEFS_X[i], t);
          ll.y = (5 * i + t) * D2R$1;
          if (xy.y < 0) {
              ll.y = -ll.y;
          }
      }

      ll.x = adjust_lon(ll.x + this.long0);
      return ll;
  }

  var names$2 = ["Robinson", "robin"];
  var robin = {
    init: init$2,
    forward: forward$2,
    inverse: inverse$2,
    names: names$2
  };

  function init$1() {
      this.name = 'geocent';

  }

  function forward$1(p) {
      var point = geodeticToGeocentric(p, this.es, this.a);
      return point;
  }

  function inverse$1(p) {
      var point = geocentricToGeodetic(p, this.es, this.a, this.b);
      return point;
  }

  var names$1 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
  var geocent = {
      init: init$1,
      forward: forward$1,
      inverse: inverse$1,
      names: names$1
  };

  var mode = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  };

  var params = {
    h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
    azi:   { def: 0, num: true, degrees: true }, // default is North
    tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
    long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
    lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
  };

  function init() {
    Object.keys(params).forEach(function (p) {
      if (typeof this[p] === "undefined") {
        this[p] = params[p].def;
      } else if (params[p].num && isNaN(this[p])) {
        throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
      } else if (params[p].num) {
        this[p] = parseFloat(this[p]);
      }
      if (params[p].degrees) {
        this[p] = this[p] * D2R$1;
      }
    }.bind(this));

    if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
      this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
    } else if (Math.abs(this.lat0) < EPSLN) {
      this.mode = mode.EQUIT;
    } else {
      this.mode = mode.OBLIQ;
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }

    this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

    if (this.pn1 <= 0 || this.pn1 > 1e10) {
      throw new Error("Invalid height");
    }
    
    this.p = 1 + this.pn1;
    this.rp = 1 / this.p;
    this.h1 = 1 / this.pn1;
    this.pfact = (this.p + 1) * this.h1;
    this.es = 0;

    var omega = this.tilt;
    var gamma = this.azi;
    this.cg = Math.cos(gamma);
    this.sg = Math.sin(gamma);
    this.cw = Math.cos(omega);
    this.sw = Math.sin(omega);
  }

  function forward(p) {
    p.x -= this.long0;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var coslam = Math.cos(p.x);
    var x, y;
    switch (this.mode) {
      case mode.OBLIQ:
        y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y = cosphi * coslam;
        break;
      case mode.S_POLE:
        y = -sinphi;
        break;
      case mode.N_POLE:
        y = sinphi;
        break;
    }
    y = this.pn1 / (this.p - y);
    x = y * cosphi * Math.sin(p.x);

    switch (this.mode) {
      case mode.OBLIQ:
        y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y *= sinphi;
        break;
      case mode.N_POLE:
        y *= -(cosphi * coslam);
        break;
      case mode.S_POLE:
        y *= cosphi * coslam;
        break;
    }

    // Tilt 
    var yt, ba;
    yt = y * this.cg + x * this.sg;
    ba = 1 / (yt * this.sw * this.h1 + this.cw);
    x = (x * this.cg - y * this.sg) * this.cw * ba;
    y = yt * ba;

    p.x = x * this.a;
    p.y = y * this.a;
    return p;
  }

  function inverse(p) {
    p.x /= this.a;
    p.y /= this.a;
    var r = { x: p.x, y: p.y };

    // Un-Tilt
    var bm, bq, yt;
    yt = 1 / (this.pn1 - p.y * this.sw);
    bm = this.pn1 * p.x * yt;
    bq = this.pn1 * p.y * this.cw * yt;
    p.x = bm * this.cg + bq * this.sg;
    p.y = bq * this.cg - bm * this.sg;

    var rh = hypot(p.x, p.y);
    if (Math.abs(rh) < EPSLN) {
      r.x = 0;
      r.y = p.y;
    } else {
      var cosz, sinz;
      sinz = 1 - rh * rh * this.pfact;
      sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
      cosz = Math.sqrt(1 - sinz * sinz);
      switch (this.mode) {
        case mode.OBLIQ:
          r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
          p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
          p.x *= sinz * this.cosph0;
          break;
        case mode.EQUIT:
          r.y = Math.asin(p.y * sinz / rh);
          p.y = cosz * rh;
          p.x *= sinz;
          break;
        case mode.N_POLE:
          r.y = Math.asin(cosz);
          p.y = -p.y;
          break;
        case mode.S_POLE:
          r.y = -Math.asin(cosz);
          break;
      }
      r.x = Math.atan2(p.x, p.y);
    }

    p.x = r.x + this.long0;
    p.y = r.y;
    return p;
  }

  var names = ["Tilted_Perspective", "tpers"];
  var tpers = {
    init: init,
    forward: forward,
    inverse: inverse,
    names: names
  };

  function includedProjections(proj4){
    proj4.Proj.projections.add(tmerc);
    proj4.Proj.projections.add(etmerc);
    proj4.Proj.projections.add(utm);
    proj4.Proj.projections.add(sterea);
    proj4.Proj.projections.add(stere);
    proj4.Proj.projections.add(somerc);
    proj4.Proj.projections.add(omerc);
    proj4.Proj.projections.add(lcc);
    proj4.Proj.projections.add(krovak);
    proj4.Proj.projections.add(cass);
    proj4.Proj.projections.add(laea);
    proj4.Proj.projections.add(aea);
    proj4.Proj.projections.add(gnom);
    proj4.Proj.projections.add(cea);
    proj4.Proj.projections.add(eqc);
    proj4.Proj.projections.add(poly);
    proj4.Proj.projections.add(nzmg);
    proj4.Proj.projections.add(mill);
    proj4.Proj.projections.add(sinu);
    proj4.Proj.projections.add(moll);
    proj4.Proj.projections.add(eqdc);
    proj4.Proj.projections.add(vandg);
    proj4.Proj.projections.add(aeqd);
    proj4.Proj.projections.add(ortho);
    proj4.Proj.projections.add(qsc);
    proj4.Proj.projections.add(robin);
    proj4.Proj.projections.add(geocent);
    proj4.Proj.projections.add(tpers);
  }

  proj4.defaultDatum = 'WGS84'; //default datum
  proj4.Proj = Projection$2;
  proj4.WGS84 = new proj4.Proj('WGS84');
  proj4.Point = Point$2;
  proj4.toPoint = common;
  proj4.defs = defs;
  proj4.nadgrid = nadgrid;
  proj4.transform = transform$5;
  proj4.mgrs = mgrs;
  proj4.version = '__VERSION__';
  includedProjections(proj4);

  /**
   * @module ol/proj/Units
   */
  /**
   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
   * `'us-ft'`.
   * @enum {string}
   */
  var Units = {
      /**
       * Degrees
       * @api
       */
      DEGREES: 'degrees',
      /**
       * Feet
       * @api
       */
      FEET: 'ft',
      /**
       * Meters
       * @api
       */
      METERS: 'm',
      /**
       * Pixels
       * @api
       */
      PIXELS: 'pixels',
      /**
       * Tile Pixels
       * @api
       */
      TILE_PIXELS: 'tile-pixels',
      /**
       * US Feet
       * @api
       */
      USFEET: 'us-ft',
  };
  /**
   * Meters per unit lookup table.
   * @const
   * @type {Object<Units, number>}
   * @api
   */
  var METERS_PER_UNIT$1 = {};
  // use the radius of the Normal sphere
  METERS_PER_UNIT$1[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
  METERS_PER_UNIT$1[Units.FEET] = 0.3048;
  METERS_PER_UNIT$1[Units.METERS] = 1;
  METERS_PER_UNIT$1[Units.USFEET] = 1200 / 3937;
  var Units$1 = Units;

  /**
   * @module ol/proj/Projection
   */
  /**
   * @typedef {Object} Options
   * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
   * @property {import("./Units.js").default|string} [units] Units. Required unless a
   * proj4 projection is defined for `code`.
   * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
   * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
   * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
   * @property {number} [metersPerUnit] The meters per unit for the SRS.
   * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
   * lookup table.
   * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
   * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
   * Function to determine resolution at a point. The function is called with a
   * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
   * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
   * the default {@link module:ol/proj#getPointResolution} function will be used.
   */
  /**
   * @classdesc
   * Projection definition class. One of these is created for each projection
   * supported in the application and stored in the {@link module:ol/proj} namespace.
   * You can use these in applications, but this is not required, as API params
   * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
   * code will suffice.
   *
   * You can use {@link module:ol/proj~get} to retrieve the object for a particular
   * projection.
   *
   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
   * with the following aliases:
   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
   *     http://www.opengis.net/gml/srs/epsg.xml#4326,
   *     urn:x-ogc:def:crs:EPSG:4326
   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
   *     urn:ogc:def:crs:EPSG:6.18:3:3857,
   *     http://www.opengis.net/gml/srs/epsg.xml#3857
   *
   * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
   * be added using `proj4.defs()`. After all required projection definitions are
   * added, call the {@link module:ol/proj/proj4~register} function.
   *
   * @api
   */
  var Projection = /** @class */ (function () {
      /**
       * @param {Options} options Projection options.
       */
      function Projection(options) {
          /**
           * @private
           * @type {string}
           */
          this.code_ = options.code;
          /**
           * Units of projected coordinates. When set to `TILE_PIXELS`, a
           * `this.extent_` and `this.worldExtent_` must be configured properly for each
           * tile.
           * @private
           * @type {import("./Units.js").default}
           */
          this.units_ = /** @type {import("./Units.js").default} */ (options.units);
          /**
           * Validity extent of the projection in projected coordinates. For projections
           * with `TILE_PIXELS` units, this is the extent of the tile in
           * tile pixel space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = options.extent !== undefined ? options.extent : null;
          /**
           * Extent of the world in EPSG:4326. For projections with
           * `TILE_PIXELS` units, this is the extent of the tile in
           * projected coordinate space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.worldExtent_ =
              options.worldExtent !== undefined ? options.worldExtent : null;
          /**
           * @private
           * @type {string}
           */
          this.axisOrientation_ =
              options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
          /**
           * @private
           * @type {boolean}
           */
          this.global_ = options.global !== undefined ? options.global : false;
          /**
           * @private
           * @type {boolean}
           */
          this.canWrapX_ = !!(this.global_ && this.extent_);
          /**
           * @private
           * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
           */
          this.getPointResolutionFunc_ = options.getPointResolution;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          this.defaultTileGrid_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      Projection.prototype.canWrapX = function () {
          return this.canWrapX_;
      };
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      Projection.prototype.getCode = function () {
          return this.code_;
      };
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").default} Units.
       * @api
       */
      Projection.prototype.getUnits = function () {
          return this.units_;
      };
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      Projection.prototype.getMetersPerUnit = function () {
          return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
      };
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getWorldExtent = function () {
          return this.worldExtent_;
      };
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      Projection.prototype.getAxisOrientation = function () {
          return this.axisOrientation_;
      };
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      Projection.prototype.isGlobal = function () {
          return this.global_;
      };
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      Projection.prototype.setGlobal = function (global) {
          this.global_ = global;
          this.canWrapX_ = !!(global && this.extent_);
      };
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      Projection.prototype.getDefaultTileGrid = function () {
          return this.defaultTileGrid_;
      };
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      Projection.prototype.setDefaultTileGrid = function (tileGrid) {
          this.defaultTileGrid_ = tileGrid;
      };
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Projection.prototype.setExtent = function (extent) {
          this.extent_ = extent;
          this.canWrapX_ = !!(this.global_ && extent);
      };
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      Projection.prototype.setWorldExtent = function (worldExtent) {
          this.worldExtent_ = worldExtent;
      };
      /**
       * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      Projection.prototype.setGetPointResolution = function (func) {
          this.getPointResolutionFunc_ = func;
      };
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      Projection.prototype.getPointResolutionFunc = function () {
          return this.getPointResolutionFunc_;
      };
      return Projection;
  }());
  var Projection$1 = Projection;

  /**
   * @module ol/math
   */
  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param {number} value The input number.
   * @param {number} min The minimum value to return.
   * @param {number} max The maximum value to return.
   * @return {number} The input number if it is within bounds, or the nearest
   *     number within the bounds.
   */
  function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
  }
  /**
   * Return the hyperbolic cosine of a given number. The method will use the
   * native `Math.cosh` function if it is available, otherwise the hyperbolic
   * cosine will be calculated via the reference implementation of the Mozilla
   * developer network.
   *
   * @param {number} x X.
   * @return {number} Hyperbolic cosine of x.
   */
  var cosh = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var cosh;
      if ('cosh' in Math) {
          // The environment supports the native Math.cosh function, use it…
          cosh = Math.cosh;
      }
      else {
          // … else, use the reference implementation of MDN:
          cosh = function (x) {
              var y = /** @type {Math} */ (Math).exp(x);
              return (y + 1 / y) / 2;
          };
      }
      return cosh;
  })();

  var __extends$2 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Radius of WGS84 sphere
   *
   * @const
   * @type {number}
   */
  var RADIUS$2 = 6378137;
  /**
   * @const
   * @type {number}
   */
  var HALF_SIZE = Math.PI * RADIUS$2;
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var WORLD_EXTENT = [-180, -85, 180, 85];
  /**
   * Maximum safe value in y direction
   * @const
   * @type {number}
   */
  var MAX_SAFE_Y = RADIUS$2 * Math.log(Math.tan(Math.PI / 2));
  /**
   * @classdesc
   * Projection object for web/spherical Mercator (EPSG:3857).
   */
  var EPSG3857Projection = /** @class */ (function (_super) {
      __extends$2(EPSG3857Projection, _super);
      /**
       * @param {string} code Code.
       */
      function EPSG3857Projection(code) {
          return _super.call(this, {
              code: code,
              units: Units$1.METERS,
              extent: EXTENT$1,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function (resolution, point) {
                  return resolution / cosh(point[1] / RADIUS$2);
              },
          }) || this;
      }
      return EPSG3857Projection;
  }(Projection$1));
  /**
   * Projections equal to EPSG:3857.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS$1 = [
      new EPSG3857Projection('EPSG:3857'),
      new EPSG3857Projection('EPSG:102100'),
      new EPSG3857Projection('EPSG:102113'),
      new EPSG3857Projection('EPSG:900913'),
      new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
  ];
  /**
   * Transformation from EPSG:4326 to EPSG:3857.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function fromEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      for (var i = 0; i < length; i += dimension) {
          output[i] = (HALF_SIZE * input[i]) / 180;
          var y = RADIUS$2 * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
          if (y > MAX_SAFE_Y) {
              y = MAX_SAFE_Y;
          }
          else if (y < -MAX_SAFE_Y) {
              y = -MAX_SAFE_Y;
          }
          output[i + 1] = y;
      }
      return output;
  }
  /**
   * Transformation from EPSG:3857 to EPSG:4326.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function toEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      for (var i = 0; i < length; i += dimension) {
          output[i] = (180 * input[i]) / HALF_SIZE;
          output[i + 1] =
              (360 * Math.atan(Math.exp(input[i + 1] / RADIUS$2))) / Math.PI - 90;
      }
      return output;
  }

  var __extends$1 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Semi-major radius of the WGS84 ellipsoid.
   *
   * @const
   * @type {number}
   */
  var RADIUS$1 = 6378137;
  /**
   * Extent of the EPSG:4326 projection which is the whole world.
   *
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT = [-180, -90, 180, 90];
  /**
   * @const
   * @type {number}
   */
  var METERS_PER_UNIT = (Math.PI * RADIUS$1) / 180;
  /**
   * @classdesc
   * Projection object for WGS84 geographic coordinates (EPSG:4326).
   *
   * Note that OpenLayers does not strictly comply with the EPSG definition.
   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
   */
  var EPSG4326Projection = /** @class */ (function (_super) {
      __extends$1(EPSG4326Projection, _super);
      /**
       * @param {string} code Code.
       * @param {string=} opt_axisOrientation Axis orientation.
       */
      function EPSG4326Projection(code, opt_axisOrientation) {
          return _super.call(this, {
              code: code,
              units: Units$1.DEGREES,
              extent: EXTENT,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: METERS_PER_UNIT,
              worldExtent: EXTENT,
          }) || this;
      }
      return EPSG4326Projection;
  }(Projection$1));
  /**
   * Projections equal to EPSG:4326.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS = [
      new EPSG4326Projection('CRS:84'),
      new EPSG4326Projection('EPSG:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
      new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  ];

  /**
   * @module ol/proj/projections
   */
  /**
   * @type {Object<string, import("./Projection.js").default>}
   */
  var cache$1 = {};
  /**
   * Get a cached projection by code.
   * @param {string} code The code for the projection.
   * @return {import("./Projection.js").default} The projection (if cached).
   */
  function get$3(code) {
      return (cache$1[code] ||
          cache$1[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
          null);
  }
  /**
   * Add a projection to the cache.
   * @param {string} code The projection code.
   * @param {import("./Projection.js").default} projection The projection to cache.
   */
  function add$1(code, projection) {
      cache$1[code] = projection;
  }

  /**
   * @module ol/obj
   */
  /**
   * Polyfill for Object.assign().  Assigns enumerable and own properties from
   * one or more source objects to a target object.
   * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
   *
   * @param {!Object} target The target object.
   * @param {...Object} var_sources The source object(s).
   * @return {!Object} The modified target object.
   */
  var assign$2 = typeof Object.assign === 'function'
      ? Object.assign
      : function (target, var_sources) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== undefined && source !== null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          output[key] = source[key];
                      }
                  }
              }
          }
          return output;
      };

  /**
   * @module ol/proj/transforms
   */
  /**
   * @private
   * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
   */
  var transforms = {};
  /**
   * Registers a conversion function to convert coordinates from the source
   * projection to the destination projection.
   *
   * @param {import("./Projection.js").default} source Source.
   * @param {import("./Projection.js").default} destination Destination.
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  function add(source, destination, transformFn) {
      var sourceCode = source.getCode();
      var destinationCode = destination.getCode();
      if (!(sourceCode in transforms)) {
          transforms[sourceCode] = {};
      }
      transforms[sourceCode][destinationCode] = transformFn;
  }
  /**
   * Get a transform given a source code and a destination code.
   * @param {string} sourceCode The code for the source projection.
   * @param {string} destinationCode The code for the destination projection.
   * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
   */
  function get$2(sourceCode, destinationCode) {
      var transform;
      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
          transform = transforms[sourceCode][destinationCode];
      }
      return transform;
  }

  /**
   * @module ol/extent
   */
  /**
   * Get the width of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Width.
   * @api
   */
  function getWidth(extent) {
      return extent[2] - extent[0];
  }

  /**
   * @module ol/coordinate
   */
  /**
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {number=} opt_sourceExtentWidth Width of the source extent.
   * @return {number} Offset in world widths.
   */
  function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
      var projectionExtent = projection.getExtent();
      var worldsAway = 0;
      if (projection.canWrapX() &&
          (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
          var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
          worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
      }
      return worldsAway;
  }

  /**
   * @module ol/proj
   */
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Output coordinate array (new array, same coordinate
   *     values).
   */
  function cloneTransform(input, opt_output, opt_dimension) {
      var output;
      if (opt_output !== undefined) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          output = opt_output;
      }
      else {
          output = input.slice();
      }
      return output;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Input coordinate array (same array as input).
   */
  function identityTransform(input, opt_output, opt_dimension) {
      if (opt_output !== undefined && input !== opt_output) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          input = opt_output;
      }
      return input;
  }
  /**
   * Add a Projection object to the list of supported projections that can be
   * looked up by their code.
   *
   * @param {Projection} projection Projection instance.
   * @api
   */
  function addProjection(projection) {
      add$1(projection.getCode(), projection);
      add(projection, projection, cloneTransform);
  }
  /**
   * @param {Array<Projection>} projections Projections.
   */
  function addProjections(projections) {
      projections.forEach(addProjection);
  }
  /**
   * Fetches a Projection object for the code specified.
   *
   * @param {ProjectionLike} projectionLike Either a code string which is
   *     a combination of authority and identifier such as "EPSG:4326", or an
   *     existing projection object, or undefined.
   * @return {Projection} Projection object, or null if not in list.
   * @api
   */
  function get$1(projectionLike) {
      return typeof projectionLike === 'string'
          ? get$3(/** @type {string} */ (projectionLike))
          : /** @type {Projection} */ (projectionLike) || null;
  }
  /**
   * Registers transformation functions that don't alter coordinates. Those allow
   * to transform between projections with equal meaning.
   *
   * @param {Array<Projection>} projections Projections.
   * @api
   */
  function addEquivalentProjections(projections) {
      addProjections(projections);
      projections.forEach(function (source) {
          projections.forEach(function (destination) {
              if (source !== destination) {
                  add(source, destination, cloneTransform);
              }
          });
      });
  }
  /**
   * Registers transformation functions to convert coordinates in any projection
   * in projection1 to any projection in projection2.
   *
   * @param {Array<Projection>} projections1 Projections with equal
   *     meaning.
   * @param {Array<Projection>} projections2 Projections with equal
   *     meaning.
   * @param {TransformFunction} forwardTransform Transformation from any
   *   projection in projection1 to any projection in projection2.
   * @param {TransformFunction} inverseTransform Transform from any projection
   *   in projection2 to any projection in projection1..
   */
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
      projections1.forEach(function (projection1) {
          projections2.forEach(function (projection2) {
              add(projection1, projection2, forwardTransform);
              add(projection2, projection1, inverseTransform);
          });
      });
  }
  /**
   * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
   * function.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
   *     transform.
   * @return {TransformFunction} Transform function.
   */
  function createTransformFromCoordinateTransform(coordTransform) {
      return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>=} opt_output Output.
       * @param {number=} opt_dimension Dimension.
       * @return {Array<number>} Output.
       */
      function (input, opt_output, opt_dimension) {
          var length = input.length;
          var dimension = opt_dimension !== undefined ? opt_dimension : 2;
          var output = opt_output !== undefined ? opt_output : new Array(length);
          for (var i = 0; i < length; i += dimension) {
              var point = coordTransform([input[i], input[i + 1]]);
              output[i] = point[0];
              output[i + 1] = point[1];
              for (var j = dimension - 1; j >= 2; --j) {
                  output[i + j] = input[i + j];
              }
          }
          return output;
      });
  }
  /**
   * Registers coordinate transform functions to convert coordinates between the
   * source projection and the destination projection.
   * The forward and inverse functions convert coordinate pairs; this function
   * converts these into the functions used internally which also handle
   * extents and coordinate arrays.
   *
   * @param {ProjectionLike} source Source projection.
   * @param {ProjectionLike} destination Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
   *     function (that is, from the source projection to the destination
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
   *     function (that is, from the destination projection to the source
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @api
   */
  function addCoordinateTransforms(source, destination, forward, inverse) {
      var sourceProj = get$1(source);
      var destProj = get$1(destination);
      add(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
      add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
  }
  /**
   * Searches in the list of transform functions for the function for converting
   * coordinates from the source projection to the destination projection.
   *
   * @param {Projection} sourceProjection Source Projection object.
   * @param {Projection} destinationProjection Destination Projection
   *     object.
   * @return {TransformFunction} Transform function.
   */
  function getTransformFromProjections(sourceProjection, destinationProjection) {
      var sourceCode = sourceProjection.getCode();
      var destinationCode = destinationProjection.getCode();
      var transformFunc = get$2(sourceCode, destinationCode);
      if (!transformFunc) {
          transformFunc = identityTransform;
      }
      return transformFunc;
  }
  /**
   * Given the projection-like objects, searches for a transformation
   * function to convert a coordinates array from the source projection to the
   * destination projection.
   *
   * @param {ProjectionLike} source Source.
   * @param {ProjectionLike} destination Destination.
   * @return {TransformFunction} Transform function.
   * @api
   */
  function getTransform(source, destination) {
      var sourceProjection = get$1(source);
      var destinationProjection = get$1(destination);
      return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  /**
   * Transforms a coordinate from source projection to destination projection.
   * This returns a new coordinate (and does not modify the original).
   *
   * See {@link module:ol/proj~transformExtent} for extent transformation.
   * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
   * subclasses for geometry transforms.
   *
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  function transform$4(coordinate, source, destination) {
      var transformFunc = getTransform(source, destination);
      return transformFunc(coordinate, undefined, coordinate.length);
  }
  /**
   * Creates a safe coordinate transform function from a coordinate transform function.
   * "Safe" means that it can handle wrapping of x-coordinates for global projections,
   * and that coordinates exceeding the source projection validity extent's range will be
   * clamped to the validity range.
   * @param {Projection} sourceProj Source projection.
   * @param {Projection} destProj Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
   * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
   */
  function createSafeCoordinateTransform(sourceProj, destProj, transform) {
      return function (coord) {
          var sourceX = coord[0];
          var sourceY = coord[1];
          var transformed, worldsAway;
          if (sourceProj.canWrapX()) {
              var sourceExtent = sourceProj.getExtent();
              var sourceExtentWidth = getWidth(sourceExtent);
              worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
              if (worldsAway) {
                  // Move x to the real world
                  sourceX = sourceX - worldsAway * sourceExtentWidth;
              }
              sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
              sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
              transformed = transform([sourceX, sourceY]);
          }
          else {
              transformed = transform(coord);
          }
          if (worldsAway && destProj.canWrapX()) {
              // Move transformed coordinate back to the offset world
              transformed[0] += worldsAway * getWidth(destProj.getExtent());
          }
          return transformed;
      };
  }
  /**
   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
   * by when this module is executed and should only need to be called again after
   * `clearAllProjections()` is called (e.g. in tests).
   */
  function addCommon() {
      // Add transformations that don't alter coordinates to convert within set of
      // projections with equal meaning.
      addEquivalentProjections(PROJECTIONS$1);
      addEquivalentProjections(PROJECTIONS);
      // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
      // coordinates and back.
      addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
  }
  addCommon();

  /**
   * @module ol/proj/proj4
   */
  /**
   * Make projections defined in proj4 (with `proj4.defs()`) available in
   * OpenLayers.
   *
   * This function should be called whenever changes are made to the proj4
   * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
   * modified by this function.
   *
   * @param {?} proj4 Proj4.
   * @api
   */
  function register$1(proj4) {
      var projCodes = Object.keys(proj4.defs);
      var len = projCodes.length;
      var i, j;
      for (i = 0; i < len; ++i) {
          var code = projCodes[i];
          if (!get$1(code)) {
              var def = proj4.defs(code);
              var units = def.units;
              if (!units && def.projName === 'longlat') {
                  units = Units$1.DEGREES;
              }
              addProjection(new Projection$1({
                  code: code,
                  axisOrientation: def.axis,
                  metersPerUnit: def.to_meter,
                  units: units,
              }));
          }
      }
      for (i = 0; i < len; ++i) {
          var code1 = projCodes[i];
          var proj1 = get$1(code1);
          for (j = 0; j < len; ++j) {
              var code2 = projCodes[j];
              var proj2 = get$1(code2);
              if (!get$2(code1, code2)) {
                  var def1 = proj4.defs(code1);
                  var def2 = proj4.defs(code2);
                  if (def1 === def2) {
                      addEquivalentProjections([proj1, proj2]);
                  }
                  else {
                      // Reset axis because OpenLayers always uses x, y axis order
                      var transform = proj4(assign$2({}, def1, { axis: undefined }), assign$2({}, def2, { axis: undefined }));
                      addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform.forward), createSafeCoordinateTransform(proj2, proj1, transform.inverse));
                  }
              }
          }
      }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var download_min = {exports: {}};

  (function (module, exports) {
  (function(r,l){module.exports=l();})(commonjsGlobal,function(){return function l(a,e,k){function q(a){var h=a.split(/[:;,]/);a=h[1];var h=("base64"==h[2]?atob:decodeURIComponent)(h.pop()),d=h.length,b=0,c=new Uint8Array(d);for(b;b<d;++b)c[b]=h.charCodeAt(b);return new f([c],{type:a})}function m(a,b){if("download"in d)return d.href=a,d.setAttribute("download",n),d.className="download-js-link",d.innerHTML="downloading...",d.style.display="none",document.body.appendChild(d),setTimeout(function(){d.click(),document.body.removeChild(d),!0===b&&setTimeout(function(){g.URL.revokeObjectURL(d.href);},250);},66),!0;if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent))return /^data:/.test(a)&&(a="data:"+a.replace(/^data:([\w\/\-\+]+)/,"application/octet-stream")),!window.open(a)&&confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")&&(location.href=a),!0;var c=document.createElement("iframe");document.body.appendChild(c),!b&&/^data:/.test(a)&&(a="data:"+a.replace(/^data:([\w\/\-\+]+)/,"application/octet-stream")),c.src=a,setTimeout(function(){document.body.removeChild(c);},333);}var g=window,b=k||"application/octet-stream",c=!e&&!k&&a,d=document.createElement("a");k=function(a){return String(a)};var f=g.Blob||g.MozBlob||g.WebKitBlob||k,n=e||"download",f=f.call?f.bind(g):Blob;"true"===String(this)&&(a=[a,b],b=a[0],a=a[1]);if(c&&2048>c.length&&(n=c.split("/").pop().split("?")[0],d.href=c,-1!==d.href.indexOf(c))){var p=new XMLHttpRequest;return p.open("GET",c,!0),p.responseType="blob",p.onload=function(a){l(a.target.response,n,"application/octet-stream");},setTimeout(function(){p.send();},0),p}if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(a)){if(!(2096103.424<a.length&&f!==k))return navigator.msSaveBlob?navigator.msSaveBlob(q(a),n):m(a);a=q(a),b=a.type||"application/octet-stream";}else if(/([\x80-\xff])/.test(a)){e=0;var c=new Uint8Array(a.length),t=c.length;for(e;e<t;++e)c[e]=a.charCodeAt(e);a=new f([c],{type:b});}a=a instanceof f?a:new f([a],{type:b});if(navigator.msSaveBlob)return navigator.msSaveBlob(a,n);if(g.URL)m(g.URL.createObjectURL(a),!0);else {if("string"==typeof a||a.constructor===k)try{return m("data:"+b+";base64,"+g.btoa(a))}catch(h){return m("data:"+b+","+encodeURIComponent(a))}b=new FileReader,b.onload=function(a){m(this.result);},b.readAsDataURL(a);}return !0}});
  }(download_min));

  var download = download_min.exports;

  /**
   * 错误提示
   *
   * @export
   * @enum {number}
   */
  var ErrorNotification;
  (function (ErrorNotification) {
      ErrorNotification["NOT_IMPLEMENTED"] = "\u672A\u5B9E\u73B0";
      ErrorNotification["NOT_SUPPORTED"] = "\u6B64\u529F\u80FD\u8BE5\u5F15\u64CE\u4E0D\u652F\u6301";
      ErrorNotification["NOT_COMMEND"] = "\u8BE5\u56FE\u5C42\u4E3A\u805A\u5408\u56FE\u5C42\u65F6\uFF0C\u4E0D\u63A8\u8350\u4F7F\u7528\u8BE5\u65B9\u6CD5\u6DFB\u52A0\u8981\u7D20\uFF0C\u6B64\u65B9\u6CD5\u65E0\u6548\uFF0C\u8BF7\u4F7F\u7528addFeatures\u65B9\u6CD5\u6DFB\u52A0\u8981\u7D20";
      ErrorNotification["DESTROYED"] = "\u5BF9\u8C61\u5DF2\u88AB\u9500\u6BC1";
      ErrorNotification["UNEXPECTED_DATA_FORMAT"] = "\u4E1A\u52A1\u6570\u636E\u683C\u5F0F\u9519\u8BEF";
      ErrorNotification["UNSUPPORTED_PARAM"] = "\u53C2\u6570\u9519\u8BEF";
      ErrorNotification["OPTIONS_UNDEFINED"] = "\u53C2\u6570\u672A\u5B9A\u4E49";
      ErrorNotification["NOT_SUPPORTED_STYLE_TYPE"] = "\u4E0D\u652F\u6301\u8BE5\u7C7B\u578B\u6837\u5F0F";
      ErrorNotification["WALL_COORDINATES_NEED_HEIGHT"] = "\u5899\u4F53\u5750\u6807\u9700\u8981\u8BBE\u7F6E\u9AD8\u5EA6";
      ErrorNotification["NOT_ADD_MAP"] = "\u8BE5\u793A\u4F8B\u672A\u6DFB\u52A0\u5230\u5730\u56FE\u4E2D\uFF0C\u65E0\u6CD5\u6FC0\u6D3B";
      ErrorNotification["NOT_SUPPORTED_GEOJSON_TYPE"] = "geoJson\u7C7B\u578B\u6709\u8BEF";
      ErrorNotification["NOT_MODELTYPE_SUPPORTED"] = "\u8BE5\u6A21\u578B\u5E95\u5C42\u4F7F\u7528\u56FE\u5143\u6E32\u67D3\uFF0C\u4E0D\u652F\u6301\u81EA\u65CB\u8F6C\u52A8\u753B\uFF0C\u8BF7\u5B9E\u4F8B\u5316\u8BE5\u6A21\u578B\u65F6\u6307\u660E\u8BE5\u6A21\u578B\u7C7B\u578B\u4E3A\u5B9E\u4F53\uFF0C\u6216\u8005\u4F7F\u7528\u9ED8\u8BA4";
      ErrorNotification["ADDED_FEATURE"] = "\u8BE5\u8981\u7D20\u5DF2\u6DFB\u52A0\u81F3\u56FE\u5C42\uFF0C\u8BF7\u52FF\u518D\u6B21\u6DFB\u52A0";
  })(ErrorNotification || (ErrorNotification = {}));

  /**
   * 内部公共方法  不外暴露
   */
  /**
   * 判断className是否具有后续传入的名称,不需要则添加
   */
  function initClassName(className, defaultName) {
      var e_1, _a;
      if (defaultName === void 0) { defaultName = []; }
      className || (className = "");
      Array.isArray(defaultName) || (defaultName = [defaultName]);
      try {
          for (var defaultName_1 = __values(defaultName), defaultName_1_1 = defaultName_1.next(); !defaultName_1_1.done; defaultName_1_1 = defaultName_1.next()) {
              var name_1 = defaultName_1_1.value;
              className.includes(name_1) || (className = className + " " + name_1);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (defaultName_1_1 && !defaultName_1_1.done && (_a = defaultName_1.return)) _a.call(defaultName_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
      return className;
  }
  /**
   * 删除对象所有属性
   *
   * @param object
   */
  function clearProperty(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * 首字母大写
   *
   * @param {string} text
   * @returns {string}
   */
  function upperCaseFirstWord(text) {
      return text && text.slice(0, 1).toLocaleUpperCase() + text.slice(1, text.length);
  }
  function initTooltipElement() {
      var dom = document.createElement("div");
      dom.classList.add("tooltip-container");
      dom.classList.add("is-top");
      dom.classList.add("is-dark");
      dom.appendChild(document.createElement("div"));
      var arrow = document.createElement("div");
      arrow.classList.add("popper-arrow");
      dom.appendChild(arrow);
      return dom;
  }
  /**
   * @ignore
   */
  function replaceText(text, properties) {
      var e_2, _a;
      if (properties === void 0) { properties = {}; }
      if (/{|}/g.test(text)) {
          try {
              for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var key = _c.value;
                  text = text.replace(new RegExp("{" + key + "}", "g"), properties[key]);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
      }
      return text;
  }
  function heightToZoom(height) {
      var A = 40487.57;
      var B = 0.00007096758;
      var C = 91610.74;
      var D = -40467.74;
      // return Math.round(D + (A - D) / (1 + Math.pow(height / C, B)));
      return D + (A - D) / (1 + Math.pow(height / C, B)) + 1;
  }
  function zoomToHeight(zoom) {
      var A = 40487.57;
      var B = 0.00007096758;
      var C = 91610.74;
      var D = -40467.74;
      return Math.pow((A - D) / (zoom - 1 - D) - 1, 1 / B) * C;
  }
  function createContextMenuElement(options, event) {
      var e_3, _a;
      var menuElement = document.createElement("ul");
      menuElement.classList.add("context-menu");
      menuElement.classList.add(options.theme);
      try {
          for (var _b = __values(options.list), _c = _b.next(); !_c.done; _c = _b.next()) {
              var item = _c.value;
              var itemElement = document.createElement("li");
              itemElement.classList.add("item");
              itemElement.innerHTML = item.text;
              itemElement.setAttribute("data-id", item.id);
              menuElement.appendChild(itemElement);
              itemElement.onclick = event;
          }
      }
      catch (e_3_1) { e_3 = { error: e_3_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_3) throw e_3.error; }
      }
      return menuElement;
  }
  function clearContextMenuElementEvent(element) {
      var e_4, _a;
      try {
          for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
              var iterator = _c.value;
              iterator.onclick = void 0;
          }
      }
      catch (e_4_1) { e_4 = { error: e_4_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_4) throw e_4.error; }
      }
  }
  /**
   * 设置要素坐标系配置
   *
   * @param this
   * @param options
   */
  function setFeatureProjection(options) {
      if (options === null || options === void 0 ? void 0 : options.dataProjection) {
          this._dataProjection = options === null || options === void 0 ? void 0 : options.dataProjection;
      }
      if (options === null || options === void 0 ? void 0 : options.projection) {
          this._projection = options === null || options === void 0 ? void 0 : options.projection;
      }
      if (options === null || options === void 0 ? void 0 : options.offset) {
          this._offset = options === null || options === void 0 ? void 0 : options.offset;
      }
  }
  function isObject$a(value) {
      var type = typeof value;
      return value !== null && (type === "object" || type === "function");
  }
  function vertifyParam(options, keys) {
      var e_5, _a;
      if (keys === void 0) { keys = []; }
      if (!defined$1(options)) {
          throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
      }
      try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
              var key = keys_1_1.value;
              if (!defined$1(getValueByChaining(options, key))) {
                  throw new Error("".concat(key, " ").concat(ErrorNotification.OPTIONS_UNDEFINED));
              }
          }
      }
      catch (e_5_1) { e_5 = { error: e_5_1 }; }
      finally {
          try {
              if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          }
          finally { if (e_5) throw e_5.error; }
      }
  }
  /**
   * 链式取值
   */
  function getValueByChaining(target, chaining) {
      return chaining.split(".").reduce(function (prev, curr) {
          return prev === null || prev === void 0 ? void 0 : prev[curr];
      }, target);
  }
  function computeRotationRadians(startCoordinates, endCoordinates) {
      return ((Math.PI * 2.5 - Math.atan2(endCoordinates[1] - startCoordinates[1], endCoordinates[0] - startCoordinates[0])) %
          (Math.PI * 2));
  }
  /**
   * 将item添加到selfArray数组内
   */
  function arraySelfConcat(selfArray, item) {
      if (Array.isArray(item)) {
          for (var index = 0, length_1 = item.length; index < length_1; index++) {
              selfArray[selfArray.length] = item[index];
          }
      }
      else {
          selfArray[selfArray.length] = item;
      }
  }

  /**
   * 判断对象是否存在
   *
   * @param val
   * @returns
   */
  function defined$1(val) {
      return val !== void 0 && val !== null;
  }
  /**
   * 角度转弧度
   *
   * @param degrees 角度值
   * @returns
   */
  function toRadians(degrees) {
      return (degrees * Math.PI) / 180;
  }
  /**
   * 弧度转角度
   *
   * @param radians 弧度值
   * @returns
   */
  function toDegrees(radians) {
      return (radians * 180) / Math.PI;
  }
  /**
   * 经纬度圆半径转化为投影圆半径
   *
   * @ignore
   * @param center
   * @param radius
   * @returns
   */
  function convertToProjectionRadius(center, radius, featureProjection) {
      if (featureProjection === void 0) { featureProjection = PUBLIC_CONFIG.projection; }
      return (transformInternal(Turf__namespace.transformTranslate(Turf__namespace.point(center), radius / 1000, 90).geometry.coordinates, {
          source: WGS84_PROJECTION_NAME,
          destination: featureProjection
      })[0] - transformInternal(center, { source: WGS84_PROJECTION_NAME, destination: featureProjection })[0]);
  }
  /**
   * 将投影圆半径转化为经纬度圆半径
   *
   * @ignore
   * @param point
   * @param distance
   * @returns
   */
  function calculatesDistance(point, distance) {
      return Number.parseFloat((Turf__namespace.distance(transformToDataProjection(point), transformToDataProjection([point[0], point[1] + distance])) * 1000).toFixed(4));
  }
  /**
   * @ignore
   * @param start
   * @param end
   * @returns
   */
  function calculatesRadius(start, end) {
      return Number.parseFloat(Turf__namespace.distance(start, end).toFixed(4));
  }
  /**
   * @ignore
   * @param center
   * @param radius
   * @returns
   */
  function getCircleCoordinates(center, radius) {
      return Turf__namespace.circle(center, radius, { steps: 20, units: "kilometers" }).geometry.coordinates[0];
  }
  /**
   * 根据起始点生成经过两点之间的抛物线的坐标数组
   */
  function createParabola(
  /**
   * 起始点GeoJSON
   */
  startPoint, 
  /**
   * 结束点GeoJSON
   */
  endPoint, options) {
      if (options === void 0) { options = {}; }
      var _a = options.heightProportion, heightProportion = _a === void 0 ? 0.125 : _a, _b = options.step, step = _b === void 0 ? 60 : _b;
      var _c = __read(startPoint, 3), lng1 = _c[0], lat1 = _c[1], _d = _c[2], height1 = _d === void 0 ? 0 : _d;
      var _e = __read(endPoint, 3), lng2 = _e[0], lat2 = _e[1], _f = _e[2], height2 = _f === void 0 ? 0 : _f;
      // const heightProportion = 0.125 // 最高点和总距离的比值
      var dLon = (lng2 - lng1) / step;
      var dLat = (lat2 - lat1) / step;
      var dHei = (height2 - height1) / step;
      var deltaLon = dLon * Math.abs(111000 * Math.cos((lat1 / 180) * Math.PI)); // 经度差（米）
      var deltaLat = dLat * 111000; // 纬度差(米)
      var interPolatePoint = [];
      interPolatePoint.push([lng1, lat1, height1]);
      var height = (step * Math.sqrt(deltaLon * deltaLon + deltaLat * deltaLat) * heightProportion).toFixed(0);
      var x2 = "1"; //(10000 * Math.sqrt(dLon * dLon + dLat * dLat)).toFixed(0) // 提高经度--
      var a = Number.parseFloat(height) / (Number.parseFloat(x2) * Number.parseFloat(x2));
      function y(x, height) {
          return height - a * x * x;
      }
      for (var i = 1; i < step; i++) {
          // 计算插值
          var _lon = lng1 + dLon * i;
          var _lat = lat1 + dLat * i;
          var _hei = height1 + dHei * i;
          var x = Number.parseFloat(x2) * ((2 * i) / step - 1);
          var _height = Number.parseFloat(y(x, height).toFixed(0));
          interPolatePoint.push([_lon, _lat, _height + _hei]);
      }
      interPolatePoint.push([lng2, lat2, height2]);
      return interPolatePoint;
  }
  /**
   * @ignore
   * @param fileName
   * @param dataURL
   * @param mimeType
   */
  function saveDataURL(fileName, dataURL, mimeType) {
      download(dataURL, fileName, mimeType);
  }
  /**
   * 计算起点与终点形成的方向与北方向的夹角（角度）
   */
  function calculateNorthAngleDegrees(starCoordinate, endCoordinate) {
      return toDegrees(computeRotationRadians(starCoordinate, endCoordinate));
  }

  var wellknown$1 = {exports: {}};

  /*eslint-disable no-cond-assign */

  wellknown$1.exports = parse$2;
  wellknown$1.exports.parse = parse$2;
  wellknown$1.exports.stringify = stringify;

  var numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;
  // Matches sequences like '100 100' or '100 100 100'.
  var tuples = new RegExp('^' + numberRegexp.source + '(\\s' + numberRegexp.source + '){1,}');

  /*
   * Parse WKT and return GeoJSON.
   *
   * @param {string} _ A WKT geometry
   * @return {?Object} A GeoJSON geometry object
   */
  function parse$2 (input) {
    var parts = input.split(';');
    var _ = parts.pop();
    var srid = (parts.shift() || '').split('=').pop();

    var i = 0;

    function $ (re) {
      var match = _.substring(i).match(re);
      if (!match) return null;
      else {
        i += match[0].length;
        return match[0];
      }
    }

    function crs (obj) {
      if (obj && srid.match(/\d+/)) {
        obj.crs = {
          type: 'name',
          properties: {
            name: 'urn:ogc:def:crs:EPSG::' + srid
          }
        };
      }

      return obj;
    }

    function white () { $(/^\s*/); }

    function multicoords () {
      white();
      var depth = 0;
      var rings = [];
      var stack = [rings];
      var pointer = rings;
      var elem;

      while (elem =
             $(/^(\()/) ||
               $(/^(\))/) ||
                 $(/^(,)/) ||
                   $(tuples)) {
        if (elem === '(') {
          stack.push(pointer);
          pointer = [];
          stack[stack.length - 1].push(pointer);
          depth++;
        } else if (elem === ')') {
          // For the case: Polygon(), ...
          if (pointer.length === 0) return null;

          pointer = stack.pop();
          // the stack was empty, input was malformed
          if (!pointer) return null;
          depth--;
          if (depth === 0) break;
        } else if (elem === ',') {
          pointer = [];
          stack[stack.length - 1].push(pointer);
        } else if (!elem.split(/\s/g).some(isNaN)) {
          Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
        } else {
          return null;
        }
        white();
      }

      if (depth !== 0) return null;

      return rings;
    }

    function coords () {
      var list = [];
      var item;
      var pt;
      while (pt =
             $(tuples) ||
               $(/^(,)/)) {
        if (pt === ',') {
          list.push(item);
          item = [];
        } else if (!pt.split(/\s/g).some(isNaN)) {
          if (!item) item = [];
          Array.prototype.push.apply(item, pt.split(/\s/g).map(parseFloat));
        }
        white();
      }

      if (item) list.push(item);
      else return null;

      return list.length ? list : null;
    }

    function point () {
      if (!$(/^(point(\sz)?)/i)) return null;
      white();
      if (!$(/^(\()/)) return null;
      var c = coords();
      if (!c) return null;
      white();
      if (!$(/^(\))/)) return null;
      return {
        type: 'Point',
        coordinates: c[0]
      };
    }

    function multipoint () {
      if (!$(/^(multipoint)/i)) return null;
      white();
      var newCoordsFormat = _
        .substring(_.indexOf('(') + 1, _.length - 1)
        .replace(/\(/g, '')
        .replace(/\)/g, '');
      _ = 'MULTIPOINT (' + newCoordsFormat + ')';
      var c = multicoords();
      if (!c) return null;
      white();
      return {
        type: 'MultiPoint',
        coordinates: c
      };
    }

    function multilinestring () {
      if (!$(/^(multilinestring)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      white();
      return {
        type: 'MultiLineString',
        coordinates: c
      };
    }

    function linestring () {
      if (!$(/^(linestring(\sz)?)/i)) return null;
      white();
      if (!$(/^(\()/)) return null;
      var c = coords();
      if (!c) return null;
      if (!$(/^(\))/)) return null;
      return {
        type: 'LineString',
        coordinates: c
      };
    }

    function polygon () {
      if (!$(/^(polygon(\sz)?)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      return {
        type: 'Polygon',
        coordinates: c
      };
    }

    function multipolygon () {
      if (!$(/^(multipolygon)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      return {
        type: 'MultiPolygon',
        coordinates: c
      };
    }

    function geometrycollection () {
      var geometries = [];
      var geometry;

      if (!$(/^(geometrycollection)/i)) return null;
      white();

      if (!$(/^(\()/)) return null;
      while (geometry = root()) {
        geometries.push(geometry);
        white();
        $(/^(,)/);
        white();
      }
      if (!$(/^(\))/)) return null;

      return {
        type: 'GeometryCollection',
        geometries: geometries
      };
    }

    function root () {
      return point() ||
        linestring() ||
        polygon() ||
        multipoint() ||
        multilinestring() ||
        multipolygon() ||
        geometrycollection();
    }

    return crs(root());
  }

  /**
   * Stringifies a GeoJSON object into WKT
   */
  function stringify (gj) {
    if (gj.type === 'Feature') {
      gj = gj.geometry;
    }

    function pairWKT (c) {
      return c.join(' ');
    }

    function ringWKT (r) {
      return r.map(pairWKT).join(', ');
    }

    function ringsWKT (r) {
      return r.map(ringWKT).map(wrapParens).join(', ');
    }

    function multiRingsWKT (r) {
      return r.map(ringsWKT).map(wrapParens).join(', ');
    }

    function wrapParens (s) { return '(' + s + ')'; }

    switch (gj.type) {
      case 'Point':
        return 'POINT (' + pairWKT(gj.coordinates) + ')';
      case 'LineString':
        return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';
      case 'Polygon':
        return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';
      case 'MultiPoint':
        return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';
      case 'MultiPolygon':
        return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';
      case 'MultiLineString':
        return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';
      case 'GeometryCollection':
        return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';
      default:
        throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');
    }
  }

  var wellknown = wellknown$1.exports;

  /**
   * 第三方代码
   */
  var geoJsonParse = (function name() {
      // 配置
      var defaultConfig = {
          doThrows: {
              invalidGeometry: false
          }
      };
      var geoms = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeoJSON"];
      var geomAttrs = [];
      function applyDefaults(params, defaults) {
          var settings = params || {};
          settings = Object.assign(defaults, settings);
          return settings;
      }
      function addOptionals(geojson, settings) {
          if (settings.crs && checkCRS(settings.crs)) {
              if (settings.isPostgres)
                  geojson.geometry.crs = settings.crs;
              else
                  geojson.crs = settings.crs;
          }
          if (settings.bbox) {
              geojson.bbox = settings.bbox;
          }
          if (settings.extraGlobal) {
              geojson.properties = {};
              for (var key in settings.extraGlobal) {
                  geojson.properties[key] = settings.extraGlobal[key];
              }
          }
      }
      function checkCRS(crs) {
          if (crs.type === "name") {
              if (crs.properties && crs.properties.name) {
                  return true;
              }
              else {
                  throw new Error("无效的CRS，name属性不存在");
              }
          }
          else if (crs.type === "link") {
              if (crs.properties && crs.properties.href && crs.properties.type) {
                  return true;
              }
              else {
                  throw new Error("无效的CRS，href与type属性不存在");
              }
          }
          else {
              throw new Error("无效的CRS，类型属性必须包含name或link属性");
          }
      }
      function setGeom(params) {
          params.geom = {};
          for (var param in params) {
              if (Object.hasOwnProperty.call(params, param) && geoms.indexOf(param) !== -1) {
                  params.geom[param] = params[param];
                  delete params[param];
              }
          }
          setGeomAttrList(params.geom);
      }
      function setGeomAttrList(params) {
          for (var param in params) {
              if (Object.hasOwnProperty.call(params, param)) {
                  if (typeof params[param] === "string") {
                      geomAttrs.push(params[param]);
                  }
                  else if (typeof params[param] === "object") {
                      geomAttrs.push(params[param][0]);
                      geomAttrs.push(params[param][1]);
                      !params[param][2] || geomAttrs.push(params[param][2]);
                  }
              }
          }
          if (geomAttrs.length === 0) {
              throw new Error("几何属性为空");
          }
      }
      function getFeature(args) {
          var item = args.item;
          var params = args.params;
          var offset = args.offset;
          var propFunc = args.propFunc;
          return {
              type: "Feature",
              geometry: buildGeom(item, params, offset),
              properties: propFunc.call(item)
          };
      }
      function isNested(val) {
          return /^.+\..+$/.test(val);
      }
      function buildGeom(item, params, offset) {
          var geom = {};
          var _loop_1 = function (gtype) {
              var e_1, _a, e_2, _b, e_3, _c;
              var val = params.geom[gtype];
              if (typeof val === "string" && Object.hasOwnProperty.call(item, val)) {
                  if (gtype === "GeoJSON") {
                      geom = item[val];
                  }
                  else {
                      geom.type = gtype;
                      geom.coordinates = offset ? ProjUtil[offset](item[val]) : item[val];
                  }
              }
              else if (typeof val === "object" && !Array.isArray(val)) {
                  var points = Object.keys(val).map(function (key) {
                      var order = val[key];
                      var newItem = item[key];
                      return buildGeom(newItem, { geom: { Point: order } }, offset);
                  });
                  geom.type = gtype;
                  geom.coordinates = [].concat(points.map(function (p) {
                      return offset ? ProjUtil[offset](p.coordinates) : p.coordinates;
                  }));
              }
              else if (Array.isArray(val) &&
                  item.hasOwnProperty(val[0]) &&
                  item.hasOwnProperty(val[1]) &&
                  item.hasOwnProperty(val[2])) {
                  geom.type = gtype;
                  geom.coordinates = [Number(item[val[1]]), Number(item[val[0]]), Number(item[val[2]])];
              }
              else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([Number(item[val[1]]), Number(item[val[0]])])
                      : [Number(item[val[1]]), Number(item[val[0]])];
              }
              else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1]) && isNested(val[2])) {
                  var coordinates = [];
                  for (var i = 0; i < val.length; i++) {
                      var paths = val[i].split(".");
                      var itemClone = item;
                      try {
                          for (var paths_1 = (e_1 = void 0, __values(paths)), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
                              var path = paths_1_1.value;
                              if (!itemClone.hasOwnProperty(path)) {
                                  return { value: false };
                              }
                              itemClone = itemClone[path];
                          }
                      }
                      catch (e_1_1) { e_1 = { error: e_1_1 }; }
                      finally {
                          try {
                              if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                      }
                      coordinates[i] = itemClone;
                  }
                  geom.type = gtype;
                  geom.coordinates = [Number(coordinates[1]), Number(coordinates[0]), Number(coordinates[2])];
              }
              else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                  var coordinates = [];
                  try {
                      for (var val_1 = (e_2 = void 0, __values(val)), val_1_1 = val_1.next(); !val_1_1.done; val_1_1 = val_1.next()) {
                          var iterator = val_1_1.value;
                          var paths = iterator.split(".");
                          var itemClone = item;
                          try {
                              for (var paths_2 = (e_3 = void 0, __values(paths)), paths_2_1 = paths_2.next(); !paths_2_1.done; paths_2_1 = paths_2.next()) {
                                  var path = paths_2_1.value;
                                  if (!itemClone.hasOwnProperty(path)) {
                                      return { value: false };
                                  }
                                  itemClone = itemClone[path];
                              }
                          }
                          catch (e_3_1) { e_3 = { error: e_3_1 }; }
                          finally {
                              try {
                                  if (paths_2_1 && !paths_2_1.done && (_c = paths_2.return)) _c.call(paths_2);
                              }
                              finally { if (e_3) throw e_3.error; }
                          }
                          coordinates.push(itemClone);
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (val_1_1 && !val_1_1.done && (_b = val_1.return)) _b.call(val_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([Number(coordinates[1]), Number(coordinates[0])])
                      : [Number(coordinates[1]), Number(coordinates[0])];
              }
              else if (Array.isArray(val) &&
                  val[0].constructor.name === "Object" &&
                  Object.keys(val[0])[0] === "coordinates") {
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([
                          Number(item.coordinates[val[0].coordinates.indexOf("lng")]),
                          Number(item.coordinates[val[0].coordinates.indexOf("lat")])
                      ])
                      : [
                          Number(item.coordinates[val[0].coordinates.indexOf("lng")]),
                          Number(item.coordinates[val[0].coordinates.indexOf("lat")])
                      ];
              }
              else {
                  throw new Error("传入的数据缺少地理属性");
              }
          };
          for (var gtype in params.geom) {
              var state_1 = _loop_1(gtype);
              if (typeof state_1 === "object")
                  return state_1.value;
          }
          return geom;
      }
      /**
       * 构建属性生成函数
       * @param {*} params
       */
      function getPropFunction(params) {
          var func;
          if (!params.exclude && !params.include) {
              func = function (properties) {
                  for (var attr in this) {
                      if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
                          properties[attr] = this[attr];
                      }
                  }
              };
          }
          else if (params.include) {
              func = function (properties) {
                  params.include.forEach(function (attr) {
                      properties[attr] = this[attr];
                  }, this);
              };
          }
          else if (params.exclude) {
              func = function (properties) {
                  for (var attr in this) {
                      if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
                          properties[attr] = this[attr];
                      }
                  }
              };
          }
          return function () {
              var properties = {};
              func.call(this, properties);
              if (params.extra) {
                  addExtra(properties, params.extra);
              }
              return properties;
          };
      }
      function addExtra(properties, extra) {
          for (var key in extra) {
              if (extra.hasOwnProperty(key)) {
                  properties[key] = extra[key];
              }
          }
          return properties;
      }
      return function (objects, params, offset, callback) {
          if (offset === void 0) { offset = undefined; }
          if (callback === void 0) { callback = undefined; }
          var geojson;
          var settings = applyDefaults(params, __assign$1({}, defaultConfig));
          geomAttrs.length = 0;
          setGeom(settings);
          var propFunc = getPropFunction(settings);
          if (Array.isArray(objects)) {
              geojson = {
                  type: "FeatureCollection",
                  features: []
              };
              objects.forEach(function (item) {
                  geojson.features.push(getFeature({
                      item: item,
                      params: settings,
                      propFunc: propFunc,
                      offset: offset
                  }));
              });
              addOptionals(geojson, settings);
          }
          else {
              geojson = getFeature({
                  item: objects,
                  params: settings,
                  propFunc: propFunc,
                  offset: offset
              });
              addOptionals(geojson, settings);
          }
          if (callback && typeof callback === "function") {
              callback(geojson);
          }
          else {
              return geojson;
          }
      };
  })();
  /**
   * 构造geoJson点要素
   *
   * @param {PointCoordinate} coordinate 点坐标
   * @returns {GeoJsonFeature}
   */
  function point(coordinate, properties) {
      return Turf__namespace.point(coordinate, properties || {});
  }
  /**
   * 构造geoJson面要素
   *
   * @param {PolygonCoordinates} coordinates 面坐标
   * @returns {GeoJsonFeature}
   */
  function polygon$1(coordinates, properties) {
      return Turf__namespace.polygon(coordinates, properties || {});
  }
  /**
   * 构造geoJson线要素
   *
   * @param {LineStringCoordinates} coordinates 线坐标
   * @returns {GeoJsonFeature}
   */
  function lineString(coordinates, properties) {
      return Turf__namespace.lineString(coordinates, properties || {});
  }
  /**
   * 构造geoJson多点要素
   *
   * @param {MultiPointCoordinates} coordinates 多点坐标
   * @returns {GeoJsonFeature}
   */
  function multiPoint(coordinates, properties) {
      return Turf__namespace.multiPoint(coordinates, properties || {});
  }
  /**
   * 构造geoJson多线要素
   *
   * @param {MultiLineStringCoordinates} coordinates 多线坐标
   * @returns {GeoJsonFeature}
   */
  function multiLineString(coordinates, properties) {
      return Turf__namespace.multiLineString(coordinates, properties || {});
  }
  /**
   * 构造geoJson多面要素
   *
   * @param {MultiPolygonCoordinates} coordinates 多面坐标
   * @returns {GeoJsonFeature}
   */
  function multiPolygon(coordinates, properties) {
      return Turf__namespace.multiPolygon(coordinates, properties || {});
  }
  /**
   * 构造geoJson要素对象
   * @param geometry
   * @param properties
   * @returns GeoJsonFeature
   */
  function feature$3(geometry, properties) {
      return Turf__namespace.feature(geometry, properties);
  }
  /**
   * 构造geoJson要素集合对象
   *
   * @param {features} FeatureGeoJSON[] 要素数组
   * @returns {FeatureCollectionGeoJSON}
   */
  function featureCollection(features) {
      return {
          type: GeoJsonType.FEATURE_COLLECTION,
          features: features
      };
  }
  /**
   * 格式化geoJson数据为FeatureCollection
   *
   * @param geoJson
   * @returns
   */
  function normalize$2(geoJson) {
      if (geoJson.type === GeoJsonType.FEATURE) {
          return featureCollection([geoJson]);
      }
      else {
          return featureCollection([feature$3(geoJson)]);
      }
  }
  function featuresToGeoJsonFeatureCollection(features, options) {
      return featureCollection(features.map(function (f) {
          return featureToGeoJsonFeature(f, options);
      }));
  }
  function featureToGeoJsonFeature(f, options) {
      var geoJsonFeature = JSON.parse(JSON.stringify(f.geoJson));
      if ((options === null || options === void 0 ? void 0 : options.offset) || ((options === null || options === void 0 ? void 0 : options.dataProjection) && (options === null || options === void 0 ? void 0 : options.dataProjection) !== f.dataProjection)) {
          transformInternal(geoJsonFeature, {
              source: f.dataProjection,
              destination: (options === null || options === void 0 ? void 0 : options.dataProjection) || f.dataProjection,
              offset: options === null || options === void 0 ? void 0 : options.offset
          });
      }
      return geoJsonFeature;
  }
  function geoJsonToFeature(geoJson, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var result = [];
      if (geoJson.type !== GeoJsonType.FEATURE_COLLECTION) {
          geoJson = normalize$2(geoJson);
      }
      for (var index = 0, len = geoJson.features.length; index < len; index++) {
          var f = geoJson.features[index];
          result.push(geoJsonFeatureToFeature(f, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options));
      }
      return result;
  }
  /**
   * 将业务数据数组转为geoJson
   *
   * **业务数据格式**
   *
   * ```
   * { x: number; y: number; z?: number; [propName: string]: any }[]
   * | { lng: number; lat: number; height?: number; [propName: string]: any }[]
   * | { lon: number; lat: number; height?: number; [propName: string]: any }[];
   * | {
   *     longitude: number;
   *     latitude: number;
   *     height?: number;
   *     [propName: string]: any;
   *   }[]
   * ```
   *
   * @param {Array<object>} data 业务数据对象数组
   * @param {string} offset 偏移类型 可选值：'WGStoGCJ', 'GCJtoWGS','GCJtoBD','BDtoGCJ','WGStoBD','BDtoWGS'
   *
   */
  function dataToGeoJsonFeatureCollection(data, options) {
      if (data.length === 0) {
          return { type: GeoJsonType.FEATURE_COLLECTION, features: [] };
      }
      var _a = data[0], x = _a.x, y = _a.y, lng = _a.lng, lat = _a.lat, longitude = _a.longitude, latitude = _a.latitude, lon = _a.lon;
      var param;
      if (defined$1(x) && defined$1(y)) {
          param = ["y", "x", "z"];
      }
      else if (defined$1(lng) && defined$1(lat)) {
          param = ["lat", "lng", "height"];
      }
      else if (defined$1(longitude) && defined$1(latitude)) {
          param = ["latitude", "longitude", "height"];
      }
      else if (defined$1(lon) && defined$1(lat)) {
          param = ["lat", "lon", "height"];
      }
      else {
          throw new Error(ErrorNotification.UNEXPECTED_DATA_FORMAT);
      }
      return geoJsonParse(data, { Point: param }, options === null || options === void 0 ? void 0 : options.offset);
  }
  function geoJsonFeatureToFeature(geoJson, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var _b = geoJson.type === GeoJsonType.FEATURE ? geoJson.geometry : geoJson, type = _b.type, coordinates = _b.coordinates;
      switch (type) {
          case GeoJsonGeometryType.POINT:
          case GeoJsonGeometryType.MULTI_POINT:
              return new Point(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          case GeoJsonGeometryType.LINE_STRING:
          case GeoJsonGeometryType.MULTI_LINE_STRING:
              return new Polyline(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          case GeoJsonGeometryType.POLYGON:
          case GeoJsonGeometryType.MULTI_POLYGON:
              return new Polygon(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          default:
              throw new Error(ErrorNotification.NOT_SUPPORTED_GEOJSON_TYPE);
      }
  }
  function featuresToWkts(features, options) {
      return features.map(function (f) {
          return featureToWkt(f, options);
      });
  }
  function featureToWkt(f, options) {
      if ((options === null || options === void 0 ? void 0 : options.offset) || ((options === null || options === void 0 ? void 0 : options.dataProjection) && (options === null || options === void 0 ? void 0 : options.dataProjection) !== f.dataProjection)) {
          return geoJsonFeatureToWkt(featureToGeoJsonFeature(f, options));
      }
      return f.wkt;
  }
  function wktsToFeatures(wkts, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      return wkts.map(function (wkt) {
          return wktToFeature(wkt, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options);
      });
  }
  function wktToFeature(wkt, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var geometry = wktToGeoJsonFeature(wkt);
      if (geometry) {
          return geoJsonFeatureToFeature(geometry, {
              Point: Point,
              Polyline: Polyline,
              Polygon: Polygon
          }, options);
      }
      else {
          throw new Error(ErrorNotification.UNSUPPORTED_PARAM);
      }
  }
  function wktToGeoJsonFeature(wkt) {
      return wellknown.parse(wkt);
  }
  function geoJsonFeatureToWkt(geoJson) {
      return wellknown.stringify(geoJson);
  }
  function vectorDataToFeatures(data, _a, options) {
      var Feature = _a.Feature, Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var features = [];
      if (defined$1(data) && Array.isArray(data) && data.length > 0) {
          if (data[0] instanceof Feature) {
              features = data;
          }
          else if (typeof data[0] === "string") {
              features = wktsToFeatures(data, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options);
          }
          else if (typeof data[0] === "object") {
              features = dataToGeoJsonFeatureCollection(data, { offset: options === null || options === void 0 ? void 0 : options.offset }).features.map(function (feature) {
                  return geoJsonFeatureToFeature(feature, { Point: Point, Polyline: Polyline, Polygon: Polygon }, { projection: options === null || options === void 0 ? void 0 : options.projection, dataProjection: options === null || options === void 0 ? void 0 : options.dataProjection });
              });
          }
      }
      else if (!Array.isArray(data) && typeof data === "object") {
          features = geoJsonToFeature(data, { Point: Point, Polygon: Polygon, Polyline: Polyline }, options);
      }
      return features;
  }

  var getProjection = get$1;
  var coordinateOffsetUtil = {
      wgstogcj: _WGStoGCJ,
      gcjtowgs: _GCJtoWGS,
      gcjtobd: _GCJtoBD,
      bdtogcj: _BDtoGCJ,
      wgstobd: _WGStoBD,
      bdtowgs: _BDtoWGS
  };
  /**
   * 注册坐标系
   *
   * @param code 坐标名称
   * @param defs 坐标定义
   * @param extent 坐标范围
   */
  function register(code, defs, extent) {
      proj4.defs(code, defs);
      register$1(proj4);
      var projection = get$1(code);
      extent && projection.setExtent(extent);
  }
  var GPS = {
      PI: parseFloat("3.14159265358979324"),
      x_pi: (parseFloat("3.14159265358979324") * 3000.0) / 180.0,
      delta: function (lat, lon) {
          var a = 6378245.0; //  a: 卫星椭球坐标投影到平面地图坐标系的投影因子。
          var ee = parseFloat("0.00669342162296594323"); //  ee: 椭球的偏心率。
          var dLat = this.transformLat(lon - 105.0, lat - 35.0);
          var dLon = this.transformLon(lon - 105.0, lat - 35.0);
          var radLat = (lat / 180.0) * this.PI;
          var magic = Math.sin(radLat);
          magic = 1 - ee * magic * magic;
          var sqrtMagic = Math.sqrt(magic);
          dLat = (dLat * 180.0) / (((a * (1 - ee)) / (magic * sqrtMagic)) * this.PI);
          dLon = (dLon * 180.0) / ((a / sqrtMagic) * Math.cos(radLat) * this.PI);
          return { lat: dLat, lon: dLon };
      },
      //WGS-84 to GCJ-02
      gcj_encrypt: function (wgsLat, wgsLon) {
          if (this.outOfChina(wgsLat, wgsLon))
              return { lat: wgsLat, lon: wgsLon };
          var d = this.delta(wgsLat, wgsLon);
          return { lat: wgsLat + d.lat, lon: wgsLon + d.lon };
      },
      //GCJ-02 to WGS-84
      gcj_decrypt: function (gcjLat, gcjLon) {
          if (this.outOfChina(gcjLat, gcjLon))
              return { lat: gcjLat, lon: gcjLon };
          var d = this.delta(gcjLat, gcjLon);
          return { lat: gcjLat - d.lat, lon: gcjLon - d.lon };
      },
      //GCJ-02 to WGS-84
      gcj_decrypt_exact: function (gcjLat, gcjLon) {
          var initDelta = 0.01;
          var threshold = 0.000000001;
          var dLat = initDelta, dLon = initDelta;
          var mLat = gcjLat - dLat, mLon = gcjLon - dLon;
          var pLat = gcjLat + dLat, pLon = gcjLon + dLon;
          var wgsLat, wgsLon, i = 0;
          while (1) {
              wgsLat = (mLat + pLat) / 2;
              wgsLon = (mLon + pLon) / 2;
              var tmp = this.gcj_encrypt(wgsLat, wgsLon);
              dLat = tmp.lat - gcjLat;
              dLon = tmp.lon - gcjLon;
              if (Math.abs(dLat) < threshold && Math.abs(dLon) < threshold)
                  break;
              if (dLat > 0)
                  pLat = wgsLat;
              else
                  mLat = wgsLat;
              if (dLon > 0)
                  pLon = wgsLon;
              else
                  mLon = wgsLon;
              if (++i > 10000)
                  break;
          }
          return { lat: wgsLat, lon: wgsLon };
      },
      //GCJ-02 to BD-09
      bd_encrypt: function (gcjLat, gcjLon) {
          var x = gcjLon, y = gcjLat;
          var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);
          var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);
          var bdLon = z * Math.cos(theta) + 0.0065;
          var bdLat = z * Math.sin(theta) + 0.006;
          return { lat: bdLat, lon: bdLon };
      },
      //BD-09 to GCJ-02
      bd_decrypt: function (bdLat, bdLon) {
          var x = bdLon - 0.0065, y = bdLat - 0.006;
          var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_pi);
          var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_pi);
          var gcjLon = z * Math.cos(theta);
          var gcjLat = z * Math.sin(theta);
          return { lat: gcjLat, lon: gcjLon };
      },
      //WGS-84 to Web mercator
      mercator_encrypt: function (wgsLat, wgsLon) {
          var x = (wgsLon * 20037508.34) / 180;
          var y = Math.log(Math.tan(((90 + wgsLat) * this.PI) / 360)) / (this.PI / 180);
          y = (y * 20037508.34) / 180;
          return { lat: y, lon: x };
      },
      // Web mercator to WGS-84
      mercator_decrypt: function (mercatorLat, mercatorLon) {
          var x = (mercatorLon / 20037508.34) * 180;
          var y = (mercatorLat / 20037508.34) * 180;
          y = (180 / this.PI) * (2 * Math.atan(Math.exp((y * this.PI) / 180)) - this.PI / 2);
          return { lat: y, lon: x };
      },
      // 计算两点在地球椭球体上的距离
      distance: function (latA, lonA, latB, lonB) {
          var earthR = 6371000;
          var x = Math.cos((latA * this.PI) / 180) * Math.cos((latB * this.PI) / 180) * Math.cos(((lonA - lonB) * this.PI) / 180);
          var y = Math.sin((latA * this.PI) / 180) * Math.sin((latB * this.PI) / 180);
          var s = x + y;
          if (s > 1)
              s = 1;
          if (s < -1)
              s = -1;
          var alpha = Math.acos(s);
          return alpha * earthR;
      },
      // 判断坐标是否超出中国范围-
      outOfChina: function (lat, lon) {
          if (lon < 72.004 || lon > 137.8347)
              return true;
          if (lat < 0.8293 || lat > 55.8271)
              return true;
          return false;
      },
      transformLat: function (x, y) {
          var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
          ret += ((20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0) / 3.0;
          ret += ((20.0 * Math.sin(y * this.PI) + 40.0 * Math.sin((y / 3.0) * this.PI)) * 2.0) / 3.0;
          ret += ((160.0 * Math.sin((y / 12.0) * this.PI) + 320 * Math.sin((y * this.PI) / 30.0)) * 2.0) / 3.0;
          return ret;
      },
      transformLon: function (x, y) {
          var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
          ret += ((20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0) / 3.0;
          ret += ((20.0 * Math.sin(x * this.PI) + 40.0 * Math.sin((x / 3.0) * this.PI)) * 2.0) / 3.0;
          ret += ((150.0 * Math.sin((x / 12.0) * this.PI) + 300.0 * Math.sin((x / 30.0) * this.PI)) * 2.0) / 3.0;
          return ret;
      }
  };
  /**
   * 自定义并注册百度坐标系
   */
  (function () {
      if (proj4) {
          proj4.defs("BD-09", "+proj=merc +a=6378206 +b=6356584.314245179 +lat_ts=0.0 +lon_0=0.0 +x_0=0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs");
          register$1(proj4);
      }
      else {
          console.error("未引入proj4.js,无法调用修正百度地图加密坐标!");
      }
  })();
  /**
   * 自定义并注册CGCS2000坐标系
   */
  (function () {
      if (proj4) {
          proj4.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs");
          register$1(proj4);
      }
  })();
  function transformToDataProjection(coordinate, projection) {
      return transformInternal(coordinate, {
          source: projection || PUBLIC_CONFIG.projection,
          destination: PUBLIC_CONFIG.dataProjection
      });
  }
  function transformToProjection(coordinate, dataProjection) {
      return transformInternal(coordinate, {
          source: dataProjection || PUBLIC_CONFIG.dataProjection,
          destination: PUBLIC_CONFIG.projection
      });
  }
  function transform$3(coordinate, options) {
      var _a = options.source, source = _a === void 0 ? PUBLIC_CONFIG.dataProjection : _a, _b = options.destination, destination = _b === void 0 ? PUBLIC_CONFIG.projection : _b, offset = options.offset;
      if (source === destination && !defined$1(offset)) {
          return coordinate;
      }
      if (!Array.isArray(coordinate)) {
          if (coordinate.type === GeoJsonType.FEATURE) {
              return transformGeoJsonFeature(coordinate, options);
          }
          else if (coordinate.type === GeoJsonType.FEATURE_COLLECTION) {
              return featureCollection(coordinate.features.map(function (f) { return transformGeoJsonFeature(f, options); }));
          }
      }
      if (!Array.isArray(coordinate)) {
          console.warn(ErrorNotification.UNSUPPORTED_PARAM);
          return;
      }
      if (typeof coordinate[0] === "number" && coordinate.length === 4) {
          var _c = __read(transform$3([coordinate[0], coordinate[1]], options), 2), minX = _c[0], minY = _c[1];
          var _d = __read(transform$3([coordinate[2], coordinate[3]], options), 2), maxX = _d[0], maxY = _d[1];
          return [minX, minY, maxX, maxY];
      }
      if (offset) {
          if (source.toLocaleUpperCase() !== WGS84_PROJECTION_NAME) {
              coordinate = transform$4(coordinate, source, WGS84_PROJECTION_NAME);
          }
          coordinate = coordinateOffsetUtil[offset.toLocaleLowerCase()](coordinate);
          return transform$4(coordinate, WGS84_PROJECTION_NAME, destination);
      }
      return transform$4(coordinate, source, destination);
  }
  /**
   * @ignore
   */
  function transformInternal(coordinate, options) {
      // @ts-ignore
      if (defined$1(options === null || options === void 0 ? void 0 : options.destination) && options.destination !== WGS84_PROJECTION_NAME) {
          options = __assign$1(__assign$1({}, options), { destination: WGS84_PROJECTION_NAME });
      }
      return transform$3(coordinate, options);
  }
  function dataTransform(coordinates, offsetType) {
      if (defined$1(coordinates) && Array.isArray(coordinates) && coordinates.length > 0) {
          // wkt 数组
          if (typeof coordinates[0] === "string") {
              return coordinates.map(function (wkt) {
                  var json = wktToGeoJsonFeature(wkt);
                  return geoJsonFeatureToWkt(dataOffset(json, offsetType));
              });
          }
          // PointCoordinate []
          if (Array.isArray(coordinates[0])) {
              return coordinates.map(function (coordinate) {
                  return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](coordinate);
              });
          }
          if (typeof coordinates[0] === "number") {
              return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](coordinates);
          }
          if (coordinates[0] instanceof Object) {
              var obj = coordinates[0];
              var _res = [];
              if (obj.hasOwnProperty("lon")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.lon, coordinate.lat]);
                      return Object.assign(coordinates, { lon: Tcoords[0], ltat: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("lng")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.lng, coordinate.lat]);
                      return Object.assign(coordinates, { lng: Tcoords[0], lat: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("x")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.x, coordinate.y]);
                      return Object.assign(coordinates, { x: Tcoords[0], y: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("longitude")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.x, coordinate.y]);
                      return Object.assign(coordinates, { longitude: Tcoords[0], lattitude: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("wkt")) {
                  _res = coordinates.map(function (coordinate) {
                      var json = wktToGeoJsonFeature(coordinate.wkt);
                      var _wkt = geoJsonFeatureToWkt(dataOffset(json, offsetType));
                      return Object.assign(coordinates, { wkt: _wkt });
                  });
              }
              return _res;
          }
          // GeoJson 数据格式
      }
      else if (!Array.isArray(coordinates) && typeof coordinates === "object") {
          return dataOffset(coordinates, offsetType);
      }
  }
  /**
   * 坐标从WGS84转到国测局02
   */
  function WGStoGCJ(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.WGS_TO_GCJ);
  }
  /**
   * 坐标从WGS84转到国测局02
   */
  function _WGStoGCJ(coordinate) {
      var Tcoords = GPS.gcj_encrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从国测局02转到WGS84
   */
  function GCJtoWGS(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.GCJ_TO_WGS);
  }
  /**
   * 坐标从国测局02转到WGS84
   */
  function _GCJtoWGS(coordinate) {
      var Tcoords = GPS.gcj_decrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从国测局02转到百度
   */
  function GCJtoBD(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.GCJ_TO_BD);
  }
  /**
   * 坐标从国测局02转到百度
   */
  function _GCJtoBD(coordinate) {
      var Tcoords = GPS.bd_encrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从百度转到国测局02
   */
  function BDtoGCJ(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.BD_TO_GCJ);
  }
  /**
   * 坐标从百度转到国测局02
   */
  function _BDtoGCJ(coordinates) {
      var Tcoords = GPS.bd_decrypt(coordinates[1], coordinates[0]);
      return coordinates.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinates[2]];
  }
  /**
   * 坐标从WGS84转到百度
   */
  function WGStoBD(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.WGS_TO_BD);
  }
  /**
   * 坐标从WGS84转到百度
   */
  function _WGStoBD(coordinate) {
      var Tcoords1 = GPS.gcj_encrypt(coordinate[1], coordinate[0]);
      var Tcoords = GPS.bd_encrypt(Tcoords1.lat, Tcoords1.lon);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从百度转到WGS84
   */
  function BDtoWGS(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.BD_TO_WGS);
  }
  /**
   * 坐标从百度转到WGS84
   */
  function _BDtoWGS(coordinate) {
      var Tcoords1 = GPS.bd_decrypt(coordinate[1], coordinate[0]);
      var Tcoords = GPS.gcj_decrypt(Tcoords1.lat, Tcoords1.lon);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * @ignore
   */
  function transformGeoJsonFeature(geoJson, options) {
      if ((options === null || options === void 0 ? void 0 : options.mutate) !== true) {
          geoJson = JSON.parse(JSON.stringify(geoJson));
      }
      transformGeoJsonGeometryCoordinatesInternal(geoJson.geometry.coordinates, options);
      return geoJson;
  }
  /**
   * @ignore
   */
  function transformGeoJsonGeometryCoordinates(coordinates, options) {
      if (options === void 0) { options = {}; }
      var _a = options.source, source = _a === void 0 ? PUBLIC_CONFIG.dataProjection : _a, _b = options.destination, destination = _b === void 0 ? PUBLIC_CONFIG.projection : _b, offset = options.offset;
      if (source === destination && !defined$1(offset)) {
          return coordinates;
      }
      if ((options === null || options === void 0 ? void 0 : options.mutate) !== true) {
          coordinates = JSON.parse(JSON.stringify(coordinates));
      }
      transformGeoJsonGeometryCoordinatesInternal(coordinates, options);
      return coordinates;
  }
  /**
   * 该方法会修改传入的参数
   */
  function transformGeoJsonGeometryCoordinatesInternal(coordinates, options) {
      var e_1, _a;
      if (Array.isArray(coordinates) && typeof coordinates[0] === "number") {
          var _b = __read(transformInternal(coordinates, options), 3), x = _b[0], y = _b[1], z = _b[2];
          coordinates[0] = x;
          coordinates[1] = y;
          defined$1(z) && (coordinates[2] = z);
      }
      else {
          try {
              for (var coordinates_1 = __values(coordinates), coordinates_1_1 = coordinates_1.next(); !coordinates_1_1.done; coordinates_1_1 = coordinates_1.next()) {
                  var coordinate = coordinates_1_1.value;
                  transformGeoJsonGeometryCoordinatesInternal(coordinate, options);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (coordinates_1_1 && !coordinates_1_1.done && (_a = coordinates_1.return)) _a.call(coordinates_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
      }
  }
  /**
   * @description 数据偏移
   * @export
   * @param {Object} data - GeoJSON对象
   * @param {*} offsetType
   * @returns {Object} GeoJSON对象
   */
  function dataOffset(data, offsetType) {
      if (!data || !offsetType) {
          console.error("参数错误");
          return;
      }
      if (data.type === "FeatureCollection") {
          for (var index = 0; index < data.features.length; index++) {
              var feature = data.features[index];
              featureOffset(feature, offsetType);
          }
      }
      else if (data.type === "Feature") {
          featureOffset(data, offsetType);
      }
      return data;
  }
  function geometryOffset(geo, offsetType) {
      if (geo.type === "Point") {
          geo.coordinates = coordinateOffsetUtil[offsetType.toLocaleLowerCase()](geo.coordinates);
      }
      else if (geo.type === "LineString" || geo.type === "MultiPoint") {
          geo.coordinates = geo.coordinates.map(function (currentValue) {
              return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](currentValue);
          });
      }
      else if (geo.type === "Polygon" || geo.type === "MultiLineString") {
          geo.coordinates = geo.coordinates.map(function (currentValue) {
              return currentValue.map(function (item) {
                  return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](item);
              });
          });
      }
      else if (geo.type === "MultiPolygon") {
          geo.coordinates = geo.coordinates.map(function (item1) {
              return item1.map(function (item2) {
                  return item2.map(function (item3) {
                      return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](item3);
                  });
              });
          });
      }
      else {
          console.error("该GeoJSON格式不正确");
      }
  }
  function featureOffset(feature, offsetType) {
      geometryOffset(feature.geometry, offsetType);
  }

  var gitVersion = "1.0.0-beta.7-dev+g0e095ee";
  var gitDate = "2022-10-14 17:19:14 +0800";

  var css_248z$1 = ".cesium-svgPath-svg{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden}.cesium-button{display:inline-block;position:relative;background:#303336;border:1px solid #444;color:#edffff;fill:#edffff;border-radius:4px;padding:5px 12px;margin:2px 3px;cursor:pointer;overflow:hidden;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.cesium-button:focus{color:#fff;fill:#fff;border-color:#ea4;outline:0}.cesium-button:hover{color:#fff;fill:#fff;background:#48b;border-color:#aef;box-shadow:0 0 8px #fff}.cesium-button:active{color:#000;fill:#000;background:#adf;border-color:#fff;box-shadow:0 0 8px #fff}.cesium-button-disabled,.cesium-button-disabled:active,.cesium-button-disabled:focus,.cesium-button-disabled:hover,.cesium-button:disabled{background:#303336;border-color:#444;color:#646464;fill:#646464;box-shadow:none;cursor:default}.cesium-button option{background-color:#000;color:#eee}.cesium-button option:disabled{color:#777}.cesium-button input,.cesium-button label{cursor:pointer}.cesium-button input{vertical-align:sub}.cesium-toolbar-button{box-sizing:border-box;width:32px;height:32px;border-radius:14%;padding:0;vertical-align:middle;z-index:0}.cesium-performanceDisplay-defaultContainer{position:absolute;top:50px;right:10px;text-align:right}.cesium-performanceDisplay{background-color:rgba(40,40,40,.7);padding:7px;border-radius:5px;border:1px solid #444;font:bold 12px sans-serif}.cesium-performanceDisplay-fps{color:#e52}.cesium-performanceDisplay-throttled{color:#a42}.cesium-performanceDisplay-ms{color:#de3}.cesium-animation-theme{visibility:hidden;display:block;position:absolute;z-index:-100}.cesium-animation-themeNormal{color:#222}.cesium-animation-themeHover{color:#4488b0}.cesium-animation-themeSelect{color:#242}.cesium-animation-themeDisabled{color:#333}.cesium-animation-themeKnob{color:#222}.cesium-animation-themePointer{color:#2e2}.cesium-animation-themeSwoosh{color:#8ac}.cesium-animation-themeSwooshHover{color:#aef}.cesium-animation-svgText{fill:#edffff;font-family:Sans-Serif;font-size:15px;text-anchor:middle}.cesium-animation-blank{fill:#000;fill-opacity:.01;stroke:none}.cesium-animation-rectButton{cursor:pointer;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.cesium-animation-rectButton .cesium-animation-buttonGlow{fill:#fff;stroke:none;display:none}.cesium-animation-rectButton:hover .cesium-animation-buttonGlow{display:block}.cesium-animation-rectButton .cesium-animation-buttonPath{fill:#edffff}.cesium-animation-rectButton .cesium-animation-buttonMain{stroke:#444;stroke-width:1.2}.cesium-animation-rectButton:hover .cesium-animation-buttonMain{stroke:#aef}.cesium-animation-rectButton:active .cesium-animation-buttonMain{fill:#abd6ff}.cesium-animation-buttonDisabled{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.cesium-animation-buttonDisabled .cesium-animation-buttonMain{stroke:#555}.cesium-animation-buttonDisabled .cesium-animation-buttonPath{fill:#818181}.cesium-animation-buttonDisabled .cesium-animation-buttonGlow{display:none}.cesium-animation-buttonToggled .cesium-animation-buttonGlow{display:block;fill:#2e2}.cesium-animation-buttonToggled .cesium-animation-buttonMain{stroke:#2e2}.cesium-animation-buttonToggled:hover .cesium-animation-buttonGlow{fill:#fff}.cesium-animation-buttonToggled:hover .cesium-animation-buttonMain{stroke:#2e2}.cesium-animation-shuttleRingG{cursor:pointer}.cesium-animation-shuttleRingPointer{cursor:pointer}.cesium-animation-shuttleRingPausePointer{cursor:pointer}.cesium-animation-shuttleRingBack{fill:#181818;fill-opacity:.8;stroke:#333;stroke-width:1.2}.cesium-animation-shuttleRingSwoosh line{stroke:#8ac;stroke-width:3;stroke-opacity:.2;stroke-linecap:round}.cesium-animation-knobOuter{cursor:pointer;stroke:#444;stroke-width:1.2}.cesium-animation-knobInner{cursor:pointer}.cesium-baseLayerPicker-selected{position:absolute;top:0;left:0;width:100%;height:100%;border:none}.cesium-baseLayerPicker-dropDown{display:block;position:absolute;box-sizing:content-box;top:auto;right:0;width:320px;max-height:500px;margin-top:5px;background-color:rgba(38,38,38,.75);border:1px solid #444;padding:6px;overflow:auto;border-radius:10px;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;transform:translate(0,-20%);visibility:hidden;opacity:0;transition:visibility 0s .2s,opacity .2s ease-in,transform .2s ease-in}.cesium-baseLayerPicker-dropDown-visible{transform:translate(0,0);visibility:visible;opacity:1;transition:opacity .2s ease-out,transform .2s ease-out}.cesium-baseLayerPicker-sectionTitle{display:block;font-family:sans-serif;font-size:16pt;text-align:left;color:#edffff;margin-bottom:4px}.cesium-baseLayerPicker-choices{margin-bottom:5px}.cesium-baseLayerPicker-categoryTitle{color:#edffff;font-size:11pt}.cesium-baseLayerPicker-choices{display:block;border:1px solid #888;border-radius:5px;padding:5px 0}.cesium-baseLayerPicker-item{display:inline-block;vertical-align:top;margin:2px 5px;width:64px;text-align:center;cursor:pointer}.cesium-baseLayerPicker-itemLabel{display:block;font-family:sans-serif;font-size:8pt;text-align:center;vertical-align:middle;color:#edffff;cursor:pointer;word-wrap:break-word}.cesium-baseLayerPicker-item:focus .cesium-baseLayerPicker-itemLabel,.cesium-baseLayerPicker-item:hover .cesium-baseLayerPicker-itemLabel{text-decoration:underline}.cesium-baseLayerPicker-itemIcon{display:inline-block;position:relative;width:inherit;height:auto;background-size:100% 100%;border:solid 1px #444;border-radius:9px;color:#edffff;margin:0;padding:0;cursor:pointer;box-sizing:border-box}.cesium-baseLayerPicker-item:hover .cesium-baseLayerPicker-itemIcon{border-color:#fff;box-shadow:0 0 8px #fff,0 0 8px #fff}.cesium-baseLayerPicker-selectedItem .cesium-baseLayerPicker-itemLabel{color:#bdecf8}.cesium-baseLayerPicker-selectedItem .cesium-baseLayerPicker-itemIcon{border:double 4px #bdecf8}.cesium-widget{position:relative}.cesium-widget,.cesium-widget canvas{width:100%;height:100%;touch-action:none}.cesium-widget-credits{display:block;position:absolute;bottom:0;left:0;color:#fff;font-size:10px;text-shadow:0 0 2px #000;padding-right:5px}.cesium-widget-credits a,.cesium-widget-credits a:visited{color:#fff}.cesium-widget-errorPanel{position:absolute;top:0;right:0;bottom:0;left:0;text-align:center;background:rgba(0,0,0,.7);z-index:99999}.cesium-widget-errorPanel:before{display:inline-block;vertical-align:middle;height:100%;content:\"\"}.cesium-widget-errorPanel-content{width:75%;max-width:500px;display:inline-block;text-align:left;vertical-align:middle;border:1px solid #510c00;border-radius:7px;background-color:#f0d9d5;font-size:14px;color:#510c00}.cesium-widget-errorPanel-content.expanded{max-width:75%}.cesium-widget-errorPanel-header{font-size:18px;font-family:\"Open Sans\",Verdana,Geneva,sans-serif;background:#d69d93;border-bottom:2px solid #510c00;padding-bottom:10px;border-radius:3px 3px 0 0;padding:15px}.cesium-widget-errorPanel-scroll{overflow:auto;font-family:\"Open Sans\",Verdana,Geneva,sans-serif;white-space:pre-wrap;padding:0 15px;margin:10px 0 20px 0}.cesium-widget-errorPanel-buttonPanel{padding:0 15px;margin:10px 0 20px 0;text-align:right}.cesium-widget-errorPanel-buttonPanel button{border-color:#510c00;background:#d69d93;color:#202020;margin:0}.cesium-widget-errorPanel-buttonPanel button:focus{border-color:#510c00;background:#f0d9d5;color:#510c00}.cesium-widget-errorPanel-buttonPanel button:hover{border-color:#510c00;background:#f0d9d5;color:#510c00}.cesium-widget-errorPanel-buttonPanel button:active{border-color:#510c00;background:#b17b72;color:#510c00}.cesium-widget-errorPanel-more-details{text-decoration:underline;cursor:pointer}.cesium-widget-errorPanel-more-details:hover{color:#2b0700}.cesium-cesiumInspector{border-radius:5px;transition:width ease-in-out .25s;background:rgba(48,51,54,.8);border:1px solid #444;color:#edffff;display:inline-block;position:relative;padding:4px 12px;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden}.cesium-cesiumInspector-button{text-align:center;font-size:11pt}.cesium-cesiumInspector-visible .cesium-cesiumInspector-button{border-bottom:1px solid #aaa;padding-bottom:3px}.cesium-cesiumInspector input:enabled,.cesium-cesiumInspector-button{cursor:pointer}.cesium-cesiumInspector-visible{width:185px;height:auto}.cesium-cesiumInspector-hidden{width:122px;height:17px}.cesium-cesiumInspector-sectionContent{max-height:500px}.cesium-cesiumInspector-section-collapsed .cesium-cesiumInspector-sectionContent{max-height:0;padding:0!important;overflow:hidden}.cesium-cesiumInspector-dropDown{margin:5px 0;font-family:sans-serif;font-size:10pt;width:185px}.cesium-cesiumInspector-frustumStatistics{padding-left:10px;padding:5px;background-color:rgba(80,80,80,.75)}.cesium-cesiumInspector-pickButton{background-color:rgba(0,0,0,.3);border:1px solid #444;color:#edffff;border-radius:5px;padding:3px 7px;cursor:pointer;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;margin:0 auto}.cesium-cesiumInspector-pickButton:focus{outline:0}.cesium-cesiumInspector-pickButton:active,.cesium-cesiumInspector-pickButtonHighlight{color:#000;background:#adf;border-color:#fff;box-shadow:0 0 8px #fff}.cesium-cesiumInspector-center{text-align:center}.cesium-cesiumInspector-sectionHeader{font-weight:700;font-size:10pt;margin:0;cursor:pointer}.cesium-cesiumInspector-pickSection{border:1px solid #aaa;border-radius:5px;padding:3px;margin-bottom:5px}.cesium-cesiumInspector-sectionContent{margin-bottom:10px;transition:max-height .25s}.cesium-cesiumInspector-tileText{padding-bottom:10px;border-bottom:1px solid #aaa}.cesium-cesiumInspector-relativeText{padding-top:10px}.cesium-cesiumInspector-sectionHeader::before{margin-right:5px;content:\"-\";width:1ch;display:inline-block}.cesium-cesiumInspector-section-collapsed .cesium-cesiumInspector-sectionHeader::before{content:\"+\"}ul.cesium-cesiumInspector-statistics{margin:0;padding-top:3px;padding-bottom:3px}ul.cesium-cesiumInspector-statistics+ul.cesium-cesiumInspector-statistics{border-top:1px solid #aaa}.cesium-cesiumInspector-slider{margin-top:5px}.cesium-cesiumInspector-slider input[type=number]{text-align:left;background-color:#222;outline:0;border:1px solid #444;color:#edffff;width:100px;border-radius:3px;padding:1px;margin-left:10px;cursor:auto}.cesium-cesiumInspector-slider input[type=number]::-webkit-inner-spin-button,.cesium-cesiumInspector-slider input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.cesium-cesiumInspector-slider input[type=range]{margin-left:5px;vertical-align:middle}.cesium-cesiumInspector-hide .cesium-cesiumInspector-styleEditor{display:none}.cesium-cesiumInspector-styleEditor{padding:10px;border-radius:5px;background:rgba(48,51,54,.8);border:1px solid #444}.cesium-cesiumInspector-styleEditor textarea{width:100%;height:300px;background:0 0;color:#edffff;border:none;padding:0;white-space:pre;overflow-wrap:normal;overflow-x:auto}.cesium-3DTilesInspector{width:300px;pointer-events:all}.cesium-3DTilesInspector-statistics{font-size:11px}.cesium-3DTilesInspector div,.cesium-3DTilesInspector input[type=range]{width:100%;box-sizing:border-box}.cesium-cesiumInspector-error{color:#ff9e9e;overflow:auto}.cesium-3DTilesInspector .cesium-cesiumInspector-section{margin-top:3px}.cesium-3DTilesInspector .cesium-cesiumInspector-sectionHeader+.cesium-cesiumInspector-show{border-top:1px solid #fff}input.cesium-cesiumInspector-url{overflow:hidden;white-space:nowrap;overflow-x:scroll;background-color:transparent;color:#fff;outline:0;border:none;height:1em;width:100%}.cesium-cesiumInspector .field-group{display:table}.cesium-cesiumInspector .field-group>label{display:table-cell;font-weight:700}.cesium-cesiumInspector .field-group>.field{display:table-cell;width:100%}.cesium-button.cesium-fullscreenButton{display:block;width:100%;height:100%;margin:0;border-radius:0}.cesium-button.cesium-vrButton{display:block;width:100%;height:100%;margin:0;border-radius:0}.cesium-viewer-geocoderContainer .cesium-geocoder-input{border:solid 1px #444;background-color:rgba(40,40,40,.7);color:#fff;display:inline-block;vertical-align:middle;width:0;height:32px;margin:0;padding:0 32px 0 0;border-radius:0;box-sizing:border-box;transition:width ease-in-out .25s,background-color .2s ease-in-out;-webkit-appearance:none}.cesium-viewer-geocoderContainer:hover .cesium-geocoder-input{border-color:#aef;box-shadow:0 0 8px #fff}.cesium-viewer-geocoderContainer .cesium-geocoder-input:focus{border-color:#ea4;background-color:rgba(15,15,15,.9);box-shadow:none;outline:0}.cesium-viewer-geocoderContainer .cesium-geocoder-input-wide,.cesium-viewer-geocoderContainer .cesium-geocoder-input:focus,.cesium-viewer-geocoderContainer:hover .cesium-geocoder-input{padding-left:4px;width:250px}.cesium-viewer-geocoderContainer .search-results{position:absolute;background-color:#000;color:#eee;overflow-y:auto;opacity:.8;width:100%}.cesium-viewer-geocoderContainer .search-results ul{list-style-type:none;margin:0;padding:0}.cesium-viewer-geocoderContainer .search-results ul li{font-size:14px;padding:3px 10px}.cesium-viewer-geocoderContainer .search-results ul li:hover{cursor:pointer}.cesium-viewer-geocoderContainer .search-results ul li.active{background:#48b}.cesium-geocoder-searchButton{background-color:#303336;display:inline-block;position:absolute;cursor:pointer;width:32px;top:1px;right:1px;height:30px;vertical-align:middle;fill:#edffff}.cesium-geocoder-searchButton:hover{background-color:#48b}.cesium-infoBox{display:block;position:absolute;top:50px;right:0;width:40%;max-width:480px;background:rgba(38,38,38,.95);color:#edffff;border:1px solid #444;border-right:none;border-top-left-radius:7px;border-bottom-left-radius:7px;box-shadow:0 0 10px 1px #000;transform:translate(100%,0);visibility:hidden;opacity:0;transition:visibility 0s .2s,opacity .2s ease-in,transform .2s ease-in}.cesium-infoBox-visible{transform:translate(0,0);visibility:visible;opacity:1;transition:opacity .2s ease-out,transform .2s ease-out}.cesium-infoBox-title{display:block;height:20px;padding:5px 30px 5px 25px;background:#545454;border-top-left-radius:7px;text-align:center;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;box-sizing:content-box}.cesium-infoBox-bodyless .cesium-infoBox-title{border-bottom-left-radius:7px}button.cesium-infoBox-camera{display:block;position:absolute;top:4px;left:4px;width:22px;height:22px;background:0 0;border-color:transparent;border-radius:3px;padding:0 5px;margin:0}button.cesium-infoBox-close{display:block;position:absolute;top:5px;right:5px;height:20px;background:0 0;border:none;border-radius:2px;font-weight:700;font-size:16px;padding:0 5px;margin:0;color:#edffff}button.cesium-infoBox-close:focus{background:rgba(238,136,0,.44);outline:0}button.cesium-infoBox-close:hover{background:#888;color:#000}button.cesium-infoBox-close:active{background:#a00;color:#000}.cesium-infoBox-bodyless .cesium-infoBox-iframe{display:none}.cesium-infoBox-iframe{border:none;width:100%;width:calc(100% - 2px)}span.cesium-sceneModePicker-wrapper{display:inline-block;position:relative;margin:0 3px}.cesium-sceneModePicker-visible{visibility:visible;opacity:1;transition:opacity .25s linear}.cesium-sceneModePicker-hidden{visibility:hidden;opacity:0;transition:visibility 0s .25s,opacity .25s linear}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-none{display:none}.cesium-sceneModePicker-slide-svg{transition:left 2s;top:0;left:0}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-dropDown-icon{box-sizing:border-box;padding:0;margin:3px 0}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button2D,.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button3D,.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-buttonColumbusView{margin:0 0 3px 0}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button3D .cesium-sceneModePicker-icon2D{left:100%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button3D .cesium-sceneModePicker-iconColumbusView{left:200%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-buttonColumbusView .cesium-sceneModePicker-icon3D{left:-200%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-buttonColumbusView .cesium-sceneModePicker-icon2D{left:-100%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button2D .cesium-sceneModePicker-icon3D{left:-100%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-button2D .cesium-sceneModePicker-iconColumbusView{left:100%}.cesium-sceneModePicker-wrapper .cesium-sceneModePicker-selected{border-color:#2e2;box-shadow:0 0 8px #fff,0 0 8px #fff}span.cesium-projectionPicker-wrapper{display:inline-block;position:relative;margin:0 3px}.cesium-projectionPicker-visible{visibility:visible;opacity:1;transition:opacity .25s linear}.cesium-projectionPicker-hidden{visibility:hidden;opacity:0;transition:visibility 0s .25s,opacity .25s linear}.cesium-projectionPicker-wrapper .cesium-projectionPicker-none{display:none}.cesium-projectionPicker-wrapper .cesium-projectionPicker-dropDown-icon{box-sizing:border-box;padding:0;margin:3px 0}.cesium-projectionPicker-wrapper .cesium-projectionPicker-buttonOrthographic,.cesium-projectionPicker-wrapper .cesium-projectionPicker-buttonPerspective{margin:0 0 3px 0}.cesium-projectionPicker-wrapper .cesium-projectionPicker-buttonPerspective .cesium-projectionPicker-iconOrthographic{left:100%}.cesium-projectionPicker-wrapper .cesium-projectionPicker-buttonOrthographic .cesium-projectionPicker-iconPerspective{left:-100%}.cesium-projectionPicker-wrapper .cesium-projectionPicker-selected{border-color:#2e2;box-shadow:0 0 8px #fff,0 0 8px #fff}.cesium-performance-watchdog-message-area{position:relative;background-color:#ff0;color:#000;padding:10px}.cesium-performance-watchdog-message{margin-right:30px}.cesium-performance-watchdog-message-dismiss{position:absolute;right:0;margin:0 10px 0 0}.cesium-navigationHelpButton-wrapper{position:relative;display:inline-block}.cesium-navigation-help{visibility:hidden;position:absolute;top:38px;right:2px;width:250px;border-radius:10px;transform:scale(.01);transform-origin:234px -10px;transition:visibility 0s .25s,transform .25s ease-in}.cesium-navigation-help-visible{visibility:visible;transform:scale(1);transition:transform .25s ease-out}.cesium-navigation-help-instructions{border:1px solid #444;background-color:rgba(38,38,38,.75);padding-bottom:5px;border-radius:0 0 10px 10px}.cesium-click-navigation-help{display:none}.cesium-touch-navigation-help{display:none;padding-top:5px}.cesium-click-navigation-help-visible{display:block}.cesium-touch-navigation-help-visible{display:block}.cesium-navigation-help-pan{color:#6cf;font-weight:700}.cesium-navigation-help-zoom{color:#65fd00;font-weight:700}.cesium-navigation-help-rotate{color:#ffd800;font-weight:700}.cesium-navigation-help-tilt{color:#d800d8;font-weight:700}.cesium-navigation-help-details{color:#fff}.cesium-navigation-button{color:#fff;background-color:transparent;border-bottom:none;border-top:1px solid #444;border-right:1px solid #444;margin:0;width:50%;cursor:pointer}.cesium-navigation-button-icon{vertical-align:middle;padding:5px 1px}.cesium-navigation-button:focus{outline:0}.cesium-navigation-button-left{border-radius:10px 0 0 0;border-left:1px solid #444}.cesium-navigation-button-right{border-radius:0 10px 0 0;border-left:none}.cesium-navigation-button-selected{background-color:rgba(38,38,38,.75)}.cesium-navigation-button-unselected{background-color:rgba(0,0,0,.75)}.cesium-navigation-button-unselected:hover{background-color:rgba(76,76,76,.75)}.cesium-selection-wrapper{position:absolute;width:160px;height:160px;pointer-events:none;visibility:hidden;opacity:0;transition:visibility 0s .2s,opacity .2s ease-in}.cesium-selection-wrapper-visible{visibility:visible;opacity:1;transition:opacity .2s ease-out}.cesium-selection-wrapper svg{fill:#2e2;stroke:#000;stroke-width:1.1px}.cesium-timeline-main{position:relative;left:0;bottom:0;overflow:hidden;border:solid 1px #888}.cesium-timeline-trackContainer{width:100%;overflow:auto;border-top:solid 1px #888;position:relative;top:0;left:0}.cesium-timeline-tracks{position:absolute;top:0;left:0;width:100%}.cesium-timeline-needle{position:absolute;left:0;top:1.7em;bottom:0;width:1px;background:red}.cesium-timeline-bar{position:relative;left:0;top:0;overflow:hidden;cursor:pointer;width:100%;height:1.7em;background:linear-gradient(to bottom,rgba(116,117,119,.8) 0,rgba(58,68,82,.8) 11%,rgba(46,50,56,.8) 46%,rgba(53,53,53,.8) 81%,rgba(53,53,53,.8) 100%)}.cesium-timeline-ruler{visibility:hidden;white-space:nowrap;font-size:80%;z-index:-200}.cesium-timeline-highlight{position:absolute;bottom:0;left:0;background:#08f}.cesium-timeline-ticLabel{position:absolute;top:0;left:0;white-space:nowrap;font-size:80%;color:#eee}.cesium-timeline-ticMain{position:absolute;bottom:0;left:0;width:1px;height:50%;background:#eee}.cesium-timeline-ticSub{position:absolute;bottom:0;left:0;width:1px;height:33%;background:#aaa}.cesium-timeline-ticTiny{position:absolute;bottom:0;left:0;width:1px;height:25%;background:#888}.cesium-timeline-icon16{display:block;position:absolute;width:16px;height:16px;background-image:url(Images/TimelineIcons.png);background-repeat:no-repeat}.cesium-viewer{font-family:sans-serif;font-size:16px;overflow:hidden;display:block;position:relative;top:0;left:0;width:100%;height:100%}.cesium-viewer-cesiumWidgetContainer{width:100%;height:100%}.cesium-viewer-bottom{display:block;position:absolute;bottom:0;left:0;padding-right:5px}.cesium-viewer .cesium-widget-credits{display:inline;position:static;bottom:auto;left:auto;padding-right:0;color:#fff;font-size:10px;text-shadow:0 0 2px #000}.cesium-viewer-timelineContainer{position:absolute;bottom:0;left:169px;right:29px;height:27px;padding:0;margin:0;overflow:hidden;font-size:14px}.cesium-viewer-animationContainer{position:absolute;bottom:0;left:0;padding:0;width:169px;height:112px}.cesium-viewer-fullscreenContainer{position:absolute;bottom:0;right:0;padding:0;width:29px;height:29px;overflow:hidden}.cesium-viewer-vrContainer{position:absolute;bottom:0;right:0;padding:0;width:29px;height:29px;overflow:hidden}.cesium-viewer-toolbar{display:block;position:absolute;top:5px;right:5px}.cesium-viewer-cesiumInspectorContainer{display:block;position:absolute;top:50px;right:10px}.cesium-viewer-geocoderContainer{position:relative;display:inline-block;margin:0 3px}.cesium-viewer-cesium3DTilesInspectorContainer{display:block;position:absolute;top:50px;right:10px;max-height:calc(100% - 120px);box-sizing:border-box;overflow-y:auto;overflow-x:hidden}";
  styleInject(css_248z$1);

  var css_248z = "/*html {\n    height: 100%;\n    -webkit-font-smoothing: antialiased;\n}\n\nbody {\n    height: 100%;\n    width: 100%;\n    margin: 0;\n    overflow: hidden;\n    padding: 0;\n    background: #000;\n    font-size: 15px;\n    font-family: @default-font;\n}*/\n.full-window {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  margin: 0;\n  overflow: hidden;\n  padding: 0;\n  -webkit-transition: left 0.25s ease-out;\n  -moz-transition: left 0.25s ease-out;\n  -ms-transition: left 0.25s ease-out;\n  -o-transition: left 0.25s ease-out;\n  transition: left 0.25s ease-out;\n}\n\n.transparent-to-input {\n  pointer-events: none;\n}\n\n.opaque-to-input {\n  pointer-events: auto;\n}\n\n.clickable {\n  cursor: pointer;\n}\n\n/*a {\n    text-decoration: none;\n    color: @highlight-color;\n}*/\na:hover {\n  text-decoration: underline;\n}\n\n/*\n@modal-background-color: @panel-background-color;\n@modal-text-color: @panel-emphasized-text-color;\n@modal-header-background-color: rgba(0,0,0,0.2);\n@modal-header-text-color: @panel-emphasized-text-color;*/\n/*.modal-background {\n    .opaque-to-input;\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    background-color: rgba(0,0,0,0.5);\n    z-index: 1000;  required for IE9 \n}*/\n/*\n.modal {\n    position: absolute;\n    margin: auto;\n    background-color: @modal-background-color;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    max-height: 100%;\n    max-width: 100%;\n    font-family: @default-font;\n    color: @modal-text-color;\n}\n\n.modal-header {\n  background-color: @modal-header-background-color;\n  border-bottom: @panel-element-border;\n  font-size: 15px;\n  line-height: 40px;\n  margin: 0;\n}\n\n.modal-header h1 {\n  font-size: 15px;\n  color: @modal-header-text-color;\n  margin-left: 15px;\n}*/\n/* Commented out due to conflicts with client apps. \n.modal-content {\n  margin-left: 15px;\n  margin-right: 15px;\n  margin-bottom: 15px;\n  padding-top: 15px;\n  overflow: auto;\n}*/\n/*.modal-close-button {\n    position: absolute;\n    right: 15px;\n    cursor: pointer;\n    font-size: 18px;\n    color: @modal-header-text-color;\n}*/\n#ui {\n  z-index: 2100;\n}\n\n@media print {\n  .full-window {\n    position: initial;\n  }\n}\n\n/* input[type=text] {\n  height: 38px;\n  background-color: #eeeeee;\n  color: @input-text-color;\n  font-size: 14px;\n}\n\n::-webkit-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-moz-placeholder { /* Firefox 18- \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n::-moz-placeholder {  /* Firefox 19+  \n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\n:-ms-input-placeholder {\n  color: fade(@input-text-color, 75%);\n  font-style: italic;\n}\n\ninput:focus {\n    outline-color: #FFFFFF;\n}\n*/\n/*select {\n  display: block;\n  background-color: @panel-form-input-background-color;\n  color: @panel-form-input-text-color;\n  height: 40px;\n  border: 0;\n  margin-top: 10px;\n  font-size: 14px;\n  padding-left: 5px;\n}*/\n.markdown img {\n  max-width: 100%;\n}\n\n.markdown svg {\n  max-height: 100%;\n}\n\n.markdown input,\n.markdown select,\n.markdown textarea,\n.markdown fieldset {\n  font-family: inherit;\n  font-size: 1rem;\n  box-sizing: border-box;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.markdown label {\n  vertical-align: middle;\n}\n\n.markdown h1,\n.markdown h2,\n.markdown h3,\n.markdown h4,\n.markdown h5,\n.markdown h6 {\n  font-family: inherit;\n  font-weight: bold;\n  line-height: 1.25;\n  margin-top: 1em;\n  margin-bottom: 0.5em;\n}\n\n.markdown h1 {\n  font-size: 2rem;\n}\n\n.markdown h2 {\n  font-size: 1.5rem;\n}\n\n.markdown h3 {\n  font-size: 1.25rem;\n}\n\n.markdown h4 {\n  font-size: 1rem;\n}\n\n.markdown h5 {\n  font-size: 0.875rem;\n}\n\n.markdown h6 {\n  font-size: 0.75rem;\n}\n\n.markdown p {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\n.markdown strong {\n  font-weight: bold;\n}\n\n.markdown em {\n  font-style: italic;\n}\n\n.markdown small {\n  font-size: 80%;\n}\n\n.markdown mark {\n  color: #000;\n  background: #ff0;\n}\n\n.markdown u {\n  text-decoration: underline;\n}\n\n.markdown s {\n  text-decoration: line-through;\n}\n\n.markdown dl,\n.markdown ol,\n.markdown ul {\n  margin-top: 0;\n  margin-bottom: 1rem;\n}\n\n.markdown ol {\n  list-style: decimal inside;\n}\n\n.markdown ul {\n  list-style: disc inside;\n}\n\n.markdown pre,\n.markdown code,\n.markdown samp {\n  font-family: monospace;\n  font-size: inherit;\n}\n\n.markdown pre {\n  margin-top: 0;\n  margin-bottom: 1rem;\n  overflow-x: scroll;\n}\n\n.markdown a {\n  color: #68adfe;\n  text-decoration: none;\n}\n\n.markdown a:hover {\n  text-decoration: underline;\n}\n\n.markdown pre,\n.markdown code {\n  background-color: transparent;\n  border-radius: 3px;\n}\n\n.markdown hr {\n  border: 0;\n  border-bottom-style: solid;\n  border-bottom-width: 1px;\n  border-bottom-color: rgba(0, 0, 0, 0.125);\n}\n\n.markdown .left-align {\n  text-align: left;\n}\n\n.markdown .center {\n  text-align: center;\n}\n\n.markdown .right-align {\n  text-align: right;\n}\n\n.markdown .justify {\n  text-align: justify;\n}\n\n.markdown .truncate {\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.markdown ol.upper-roman {\n  list-style-type: upper-roman;\n}\n\n.markdown ol.lower-alpha {\n  list-style-type: lower-alpha;\n}\n\n.markdown ul.circle {\n  list-style-type: circle;\n}\n\n.markdown ul.square {\n  list-style-type: square;\n}\n\n.markdown .list-reset {\n  list-style: none;\n  padding-left: 0;\n}\n\n.floating {\n  pointer-events: auto;\n  position: absolute;\n  border-radius: 15px;\n}\n\n.floating-horizontal {\n  pointer-events: auto;\n  position: absolute;\n  border-radius: 15px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n.floating-vertical {\n  pointer-events: auto;\n  position: absolute;\n  border-radius: 15px;\n  padding-top: 5px;\n  padding-bottom: 5px;\n}\n\n@media print {\n  .floating {\n    display: none;\n  }\n}\n\n.distance-legend {\n  pointer-events: auto;\n  position: absolute;\n  border-radius: 15px;\n  padding-left: 5px;\n  padding-right: 5px;\n  bottom: 30px;\n  height: 30px;\n  width: 125px;\n  box-sizing: content-box;\n}\n\n.distance-legend-label {\n  display: inline-block;\n  font-family: \"Roboto\", sans-serif;\n  font-size: 14px;\n  font-weight: lighter;\n  line-height: 30px;\n  color: #ffffff;\n  width: 125px;\n  text-align: center;\n}\n\n.distance-legend-scale-bar {\n  border-left: 1px solid #ffffff;\n  border-right: 1px solid #ffffff;\n  border-bottom: 1px solid #ffffff;\n  position: absolute;\n  height: 10px;\n  top: 15px;\n}\n\n@media print {\n  .distance-legend {\n    /* display: none; */\n  }\n}\n\n@media screen and (max-width: 700px), screen and (max-height: 420px) {\n  .distance-legend {\n    /* display: none; */\n  }\n}\n\n.navigation-controls {\n  position: absolute;\n  top: 110px;\n  right: 34px;\n  width: 27px;\n  font-weight: 300;\n  background-color: rgba(47, 53, 60, 0.8);\n  border: 1px solid rgba(255, 255, 255, 0.6);\n  border-radius: 20px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.navigation-control {\n  cursor: pointer;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.5);\n}\n\n.naviagation-control:active {\n  color: #fff;\n}\n\n.navigation-control-last {\n  cursor: pointer;\n  border-bottom: 1px solid #555555;\n  border-bottom: 0;\n}\n\n.navigation-control-icon-zoom-in {\n  position: relative;\n  text-align: center;\n  font-size: 20px;\n  color: #ffffff;\n  padding-bottom: 4px;\n}\n\n.navigation-control-icon-zoom-out {\n  position: relative;\n  text-align: center;\n  font-size: 20px;\n  color: #ffffff;\n}\n\n.navigation-control-icon-reset {\n  position: relative;\n  text-align: center;\n  top: 3px;\n  left: 7px;\n  width: 11px;\n  display: inline-block;\n  height: 10px;\n  fill: rgba(255, 255, 255, 0.8);\n  padding-top: 6px;\n  padding-bottom: 6px;\n  box-sizing: content-box;\n}\n\n.compass {\n  pointer-events: auto;\n  position: absolute;\n  right: 0px;\n  top: 10px;\n  width: 95px;\n  height: 95px;\n  overflow: hidden;\n}\n\n.compass-outer-ring {\n  position: absolute;\n  top: 0;\n  width: 95px;\n  height: 95px;\n  fill: rgba(255, 255, 255, 0.5);\n}\n\n.compass-outer-ring-background {\n  position: absolute;\n  top: 14px;\n  left: 14px;\n  width: 44px;\n  height: 44px;\n  border-radius: 44px;\n  border: 12px solid rgba(47, 53, 60, 0.8);\n  box-sizing: content-box;\n}\n\n.compass-gyro {\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  width: 95px;\n  height: 95px;\n  fill: #ccc;\n}\n\n.compass-gyro-active {\n  fill: #68adfe;\n}\n\n.compass-gyro-background {\n  position: absolute;\n  top: 30px;\n  left: 30px;\n  width: 33px;\n  height: 33px;\n  border-radius: 33px;\n  background-color: rgba(47, 53, 60, 0.8);\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  box-sizing: content-box;\n}\n\n.compass-gyro-background:hover + .compass-gyro {\n  fill: #68adfe;\n}\n\n.compass-rotation-marker {\n  position: absolute;\n  top: 0;\n  width: 95px;\n  height: 95px;\n  fill: #68adfe;\n}\n\n@media screen and (max-width: 700px), screen and (max-height: 420px) {\n  .navigation-controls {\n    /* display: none; */\n  }\n\n  .compass {\n    /* display: none; */\n  }\n}\n\n@media print {\n  .navigation-controls {\n    /* display: none; */\n  }\n\n  .compass {\n    /* display: none; */\n  }\n}\n";
  styleInject(css_248z);

  /**
   *  getUid方法的计数器
   * @type {number}
   * @private
   */
  var uidCounter$1 = 0;
  /**
   * 生成全局唯一ID
   */
  function getUid$1() {
      return ++uidCounter$1 + "";
  }
  var MAP_MOUSE_EVENT_TYPE = [
      BaseEventType.CLICK,
      BaseEventType.DOUBLE_CLICK,
      BaseEventType.MOUSE_DOWN,
      BaseEventType.MOUSE_UP,
      BaseEventType.MOUSE_MOVE,
      BaseEventType.RIGHT_CLICK
  ];
  function isMapMouseEventType(type) {
      return MAP_MOUSE_EVENT_TYPE.includes(type);
  }

  /**
   *  getUid方法的计数器
   * @type {number}
   * @private
   */
  var uidCounter = 0;
  /**
   * 生成全局唯一ID
   */
  function getUid() {
      return ++uidCounter + "";
  }
  function VOID() {
      // 一个可重用的函数，例如用作回调的默认值。
  }
  /**
   *
   * @param target 事件目标.
   * @param {string} type 事件类型.
   * @param {ListenerFunction} listener 事件监听器.
   * @param {Object=} optThis Object 事件监听器执行的上下文，默认为target
   * @param {boolean=} optOnce 如果为真，则将侦听器添加为一次性侦听器。.
   * @return {EventsKey} 该监听器的唯一值
   * @ignore
   */
  function listen(target, type, listener, optThis, optOnce) {
      if (optThis && optThis !== target) {
          listener = listener.bind(optThis);
      }
      if (optOnce) {
          var originalListener_1 = listener;
          listener = function (e) {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  function listenOnce(target, type, listener, optThis) {
      return listen(target, type, listener, optThis, true);
  }
  /**
   * 在事件目标上注销事件监听器.
   */
  function unListenByKey(key) {
      if (key === null || key === void 0 ? void 0 : key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clearProperty(key);
      }
  }
  /**
   * 使用' on() '或' once() '返回的唯一值删除事件监听器。.
   */
  function unByKey(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unListenByKey(key[i]);
          }
      }
      else {
          unListenByKey(key);
      }
  }
  [
      BaseEventType.CLICK,
      BaseEventType.DOUBLE_CLICK,
      BaseEventType.MOUSE_DOWN,
      BaseEventType.MOUSE_UP,
      BaseEventType.MOUSE_MOVE,
      BaseEventType.RIGHT_CLICK
  ];

  /**
   * 事件基础类，如果需要定义更高级别的事件，需要继承此类
   *
   * @ignore
   */
  var BaseEvent = /** @class */ (function () {
      /**
       * @param {string} type 事件类型
       */
      function BaseEvent(type) {
          this.propagationStopped = false;
          /**
           * 事件类型
           * @type {string}
           */
          this.type = type;
      }
      /**
       * 阻止事件传播
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * 阻止事件传播
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());

  var Destroyer = /** @class */ (function () {
      function Destroyer() {
          /**
           * @ignore
           */
          this._destroyed = false;
      }
      Object.defineProperty(Destroyer.prototype, "destroyed", {
          /**
           * 对象是否已经销毁
           */
          get: function () {
              return this._destroyed;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 销毁对象
       *
       * 未从地球移除时,请勿调用该方法
       */
      Destroyer.prototype.destroy = function () {
          if (!this._destroyed) {
              this._destroyed = true;
              this._destroy();
          }
      };
      /**
       * @ignore
       */
      Destroyer.prototype._destroy = function () {
          // 需子类重写
      };
      return Destroyer;
  }());

  var EventTarget = /** @class */ (function (_super) {
      __extends$3(EventTarget, _super);
      function EventTarget() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * @ignore
           */
          _this._pendingRemovals = {};
          /**
           * @ignore
           */
          _this._dispatching = {};
          /**
           * @ignore
           */
          _this._listeners = {};
          return _this;
      }
      Object.defineProperty(EventTarget.prototype, "listeners", {
          /**
           * @ignore
           */
          get: function () {
              return this._listeners;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      EventTarget.prototype.addEventListener = function (type, listener) {
          var _a;
          if (!type || !listener) {
              return false;
          }
          var listeners = this._listeners[type] || (this._listeners[type] = []);
          if (listeners.indexOf(listener) === -1) {
              listeners.push(listener);
              if (defined$1(this["registerEventEnable"])) {
                  this["registerEventEnable"](type);
              }
              else if (defined$1((_a = this["map"]) === null || _a === void 0 ? void 0 : _a["registerEventEnable"])) {
                  this["map"]["registerEventEnable"](type);
              }
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype.dispatchEvent = function (event) {
          var evt = typeof event === "string" ? new BaseEvent(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this;
          }
          // 获取该事件类型的监听器
          var listeners = this._listeners[type];
          var propagate;
          if (listeners) {
              // 没有该属性
              if (!(type in this._dispatching)) {
                  this._dispatching[type] = 0;
                  this._pendingRemovals[type] = 0;
              }
              ++this._dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --this._dispatching[type];
              if (this._dispatching[type] === 0) {
                  var pendingRemovals = this._pendingRemovals[type];
                  delete this._pendingRemovals[type];
                  while (pendingRemovals--) {
                      this.removeEventListener(type, VOID);
                  }
                  delete this._dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype.getListeners = function (type) {
          return this._listeners[type];
      };
      /**
       * @ignore
       */
      EventTarget.prototype.hasListener = function (type) {
          return type ? type in this._listeners : Object.keys(this._listeners).length > 0;
      };
      /**
       * @ignore
       */
      EventTarget.prototype.removeEventListener = function (type, listener) {
          var _a;
          var listeners = this._listeners[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (type in this._pendingRemovals) {
                      listeners[index] = VOID;
                      ++this._pendingRemovals[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this._listeners[type];
                      }
                      if (defined$1(this["unregisterEventEnable"])) {
                          this["unregisterEventEnable"](type);
                      }
                      else if (defined$1((_a = this["map"]) === null || _a === void 0 ? void 0 : _a["unregisterEventEnable"])) {
                          this["map"]["unregisterEventEnable"](type);
                      }
                  }
              }
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype._destroy = function () {
          for (var property in this._listeners) {
              delete this._listeners[property];
          }
      };
      return EventTarget;
  }(Destroyer));

  var Observable = /** @class */ (function (_super) {
      __extends$3(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          _this._revision = 0;
          return _this;
      }
      /**
       * 增加版本号，触发一次更改事件
       * @ignore
       */
      Observable.prototype.changed = function () {
          ++this._revision;
          this.dispatchEvent(BaseEventType.CHANGE);
      };
      /**
       * 获取该对象的版本号。每次对象被修改时，其版本号都会递增
       * @return {number} Revision.
       * @ignore
       */
      Observable.prototype.getRevision = function () {
          return this._revision;
      };
      /**
       * 注册事件
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Observable.prototype.on = function (type, listener) {
          return on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Observable.prototype.once = function (type, listener) {
          return once.call(this, type, listener);
      };
      /**
       * 注销事件类型的监听
       *
       * @param {(string | string[])} type 事件类型，或者事件类型数组
       * @param {Function} listener 事件监听器
       */
      Observable.prototype.un = function (type, listener) {
          un.call(this, type, listener);
      };
      /**
       * 注销事件
       *
       * @param {(eventKey | eventKey[])} key
       */
      Observable.prototype.unByKey = function (key) {
          unByKey(key);
      };
      return Observable;
  }(EventTarget));
  function once(type, listener) {
      if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
              keys[i] = listenOnce(this, type[i], listener);
          }
          return keys;
      }
      else {
          return listenOnce(this, type, listener);
      }
  }
  function un(type, listener) {
      if (Array.isArray(type)) {
          for (var i = 0, ii = type.length; i < ii; ++i) {
              this.removeEventListener(type[i], listener);
          }
      }
      else {
          this.removeEventListener(type, listener);
      }
  }
  function on(type, listener) {
      if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
              keys[i] = listen(this, type[i], listener);
          }
          return keys;
      }
      else {
          return listen(this, type, listener);
      }
  }

  /**
   * 对象事件，继承事件类，该对象事件用于对象属性变化的监听
   * @ignore
   */
  var ObjectEvent = /** @class */ (function (_super) {
      __extends$3(ObjectEvent, _super);
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          _this.key = key;
          _this.oldValue = oldValue;
          return _this;
      }
      ObjectEvent.PROPERTYCHANGE = "propertychange";
      return ObjectEvent;
  }(BaseEvent));

  /**
   * @ignore
   */
  var AbstractObject = /** @class */ (function (_super) {
      __extends$3(AbstractObject, _super);
      function AbstractObject(values) {
          var _this = _super.call(this) || this;
          /**
           * @ignore
           */
          _this._values = {};
          /**
           * @ignore
           */
          _this._uid = getUid$1();
          if (values) {
              _this._values = values;
          }
          return _this;
      }
      Object.defineProperty(AbstractObject.prototype, "uid", {
          /**
           * 全局唯一id
           */
          get: function () {
              return this._uid;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 根据key获取监听属性值
       *
       * @param {string} key
       * @returns {*}
       * @ignore
       */
      AbstractObject.prototype.get = function (key) {
          var value;
          if (Object.hasOwnProperty.call(this._values, key)) {
              value = this._values[key];
          }
          return value;
      };
      /**
       * 获取当前对象监听的属性key列表
       *
       * @returns {string[]}
       * @ignore
       */
      AbstractObject.prototype.getKeys = function () {
          return Object.keys(this._values);
      };
      /**
       * @ignore
       * @returns
       */
      AbstractObject.prototype.getAttributes = function () {
          return Object.assign({}, this._values);
      };
      /**
       * 分发事件-----
       * @param {string} key 键值
       * @param {*} oldValue 该键值的旧值
       * @ignore
       */
      AbstractObject.prototype.notify = function (key, oldValue) {
          this.dispatchEvent(new ObjectEvent(getChangeEventType(key), key, oldValue));
          this.dispatchEvent(new ObjectEvent(ObjectEvent.PROPERTYCHANGE, key, oldValue));
      };
      /**
       * @param {string} key 键名称
       * @param {*} value 键值.
       * @param {boolean} silent 更新属性时是否触发事件.
       * @ignore
       */
      AbstractObject.prototype.set = function (key, value, silent) {
          if (silent === void 0) { silent = false; }
          var oldValue = this._values[key];
          this._values[key] = value;
          if (oldValue !== value && !silent) {
              this.notify(key, oldValue);
          }
      };
      /**
       * @param {string} key 键值名称
       * @param {boolean} silent 是否禁止触发事件
       * @ignore
       */
      AbstractObject.prototype.unset = function (key, silent) {
          if (silent === void 0) { silent = false; }
          if (key in this._values) {
              var oldValue = this._values[key];
              delete this._values[key];
              if (!silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * @override
       */
      AbstractObject.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._values = undefined;
      };
      return AbstractObject;
  }(Observable));
  /**
   * @ignore
   */
  var changeEventTypeCache = {};
  /**
   * @ignore
   */
  function getChangeEventType(key) {
      if (!changeEventTypeCache.hasOwnProperty(key)) {
          changeEventTypeCache[key] = "change:" + key;
      }
      return changeEventTypeCache[key];
  }

  var BaseObject = /** @class */ (function (_super) {
      __extends$3(BaseObject, _super);
      function BaseObject(options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, options) || this;
          _this._id = options.id || getUid();
          _this._options = options;
          return _this;
      }
      Object.defineProperty(BaseObject.prototype, "id", {
          /**
           * 对象id
           */
          get: function () {
              return this._id;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaseObject.prototype, "map", {
          /**
           * 地图对象
           */
          get: function () {
              return this._map;
          },
          /**
           * @ignore
           */
          set: function (map) {
              var e_1, _a;
              var _b, _c, _d, _e;
              var first = !defined$1(this.map) && defined$1(map);
              var mtiMap = this._map || map;
              this._map = map;
              try {
                  for (var _f = __values(Object.keys(this.listeners)), _g = _f.next(); !_g.done; _g = _f.next()) {
                      var key = _g.value;
                      for (var index = 0, count = this.listeners[key].length; index < count; index++) {
                          if (defined$1(map)) {
                              first && ((_c = (_b = mtiMap).registerEventEnable) === null || _c === void 0 ? void 0 : _c.call(_b, key));
                          }
                          else {
                              (_e = (_d = mtiMap).unregisterEventEnable) === null || _e === void 0 ? void 0 : _e.call(_d, key);
                          }
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaseObject.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 重写父类销毁方法
       * @ignore
       */
      BaseObject.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._map = undefined;
          this._options = undefined;
      };
      return BaseObject;
  }(AbstractObject));

  /**
   * 图层基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Layer = /** @class */ (function (_super) {
      __extends$3(Layer, _super);
      function Layer(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, basemap: false }, options)) || this;
          /**
           * @ignore
           */
          _this._visible = true;
          /**
           * @ignore
           */
          _this._initialized = false;
          _this._basemap = _this.options.basemap;
          if (defined$1(map)) {
              map.addLayer(_this);
          }
          return _this;
      }
      Object.defineProperty(Layer.prototype, "visible", {
          /**
           * 图层显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "layer", {
          /**
           * 内部图层对象
           *
           * @ignore
           */
          get: function () {
              return this._layer;
          },
          /**
           * @ignore
           *
           * @
           */
          set: function (layer) {
              this._layer = layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "initialized", {
          /**
           * 初始化状态
           *
           * @ignore
           */
          get: function () {
              return this._initialized;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "basemap", {
          /**
           * 是否为底图图层
           */
          get: function () {
              return this._basemap;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "zIndex", {
          /**
           * 图层zIndex 数值大的图层显示在上方
           */
          get: function () {
              return this._zIndex;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化图层
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Layer.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Layer.prototype.addTo = function (map) {
          this.map = map;
          this.initialized || this.init();
          /** 子类有不同实现,自行重写 */
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Layer.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 显示图层
       */
      Layer.prototype.show = function () {
          if (this.visible === true)
              return;
          this.dispatchEvent({
              type: BaseEventType.SHOW,
              target: this
          });
          this._visible = true;
          this._setVisible();
          return this;
      };
      /**
       * 隐藏图层
       */
      Layer.prototype.hide = function () {
          if (this.visible === false)
              return;
          this.dispatchEvent({
              type: BaseEventType.HIDE,
              target: this
          });
          this._visible = false;
          this._setVisible();
          return this;
      };
      /**
       * @ignore
       */
      Layer.prototype._setVisible = function () {
          var _this = this;
          var _a, _b;
          (_b = (_a = this.layer) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, function (i) {
              i.show = _this._visible;
          });
      };
      /**
       * 设置图层zIndex 数值大的图层显示在上方
       *
       * [ol]
       */
      Layer.prototype.setZIndex = function (zIndex) {
          this._zIndex = zIndex;
          return this;
      };
      return Layer;
  }(BaseObject));

  /**
   * 高德图层
   */
  var AMapLayer = /** @class */ (function (_super) {
      __extends$3(AMapLayer, _super);
      function AMapLayer(options, map) {
          return _super.call(this, __assign$1({ maxLevel: 18, type: MapType.VECTOR, visible: true }, options), map) || this;
      }
      Object.defineProperty(AMapLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      AMapLayer.prototype.init = function () {
          this._initialized = true;
          var _a = this.options, type = _a.type, maxLevel = _a.maxLevel;
          if (type === MapType.LABEL) {
              this._layer = [
                  Object.assign(new Cesium__namespace.ImageryLayer(
                  // @ts-ignore
                  new Cesium__namespace.UrlTemplateImageryProvider({
                      url: "//webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8",
                      subdomains: ["1", "2", "3", "4"],
                      maximumLevel: maxLevel
                  })), { id: this.id + "-label" })
              ];
          }
          else {
              this._layer = [
                  Object.assign(new Cesium__namespace.ImageryLayer(
                  // @ts-ignore
                  new Cesium__namespace.UrlTemplateImageryProvider({
                      url: "//webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=".concat(type === MapType.IMAGE ? 6 : 7),
                      subdomains: ["1", "2", "3", "4"],
                      maximumLevel: maxLevel
                  })), { id: this.id })
              ];
          }
      };
      /**
       * @ignore
       */
      AMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      /**
       * @ignore
       */
      AMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = void 0;
      };
      /**
       * @ignore
       */
      AMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = void 0;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return AMapLayer;
  }(Layer));

  /**
   * @Author: Caven
   * @Date: 2021-01-30 22:41:41
   */

  const EARTH_RADIUS = 6370996.81;
  const MC_BAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];
  const LL_BAND = [75, 60, 45, 30, 15, 0];
  const MC2LL = [
    [
      1.410526172116255e-8, 8.98305509648872e-6, -1.9939833816331, 2.009824383106796e2, -1.872403703815547e2,
      91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 1.73379812e7
    ],
    [
      -7.435856389565537e-9, 8.983055097726239e-6, -0.78625201886289, 96.32687599759846, -1.85204757529826,
      -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486e7
    ],
    [
      -3.030883460898826e-8, 8.98305509983578e-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745,
      13.45380521110908, -3.29883767235584, 0.32710905363475, 6.85681737e6
    ],
    [
      -1.981981304930552e-8, 8.983055099779535e-6, 0.03278182852591, 40.31678527705744, 0.65659298677277,
      -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4.48277706e6
    ],
    [
      3.09191371068437e-9, 8.983055096812155e-6, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242,
      -0.00663494467273, 0.03430082397953, -0.00466043876332, 2.5551644e6
    ],
    [
      2.890871144776878e-9, 8.983055095805407e-6, -0.00000003068298, 7.47137025468032, -0.00000353937994,
      -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 8.260885e5
    ]
  ];
  const LL2MC = [
    [
      -0.0015702102444, 1.113207020616939e5, 1.704480524535203e15, -1.033898737604234e16, 2.611266785660388e16,
      -3.51496691766537e16, 2.659570071840392e16, -1.072501245418824e16, 1.800819912950474e15, 82.5
    ],
    [
      8.277824516172526e-4, 1.113207020463578e5, 6.477955746671608e8, -4.082003173641316e9, 1.077490566351142e10,
      -1.517187553151559e10, 1.205306533862167e10, -5.124939663577472e9, 9.133119359512032e8, 67.5
    ],
    [
      0.00337398766765, 1.113207020202162e5, 4.481351045890365e6, -2.339375119931662e7, 7.968221547186455e7,
      -1.159649932797253e8, 9.723671115602145e7, -4.366194633752821e7, 8.477230501135234e6, 52.5
    ],
    [
      0.00220636496208, 1.113207020209128e5, 5.175186112841131e4, 3.796837749470245e6, 9.920137397791013e5,
      -1.22195221711287e6, 1.340652697009075e6, -6.209436990984312e5, 1.444169293806241e5, 37.5
    ],
    [
      -3.441963504368392e-4, 1.113207020576856e5, 2.782353980772752e2, 2.485758690035394e6, 6.070750963243378e3,
      5.482118345352118e4, 9.540606633304236e3, -2.71055326746645e3, 1.405483844121726e3, 22.5
    ],
    [
      -3.218135878613132e-4, 1.113207020701615e5, 0.00369383431289, 8.237256402795718e5, 0.46104986909093,
      2.351343141331292e3, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45
    ]
  ];

  class BaiduMercatorProjection {
    constructor() {
      this.isWgs84 = false;
    }

    getDistanceByMC(point1, point2) {
      if (!point1 || !point2) {
        return 0;
      }
      point1 = this.convertMC2LL(point1);
      if (!point1) {
        return 0;
      }
      let x1 = this.toRadians(point1["lng"]);
      let y1 = this.toRadians(point1["lat"]);
      point2 = this.convertMC2LL(point2);
      if (!point2) {
        return 0;
      }
      let x2 = this.toRadians(point2["lng"]);
      let y2 = this.toRadians(point2["lat"]);
      return this.getDistance(x1, x2, y1, y2);
    }

    /**
     * 根据经纬度坐标计算两点间距离;
     * @param point1
     * @param point2
     * @returns {number|*} 返回两点间的距离
     */
    getDistanceByLL(point1, point2) {
      if (!point1 || !point2) {
        return 0;
      }
      point1["lng"] = this.getLoop(point1["lng"], -180, 180);
      point1["lat"] = this.getRange(point1["lat"], -74, 74);
      point2["lng"] = this.getLoop(point2["lng"], -180, 180);
      point2["lat"] = this.getRange(point2["lat"], -74, 74);
      let x1 = this.toRadians(point1["lng"]);
      let y1 = this.toRadians(point1["lat"]);
      let x2 = this.toRadians(point2["lng"]);
      let y2 = this.toRadians(point2["lat"]);
      return this.getDistance(x1, x2, y1, y2);
    }

    /**
     * 平面直角坐标转换成经纬度坐标;
     * @param point
     * @returns {Point|{lng: number, lat: number}}
     */
    convertMC2LL(point) {
      if (!point) {
        return { lng: 0, lat: 0 };
      }
      let lnglat = {};
      if (this.isWgs84) {
        lnglat.lng = (point.lng / 20037508.34) * 180;
        let mmy = (point.lat / 20037508.34) * 180;
        lnglat.lat = (180 / Math.PI) * (2 * Math.atan(Math.exp((mmy * Math.PI) / 180)) - Math.PI / 2);
        return {
          lng: lnglat["lng"].toFixed(6),
          lat: lnglat["lat"].toFixed(6)
        };
      }

      let temp = {
        lng: Math.abs(point["lng"]),
        lat: Math.abs(point["lat"])
      };

      let factor = undefined;
      for (let i = 0; i < MC_BAND.length; i++) {
        if (temp["lat"] >= MC_BAND[i]) {
          factor = MC2LL[i];
          break;
        }
      }
      lnglat = this.convertor(point, factor);
      return {
        lng: lnglat["lng"].toFixed(6),
        lat: lnglat["lat"].toFixed(6)
      };
    }

    /**
     * 经纬度坐标转换成平面直角坐标;
     * @param point 经纬度坐标
     * @returns {{lng: number, lat: number}|*}
     */
    convertLL2MC(point) {
      if (!point) {
        return { lng: 0, lat: 0 };
      }
      if (point["lng"] > 180 || point["lng"] < -180 || point["lat"] > 90 || point["lat"] < -90) {
        return point;
      }

      if (this.isWgs84) {
        let mercator = {};
        let earthRad = 6378137.0;
        mercator.lng = ((point.lng * Math.PI) / 180) * earthRad;
        let a = (point.lat * Math.PI) / 180;
        mercator.lat = (earthRad / 2) * Math.log((1.0 + Math.sin(a)) / (1.0 - Math.sin(a)));

        return {
          lng: parseFloat(mercator["lng"].toFixed(2)),
          lat: parseFloat(mercator["lat"].toFixed(2))
        };
      }

      point["lng"] = this.getLoop(point["lng"], -180, 180);
      point["lat"] = this.getRange(point["lat"], -74, 74);
      let temp = { lng: point["lng"], lat: point["lat"] };
      let factor = undefined;
      for (let i = 0; i < LL_BAND.length; i++) {
        if (temp["lat"] >= LL_BAND[i]) {
          factor = LL2MC[i];
          break;
        }
      }
      if (!factor) {
        for (let i = 0; i < LL_BAND.length; i++) {
          if (temp["lat"] <= -LL_BAND[i]) {
            factor = LL2MC[i];
            break;
          }
        }
      }
      let mc = this.convertor(point, factor);
      return {
        lng: parseFloat(mc["lng"].toFixed(2)),
        lat: parseFloat(mc["lat"].toFixed(2))
      };
    }

    /**
     *
     * @param fromPoint
     * @param factor
     * @returns {{lng: *, lat: *}}
     */
    convertor(fromPoint, factor) {
      if (!fromPoint || !factor) {
        return { lng: 0, lat: 0 };
      }
      let x = factor[0] + factor[1] * Math.abs(fromPoint["lng"]);
      let temp = Math.abs(fromPoint["lat"]) / factor[9];
      let y =
        factor[2] +
        factor[3] * temp +
        factor[4] * temp * temp +
        factor[5] * temp * temp * temp +
        factor[6] * temp * temp * temp * temp +
        factor[7] * temp * temp * temp * temp * temp +
        factor[8] * temp * temp * temp * temp * temp * temp;
      x *= fromPoint["lng"] < 0 ? -1 : 1;
      y *= fromPoint["lat"] < 0 ? -1 : 1;
      return {
        lng: x,
        lat: y
      };
    }

    /**
     *
     * @param x1
     * @param x2
     * @param y1
     * @param y2
     * @returns {number}
     */
    getDistance(x1, x2, y1, y2) {
      return EARTH_RADIUS * Math.acos(Math.sin(y1) * Math.sin(y2) + Math.cos(y1) * Math.cos(y2) * Math.cos(x2 - x1));
    }

    /**
     *
     * @param deg
     * @returns {number}
     */
    toRadians(deg) {
      return (Math.PI * deg) / 180;
    }

    /**
     *
     * @param rad
     * @returns {number}
     */
    toDegrees(rad) {
      return (180 * rad) / Math.PI;
    }

    /**
     *
     * @param v
     * @param a
     * @param b
     * @returns {number}
     */
    getRange(v, a, b) {
      if (a != null) {
        v = Math.max(v, a);
      }
      if (b != null) {
        v = Math.min(v, b);
      }
      return v;
    }

    /**
     *
     * @param v
     * @param a
     * @param b
     * @returns {*}
     */
    getLoop(v, a, b) {
      while (v > b) {
        v -= b - a;
      }
      while (v < a) {
        v += b - a;
      }
      return v;
    }

    /**
     *
     * @param point
     * @returns {{lng: number, lat: number}|*}
     */
    lngLatToMercator(point) {
      return this.convertLL2MC(point);
    }

    /**
     *
     * @param point
     * @returns {{x: (number|*), y: (number|*)}}
     */
    lngLatToPoint(point) {
      let mercator = this.convertLL2MC(point);
      return {
        x: mercator["lng"],
        y: mercator["lat"]
      };
    }

    /**
     * 墨卡托变换至经纬度
     * @param point 墨卡托
     * @returns Point 经纬度
     */
    mercatorToLngLat(point) {
      return this.convertMC2LL(point);
    }

    /**
     * 平面到球面坐标
     * @param point 平面坐标
     * @returns Point 球面坐标
     */
    pointToLngLat(point) {
      let mercator = { lng: point.x, lat: point.y };
      return this.convertMC2LL(mercator);
    }

    /**
     * 地理坐标转换至像素坐标
     * @param point 地理坐标
     * @param zoom 级别
     * @param mapCenter 地图中心点，注意为了保证没有误差，这里需要传递墨卡托坐标
     * @param mapSize 地图容器大小
     */
    pointToPixel(point, zoom, mapCenter, mapSize) {
      if (!point) {
        return;
      }
      point = this.lngLatToMercator(point);
      let zoomUnits = this.getZoomUnits(zoom);
      let x = Math.round((point["lng"] - mapCenter["lng"]) / zoomUnits + mapSize.width / 2);
      let y = Math.round((mapCenter["lat"] - point["lat"]) / zoomUnits + mapSize.height / 2);
      return { x, y };
    }

    /**
     * 像素坐标转换至地理坐标
     * @param pixel 像素坐标
     * @param zoom 级别
     * @param mapCenter 地图中心点，注意为了保证没有误差，这里需要传递墨卡托坐标
     * @param mapSize 地图容器大小
     */
    pixelToPoint(pixel, zoom, mapCenter, mapSize) {
      if (!pixel) {
        return;
      }
      let zoomUnits = this.getZoomUnits(zoom);
      let lng = mapCenter["lng"] + zoomUnits * (pixel.x - mapSize.width / 2);
      let lat = mapCenter["lat"] - zoomUnits * (pixel.y - mapSize.height / 2);
      let point = { lng, lat };
      return this.mercatorToLngLat(point);
    }

    /**
     *
     * @param zoom
     * @returns {number}
     */
    getZoomUnits(zoom) {
      return Math.pow(2, 18 - zoom);
    }
  }

  /**
   * @Author: Caven
   * @Date: 2021-01-31 20:40:25
   */

  const BD_FACTOR = (3.14159265358979324 * 3000.0) / 180.0;
  const PI = 3.1415926535897932384626;
  const RADIUS = 6378245.0;
  const EE = 0.00669342162296594323;

  class CoordTransform {
    /**
     * BD-09 To GCJ-02
     * @param lng
     * @param lat
     * @returns {number[]}
     */
    static BD09ToGCJ02(lng, lat) {
      let x = +lng - 0.0065;
      let y = +lat - 0.006;
      let z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * BD_FACTOR);
      let theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * BD_FACTOR);
      let gg_lng = z * Math.cos(theta);
      let gg_lat = z * Math.sin(theta);
      return [gg_lng, gg_lat];
    }

    /**
     * GCJ-02 To BD-09
     * @param lng
     * @param lat
     * @returns {number[]}
     * @constructor
     */
    static GCJ02ToBD09(lng, lat) {
      lat = +lat;
      lng = +lng;
      let z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * BD_FACTOR);
      let theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * BD_FACTOR);
      let bd_lng = z * Math.cos(theta) + 0.0065;
      let bd_lat = z * Math.sin(theta) + 0.006;
      return [bd_lng, bd_lat];
    }

    /**
     * WGS-84 To GCJ-02
     * @param lng
     * @param lat
     * @returns {number[]}
     */
    static WGS84ToGCJ02(lng, lat) {
      lat = +lat;
      lng = +lng;
      if (this.out_of_china(lng, lat)) {
        return [lng, lat];
      } else {
        let d = this.delta(lng, lat);
        return [lng + d[0], lat + d[1]];
      }
    }

    /**
     * GCJ-02 To WGS-84
     * @param lng
     * @param lat
     * @returns {number[]}
     * @constructor
     */
    static GCJ02ToWGS84(lng, lat) {
      lat = +lat;
      lng = +lng;
      if (this.out_of_china(lng, lat)) {
        return [lng, lat];
      } else {
        let d = this.delta(lng, lat);
        let mgLng = lng + d[0];
        let mgLat = lat + d[1];
        return [lng * 2 - mgLng, lat * 2 - mgLat];
      }
    }

    /**
     *
     * @param lng
     * @param lat
     * @returns {number[]}
     */
    static delta(lng, lat) {
      let dLng = this.transformLng(lng - 105, lat - 35);
      let dLat = this.transformLat(lng - 105, lat - 35);
      const radLat = (lat / 180) * PI;
      let magic = Math.sin(radLat);
      magic = 1 - EE * magic * magic;
      const sqrtMagic = Math.sqrt(magic);
      dLng = (dLng * 180) / ((RADIUS / sqrtMagic) * Math.cos(radLat) * PI);
      dLat = (dLat * 180) / (((RADIUS * (1 - EE)) / (magic * sqrtMagic)) * PI);
      return [dLng, dLat];
    }

    /**
     *
     * @param lng
     * @param lat
     * @returns {number}
     */
    static transformLng(lng, lat) {
      lat = +lat;
      lng = +lng;
      let ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
      ret += ((20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0) / 3.0;
      ret += ((20.0 * Math.sin(lng * PI) + 40.0 * Math.sin((lng / 3.0) * PI)) * 2.0) / 3.0;
      ret += ((150.0 * Math.sin((lng / 12.0) * PI) + 300.0 * Math.sin((lng / 30.0) * PI)) * 2.0) / 3.0;
      return ret;
    }

    /**
     *
     * @param lng
     * @param lat
     * @returns {number}
     */
    static transformLat(lng, lat) {
      lat = +lat;
      lng = +lng;
      let ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
      ret += ((20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0) / 3.0;
      ret += ((20.0 * Math.sin(lat * PI) + 40.0 * Math.sin((lat / 3.0) * PI)) * 2.0) / 3.0;
      ret += ((160.0 * Math.sin((lat / 12.0) * PI) + 320 * Math.sin((lat * PI) / 30.0)) * 2.0) / 3.0;
      return ret;
    }

    /**
     *
     * @param lng
     * @param lat
     * @returns {boolean}
     */
    static out_of_china(lng, lat) {
      lat = +lat;
      lng = +lng;
      return !(lng > 73.66 && lng < 135.05 && lat > 3.86 && lat < 53.55);
    }
  }

  /**
   * @Author: Caven
   * @Date: 2021-01-31 19:22:04
   */

  class BaiduMercatorTilingScheme extends Cesium__namespace.WebMercatorTilingScheme {
    constructor(options) {
      super(options);
      let projection = new BaiduMercatorProjection();
      this._projection.project = function (cartographic, result) {
        result = result || {};
        result = CoordTransform.WGS84ToGCJ02(
          Cesium__namespace.Math.toDegrees(cartographic.longitude),
          Cesium__namespace.Math.toDegrees(cartographic.latitude)
        );
        result = CoordTransform.GCJ02ToBD09(result[0], result[1]);
        result[0] = Math.min(result[0], 180);
        result[0] = Math.max(result[0], -180);
        result[1] = Math.min(result[1], 74.000022);
        result[1] = Math.max(result[1], -71.988531);
        result = projection.lngLatToPoint({
          lng: result[0],
          lat: result[1]
        });
        return new Cesium__namespace.Cartesian2(result.x, result.y);
      };
      this._projection.unproject = function (cartesian, result) {
        result = result || {};
        result = projection.mercatorToLngLat({
          lng: cartesian.x,
          lat: cartesian.y
        });
        result = CoordTransform.BD09ToGCJ02(result.lng, result.lat);
        result = CoordTransform.GCJ02ToWGS84(result[0], result[1]);
        return new Cesium__namespace.Cartographic(Cesium__namespace.Math.toRadians(result[0]), Cesium__namespace.Math.toRadians(result[1]));
      };
      this.resolutions = options.resolutions || [];
    }

    /**
     *
     * @param x
     * @param y
     * @param level
     * @param result
     * @returns {module:cesium.Rectangle|*}
     */
    tileXYToNativeRectangle(x, y, level, result) {
      const tileWidth = this.resolutions[level];
      const west = x * tileWidth;
      const east = (x + 1) * tileWidth;
      const north = ((y = -y) + 1) * tileWidth;
      const south = y * tileWidth;

      if (!Cesium__namespace.defined(result)) {
        return new Cesium__namespace.Rectangle(west, south, east, north);
      }

      result.west = west;
      result.south = south;
      result.east = east;
      result.north = north;
      return result;
    }

    /**
     *
     * @param position
     * @param level
     * @param result
     * @returns {undefined|*}
     */
    positionToTileXY(position, level, result) {
      const rectangle = this._rectangle;
      if (!Cesium__namespace.Rectangle.contains(rectangle, position)) {
        return undefined;
      }
      const projection = this._projection;
      const webMercatorPosition = projection.project(position);
      if (!Cesium__namespace.defined(webMercatorPosition)) {
        return undefined;
      }
      const tileWidth = this.resolutions[level];
      const xTileCoordinate = Math.floor(webMercatorPosition.x / tileWidth);
      const yTileCoordinate = -Math.floor(webMercatorPosition.y / tileWidth);
      if (!Cesium__namespace.defined(result)) {
        return new Cesium__namespace.Cartesian2(xTileCoordinate, yTileCoordinate);
      }
      result.x = xTileCoordinate;
      result.y = yTileCoordinate;
      return result;
    }
  }

  var TILE_URL = {
      img: "//shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46",
      label: "//online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=sl&v=020",
      vec: "//maponline{s}.bdimg.com/tile/?qt=vtile&x={x}&y={y}&z={z}&styles=pl&scaler=1&udt=20220720&from=jsapi2_0",
      //vec: "http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=sl&v=020",
      traffic: "//its.map.baidu.com:8002/traffic/TrafficTileService?time={time}&label={labelStyle}&v=016&level={z}&x={x}&y={y}&scaler=2"
  };
  var BaiduImageryProvider = /** @class */ (function () {
      function BaiduImageryProvider(options) {
          //crs:BD09
          this._url = options.url ? options.url : TILE_URL[options.type];
          this._translationXY = options.translationXY ? options.translationXY : [0, 0];
          this._labelStyle = "web2D";
          this._tileWidth = 256;
          this._tileHeight = 256;
          this._maximumLevel = options.maxLevel;
          this._crs = options.crs ? options.crs : "WGS84";
          if (options.crs === "WGS84") {
              var resolutions = [];
              for (var i = 0; i < 19; i++) {
                  resolutions[i] = 256 * Math.pow(2, 18 - i);
              }
              this._tilingScheme = new BaiduMercatorTilingScheme({
                  resolutions: resolutions,
                  rectangleSouthwestInMeters: new Cesium__namespace.Cartesian2(-20037726.37, -12474104.17),
                  rectangleNortheastInMeters: new Cesium__namespace.Cartesian2(20037726.37, 12474104.17)
              });
          }
          else {
              this._tilingScheme = new Cesium__namespace.WebMercatorTilingScheme({
                  rectangleSouthwestInMeters: new Cesium__namespace.Cartesian2(-33554054 - this._translationXY[0], -33746824 - this._translationXY[1]),
                  rectangleNortheastInMeters: new Cesium__namespace.Cartesian2(33554054 - this._translationXY[0], 33746824 - this._translationXY[1])
              });
          }
          this._rectangle = this._tilingScheme.rectangle;
          this._credit = undefined;
          //this._errorEvent = new Cesium.Event()
          this._rectangle = this._tilingScheme.rectangle;
          //this._rectangle =new Cesium.Rectangle(-3.1416268371156026, -1.2897471283464266, 3.1416268371156026, 1.2897471283464264)
      }
      Object.defineProperty(BaiduImageryProvider.prototype, "url", {
          get: function () {
              return this._url;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "token", {
          get: function () {
              return this._token;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "tileWidth", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("tileWidth must not be called before the imagery provider is ready.");
              }
              return this._tileWidth;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "tileHeight", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("tileHeight must not be called before the imagery provider is ready.");
              }
              return this._tileHeight;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "maximumLevel", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("maximumLevel must not be called before the imagery provider is ready.");
              }
              return this._maximumLevel;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "minimumLevel", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("minimumLevel must not be called before the imagery provider is ready.");
              }
              return 0;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "tilingScheme", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("tilingScheme must not be called before the imagery provider is ready.");
              }
              return this._tilingScheme;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "rectangle", {
          get: function () {
              if (!this.ready) {
                  throw new Cesium__namespace.DeveloperError("rectangle must not be called before the imagery provider is ready.");
              }
              return this._rectangle;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "ready", {
          get: function () {
              return !!this._url;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "credit", {
          get: function () {
              return this._credit;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaiduImageryProvider.prototype, "hasAlphaChannel", {
          get: function () {
              return true;
          },
          enumerable: false,
          configurable: true
      });
      BaiduImageryProvider.prototype.getTileCredits = function (x, y, level) { };
      /**
       * Request Image
       * @param x
       * @param y
       * @param level
       * @returns {Promise<HTMLImageElement | HTMLCanvasElement>}
       */
      BaiduImageryProvider.prototype.requestImage = function (x, y, level) {
          if (!this.ready) {
              throw new Cesium__namespace.DeveloperError("requestImage must not be called before the imagery provider is ready.");
          }
          var xTiles = this._tilingScheme.getNumberOfXTilesAtLevel(level);
          var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);
          var url = this._url.replace("{z}", level).replace("{s}", String(1));
          if (this._crs === "WGS84") {
              url = url.replace("{x}", String(x)).replace("{y}", String(-y));
          }
          else {
              url = url.replace("{x}", String(x - xTiles / 2)).replace("{y}", String(yTiles / 2 - y - 1));
          }
          // @ts-ignore
          return Cesium__namespace.ImageryProvider.loadImage(this, url);
      };
      return BaiduImageryProvider;
  }());

  /**
   * 百度图层
   */
  var BMapLayer = /** @class */ (function (_super) {
      __extends$3(BMapLayer, _super);
      function BMapLayer(options, map) {
          return _super.call(this, __assign$1({ visible: true, type: BDMapType.VEC, crs: "WGS84", translationXY: [0, 0], maxLevel: 18 }, options), map) || this;
      }
      Object.defineProperty(BMapLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      BMapLayer.prototype.init = function () {
          this._initialized = true;
          this._layer = _createBMap(this.options);
      };
      /**
       * @ignore
       */
      BMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      /**
       * @ignore
       */
      BMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      BMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return BMapLayer;
  }(Layer));
  function _createBMap(options) {
      var config = __assign$1({}, options);
      return [
          Object.assign(
          // @ts-ignore
          new Cesium__namespace.ImageryLayer(new BaiduImageryProvider(config)), {
              id: options.id
          })
      ];
  }

  var StaticImageLayer = /** @class */ (function (_super) {
      __extends$3(StaticImageLayer, _super);
      function StaticImageLayer(options, map) {
          if (!defined$1(options.url)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ opacity: 1, visible: true, extent: [-180, -90, 180, 90] }, options), map) || this;
      }
      Object.defineProperty(StaticImageLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      StaticImageLayer.prototype.init = function () {
          this._initialized = true;
          this._layer = _createImg(this.options);
      };
      StaticImageLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      StaticImageLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      StaticImageLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return StaticImageLayer;
  }(Layer));
  function _createImg(options) {
      return [
          new Cesium__namespace.ImageryLayer(new Cesium__namespace.SingleTileImageryProvider(__assign$1(__assign$1({}, options), (options.extent
              ? {
                  rectangle: new Cesium__namespace.Rectangle(Cesium__namespace.Math.toRadians(options.extent[0]), Cesium__namespace.Math.toRadians(options.extent[1]), Cesium__namespace.Math.toRadians(options.extent[2]), Cesium__namespace.Math.toRadians(options.extent[3]))
              }
              : {}))), options)
      ];
  }

  var TMapLayer = /** @class */ (function (_super) {
      __extends$3(TMapLayer, _super);
      function TMapLayer(options, map) {
          return _super.call(this, __assign$1({ type: MapType.VECTOR, language: "zh-CN", projection: WEB_MERCATOR_PROJECTION_NAME, maxLevel: 18, tk: PUBLIC_CONFIG.key.tKey }, options), map) || this;
      }
      Object.defineProperty(TMapLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      TMapLayer.prototype.init = function () {
          this._initialized = true;
          this.layer = _createTMap(this.options);
      };
      /**
       * @ignore
       */
      TMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      /**
       * @ignore
       */
      TMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      TMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return TMapLayer;
  }(Layer));
  function _createTMap(options) {
      var e_1, _a;
      options.language = options.language.toLowerCase();
      options.projection = options.projection.toLowerCase();
      var optionList = [];
      // 边界
      var boundary = "ibo".concat(options.projection.toLocaleUpperCase() === WEB_MERCATOR_PROJECTION_NAME ? "_w" : "_c");
      optionList.push({
          url: "//t{s}.tianditu.gov.cn/".concat(boundary, "/wmts?SERVICE=WMTS&LAYER=").concat(boundary.slice(0, 3), "&REQUEST=GetTile&VERSION=1.0.0&STYLE=default&TILEMATRIXSET=").concat(boundary.slice(4, 5), "&FORMAT=tiles&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}&tk=").concat(options.tk),
          subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"]
      });
      if (options.type === MapType.LABEL) {
          // 标注
          var labelName = "".concat(options.language === "zh-cn" ? "c" : "e", "va_").concat(options.projection.toLocaleUpperCase() === WEB_MERCATOR_PROJECTION_NAME ? "w" : "c");
          optionList.push({
              url: "//t{s}.tianditu.gov.cn/".concat(labelName, "/wmts?SERVICE=WMTS&LAYER=").concat(labelName.slice(0, 3), "&REQUEST=GetTile&VERSION=1.0.0&STYLE=default&TILEMATRIXSET=").concat(labelName.slice(4, 5), "&FORMAT=tiles&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}&tk=").concat(options.tk),
              subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"]
          });
      }
      else {
          // 图层名，影像还是矢量
          var layerName = options.type + (options.projection.toLocaleUpperCase() === WEB_MERCATOR_PROJECTION_NAME ? "_w" : "_c");
          optionList.push({
              url: "//t{s}.tianditu.gov.cn/".concat(layerName, "/wmts?SERVICE=WMTS&LAYER=").concat(layerName.slice(0, 3), "&REQUEST=GetTile&VERSION=1.0.0&STYLE=default&TILEMATRIXSET=").concat(layerName.slice(4, 5), "&FORMAT=tiles&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}&tk=").concat(options.tk),
              subdomains: ["0", "1", "2", "3", "4", "5", "6", "7"]
          });
      }
      var providerList = [];
      try {
          for (var optionList_1 = __values(optionList), optionList_1_1 = optionList_1.next(); !optionList_1_1.done; optionList_1_1 = optionList_1.next()) {
              var element = optionList_1_1.value;
              if (options.projection.toLocaleUpperCase() === WGS84_PROJECTION_NAME) {
                  element.tilingScheme = new Cesium__namespace.GeographicTilingScheme();
                  element.tileMatrixLabels = ["1", "2", "3", "4", "5", "6", "7"];
              }
              element.layer = "";
              element.style = "";
              element.tileMatrixSetID = "";
              if (options.maxLevel) {
                  element.maximumLevel = options.maxLevel;
              }
              providerList.push(new Cesium__namespace.ImageryLayer(new Cesium__namespace.WebMapTileServiceImageryProvider(element)));
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (optionList_1_1 && !optionList_1_1.done && (_a = optionList_1.return)) _a.call(optionList_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
      return providerList;
  }

  /**
   * 对象集合基类,提供基础集合管理方法
   *
   * @ignore
   */
  var BaseCollection = /** @class */ (function (_super) {
      __extends$3(BaseCollection, _super);
      function BaseCollection(options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this) || this;
          _this._indexArray = [];
          _this._store = new Map();
          _this._uniqueKeyName = "id";
          _this.id = options.id || getUid();
          return _this;
      }
      Object.defineProperty(BaseCollection.prototype, "map", {
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      BaseCollection.prototype.getArray = function () {
          var _this = this;
          return this._indexArray.map(function (index) {
              return _this._store.get(index);
          });
      };
      BaseCollection.prototype.getLength = function () {
          return this._indexArray.length;
      };
      BaseCollection.prototype.forEach = function (f) {
          var _this = this;
          this._indexArray.forEach(function (index) {
              f(_this._store.get(index), index);
          });
      };
      BaseCollection.prototype.include = function (id) {
          return this._indexArray.includes(id);
      };
      BaseCollection.prototype.getItem = function (id) {
          if (this.include(id)) {
              return this._store.get(id);
          }
      };
      BaseCollection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this._remove(this._indexArray[this.getLength() - 1]);
          }
      };
      BaseCollection.prototype.add = function (item) {
          if (this.include(item[this._uniqueKeyName])) {
              throw new Error("id重复：" + item[this._uniqueKeyName]);
          }
          this._indexArray.push(item[this._uniqueKeyName]);
          this._store.set(item[this._uniqueKeyName], item);
      };
      BaseCollection.prototype.pop = function () {
          if (this.getLength() > 0) {
              return this._remove(this._indexArray[this.getLength() - 1]);
          }
      };
      BaseCollection.prototype.remove = function (item) {
          if ((typeof item === "string" && this.include(item)) || (typeof item !== "string" && this.include(item))) {
              return this._remove(item);
          }
          else if (typeof item !== "string" && this.include(item[this._uniqueKeyName])) {
              return this._remove(item[this._uniqueKeyName]);
          }
      };
      BaseCollection.prototype.insertAt = function (index, item) {
          if (!this.include(item[this._uniqueKeyName]) && index <= this.getLength()) {
              this._indexArray.splice(index, 0, item[this._uniqueKeyName]);
              this._store.set(item[this._uniqueKeyName], item);
          }
      };
      BaseCollection.prototype._remove = function (id) {
          var result = this._store.get(id);
          this._store.delete(id);
          this._indexArray.splice(this._indexArray.indexOf(id), 1);
          return result;
      };
      BaseCollection.prototype[Symbol.iterator] = function () {
          var list, list_1, list_1_1, index, e_1_1;
          var e_1, _a;
          return __generator$1(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      list = __spreadArray$1([], __read(this._indexArray), false);
                      _b.label = 1;
                  case 1:
                      _b.trys.push([1, 6, 7, 8]);
                      list_1 = __values(list), list_1_1 = list_1.next();
                      _b.label = 2;
                  case 2:
                      if (!!list_1_1.done) return [3 /*break*/, 5];
                      index = list_1_1.value;
                      return [4 /*yield*/, this._store.get(index)];
                  case 3:
                      _b.sent();
                      _b.label = 4;
                  case 4:
                      list_1_1 = list_1.next();
                      return [3 /*break*/, 2];
                  case 5: return [3 /*break*/, 8];
                  case 6:
                      e_1_1 = _b.sent();
                      e_1 = { error: e_1_1 };
                      return [3 /*break*/, 8];
                  case 7:
                      try {
                          if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                      return [7 /*endfinally*/];
                  case 8: return [2 /*return*/];
              }
          });
      };
      BaseCollection.prototype._destroy = function () {
          this._map = undefined;
          this._store = undefined;
          this._indexArray = undefined;
      };
      return BaseCollection;
  }(Destroyer));

  /**
   * 原生对象链接要素对象
   */
  var FEATURE_LINK = Symbol.for("FeatureLink");
  /**
   * 原生对象链接组件对象
   */
  var COMPONENT_LINK = Symbol.for("ComponentLink");
  /**
   * 原生对象链接模型对象
   */
  var MODEL_LINK = Symbol.for("ModelLink");
  /**
   * 原生对象链接样式对象数组
   */
  var STYLE_LINK = Symbol.for("StyleLink");
  /**
   * 原生对象链接坐标索引
   */
  var COORDINATES_INDEX = Symbol.for("CoordinatesIndex");
  /**
   * 数据加载中
   */
  var LOADING_DATA = Symbol.for("LoadingData");
  var INITIALIZED = Symbol("Initialized");
  var STYLE_UID = Symbol("StyleUID");
  var NULL_STYLE_ITEM_LIST = [];
  NULL_STYLE_ITEM_LIST[INITIALIZED] = true;
  /**
   * 原生对象链接样式对象
   */
  var STYLE_ITEM_LINK = Symbol.for("StyleItemLink");

  var geometryInstanceUniqueKeyName = "__uid__";
  var geometryInstanceLinkStore = "__store__";
  var GeometryInstanceCollection = /** @class */ (function (_super) {
      __extends$3(GeometryInstanceCollection, _super);
      function GeometryInstanceCollection() {
          var _this = _super.call(this) || this;
          _this._uniqueKeyName = geometryInstanceUniqueKeyName;
          _this._show = true;
          _this._updatePrimitiveFunc = updatePrimitive.bind(_this);
          _this._instanceStore = {
              Primitive: {
                  PolylineColorAppearance: new Map(),
                  PerInstanceColorAppearance: new Map(),
                  PerInstanceColorAppearanceF: new Map(),
                  PolylineMaterialAppearance: new Map(),
                  MaterialAppearance: new Map(),
                  EllipsoidSurfaceAppearance: new Map()
              },
              GroundPolylinePrimitive: {
                  PolylineColorAppearance: new Map(),
                  PolylineMaterialAppearance: new Map()
              },
              GroundPrimitive: {
                  PerInstanceColorAppearance: new Map(),
                  PerInstanceColorAppearanceF: new Map(),
                  MaterialAppearance: new Map(),
                  EllipsoidSurfaceAppearance: new Map()
              }
          };
          _this._primitiveStore = {
              primitiveCollection: new Cesium__namespace.PrimitiveCollection({ destroyPrimitives: true }),
              groundPrimitiveCollection: new Cesium__namespace.PrimitiveCollection({
                  destroyPrimitives: true
              })
          };
          return _this;
      }
      Object.defineProperty(GeometryInstanceCollection.prototype, "show", {
          get: function () {
              return this._show;
          },
          set: function (val) {
              if (this._show === val)
                  return;
              var _a = this._primitiveStore, primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
              for (var i = 0, length_1 = primitiveCollection.length; i < length_1; ++i) {
                  primitiveCollection.get(i).show = val;
              }
              for (var i = 0, length_2 = groundPrimitiveCollection.length; i < length_2; ++i) {
                  groundPrimitiveCollection.get(i).show = val;
              }
              this._show = val;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GeometryInstanceCollection.prototype, "map", {
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 重写父类方法----
       * @override
       * @param item
       */
      GeometryInstanceCollection.prototype.add = function (item) {
          /**
           * 获取几何实例对应的要素实例的几何类型，如果为线或者多线
           */
          if (item[FEATURE_LINK].type === GeoJsonGeometryType.LINE_STRING ||
              item[FEATURE_LINK].type === GeoJsonGeometryType.MULTI_LINE_STRING ||
              item.geometry instanceof Cesium__namespace.PolylineGeometry ||
              item.geometry instanceof Cesium__namespace.GroundPolylineGeometry) {
              this.addLine(item);
              /**
               * 非多线，或者折线
               */
          }
          else {
              this.addOther(item);
          }
      };
      /**
       * 添加线
       * @param instance
       */
      GeometryInstanceCollection.prototype.addLine = function (instance) {
          var storeKey = [];
          var materialTypes = Object.keys(Cesium__namespace.Material);
          /**
           *   几何实例的几何体为线几何体，而且样式类型为颜色
           */
          if (instance.geometry instanceof Cesium__namespace.PolylineGeometry &&
              instance[STYLE_LINK].type === StyleItemType.COLOR) {
              storeKey = ["Primitive", "PolylineColorAppearance"];
          }
          else if (instance.geometry instanceof Cesium__namespace.GroundPolylineGeometry &&
              instance[STYLE_LINK].type === StyleItemType.COLOR) {
              storeKey = ["GroundPolylinePrimitive", "PolylineColorAppearance"];
          }
          else if (instance.geometry instanceof Cesium__namespace.PolylineGeometry &&
              (instance[STYLE_LINK].type === StyleItemType.IMAGE ||
                  instance[STYLE_LINK].type === StyleItemType.POLYLINE_OUTLINE ||
                  instance[STYLE_LINK].type === StyleItemType.POLYLINE_GLOW ||
                  instance[STYLE_LINK].type === StyleItemType.POLYLINE_ARROW)) {
              storeKey = ["Primitive", "PolylineMaterialAppearance"];
          }
          else if (materialTypes.includes(upperCaseFirstWord(instance[STYLE_LINK].type) + "Type")) {
              if (instance[STYLE_LINK].heightReference === 1 /* CLAMP_TO_GROUND */) {
                  storeKey = ["GroundPolylinePrimitive", "PolylineMaterialAppearance"];
              }
              else {
                  storeKey = ["Primitive", "PolylineMaterialAppearance"];
              }
          }
          this.updateStore(instance, storeKey);
      };
      /**
       * 添加面
       * @param item
       */
      GeometryInstanceCollection.prototype.addOther = function (instance) {
          var storeKey = [];
          var materialTypes = Object.keys(Cesium__namespace.Material);
          if ((instance.geometry instanceof Cesium__namespace.PolygonOutlineGeometry ||
              instance.geometry instanceof Cesium__namespace.EllipseOutlineGeometry) &&
              instance[STYLE_LINK].heightReference !== 1 /* CLAMP_TO_GROUND */) {
              storeKey = ["Primitive", "PerInstanceColorAppearance"];
          }
          else if (instance[STYLE_LINK].type === StyleItemType.COLOR) {
              if (instance[STYLE_LINK].heightReference === 1 /* CLAMP_TO_GROUND */) {
                  storeKey = ["GroundPrimitive", "PerInstanceColorAppearance"];
              }
              else {
                  storeKey = ["Primitive", "PerInstanceColorAppearance"];
              }
          }
          else if (materialTypes.includes(upperCaseFirstWord(instance[STYLE_LINK].type) + "Type")) {
              storeKey = [
                  instance[STYLE_LINK].heightReference === 1 /* CLAMP_TO_GROUND */
                      ? "GroundPrimitive"
                      : "Primitive",
                  instance[STYLE_LINK].isSurface ? "EllipsoidSurfaceAppearance" : "MaterialAppearance"
              ];
          }
          this.updateStore(instance, storeKey);
      };
      /**
       *   更新存储
       * @param instance
       * @param storeKey
       */
      GeometryInstanceCollection.prototype.updateStore = function (instance, storeKey) {
          if (storeKey) {
              _super.prototype.add.call(this, instance);
              // 对象容器---
              var map = this._instanceStore[storeKey[0]][storeKey[1]];
              var val = map.get(instance[STYLE_LINK][STYLE_UID]) || [];
              val.push(instance);
              instance[geometryInstanceLinkStore] = val;
              map.set(instance[STYLE_LINK][STYLE_UID], val);
              this._updatePrimitive();
          }
      };
      /**
       * 更新图元
       */
      GeometryInstanceCollection.prototype._updatePrimitive = function () {
          this._currentAnimationFrameId && Cesium__namespace.cancelAnimationFrame(this._currentAnimationFrameId);
          this._currentAnimationFrameId = Cesium__namespace.requestAnimationFrame(this._updatePrimitiveFunc);
      };
      /**
       *  构造时调用的函数-------
       * @returns
       */
      GeometryInstanceCollection.prototype._addPrimitive = function () {
          if (!this.map) {
              return;
          }
          var _a = this._primitiveStore, primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
          var scene = this.map.map.scene;
          scene.primitives.contains(primitiveCollection) || scene.primitives.add(primitiveCollection);
          scene.groundPrimitives.contains(groundPrimitiveCollection) || scene.groundPrimitives.add(groundPrimitiveCollection);
      };
      // 删除图元集合
      GeometryInstanceCollection.prototype._removePrimitive = function () {
          if (!this.map) {
              return;
          }
          var _a = this._primitiveStore, primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
          var scene = this.map.map.scene;
          scene.primitives.remove(primitiveCollection);
          scene.groundPrimitives.remove(groundPrimitiveCollection);
      };
      /**
       *  清除图元集合中的图元元素
       */
      GeometryInstanceCollection.prototype._clearPrimitive = function () {
          var _a = this._primitiveStore, primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
          primitiveCollection.removeAll();
          groundPrimitiveCollection.removeAll();
      };
      /**
       *  重写父类方法
       * @override
       * @param {(Cesium.GeometryInstance | string)} item
       * @returns {Cesium.GeometryInstance}
       */
      GeometryInstanceCollection.prototype.remove = function (item) {
          if (!_super.prototype.include.call(this, typeof item === "string" ? item : item[this._uniqueKeyName])) {
              return;
          }
          var res = _super.prototype.remove.call(this, item);
          var store = item[geometryInstanceLinkStore];
          var index = store.indexOf(item);
          store.splice(index, 1);
          this._updatePrimitive();
          return res;
      };
      /**
       *   添加到地图上
       * @param map
       */
      GeometryInstanceCollection.prototype.addToGlobe = function (map) {
          this._map = map;
          this._addPrimitive();
      };
      GeometryInstanceCollection.prototype.removeFromGlobe = function () {
          this._removePrimitive();
          this._map = undefined;
      };
      GeometryInstanceCollection.prototype._destroy = function () {
          this._map && this._removePrimitive();
          // 设置了primitive移除时自动销毁
          this._clearPrimitive();
          _super.prototype._destroy.call(this);
      };
      return GeometryInstanceCollection;
  }(BaseCollection));
  function assignInstance(store, keyLink, _a, visible) {
      var e_1, _b, e_2, _c, e_3, _d;
      var primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
      var keys = Object.keys(store);
      if (keys.length > 0) {
          if (store[keys[0]] instanceof Map) {
              try {
                  for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                      var key = keys_1_1.value;
                      try {
                          for (var _e = (e_2 = void 0, __values(store[key])), _f = _e.next(); !_f.done; _f = _e.next()) {
                              var _g = __read(_f.value, 2), mapKey = _g[0], value = _g[1];
                              if (value.length <= 0) {
                                  store[key].delete(mapKey);
                                  continue;
                              }
                              var collection_ = keyLink[0].indexOf("Ground") >= 0 ? groundPrimitiveCollection : primitiveCollection;
                              collection_.add(new Cesium__namespace[keyLink[0]]({
                                  show: visible,
                                  geometryInstances: value,
                                  appearance: new Cesium__namespace[key](__assign$1(__assign$1({}, (key.indexOf("Material") >= 0 || key.indexOf("Surface") >= 0
                                      ? {
                                          material: Cesium__namespace.Material.fromType(upperCaseFirstWord(value[0][STYLE_LINK].type), __assign$1({}, value[0][STYLE_LINK]))
                                      }
                                      : {})), value[0][STYLE_LINK]))
                              }));
                          }
                      }
                      catch (e_2_1) { e_2 = { error: e_2_1 }; }
                      finally {
                          try {
                              if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                          }
                          finally { if (e_2) throw e_2.error; }
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (keys_1_1 && !keys_1_1.done && (_b = keys_1.return)) _b.call(keys_1);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          else {
              try {
                  for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                      var key = keys_2_1.value;
                      var link = __spreadArray$1(__spreadArray$1([], __read(keyLink), false), [key], false);
                      assignInstance(store[key], link, { primitiveCollection: primitiveCollection, groundPrimitiveCollection: groundPrimitiveCollection }, visible);
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (keys_2_1 && !keys_2_1.done && (_d = keys_2.return)) _d.call(keys_2);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
          }
      }
  }
  function updatePrimitive() {
      this._removePrimitive();
      this._clearPrimitive();
      var _a = this._primitiveStore, primitiveCollection = _a.primitiveCollection, groundPrimitiveCollection = _a.groundPrimitiveCollection;
      assignInstance(this._instanceStore, [], { primitiveCollection: primitiveCollection, groundPrimitiveCollection: groundPrimitiveCollection }, this.show);
      this._addPrimitive();
  }

  var DEFAULT_COLOR$3 = new Cesium__namespace.Color(0, 0, 0, 0);
  var DEFAULT_REPEAT$1 = new Cesium__namespace.Cartesian2(1, 1);
  //---------------箭头材质流动材质--------------------
  var linearFlowType$1 = "ArrowFlow";
  //@ts-ignore
  Cesium__namespace.Material.ArrowFlowType = linearFlowType$1;
  var linearFlowMaterialSource$1 = "\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = (flowCount <= 0.0 ? repeat : vec2(1)) * materialInput.st;\n  if (reverseFlow) {\n    if (!horizontalDirection) {\n      st.t = st.t * -1.0;\n    } else {\n      st.s = st.s * -1.0;\n    }\n  }\n  float offset1 = offset;\n  if (flowCount <= 0.0) {\n    offset1 = speed * czm_frameNumber / 1000.0;\n  }\n  vec4 colorImage = horizontalDirection ? texture2D(arrowImage, vec2(reverseMaterial ? 1.0 - fract(st.s - offset1) : fract(st.s - offset1), st.t)) : texture2D(arrowImage, vec2(st.s, reverseMaterial ? 1.0 - fract(st.t - offset1) : fract(st.t - offset1)));\n  if (color.a == 0.0) {\n    if (colorImage.rgb == vec3(1.0)) {\n      discard;\n    }\n    material.alpha = colorImage.a;\n    material.diffuse = colorImage.rgb;\n  }\n  else {\n    material.alpha = colorImage.a * color.a;\n    material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb);\n  }\n\n  if (flowCount > 0.0 && fract(abs(1.0 + (horizontalDirection ? st.s : st.t))) > offset1) {\n    material.alpha = 0.0;\n  }\n  return material;\n}\n";
  //@ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(linearFlowType$1, {
      fabric: {
          type: linearFlowType$1,
          uniforms: {
              color: DEFAULT_COLOR$3,
              arrowImage: Cesium__namespace.Material.DefaultImageId,
              repeat: DEFAULT_REPEAT$1,
              speed: 10,
              horizontalDirection: true,
              reverseMaterial: false,
              reverseFlow: false,
              flowCount: -1,
              offset: 0
          },
          source: linearFlowMaterialSource$1
      },
      translucent: function () {
          return true;
      }
  });
  /**
   *  箭头流动材质
   */
  var ArrowFlowMaterialProperty = /** @class */ (function () {
      function ArrowFlowMaterialProperty(options) {
          // @ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._color = Cesium__namespace.defaultValue(options.color, DEFAULT_COLOR$3);
          this._image = options.arrowImage;
          this._horizontalDirection = Cesium__namespace.defaultValue(options.horizontalDirection, true);
          this._repeat = Cesium__namespace.defaultValue(options.repeat, DEFAULT_REPEAT$1);
          this._speed = Cesium__namespace.defaultValue(options.speed, 10);
          this._reverseMaterial = Cesium__namespace.defaultValue(options.reverseMaterial, false);
          this._reverseFlow = Cesium__namespace.defaultValue(options.reverseFlow, false);
          this._duration = Cesium__namespace.defaultValue(options.duration, 2);
          this._flowCount = Cesium__namespace.defaultValue(options.flowCount, -1);
      }
      Object.defineProperty(ArrowFlowMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ArrowFlowMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      ArrowFlowMaterialProperty.prototype.getType = function (time) {
          return linearFlowType$1;
      };
      ArrowFlowMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          if (!this._startTime && result.offset === 0) {
              this._startTime = performance.now();
          }
          result.arrowImage = this._image;
          result.color = this._color;
          var offset = (performance.now() - this._startTime) / (this._duration * 1000);
          if (this._flowCount > -1 && offset >= this._flowCount) {
              result.offset = 1;
          }
          else {
              // 取小数部分
              result.offset = Number((offset % 1).toFixed(3));
          }
          result.horizontalDirection = this._horizontalDirection;
          result.repeat = this._repeat;
          result.speed = this._speed;
          result.repeat = this._repeat;
          result.reverseMaterial = this._reverseMaterial;
          result.reverseFlow = this._reverseFlow;
          result.flowCount = this._flowCount;
          return result;
      };
      ArrowFlowMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof ArrowFlowMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color, other === null || other === void 0 ? void 0 : other._color) &&
                  // @ts-ignore
                  Cesium__namespace.Property.equals(this._repeat, other === null || other === void 0 ? void 0 : other._repeat) &&
                  this._image === (other === null || other === void 0 ? void 0 : other._image) &&
                  this._startTime === (other === null || other === void 0 ? void 0 : other._startTime) &&
                  this._horizontalDirection === (other === null || other === void 0 ? void 0 : other._horizontalDirection) &&
                  this._offset === (other === null || other === void 0 ? void 0 : other._offset) &&
                  this._horizontalDirection === (other === null || other === void 0 ? void 0 : other._horizontalDirection) &&
                  this._reverseMaterial === (other === null || other === void 0 ? void 0 : other._reverseMaterial) &&
                  this._reverseFlow === (other === null || other === void 0 ? void 0 : other._reverseFlow) &&
                  this._duration === (other === null || other === void 0 ? void 0 : other._duration) &&
                  this._speed === (other === null || other === void 0 ? void 0 : other._speed) &&
                  this._flowCount === (other === null || other === void 0 ? void 0 : other._flowCount)));
      };
      return ArrowFlowMaterialProperty;
  }());

  var DEFAULT_COLOR$2 = new Cesium__namespace.Color(0, 0, 0, 0);
  var DEFAULT_COLOR2$1 = new Cesium__namespace.Color(1, 1, 1, 1);
  var DEFAULT_REPEAT = new Cesium__namespace.Cartesian2(1, 1);
  //---------------线性流动材质--------------------
  var linearFlowType = "LinearFlow";
  //@ts-ignore
  Cesium__namespace.Material.LinearFlowType = linearFlowType;
  var linearFlowMaterialSource = "\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = (flowCount <= 0.0 ? repeat : vec2(1)) * materialInput.st;\n  if (reverseFlow) {\n    if (!horizontalDirection) {\n      st.t = st.t * -1.0;\n    } else {\n      st.s = st.s * -1.0;\n    }\n  }\n  float offset1 = offset;\n  if (flowCount <= 0.0) {\n    offset1 = speed * czm_frameNumber / 1000.0;\n  }\n  vec4 colorImage = horizontalDirection ? texture2D(image, vec2(reverseMaterial ? 1.0 - fract(st.s - offset1) : fract(st.s - offset1), st.t)) : texture2D(image, vec2(st.s, reverseMaterial ? 1.0 - fract(st.t - offset1) : fract(st.t - offset1)));\n  if (color.a == 0.0) {\n    if (colorImage.rgb == vec3(1.0)) {\n      discard;\n    }\n    material.alpha = colorImage.a;\n    material.diffuse = colorImage.rgb;\n  }\n  else {\n    material.alpha = colorImage.a * color.a;\n    material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb);\n  }\n  if (hasImage2) {\n    vec4 colorBG = texture2D(image2, materialInput.st);\n    if (colorBG.a > 0.5) {\n      material.diffuse = color2.rgb;\n    }\n  }\n  if (flowCount > 0.0 && fract(abs(1.0 + (horizontalDirection ? st.s : st.t))) > offset1) {\n    material.alpha = 0.0;\n  }\n  return material;\n}\n";
  //@ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(linearFlowType, {
      fabric: {
          type: linearFlowType,
          uniforms: {
              color: DEFAULT_COLOR$2,
              color2: DEFAULT_COLOR2$1,
              hasImage2: false,
              image: Cesium__namespace.Material.DefaultImageId,
              image2: Cesium__namespace.Material.DefaultImageId,
              repeat: DEFAULT_REPEAT,
              speed: 10,
              horizontalDirection: true,
              reverseMaterial: false,
              reverseFlow: false,
              flowCount: -1,
              offset: 0
          },
          source: linearFlowMaterialSource
      },
      translucent: function () {
          return true;
      }
  });
  /**
   * 直线流动材质
   */
  var LinearFlowMaterialProperty = /** @class */ (function () {
      function LinearFlowMaterialProperty(options) {
          // @ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._color = Cesium__namespace.defaultValue(options.color, DEFAULT_COLOR$2);
          this._image = options.image;
          this._horizontalDirection = Cesium__namespace.defaultValue(options.horizontalDirection, true);
          this._repeat = Cesium__namespace.defaultValue(options.repeat, DEFAULT_REPEAT);
          this._speed = Cesium__namespace.defaultValue(options.speed, 10);
          this._reverseMaterial = Cesium__namespace.defaultValue(options.reverseMaterial, false);
          this._reverseFlow = Cesium__namespace.defaultValue(options.reverseFlow, false);
          this._duration = Cesium__namespace.defaultValue(options.duration, 2);
          this._flowCount = Cesium__namespace.defaultValue(options.flowCount, -1);
      }
      Object.defineProperty(LinearFlowMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(LinearFlowMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      LinearFlowMaterialProperty.prototype.getType = function (time) {
          return linearFlowType;
      };
      LinearFlowMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          if (!this._startTime && result.offset === 0) {
              this._startTime = performance.now();
          }
          result.image = this._image;
          result.color = this._color;
          // result.color2 = this._color2;
          // result.image2 = this._image2;
          var offset = (performance.now() - this._startTime) / (this._duration * 1000);
          if (this._flowCount > -1 && offset >= this._flowCount) {
              result.offset = 1;
          }
          else {
              // 取小数部分
              result.offset = Number((offset % 1).toFixed(3));
          }
          result.horizontalDirection = this._horizontalDirection;
          result.repeat = this._repeat;
          result.speed = this._speed;
          // result.hasImage2 = this._hasImage2;
          result.repeat = this._repeat;
          result.reverseMaterial = this._reverseMaterial;
          result.reverseFlow = this._reverseFlow;
          result.flowCount = this._flowCount;
          return result;
      };
      LinearFlowMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof LinearFlowMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color, other === null || other === void 0 ? void 0 : other._color) &&
                  // @ts-ignore
                  // Cesium.Property.equals(this._color2, other?._color2) &&
                  // @ts-ignore
                  Cesium__namespace.Property.equals(this._repeat, other === null || other === void 0 ? void 0 : other._repeat) &&
                  this._image === (other === null || other === void 0 ? void 0 : other._image) &&
                  // this._image2 === other?._image2 &&
                  // this._hasImage2 === other?._hasImage2 &&
                  this._startTime === (other === null || other === void 0 ? void 0 : other._startTime) &&
                  this._horizontalDirection === (other === null || other === void 0 ? void 0 : other._horizontalDirection) &&
                  this._offset === (other === null || other === void 0 ? void 0 : other._offset) &&
                  this._horizontalDirection === (other === null || other === void 0 ? void 0 : other._horizontalDirection) &&
                  this._reverseMaterial === (other === null || other === void 0 ? void 0 : other._reverseMaterial) &&
                  this._reverseFlow === (other === null || other === void 0 ? void 0 : other._reverseFlow) &&
                  this._duration === (other === null || other === void 0 ? void 0 : other._duration) &&
                  this._speed === (other === null || other === void 0 ? void 0 : other._speed) &&
                  this._flowCount === (other === null || other === void 0 ? void 0 : other._flowCount)));
      };
      return LinearFlowMaterialProperty;
  }());

  var materialType$3 = "LinearGradient";
  //@ts-ignore
  Cesium__namespace.Material.LinearGradientType = materialType$3;
  var defaultColor = Cesium__namespace.Color.RED;
  var materialSource$3 = "\nfloat easing(float x) {\n  return x >= 1.0 ? 1.0 : 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\nvec4 createLinearColor(float s) {\n  if(reverse){\n    s=1.0-s;\n  }\n  const int arrayCount =3;    \n  float steps[arrayCount];\n  steps[0] = 0.0;\n  steps[1] = middleStepRate;\n  steps[2] = 1.0;\n  vec4 colors[arrayCount];\n  colors[0] = openingStartColor;\n  colors[1] = middleStepColor;\n  colors[2] = endStepColor;\n  vec4 color;\n  for (int index = 0; index < arrayCount; index++) {\n    if (index == 0) {\n      color = mix(colors[0], colors[1], smoothstep(steps[0], steps[1], s));\n    } else if (index > 1) {\n      color = mix(color, colors[index], smoothstep(steps[index - 1], steps[index], s));\n    }\n  }\n  return color;\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec4 color = createLinearColor(horizontalDirection?materialInput.st.s:materialInput.st.t);\n  material.diffuse = vec3(color);\n  material.alpha = easing(color.a * alpha);\n  return material;\n}\n";
  // @ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(materialType$3, {
      fabric: {
          type: materialType$3,
          uniforms: {
              alpha: 1,
              reverse: false,
              horizontalDirection: false,
              openingStartColor: defaultColor.withAlpha(0),
              middleStepColor: defaultColor.withAlpha(0.5),
              endStepColor: defaultColor,
              middleStepRate: 0.5
          },
          source: materialSource$3
      },
      translucent: function () {
          return true;
      }
  });
  /**
   * 线性渐变可闪烁材质
   */
  var LinearGradientMaterialProperty = /** @class */ (function () {
      function LinearGradientMaterialProperty(options) {
          if (options === void 0) { options = {}; }
          //@ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._duration = Cesium__namespace.defaultValue(options.duration, 0);
          this._reverse = Cesium__namespace.defaultValue(options.reverse, false);
          this._horizontalDirection = Cesium__namespace.defaultValue(options.horizontalDirection, true);
          this._openingStartColor = Cesium__namespace.defaultValue(options.openingStartColor, defaultColor.withAlpha(0));
          this._middleStepColor = Cesium__namespace.defaultValue(options.middleStepColor, defaultColor.withAlpha(0.5));
          this._endStepColor = Cesium__namespace.defaultValue(options.endStepColor, defaultColor.withAlpha(1));
          this._middleStepRate = Cesium__namespace.defaultValue(options.middleStepRate, 0.5);
          this._offset = 1;
      }
      Object.defineProperty(LinearGradientMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(LinearGradientMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      LinearGradientMaterialProperty.prototype.getType = function (time) {
          return materialType$3;
      };
      LinearGradientMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          if (!this._startTime && result.alpha === 1) {
              this._startTime = new Date().getTime();
          }
          result.openingStartColor = this._openingStartColor;
          result.middleStepColor = this._middleStepColor;
          result.endStepColor = this._endStepColor;
          result.middleStepRate = this._middleStepRate;
          result.horizontalDirection = this._horizontalDirection;
          result.duration = this._duration;
          result.reverse = this._reverse;
          if (this._duration !== 0) {
              result.alpha = Math.abs(Math.sin(Number((((new Date().getTime() - this._startTime) / (this._duration * 1000)) % 1).toFixed(3)) * Math.PI));
          }
          else {
              result.alpha = this._offset;
          }
          return result;
      };
      LinearGradientMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof LinearGradientMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._openingStartColor, other === null || other === void 0 ? void 0 : other._openingStartColor) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._middleStepColor, other === null || other === void 0 ? void 0 : other._middleStepColor) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._endStepColor, other === null || other === void 0 ? void 0 : other._endStepColor) &&
                  this._middleStepRate === (other === null || other === void 0 ? void 0 : other._middleStepRate) &&
                  this._horizontalDirection === (other === null || other === void 0 ? void 0 : other._horizontalDirection) &&
                  this._reverse === (other === null || other === void 0 ? void 0 : other._reverse) &&
                  // @ts-ignore
                  this._duration === (other === null || other === void 0 ? void 0 : other._duration)));
      };
      return LinearGradientMaterialProperty;
  }());

  var DEFAULT_COLOR1 = Cesium__namespace.Color.fromCssColorString("rgba(255,0,0,0)");
  var DEFAULT_COLOR2 = Cesium__namespace.Color.fromCssColorString("rgba(255,0,0,0.5)");
  var DEFAULT_COLOR3 = Cesium__namespace.Color.fromCssColorString("rgba(255,0,0,1)");
  var materialType$2 = "RadialGradient";
  //@ts-ignore
  Cesium__namespace.Material.RadialGradientType = materialType$2;
  var materialSource$2 = "\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  float dis = smoothstep(0.0, 1.0, distance(materialInput.st, vec2(0.5, 0.5)) * 2.0);\n  float alpha;\n  vec3 color;\n  if (dis <= stop2) {\n    float percent = (dis - stop1) / (stop2 - stop1);\n    color = vec3(color1 + ((color2 - color1) * percent));\n    alpha = color1.a + (color2.a - color1.a) * percent;\n  } else if (dis > stop2) {\n    float percent = (dis - stop2) / (stop3 - stop2);\n    color = vec3(color2 + ((color3 - color2) * percent));\n    alpha = color2.a + (color3.a - color2.a) * percent;\n  }\n  material.diffuse = color;\n  material.alpha = alpha;\n  return material;\n}\n";
  // @ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(materialType$2, {
      fabric: {
          type: materialType$2,
          uniforms: {
              color1: DEFAULT_COLOR1,
              color2: DEFAULT_COLOR2,
              color3: DEFAULT_COLOR3,
              stop1: 0,
              stop2: 0.5,
              stop3: 1.0
          },
          source: materialSource$2
      },
      translucent: function () {
          return true;
      }
  });
  /**
   * 径向渐变材质
   */
  var RadialGradientMaterialProperty = /** @class */ (function () {
      function RadialGradientMaterialProperty(options) {
          if (options === void 0) { options = {}; }
          //@ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._color1 = Cesium__namespace.defaultValue(options.color1, DEFAULT_COLOR1);
          this._color2 = Cesium__namespace.defaultValue(options.color2, DEFAULT_COLOR2);
          this._color3 = Cesium__namespace.defaultValue(options.color3, DEFAULT_COLOR3);
          this._stop1 = Cesium__namespace.defaultValue(options.stop1, 0);
          this._stop2 = Cesium__namespace.defaultValue(options.stop2, 0.5);
          this._stop3 = Cesium__namespace.defaultValue(options.stop3, 1);
      }
      Object.defineProperty(RadialGradientMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(RadialGradientMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      RadialGradientMaterialProperty.prototype.getType = function (time) {
          return materialType$2;
      };
      RadialGradientMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          result.color1 = this._color1;
          result.color2 = this._color2;
          result.color3 = this._color3;
          result.stop1 = this._stop1;
          result.stop2 = this._stop2;
          result.stop3 = this._stop3;
          return result;
      };
      RadialGradientMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof RadialGradientMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color1, other === null || other === void 0 ? void 0 : other._color1) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color2, other === null || other === void 0 ? void 0 : other._color2) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color3, other === null || other === void 0 ? void 0 : other._color3) &&
                  // @ts-ignore
                  this._stop1 === (other === null || other === void 0 ? void 0 : other._stop1) &&
                  // @ts-ignore
                  this._stop2 === (other === null || other === void 0 ? void 0 : other._stop2) &&
                  // @ts-ignore
                  this._stop3 === (other === null || other === void 0 ? void 0 : other._stop3)));
      };
      return RadialGradientMaterialProperty;
  }());

  var DEFAULT_COLOR$1 = new Cesium__namespace.Color(1, 0, 0);
  var DEFAULT_CARTESIAN2$1 = new Cesium__namespace.Cartesian2(1, 1);
  var materialType$1 = "Ripple";
  //@ts-ignore
  Cesium__namespace.Material.RippleType = materialType$1;
  var materialSource$1 = "\nfloat easeOutQuad(float x) {\n  return 1.0 - (1.0 - x) * (1.0 - x);\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float num = 360.0;\n  float rate = rateEntity != -1.0 ? easeOutQuad(rateEntity) / 2.0 : easeOutQuad(mod(czm_frameNumber * speed / 10.0, num) / num) / 2.0;\n  st = st - 0.5;\n  st = st * 0.5 / rate;\n  st = st + 0.5;\n  material.diffuse = czm_gammaCorrect(texture2D(image, fract(repeat * st)).rgb * color.rgb);\n  if (distance(vec2(0.5, 0.5), materialInput.st) <= rate) {\n    material.alpha = texture2D(image, fract(repeat * st)).a * color.a * easeOutQuad(1.0 - 2.0 * rate);\n  } else {\n    material.alpha = 0.0;\n  }\n  return material;\n}\n";
  // @ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(materialType$1, {
      fabric: {
          type: materialType$1,
          uniforms: {
              color: DEFAULT_COLOR$1,
              repeat: DEFAULT_CARTESIAN2$1,
              image: DEFAULT_STYLE_ITEM[StyleItemType.RIPPLE].image,
              speed: 10,
              rateEntity: -1
          },
          source: materialSource$1
      },
      translucent: function () {
          return true;
      }
  });
  var RippleMaterialProperty = /** @class */ (function () {
      function RippleMaterialProperty(options) {
          if (options === void 0) { options = {}; }
          //@ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._color = Cesium__namespace.defaultValue(options.color, DEFAULT_COLOR$1);
          this._repeat = Cesium__namespace.defaultValue(options.repeat, DEFAULT_CARTESIAN2$1);
          this._image = Cesium__namespace.defaultValue(options.image, DEFAULT_STYLE_ITEM[StyleItemType.RIPPLE].image);
          this._speed = Cesium__namespace.defaultValue(options.speed, 10);
          this._duration = Cesium__namespace.defaultValue(options.duration, 3);
      }
      Object.defineProperty(RippleMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(RippleMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      RippleMaterialProperty.prototype.getType = function (time) {
          return materialType$1;
      };
      RippleMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          this._time || (this._time = performance.now());
          result.color = this._color;
          result.repeat = this._repeat;
          result.image = this._image;
          result.speed = this._speed;
          result.rateEntity = ((performance.now() - this._time) % (this._duration * 1000)) / (this._duration * 1000);
          return result;
      };
      RippleMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof RippleMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color, other === null || other === void 0 ? void 0 : other._color) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._repeat, other === null || other === void 0 ? void 0 : other._repeat) &&
                  this._image === (other === null || other === void 0 ? void 0 : other._image) &&
                  this._duration === (other === null || other === void 0 ? void 0 : other._duration) &&
                  this._speed === (other === null || other === void 0 ? void 0 : other._speed)));
      };
      return RippleMaterialProperty;
  }());

  var DEFAULT_COLOR = new Cesium__namespace.Color();
  var DEFAULT_CARTESIAN2 = new Cesium__namespace.Cartesian2(1, 1);
  var materialType = "Rotate";
  //@ts-ignore
  Cesium__namespace.Material.RotateType = materialType;
  var materialSource = "\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle),\n    sin(_angle), cos(_angle));\n}\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n  czm_material material = czm_getDefaultMaterial(materialInput);\n  vec2 st = materialInput.st;\n  float rotate = (rotateRa != -10.0 ? -rotateRa : -mod(czm_frameNumber * speed / 10.0, 360.0) * czm_radiansPerDegree) * (reverse ? - 1.0 : 1.0);\n\n  st = st + vec2(-0.5, -0.5);\n  st = rotate2d(rotate) * st;\n  st = st + vec2(0.5, 0.5);\n  material.diffuse = czm_gammaCorrect(texture2D(image, fract(repeat * st)).rgb * color.rgb);\n  material.alpha = texture2D(image, fract(repeat * st)).a * color.a;\n  return material;\n}\n";
  // @ts-ignore
  Cesium__namespace.Material._materialCache.addMaterial(materialType, {
      fabric: {
          type: materialType,
          uniforms: {
              color: DEFAULT_COLOR,
              repeat: DEFAULT_CARTESIAN2,
              image: "czm_defaultImage",
              speed: 10,
              reverse: false,
              rotateRa: -10
          },
          source: materialSource
      },
      translucent: function () {
          return true;
      }
  });
  var RotateMaterialProperty = /** @class */ (function () {
      function RotateMaterialProperty(options) {
          if (options === void 0) { options = {}; }
          //@ts-ignore
          options = transformParams(options);
          this._definitionChanged = new Cesium__namespace.Event();
          this._color = Cesium__namespace.defaultValue(options.color, DEFAULT_COLOR);
          this._repeat = Cesium__namespace.defaultValue(options.repeat, DEFAULT_CARTESIAN2);
          this._image = Cesium__namespace.defaultValue(options.image, "czm_defaultImage");
          this._speed = Cesium__namespace.defaultValue(options.speed, 10);
          this._reverse = Cesium__namespace.defaultValue(options.reverse, false);
          this._duration = Cesium__namespace.defaultValue(options.duration, 3);
      }
      Object.defineProperty(RotateMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(RotateMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      RotateMaterialProperty.prototype.getType = function (time) {
          return materialType;
      };
      RotateMaterialProperty.prototype.getValue = function (time, result) {
          result || (result = {});
          this._time || (this._time = performance.now());
          result.color = this._color;
          result.repeat = this._repeat;
          result.image = this._image;
          result.speed = this._speed;
          result.reverse = this._reverse;
          result.rotateRa =
              (((360 * ((performance.now() - this._time) % (this._duration * 1000))) / (this._duration * 1000)) * Math.PI) /
                  180;
          return result;
      };
      RotateMaterialProperty.prototype.equals = function (other) {
          return (this === other ||
              (other instanceof RotateMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._color, other === null || other === void 0 ? void 0 : other._color) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._repeat, other === null || other === void 0 ? void 0 : other._repeat) &&
                  this._image === (other === null || other === void 0 ? void 0 : other._image) &&
                  this._reverse === (other === null || other === void 0 ? void 0 : other._reverse) &&
                  this._duration === (other === null || other === void 0 ? void 0 : other._duration) &&
                  this._speed === (other === null || other === void 0 ? void 0 : other._speed)));
      };
      return RotateMaterialProperty;
  }());

  /**
   * 水面材质属性
   */
  var WaterMaterialProperty = /** @class */ (function () {
      function WaterMaterialProperty(options) {
          if (options === void 0) { options = {}; }
          // @ts-ignore
          this._options = transformParams(__assign$1(__assign$1({}, DEFAULT_STYLE_ITEM[StyleItemType.WATER]), options));
          this._definitionChanged = new Cesium__namespace.Event();
      }
      Object.defineProperty(WaterMaterialProperty.prototype, "isConstant", {
          get: function () {
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(WaterMaterialProperty.prototype, "definitionChanged", {
          get: function () {
              return this._definitionChanged;
          },
          enumerable: false,
          configurable: true
      });
      WaterMaterialProperty.prototype.getType = function (time) {
          return "Water";
      };
      WaterMaterialProperty.prototype.getValue = function (time, result) {
          var _a = this._options, baseWaterColor = _a.baseWaterColor, blendColor = _a.blendColor, specularMap = _a.specularMap, normalMap = _a.normalMap, frequency = _a.frequency, animationSpeed = _a.animationSpeed, amplitude = _a.amplitude, specularIntensity = _a.specularIntensity;
          result.baseWaterColor = baseWaterColor;
          result.blendColor = blendColor || new Cesium__namespace.Color(0, 1, 0.699, 1);
          result.specularMap = specularMap || "czm_defaultImage";
          result.normalMap = normalMap;
          result.frequency = frequency;
          result.animationSpeed = animationSpeed;
          result.amplitude = amplitude;
          result.specularIntensity = specularIntensity || 0.5;
          return result;
      };
      WaterMaterialProperty.prototype.equals = function (other) {
          var _a, _b, _c, _d, _e, _f;
          return (this === other ||
              (other instanceof WaterMaterialProperty &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._options.baseWaterColor, other === null || other === void 0 ? void 0 : other._options.baseWaterColor) &&
                  //@ts-ignore
                  Cesium__namespace.Property.equals(this._options.blendColor, other === null || other === void 0 ? void 0 : other._options.blendColor) &&
                  //@ts-ignore
                  this._options.specularMap === ((_a = other === null || other === void 0 ? void 0 : other._options) === null || _a === void 0 ? void 0 : _a.specularMap) &&
                  this._options.normalMap === ((_b = other === null || other === void 0 ? void 0 : other._options) === null || _b === void 0 ? void 0 : _b.normalMap) &&
                  this._options.frequency === ((_c = other === null || other === void 0 ? void 0 : other._options) === null || _c === void 0 ? void 0 : _c.frequency) &&
                  this._options.animationSpeed === ((_d = other === null || other === void 0 ? void 0 : other._options) === null || _d === void 0 ? void 0 : _d.animationSpeed) &&
                  this._options.amplitude === ((_e = other === null || other === void 0 ? void 0 : other._options) === null || _e === void 0 ? void 0 : _e.amplitude) &&
                  this._options.specularIntensity === ((_f = other === null || other === void 0 ? void 0 : other._options) === null || _f === void 0 ? void 0 : _f.specularIntensity)));
      };
      return WaterMaterialProperty;
  }());

  function transformParams(style) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      // @ts-ignore
      if (style[INITIALIZED] === true) {
          return style;
      }
      Object.keys(style).forEach(function (key) {
          var _a;
          if (key.match(/color/gi) &&
              !(style[key] instanceof Cesium__namespace.Color) &&
              !style[key].getValue &&
              !key.match(/colors/gi)) {
              if (Array.isArray(style[key])) {
                  style[key] = new ((_a = Cesium__namespace.Color).bind.apply(_a, __spreadArray$1([void 0], __read(style[key]), false)))();
              }
              else {
                  style[key] = Cesium__namespace.Color.fromCssColorString(style[key]);
              }
          }
      });
      if (style.hasOwnProperty("distanceDisplayCondition") &&
          !(style.distanceDisplayCondition instanceof Cesium__namespace.DistanceDisplayCondition) &&
          !style.distanceDisplayCondition.getValue) {
          style.distanceDisplayCondition = new ((_a = Cesium__namespace.DistanceDisplayCondition).bind.apply(_a, __spreadArray$1([void 0], __read(style.distanceDisplayCondition), false)))();
      }
      if (style.hasOwnProperty("scaleByDistance") &&
          !(style.scaleByDistance instanceof Cesium__namespace.NearFarScalar) &&
          !style.scaleByDistance.getValue) {
          style.scaleByDistance = new ((_b = Cesium__namespace.NearFarScalar).bind.apply(_b, __spreadArray$1([void 0], __read(style.scaleByDistance), false)))();
      }
      if (style.hasOwnProperty("translucencyByDistance") &&
          !(style.translucencyByDistance instanceof Cesium__namespace.NearFarScalar) &&
          !style.translucencyByDistance.getValue) {
          style.translucencyByDistance = new ((_c = Cesium__namespace.NearFarScalar).bind.apply(_c, __spreadArray$1([void 0], __read(style.translucencyByDistance), false)))();
      }
      if (style.hasOwnProperty("backgroundPadding") &&
          !(style.backgroundPadding instanceof Cesium__namespace.Cartesian2) &&
          !style.backgroundPadding.getValue) {
          style.backgroundPadding = new ((_d = Cesium__namespace.Cartesian2).bind.apply(_d, __spreadArray$1([void 0], __read(style.backgroundPadding), false)))();
      }
      if (style.hasOwnProperty("eyeOffset") &&
          !(style.eyeOffset instanceof Cesium__namespace.Cartesian3) &&
          !style.eyeOffset.getValue) {
          style.eyeOffset = new ((_e = Cesium__namespace.Cartesian3).bind.apply(_e, __spreadArray$1([void 0], __read(style.eyeOffset), false)))();
      }
      if (style.hasOwnProperty("offset")) {
          style.pixelOffset = style.offset;
      }
      if (style.hasOwnProperty("pixelOffset") &&
          !(style.pixelOffset instanceof Cesium__namespace.Cartesian2) &&
          !style.pixelOffset.getValue) {
          style.pixelOffset = new ((_f = Cesium__namespace.Cartesian2).bind.apply(_f, __spreadArray$1([void 0], __read(style.pixelOffset), false)))();
      }
      if (style.hasOwnProperty("repeat") && !(style.repeat instanceof Cesium__namespace.Cartesian2) && !style.repeat.getValue) {
          style.repeat = new ((_g = Cesium__namespace.Cartesian2).bind.apply(_g, __spreadArray$1([void 0], __read(style.repeat), false)))();
      }
      if (style.hasOwnProperty("pixelOffsetScaleByDistance") &&
          !(style.pixelOffsetScaleByDistance instanceof Cesium__namespace.NearFarScalar) &&
          !style.pixelOffsetScaleByDistance.getValue) {
          style.pixelOffsetScaleByDistance = new ((_h = Cesium__namespace.NearFarScalar).bind.apply(_h, __spreadArray$1([void 0], __read(style.pixelOffsetScaleByDistance), false)))();
      }
      if (style.hasOwnProperty("translucencyByDistance") &&
          !(style.translucencyByDistance instanceof Cesium__namespace.NearFarScalar) &&
          !style.translucencyByDistance.getValue) {
          style.translucencyByDistance = new ((_j = Cesium__namespace.NearFarScalar).bind.apply(_j, __spreadArray$1([void 0], __read(style.translucencyByDistance), false)))();
      }
      if (style.hasOwnProperty("material") && typeof style.material === "string") {
          style.material = Cesium__namespace.Color.fromCssColorString(style.material);
      }
      if (style.hasOwnProperty("depthFailMaterial") && typeof style.depthFailMaterial === "string") {
          style.depthFailMaterial = Cesium__namespace.Color.fromCssColorString(style.depthFailMaterial);
      }
      if (style.hasOwnProperty("rotation") && typeof style.rotation === "number") {
          style.rotation = -Cesium__namespace.Math.toRadians(style.rotation);
      }
      if (style.hasOwnProperty("stRotation") && typeof style.stRotation === "number") {
          style.stRotation = Cesium__namespace.Math.toRadians(style.stRotation);
      }
      if (style.hasOwnProperty("positioning")) {
          var _k = positioningToHOAndVO(style.positioning), verticalOrigin = _k.verticalOrigin, horizontalOrigin = _k.horizontalOrigin;
          style.verticalOrigin = verticalOrigin;
          style.horizontalOrigin = horizontalOrigin;
      }
      if (style.hasOwnProperty("opacity")) {
          if (defined$1(style.color)) {
              style.color.alpha = style.opacity;
          }
          else {
              style.color = new Cesium__namespace.Color(1, 1, 1, style.opacity);
          }
      }
      if (defined$1(style.gradientStep)) {
          style.gradientStep.forEach(function (item, index) {
              style["color" + (index + 1)] = Cesium__namespace.Color.fromCssColorString(item[1]);
              style["stop" + (index + 1)] = item[0];
          });
      }
      if (defined$1(style.zIndex) && !defined$1(style.eyeOffset)) {
          style.eyeOffset = new Cesium__namespace.Cartesian3(0, 0, -style.zIndex);
      }
      if (defined$1(style.heightReference) && !defined$1(style.clampToGround)) {
          style.clampToGround = style.heightReference === HeightReference.CLAMP_TO_GROUND;
      }
      return __assign$1({}, style);
  }
  function styleItemToImageMaterialProperty(styleItem) {
      return new Cesium__namespace.ImageMaterialProperty({
          image: styleItem.image,
          repeat: styleItem.repeat,
          color: styleItem.color,
          transparent: styleItem.transparent
      });
  }
  function styleItemBorderColorToColorMaterialProperty(styleItem) {
      return styleItem.lineDash
          ? new Cesium__namespace.PolylineDashMaterialProperty({
              color: styleItem.borderColor,
              dashLength: styleItem.lineDash[0] * 2
          })
          : new Cesium__namespace.ColorMaterialProperty(styleItem.borderColor);
  }
  function styleItemFillColorToColorMaterialProperty(styleItem) {
      return new Cesium__namespace.ColorMaterialProperty(styleItem.fillColor);
  }
  function styleItemToPolyLineArrowMaterialProperty(styleItem) {
      return new Cesium__namespace.PolylineArrowMaterialProperty(styleItem.color);
  }
  function positioningToHOAndVO(positioning) {
      var p = positioning.split("-");
      var res = { verticalOrigin: undefined, horizontalOrigin: undefined };
      switch (p[0]) {
          case "top":
              res.verticalOrigin = -1 /* TOP */;
              break;
          case "center":
              res.verticalOrigin = 0 /* CENTER */;
              break;
          case "bottom":
              res.verticalOrigin = 2 /* BASELINE */;
              break;
      }
      switch (p[1]) {
          case "left":
              res.horizontalOrigin = 1 /* LEFT */;
              break;
          case "center":
              res.horizontalOrigin = 0 /* CENTER */;
              break;
          case "right":
              res.horizontalOrigin = -1 /* RIGHT */;
              break;
      }
      return res;
  }
  function styleItemToLinearGradientMaterialProperty(styleItem) {
      var op = styleItem;
      op.openingStartColor = op.stop[0][1];
      op.middleStepColor = op.stop[1][1];
      op.endStepColor = op.stop[2][1];
      Object.keys(op).forEach(function (key) {
          var _a;
          if (key.match(/color/gi) && !(op[key] instanceof Cesium__namespace.Color) && !op[key].getValue) {
              if (Array.isArray(op[key])) {
                  op[key] = new ((_a = Cesium__namespace.Color).bind.apply(_a, __spreadArray$1([void 0], __read(op[key]), false)))();
              }
              else {
                  op[key] = Cesium__namespace.Color.fromCssColorString(op[key]);
              }
          }
      });
      op.middleStepRate = op.stop[1][0];
      return new LinearGradientMaterialProperty(op);
  }
  function styleItemToLinearFlowMaterialProperty(styleItem) {
      return new LinearFlowMaterialProperty(styleItem);
  }
  function styleItemToArrowFlowMaterialProperty(styleItem) {
      return new ArrowFlowMaterialProperty(styleItem);
  }
  function styleItemToWaterMaterialProperty(styleItem) {
      return new WaterMaterialProperty(styleItem);
  }
  function styleItemToRadialGradientMaterialProperty(styleItem) {
      return new RadialGradientMaterialProperty(styleItem);
  }
  function buildRippleMaterialProperty(styleItem) {
      return new RippleMaterialProperty(styleItem);
  }
  function buildRotateMaterialProperty(styleItem) {
      return new RotateMaterialProperty(styleItem);
  }
  function styleItemToMaterialProperty(styleItem, _a) {
      var _b = _a === void 0 ? {} : _a, isLine = _b.isLine;
      var material;
      switch (styleItem.type) {
          case StyleItemType.COLOR:
              material =
                  isLine === true
                      ? styleItemBorderColorToColorMaterialProperty(styleItem)
                      : styleItemFillColorToColorMaterialProperty(styleItem);
              break;
          case StyleItemType.IMAGE:
              material = styleItemToImageMaterialProperty(styleItem);
              break;
          case StyleItemType.WATER:
              material = styleItemToWaterMaterialProperty(styleItem);
              break;
          case StyleItemType.RIPPLE:
              material = buildRippleMaterialProperty(styleItem);
              break;
          case StyleItemType.ROTATE:
              material = buildRotateMaterialProperty(styleItem);
              break;
          case StyleItemType.LINEAR_FOW:
              material = styleItemToLinearFlowMaterialProperty(styleItem);
              break;
          case StyleItemType.ARROW_FOW:
              material = styleItemToArrowFlowMaterialProperty(styleItem);
              break;
          case StyleItemType.RADIAL_GRADIENT:
              material = styleItemToRadialGradientMaterialProperty(styleItem);
              break;
          case StyleItemType.POLYLINE_ARROW:
              material = styleItemToPolyLineArrowMaterialProperty(styleItem);
              break;
      }
      return material;
  }

  /**
   * 暂时没考虑使用已经缓存图片到canvas
   * @param style
   * @returns
   */
  function cesiumStyleItemListInit(style) {
      var _a;
      if (style[INITIALIZED]) {
          return style;
      }
      for (var index = 0, len = style.length; index < len; index++) {
          var item = style[index];
          // @ts-ignore
          if (!item[INITIALIZED]) {
              style[index] = transformParams(__assign$1(__assign$1(__assign$1({}, DEFAULT_STYLE_ITEM[item.type]), item), (_a = {}, _a[STYLE_UID] = getUid(), _a)));
              // @ts-ignore
              style[index][INITIALIZED] = true;
          }
      }
      style[INITIALIZED] = true;
      return style;
  }

  var PICK_EVENT_TYPE = [BaseEventType.CLICK, BaseEventType.DOUBLE_CLICK, BaseEventType.RIGHT_CLICK];
  function toPickEventType(type) {
      if (PICK_EVENT_TYPE.includes(type)) {
          switch (type) {
              case BaseEventType.CLICK:
                  return BaseEventType.PICK;
              case BaseEventType.DOUBLE_CLICK:
                  return BaseEventType.DOUBLE_PICK;
              case BaseEventType.RIGHT_CLICK:
                  return BaseEventType.RIGHT_PICK;
          }
      }
      return;
  }
  function pickEventTypeToClickType(type) {
      switch (type) {
          case BaseEventType.PICK:
              return BaseEventType.CLICK;
          case BaseEventType.DOUBLE_PICK:
              return BaseEventType.DOUBLE_CLICK;
          case BaseEventType.RIGHT_PICK:
              return BaseEventType.RIGHT_CLICK;
          default:
              return type;
      }
  }
  function toStyleItemList(style, callback) {
      if (Array.isArray(style)) {
          if (style.length === 0 || defined$1(style[0].type)) {
              return defined$1(callback) ? callback(style) : style;
          }
          else {
              return void 0;
          }
      }
      else {
          return void 0;
      }
  }
  function toStyleFunction(style, callback) {
      if (Array.isArray(style)) {
          if (style.length === 0 || defined$1(style[0].type)) {
              return function () {
                  return defined$1(callback) ? callback(style) : style;
              };
          }
          else {
              return function (feature) {
                  var _a;
                  var styleItemList = ((_a = style.find(function (item) {
                      if (!defined$1(item.condition)) {
                          return true;
                      }
                      else {
                          return item.condition(feature);
                      }
                  })) === null || _a === void 0 ? void 0 : _a.style) || NULL_STYLE_ITEM_LIST;
                  return defined$1(callback) ? callback(styleItemList) : styleItemList;
              };
          }
      }
      else {
          return style;
      }
  }

  // 样式渲染器
  var StyleRenderStatusEnum;
  (function (StyleRenderStatusEnum) {
      StyleRenderStatusEnum[StyleRenderStatusEnum["NULL"] = 0] = "NULL";
      StyleRenderStatusEnum[StyleRenderStatusEnum["FEATURE_STYLE"] = 1] = "FEATURE_STYLE";
      StyleRenderStatusEnum[StyleRenderStatusEnum["LAYER_STYLE"] = 2] = "LAYER_STYLE";
  })(StyleRenderStatusEnum || (StyleRenderStatusEnum = {}));
  /**
   * 要素基础类
   *
   * 此为基类,不可实例化
   */
  var Feature = /** @class */ (function (_super) {
      __extends$3(Feature, _super);
      /**
       * @param options
       * @param layer
       */
      function Feature(options, layer) {
          var _this = _super.call(this, options.properties) || this;
          /** 样式渲染状态是否渲染、图层样式、要素样式
           * @ignore
           */
          _this._styleRenderStatus = StyleRenderStatusEnum.NULL;
          _this._coordinates = options.coordinates;
          _this._properties = options.properties || {};
          setFeatureProjection.call(_this, options);
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Feature.prototype, "id", {
          /**
           * 要素id
           *
           * 默认为要素属性中`id`值,若不存在,则内部生成
           */
          get: function () {
              return this._id;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "properties", {
          get: function () {
              return this._properties;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "style", {
          /**
           * 要素设置的样式
           */
          get: function () {
              return this._style;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "styleItemList", {
          /**
           * 当前要素使用的样式配置数组
           */
          get: function () {
              var _a;
              var style = this._styleClone || this._layerStyleClone;
              return (_a = (toStyleItemList(style) || toStyleFunction(style)(this))) === null || _a === void 0 ? void 0 : _a.map(function (i) { return (__assign$1(__assign$1({}, DEFAULT_STYLE_ITEM[i.type]), i)); });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "type", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "sourceFeature", {
          /**
           * 该要素引用的底层要素
           */
          get: function () {
              return this._sourceFeature;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "layer", {
          /**
           * 应用图层样式
           */
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "wkt", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "geoJson", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "dataProjection", {
          /**
           * 要素数据坐标名称
           */
          get: function () {
              return this._dataProjection || PUBLIC_CONFIG.dataProjection;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "projection", {
          /**
           * 要素地图中渲染使用坐标名称
           */
          get: function () {
              return this._projection || PUBLIC_CONFIG.projection;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "offset", {
          /**
           * 偏移类型
           */
          get: function () {
              return this._offset;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化要素
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Feature.prototype.init = function (style) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到图层
       *
       * @ignore
       */
      Feature.prototype.addToLayer = function (layer) {
          // 已有图层属性存在
          if (this.layer && this.layer !== layer) {
              console.warn(ErrorNotification.ADDED_FEATURE);
              this.layer.removeFeature(this);
          }
          this.layer === layer || this._updateLayer(layer);
          this.map = this.layer.map;
      };
      /**
       * 从图层中移除
       *
       * @ignore
       */
      Feature.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (destroy) {
              this.destroy();
              return;
          }
          this._unloadGeometry();
          this._layer &&
              this._layer.dispatchEvent({
                  type: BaseEventType.REMOVE_FEATURE,
                  target: this._layer,
                  feature: this
              });
          this._layer = void 0;
          this.map = void 0;
      };
      /**
       * 设置要素属性
       * @param properties
       */
      Feature.prototype.setProperties = function (properties) {
          this._properties = __assign$1({}, properties);
          this._setStyle();
          return this;
      };
      /**
       * 设置要素坐标
       *
       * @param coordinates
       */
      Feature.prototype.setCoordinates = function (coordinates, options) {
          this._coordinates = coordinates;
          setFeatureProjection.call(this, options);
          this._setStyle();
          return this;
      };
      /**
       * 设置样式
       */
      Feature.prototype.setStyle = function (style, isLayerStyle) {
          // @ts-ignore
          this[isLayerStyle ? "_layerStyle" : "_style"] = style;
          // @ts-ignore
          this[isLayerStyle ? "_layerStyleClone" : "_styleClone"] =
              Array.isArray(style) && style.length !== 0 && defined$1(style[0].type)
                  ? style.map(function (i) { return (__assign$1({}, i)); })
                  : style;
          // 要素样式存在，优先级高
          if (this._styleRenderStatus === StyleRenderStatusEnum.FEATURE_STYLE && isLayerStyle) {
              return;
          }
          this._setStyle();
          return this;
      };
      /**
       * @ignore
       */
      Feature.prototype._setStyle = function () {
          var _a, _b;
          var style = toStyleItemList(this._style || this._layerStyle, cesiumStyleItemListInit) ||
              ((_a = toStyleFunction(this._style || this._layerStyle, cesiumStyleItemListInit)) === null || _a === void 0 ? void 0 : _a(this));
          if (!((_b = this.layer) === null || _b === void 0 ? void 0 : _b.layer) || !style) {
              return;
          }
          var _feature = this.init(cesiumStyleItemListInit(style));
          this._clearGeometry();
          this._updateGeometry(_feature);
          this.dispatchEvent({
              type: BaseEventType.STYLE_CHANGED
          });
      };
      /**
       * 更新几何实体集合
       *
       *  视情况重写
       *
       * @ignore
       */
      Feature.prototype._updateGeometry = function (geometry) {
          this._sourceFeature = geometry;
          this._loadGeometry();
      };
      /**
       * 加载几何实体
       *
       * 视情况重写
       * @ignore
       */
      Feature.prototype._loadGeometry = function () {
          var e_1, _a, e_2, _b, e_3, _c;
          var _this = this;
          var _d;
          //TODO:判断要素是否添加到图层 将几何加载图层
          // 数据源集合对象
          if (!((_d = this.layer) === null || _d === void 0 ? void 0 : _d.layer) || !this._sourceFeature) {
              return false;
          }
          var _e = this.layer.layer, billboardCollection = _e.billboardCollection, labelCollection = _e.labelCollection, pointPrimitiveCollection = _e.pointPrimitiveCollection, primitiveCollection = _e.primitiveCollection, dataSource = _e.dataSource, geometryInstanceCollection = _e.geometryInstanceCollection;
          var _f = this._sourceFeature, entities = _f.entities, primitives = _f.primitives, billboards = _f.billboards, points = _f.points, labels = _f.labels, geometryInstances = _f.geometryInstances;
          if (entities) {
              try {
                  for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                      var entity = entities_1_1.value;
                      entity[FEATURE_LINK] = this;
                      dataSource.entities.add(entity);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          if (primitives) {
              try {
                  for (var primitives_1 = __values(primitives), primitives_1_1 = primitives_1.next(); !primitives_1_1.done; primitives_1_1 = primitives_1.next()) {
                      var primitive = primitives_1_1.value;
                      primitive[FEATURE_LINK] = this;
                      primitiveCollection.add(primitive);
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (primitives_1_1 && !primitives_1_1.done && (_b = primitives_1.return)) _b.call(primitives_1);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
          if (billboards) {
              this._sourceFeature.billboards = billboards.map(function (item) {
                  var billboard = billboardCollection.add(item);
                  item.alignedAxis && (billboard.alignedAxis = item.alignedAxis);
                  item.rotation && (billboard.rotation = item.rotation);
                  billboard[FEATURE_LINK] = _this;
                  billboard[COORDINATES_INDEX] = item[COORDINATES_INDEX];
                  _this.layer.visible || (billboard.show = false);
                  return billboard;
              });
          }
          if (points) {
              this._sourceFeature.points = points.map(function (item) {
                  var point = pointPrimitiveCollection.add(item);
                  point["heightReference"] = item["heightReference"];
                  point[COORDINATES_INDEX] = item[COORDINATES_INDEX];
                  point[FEATURE_LINK] = _this;
                  return point;
              });
          }
          if (labels) {
              this._sourceFeature.labels = labels.map(function (item) {
                  var label = labelCollection.add(item);
                  label[FEATURE_LINK] = _this;
                  label[COORDINATES_INDEX] = item[COORDINATES_INDEX];
                  return label;
              });
          }
          if (geometryInstances) {
              try {
                  for (var geometryInstances_1 = __values(geometryInstances), geometryInstances_1_1 = geometryInstances_1.next(); !geometryInstances_1_1.done; geometryInstances_1_1 = geometryInstances_1.next()) {
                      var geometryInstance = geometryInstances_1_1.value;
                      geometryInstance[FEATURE_LINK] = this;
                      geometryInstance.id = this;
                      geometryInstanceCollection.add(geometryInstance);
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (geometryInstances_1_1 && !geometryInstances_1_1.done && (_c = geometryInstances_1.return)) _c.call(geometryInstances_1);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
          }
          // 样式渲染状态
          this._styleRenderStatus = this.style ? StyleRenderStatusEnum.FEATURE_STYLE : StyleRenderStatusEnum.LAYER_STYLE;
          return true;
      };
      /**
       * 清空几何实体集合
       *
       *  视情况重写
       *
       * @ignore
       */
      Feature.prototype._clearGeometry = function () {
          var e_4, _a;
          this._unloadGeometry();
          //TODO:清空几何实体集合
          if (!this._sourceFeature) {
              return;
          }
          var primitives = this._sourceFeature.primitives;
          try {
              for (var primitives_2 = __values(primitives), primitives_2_1 = primitives_2.next(); !primitives_2_1.done; primitives_2_1 = primitives_2.next()) {
                  var iterator = primitives_2_1.value;
                  iterator.destroy();
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (primitives_2_1 && !primitives_2_1.done && (_a = primitives_2.return)) _a.call(primitives_2);
              }
              finally { if (e_4) throw e_4.error; }
          }
          this._sourceFeature = undefined;
      };
      /**
       * 卸载几何实体
       *
       * 视情况重写
       * @ignore
       */
      Feature.prototype._unloadGeometry = function () {
          var e_5, _a, e_6, _b, e_7, _c, e_8, _d, e_9, _e, e_10, _f;
          var _g;
          //TODO:判断要素是否添加到图层 从图层中卸载几何对象
          if (!((_g = this.layer) === null || _g === void 0 ? void 0 : _g.layer) || !this._sourceFeature) {
              return;
          }
          var _h = this.layer.layer, billboardCollection = _h.billboardCollection, labelCollection = _h.labelCollection, pointPrimitiveCollection = _h.pointPrimitiveCollection, primitiveCollection = _h.primitiveCollection, dataSource = _h.dataSource, geometryInstanceCollection = _h.geometryInstanceCollection;
          var _j = this._sourceFeature, entities = _j.entities, primitives = _j.primitives, billboards = _j.billboards, points = _j.points, labels = _j.labels, geometryInstances = _j.geometryInstances;
          if (entities) {
              try {
                  for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                      var entity = entities_2_1.value;
                      dataSource.entities.remove(entity);
                  }
              }
              catch (e_5_1) { e_5 = { error: e_5_1 }; }
              finally {
                  try {
                      if (entities_2_1 && !entities_2_1.done && (_a = entities_2.return)) _a.call(entities_2);
                  }
                  finally { if (e_5) throw e_5.error; }
              }
          }
          if (primitives) {
              try {
                  for (var primitives_3 = __values(primitives), primitives_3_1 = primitives_3.next(); !primitives_3_1.done; primitives_3_1 = primitives_3.next()) {
                      var primitive = primitives_3_1.value;
                      primitiveCollection.remove(primitive);
                  }
              }
              catch (e_6_1) { e_6 = { error: e_6_1 }; }
              finally {
                  try {
                      if (primitives_3_1 && !primitives_3_1.done && (_b = primitives_3.return)) _b.call(primitives_3);
                  }
                  finally { if (e_6) throw e_6.error; }
              }
          }
          if (billboards) {
              try {
                  for (var billboards_1 = __values(billboards), billboards_1_1 = billboards_1.next(); !billboards_1_1.done; billboards_1_1 = billboards_1.next()) {
                      var billboard = billboards_1_1.value;
                      billboardCollection.remove(billboard);
                  }
              }
              catch (e_7_1) { e_7 = { error: e_7_1 }; }
              finally {
                  try {
                      if (billboards_1_1 && !billboards_1_1.done && (_c = billboards_1.return)) _c.call(billboards_1);
                  }
                  finally { if (e_7) throw e_7.error; }
              }
          }
          if (points) {
              try {
                  for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                      var point = points_1_1.value;
                      pointPrimitiveCollection.remove(point);
                  }
              }
              catch (e_8_1) { e_8 = { error: e_8_1 }; }
              finally {
                  try {
                      if (points_1_1 && !points_1_1.done && (_d = points_1.return)) _d.call(points_1);
                  }
                  finally { if (e_8) throw e_8.error; }
              }
          }
          if (labels) {
              try {
                  for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
                      var label = labels_1_1.value;
                      labelCollection.remove(label);
                  }
              }
              catch (e_9_1) { e_9 = { error: e_9_1 }; }
              finally {
                  try {
                      if (labels_1_1 && !labels_1_1.done && (_e = labels_1.return)) _e.call(labels_1);
                  }
                  finally { if (e_9) throw e_9.error; }
              }
          }
          if (geometryInstances) {
              try {
                  for (var geometryInstances_2 = __values(geometryInstances), geometryInstances_2_1 = geometryInstances_2.next(); !geometryInstances_2_1.done; geometryInstances_2_1 = geometryInstances_2.next()) {
                      var geometryInstance = geometryInstances_2_1.value;
                      geometryInstanceCollection.remove(geometryInstance);
                  }
              }
              catch (e_10_1) { e_10 = { error: e_10_1 }; }
              finally {
                  try {
                      if (geometryInstances_2_1 && !geometryInstances_2_1.done && (_f = geometryInstances_2.return)) _f.call(geometryInstances_2);
                  }
                  finally { if (e_10) throw e_10.error; }
              }
          }
      };
      /**
       * @ignore
       * @param layer
       * @
       */
      Feature.prototype._updateLayer = function (layer) {
          this._layer = layer;
          this.applyLayerStyle();
      };
      /**
       * 应用图层样式
       *
       * @ignore
       */
      Feature.prototype.applyLayerStyle = function () {
          this.setStyle(this.layer.styleFunction, true);
      };
      /**
       * @ignore
       * @
       */
      Feature.prototype._destroy = function () {
          var e_11, _a;
          this.remove();
          if (!this._sourceFeature) {
              return;
          }
          var primitives = this._sourceFeature.primitives;
          try {
              for (var primitives_4 = __values(primitives), primitives_4_1 = primitives_4.next(); !primitives_4_1.done; primitives_4_1 = primitives_4.next()) {
                  var iterator = primitives_4_1.value;
                  iterator.destroy();
              }
          }
          catch (e_11_1) { e_11 = { error: e_11_1 }; }
          finally {
              try {
                  if (primitives_4_1 && !primitives_4_1.done && (_a = primitives_4.return)) _a.call(primitives_4);
              }
              finally { if (e_11) throw e_11.error; }
          }
          this._sourceFeature = undefined;
          this._layer = undefined;
          this._coordinates = undefined;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `pick`    |   左键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doublepick` |  左键双击拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightpick` |  右键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Feature.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `pick`    |   左键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doublepick` |  左键双击拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightpick` |  右键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Feature.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Feature;
  }(BaseObject));

  var TerrainLayer = /** @class */ (function (_super) {
      __extends$3(TerrainLayer, _super);
      function TerrainLayer(options, map) {
          return _super.call(this, options || {}, map) || this;
      }
      Object.defineProperty(TerrainLayer.prototype, "layer", {
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @override
       * @ignore
       */
      TerrainLayer.prototype.init = function () {
          this.options.type || (this.options.type = "cesium");
          switch (this.options.type) {
              case "cesium":
                  this._layer = createCesiumTerrain.call(this, this.options);
                  break;
              default:
                  throw new Error("传入的地形服务类型有误");
          }
      };
      /**
       * @override
       * @param globe
       * @ignore
       */
      TerrainLayer.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          if (this.get("visible") === false) {
              this.hide();
          }
          else {
              this.map.map.scene.terrainProvider = this._layer;
          }
      };
      /**
       * @param destroy
       * @ignore
       */
      TerrainLayer.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.scene.terrainProvider = new Cesium__namespace.EllipsoidTerrainProvider();
      };
      /**
       * 显示图层
       */
      TerrainLayer.prototype.show = function () {
          if (this.visible)
              return;
          this.map.map.scene.terrainProvider = this._layer;
          _super.prototype.show.call(this);
          return this;
      };
      /**
       * 隐藏图层
       */
      TerrainLayer.prototype.hide = function () {
          if (!this.visible)
              return;
          this.remove();
          _super.prototype.hide.call(this);
          return this;
      };
      /**
       * @ignore
       */
      TerrainLayer.prototype._destroy = function () {
          this.remove();
          this._layer = undefined;
          this.map = undefined;
          _super.prototype._destroy.call(this);
      };
      return TerrainLayer;
  }(Layer));
  function createCesiumTerrain(options) {
      return new Cesium__namespace.CesiumTerrainProvider(merge$2({
          cors: false,
          proxy: undefined,
          headers: undefined,
          parameters: undefined,
          requestWaterMask: false,
          requestVertexNormals: false,
          requestMetadata: true
      }, options));
  }

  /**
   * 判断点是否在当前相机的视椎体范围内
   * @param point { Cartesian3 } 查看器对象
   * @param viewer {Viewer } 查看器对象
   * @returns {boolean}
   * @ignore
   */
  function getPointVisibility(point, viewer) {
      var _a;
      if (2 /* SCENE2D */ === viewer.scene.mode) {
          return true;
      }
      if (!(point instanceof Cesium__namespace.Cartesian3)) {
          var coordinate = point.geometry.coordinates;
          point = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
      }
      //@ts-ignore
      return new Cesium__namespace.EllipsoidalOccluder(viewer.scene.globe.ellipsoid, viewer.camera.position).isPointVisible(point);
  }
  function computeBoundingSphere(geojson, map, padding) {
      if (padding === void 0) { padding = 0; }
      var _a = __read(Turf__namespace.bbox(geojson), 4), minX = _a[0], minY = _a[1], maxX = _a[2], maxY = _a[3];
      return new Cesium__namespace.BoundingSphere(degreesToCartesian3([(maxX - minX) / 2 + minX, (maxY - minY) / 2 + minY], map), Math.max(Number.parseInt((Turf__namespace.distance([minX, minY], [maxX, minY]) * 1000) / 2 + padding + ""), Number.parseInt((Turf__namespace.distance([minX, minY], [minX, maxY]) * 1000) / 2 + padding + "")));
  }
  /**
   *
   * @ignore
   * @returns {[number, number, number, number]}
   */
  function getBbox(data, padding) {
      if (padding === void 0) { padding = 0.5; }
      return Turf__namespace.bbox(lineString(data.map(function (i) {
          return [i.x, i.y];
      }))).map(function (i, index) { return i + (index > 1 ? padding : -padding); });
  }
  /**
   * 将经纬度坐标贴地
   */
  function coordinatesClampToTerrain(coordinates, map) {
      return __awaiter$8(this, void 0, void 0, function () {
          var terrainLayer, cartographicArray, res, index, item, r;
          return __generator$1(this, function (_a) {
              switch (_a.label) {
                  case 0:
                      terrainLayer = map.getLayers().find(function (layer) {
                          return layer instanceof TerrainLayer;
                      });
                      if (!terrainLayer) {
                          return [2 /*return*/, coordinates];
                      }
                      return [4 /*yield*/, Cesium__namespace.sampleTerrainMostDetailed(terrainLayer.layer, coordinates.map(function (item) {
                              return degreesToCartographic(item);
                          }))];
                  case 1:
                      cartographicArray = _a.sent();
                      res = [];
                      index = 0;
                      _a.label = 2;
                  case 2:
                      if (!(index < cartographicArray.length)) return [3 /*break*/, 7];
                      item = cartographicArray[index];
                      r = __spreadArray$1([], __read(coordinates[index]), false);
                      if (!defined$1(item.height)) return [3 /*break*/, 3];
                      r[2] = item.height;
                      return [3 /*break*/, 5];
                  case 3: return [4 /*yield*/, coordinateClampToTerrain(r, map)];
                  case 4:
                      r = _a.sent();
                      _a.label = 5;
                  case 5:
                      res.push(r);
                      _a.label = 6;
                  case 6:
                      index++;
                      return [3 /*break*/, 2];
                  case 7: return [2 /*return*/, res];
              }
          });
      });
  }
  function coordinateClampToTerrain(coordinate, map) {
      return __awaiter$8(this, void 0, void 0, function () {
          var height, temCartographic, maxLevel, terrainLayer;
          return __generator$1(this, function (_a) {
              switch (_a.label) {
                  case 0:
                      maxLevel = 14;
                      terrainLayer = map.getLayers().find(function (layer) {
                          return layer instanceof TerrainLayer;
                      });
                      if (!terrainLayer) {
                          return [2 /*return*/, coordinate];
                      }
                      _a.label = 1;
                  case 1:
                      if (!(!defined$1(height) && maxLevel >= 0)) return [3 /*break*/, 3];
                      return [4 /*yield*/, Cesium__namespace.sampleTerrain(terrainLayer.layer, maxLevel, [degreesToCartographic(coordinate)])];
                  case 2:
                      temCartographic = _a.sent();
                      height = temCartographic[0].height;
                      --maxLevel;
                      if (defined$1(height)) {
                          coordinate[2] = height;
                      }
                      return [3 /*break*/, 1];
                  case 3: return [2 /*return*/, coordinate];
              }
          });
      });
  }
  /**
   * 更新模型要素的方向
   *
   * @param feature
   * @param position1
   * @param position2
   * @param ellipsoid
   */
  function updateFeatureOrientation(feature, position1, position2, ellipsoid) {
      var _a;
      var s = Cesium__namespace.Cartesian3.subtract(position2, position1, new Cesium__namespace.Cartesian3());
      if (!Cesium__namespace.Cartesian3.ZERO.equals(s)) {
          var normal = Cesium__namespace.Cartesian3.normalize(s, new Cesium__namespace.Cartesian3());
          //将位置和速度转换为旋转矩阵
          var rotationMatrix3_1 = Cesium__namespace.Transforms.rotationMatrixFromPositionVelocity(position1, normal, ellipsoid);
          (_a = feature.sourceFeature.entities) === null || _a === void 0 ? void 0 : _a.forEach(function (entity) {
              var _a;
              if (entity.model) {
                  var orientation_1 = entity[STYLE_ITEM_LINK].orientation || [0, 0, 0];
                  entity.orientation = new Cesium__namespace.ConstantProperty(Cesium__namespace.Quaternion.fromRotationMatrix(
                  // rotationMatrix3
                  Cesium__namespace.Matrix3.multiply(rotationMatrix3_1, Cesium__namespace.Matrix3.fromHeadingPitchRoll(new ((_a = Cesium__namespace.HeadingPitchRoll).bind.apply(_a, __spreadArray$1([void 0], __read(orientation_1.map(function (i) { return toRadians(i); })), false)))()), rotationMatrix3_1)));
              }
          });
      }
  }
  /**
   * 获取点要素模型相关的参数
   *
   * @param point
   * @param map
   * @returns
   */
  function getPointFeatureModelParams(point, map) {
      var clamped = point.sourceFeature.entities.reduce(function (prev, curr) {
          var _a;
          if (prev === true) {
              return true;
          }
          if (((_a = curr.model) === null || _a === void 0 ? void 0 : _a.heightReference) &&
              curr.model.heightReference.getValue(map.map.clock.currentTime) === HeightReference.CLAMP_TO_GROUND) {
              return true;
          }
          return false;
      }, false);
      var hasModel = point.sourceFeature.entities.reduce(function (prev, curr) {
          if (prev === true) {
              return true;
          }
          if (defined$1(curr.model)) {
              return true;
          }
          else {
              return false;
          }
      }, false);
      return {
          clamped: clamped,
          hasModel: hasModel
      };
  }
  /**
   * @description 获取当前视图范围
   * @function getCurrentExtent
   * @param {Object} map Map
   * @example
   */
  function getCurrentExtent(map) {
      var extent = {};
      var viewer = map.map;
      var scene = viewer.scene;
      // 得到当前三维场景的椭球体
      var ellipsoid = scene.globe.ellipsoid;
      var canvas = scene.canvas;
      // canvas左上角
      var car3_lt = viewer.camera.pickEllipsoid(
      // @ts-ignore
      new Cesium__namespace.Cartesian2(0, 0), ellipsoid);
      // canvas右下角
      var car3_rb = viewer.camera.pickEllipsoid(
      // @ts-ignore
      new Cesium__namespace.Cartesian2(canvas.width, canvas.height), ellipsoid);
      // 当canvas左上角和右下角全部在椭球体上
      if (car3_lt && car3_rb) {
          var carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
          var carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
          // @ts-ignore
          extent.minX = Cesium__namespace.Math.toDegrees(carto_lt.longitude);
          // @ts-ignore
          extent.maxY = Cesium__namespace.Math.toDegrees(carto_lt.latitude);
          // @ts-ignore
          extent.maxX = Cesium__namespace.Math.toDegrees(carto_rb.longitude);
          // @ts-ignore
          extent.minY = Cesium__namespace.Math.toDegrees(carto_rb.latitude);
      }
      else if (!car3_lt && car3_rb) {
          // 当canvas左上角不在但右下角在椭球体上
          var car3_lt2 = null;
          var yIndex = 0;
          do {
              // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率
              // eslint-disable-next-line no-unused-expressions
              yIndex <= canvas.height ? (yIndex += 10) : canvas.height;
              car3_lt2 = viewer.camera.pickEllipsoid(
              // @ts-ignore
              new Cesium__namespace.Cartesian2(0, yIndex), ellipsoid);
          } while (!car3_lt2);
          var carto_lt2 = ellipsoid.cartesianToCartographic(car3_lt2);
          var carto_rb2 = ellipsoid.cartesianToCartographic(car3_rb);
          extent.minX = Cesium__namespace.Math.toDegrees(carto_lt2.longitude);
          extent.maxY = Cesium__namespace.Math.toDegrees(carto_lt2.latitude);
          extent.maxX = Cesium__namespace.Math.toDegrees(carto_rb2.longitude);
          extent.minY = Cesium__namespace.Math.toDegrees(carto_rb2.latitude);
      }
      // 获取高度
      extent.height = Math.ceil(viewer.camera.positionCartographic.height);
      return [extent.minX, extent.minY, extent.maxX, extent.maxY];
  }
  function LineStringCoordinatesToCartesian3Array(lineStringCoordinates) {
      return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(lineStringCoordinates
          .map(function (coord) {
          if (coord.length === 2) {
              coord[2] = 0;
          }
          return coord;
      })
          .flat());
  }

  /**
   * 返回当前相机位置（角度）
   *
   * @param map
   * @returns
   */
  function getDegreesOfCamera(map) {
      var viewer = map.map;
      var lngLat = cartesian3ToDegrees(viewer.camera.positionWC, map);
      var heading = Cesium__namespace.Math.toDegrees(viewer.camera.heading || 0);
      var pitch = Cesium__namespace.Math.toDegrees(viewer.camera.pitch || -90);
      var roll = Cesium__namespace.Math.toDegrees(viewer.camera.roll || 0);
      return {
          destination: [lngLat[0], lngLat[1], lngLat[2]],
          orientation: [360 - heading, pitch, roll]
      };
  }
  /**
   * 经纬度坐标转化为三维笛卡尔坐标
   */
  function degreesToCartesian3(coordinate, map) {
      var _a;
      return Cesium__namespace.Cartesian3.fromDegrees(coordinate[0], coordinate[1], coordinate[2] || 0, (_a = map === null || map === void 0 ? void 0 : map.map) === null || _a === void 0 ? void 0 : _a.scene.globe.ellipsoid);
  }
  /**
   * 三维笛卡尔坐标转为经纬度坐标
   */
  function cartesian3ToDegrees(cartesian3, map) {
      var lngLat = (map ? map.map.scene.globe.ellipsoid : Cesium__namespace.Ellipsoid.WGS84).cartesianToCartographic(cartesian3);
      var lng = Cesium__namespace.Math.toDegrees(lngLat.longitude);
      var lat = Cesium__namespace.Math.toDegrees(lngLat.latitude);
      var hei = lngLat.height;
      return [lng, lat, hei];
  }
  /**
   *  三维笛卡尔坐标转为制图坐标对象
   */
  function cartesian3ToCartographic(cartesian3, map) {
      var _a;
      return Cesium__namespace.Cartographic.fromCartesian(cartesian3, (_a = map === null || map === void 0 ? void 0 : map.map) === null || _a === void 0 ? void 0 : _a.scene.globe.ellipsoid);
  }
  /**
   * 地理制图坐标对象转为三维笛卡尔坐标
   *
   * @param {Cesium.Cartographic} cartographic
   * @returns {PointCoordinate}
   */
  function cartographicToCartesian3(cartographic, map) {
      var _a;
      var lng = Cesium__namespace.Math.toDegrees(cartographic.longitude);
      var lat = Cesium__namespace.Math.toDegrees(cartographic.latitude);
      var hei = cartographic.height;
      return Cesium__namespace.Cartesian3.fromDegrees(lng, lat, hei, (_a = map === null || map === void 0 ? void 0 : map.map) === null || _a === void 0 ? void 0 : _a.scene.globe.ellipsoid);
  }
  /**
   * 获取地球当前缩放级别
   *
   * @param {Globe} map
   * @returns {number}
   */
  function getZoom(map) {
      return heightToZoom(getHeight(map));
  }
  /**
   * 获取地球当前中心点坐标
   *
   * @param map
   * @returns
   */
  function getCenter$1(map) {
      var res;
      if (map.map.scene.mode === 2 /* SCENE2D */) {
          res = cartographicToDegrees(map.map.camera.positionCartographic);
      }
      else {
          try {
              res = pixelToDegrees([map.map.container.clientWidth / 2, map.map.container.clientHeight / 2], map);
          }
          catch (error) {
              res = getDegreesOfCamera(map).destination;
          }
      }
      res.length = 2;
      return res;
  }
  /**
   * 获取相机高度
   * @param map
   * @returns
   */
  function getHeight(map) {
      return map.map.camera.positionCartographic.height;
  }
  /**
   * 计算多边形面积
   *
   * @ignore
   * @param {PointCoordinate[]} points
   * @returns
   */
  function getArea(points) {
      var res = 0;
      //拆分三角曲面
      for (var i = 0; i < points.length - 2; i++) {
          var j = (i + 1) % points.length;
          var k = (i + 2) % points.length;
          var totalAngle = Angle(points[i], points[j], points[k]);
          var dis_temp1 = distance$2(points[i], points[j]);
          var dis_temp2 = distance$2(points[j], points[k]);
          res += dis_temp1 * dis_temp2 * Math.abs(Math.sin(totalAngle));
      }
      if (res < 1000000) {
          return res.toFixed(2) + "平方米";
      }
      return (res / 1000000.0).toFixed(2) + "平方千米";
  }
  /*角度*/
  function Angle(p1, p2, p3) {
      var bearing21 = Bearing(p2, p1);
      var bearing23 = Bearing(p2, p3);
      var angle = bearing21 - bearing23;
      if (angle < 0) {
          angle += 360;
      }
      return angle;
  }
  /*方向*/
  function Bearing(from, to) {
      var lat1 = Cesium__namespace.Math.toRadians(from[0]);
      var lon1 = Cesium__namespace.Math.toRadians(from[1]);
      var lat2 = Cesium__namespace.Math.toRadians(to[0]);
      var lon2 = Cesium__namespace.Math.toRadians(to[1]);
      var angle = -Math.atan2(Math.sin(lon1 - lon2) * Math.cos(lat2), Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));
      if (angle < 0) {
          angle += Math.PI * 2.0;
      }
      angle = Cesium__namespace.Math.toDegrees(angle);
      return angle;
  }
  /**
   * 计算两点之间椭球面的测地线距离
   *
   * 单位: 米
   * @param coordinate1
   * @param coordinate2
   * @returns
   */
  function distance$2(coordinate1, coordinate2) {
      var point1cartographic = degreesToCartographic(coordinate1);
      var point2cartographic = degreesToCartographic(coordinate2);
      /**根据经纬度计算出距离**/
      var geodesic = new Cesium__namespace.EllipsoidGeodesic();
      geodesic.setEndPoints(point1cartographic, point2cartographic);
      var s = geodesic.surfaceDistance;
      //返回两点之间的距离
      s = Math.sqrt(Math.pow(s, 2) + Math.pow(point2cartographic.height - point1cartographic.height, 2));
      return s;
  }
  /**
   * 计算包含高度的空间距离
   * @param x {Cartographic} 起始点的地理坐标
   * @param y {Cartographic} 结束点的地理坐标
   * @returns {string} 两点之间的空间距离(m)
   * @ignore
   */
  var getSpaceDistance = function (x, y) {
      var surdis = getDistance(x, y);
      return Math.sqrt(Math.pow(surdis, 2) + Math.pow(x.height - y.height, 2));
  };
  /**
   * 一组空间点组成的空间折线的距离
   * @param positions {Array<Cartesian3>} 起始点的地理坐标
   * @returns {number} 一组空间点组成的空间折线的距离
   * @ignore
   */
  var getSpaceDisfromCartesian3Array = function (positions) {
      var dist = 0.0;
      // @ts-ignore
      for (var i = 0; i < positions.length - 1; i++) {
          dist += getSpaceDistance(Cesium__namespace.Cartographic.fromCartesian(positions[i]), Cesium__namespace.Cartographic.fromCartesian(positions[i + 1]));
      }
      var result = "";
      if (dist < 1000) {
          result = dist.toFixed(2) + "米";
      }
      else {
          result = (dist / 1000).toFixed(2) + "千米";
      }
      return result;
  };
  /**
   * 计算两点测地线距离，如果两点不在椭球面上，沿着椭球面法线投影到椭球面上，再进行距离计算
   * @param x {Cesium.Cartographic} 起始点的地理坐标
   * @param y {Cesium.Cartographic} 结束点的地理坐标
   * @returns {number} 两点的测地线距离，即地球椭球面上两点之间最短距离
   * @ignore
   */
  var getDistance = function (x, y) {
      var _x = x;
      var _y = y;
      if (Array.isArray(x)) {
          _x = degreesToCartographic(x);
      }
      if (Array.isArray(y)) {
          _y = degreesToCartographic(y);
      }
      var geodesic = new Cesium__namespace.EllipsoidGeodesic();
      geodesic.setEndPoints(_x, _y);
      return geodesic.surfaceDistance;
  };
  /**
   * 三维笛卡尔坐标数组转为经纬度坐标集合
   */
  function cartesian3sToDegreesArray(cartesian3s, map) {
      return cartesian3s.map(function (cartesian3) {
          return cartesian3ToDegrees(cartesian3, map);
      });
  }
  /**
   *  屏幕像素转为经纬度坐标
   */
  function pixelToDegrees(windowCoordinates, map) {
      return cartesian3ToDegrees(map.map.scene.globe.pick(map.map.camera.getPickRay(Cesium__namespace.Cartesian2.fromArray(windowCoordinates)), map.map.scene), map);
  }
  /**
   * 计算当前单位像素对应的实际距离(单位米)
   *
   * @param {Globe} globe
   * @returns
   */
  function getPixelSize(map) {
      return map.map.camera.getPixelSize(Cesium__namespace.BoundingSphere.fromEllipsoid(map.map.scene.globe.ellipsoid), map.map.scene.drawingBufferWidth, map.map.scene.drawingBufferHeight);
  }
  /**
   *  屏幕像素转为三维笛卡尔坐标
   * @param windowCoordinates {Cartesian2} 屏幕坐标
   * @param viewer {Viewer } 查看器对象
   * @return {Cartesian3}
   */
  function pixelToCartesian3(windowCoordinates, map) {
      return map.map.scene.globe.pick(map.map.camera.getPickRay(windowCoordinates), map.map.scene);
  }
  /**
   * 三维笛卡尔坐标转为屏幕像素坐标
   */
  function cartesian3ToPixel(cartesian3, map) {
      return Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(map.map.scene, cartesian3);
  }
  /**
   * 地理制图坐标对象转为经纬度坐标
   *
   * @param {Cesium.Cartographic} cartographic
   * @returns {PointCoordinate}
   */
  function cartographicToDegrees(cartographic) {
      var lng = Cesium__namespace.Math.toDegrees(cartographic.longitude);
      var lat = Cesium__namespace.Math.toDegrees(cartographic.latitude);
      var hei = cartographic.height;
      return [lng, lat, hei];
  }
  /**
   * 经纬度坐标转为地理制图坐标对象
   * @param coordinate
   * @returns
   */
  function degreesToCartographic(coordinate) {
      var _a;
      return (_a = Cesium__namespace.Cartographic).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
  }
  /**
   * 经纬度坐标转为屏幕像素坐标
   *
   * @param coordinate 经纬度坐标
   */
  function degreesToPixel(coordinate, map) {
      return Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(map.map.scene, degreesToCartesian3(coordinate, map));
  }
  function coordinatesToCartesian3Array(coordinates) {
      if (coordinates[0].length <= 2) {
          return Cesium__namespace.Cartesian3.fromDegreesArray(coordinates.flat());
      }
      else {
          return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(coordinates.flat());
      }
  }

  var ModelType;
  (function (ModelType) {
      ModelType["MODEL"] = "model";
      ModelType["MODEL_ENTITY"] = "modelEntity";
  })(ModelType || (ModelType = {}));
  var DirectionType;
  (function (DirectionType) {
      DirectionType["MOVE_UP"] = "moveup";
      DirectionType["MOVE_DOWN"] = "movedown";
      DirectionType["MOVE_LEFT"] = "moveleft";
      DirectionType["MOVE_RIGHT"] = "moveright";
      DirectionType["MOVE_FORWARD"] = "moveforward";
      DirectionType["MOVE_BACKWARD"] = "movebackward";
  })(DirectionType || (DirectionType = {}));

  /**
   * 模型基础类
   *
   * 此为基类,不可实例化
   */
  var Model = /** @class */ (function (_super) {
      __extends$3(Model, _super);
      function Model(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           */
          _this._visible = true;
          /**
           * @ignore
           */
          _this._initialized = false;
          if (defined$1(map)) {
              map.addModel(_this);
          }
          return _this;
      }
      Object.defineProperty(Model.prototype, "visible", {
          /**
           * 模型显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Model.prototype, "model", {
          /**
           * 内部模型对象
           */
          get: function () {
              return this._model;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Model.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化模型
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Model.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      // addTo(map: IMap): void {}
      /**
       * 添加到地球
       *
       * @ignore
       */
      Model.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this.initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Model.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Object.defineProperty(Model.prototype, "rotate", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 显示模型
       */
      Model.prototype.show = function () {
          this._visible = true;
          return this;
      };
      /**
       * 隐藏模型
       */
      Model.prototype.hide = function () {
          this._visible = false;
          return this;
      };
      Model.prototype.setTranslation = function (translation) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Model.prototype.setRotate = function (rotate) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      return Model;
  }(BaseObject));
  function orientationToRadians(orientation) {
      if (orientation === void 0) { orientation = [0, 0, 0]; }
      return orientation.map(function (i) { return toRadians(i); });
  }
  // 计算一个代表模型旋转的四元数
  function buildModelDirection(_a) {
      var _b, _c;
      var position = _a.position, orientation = _a.orientation;
      return new Cesium__namespace.ConstantProperty(Cesium__namespace.Transforms.headingPitchRollQuaternion((_b = Cesium__namespace.Cartesian3).fromDegrees.apply(_b, __spreadArray$1([], __read(position), false)), new ((_c = Cesium__namespace.HeadingPitchRoll).bind.apply(_c, __spreadArray$1([void 0], __read(orientationToRadians(orientation)), false)))()));
  }

  var index$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defined: defined$1,
    toRadians: toRadians,
    toDegrees: toDegrees,
    convertToProjectionRadius: convertToProjectionRadius,
    calculatesDistance: calculatesDistance,
    calculatesRadius: calculatesRadius,
    getCircleCoordinates: getCircleCoordinates,
    createParabola: createParabola,
    saveDataURL: saveDataURL,
    calculateNorthAngleDegrees: calculateNorthAngleDegrees,
    coordinatesClampToTerrain: coordinatesClampToTerrain,
    getDegreesOfCamera: getDegreesOfCamera,
    degreesToCartesian3: degreesToCartesian3,
    cartesian3ToDegrees: cartesian3ToDegrees,
    cartesian3ToCartographic: cartesian3ToCartographic,
    cartographicToCartesian3: cartographicToCartesian3,
    getZoom: getZoom,
    getCenter: getCenter$1,
    getHeight: getHeight,
    getArea: getArea,
    distance: distance$2,
    getSpaceDistance: getSpaceDistance,
    getSpaceDisfromCartesian3Array: getSpaceDisfromCartesian3Array,
    getDistance: getDistance,
    cartesian3sToDegreesArray: cartesian3sToDegreesArray,
    pixelToDegrees: pixelToDegrees,
    getPixelSize: getPixelSize,
    pixelToCartesian3: pixelToCartesian3,
    cartesian3ToPixel: cartesian3ToPixel,
    cartographicToDegrees: cartographicToDegrees,
    degreesToCartographic: degreesToCartographic,
    degreesToPixel: degreesToPixel,
    coordinatesToCartesian3Array: coordinatesToCartesian3Array
  });

  var Point$1 = /** @class */ (function (_super) {
      __extends$3(Point, _super);
      /**
       * @param options
       * @param layer
       */
      function Point(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, projection = _a.projection, dataProjection = _a.dataProjection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: coordinates, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }) || this;
          updateTransformCoordinates$2.call(_this);
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Point.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "type", {
          get: function () {
              return Array.isArray(this.coordinates[0]) ? GeoJsonGeometryType.MULTI_POINT : GeoJsonGeometryType.POINT;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "geoJson", {
          get: function () {
              return {
                  type: GeoJsonType.FEATURE,
                  properties: this.properties,
                  geometry: {
                      type: this.type,
                      coordinates: this.coordinates
                  }
              };
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @override
       * @param coordinates
       * @returns
       */
      Point.prototype.setCoordinates = function (coordinates, options) {
          var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
          var previousType = this.type;
          this._coordinates = coordinates;
          updateTransformCoordinates$2.call(this);
          if ((previousType === this.type && previousType === GeoJsonGeometryType.POINT) ||
              (previousType === GeoJsonGeometryType.MULTI_POINT && coordinates.length === this._coordinates.length)) {
              var _e = this.sourceFeature, points = _e.points, billboards = _e.billboards, labels = _e.labels, entities = _e.entities;
              if (points) {
                  try {
                      for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                          var point = points_1_1.value;
                          point.position = degreesToCartesian3(this._transformedCoordinates[point[COORDINATES_INDEX]], this.map);
                      }
                  }
                  catch (e_1_1) { e_1 = { error: e_1_1 }; }
                  finally {
                      try {
                          if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                  }
              }
              if (billboards) {
                  try {
                      for (var billboards_1 = __values(billboards), billboards_1_1 = billboards_1.next(); !billboards_1_1.done; billboards_1_1 = billboards_1.next()) {
                          var billboard = billboards_1_1.value;
                          billboard.position = degreesToCartesian3(this._transformedCoordinates[billboard[COORDINATES_INDEX]], this.map);
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (billboards_1_1 && !billboards_1_1.done && (_b = billboards_1.return)) _b.call(billboards_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
              }
              if (labels) {
                  try {
                      for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
                          var label = labels_1_1.value;
                          label.position = degreesToCartesian3(this._transformedCoordinates[label[COORDINATES_INDEX]], this.map);
                      }
                  }
                  catch (e_3_1) { e_3 = { error: e_3_1 }; }
                  finally {
                      try {
                          if (labels_1_1 && !labels_1_1.done && (_c = labels_1.return)) _c.call(labels_1);
                      }
                      finally { if (e_3) throw e_3.error; }
                  }
              }
              if (entities) {
                  try {
                      for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                          var entity = entities_1_1.value;
                          if (entity.position instanceof Cesium__namespace.ConstantPositionProperty) {
                              entity.position.setValue(degreesToCartesian3(this._transformedCoordinates[entity[COORDINATES_INDEX]], this.map));
                          }
                      }
                  }
                  catch (e_4_1) { e_4 = { error: e_4_1 }; }
                  finally {
                      try {
                          if (entities_1_1 && !entities_1_1.done && (_d = entities_1.return)) _d.call(entities_1);
                      }
                      finally { if (e_4) throw e_4.error; }
                  }
              }
          }
          else {
              _super.prototype.setCoordinates.call(this, coordinates, options);
          }
          return this;
      };
      /**
       *
       * @ignore
       */
      Point.prototype.init = function (styles) {
          var e_5, _a;
          var featureGeometry = {
              entities: [],
              primitives: [],
              billboards: [],
              points: [],
              labels: [] // 标注
          };
          try {
              for (var styles_1 = __values(styles), styles_1_1 = styles_1.next(); !styles_1_1.done; styles_1_1 = styles_1.next()) {
                  var style = styles_1_1.value;
                  buildGeometry$3.call(this, style, featureGeometry);
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (styles_1_1 && !styles_1_1.done && (_a = styles_1.return)) _a.call(styles_1);
              }
              finally { if (e_5) throw e_5.error; }
          }
          return featureGeometry;
      };
      /**
       * @ignore
       * @override 特殊处理,需重新写
       */
      Point.prototype._loadGeometry = function () {
          var _this = this;
          if (_super.prototype._loadGeometry.call(this)) {
              var coords = this.type === GeoJsonGeometryType.POINT
                  ? [this._coordinates]
                  : this._coordinates;
              this._clearHeightUpdate();
              // 点数量
              var count_1 = coords.length;
              // @ts-ignore 函数数组，执行该函数取消对点高程的实时修正
              this._clearHeightUpdateFunc = coords.map(function (item, index) {
                  //@ts-ignore
                  return _this._layer.map.map.scene.globe._surface.updateHeight(degreesToCartographic(item), updatePointHeight.call(_this, index, count_1, item));
              });
              return true;
          }
          else {
              return false;
          }
      };
      /**
       * @ignore
       * @protected
       */
      Point.prototype._clearHeightUpdate = function () {
          var e_6, _a;
          // @ts-ignore
          if (this._clearHeightUpdateFunc) {
              try {
                  // @ts-ignore
                  for (var _b = __values(this._clearHeightUpdateFunc), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var iterator = _c.value;
                      iterator();
                  }
              }
              catch (e_6_1) { e_6 = { error: e_6_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_6) throw e_6.error; }
              }
          }
      };
      /**
       * @override
       * @ignore
       */
      Point.prototype._destroy = function () {
          this._clearHeightUpdate();
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `pick`    |   左键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doublepick` |  左键双击拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightpick` |  右键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `move`    |   要素移动队列中要素移动  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Point.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `pick`    |   左键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `doublepick` |  左键双击拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `rightpick` |  右键拾取(只有顶部要素触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (feature: [[Feature]])-要素对象
       *  `move`    |   要素移动队列中要素移动  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Point.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Point;
  }(Feature));
  // 构建几何体
  function buildGeometry$3(style, store) {
      switch (style.type) {
          case StyleItemType.CIRCLE:
              if (style.entity) {
                  buildPointEntity.call(this, style, store.entities);
              }
              else {
                  store.points = store.points.concat(buildPointPrimitive.call(this, style));
              }
              break;
          case StyleItemType.ICON:
              if (style.entity) {
                  buildBillboardEntity.call(this, style, store.entities);
              }
              else {
                  store.billboards = store.billboards.concat(buildBillboard.call(this, style));
              }
              break;
          case StyleItemType.LABEL:
              if (style.entity) {
                  buildLabelEntity.call(this, style, store.entities);
              }
              else {
                  store.labels = store.labels.concat(buildLabel.call(this, style));
              }
              break;
          case StyleItemType.MODEL:
              if (style.entity) {
                  buildModelEntity.call(this, style, store.entities);
              }
              break;
      }
  }
  // 根据投影选项投影坐标
  function updateTransformCoordinates$2() {
      var coordinates = this.coordinates;
      if (this.type === GeoJsonGeometryType.POINT) {
          coordinates = [coordinates];
      }
      this._transformedCoordinates = transformGeoJsonGeometryCoordinates(coordinates, {
          source: this.dataProjection,
          destination: this.projection,
          offset: this.offset
      });
  }
  // 构建点图元
  function buildPointPrimitive(style) {
      var _this = this;
      return this._transformedCoordinates.map(function (coordinate, index) {
          var _a;
          return __assign$1(__assign$1({ id: _this, position: degreesToCartesian3(coordinate, _this.map), color: style.fillColor, pixelSize: style.radius * 2 }, style), (_a = {}, _a[COORDINATES_INDEX] = index, _a));
      });
  }
  // 构建广告牌
  function buildBillboard(style) {
      var _this = this;
      return this._transformedCoordinates.map(function (coordinate, index) {
          var _a;
          return __assign$1(__assign$1({ id: _this, position: degreesToCartesian3(coordinate, _this.map) }, style), (_a = {}, _a[COORDINATES_INDEX] = index, _a));
      });
  }
  // 构建标注
  function buildLabel(style) {
      var _this = this;
      return this._transformedCoordinates.map(function (coordinate, index) {
          var options = buildLabelOptions.call(_this, { coordinate: coordinate, styleItem: style, properties: _this.properties });
          options[COORDINATES_INDEX] = index;
          return options;
      });
  }
  // 构建实体数组
  function buildPointEntity(style, storeArray) {
      var _this = this;
      // 是否覆盖
      var over = false;
      var count = this._transformedCoordinates.length;
      var pointGraphicsOptions = __assign$1({ color: style.fillColor, pixelSize: style.radius * 2 }, style);
      for (var index = 0, length_1 = storeArray.length; index < length_1; index += count) {
          if (!defined$1(storeArray[index].point)) {
              for (var number = 0; number < count; number++) {
                  storeArray[index + number].point = new Cesium__namespace.PointGraphics(pointGraphicsOptions);
              }
              over = true;
              break;
          }
      }
      if (!over) {
          this._transformedCoordinates.forEach(function (coordinate, coordinateIndex) {
              var point = new Cesium__namespace.Entity(__assign$1({ position: degreesToCartesian3(coordinate, _this.map), point: pointGraphicsOptions }, style));
              point[COORDINATES_INDEX] = coordinateIndex;
              storeArray.push(point);
          });
      }
  }
  // 构建实体数组
  function buildBillboardEntity(style, storeArray) {
      var _this = this;
      var over = false;
      var count = this._transformedCoordinates.length;
      var billboardGraphicsOptions = style;
      for (var index = 0, length_2 = storeArray.length; index < length_2; index += count) {
          if (!defined$1(storeArray[index].billboard)) {
              for (var number = 0; number < count; number++) {
                  storeArray[index + number].billboard = new Cesium__namespace.BillboardGraphics(billboardGraphicsOptions);
              }
              over = true;
              break;
          }
      }
      if (!over) {
          this._transformedCoordinates.forEach(function (coordinate, coordinateIndex) {
              var billboard = new Cesium__namespace.Entity({
                  position: degreesToCartesian3(coordinate, _this.map),
                  billboard: billboardGraphicsOptions
              });
              billboard[COORDINATES_INDEX] = coordinateIndex;
              storeArray.push(billboard);
          });
      }
  }
  // 构建实体数组
  function buildLabelEntity(style, storeArray) {
      var _this = this;
      var over = false;
      var count = this._transformedCoordinates.length;
      var labelGraphics = buildLabelGraphics({ styleItem: style, properties: this.properties });
      for (var index = 0, length_3 = storeArray.length; index < length_3; index += count) {
          if (!defined$1(storeArray[index].label)) {
              for (var number = 0; number < count; number++) {
                  storeArray[index + number].label = labelGraphics;
              }
              over = true;
              break;
          }
      }
      if (!over) {
          this._transformedCoordinates.forEach(function (coordinate, coordinateIndex) {
              var label = new Cesium__namespace.Entity({
                  position: degreesToCartesian3(coordinate, _this.map),
                  label: labelGraphics
              });
              label[COORDINATES_INDEX] = coordinateIndex;
              storeArray.push(label);
          });
      }
  }
  // 构建模型entity
  function buildModelEntity(style, storeArray) {
      var _this = this;
      this._transformedCoordinates.forEach(function (coordinate, index) {
          var model = new Cesium__namespace.Entity(__assign$1(__assign$1({ position: degreesToCartesian3(coordinate, _this.map), model: __assign$1({ uri: style.url }, style) }, style), { orientation: Array.isArray(style.orientation)
                  ? buildModelDirection({ position: coordinate, orientation: style.orientation })
                  : style.orientation }));
          model[COORDINATES_INDEX] = index;
          model[STYLE_ITEM_LINK] = style;
          storeArray.push(model);
      });
  }
  // 调整点高度，相对地形、贴地
  function updatePointHeight(index, count, coords) {
      var _this = this;
      return function (cartesian3) {
          _this._sourceFeature.points.forEach(function (point, i) {
              if (i % count === index) {
                  //@ts-ignore
                  if (point.heightReference === 1 /* CLAMP_TO_GROUND */) {
                      point.position = cartesian3.clone(new Cesium__namespace.Cartesian3());
                  }
                  else if (
                  //@ts-ignore
                  point.heightReference === 2 /* RELATIVE_TO_GROUND */) {
                      var cartographic = _this._layer.map.map.scene.globe.ellipsoid.cartesianToCartographic(cartesian3);
                      cartographic.height += coords[2] || 0;
                      point.position = _this._layer.map.map.scene.globe.ellipsoid.cartographicToCartesian(cartographic, new Cesium__namespace.Cartesian3());
                  }
              }
          });
      };
  }
  function buildLabelGraphics(_a) {
      var styleItem = _a.styleItem; _a.positionStoreMap; _a.height; var properties = _a.properties;
      var labelGraphicsOptions = __assign$1(__assign$1({}, styleItem), { text: replaceText(styleItem.text, properties) });
      return new Cesium__namespace.LabelGraphics(labelGraphicsOptions);
  }
  function buildLabelOptions(_a) {
      var coordinate = _a.coordinate, styleItem = _a.styleItem, properties = _a.properties;
      return __assign$1(__assign$1({ id: this, position: degreesToCartesian3(coordinate, this === null || this === void 0 ? void 0 : this.map) }, styleItem), { text: replaceText(styleItem.text || "", properties) });
  }

  function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          var coordinate = coordinates[i];
          for (var j = 0; j < stride; ++j) {
              flatCoordinates[offset++] = coordinate[j];
          }
      }
      return offset;
  }
  function deflateCoordinatesArray(flatCoordinates, offset, coordinates, stride, opt_ends) {
      var ends = opt_ends ? opt_ends : [];
      var i = 0;
      for (var j = 0, jj = coordinates.length; j < jj; ++j) {
          var end = deflateCoordinates(flatCoordinates, offset, coordinates[j], stride);
          ends[i++] = end;
          offset = end;
      }
      ends.length = i;
      return ends;
  }
  function getFlatMidpoint(polylineCoordinates) {
      var stride = polylineCoordinates[0].length;
      var flatCoordinates = polylineCoordinates.flat(1);
      return interpolatePoint(flatCoordinates, 0, flatCoordinates.length, stride, 0.5, void 0, stride);
  }
  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
      var o, t;
      var n = (end - offset) / stride;
      if (n === 1) {
          o = offset;
      }
      else if (n === 2) {
          o = offset;
          t = fraction;
      }
      else if (n !== 0) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          var length_1 = 0;
          var cumulativeLengths = [0];
          for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              cumulativeLengths.push(length_1);
              x1 = x2;
              y1 = y2;
          }
          var target = fraction * length_1;
          var index = binarySearch(cumulativeLengths, target);
          if (index < 0) {
              t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
              o = offset + (-index - 2) * stride;
          }
          else {
              o = offset + index * stride;
          }
      }
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var dest = opt_dest ? opt_dest : new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
          dest[i] =
              o === undefined
                  ? NaN
                  : t === undefined
                      ? flatCoordinates[o + i]
                      : lerp$1(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
      }
      return dest;
  }
  function lerp$1(a, b, x) {
      return a + x * (b - a);
  }
  function binarySearch(haystack, needle, opt_comparator) {
      var mid, cmp;
      var comparator = opt_comparator || numberSafeCompareFunction;
      var low = 0;
      var high = haystack.length;
      var found = false;
      while (low < high) {
          /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
           * to double (which gives the wrong results). */
          mid = low + ((high - low) >> 1);
          cmp = +comparator(haystack[mid], needle);
          if (cmp < 0.0) {
              /* Too low. */
              low = mid + 1;
          }
          else {
              /* Key found or too high */
              high = mid;
              found = !cmp;
          }
      }
      /* Key not found. */
      return found ? low : ~low;
  }
  function getFlatInteriorPoint(polygonCoordinates) {
      var stride = polygonCoordinates[0][0].length;
      var flatCoordinates = [];
      var ends = deflateCoordinatesArray(flatCoordinates, 0, polygonCoordinates, stride);
      var flatCenter = getCenter(getExtent(flatCoordinates, void 0, stride));
      var interiorPoint = getInteriorPointOfArray(getOrientedFlatCoordinates(flatCoordinates, ends, stride), 0, ends, stride, flatCenter, 0);
      interiorPoint.length = stride;
      if (stride === 3) {
          interiorPoint[2] = flatCoordinates[2];
      }
      return interiorPoint;
  }
  function getOrientedFlatCoordinates(flatCoordinates, ends, stride) {
      var orientedFlatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {
          orientedFlatCoordinates = flatCoordinates;
      }
      else {
          orientedFlatCoordinates = flatCoordinates.slice();
          orientedFlatCoordinates.length = orientLinearRings(orientedFlatCoordinates, 0, ends, stride);
      }
      return orientedFlatCoordinates;
  }
  function getCenter(extent) {
      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  function getExtent(flatCoordinates, extent, stride, opt_extent) {
      extent = computeExtent(flatCoordinates, extent, stride);
      if (isNaN(extent[0]) || isNaN(extent[1])) {
          createOrUpdateEmpty(extent);
      }
      return returnOrUpdate(extent, opt_extent);
  }
  function computeExtent(flatCoordinates, extent, stride) {
      return createOrUpdateFromFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, extent);
  }
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
  }
  function createOrUpdateEmpty(opt_extent) {
      return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
  }
  function returnOrUpdate(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent;
      }
  }
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = minX;
          opt_extent[1] = minY;
          opt_extent[2] = maxX;
          opt_extent[3] = maxY;
          return opt_extent;
      }
      else {
          return [minX, minY, maxX, maxY];
      }
  }
  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
      for (; offset < end; offset += stride) {
          extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
      }
      return extent;
  }
  function extendXY(extent, x, y) {
      extent[0] = Math.min(extent[0], x);
      extent[1] = Math.min(extent[1], y);
      extent[2] = Math.max(extent[2], x);
      extent[3] = Math.max(extent[3], y);
  }
  function numberSafeCompareFunction(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
  }
  function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
      var i, ii, x, x1, x2, y1, y2;
      var y = flatCenters[flatCentersOffset + 1];
      /** @type {Array<number>} */
      var intersections = [];
      // Calculate intersections with the horizontal line
      for (var r = 0, rr = ends.length; r < rr; ++r) {
          var end = ends[r];
          x1 = flatCoordinates[end - stride];
          y1 = flatCoordinates[end - stride + 1];
          for (i = offset; i < end; i += stride) {
              x2 = flatCoordinates[i];
              y2 = flatCoordinates[i + 1];
              if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                  x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                  intersections.push(x);
              }
              x1 = x2;
              y1 = y2;
          }
      }
      // Find the longest segment of the horizontal line that has its center point
      // inside the linear ring.
      var pointX = NaN;
      var maxSegmentLength = -Infinity;
      intersections.sort(numberSafeCompareFunction);
      x1 = intersections[0];
      for (i = 1, ii = intersections.length; i < ii; ++i) {
          x2 = intersections[i];
          var segmentLength = Math.abs(x2 - x1);
          if (segmentLength > maxSegmentLength) {
              x = (x1 + x2) / 2;
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                  pointX = x;
                  maxSegmentLength = segmentLength;
              }
          }
          x1 = x2;
      }
      if (isNaN(pointX)) {
          // There is no horizontal line that has its center point inside the linear
          // ring.  Use the center of the the linear ring's extent.
          pointX = flatCenters[flatCentersOffset];
      }
      if (opt_dest) {
          opt_dest.push(pointX, y, maxSegmentLength);
          return opt_dest;
      }
      else {
          return [pointX, y, maxSegmentLength];
      }
  }
  function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
      if (ends.length === 0) {
          return false;
      }
      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
          return false;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
              return false;
          }
      }
      return true;
  }
  function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
      // http://geomalgorithms.com/a03-_inclusion.html
      // Copyright 2000 softSurfer, 2012 Dan Sunday
      // This code may be freely used and modified for any purpose
      // providing that this copyright notice is included with it.
      // SoftSurfer makes no warranty for this code, and cannot be held
      // liable for any real or imagined damage resulting from its use.
      // Users of this code must verify correctness for their application.
      var wn = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          if (y1 <= y) {
              if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                  wn++;
              }
          }
          else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
              wn--;
          }
          x1 = x2;
          y1 = y2;
      }
      return wn !== 0;
  }
  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          if (i === 0) {
              if ((right && isClockwise) || (!right && !isClockwise)) {
                  return false;
              }
          }
          else {
              if ((right && !isClockwise) || (!right && isClockwise)) {
                  return false;
              }
          }
          offset = end;
      }
      return true;
  }
  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
      // http://tinyurl.com/clockwise-method
      // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
      var edge = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          edge += (x2 - x1) * (y2 + y1);
          x1 = x2;
          y1 = y2;
      }
      return edge === 0 ? undefined : edge > 0;
  }
  function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          var reverse = i === 0 ? (right && isClockwise) || (!right && !isClockwise) : (right && !isClockwise) || (!right && isClockwise);
          if (reverse) {
              reverseCoordinates(flatCoordinates, offset, end, stride);
          }
          offset = end;
      }
      return offset;
  }
  function reverseCoordinates(flatCoordinates, offset, end, stride) {
      while (offset < end - stride) {
          for (var i = 0; i < stride; ++i) {
              var tmp = flatCoordinates[offset + i];
              flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
              flatCoordinates[end - stride + i] = tmp;
          }
          offset += stride;
          end -= stride;
      }
  }

  var Polyline$1 = /** @class */ (function (_super) {
      __extends$3(Polyline, _super);
      /**
       * @param options
       * @param layer
       */
      function Polyline(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, projection = _a.projection, dataProjection = _a.dataProjection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: coordinates, properties: properties, projection: projection, dataProjection: dataProjection, offset: offset }) || this;
          _this._positionMap = new Map();
          updateTransformCoordinates$1.call(_this);
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Polyline.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "type", {
          get: function () {
              return Array.isArray(this.coordinates[0][0])
                  ? GeoJsonGeometryType.MULTI_LINE_STRING
                  : GeoJsonGeometryType.LINE_STRING;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "geoJson", {
          get: function () {
              return {
                  type: GeoJsonType.FEATURE,
                  properties: this.properties,
                  geometry: {
                      type: this.type,
                      coordinates: this.coordinates
                  }
              };
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Polyline.prototype.init = function (styles) {
          var e_1, _a;
          var featureGeometry = {
              entities: [],
              primitives: [],
              geometryInstances: [],
              labels: []
          };
          try {
              for (var _b = __values(styles.filter(function (style) {
                  return ![StyleItemType.CIRCLE, StyleItemType.ICON, StyleItemType.MODEL].includes(style.type);
              })), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var style = _c.value;
                  buildGeometry$2.call(this, style, featureGeometry);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return featureGeometry;
      };
      /**
       * 设置要素坐标
       *
       * @param coordinates 坐标
       */
      Polyline.prototype.setCoordinates = function (coordinates, options) {
          this._positionMap.clear();
          this._coordinates = coordinates;
          updateTransformCoordinates$1.call(this);
          _super.prototype.setCoordinates.call(this, coordinates, options);
          return this;
      };
      return Polyline;
  }(Feature));
  var SUPPORT_TYPE = [
      StyleItemType.POLYLINE_GLOW,
      StyleItemType.POLYLINE_ARROW,
      StyleItemType.POLYLINE_OUTLINE,
      StyleItemType.COLOR,
      StyleItemType.IMAGE,
      StyleItemType.LINEAR_FOW,
      StyleItemType.LABEL
  ];
  function buildGeometry$2(styleItem, store) {
      if (!SUPPORT_TYPE.includes(styleItem.type)) {
          console.warn(ErrorNotification.NOT_SUPPORTED_STYLE_TYPE);
      }
      if (styleItem.entity) {
          buildLineEntity.call(this, styleItem, store.entities);
      }
      else {
          buildLineInstance.call(this, styleItem, styleItem.type === StyleItemType.LABEL ? store.labels : store.geometryInstances);
      }
  }
  function updateTransformCoordinates$1() {
      var coordinates = this.coordinates;
      if (this.type === GeoJsonGeometryType.LINE_STRING) {
          coordinates = [coordinates];
      }
      this._transformedCoordinates = transformGeoJsonGeometryCoordinates(coordinates, {
          source: this.dataProjection,
          destination: this.projection,
          offset: this.offset
      });
  }
  // 构造线几何实例数组
  function buildLineInstance(styleItem, storeArray) {
      var type = this.type;
      if (/entity/gi.test(type)) {
          return [];
      }
      arraySelfConcat(storeArray, buildPolylineGeometryInstancesByMultiLineStringCoordinates({
          multiLineStringCoordinates: this._transformedCoordinates,
          styleItem: styleItem,
          positionStoreMap: this._positionMap,
          properties: this.properties
      }));
  }
  function buildLineEntity(styleItem, storeArray) {
      var _this = this;
      arraySelfConcat(storeArray, styleItem.type === StyleItemType.LABEL
          ? buildLabelGraphicsByMultiLineStringCoordinates({
              multiLineStringCoordinates: this._transformedCoordinates,
              styleItem: styleItem,
              positionStoreMap: this._positionMap,
              properties: this.properties
          }).map(function (labelGraphics, index) {
              var pointCoordinate = getFlatMidpoint(_this._transformedCoordinates[index]);
              var entity = new Cesium__namespace.Entity(__assign$1({ id: getUid(), position: new Cesium__namespace.ConstantPositionProperty(degreesToCartesian3(pointCoordinate)), label: labelGraphics }, styleItem));
              entity[STYLE_LINK] = styleItem;
              return entity;
          })
          : buildPolylineGraphicsByMultiLineStringCoordinates({
              multiLineStringCoordinates: this._transformedCoordinates,
              styleItem: styleItem,
              positionStoreMap: this._positionMap
          }).map(function (polylineGraphics, index) {
              var entity = new Cesium__namespace.Entity(__assign$1({ id: getUid(), polyline: polylineGraphics }, styleItem));
              entity[STYLE_LINK] = styleItem;
              entity[COORDINATES_INDEX] = index;
              return entity;
          }));
  }
  function buildPolylineGeometryInstancesByMultiLineStringCoordinates(_a) {
      var _this = this;
      var multiLineStringCoordinates = _a.multiLineStringCoordinates, styleItem = _a.styleItem, positionStoreMap = _a.positionStoreMap, height = _a.height, properties = _a.properties;
      return multiLineStringCoordinates.map(function (coordinate, index) {
          if (styleItem.type === StyleItemType.LABEL) {
              var pointCoordinate = getFlatMidpoint(coordinate);
              return buildLabelOptions.call(_this, {
                  coordinate: pointCoordinate,
                  styleItem: styleItem,
                  properties: properties
              });
          }
          else {
              var positions = positionStoreMap === null || positionStoreMap === void 0 ? void 0 : positionStoreMap.get(index);
              if (defined$1(height)) {
                  coordinate.forEach(function (element) { return (element[2] = height); });
                  positions = LineStringCoordinatesToCartesian3Array(coordinate);
              }
              else if (!defined$1(positions)) {
                  positions = LineStringCoordinatesToCartesian3Array(coordinate);
                  positionStoreMap === null || positionStoreMap === void 0 ? void 0 : positionStoreMap.set(index, positions);
              }
              var line = new Cesium__namespace.GeometryInstance(__assign$1(__assign$1({ geometry: new Cesium__namespace[styleItem.heightReference === 1 /* CLAMP_TO_GROUND */
                      ? "GroundPolylineGeometry"
                      : "PolylineGeometry"](__assign$1({ positions: positions }, styleItem)) }, (styleItem.type === StyleItemType.COLOR
                  ? {
                      attributes: {
                          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(styleItem.borderColor)
                      }
                  }
                  : {})), styleItem));
              line[geometryInstanceUniqueKeyName] = getUid();
              line[STYLE_LINK] = defined$1(styleItem.lineDash)
                  ? __assign$1(__assign$1({}, styleItem), { color: styleItem.borderColor, dashLength: styleItem.lineDash[0] * 2, type: "polylineDash" }) : styleItem;
              line[COORDINATES_INDEX] = index;
              return line;
          }
      });
  }
  function buildLabelGraphicsByMultiLineStringCoordinates(_a) {
      var multiLineStringCoordinates = _a.multiLineStringCoordinates, styleItem = _a.styleItem; _a.positionStoreMap; _a.height; var properties = _a.properties;
      return multiLineStringCoordinates.map(function () {
          return buildLabelGraphics({
              styleItem: styleItem,
              properties: properties
          });
      });
  }
  function buildPolylineGraphicsByMultiLineStringCoordinates(_a) {
      var multiLineStringCoordinates = _a.multiLineStringCoordinates, styleItem = _a.styleItem, positionStoreMap = _a.positionStoreMap, height = _a.height;
      var material = styleItemToMaterialProperty(styleItem, {
          isLine: true
      });
      return multiLineStringCoordinates.map(function (coordinate, index) {
          var positions = positionStoreMap === null || positionStoreMap === void 0 ? void 0 : positionStoreMap.get(index);
          if (defined$1(height)) {
              coordinate.forEach(function (element) { return (element[2] = height); });
              positions = LineStringCoordinatesToCartesian3Array(coordinate);
          }
          else if (!defined$1(positions)) {
              positions = LineStringCoordinatesToCartesian3Array(coordinate);
              positionStoreMap === null || positionStoreMap === void 0 ? void 0 : positionStoreMap.set(index, positions);
          }
          return new Cesium__namespace.PolylineGraphics(__assign$1({ positions: positions, material: material }, styleItem));
      });
  }

  var Polygon$1 = /** @class */ (function (_super) {
      __extends$3(Polygon, _super);
      /**
       * @param options
       * @param layer
       */
      function Polygon(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: coordinates, properties: properties, projection: projection, dataProjection: dataProjection, offset: offset }) || this;
          _this._positionMap = new Map();
          updateTransformCoordinates.call(_this);
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Polygon.prototype, "coordinates", {
          /**
           * 要素坐标
           */
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "geoJson", {
          get: function () {
              return {
                  type: GeoJsonType.FEATURE,
                  properties: this.properties,
                  geometry: {
                      type: this.type,
                      coordinates: this.coordinates
                  }
              };
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "type", {
          get: function () {
              return Array.isArray(this.coordinates[0][0][0]) ? GeoJsonGeometryType.MULTI_POLYGON : GeoJsonGeometryType.POLYGON;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Polygon.prototype.init = function (styles) {
          var e_1, _a;
          var featureGeometry = {
              entities: [],
              primitives: [],
              geometryInstances: [],
              labels: []
          };
          try {
              for (var _b = __values(styles.filter(function (style) {
                  return ![StyleItemType.CIRCLE, StyleItemType.ICON, StyleItemType.MODEL].includes(style.type);
              })), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var style = _c.value;
                  buildGeometry$1.call(this, style, featureGeometry);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return featureGeometry;
      };
      /**
       * 设置要素坐标
       *
       * @param coordinates
       */
      Polygon.prototype.setCoordinates = function (coordinates, options) {
          this._positionMap.clear();
          this._coordinates = coordinates;
          updateTransformCoordinates.call(this);
          _super.prototype.setCoordinates.call(this, coordinates, options);
          return this;
      };
      return Polygon;
  }(Feature));
  function buildGeometry$1(style, store) {
      if (style.entity) {
          buildPolygonEntity.call(this, style, store.entities);
      }
      else {
          buildPolygonInstance.call(this, style, style.type === StyleItemType.LABEL ? store.labels : store.geometryInstances);
      }
  }
  function updateTransformCoordinates() {
      var coordinates = this.coordinates;
      if (this.type === GeoJsonGeometryType.POLYGON) {
          coordinates = [coordinates];
      }
      this._transformedCoordinates = transformGeoJsonGeometryCoordinates(coordinates, {
          source: this.dataProjection,
          destination: this.projection,
          offset: this.offset
      });
  }
  function buildPolygonInstance(styleItem, storeArray) {
      var res = [];
      for (var index = 0; index < this._transformedCoordinates.length; index++) {
          var coordinate = this._transformedCoordinates[index];
          if (styleItem.type === StyleItemType.LABEL) {
              var pointCoordinate = getFlatInteriorPoint(coordinate);
              var height = this.styleItemList.reduce(function (prev, curr) {
                  if (defined$1(curr.extrudedHeight)) {
                      if (!defined$1(prev) || prev < curr.extrudedHeight) {
                          prev = curr.extrudedHeight;
                      }
                  }
                  return prev;
              }, void 0);
              if (defined$1(height)) {
                  pointCoordinate[2] = height;
              }
              defined$1(styleItem.extrudedHeight) && (pointCoordinate[2] = styleItem.extrudedHeight);
              res.push(buildLabelOptions.call(this, {
                  coordinate: pointCoordinate,
                  styleItem: styleItem,
                  properties: this.properties
              }));
          }
          else {
              var polygonHierarchy = polygonCoordinatesPolygonHierarchy(coordinate);
              var polygon = new Cesium__namespace.GeometryInstance(__assign$1(__assign$1({ geometry: new Cesium__namespace.PolygonGeometry(__assign$1({ polygonHierarchy: polygonHierarchy }, styleItem)) }, (styleItem.type === StyleItemType.COLOR
                  ? {
                      attributes: {
                          color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(styleItem.fillColor)
                      }
                  }
                  : {})), styleItem));
              polygon[geometryInstanceUniqueKeyName] = getUid();
              polygon[STYLE_LINK] = __assign$1({ flat: true }, styleItem);
              polygon[COORDINATES_INDEX] = index;
              res.push(polygon);
              if (styleItem.width > 0 &&
                  (StyleItemType.COLOR === styleItem.type || StyleItemType.RADIAL_GRADIENT === styleItem.type)) {
                  arraySelfConcat(res, buildPolylineGeometryInstancesByMultiLineStringCoordinates({
                      multiLineStringCoordinates: coordinate,
                      styleItem: __assign$1(__assign$1({}, styleItem), { type: StyleItemType.COLOR }),
                      height: styleItem.extrudedHeight || styleItem.height,
                      properties: this.properties
                  }));
              }
          }
      }
      arraySelfConcat(storeArray, res);
  }
  var SUPPORT_TYPE_ENTITY$1 = [
      StyleItemType.COLOR,
      StyleItemType.IMAGE,
      StyleItemType.WATER,
      StyleItemType.LINEAR_FOW,
      StyleItemType.RADIAL_GRADIENT,
      StyleItemType.LABEL
  ];
  function buildPolygonEntity(styleItem, entities) {
      if (!SUPPORT_TYPE_ENTITY$1.includes(styleItem.type)) {
          console.warn(ErrorNotification.NOT_SUPPORTED_STYLE_TYPE);
          return [];
      }
      var res = [];
      var material = styleItemToMaterialProperty(styleItem);
      var polylineArray = [];
      var _loop_1 = function (index) {
          var e_2, _a;
          var coordinate = this_1._transformedCoordinates[index];
          if (styleItem.type === StyleItemType.LABEL) {
              var labelGraphics = buildLabelGraphics({ styleItem: styleItem, properties: this_1.properties });
              var over = false;
              var height = this_1.styleItemList.reduce(function (prev, curr) {
                  if (defined$1(curr.extrudedHeight)) {
                      if (!defined$1(prev) || prev < curr.extrudedHeight) {
                          prev = curr.extrudedHeight;
                      }
                  }
                  return prev;
              }, void 0);
              var pointCoordinate = getFlatInteriorPoint(coordinate);
              if (defined$1(height)) {
                  pointCoordinate[2] = height;
              }
              defined$1(styleItem.extrudedHeight) && (pointCoordinate[2] = styleItem.extrudedHeight);
              var position = new Cesium__namespace.ConstantPositionProperty(degreesToCartesian3(pointCoordinate));
              try {
                  for (var entities_1 = (e_2 = void 0, __values(entities)), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                      var entity = entities_1_1.value;
                      if (defined$1(entity.label)) {
                          entity.label = labelGraphics;
                          entity.position = position;
                          over = true;
                          break;
                      }
                      if (!over) {
                          res.push(new Cesium__namespace.Entity(__assign$1({ id: getUid(), position: position, label: labelGraphics }, styleItem)));
                      }
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
          else {
              var polygonHierarchy = polygonCoordinatesPolygonHierarchy(coordinate);
              var polyline_1;
              if (styleItem.width > 0 &&
                  (StyleItemType.COLOR === styleItem.type || StyleItemType.RADIAL_GRADIENT === styleItem.type)) {
                  buildPolylineGraphicsByMultiLineStringCoordinates({
                      multiLineStringCoordinates: coordinate,
                      styleItem: __assign$1(__assign$1({}, styleItem), { type: StyleItemType.COLOR }),
                      height: styleItem.extrudedHeight || styleItem.height
                  }).forEach(function (polylineGraphic, index) {
                      if (index === 0) {
                          polyline_1 = polylineGraphic;
                      }
                      else {
                          polylineArray.push(new Cesium__namespace.Entity({
                              polyline: polylineGraphic
                          }));
                      }
                  });
              }
              var polygon = new Cesium__namespace.Entity(__assign$1({ id: getUid(), polygon: new Cesium__namespace.PolygonGraphics(__assign$1({ hierarchy: polygonHierarchy, 
                      // height: 0,
                      material: material, outline: false }, styleItem)), polyline: polyline_1 }, styleItem));
              polygon[STYLE_LINK] = styleItem;
              polygon[COORDINATES_INDEX] = index;
              res.push(polygon);
          }
      };
      var this_1 = this;
      for (var index = 0; index < this._transformedCoordinates.length; index++) {
          _loop_1(index);
      }
      polylineArray.length > 0 && arraySelfConcat(entities, polylineArray);
      arraySelfConcat(entities, res);
  }
  function polygonCoordinatesPolygonHierarchy(polygonCoordinates, index) {
      if (index === void 0) { index = void 0; }
      index === void 0 && (index = 0);
      return new Cesium__namespace.PolygonHierarchy(polygonCoordinates[index].map(function (coordinate) {
          var _a;
          return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
      }), index === polygonCoordinates.length - 1 ? [] : [polygonCoordinatesPolygonHierarchy(polygonCoordinates, index + 1)]);
  }

  /**
   * 将geoJson对象转换为要素数组
   *
   * @param geoJson geoJson数据
   * @returns
   */
  function read$1(geoJson, options) {
      return geoJsonToFeature(geoJson, { Point: Point$1, Polygon: Polygon$1, Polyline: Polyline$1 }, options);
  }
  /**
   * 将Feature对象数组转为geoJson集合对象
   *
   * @param {Feature[]} features 要素数组
   * @returns {FeatureCollectionGeoJSON}
   */
  function write$1(features, options) {
      return featuresToGeoJsonFeatureCollection(features, options);
  }

  var GeoJson = /*#__PURE__*/Object.freeze({
    __proto__: null,
    read: read$1,
    write: write$1,
    get GeoJsonGeometryType () { return GeoJsonGeometryType; },
    get GeoJsonType () { return GeoJsonType; },
    create: dataToGeoJsonFeatureCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon$1,
    multiPolygon: multiPolygon,
    feature: feature$3,
    featureCollection: featureCollection
  });

  function sortKD(ids, coords, nodeSize, left, right, depth) {
      if (right - left <= nodeSize) return;

      const m = (left + right) >> 1;

      select(ids, coords, m, left, right, depth % 2);

      sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
      sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
  }

  function select(ids, coords, k, left, right, inc) {

      while (right > left) {
          if (right - left > 600) {
              const n = right - left + 1;
              const m = k - left + 1;
              const z = Math.log(n);
              const s = 0.5 * Math.exp(2 * z / 3);
              const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              select(ids, coords, k, newLeft, newRight, inc);
          }

          const t = coords[2 * k + inc];
          let i = left;
          let j = right;

          swapItem(ids, coords, left, k);
          if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

          while (i < j) {
              swapItem(ids, coords, i, j);
              i++;
              j--;
              while (coords[2 * i + inc] < t) i++;
              while (coords[2 * j + inc] > t) j--;
          }

          if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
          else {
              j++;
              swapItem(ids, coords, j, right);
          }

          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
      }
  }

  function swapItem(ids, coords, i, j) {
      swap(ids, i, j);
      swap(coords, 2 * i, 2 * j);
      swap(coords, 2 * i + 1, 2 * j + 1);
  }

  function swap(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function range$1(ids, coords, minX, minY, maxX, maxY, nodeSize) {
      const stack = [0, ids.length - 1, 0];
      const result = [];
      let x, y;

      while (stack.length) {
          const axis = stack.pop();
          const right = stack.pop();
          const left = stack.pop();

          if (right - left <= nodeSize) {
              for (let i = left; i <= right; i++) {
                  x = coords[2 * i];
                  y = coords[2 * i + 1];
                  if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
              }
              continue;
          }

          const m = Math.floor((left + right) / 2);

          x = coords[2 * m];
          y = coords[2 * m + 1];

          if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

          const nextAxis = (axis + 1) % 2;

          if (axis === 0 ? minX <= x : minY <= y) {
              stack.push(left);
              stack.push(m - 1);
              stack.push(nextAxis);
          }
          if (axis === 0 ? maxX >= x : maxY >= y) {
              stack.push(m + 1);
              stack.push(right);
              stack.push(nextAxis);
          }
      }

      return result;
  }

  function within(ids, coords, qx, qy, r, nodeSize) {
      const stack = [0, ids.length - 1, 0];
      const result = [];
      const r2 = r * r;

      while (stack.length) {
          const axis = stack.pop();
          const right = stack.pop();
          const left = stack.pop();

          if (right - left <= nodeSize) {
              for (let i = left; i <= right; i++) {
                  if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
              }
              continue;
          }

          const m = Math.floor((left + right) / 2);

          const x = coords[2 * m];
          const y = coords[2 * m + 1];

          if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

          const nextAxis = (axis + 1) % 2;

          if (axis === 0 ? qx - r <= x : qy - r <= y) {
              stack.push(left);
              stack.push(m - 1);
              stack.push(nextAxis);
          }
          if (axis === 0 ? qx + r >= x : qy + r >= y) {
              stack.push(m + 1);
              stack.push(right);
              stack.push(nextAxis);
          }
      }

      return result;
  }

  function sqDist(ax, ay, bx, by) {
      const dx = ax - bx;
      const dy = ay - by;
      return dx * dx + dy * dy;
  }

  const defaultGetX = p => p[0];
  const defaultGetY = p => p[1];

  class KDBush {
      constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {
          this.nodeSize = nodeSize;
          this.points = points;

          const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;

          const ids = this.ids = new IndexArrayType(points.length);
          const coords = this.coords = new ArrayType(points.length * 2);

          for (let i = 0; i < points.length; i++) {
              ids[i] = i;
              coords[2 * i] = getX(points[i]);
              coords[2 * i + 1] = getY(points[i]);
          }

          sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
      }

      range(minX, minY, maxX, maxY) {
          return range$1(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
      }

      within(x, y, r) {
          return within(this.ids, this.coords, x, y, r, this.nodeSize);
      }
  }

  const defaultOptions$1 = {
      minZoom: 0,   // min zoom to generate clusters on
      maxZoom: 16,  // max zoom level to cluster the points on
      minPoints: 2, // minimum points to form a cluster
      radius: 40,   // cluster radius in pixels
      extent: 512,  // tile extent (radius is calculated relative to it)
      nodeSize: 64, // size of the KD-tree leaf node, affects performance
      log: false,   // whether to log timing info

      // whether to generate numeric ids for input features (in vector tiles)
      generateId: false,

      // a reduce function for calculating custom cluster properties
      reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }

      // properties to use for individual points when running the reducer
      map: props => props // props => ({sum: props.my_value})
  };

  const fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));

  class Supercluster {
      constructor(options) {
          this.options = extend(Object.create(defaultOptions$1), options);
          this.trees = new Array(this.options.maxZoom + 1);
      }

      load(points) {
          const {log, minZoom, maxZoom, nodeSize} = this.options;

          if (log) console.time('total time');

          const timerId = `prepare ${  points.length  } points`;
          if (log) console.time(timerId);

          this.points = points;

          // generate a cluster object for each point and index input points into a KD-tree
          let clusters = [];
          for (let i = 0; i < points.length; i++) {
              if (!points[i].geometry) continue;
              clusters.push(createPointCluster(points[i], i));
          }
          this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

          if (log) console.timeEnd(timerId);

          // cluster points on max zoom, then cluster the results on previous zoom, etc.;
          // results in a cluster hierarchy across zoom levels
          for (let z = maxZoom; z >= minZoom; z--) {
              const now = +Date.now();

              // create a new set of clusters for the zoom and index them with a KD-tree
              clusters = this._cluster(clusters, z);
              this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

              if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
          }

          if (log) console.timeEnd('total time');

          return this;
      }

      getClusters(bbox, zoom) {
          let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
          const minLat = Math.max(-90, Math.min(90, bbox[1]));
          let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
          const maxLat = Math.max(-90, Math.min(90, bbox[3]));

          if (bbox[2] - bbox[0] >= 360) {
              minLng = -180;
              maxLng = 180;
          } else if (minLng > maxLng) {
              const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
              const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
              return easternHem.concat(westernHem);
          }

          const tree = this.trees[this._limitZoom(zoom)];
          const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
          const clusters = [];
          for (const id of ids) {
              const c = tree.points[id];
              clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
          }
          return clusters;
      }

      getChildren(clusterId) {
          const originId = this._getOriginId(clusterId);
          const originZoom = this._getOriginZoom(clusterId);
          const errorMsg = 'No cluster with the specified id.';

          const index = this.trees[originZoom];
          if (!index) throw new Error(errorMsg);

          const origin = index.points[originId];
          if (!origin) throw new Error(errorMsg);

          const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
          const ids = index.within(origin.x, origin.y, r);
          const children = [];
          for (const id of ids) {
              const c = index.points[id];
              if (c.parentId === clusterId) {
                  children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
              }
          }

          if (children.length === 0) throw new Error(errorMsg);

          return children;
      }

      getLeaves(clusterId, limit, offset) {
          limit = limit || 10;
          offset = offset || 0;

          const leaves = [];
          this._appendLeaves(leaves, clusterId, limit, offset, 0);

          return leaves;
      }

      getTile(z, x, y) {
          const tree = this.trees[this._limitZoom(z)];
          const z2 = Math.pow(2, z);
          const {extent, radius} = this.options;
          const p = radius / extent;
          const top = (y - p) / z2;
          const bottom = (y + 1 + p) / z2;

          const tile = {
              features: []
          };

          this._addTileFeatures(
              tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
              tree.points, x, y, z2, tile);

          if (x === 0) {
              this._addTileFeatures(
                  tree.range(1 - p / z2, top, 1, bottom),
                  tree.points, z2, y, z2, tile);
          }
          if (x === z2 - 1) {
              this._addTileFeatures(
                  tree.range(0, top, p / z2, bottom),
                  tree.points, -1, y, z2, tile);
          }

          return tile.features.length ? tile : null;
      }

      getClusterExpansionZoom(clusterId) {
          let expansionZoom = this._getOriginZoom(clusterId) - 1;
          while (expansionZoom <= this.options.maxZoom) {
              const children = this.getChildren(clusterId);
              expansionZoom++;
              if (children.length !== 1) break;
              clusterId = children[0].properties.cluster_id;
          }
          return expansionZoom;
      }

      _appendLeaves(result, clusterId, limit, offset, skipped) {
          const children = this.getChildren(clusterId);

          for (const child of children) {
              const props = child.properties;

              if (props && props.cluster) {
                  if (skipped + props.point_count <= offset) {
                      // skip the whole cluster
                      skipped += props.point_count;
                  } else {
                      // enter the cluster
                      skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
                      // exit the cluster
                  }
              } else if (skipped < offset) {
                  // skip a single point
                  skipped++;
              } else {
                  // add a single point
                  result.push(child);
              }
              if (result.length === limit) break;
          }

          return skipped;
      }

      _addTileFeatures(ids, points, x, y, z2, tile) {
          for (const i of ids) {
              const c = points[i];
              const isCluster = c.numPoints;

              let tags, px, py;
              if (isCluster) {
                  tags = getClusterProperties(c);
                  px = c.x;
                  py = c.y;
              } else {
                  const p = this.points[c.index];
                  tags = p.properties;
                  px = lngX(p.geometry.coordinates[0]);
                  py = latY(p.geometry.coordinates[1]);
              }

              const f = {
                  type: 1,
                  geometry: [[
                      Math.round(this.options.extent * (px * z2 - x)),
                      Math.round(this.options.extent * (py * z2 - y))
                  ]],
                  tags
              };

              // assign id
              let id;
              if (isCluster) {
                  id = c.id;
              } else if (this.options.generateId) {
                  // optionally generate id
                  id = c.index;
              } else if (this.points[c.index].id) {
                  // keep id if already assigned
                  id = this.points[c.index].id;
              }

              if (id !== undefined) f.id = id;

              tile.features.push(f);
          }
      }

      _limitZoom(z) {
          return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));
      }

      _cluster(points, zoom) {
          const clusters = [];
          const {radius, extent, reduce, minPoints} = this.options;
          const r = radius / (extent * Math.pow(2, zoom));

          // loop through each point
          for (let i = 0; i < points.length; i++) {
              const p = points[i];
              // if we've already visited the point at this zoom level, skip it
              if (p.zoom <= zoom) continue;
              p.zoom = zoom;

              // find all nearby points
              const tree = this.trees[zoom + 1];
              const neighborIds = tree.within(p.x, p.y, r);

              const numPointsOrigin = p.numPoints || 1;
              let numPoints = numPointsOrigin;

              // count the number of points in a potential cluster
              for (const neighborId of neighborIds) {
                  const b = tree.points[neighborId];
                  // filter out neighbors that are already processed
                  if (b.zoom > zoom) numPoints += b.numPoints || 1;
              }

              // if there were neighbors to merge, and there are enough points to form a cluster
              if (numPoints > numPointsOrigin && numPoints >= minPoints) {
                  let wx = p.x * numPointsOrigin;
                  let wy = p.y * numPointsOrigin;

                  let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;

                  // encode both zoom and point index on which the cluster originated -- offset by total length of features
                  const id = (i << 5) + (zoom + 1) + this.points.length;

                  for (const neighborId of neighborIds) {
                      const b = tree.points[neighborId];

                      if (b.zoom <= zoom) continue;
                      b.zoom = zoom; // save the zoom (so it doesn't get processed twice)

                      const numPoints2 = b.numPoints || 1;
                      wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center
                      wy += b.y * numPoints2;

                      b.parentId = id;

                      if (reduce) {
                          if (!clusterProperties) clusterProperties = this._map(p, true);
                          reduce(clusterProperties, this._map(b));
                      }
                  }

                  p.parentId = id;
                  clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));

              } else { // left points as unclustered
                  clusters.push(p);

                  if (numPoints > 1) {
                      for (const neighborId of neighborIds) {
                          const b = tree.points[neighborId];
                          if (b.zoom <= zoom) continue;
                          b.zoom = zoom;
                          clusters.push(b);
                      }
                  }
              }
          }

          return clusters;
      }

      // get index of the point from which the cluster originated
      _getOriginId(clusterId) {
          return (clusterId - this.points.length) >> 5;
      }

      // get zoom of the point from which the cluster originated
      _getOriginZoom(clusterId) {
          return (clusterId - this.points.length) % 32;
      }

      _map(point, clone) {
          if (point.numPoints) {
              return clone ? extend({}, point.properties) : point.properties;
          }
          const original = this.points[point.index].properties;
          const result = this.options.map(original);
          return clone && result === original ? extend({}, result) : result;
      }
  }

  function createCluster(x, y, id, numPoints, properties) {
      return {
          x: fround(x), // weighted cluster center; round for consistency with Float32Array index
          y: fround(y),
          zoom: Infinity, // the last zoom the cluster was processed at
          id, // encodes index of the first child of the cluster and its zoom level
          parentId: -1, // parent cluster id
          numPoints,
          properties
      };
  }

  function createPointCluster(p, id) {
      const [x, y] = p.geometry.coordinates;
      return {
          x: fround(lngX(x)), // projected point coordinates
          y: fround(latY(y)),
          zoom: Infinity, // the last zoom the point was processed at
          index: id, // index of the source feature in the original input array,
          parentId: -1 // parent cluster id
      };
  }

  function getClusterJSON(cluster) {
      return {
          type: 'Feature',
          id: cluster.id,
          properties: getClusterProperties(cluster),
          geometry: {
              type: 'Point',
              coordinates: [xLng(cluster.x), yLat(cluster.y)]
          }
      };
  }

  function getClusterProperties(cluster) {
      const count = cluster.numPoints;
      const abbrev =
          count >= 10000 ? `${Math.round(count / 1000)  }k` :
          count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;
      return extend(extend({}, cluster.properties), {
          cluster: true,
          cluster_id: cluster.id,
          point_count: count,
          point_count_abbreviated: abbrev
      });
  }

  // longitude/latitude to spherical mercator in [0..1] range
  function lngX(lng) {
      return lng / 360 + 0.5;
  }
  function latY(lat) {
      const sin = Math.sin(lat * Math.PI / 180);
      const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
      return y < 0 ? 0 : y > 1 ? 1 : y;
  }

  // spherical mercator to longitude/latitude
  function xLng(x) {
      return (x - 0.5) * 360;
  }
  function yLat(y) {
      const y2 = (180 - y * 360) * Math.PI / 180;
      return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
  }

  function extend(dest, src) {
      for (const id in src) dest[id] = src[id];
      return dest;
  }

  function getX(p) {
      return p.x;
  }
  function getY(p) {
      return p.y;
  }

  /**
   * 聚合数据源
   */
  var ClusterSource = /** @class */ (function (_super) {
      __extends$3(ClusterSource, _super);
      function ClusterSource(options) {
          var _this = this;
          options = options || {};
          _this = _super.call(this, options) || this;
          _this._clusterData = [];
          _this._geoJson = [];
          if (options.data && Array.isArray(options.data) && options.data.length && options.data[0] instanceof Point$1) {
              _this._geoJson = write$1(options.data).features;
          }
          if (options.data && Array.isArray(options.data) && options.data.length && typeof options.data[0] === "string") {
              _this._geoJson = options.data.map(function (wkt) {
                  return wktToGeoJsonFeature(wkt);
              });
          }
          if (options.data && typeof options.data === "object") {
              _this._geoJson = options.data.features;
          }
          if (options.data && Array.isArray(options.data) && options.data.length && typeof options.data[0] === "object") {
              _this._geoJson = dataToGeoJsonFeatureCollection(options.data).features;
          }
          _this._distance = Cesium__namespace.defaultValue(options.distance, 200);
          var _maxZoom = Cesium__namespace.defaultValue(options.expandZoom, 19);
          _this._superCluster = new Supercluster({
              radius: _this._distance,
              maxZoom: _maxZoom
          });
          _this._superCluster.load(_this._geoJson);
          return _this;
      }
      Object.defineProperty(ClusterSource.prototype, "radius", {
          get: function () {
              return this._distance;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ClusterSource.prototype, "animation", {
          get: function () {
              return this._animation;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      ClusterSource.prototype.init = function () {
          var _this = this;
          this._postRenderEventListener = this.map.map.scene.postRender.addEventListener(function () {
              _this._clusterFeatures();
          }, this);
      };
      /**
       * @ignore
       */
      ClusterSource.prototype.addTo = function (map) {
          this.map = map;
          this._postRenderEventListener || this.init();
      };
      /**
       * @ignore
       */
      ClusterSource.prototype.remove = function () {
          if (!this.map) {
              return;
          }
          if (this._postRenderEventListener) {
              this._postRenderEventListener();
              this._postRenderEventListener = undefined;
          }
          this.map = undefined;
      };
      /**
       * 显示聚合或者显示单要素
       * @ignore
       */
      ClusterSource.prototype._clusterFeatures = function () {
          var _this = this;
          var height = getHeight(this.map);
          var zoom = this._altitudeToZoom(height);
          // 判断zoom缩放级别为非数字的情况，当height为小于零的数字时，可能会出现缩放级别为非数字的情况
          if (Number.isNaN(zoom)) {
              return;
          }
          // 非首次渲染时
          if (Cesium__namespace.defined(this._level)) {
              if (this._level === zoom) {
                  this._animation = false;
                  // 是否聚合动画
              }
              else {
                  this.dispatchEvent({ type: "postrender" });
                  this._level = zoom;
                  this._animation = true;
              }
              // 首次渲染缩放级别未定义
          }
          else {
              this._level = zoom;
          }
          // 三维场景----聚合的运算
          if (this.map.map.scene.mode === 3 /* SCENE3D */) {
              var rectangle = this.map.map.camera.computeViewRectangle();
              if (!rectangle || (Cesium__namespace.defined(this._rectangle) && this._rectangle.equals(rectangle))) {
                  return;
              }
              this._rectangle = rectangle;
              this._clusterData = [];
              if (!Cesium__namespace.defined(rectangle.west) ||
                  !Cesium__namespace.defined(rectangle.south) ||
                  !Cesium__namespace.defined(rectangle.east) ||
                  !Cesium__namespace.defined(rectangle.north)) {
                  return;
              }
              this._extent = [
                  Cesium__namespace.Math.toDegrees(rectangle.west),
                  Cesium__namespace.Math.toDegrees(rectangle.south),
                  Cesium__namespace.Math.toDegrees(rectangle.east),
                  Cesium__namespace.Math.toDegrees(rectangle.north)
              ];
          }
          else {
              // 二维场景逻辑
              var extent = getCurrentExtent(this.map);
              // 范围未定义返回
              if (!Cesium__namespace.defined(extent)) {
                  return;
              }
              if (defined$1(this._extent) &&
                  this._extent[0] === extent[0] &&
                  this._extent[1] === extent[1] &&
                  this._extent[2] === extent[2] &&
                  this._extent[3] === extent[3]) {
                  return;
              }
              this._extent = extent;
          }
          try {
              this._clusterData = this._superCluster.getClusters(this._extent, Number(parseInt(zoom + "")));
              var features_ = this._clusterData.map(function (_data) {
                  var properties = __assign$1({}, _data.properties);
                  delete properties.id;
                  var _feature = new Point$1({
                      coordinates: _data.geometry.coordinates,
                      properties: __assign$1({}, properties)
                  });
                  var cluster = _feature.get("cluster");
                  if (cluster) {
                      var cluster_id = _feature.get("cluster_id");
                      var features = _this._superCluster.getLeaves(cluster_id, Infinity);
                      _feature.set("features", features);
                  }
                  return _feature;
              });
              this.dispatchEvent({ type: "getfeatures", features: features_, clusterData: this._clusterData });
          }
          catch (e) {
              console.warn("e", e);
              throw new Error("异常处理");
          }
      };
      /**
       * 添加聚合数据
       * @param {geoJson} geoJson 聚合数据
       */
      ClusterSource.prototype.addFeatures = function (geoJson) {
          var _a;
          this._rectangle = undefined;
          (_a = this._geoJson).push.apply(_a, __spreadArray$1([], __read(geoJson.features), false));
          this._superCluster.load(this._geoJson);
          this._clusterFeatures();
      };
      ClusterSource.prototype.updateFeatures = function (geoJson) {
          this._rectangle = undefined;
          this._geoJson = geoJson.features;
          this._superCluster.load(this._geoJson);
          this._clusterFeatures();
      };
      /**
       * @ignore
       */
      ClusterSource.prototype._altitudeToZoom = function (altitude) {
          var A = 40487.57;
          var B = 0.00007096758;
          var C = 91610.74;
          var D = -40467.74;
          return D + (A - D) / (1 + Math.pow(altitude / C, B));
      };
      return ClusterSource;
  }(BaseObject));

  /**
   * 将业务数据数组转为Feature对象数组
   *
   * **业务数据格式**
   *
   * ```
   * { x: number; y: number; z?: number; [propName: string]: any }[]
   * | { lng: number; lat: number; height?: number; [propName: string]: any }[]
   * | { lon: number; lat: number; height?: number; [propName: string]: any }[]
   * | {
   *     longitude: number;
   *     latitude: number;
   *     height?: number;
   *     [propName: string]: any;
   *   }[]
   * | { wkt: string; [propName: string]: any }[];
   * ```
   *
   * @param {Array<object>} data 业务数据对象数组
   * @param {string} offset 偏移类型 可选值：'WGStoGCJ', 'GCJtoWGS','GCJtoBD','BDtoGCJ','WGStoBD','BDtoWGS'
   * @returns {Array<Feature>}
   *
   */
  function create$4(data, options) {
      return dataToFeatures(data, options);
  }
  function dataToFeatures(data, options) {
      return vectorDataToFeatures(data, { Feature: Feature, Point: Point$1, Polyline: Polyline$1, Polygon: Polygon$1 }, options);
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter$7(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function defined(value) {
      return value !== void 0 && value !== null;
  }
  class BaseJob {
      constructor(options = {}) {
          this._freeze = false;
          this._queue = [];
          this._id = options.id || performance.now() + "";
          if (options.tasks) {
              for (const task of options.tasks) {
                  this.add(task);
              }
          }
      }
      get id() {
          return this._id;
      }
      get freeze() {
          return this._freeze;
      }
      set freeze(value) {
          this._freeze = value;
      }
      get queue() {
          return this._queue;
      }
      add(task) {
          if (!this._freeze) {
              this._queue.push(task);
          }
          else {
              console.warn("工作已冻结,不可再添加");
          }
          return this;
      }
      run(previousTaskResult) {
          return __awaiter$7(this, void 0, void 0, function* () {
              this.job.freeze = true;
              for (const task of this.job.queue) {
                  previousTaskResult = yield task.run.call({ jobScheduler: this.jobScheduler, job: this.job, task }, previousTaskResult);
              }
              return previousTaskResult;
          });
      }
  }
  class JobScheduler {
      constructor() {
          this._id = performance.now() + "";
          this._schedulerStore = new Map();
          this._jobQueue = [];
          this._paused = false;
          this._pauseKeyStore = new Set();
      }
      get id() {
          return this._id;
      }
      get paused() {
          return this._paused;
      }
      get activeJob() {
          return this._activeJob;
      }
      _run(previousTaskResult) {
          this._activeJob = this._jobQueue[0];
          if (this._activeJob && !this._paused) {
              this._activeJob.run
                  .call({ jobScheduler: this, job: this._activeJob }, previousTaskResult)
                  .then((taskResult) => {
                  this._jobQueue = this._jobQueue.slice(1);
                  this._activeJob = void 0;
                  this._run(taskResult);
              });
          }
      }
      /**
       * 添加工作
       *
       * 如果传入调度器id则将工作添加到该id对应的调度器,调度器并行执行,工作串行执行
       */
      add(job, schedulerId) {
          if (defined(schedulerId)) {
              this._schedulerStore.has(schedulerId) ||
                  this._schedulerStore.set(schedulerId, new JobScheduler());
              this._schedulerStore.get(schedulerId).add(job);
          }
          else {
              this._jobQueue.push(job);
              this._jobQueue.length === 1 && this._run();
          }
          return this;
      }
      /**
       * 移除工作
       */
      remove(jobId, schedulerId) {
          var _a, _b;
          if (defined(schedulerId)) {
              return ((_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.remove(jobId)) || false;
          }
          else if (jobId !== ((_b = this._activeJob) === null || _b === void 0 ? void 0 : _b.id)) {
              this._jobQueue = this._jobQueue.filter((i) => i.id !== jobId);
              return true;
          }
          console.warn("执行中的工作不可删除");
          return false;
      }
      /**
       * 传入调度器id则只暂停对应的调度器
       */
      pause(key, schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              return (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.pause(key);
          }
          this._schedulerStore.forEach((jobScheduler) => {
              jobScheduler.pause(key);
          });
          key || (key = performance.now() + "");
          this._pauseKeyStore.add(key);
          this._paused = true;
          return key;
      }
      /**
       * 传入调度器id则只恢复对应的调度器
       */
      resume(key, schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              return (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.resume(key);
          }
          this._schedulerStore.forEach((jobScheduler) => {
              jobScheduler.resume(key);
          });
          if (key) {
              this._pauseKeyStore.delete(key);
              if (this._pauseKeyStore.size > 0) {
                  return false;
              }
          }
          else {
              this._pauseKeyStore.clear();
          }
          this._paused = false;
          this._run();
          return true;
      }
      /**
       * 传入调度器id则只清空对应的调度器
       */
      clear(schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.clear();
          }
          else {
              this._jobQueue = [];
              this._pauseKeyStore.clear();
              this._schedulerStore.forEach((scheduler) => {
                  scheduler.clear();
              });
              this._schedulerStore.clear();
          }
          return this;
      }
  }

  function styleChangeHandle(e) {
      fallBeforeAnimate.call(e.target);
  }
  var BeforeFallDownTask = /** @class */ (function () {
      function BeforeFallDownTask(options) {
          this._options = options;
      }
      BeforeFallDownTask.prototype.run = function () {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  this.task._options.features.forEach(function (item) {
                      fallBeforeAnimate.call(item);
                      item.on(BaseEventType.STYLE_CHANGED, styleChangeHandle);
                  });
                  return [2 /*return*/, { data: { features: this.task._options.features, layer: this.task._options.layer } }];
              });
          });
      };
      return BeforeFallDownTask;
  }());
  var FallDownTask = /** @class */ (function () {
      function FallDownTask() {
      }
      FallDownTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve) {
                          var features = previousTaskResult.data.features;
                          var previousTime;
                          var rate = 0;
                          var _a = (previousTaskResult.data.layer.options.animation === true ? {} : previousTaskResult.data.layer.options.animation), _b = _a.duration, duration = _b === void 0 ? 2 : _b, _c = _a.bouncePixel, bouncePixel = _c === void 0 ? 0 : _c, easingFunction = _a.easingFunction;
                          var eventKey = previousTaskResult.data.layer.map.on(BaseEventType.POST_RENDER, function (e) {
                              if (defined$1(previousTime)) {
                                  rate += (performance.now() - previousTime) / 1000 / duration;
                                  rate > 1 && (rate = 1);
                                  var currentTime_1 = previousTaskResult.data.layer.map.map.clock.currentTime.clone();
                                  var newRate_1 = easingFunction ? easingFunction(rate) : Math.pow(rate, 3);
                                  features.forEach(function (feature) {
                                      fallAnimating.call(feature, bouncePixel, currentTime_1, newRate_1);
                                  });
                              }
                              previousTime = performance.now();
                              if (rate >= 1) {
                                  previousTaskResult.data.layer.unByKey(eventKey);
                                  resolve(previousTaskResult);
                              }
                          });
                      })];
              });
          });
      };
      return FallDownTask;
  }());
  var AfterFallDownTask = /** @class */ (function () {
      function AfterFallDownTask() {
      }
      AfterFallDownTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  previousTaskResult.data.features.forEach(function (item) {
                      fallAfterAnimate.call(item);
                      item.un(BaseEventType.STYLE_CHANGED, styleChangeHandle);
                  });
                  return [2 /*return*/];
              });
          });
      };
      return AfterFallDownTask;
  }());
  var INIT = Symbol("init");
  function initBillboard(billboard) {
      if (billboard[INIT]) {
          return;
      }
      // if (iterator.color) {
      billboard.color_default_alpha = billboard.color.alpha;
      billboard.color = new Cesium__namespace.Color(billboard.color.red, billboard.color.green, billboard.color.blue, 0.001);
      // } else {
      //   iterator.color = new Cesium.Color(1, 1, 1, 0.001)
      //   iterator.color_default_alpha = 1
      // }
      billboard.pixelOffset_default_y = billboard.pixelOffset.y;
      billboard[INIT] = true;
  }
  function initLabel(label) {
      if (label[INIT]) {
          return;
      }
      label.pixelOffset_default_y = label.pixelOffset.y;
      label.backgroundColor_default_alpha = label.backgroundColor.alpha;
      label.backgroundColor = new Cesium__namespace.Color(label.backgroundColor.red, label.backgroundColor.green, label.backgroundColor.blue, 0.001);
      label.fillColor_default_alpha = label.fillColor.alpha;
      label.fillColor = new Cesium__namespace.Color(label.fillColor.red, label.fillColor.green, label.fillColor.blue, 0.001);
      label.outlineColor_default_alpha = label.outlineColor.alpha;
      label.outlineColor = new Cesium__namespace.Color(label.outlineColor.red, label.outlineColor.green, label.outlineColor.blue, 0.001);
      label[INIT] = true;
  }
  function initBillboardGraphics(billboard, startTime) {
      if (billboard[INIT]) {
          return;
      }
      billboard.color || (billboard.color = new Cesium__namespace.ConstantProperty(Cesium__namespace.Color.WHITE));
      var defaultColor = billboard.color.getValue(startTime);
      billboard.color_default_alpha = defaultColor.alpha;
      billboard.color.setValue(defaultColor.withAlpha(0.001));
      // } else {
      //   iterator.color = new Cesium.Color(1, 1, 1, 0                                                                            .001)
      //   iterator.color_default_alpha = 1
      // }
      billboard.pixelOffset || (billboard.pixelOffset = new Cesium__namespace.ConstantProperty(new Cesium__namespace.Cartesian2()));
      var defaultOffset = billboard.pixelOffset.getValue(startTime);
      billboard.pixelOffset_default_y = defaultOffset.y;
      billboard[INIT] = true;
  }
  function initLabelGraphics(label, startTime) {
      if (label[INIT]) {
          return;
      }
      var defaultOffset = label.pixelOffset.getValue(startTime);
      label.pixelOffset_default_y = defaultOffset.y;
      var defaultBackgroundColor = label.backgroundColor.getValue(startTime);
      label.backgroundColor_default_alpha = defaultBackgroundColor.alpha;
      label.backgroundColor.setValue(defaultBackgroundColor.withAlpha(0.001));
      var defaultFillColor = label.fillColor.getValue(startTime);
      label.fillColor_default_alpha = defaultFillColor.alpha;
      label.fillColor.setValue(defaultFillColor.withAlpha(0.001));
      var defaultOutlineColor = label.outlineColor.getValue(startTime);
      label.outlineColor_default_alpha = defaultOutlineColor.alpha;
      label.outlineColor.setValue(defaultOutlineColor.withAlpha(0.001));
      label[INIT] = true;
  }
  function fallBeforeAnimate() {
      var e_1, _a, e_2, _b, e_3, _c;
      var _d = this.sourceFeature, billboards = _d.billboards, labels = _d.labels, entities = _d.entities;
      var startTime = this.layer.map.map.clock.currentTime;
      if (billboards) {
          try {
              for (var _e = __values(billboards), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var billboard = _f.value;
                  initBillboard(billboard);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
              }
              finally { if (e_1) throw e_1.error; }
          }
      }
      if (labels) {
          try {
              for (var _g = __values(labels), _h = _g.next(); !_h.done; _h = _g.next()) {
                  var label = _h.value;
                  initLabel(label);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
              }
              finally { if (e_2) throw e_2.error; }
          }
      }
      if (entities) {
          try {
              for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                  var iterator = entities_1_1.value;
                  if (iterator.billboard) {
                      var billboard = iterator.billboard;
                      initBillboardGraphics(billboard, startTime);
                  }
                  if (iterator.label) {
                      var label = iterator.label;
                      initLabelGraphics(label, startTime);
                  }
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (entities_1_1 && !entities_1_1.done && (_c = entities_1.return)) _c.call(entities_1);
              }
              finally { if (e_3) throw e_3.error; }
          }
      }
  }
  function fallAfterAnimate() {
      var e_4, _a, e_5, _b, e_6, _c;
      var _d = this.sourceFeature, billboards = _d.billboards, labels = _d.labels, entities = _d.entities;
      var startTime = this.layer.map.map.clock.currentTime;
      if (billboards) {
          try {
              for (var _e = __values(billboards), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var billboard = _f.value;
                  billboard.pixelOffset = new Cesium__namespace.Cartesian2(billboard.pixelOffset.x, billboard.pixelOffset_default_y || 0);
                  // if (iterator.color) {
                  billboard.color = new Cesium__namespace.Color(billboard.color.red, billboard.color.green, billboard.color.blue, billboard.color_default_alpha || 1);
                  // } else {
                  //   iterator.color = new Cesium.Color(1, 1, 1, 0.001)
                  //   iterator.color_default_alpha = 1
                  // }
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
              }
              finally { if (e_4) throw e_4.error; }
          }
      }
      if (labels) {
          try {
              for (var _g = __values(labels), _h = _g.next(); !_h.done; _h = _g.next()) {
                  var label = _h.value;
                  label.pixelOffset = new Cesium__namespace.Cartesian2(label.pixelOffset.x, label.pixelOffset_default_y);
                  label.backgroundColor = new Cesium__namespace.Color(label.backgroundColor.red, label.backgroundColor.green, label.backgroundColor.blue, label.backgroundColor_default_alpha);
                  label.fillColor = new Cesium__namespace.Color(label.fillColor.red, label.fillColor.green, label.fillColor.blue, label.fillColor_default_alpha);
                  label.outlineColor = new Cesium__namespace.Color(label.outlineColor.red, label.outlineColor.green, label.outlineColor.blue, label.outlineColor_default_alpha);
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
              }
              finally { if (e_5) throw e_5.error; }
          }
      }
      if (entities) {
          try {
              for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                  var iterator = entities_2_1.value;
                  if (iterator.billboard) {
                      var billboard = iterator.billboard;
                      var defaultColor = billboard.color.getValue(startTime);
                      billboard.color.setValue(defaultColor.withAlpha(billboard.color_default_alpha));
                      // } else {
                      //   iterator.color = new Cesium.Color(1, 1, 1, 0                                                                            .001)
                      //   iterator.color_default_alpha = 1
                      // }
                      var defaultOffset = billboard.pixelOffset.getValue(startTime);
                      billboard.pixelOffset.setValue(new Cesium__namespace.Cartesian2(defaultOffset.x, billboard.pixelOffset_default_y));
                  }
                  if (iterator.label) {
                      var label = iterator.label;
                      var defaultOffset = label.pixelOffset.getValue(startTime);
                      label.pixelOffset.setValue(new Cesium__namespace.Cartesian2(defaultOffset.x, label.pixelOffset_default_y));
                      var defaultBackgroundColor = label.backgroundColor.getValue(startTime);
                      label.backgroundColor.setValue(defaultBackgroundColor.withAlpha(label.backgroundColor_default_alpha));
                      var defaultFillColor = label.fillColor.getValue(startTime);
                      label.fillColor.setValue(defaultFillColor.withAlpha(label.fillColor_default_alpha));
                      var defaultOutlineColor = label.outlineColor.getValue(startTime);
                      label.outlineColor.setValue(defaultOutlineColor.withAlpha(label.outlineColor_default_alpha));
                  }
              }
          }
          catch (e_6_1) { e_6 = { error: e_6_1 }; }
          finally {
              try {
                  if (entities_2_1 && !entities_2_1.done && (_c = entities_2.return)) _c.call(entities_2);
              }
              finally { if (e_6) throw e_6.error; }
          }
      }
      //@ts-ignore
      this.__previousTime__ = this.__complete__ = undefined;
  }
  function fallAnimating(bouncePixel, startTime, rate) {
      var e_7, _a, e_8, _b, e_9, _c;
      var _d = this.sourceFeature, billboards = _d.billboards, labels = _d.labels, entities = _d.entities;
      var alpha = rate;
      if (billboards) {
          try {
              for (var _e = __values(billboards), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var iterator = _f.value;
                  if (!defined$1(iterator[INIT])) {
                      initBillboard(iterator);
                  }
                  iterator.pixelOffset = new Cesium__namespace.Cartesian2(iterator.pixelOffset.x, iterator.pixelOffset_default_y - (1 - alpha) * bouncePixel);
                  // if (iterator.color) {
                  iterator.color = new Cesium__namespace.Color(iterator.color.red, iterator.color.green, iterator.color.blue, iterator.color_default_alpha * alpha);
                  // } else {
                  //   iterator.color = new Cesium.Color(1, 1, 1, 0.001)
                  //   iterator.color_default_alpha = 1
                  // }
              }
          }
          catch (e_7_1) { e_7 = { error: e_7_1 }; }
          finally {
              try {
                  if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
              }
              finally { if (e_7) throw e_7.error; }
          }
      }
      if (labels) {
          try {
              for (var _g = __values(labels), _h = _g.next(); !_h.done; _h = _g.next()) {
                  var iterator = _h.value;
                  // @ts-ignore
                  if (!iterator._labelCollection) {
                      continue;
                  }
                  if (!defined$1(iterator[INIT])) {
                      initLabel(iterator);
                  }
                  iterator.pixelOffset = new Cesium__namespace.Cartesian2(iterator.pixelOffset.x, iterator.pixelOffset_default_y - (1 - alpha) * bouncePixel);
                  iterator.backgroundColor = new Cesium__namespace.Color(iterator.backgroundColor.red, iterator.backgroundColor.green, iterator.backgroundColor.blue, iterator.backgroundColor_default_alpha * alpha);
                  iterator.fillColor = new Cesium__namespace.Color(iterator.fillColor.red, iterator.fillColor.green, iterator.fillColor.blue, iterator.fillColor_default_alpha * alpha);
                  iterator.outlineColor = new Cesium__namespace.Color(iterator.outlineColor.red, iterator.outlineColor.green, iterator.outlineColor.blue, iterator.outlineColor_default_alpha * alpha);
              }
          }
          catch (e_8_1) { e_8 = { error: e_8_1 }; }
          finally {
              try {
                  if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
              }
              finally { if (e_8) throw e_8.error; }
          }
      }
      if (entities) {
          try {
              for (var entities_3 = __values(entities), entities_3_1 = entities_3.next(); !entities_3_1.done; entities_3_1 = entities_3.next()) {
                  var iterator = entities_3_1.value;
                  if (iterator.billboard) {
                      var billboard = iterator.billboard;
                      if (!defined$1(billboard[INIT])) {
                          initBillboardGraphics(billboard, startTime);
                      }
                      var defaultColor = billboard.color.getValue(startTime);
                      billboard.color.setValue(defaultColor.withAlpha(billboard.color_default_alpha * alpha));
                      // } else {
                      //   iterator.color = new Cesium.Color(1, 1, 1, 0.001)
                      //   iterator.color_default_alpha = 1
                      // }
                      var defaultOffset = billboard.pixelOffset.getValue(startTime);
                      billboard.pixelOffset.setValue(new Cesium__namespace.Cartesian2(defaultOffset.x, billboard.pixelOffset_default_y - (1 - alpha) * bouncePixel));
                  }
                  if (iterator.label) {
                      var label = iterator.label;
                      if (!defined$1(label[INIT])) {
                          initLabelGraphics(label, startTime);
                      }
                      var defaultOffset = label.pixelOffset.getValue(startTime);
                      label.pixelOffset.setValue(new Cesium__namespace.Cartesian2(defaultOffset.x, label.pixelOffset_default_y - (1 - alpha) * bouncePixel));
                      var defaultBackgroundColor = label.backgroundColor.getValue(startTime);
                      label.backgroundColor.setValue(defaultBackgroundColor.withAlpha(label.backgroundColor_default_alpha * alpha));
                      var defaultFillColor = label.fillColor.getValue(startTime);
                      label.fillColor.setValue(defaultFillColor.withAlpha(label.fillColor_default_alpha * alpha));
                      var defaultOutlineColor = label.outlineColor.getValue(startTime);
                      label.outlineColor.setValue(defaultOutlineColor.withAlpha(label.outlineColor_default_alpha * alpha));
                  }
              }
          }
          catch (e_9_1) { e_9 = { error: e_9_1 }; }
          finally {
              try {
                  if (entities_3_1 && !entities_3_1.done && (_c = entities_3.return)) _c.call(entities_3);
              }
              finally { if (e_9) throw e_9.error; }
          }
      }
  }

  function featureAnimate(_a) {
      var layer = _a.layer, features = _a.features;
      var point = [];
      features.forEach(function (item) {
          if (item instanceof Point$1) {
              point.push(item);
          }
      });
      layer.map.jobScheduler.add(new BaseJob({
          tasks: [new BeforeFallDownTask({ layer: layer, features: point }), new FallDownTask(), new AfterFallDownTask()]
      }));
  }

  /**
   * 组件基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Component$1 = /** @class */ (function (_super) {
      __extends$3(Component, _super);
      function Component(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           * @private
           */
          _this._initialized = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Component.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化组件
       *
       * @ignore
       */
      Component.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Component.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this._initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Component.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      return Component;
  }(BaseObject));

  function translation(options) {
      return __awaiter$8(this, void 0, void 0, function () {
          var _this = this;
          return __generator$1(this, function (_a) {
              return [2 /*return*/, new Promise(function (resolve) {
                      var target = options.target, oldCoordinates = options.coordinates, map = options.map, velocity = options.velocity, _a = options.duration, duration = _a === void 0 ? 5 : _a, callback = options.callback;
                      var coordinates = Array.isArray(oldCoordinates[0])
                          ? oldCoordinates
                          : [target.coordinates, oldCoordinates];
                      if (coordinates[0][0] === coordinates[1][0] && coordinates[0][1] === coordinates[1][1]) {
                          return;
                      }
                      // 构造geojson线---
                      var lineFeature = lineString(coordinates);
                      // 计算线的长度，单位米
                      var length = Turf__namespace.length(lineFeature) * 1000;
                      // 坐标是否含有高度----
                      var hasHeight = coordinates[0].length > 2;
                      var time = 0;
                      var distance = 0;
                      var previousTime = performance.now();
                      var eventKey = map.on(BaseEventType.POST_RENDER, function () {
                          if (_this.jobScheduler.paused) {
                              previousTime = performance.now();
                              return;
                          }
                          var currentTime = performance.now();
                          // 消耗的时间
                          var timeSpan = (currentTime - previousTime) / 1000;
                          var rate;
                          // 速度是否定义，定义计算距离-----
                          if (defined$1(velocity)) {
                              distance += timeSpan * velocity;
                              rate = distance / length;
                          }
                          else {
                              time += timeSpan;
                              rate = time / duration;
                          }
                          // 计算进度
                          rate = rate >= 1 ? 1 : rate;
                          var slicedLineFeature = Turf__namespace.lineSliceAlong(lineFeature, 0, (length * rate) / 1000);
                          var slicedCoordinates = slicedLineFeature.geometry.coordinates;
                          var newPointCoordinate = slicedCoordinates[slicedCoordinates.length - 1];
                          if (hasHeight) {
                              var _a = __read(coordinates[slicedCoordinates.length - 1], 3), lng1 = _a[0], lat1 = _a[1], height1 = _a[2];
                              var _b = __read(coordinates[slicedCoordinates.length - 2], 3), lng2 = _b[0], lat2 = _b[1], height2 = _b[2];
                              var _c = __read(slicedCoordinates[slicedCoordinates.length - 1], 2), lng3 = _c[0], lat3 = _c[1];
                              var newHeight = void 0;
                              if (lng1 === lng3 && lat1 === lat3) {
                                  newHeight = height1;
                              }
                              else {
                                  newHeight =
                                      height2 -
                                          (Turf__namespace.distance([lng2, lat2], [lng3, lat3]) / Turf__namespace.distance([lng2, lat2], [lng1, lat1])) *
                                              (height2 - height1);
                              }
                              newPointCoordinate[2] = newHeight;
                          }
                          // 要素移动
                          target.setCoordinates(newPointCoordinate);
                          // 回调是否定义
                          if (defined$1(callback)) {
                              callback({
                                  feature: target,
                                  startPosition: coordinates[slicedCoordinates.length - 2],
                                  endPosition: newPointCoordinate,
                                  map: map
                              });
                          }
                          // 要素分发事件
                          target.dispatchEvent({ type: BaseEventType.MOVE, progress: rate, position: newPointCoordinate });
                          previousTime = performance.now();
                          // 要素移动完成，注销事件监听，移动完成
                          if (rate >= 1) {
                              map.unByKey(eventKey);
                              // 要素分发移动完成事件
                              target.dispatchEvent({ type: BaseEventType.MOVE_END, progress: rate, position: newPointCoordinate });
                              //
                              resolve(void 0);
                          }
                          // 要素图层
                          // target.layer.layer[0]?.changed?.();
                      });
                      // target.layer.layer[0]?.changed?.();
                  })];
          });
      });
  }
  // 要素移动任务
  var FeatureTranslationTask = /** @class */ (function () {
      function FeatureTranslationTask(options) {
          this._options = options;
      }
      FeatureTranslationTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, translation.call(this, {
                              map: this.task._options.map,
                              target: this.task._options.target,
                              coordinates: this.task._options.coordinates,
                              duration: this.task._options.duration || 5,
                              callback: this.task._options.callback
                          })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/, {}];
                  }
              });
          });
      };
      return FeatureTranslationTask;
  }());
  var FeatureTranslationOverEventTask = /** @class */ (function () {
      function FeatureTranslationOverEventTask(options) {
          this._options = options;
      }
      // 指定的方法
      FeatureTranslationOverEventTask.prototype.run = function (
      // 上一个任务调用结果
      previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              var _this = this;
              return __generator$1(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve) {
                          _this.task._options.callback.call(_this.task._options.scope);
                          resolve({});
                      })];
              });
          });
      };
      return FeatureTranslationOverEventTask;
  }());

  /**
   * 移动任务队列组件
   *
   * 可触发要素对象的`move`事件,获取当前移动进度和位置
   */
  var TranslationQueue = /** @class */ (function (_super) {
      __extends$3(TranslationQueue, _super);
      function TranslationQueue(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(TranslationQueue.prototype, "jobScheduler", {
          get: function () {
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      TranslationQueue.prototype.init = function () {
          this.initialized = true;
          this._taskIdStore = {};
          this._jobScheduler = new JobScheduler();
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.stop();
          this.clearTask();
          this._jobScheduler = void 0;
          this._taskIdStore = void 0;
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 添加移动任务
       */
      TranslationQueue.prototype.addTask = function (taskOptions) {
          var _this = this;
          if (this.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          // 移动目标、移动位置、持续时间
          var target = taskOptions.target, coordinates = taskOptions.coordinates, duration = taskOptions.duration;
          var jobSchedulerId = target.id + "-scheduler";
          var _a = getPointFeatureModelParams(target, this.map), clamped = _a.clamped, hasModel = _a.hasModel;
          //  创建基础工作
          var job = new BaseJob({
              tasks: [
                  new FeatureTranslationTask({
                      map: this.map,
                      target: target,
                      duration: duration,
                      coordinates: coordinates,
                      callback: hasModel
                          ? function (_a) {
                              var feature = _a.feature, startPosition = _a.startPosition, endPosition = _a.endPosition;
                              if (clamped) {
                                  coordinatesClampToTerrain([endPosition], _this.map).then(function (res) {
                                      updateFeatureOrientation(feature, degreesToCartesian3(startPosition, _this.map), degreesToCartesian3(res[0], _this.map), _this.map.map.scene.globe.ellipsoid);
                                  });
                              }
                              else {
                                  updateFeatureOrientation(feature, degreesToCartesian3(startPosition, _this.map), degreesToCartesian3(endPosition, _this.map), _this.map.map.scene.globe.ellipsoid);
                              }
                          }
                          : void 0
                  }),
                  new FeatureTranslationOverEventTask({
                      callback: function () {
                          _this._taskIdStore[job.id] = void 0;
                      }
                  })
              ]
          });
          this._jobScheduler.add(job, jobSchedulerId);
          this._taskIdStore[job.id] = jobSchedulerId;
          return job.id;
      };
      /**
       * 移除移动任务
       */
      TranslationQueue.prototype.removeTask = function (taskId) {
          this._jobScheduler.remove(taskId, this._taskIdStore[taskId]);
          return this;
      };
      /**
       * 清空队列
       */
      TranslationQueue.prototype.clearTask = function () {
          this.start();
          this._jobScheduler.clear();
          return this;
      };
      /**
       * 开始
       */
      TranslationQueue.prototype.start = function () {
          this._jobScheduler.resume();
          return this;
      };
      /**
       * 停止
       */
      TranslationQueue.prototype.stop = function () {
          this._jobScheduler.pause();
          return this;
      };
      return TranslationQueue;
  }(Component$1));

  var _a$1;
  var VectorLayer = /** @class */ (function (_super) {
      __extends$3(VectorLayer, _super);
      function VectorLayer(options, map) {
          var _this = _super.call(this, __assign$1({ opacity: 1, visible: true, cluster: false, distance: 200, animation: false }, options)) || this;
          /**
           * 数据加载中
           * @ignore
           */
          _this[_a$1] = false;
          _this._features = new BaseCollection();
          if (_this.cluster) {
              _this._clusterFeatures = new BaseCollection();
              _this._style = _this.options.style || DEFAULT_ClUSTER_STYLE_ITEM;
              _this._animationLayer = new VectorLayer({
                  id: "animation-".concat(Cesium__namespace.createGuid())
              });
          }
          else {
              _this._style = _this.options.style || VECTOR_LAYER_STYLE.default;
          }
          _this.addFeatures(dataToFeatures(_this.options.data));
          if (_this.options.animation) {
              _this.on([BaseEventType.SHOW, BaseEventType.ADD_FEATURE, BaseEventType.ADD_FEATURES], function (e) {
                  if (!_this.cluster && !_this[LOADING_DATA]) {
                      var features = void 0;
                      switch (e.type) {
                          case BaseEventType.SHOW:
                              features = _this.features;
                              break;
                          case BaseEventType.ADD_FEATURE:
                              features = [e.feature];
                              break;
                          case BaseEventType.ADD_FEATURES:
                              features = e.features;
                              break;
                      }
                      features.length > 0 && featureAnimate({ layer: _this, features: features });
                  }
              });
          }
          if (defined$1(map)) {
              map.addLayer(_this);
          }
          return _this;
      }
      Object.defineProperty(VectorLayer.prototype, "extent", {
          get: function () {
              return Turf__namespace.bbox(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "geoJson", {
          get: function () {
              return featureCollection(this.features.map(function (f) { return f.geoJson; }));
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "wkts", {
          get: function () {
              return this.features.map(function (f) { return f.wkt; });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "style", {
          /**
           * 图层设置的样式
           */
          get: function () {
              return this._style;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "styleFunction", {
          /**
           * 当前图层使用的样式函数
           */
          get: function () {
              return this._styleFunction;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "features", {
          /**
           * 图层要素集合
           */
          get: function () {
              return this._features.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "layer", {
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "cluster", {
          get: function () {
              return this.options.cluster;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      VectorLayer.prototype._updateClusterData = function () {
          if (this.cluster && this._source) {
              this._source.updateFeatures(write$1(this._clusterFeatures.getArray()));
          }
      };
      /**
       * 添加数据
       *
       * @param data 数据
       * @param options
       */
      VectorLayer.prototype.addData = function (data, options) {
          return this.addFeatures(dataToFeatures(data, options));
      };
      VectorLayer.prototype.addFeature = function (feature) {
          if (this.cluster) {
              console.warn(ErrorNotification.NOT_COMMEND);
          }
          else {
              this._features.add(feature);
              feature.addToLayer(this);
              this.dispatchEvent({
                  type: BaseEventType.ADD_FEATURE,
                  target: this,
                  feature: feature
              });
          }
          return this;
      };
      /**
       * @ignore
       */
      VectorLayer.prototype._addFeature = function (feature) {
          this._clusterFeatures.add(feature);
      };
      VectorLayer.prototype.addFeatures = function (features) {
          var e_1, _b;
          this[LOADING_DATA] = true;
          try {
              for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                  var feature = features_1_1.value;
                  if (this.cluster) {
                      this._addFeature(feature);
                  }
                  else {
                      this.addFeature(feature);
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (features_1_1 && !features_1_1.done && (_b = features_1.return)) _b.call(features_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          if (this.cluster) {
              this._updateClusterData();
          }
          else {
              this[LOADING_DATA] = false;
              this.dispatchEvent({
                  type: BaseEventType.ADD_FEATURES,
                  target: this,
                  features: features
              });
          }
          return this;
      };
      /**
       * 根据要素id获取要素
       * @param id
       */
      VectorLayer.prototype.getFeature = function (id) {
          return this._features.getItem(id);
      };
      /**
       * 获取矢量图层当前要素数组
       */
      VectorLayer.prototype.getFeatures = function () {
          return this.features;
      };
      /**
       * 移除要素
       * @param feature
       */
      VectorLayer.prototype.removeFeature = function (feature) {
          if (this.cluster) {
              console.warn(ErrorNotification.NOT_COMMEND);
          }
          else {
              if (this._features.include(feature.id)) {
                  // 聚合时的删除
                  feature.remove();
                  // 要素移除事件 在要素内部触发
                  this._features.remove(feature);
              }
              return this;
          }
      };
      /**
       * 移除多个要素
       * @param features
       */
      VectorLayer.prototype.removeFeatures = function (features) {
          var e_2, _b, e_3, _c;
          if (this.cluster) {
              try {
                  for (var features_2 = __values(features), features_2_1 = features_2.next(); !features_2_1.done; features_2_1 = features_2.next()) {
                      var feature = features_2_1.value;
                      if (this._clusterFeatures.include(feature.id)) {
                          // 要素移除事件 在要素内部触发
                          this._clusterFeatures.remove(feature);
                      }
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (features_2_1 && !features_2_1.done && (_b = features_2.return)) _b.call(features_2);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
              this._updateClusterData();
          }
          else {
              if (features && features.length > 0) {
                  try {
                      for (var features_3 = __values(features), features_3_1 = features_3.next(); !features_3_1.done; features_3_1 = features_3.next()) {
                          var feature = features_3_1.value;
                          this.removeFeature(feature);
                      }
                  }
                  catch (e_3_1) { e_3 = { error: e_3_1 }; }
                  finally {
                      try {
                          if (features_3_1 && !features_3_1.done && (_c = features_3.return)) _c.call(features_3);
                      }
                      finally { if (e_3) throw e_3.error; }
                  }
              }
          }
          return this;
      };
      /**
       * 清空要素
       */
      VectorLayer.prototype.clearFeatures = function () {
          if (this.cluster) {
              this.removeFeatures(this._clusterFeatures.getArray());
          }
          else {
              this.removeFeatures(this.getFeatures());
          }
          return this;
      };
      /**
       * @ignore
       */
      VectorLayer.prototype.init = function () {
          var _this = this;
          this._initialized = true;
          var dataSource = new Cesium__namespace.CustomDataSource();
          dataSource.show = false;
          this._layer = {
              billboardCollection: this.map.getOrCreateCesiumCollection("billboard"),
              labelCollection: this.map.getOrCreateCesiumCollection("label"),
              pointPrimitiveCollection: this.map.getOrCreateCesiumCollection("point"),
              primitiveCollection: new Cesium__namespace.PrimitiveCollection({
                  show: false,
                  destroyPrimitives: false
              }),
              dataSource: dataSource,
              geometryInstanceCollection: new GeometryInstanceCollection()
          };
          if (this.cluster) {
              this._source = new ClusterSource({
                  distance: this.options.distance,
                  expandZoom: this.options.expandZoom || 19,
                  data: this.options.data
              });
              this._queue = new TranslationQueue({}, this.map);
              this._source.on("getfeatures", function (event) {
                  _this._updataFeatures(event);
              });
          }
      };
      /**
       * @ignore
       */
      VectorLayer.prototype._updataFeatures = function (event) {
          var _this = this;
          // 是否动画
          if (this._source.animation && this.options.clusterAnimation) {
              var all_1 = [];
              var points_1 = this.getFeatures();
              var clusterData = event.clusterData;
              var animationObj = clusterData.map(function (data) {
                  return _this._getClusterForFeature(data, points_1);
              });
              var taskOptions = animationObj
                  .filter(function (obj) {
                  return defined$1(obj.source);
              })
                  .map(function (obj) {
                  var peoperties = __assign$1({}, obj.source.properties);
                  delete peoperties.id;
                  var feature = new Point$1({
                      coordinates: obj.source.geometry.coordinates,
                      properties: __assign$1({}, peoperties)
                  });
                  _this._animationLayer.addFeature(feature);
                  return {
                      target: feature,
                      coordinates: obj.target.geometry.coordinates,
                      duration: 0.35
                  };
              });
              taskOptions.forEach(function (option) {
                  _this._queue.addTask(option);
                  all_1.push(new Promise(function (resolve, reject) {
                      option.target.on(BaseEventType.MOVE_END, function (event) {
                          resolve(event);
                      });
                  }));
              });
              Promise.all(all_1).then(function (res) {
                  _this._renderFeatures(event.features);
                  _this._queue.clearTask();
              });
          }
          else {
              this._renderFeatures(event.features);
          }
      };
      VectorLayer.prototype.addTo = function (map) {
          var _b, _c;
          _super.prototype.addTo.call(this, map);
          var viewer = this.map.map;
          if (this.cluster) {
              this.map.addLayer(this._animationLayer);
              this._animationLayer.setStyle(this._style);
              this._source.addTo(map);
          }
          var _d = this._layer, primitiveCollection = _d.primitiveCollection, dataSource = _d.dataSource, geometryInstanceCollection = _d.geometryInstanceCollection;
          viewer.dataSources.add(dataSource);
          viewer.scene.primitives.add(primitiveCollection);
          geometryInstanceCollection.addToGlobe(this.map);
          this._setStyle();
          if (((_b = this._options) === null || _b === void 0 ? void 0 : _b.visible) === true) {
              this._visible = false;
              this.show();
          }
          else if (((_c = this._options) === null || _c === void 0 ? void 0 : _c.visible) === false) {
              this._visible = true;
              this.hide();
          }
      };
      /**
       * 渲染要素
       * @ignore
       */
      VectorLayer.prototype._renderFeatures = function (features) {
          var _this = this;
          this._animationLayer && this._animationLayer.clearFeatures();
          this.getFeatures().forEach(function (f) {
              if (_this._features.include(f.id)) {
                  // 聚合时的删除
                  f.remove();
                  // 要素移除事件 在要素内部触发
                  _this._features.remove(f);
              }
          });
          features.forEach(function (feature_) {
              _this._features.add(feature_);
              feature_.addToLayer(_this);
          });
      };
      /**
       *返回该要素所属于的聚合要素
       * @ignore
       */
      VectorLayer.prototype._getClusterForFeature = function (feature, clusters) {
          var distance = 0;
          var _feature = clusters[0];
          for (var j = 0; j < clusters.length; j++) {
              var clusterFeature = clusters[j];
              var _distance = Turf__namespace.distance(clusterFeature.geoJson, feature);
              if (j === 0) {
                  distance = _distance;
              }
              else {
                  if (_distance < distance) {
                      _feature = clusterFeature;
                  }
              }
          }
          return { source: (_feature && _feature.geoJson) || undefined, target: feature };
      };
      /**
       * @override
       * @ignore
       */
      VectorLayer.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          var viewer = this.map.map;
          var _b = this._layer, billboardCollection = _b.billboardCollection, labelCollection = _b.labelCollection, pointPrimitiveCollection = _b.pointPrimitiveCollection, primitiveCollection = _b.primitiveCollection, dataSource = _b.dataSource, geometryInstanceCollection = _b.geometryInstanceCollection;
          viewer.dataSources.remove(dataSource);
          billboardCollection.show = false;
          labelCollection.show = false;
          pointPrimitiveCollection.show = false;
          viewer.scene.primitives.remove(primitiveCollection);
          geometryInstanceCollection.removeFromGlobe();
          this._animationLayer && this.map.removeLayer(this._animationLayer);
          this._source && this._source.remove();
      };
      /**
       * @ignore
       */
      VectorLayer.prototype._destroy = function () {
          var map = this.map;
          this.remove();
          var _b = this._layer, billboardCollection = _b.billboardCollection, labelCollection = _b.labelCollection, pointPrimitiveCollection = _b.pointPrimitiveCollection, primitiveCollection = _b.primitiveCollection, dataSource = _b.dataSource, geometryInstanceCollection = _b.geometryInstanceCollection;
          billboardCollection.removeAll();
          labelCollection.removeAll();
          pointPrimitiveCollection.removeAll();
          map.storeCesiumCollection(billboardCollection);
          map.storeCesiumCollection(labelCollection);
          map.storeCesiumCollection(pointPrimitiveCollection);
          primitiveCollection.destroy();
          geometryInstanceCollection.destroy();
          Cesium__namespace.destroyObject(dataSource);
          this._layer = void 0;
          this._features.destroyed || this._features.destroy();
          this._style = void 0;
          this._source = void 0;
          this._animationLayer = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       *  重写父类方法
       */
      VectorLayer.prototype.setStyle = function (style) {
          this._style = style;
          // 聚合样式设置
          this._setStyle();
          return this;
      };
      /**
       * @ignore
       */
      VectorLayer.prototype._setStyle = function () {
          var e_4, _b;
          this._styleFunction = toStyleFunction(this.style);
          try {
              for (var _c = __values(this.features), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var feature = _d.value;
                  feature.applyLayerStyle();
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
              }
              finally { if (e_4) throw e_4.error; }
          }
      };
      /**
       * 显示图层
       */
      VectorLayer.prototype.show = function () {
          if (this.visible === true)
              return this;
          _super.prototype.show.call(this);
          setVisible.call(this, true);
          return this;
      };
      /**
       * 隐藏图层
       */
      VectorLayer.prototype.hide = function () {
          if (this.visible === false)
              return this;
          _super.prototype.hide.call(this);
          setVisible.call(this, false);
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `pick`    |   左键拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `doublepick` |  左键双击拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `rightpick` |  右键单击拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `addfeature` | 添加单个要素 | (feature: [[Feature]])-要素对象
       *  `addfeatures` | 添加多个要素 | (features: [[Feature]][])-要素对象数组
       *  `removefeature` | 移除要素 | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      VectorLayer.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `pick`    |   左键拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `doublepick` |  左键双击拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `rightpick` |  右键单击拾取(只有顶部图层触发)  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (layer: [[VectorLayer]])-矢量图层对象, (features: [[Feature]][])-要素对象数组
       *  `addfeature` | 添加单个要素 | (feature: [[Feature]])-要素对象
       *  `addfeatures` | 添加多个要素 | (features: [[Feature]][])-要素对象数组
       *  `removefeature` | 移除要素 | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      VectorLayer.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return VectorLayer;
  }(Layer));
  _a$1 = LOADING_DATA;
  function setVisible(visible) {
      if (!this._layer)
          return;
      var _b = this._layer, billboardCollection = _b.billboardCollection, labelCollection = _b.labelCollection, pointPrimitiveCollection = _b.pointPrimitiveCollection, primitiveCollection = _b.primitiveCollection, dataSource = _b.dataSource, geometryInstanceCollection = _b.geometryInstanceCollection;
      // for (let i = 0, len = billboardCollection.length; i < len; ++i) {
      //   billboardCollection.get(i).show = visible;
      // }
      billboardCollection.show = visible;
      labelCollection.show = visible;
      pointPrimitiveCollection.show = visible;
      primitiveCollection.show = visible;
      dataSource.show = visible;
      geometryInstanceCollection.show = visible;
  }

  var WebTileLayer = /** @class */ (function (_super) {
      __extends$3(WebTileLayer, _super);
      function WebTileLayer(options, map) {
          if (!defined$1(options.url)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ type: "xyz", visible: true }, options), map) || this;
      }
      Object.defineProperty(WebTileLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WebTileLayer.prototype.init = function () {
          this._initialized = true;
          this._layer = _createWebTile(this.options);
      };
      WebTileLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WebTileLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      WebTileLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return WebTileLayer;
  }(Layer));
  function _createWebTile(options) {
      var _options = __assign$1({}, options);
      if (_options.type === "aef") {
          _options.url = _options.url.replace("{x}", "{Column}").replace("{y}", "{Row}").replace("{z}", "{Level}");
          _options = __assign$1(__assign$1({}, _options), { customTags: {
                  Level: function (imageryProvider, x, y, level) {
                      return "L" + zeroPad(level, 2, 10);
                  },
                  Row: function (imageryProvider, x, y, level) {
                      return "R" + zeroPad(y, 8, 16);
                  },
                  Column: function (imageryProvider, x, y, level) {
                      return "C" + zeroPad(x, 8, 16);
                  }
              } });
      }
      if (defined$1(_options.tilingScheme)) {
          if (_options.tilingScheme === TilingSchemeType.GEOGRAPHIC) {
              _options.tilingScheme = new Cesium__namespace.GeographicTilingScheme();
          }
          if (_options.tilingScheme === TilingSchemeType.MERCATOR) {
              _options.tilingScheme = new Cesium__namespace.WebMercatorTilingScheme();
          }
      }
      return [
          Object.assign(new Cesium__namespace.ImageryLayer(new Cesium__namespace.UrlTemplateImageryProvider(_options), _options), {
              id: options.id
          })
      ];
  }
  function zeroPad(num, len, radix) {
      var str = num.toString(radix || 10);
      while (str.length < len) {
          str = "0" + str;
      }
      return str;
  }

  var WMSLayer = /** @class */ (function (_super) {
      __extends$3(WMSLayer, _super);
      function WMSLayer(options, map) {
          if (!defined$1(options.url) || !defined$1(options.layers)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ visible: true, opacity: 1, tile: true, format: "image/png", transparent: false }, options), map) || this;
      }
      Object.defineProperty(WMSLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WMSLayer.prototype.init = function () {
          this._initialized = true;
          this._layer = _createWMS(this.options);
      };
      WMSLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WMSLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      WMSLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      WMSLayer.prototype.setParams = function (param) {
          throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
      };
      return WMSLayer;
  }(Layer));
  function _createWMS(options) {
      var _options = __assign$1({}, options);
      _options.parameters = __assign$1(__assign$1({}, Cesium__namespace.WebMapServiceImageryProvider.DefaultParameters), _options);
      return [
          Object.assign(new Cesium__namespace.ImageryLayer(new Cesium__namespace.WebMapServiceImageryProvider(__assign$1({}, _options))), { id: options.id })
      ];
  }

  var WMTSLayer = /** @class */ (function (_super) {
      __extends$3(WMTSLayer, _super);
      function WMTSLayer(options, map) {
          if (!defined$1(options.url) || !defined$1(options.layer) || !defined$1(options.matrixSet)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ visible: true, style: "default", format: "image/jpeg" }, options), map) || this;
      }
      Object.defineProperty(WMTSLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WMTSLayer.prototype.init = function () {
          this._initialized = true;
          this.layer = _createWMTS(this.options);
      };
      WMTSLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WMTSLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      WMTSLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return WMTSLayer;
  }(Layer));
  function _createWMTS(options) {
      var _a;
      var _options = __assign$1({}, options);
      _options.tileMatrixSetID = _options.matrixSet;
      delete _options.matrixSet;
      _options.tileMatrixLabels = _options.matrixIds;
      delete _options.matrixIds;
      if (defined$1(_options.tilingScheme)) {
          if (_options.tilingScheme === TilingSchemeType.GEOGRAPHIC) {
              _options.tilingScheme = new Cesium__namespace.GeographicTilingScheme();
          }
          if (_options.tilingScheme === TilingSchemeType.MERCATOR) {
              _options.tilingScheme = new Cesium__namespace.WebMercatorTilingScheme();
          }
      }
      if (defined$1(_options.extent)) {
          _options.extent = options.extent.map(function (num) {
              return Cesium__namespace.Math.toRadians(num);
          });
          _options.rectangle = new ((_a = Cesium__namespace.Rectangle).bind.apply(_a, __spreadArray$1([void 0], __read(_options.extent), false)))();
      }
      return [
          Object.assign(new Cesium__namespace.ImageryLayer(new Cesium__namespace.WebMapTileServiceImageryProvider(_options), _options), { id: options.id })
      ];
  }

  var simpleheat$1 = {exports: {}};

  (function (module) {

  module.exports = simpleheat;

  function simpleheat(canvas, width, height) {
      if (!(this instanceof simpleheat)) return new simpleheat(canvas, width, height);

      this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;

      this._ctx = canvas.getContext('2d');
      this._canvas.width = width;
      this._canvas.height = height;
      this._width = width;
      this._height = height;

      this._max = 1;
      this._data = [];
  }

  simpleheat.prototype = {

      defaultRadius: 25,

      defaultGradient: {
          0.4: 'blue',
          0.6: 'cyan',
          0.7: 'lime',
          0.8: 'yellow',
          1.0: 'red'
      },

      data: function (data) {
          this._data = data;
          return this;
      },

      max: function (max) {
          this._max = max;
          return this;
      },

      add: function (point) {
          this._data.push(point);
          return this;
      },

      clear: function () {
          this._data = [];
          return this;
      },

      radius: function (r, blur) {
          blur = blur === undefined ? 40 : blur;

          // create a grayscale blurred circle image that we'll use for drawing points
          var circle = this._circle = this._createCanvas(),
              ctx = circle.getContext('2d'),
              r2 = this._r = r + blur;

          circle.width = circle.height = r2 * 2;

          ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
          ctx.shadowBlur = blur;
          ctx.shadowColor = 'black';

          ctx.beginPath();
          ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fill();

          return this;
      },

      resize: function () {
          this._width = this._canvas.width;
          this._height = this._canvas.height;
      },

      gradient: function (grad) {
          // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
          var canvas = this._createCanvas(),
              ctx = canvas.getContext('2d'),
              gradient = ctx.createLinearGradient(0, 0, 0, 256);

          canvas.width = 1;
          canvas.height = 256;

          for (var i in grad) {
              gradient.addColorStop(+i, grad[i]);
          }

          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 1, 256);

          this._grad = ctx.getImageData(0, 0, 1, 256).data;

          return this;
      },

      draw: function (minOpacity) {
          if (!this._circle) this.radius(this.defaultRadius);
          if (!this._grad) this.gradient(this.defaultGradient);

          var ctx = this._ctx;

          ctx.clearRect(0, 0, this._width, this._height);

          // draw a grayscale heatmap by putting a blurred circle at each data point
          for (var i = 0, len = this._data.length, p; i < len; i++) {
              p = this._data[i];
              ctx.globalAlpha = Math.min(Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity), 1);
              ctx.drawImage(this._circle, p[0] - this._r, (this._height - p[1]) - this._r);
          }

          // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
          var colored = ctx.getImageData(0, 0, this._width, this._height);
          this._colorize(colored.data, this._grad);
          ctx.putImageData(colored, 0, 0);

          return this;
      },

      _colorize: function (pixels, gradient) {
          for (var i = 0, len = pixels.length, j; i < len; i += 4) {
              j = pixels[i + 3] * 4; // get gradient color from opacity value

              if (j) {
                  pixels[i] = gradient[j];
                  pixels[i + 1] = gradient[j + 1];
                  pixels[i + 2] = gradient[j + 2];
              }
          }
      },

      _createCanvas: function () {
          if (typeof document !== 'undefined') {
              return document.createElement('canvas');
          } else {
              // create a new canvas instance in node.js
              // the canvas class needs to have a default constructor without any parameter
              return new this._canvas.constructor();
          }
      }
  };
  }(simpleheat$1));

  var simpleheat = simpleheat$1.exports;

  /**
   * @module helpers
   */
  /**
   * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
   *
   * @name feature
   * @param {Geometry} geometry input geometry
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature} a GeoJSON Feature
   * @example
   * var geometry = {
   *   "type": "Point",
   *   "coordinates": [110, 50]
   * };
   *
   * var feature = turf.feature(geometry);
   *
   * //=feature
   */
  function feature$2(geom, properties, options) {
      if (options === void 0) { options = {}; }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
          feat.id = options.id;
      }
      if (options.bbox) {
          feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
  }
  /**
   * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
   *
   * @name polygon
   * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<Polygon>} Polygon Feature
   * @example
   * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
   *
   * //=polygon
   */
  function polygon(coordinates, properties, options) {
      if (options === void 0) { options = {}; }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
              throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
              // Check if first point of Polygon contains two numbers
              if (ring[ring.length - 1][j] !== ring[0][j]) {
                  throw new Error("First and last Position are not equivalent.");
              }
          }
      }
      var geom = {
          type: "Polygon",
          coordinates: coordinates,
      };
      return feature$2(geom, properties, options);
  }

  /**
   * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
   *
   * @name getCoord
   * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
   * @returns {Array<number>} coordinates
   * @example
   * var pt = turf.point([10, 10]);
   *
   * var coord = turf.getCoord(pt);
   * //= [10, 10]
   */
  function getCoord(coord) {
      if (!coord) {
          throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
          if (coord.type === "Feature" &&
              coord.geometry !== null &&
              coord.geometry.type === "Point") {
              return coord.geometry.coordinates;
          }
          if (coord.type === "Point") {
              return coord.coordinates;
          }
      }
      if (Array.isArray(coord) &&
          coord.length >= 2 &&
          !Array.isArray(coord[0]) &&
          !Array.isArray(coord[1])) {
          return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  /**
   * Get Geometry from Feature or Geometry Object
   *
   * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
   * @returns {Geometry|null} GeoJSON Geometry Object
   * @throws {Error} if geojson is not a Feature or Geometry Object
   * @example
   * var point = {
   *   "type": "Feature",
   *   "properties": {},
   *   "geometry": {
   *     "type": "Point",
   *     "coordinates": [110, 40]
   *   }
   * }
   * var geom = turf.getGeom(point)
   * //={"type": "Point", "coordinates": [110, 40]}
   */
  function getGeom(geojson) {
      if (geojson.type === "Feature") {
          return geojson.geometry;
      }
      return geojson;
  }

  // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
  // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
  // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
  /**
   * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
   * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
   *
   * @name booleanPointInPolygon
   * @param {Coord} point input point
   * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
   * @param {Object} [options={}] Optional parameters
   * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
   * the point is inside the polygon otherwise false.
   * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
   * @example
   * var pt = turf.point([-77, 44]);
   * var poly = turf.polygon([[
   *   [-81, 41],
   *   [-81, 47],
   *   [-72, 47],
   *   [-72, 41],
   *   [-81, 41]
   * ]]);
   *
   * turf.booleanPointInPolygon(pt, poly);
   * //= true
   */
  function booleanPointInPolygon(point, polygon, options) {
      if (options === void 0) { options = {}; }
      // validation
      if (!point) {
          throw new Error("point is required");
      }
      if (!polygon) {
          throw new Error("polygon is required");
      }
      var pt = getCoord(point);
      var geom = getGeom(polygon);
      var type = geom.type;
      var bbox = polygon.bbox;
      var polys = geom.coordinates;
      // Quick elimination if point is not inside bbox
      if (bbox && inBBox(pt, bbox) === false) {
          return false;
      }
      // normalize to multipolygon
      if (type === "Polygon") {
          polys = [polys];
      }
      var insidePoly = false;
      for (var i = 0; i < polys.length && !insidePoly; i++) {
          // check if it is in the outer ring first
          if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
              var inHole = false;
              var k = 1;
              // check for the point in any of the holes
              while (k < polys[i].length && !inHole) {
                  if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                      inHole = true;
                  }
                  k++;
              }
              if (!inHole) {
                  insidePoly = true;
              }
          }
      }
      return insidePoly;
  }
  /**
   * inRing
   *
   * @private
   * @param {Array<number>} pt [x,y]
   * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
   * @param {boolean} ignoreBoundary ignoreBoundary
   * @returns {boolean} inRing
   */
  function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] &&
          ring[0][1] === ring[ring.length - 1][1]) {
          ring = ring.slice(0, ring.length - 1);
      }
      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          var xi = ring[i][0];
          var yi = ring[i][1];
          var xj = ring[j][0];
          var yj = ring[j][1];
          var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&
              (xi - pt[0]) * (xj - pt[0]) <= 0 &&
              (yi - pt[1]) * (yj - pt[1]) <= 0;
          if (onBoundary) {
              return !ignoreBoundary;
          }
          var intersect = yi > pt[1] !== yj > pt[1] &&
              pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;
          if (intersect) {
              isInside = !isInside;
          }
      }
      return isInside;
  }
  /**
   * inBBox
   *
   * @private
   * @param {Position} pt point [x,y]
   * @param {BBox} bbox BBox [west, south, east, north]
   * @returns {boolean} true/false if point is inside BBox
   */
  function inBBox(pt, bbox) {
      return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);
  }

  /**
   * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
   *
   * @name bboxPolygon
   * @param {BBox} bbox extent in [minX, minY, maxX, maxY] order
   * @param {Object} [options={}] Optional parameters
   * @param {Properties} [options.properties={}] Translate properties to Polygon
   * @param {string|number} [options.id={}] Translate Id to Polygon
   * @returns {Feature<Polygon>} a Polygon representation of the bounding box
   * @example
   * var bbox = [0, 0, 10, 10];
   *
   * var poly = turf.bboxPolygon(bbox);
   *
   * //addToMap
   * var addToMap = [poly]
   */
  function bboxPolygon(bbox, options) {
      if (options === void 0) { options = {}; }
      // Convert BBox positions to Numbers
      // No performance loss for including Number()
      // https://github.com/Turfjs/turf/issues/1119
      var west = Number(bbox[0]);
      var south = Number(bbox[1]);
      var east = Number(bbox[2]);
      var north = Number(bbox[3]);
      if (bbox.length === 6) {
          throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
      }
      var lowLeft = [west, south];
      var topLeft = [west, north];
      var topRight = [east, north];
      var lowRight = [east, south];
      return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox, id: options.id });
  }

  /**
   * 热力图
   */
  var HeatLayer = /** @class */ (function (_super) {
      __extends$3(HeatLayer, _super);
      function HeatLayer(options, map) {
          return _super.call(this, __assign$1({ data: [], heightPixel: 1080, max: 3, min: 19, maxBlur: 20, minBlur: 1.5, maxRadius: 40, minRadius: 3, gradient: { 0.4: "blue", 0.6: "cyan", 0.7: "lime", 0.8: "yellow", 1: "red" } }, options), map) || this;
      }
      Object.defineProperty(HeatLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HeatLayer.prototype, "layer", {
          /**
           * @ignore
           */
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      HeatLayer.prototype.init = function () {
          var _this = this;
          this._initialized = true;
          this._heatmap = simpleheat(document.createElement("canvas"), 10, 10);
          var data = this._data;
          // 不为空，且数组有数据
          if (data && data.length > 0) {
              this._data = [];
              this._addData(data);
          }
          else {
              this.setData(this.options.data);
          }
          // 相机移动事件监听
          this._removeMoveEndEvent = this.map.map.camera.moveEnd.addEventListener(function () { return _this._update(true); });
      };
      /**
       * @ignore
       */
      HeatLayer.prototype.addTo = function (map) {
          var _this = this;
          var _a;
          _super.prototype.addTo.call(this, map);
          (_a = this.layer) === null || _a === void 0 ? void 0 : _a.forEach(function (l) {
              _this.map.map.scene.imageryLayers.add(l);
          });
          this._update(true);
      };
      /**
       * @ignore
       */
      HeatLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (l) {
              _this.map.map.scene.imageryLayers.remove(l, false);
          });
          this.map = void 0;
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._destroy = function () {
          this._heatmap = void 0;
          this._convertedData = void 0;
          this._data = void 0;
          if (this._removeMoveEndEvent) {
              this._removeMoveEndEvent();
              this._removeMoveEndEvent = void 0;
          }
          if (this._mountPoint) {
              this._mountPoint.remove();
              this._mountPoint = void 0;
          }
          this.remove();
          this.layer.forEach(function (l) {
              l.isDestroyed || l.destroy();
          });
          this._layer.length = 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 更新cesium显示
       * @param {*} updateHeat
       * @ignore
       */
      HeatLayer.prototype._update = function (flag) {
          var _a;
          var _this = this;
          var _b;
          if (!this.map || !this._heatmap) {
              return;
          }
          this._updateHeatMapConfig();
          if (this._bboxData.length === 0) {
              return;
          }
          // 保存上一图层
          var previousLayer;
          // 获取上一图层
          if (this._layer && this._layer[0]) {
              previousLayer = this._layer[0];
          }
          // 是否更新
          if (flag) {
              this._updateConvertedData(this._bboxData);
              // 获取相机高度
              var height = this.map.map.camera.positionCartographic.height;
              var params = ((_b = this.options.renderFunction) === null || _b === void 0 ? void 0 : _b.call(this, heightToZoom(height))) || this._layerParams.call(this, height);
              if (this._radius && this._radius === params.radius) {
                  return;
              }
              this._radius = params.radius;
              this._heatmap.radius(this._radius, params.blur);
              this._heatmap.gradient(params.gradient);
          }
          if (this._heatmap._canvas.width === 0 || this._heatmap._canvas.height === 0) {
              return;
          }
          this._heatmap.data(this._convertedData);
          this._heatmap.draw();
          var dataURL = this._heatmap._canvas.toDataURL();
          if (dataURL.length < 10 || this._bbox[0] === 0 || this._bbox[0] === this._bbox[2]) {
              return;
          }
          var provider = new Cesium__namespace.SingleTileImageryProvider({
              url: dataURL,
              rectangle: (_a = Cesium__namespace.Rectangle).fromDegrees.apply(_a, __spreadArray$1([], __read(this._bbox), false))
          });
          this._layer = [
              new Cesium__namespace.ImageryLayer(provider, __assign$1(__assign$1({}, this._options), { show: this.visible }))
          ];
          this.layer.forEach(function (l) {
              _this.map.map.scene.imageryLayers.add(l);
          });
          setTimeout(function () {
              if (previousLayer) {
                  previousLayer.show = false;
                  previousLayer.isDestroyed || _this.map.map.scene.imageryLayers.remove(previousLayer);
              }
          }, 100);
      };
      /**
       * 添加数据
       *
       * 点数据须存在`value`属性,属性值类型为`number`
       */
      HeatLayer.prototype.addData = function (data, options) {
          this._addData(heatDataTransformer(data, options));
          return this;
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._addData = function (heatData) {
          this._data = this._data.concat(heatData);
          if (!this.map) {
              return;
          }
          this._updateHeatMapConfig();
          this._addConvertedData(heatData);
          this._update(true);
      };
      /**
       * 设置数据
       *
       * 点数据须存在`value`属性,属性值类型为`number`
       */
      HeatLayer.prototype.setData = function (data, options) {
          this._data = [];
          this._convertedData = [];
          this.addData(data, options);
          return this;
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._updateHeatMapConfig = function () {
          if (this._bboxData && Math.abs(this.map.orientation[1]) < 40) {
              return;
          }
          var heightPixel = this.options.heightPixel;
          // 地图当前范围
          var bbox = this.map.currentExtent;
          // 将范围转化为多边形
          var bboxPolygon$1 = bboxPolygon(bbox);
          // 获取当前地图范围的数据
          this._bboxData = this._data.filter(function (i) {
              return booleanPointInPolygon([i.x, i.y], bboxPolygon$1);
          });
          var data = this._bboxData;
          // 数据存在，返回数据范围，否则返回当前地图范围
          this._bbox = data.length > 1 ? getBbox(data, 0) : bbox;
          var dw1 = (this._bbox[2] - this._bbox[0]) / 2, dh1 = (this._bbox[3] - this._bbox[1]) / 2;
          this._bbox[0] -= dw1;
          this._bbox[2] += dw1;
          this._bbox[1] -= dh1;
          this._bbox[3] += dh1;
          this._updateBoxMeta(this._bbox);
          var h = Math.floor(heightPixel) || 1;
          var w = Math.floor((heightPixel * this._boxMeta.width) / this._boxMeta.height) || 1;
          this._height = h;
          this._width = w;
          if (this.initialized) {
              this._updateCanvas();
          }
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._updateCanvas = function () {
          this._heatmap._canvas.height = this._height;
          this._heatmap._canvas.width = this._width;
          this._heatmap.resize();
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._addConvertedData = function (data) {
          var _this = this;
          this._convertedData = this._convertedData.concat(data.map(function (i) {
              // 更新数据中的最大值
              _this._updateMaxMin(i.value);
              // 将经纬度坐标转化为像素坐标
              return _this._convertData(i);
          }));
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._layerParams = function (height) {
          // 获取最大最小半径、最大最小模糊度
          var _a = this.options, minRadius = _a.minRadius, maxRadius = _a.maxRadius, gradient = _a.gradient, maxBlur = _a.maxBlur, minBlur = _a.minBlur;
          // 地图的最大最小缩放级别，并转化为最大最小高度
          var minHeight = zoomToHeight(this.options.min);
          var maxHeight = zoomToHeight(this.options.max);
          // 根据比例尺计算
          var radius = parseFloat((minRadius +
              (maxRadius - minRadius) * Cesium__namespace.EasingFunction.EXPONENTIAL_OUT((height - minHeight) / (maxHeight - minHeight))).toFixed(3));
          var blur = parseFloat((minBlur +
              (maxBlur - minBlur) * Cesium__namespace.EasingFunction.EXPONENTIAL_OUT((height - minHeight) / (maxHeight - minHeight))).toFixed(3));
          return { radius: radius, blur: blur, gradient: gradient };
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._updateConvertedData = function (data) {
          this._convertedData = [];
          this._addConvertedData(data);
      };
      /**
       * @ignore
       */
      HeatLayer.prototype._updateBoxMeta = function (bbox) {
          var _a = __read(bbox, 4), left = _a[0], bottom = _a[1], right = _a[2], top = _a[3];
          var height = top - bottom, width = right - left;
          this._boxMeta = {
              top: top,
              left: left,
              height: height,
              width: width
          };
      };
      /**
       * 更新最大值最小值
       * @param {number} value
       * @ignore
       */
      HeatLayer.prototype._updateMaxMin = function (value) {
          var _a;
          if (this._max === void 0) {
              this._max = value;
          }
          else {
              this._max = Math.max(value, this._max);
          }
          if (this._min === void 0) {
              this._min = value;
          }
          else {
              this._min = Math.min(value, this._min);
          }
          (_a = this._heatmap) === null || _a === void 0 ? void 0 : _a.max(this._max);
      };
      /**
       * 转换坐标，将经纬度坐标转为像素坐标
       * @ignore
       */
      HeatLayer.prototype._convertData = function (_a) {
          var x = _a.x, y = _a.y, value = _a.value;
          var _b = __read(this._gps2point([x, y]), 2), px = _b[0], py = _b[1];
          return [px, py, value];
      };
      /**
       * 将经纬度坐标转为像素坐标
       * @ignore
       */
      HeatLayer.prototype._gps2point = function (gps) {
          if (gps === void 0) { gps = []; }
          var _a = __read(gps, 2), x1 = _a[0], y1 = _a[1];
          var _b = this._boxMeta, top = _b.top, left = _b.left, height = _b.height, width = _b.width;
          return [
              parseInt(((x1 - left) / width) * this._width + ""),
              parseInt((1 - (top - y1) / height) * this._height + "")
          ];
      };
      return HeatLayer;
  }(Layer));
  // 数据转换器
  function heatDataTransformer(data, options) {
      return dataToFeatures(data, options).map(function (f) { return ({
          x: f.coordinates[0],
          y: f.coordinates[1],
          value: f.properties.value
      }); });
  }

  var ArcGISLayer = /** @class */ (function (_super) {
      __extends$3(ArcGISLayer, _super);
      function ArcGISLayer(options, map) {
          return _super.call(this, __assign$1({ maxLevel: 18, visible: true }, options), map) || this;
      }
      Object.defineProperty(ArcGISLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      ArcGISLayer.prototype.init = function () {
          this._initialized = true;
          this.options.maximumLevel = this.options.maxLevel;
          this._layer = [
              Object.assign(new Cesium__namespace.ImageryLayer(new Cesium__namespace.ArcGisMapServerImageryProvider(__assign$1({}, this.options)), __assign$1({}, this.options)), { id: this.id })
          ];
      };
      ArcGISLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.add(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      ArcGISLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.imageryLayers.remove(i, destroy); });
          this.map = void 0;
      };
      /**
       * @ignore
       */
      ArcGISLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.isDestroyed() || i.destroy(); });
          this.layer = void 0;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return ArcGISLayer;
  }(Layer));

  /**
   * Code
   */

  var index$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Layer: Layer,
    AMapLayer: AMapLayer,
    BMapLayer: BMapLayer,
    get BDMapType () { return BDMapType; },
    StaticImageLayer: StaticImageLayer,
    TMapLayer: TMapLayer,
    VectorLayer: VectorLayer,
    WebTileLayer: WebTileLayer,
    WMSLayer: WMSLayer,
    WMTSLayer: WMTSLayer,
    get TilingSchemeType () { return TilingSchemeType; },
    HeatLayer: HeatLayer,
    TerrainLayer: TerrainLayer,
    ArcGISLayer: ArcGISLayer
  });

  /**
   * 绘制类别
   *
   * @enum {number}
   */
  var DrawType;
  (function (DrawType) {
      /**
       * 点
       */
      DrawType["POINT"] = "point";
      DrawType["CIRCLE"] = "circle";
      /**
       * 面
       */
      DrawType["POLYGON"] = "polygon";
      /**
       * 线
       */
      DrawType["POLYLINE"] = "polyline";
      DrawType["ARC"] = "arc";
      DrawType["ELLIPSE"] = "ellipse";
      DrawType["CURVE"] = "curve";
      DrawType["CLOSED_CURVE"] = "closedcurve";
      DrawType["LUNE"] = "lune";
      DrawType["SECTOR"] = "sector";
      DrawType["GATHERING_PLACE"] = "gatheringplace";
      DrawType["STRAIGHT_ARROW"] = "straightarrow";
      DrawType["ASSAULT_DIRECTION"] = "assaultdirection";
      DrawType["ATTACK_ARROW"] = "attackarrow";
      DrawType["SQUAD_COMBAT"] = "squadcombat";
      DrawType["TAILED_SQUAD_COMBAT"] = "tailedsquadcombat";
      DrawType["FINE_ARROW"] = "finearrow";
      DrawType["DOUBLE_ARROW"] = "doublearrow";
      DrawType["RECTANGLE"] = "rectangle";
  })(DrawType || (DrawType = {}));

  /**
   * 抽象几何体
   */
  var Geometry = /** @class */ (function () {
      function Geometry(type, points) {
          this._fixPointCount = 0;
          this._coordinates = [];
          this._type = type;
          this.setPoints(points);
      }
      Object.defineProperty(Geometry.prototype, "fixPointCount", {
          get: function () {
              return this._fixPointCount;
          },
          set: function (count) {
              this._fixPointCount = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Geometry.prototype, "type", {
          get: function () {
              return this._type;
          },
          set: function (type) {
              this._type = type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Geometry.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Geometry.prototype.setPoints = function (points) {
          this._points = points ? points : [];
          if (this._points.length >= 1)
              this.generate();
      };
      Geometry.prototype.generate = function () {
          throw new Error("该方法未实现");
      };
      Geometry.prototype.setCoordinates = function (coordinates) {
          this._coordinates = coordinates;
      };
      Geometry.prototype.getPoints = function () {
          return this._points.slice(0);
      };
      Geometry.prototype.getPointCount = function () {
          return this._points.length;
      };
      Geometry.prototype.updatePoint = function (point, index) {
          if (index >= 0 && index < this._points.length) {
              this._points[index] = point;
              this.generate();
          }
      };
      Geometry.prototype.updateLastPoint = function (point) {
          this.updatePoint(point, this._points.length - 1);
      };
      Geometry.prototype.finishDrawing = function () { };
      return Geometry;
  }());

  var Circle$1 = /** @class */ (function (_super) {
      __extends$3(Circle, _super);
      function Circle(points, minRadius, maxRadius) {
          var _this = _super.call(this, DrawType.CIRCLE, points) || this;
          _this.fixPointCount = 2;
          _this._minRadius = minRadius || 50 / 1000;
          _this._maxRadius = maxRadius || Number.MAX_VALUE;
          return _this;
      }
      Object.defineProperty(Circle.prototype, "projectionRadius", {
          get: function () {
              return this._projectionRadius;
          },
          set: function (value) {
              this._projectionRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "ellipsoidRaduis", {
          get: function () {
              return this._ellipsoidRaduis;
          },
          set: function (value) {
              this._ellipsoidRaduis = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "minRadius", {
          set: function (value) {
              this._minRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "maxRadius", {
          set: function (value) {
              this._maxRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Circle.prototype.generate = function () {
          var count = this.getPointCount();
          this.center = this.getPoints()[0];
          if (count < 2) {
              return;
          }
          var radius = calculatesRadius(this.getPoints()[0], this.getPoints()[1]);
          this.projectionRadius = convertToProjectionRadius(this.getPoints()[0], radius);
          if (radius <= this._minRadius) {
              radius = this._minRadius;
          }
          if (radius >= this._maxRadius) {
              radius = this._maxRadius;
          }
          var point = Turf__namespace.transformTranslate(Turf__namespace.point(this.center), radius, 90).geometry.coordinates;
          // @ts-ignore
          this._points[1] = point;
          this.ellipsoidRaduis = radius;
          this.setCoordinates([this.generatePoints(this.getPoints()[0], radius)]);
      };
      Circle.prototype.generatePoints = function (center, radius) {
          return getCircleCoordinates(center, radius);
      };
      return Circle;
  }(Geometry));

  /**
   * 圆要素
   */
  var Circle = /** @class */ (function (_super) {
      __extends$3(Circle, _super);
      /**
       * @param options
       * @param layer
       */
      function Circle(_a, layer) {
          var center = _a.center, radius = _a.radius, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: center, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }) || this;
          _this._radius = radius;
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Circle.prototype, "coordinates", {
          /**
           * 要素坐标
           */
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "center", {
          /**
           * 圆心坐标
           */
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "radius", {
          /**
           * 半径 单位: 米
           */
          get: function () {
              return this._radius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "wkt", {
          get: function () {
              throw new Error(ErrorNotification.NOT_SUPPORTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "geoJson", {
          get: function () {
              var center = __spreadArray$1([], __read(this.center), false);
              return point(center, {
                  shape: "Circle",
                  radius: this.radius,
                  center: center
              });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "type", {
          get: function () {
              return FeatureType.CIRCLE;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Circle.prototype.init = function (styles) {
          var e_1, _a;
          var featureGeometry = {
              entities: [],
              primitives: [],
              geometryInstances: [],
              labels: []
          };
          try {
              for (var styles_1 = __values(styles), styles_1_1 = styles_1.next(); !styles_1_1.done; styles_1_1 = styles_1.next()) {
                  var style = styles_1_1.value;
                  buildGeometry.call(this, style, featureGeometry);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (styles_1_1 && !styles_1_1.done && (_a = styles_1.return)) _a.call(styles_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          if (this.radius > 0) {
              if (!this.get("isPlot")) {
                  this.set("isPlot", true);
                  var dragPointCoordinates = Turf__namespace.transformTranslate(this.geoJson, this.radius / 1000, 90).geometry
                      .coordinates;
                  var plot = new Circle$1([this.center, dragPointCoordinates]);
                  this.set("plot", plot);
              }
          }
          return featureGeometry;
      };
      /**
       * @ignore
       * @param coordinates
       */
      Circle.prototype.setCoordinates = function (coordinates, options) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      /**
       *  设置中心点坐标
       */
      Circle.prototype.setCenter = function (center, options) {
          if (Cesium__namespace.defined(center)) {
              var f = false;
              for (var index = 0, l = Math.max(this.coordinates.length, center.length); index < l; index++) {
                  f || (f = this.coordinates[index] !== center[index]);
              }
              if (f) {
                  this._coordinates = center;
                  setFeatureProjection.call(this, options);
                  refreshGeometry.call(this, { center: center });
              }
          }
          return this;
      };
      Circle.prototype.setRadius = function (radius) {
          if (this.radius !== radius) {
              this._radius = radius;
              refreshGeometry.call(this, { semiMajorAxis: radius, semiMinorAxis: radius });
          }
          return this;
      };
      return Circle;
  }(Feature));
  function refreshGeometry(_a) {
      _a.center; _a.semiMajorAxis; _a.semiMinorAxis; _a.rotation;
      // const primitiveIndex = this.style.findIndex((val) => val.type !== StyleItemType.ELLIPSE_ENTITY);
      // if (primitiveIndex === -1) {
      //   const { entities } = this.sourceFeature;
      //   for (const iterator of entities) {
      //     if (Cesium.defined(center)) {
      //       (iterator.position as Cesium.ConstantPositionProperty).setValue(degreesToCartesian3(center, this.layer?.globe));
      //     }
      //     if (Cesium.defined(semiMajorAxis)) {
      //       (iterator.ellipse.semiMajorAxis as Cesium.ConstantProperty).setValue(semiMajorAxis);
      //     }
      //     if (Cesium.defined(semiMinorAxis)) {
      //       (iterator.ellipse.semiMinorAxis as Cesium.ConstantProperty).setValue(semiMinorAxis);
      //     }
      //   }
      // } else {
      this._setStyle();
      // }
  }
  var SUPPORT_TYPE_ENTITY = [
      StyleItemType.COLOR,
      StyleItemType.IMAGE,
      StyleItemType.RADIAL_GRADIENT,
      StyleItemType.WATER,
      StyleItemType.RIPPLE,
      StyleItemType.ROTATE,
      StyleItemType.LABEL
  ];
  function buildGeometry(styleItem, store) {
      if (!SUPPORT_TYPE_ENTITY.includes(styleItem.type)) {
          console.warn(ErrorNotification.NOT_SUPPORTED_STYLE_TYPE);
          return [];
      }
      if (styleItem.entity) {
          buildEllipseEntity.call(this, styleItem, store.entities);
      }
      else {
          buildEllipseInstance.call(this, styleItem, styleItem.type === StyleItemType.LABEL ? store.labels : store.geometryInstances);
      }
  }
  Object.keys(StyleItemType)
      .map(function (i) { return StyleItemType[i]; })
      .filter(function (i) { return i !== StyleItemType.WATER && i !== StyleItemType.CIRCLE; });
  function buildEllipseInstance(styleItem, storeArray) {
      var _a = this, coordinates = _a.coordinates, radius = _a.radius;
      var res = [];
      var pointCoordinate = transformInternal(coordinates, {
          source: this.dataProjection,
          destination: this.projection,
          offset: this.offset
      });
      if (styleItem.type === StyleItemType.LABEL) {
          var height = this.styleItemList.reduce(function (prev, curr) {
              if (defined$1(curr.extrudedHeight)) {
                  if (!defined$1(prev) || prev < curr.extrudedHeight) {
                      prev = curr.extrudedHeight;
                  }
              }
              return prev;
          }, void 0);
          if (defined$1(height)) {
              pointCoordinate[2] = height;
          }
          defined$1(styleItem.extrudedHeight) && (pointCoordinate[2] = styleItem.extrudedHeight);
          res.push(buildLabelOptions.call(this, {
              coordinate: pointCoordinate,
              styleItem: styleItem,
              properties: this.properties
          }));
      }
      else {
          var centerCartesian3 = degreesToCartesian3(pointCoordinate, this.map);
          var ellipse = new Cesium__namespace.GeometryInstance(__assign$1(__assign$1({ geometry: new Cesium__namespace.EllipseGeometry(__assign$1({ center: centerCartesian3, semiMajorAxis: radius, semiMinorAxis: radius }, styleItem)) }, (styleItem.type === StyleItemType.COLOR
              ? {
                  attributes: {
                      color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(styleItem.fillColor)
                  }
              }
              : {})), styleItem));
          ellipse[geometryInstanceUniqueKeyName] = getUid();
          ellipse[STYLE_LINK] = __assign$1({ flat: true }, styleItem);
          res.push(ellipse);
          if (styleItem.width > 0 &&
              (StyleItemType.COLOR === styleItem.type || StyleItemType.RADIAL_GRADIENT === styleItem.type)) {
              var positions = calculateCircleOutlineCartesian3Points(radius, centerCartesian3, coordinates, styleItem, this.map);
              var outline = new Cesium__namespace.GeometryInstance(__assign$1({ geometry: new Cesium__namespace[styleItem.heightReference === 1 /* CLAMP_TO_GROUND */
                      ? "GroundPolylineGeometry"
                      : "PolylineGeometry"](__assign$1({ positions: positions }, styleItem)), attributes: {
                      color: Cesium__namespace.ColorGeometryInstanceAttribute.fromColor(styleItem.borderColor)
                  } }, styleItem));
              outline[geometryInstanceUniqueKeyName] = getUid();
              outline[STYLE_LINK] = defined$1(styleItem.lineDash)
                  ? __assign$1(__assign$1({}, styleItem), { color: styleItem.borderColor, dashLength: styleItem.lineDash[0] * 2, type: "polylineDash" }) : __assign$1(__assign$1({}, styleItem), { type: "color" });
              res.push(outline);
          }
      }
      arraySelfConcat(storeArray, res);
  }
  function buildEllipseEntity(styleItem, entities) {
      var e_2, _a, e_3, _b;
      var _c = this, coordinates = _c.coordinates, radius = _c.radius;
      var pointCoordinate = transformInternal(coordinates, {
          source: this.dataProjection,
          destination: this.projection,
          offset: this.offset
      });
      var centerCartesian3 = degreesToCartesian3(pointCoordinate, this.map);
      var entityOptions = {};
      if (styleItem.type === StyleItemType.LABEL) {
          var height = this.styleItemList.reduce(function (prev, curr) {
              if (defined$1(curr.extrudedHeight)) {
                  if (!defined$1(prev) || prev < curr.extrudedHeight) {
                      prev = curr.extrudedHeight;
                  }
              }
              return prev;
          }, void 0);
          if (defined$1(height)) {
              pointCoordinate[2] = height;
          }
          defined$1(styleItem.extrudedHeight) && (pointCoordinate[2] = styleItem.extrudedHeight);
          entityOptions.position = degreesToCartesian3(pointCoordinate, this.map);
          entityOptions.label = buildLabelGraphics({ styleItem: styleItem, properties: this.properties });
      }
      else {
          entityOptions.position = degreesToCartesian3(pointCoordinate, this.map);
          var material = styleItemToMaterialProperty(styleItem);
          if (styleItem.width > 0 &&
              (StyleItemType.COLOR === styleItem.type || StyleItemType.RADIAL_GRADIENT === styleItem.type)) {
              entityOptions.polyline = new Cesium__namespace.PolylineGraphics(__assign$1(__assign$1({ positions: calculateCircleOutlineCartesian3Points(radius, centerCartesian3, coordinates, styleItem, this.map) }, styleItem), { material: styleItemBorderColorToColorMaterialProperty(styleItem) }));
          }
          entityOptions.ellipse = new Cesium__namespace.EllipseGraphics(__assign$1({ semiMajorAxis: radius, semiMinorAxis: radius, 
              // height: 0,
              outline: false, material: material }, styleItem));
      }
      try {
          for (var _d = __values(["label", "polyline", "ellipse"]), _e = _d.next(); !_e.done; _e = _d.next()) {
              var key = _e.value;
              if (defined$1(entityOptions[key])) {
                  try {
                      for (var entities_1 = (e_3 = void 0, __values(entities)), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                          var entity = entities_1_1.value;
                          if (!defined$1(entity[key])) {
                              entity[key] = entityOptions[key];
                              delete entityOptions[key];
                              break;
                          }
                      }
                  }
                  catch (e_3_1) { e_3 = { error: e_3_1 }; }
                  finally {
                      try {
                          if (entities_1_1 && !entities_1_1.done && (_b = entities_1.return)) _b.call(entities_1);
                      }
                      finally { if (e_3) throw e_3.error; }
                  }
              }
          }
      }
      catch (e_2_1) { e_2 = { error: e_2_1 }; }
      finally {
          try {
              if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
          }
          finally { if (e_2) throw e_2.error; }
      }
      if (defined$1(entityOptions.label) || defined$1(entityOptions.polyline) || defined$1(entityOptions.ellipse)) {
          var entity = new Cesium__namespace.Entity(__assign$1(__assign$1({}, entityOptions), styleItem));
          entity[STYLE_LINK] = styleItem;
          arraySelfConcat(entities, entity);
      }
  }
  function calculateCircleOutlineCartesian3Points(radius, centerCartesian3, coordinates, styleItem, map) {
      // @ts-ignore
      var points = Cesium__namespace.EllipseGeometryLibrary.computeEllipsePositions({
          semiMinorAxis: radius,
          semiMajorAxis: radius,
          rotation: 0,
          granularity: Cesium__namespace.Math.RADIANS_PER_DEGREE,
          center: centerCartesian3
      }, true, false).positions.reduce(function (previousValue, currentValue, currentIndex, array) {
          if (currentIndex % 3 === 2) {
              previousValue.push(new Cesium__namespace.Cartesian3(array[currentIndex - 2], array[currentIndex - 1], array[currentIndex]));
          }
          return previousValue;
      }, []);
      var positions = [];
      var nextIndex = 0;
      var index = 0;
      var span = 0;
      do {
          positions.push(points[nextIndex]);
          if (nextIndex === 0) {
              span = 1;
          }
          else if (index < 13) {
              span = index * 2 + 2;
          }
          else if (index < 24) {
              span -= 2;
          }
          else if (index === 24) {
              span = -1;
          }
          else if (index < 37) {
              span = -1 * ((index - 24) * 2 + 2);
          }
          else {
              span += 2;
          }
          nextIndex += span;
          index++;
      } while (nextIndex > 0);
      positions.push(positions[0]);
      positions.forEach(function (value, index, array) {
          var coordinate = cartesian3ToDegrees(value, map);
          coordinate.length = coordinates.length;
          (styleItem.extrudedHeight > 0 || styleItem.height > 0) &&
              (coordinate[2] = styleItem.extrudedHeight || styleItem.height);
          array[index] = degreesToCartesian3(coordinate, map);
      });
      return positions;
  }

  var index$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Feature: Feature,
    Point: Point$1,
    Polygon: Polygon$1,
    Polyline: Polyline$1,
    Circle: Circle,
    create: create$4
  });

  /**
   * 覆盖物类
   */
  var Overlay = /** @class */ (function (_super) {
      __extends$3(Overlay, _super);
      function Overlay(options, map) {
          var _this = _super.call(this, __assign$1({ offset: [0, 0], positioning: Positioning.BOTTOM_CENTER, useEvent: true, heightReference: HeightReference.NONE, dispatchMapEvent: { wheel: false }, autoAdjustPosition: false }, options)) || this;
          /**
           * @ignore
           */
          _this._initialized = false;
          /**
           * @ignore
           */
          _this._container = document.createElement("div");
          _this._proxyHandle = proxyHandle.bind(_this);
          if (defined$1(map)) {
              map.addOverlay(_this);
          }
          return _this;
      }
      Object.defineProperty(Overlay.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "element", {
          /**
           * 覆盖物`DOM`对象
           */
          get: function () {
              return this._element;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "container", {
          /**
           * 覆盖物容器`DOM`
           *
           * @type {HTMLElement}
           */
          get: function () {
              return this._container;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "offset", {
          /**
           * 覆盖物的偏移量
           *
           * [x,y] x正值为向右偏移,y正值为向下偏移
           */
          get: function () {
              return this._offset;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "position", {
          /**
           * 覆盖物在地球上的位置点
           */
          get: function () {
              return this._position;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "useEvent", {
          /**
           * 覆盖物`DOM`对象是否触发鼠标事件
           *
           * `false` 不触发覆盖物`DOM`鼠标事件
           */
          get: function () {
              return this._useEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "visible", {
          /**
           * 覆盖物显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "positioning", {
          /**
           * 覆盖物定位方式原点位置
           */
          get: function () {
              return this._positioning;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "currentPositioning", {
          /**
           * 覆盖物当前定位方式原点位置
           */
          get: function () {
              return this._currentPositioning || this._positioning;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "currentOffset", {
          /**
           *  @ignore
           */
          get: function () {
              return this._currentOffset || this._offset;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "width", {
          /**
           * @ignore
           */
          get: function () {
              return this._width;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "height", {
          /**
           * @ignore
           */
          get: function () {
              return this._height;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "overlayContainer", {
          /**
           * @ignore
           */
          get: function () {
              return this._overlayContainer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "positionC3", {
          /**
           * @ignore
           */
          get: function () {
              return this._positionC3;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "heightReference", {
          /**
           * 位置高度参考
           *
           * [cesium]
           */
          get: function () {
              return this._heightReference;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "dispatchMapEvent", {
          /**
           * 分发到地图的事件
           */
          get: function () {
              return this._dispatchMapEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "autoAdjustment", {
          /**
           * 是否自动调整弹窗位置，当弹窗会超出地图范围时可进行调整
           */
          get: function () {
              return this._autoAdjustment;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Overlay.prototype.init = function () {
          var _a = this.options, element = _a.element, className = _a.className, offset = _a.offset, positioning = _a.positioning, useEvent = _a.useEvent, position = _a.position, heightReference = _a.heightReference, dispatchMapEvent = _a.dispatchMapEvent, autoAdjustment = _a.autoAdjustment;
          this._element = element;
          this._className = initClassName(className, "mti-gis-overlay");
          this._offset = offset;
          this._positioning = positioning;
          this._useEvent = useEvent;
          this._visible = false;
          this._initialized = true;
          defined$1(this._heightReference) || (this._heightReference = heightReference);
          defined$1(this._dispatchMapEvent) || (this._dispatchMapEvent = dispatchMapEvent);
          defined$1(this._autoAdjustment) || (this._autoAdjustment = autoAdjustment);
          this._initContainer();
          this._initEvent();
          if (defined$1(position)) {
              this.setPosition(position);
          }
      };
      /**
       * @ignore
       */
      Overlay.prototype._initContainer = function () {
          this.container.className = this._className;
          this.container.style.display = "none";
          this.container.appendChild(this.element);
      };
      /**
       * @ignore
       */
      Overlay.prototype._initEvent = function () {
          this._clearEventListen && this._removeEvent();
          this._clearEventListen = this.on(BaseEventType.POST_RENDER, viewChange.bind(this));
          this._initProxyEvent();
      };
      /**
       * @ignore
       */
      Overlay.prototype._initProxyEvent = function () {
          var _this = this;
          Object.keys(this.dispatchMapEvent).forEach(function (key) {
              var _a;
              _this.dispatchMapEvent[key] && ((_a = _this.container) === null || _a === void 0 ? void 0 : _a.addEventListener(key, _this._proxyHandle));
          });
      };
      /**
       * @ignore
       */
      Overlay.prototype._removeEvent = function () {
          this._clearEventListen && this.unByKey(this._clearEventListen);
          this._clearEventListen = void 0;
          this._removeProxyEvent();
      };
      /**
       * @ignore
       */
      Overlay.prototype._removeProxyEvent = function () {
          var _this = this;
          Object.keys(this.dispatchMapEvent).forEach(function (key) {
              var _a;
              (_a = _this.container) === null || _a === void 0 ? void 0 : _a.removeEventListener(key, _this._proxyHandle);
          });
      };
      /**
       * @ignore
       */
      Overlay.prototype._mountContainer = function () {
          this._overlayContainer = this.useEvent ? this.map.stopEventOverlayContainer : this.map.eventOverlayContainer;
          this.overlayContainer.prepend(this.container);
      };
      /**
       * @ignore
       */
      Overlay.prototype.addTo = function (map) {
          this.map = map;
          this.initialized || this.init();
          this._mountContainer();
      };
      /**
       * @ignore
       */
      Overlay.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.overlayContainer.removeChild(this._container);
          this._overlayContainer = undefined;
          this.map = undefined;
          //@ts-ignore
          defined$1(this._clearHeightUpdate) && (this._clearHeightUpdate(), (this._clearHeightUpdate = void 0));
      };
      /**
       * 设置覆盖物显示位置并显示
       *
       * `position`参数若为`undefined`时,会清除显示位置并隐藏
       */
      Overlay.prototype.setPosition = function (position) {
          var _this = this;
          //@ts-ignore
          defined$1(this._clearHeightUpdate) && (this._clearHeightUpdate(), (this._clearHeightUpdate = void 0));
          if (!this.map) {
              return this;
          }
          if (position) {
              this._position = position;
              this._positionC3 = void 0;
              if (this.heightReference === HeightReference.NONE) {
                  this._positionC3 = degreesToCartesian3(transformToProjection(this._position), this.map);
              }
              else {
                  coordinatesClampToTerrain([position], this.map).then(function (e) {
                      if (_this._position !== position) {
                          return;
                      }
                      var p = position;
                      switch (_this.heightReference) {
                          case HeightReference.CLAMP_TO_GROUND:
                              p = e[0];
                              break;
                          case HeightReference.RELATIVE_TO_GROUND:
                              p = [p[0], p[1], (p[2] || 0) + e[0][2]];
                              break;
                      }
                      _this._positionC3 = degreesToCartesian3(transformToProjection(p), _this.map);
                      //@ts-ignore
                      _this._clearHeightUpdate = _this.map.map.scene.globe._surface.updateHeight(degreesToCartographic(position), function (cartesian3) {
                          if (_this.heightReference === HeightReference.CLAMP_TO_GROUND) {
                              _this._positionC3 = cartesian3.clone();
                          }
                          else if (_this.heightReference === HeightReference.RELATIVE_TO_GROUND) {
                              _this._positionC3 = degreesToCartesian3(transformToProjection([p[0], p[1], (p[2] || 0) + cartesian3ToDegrees(cartesian3, _this.map)[2]]), _this.map);
                          }
                          _this._clearOffsetModify();
                      });
                      _this._clearOffsetModify();
                  });
              }
              this.show();
              viewChange.apply(this);
          }
          else {
              this._position = undefined;
              this._positionC3 = undefined;
              this.hide();
          }
          return this;
      };
      /**
       * 设置覆盖物`DOM`对象
       */
      Overlay.prototype.setElement = function (value) {
          if (this.element === value)
              return this;
          this.element && this.container.removeChild(this.element);
          this.container.appendChild(value);
          this._element = value;
          viewChange.call(this, true);
          return this;
      };
      /**
       * 设置覆盖物的偏移量
       *
       * [x,y] x正值为向右偏移,y正值为向下偏移
       * @param value
       */
      Overlay.prototype.setOffset = function (value) {
          this._offset = value;
          viewChange.call(this, true);
          return this;
      };
      // /**
      //  * 设置覆盖物`DOM`对象是否触发鼠标事件
      //  *
      //  * `false` 不触发覆盖物`DOM`鼠标事件
      //  * @param value
      //  */
      // setUseEvent(value: boolean): Overlay {
      //   if (this.useEvent === value) return this
      //   this._useEvent = value
      //   this._mountContainer()
      //   viewChange.apply(this)
      //   return this
      // }
      /**
       * 设置覆盖物定位方式原点位置
       *
       * 可选值:`'top-left','bottom-left', 'bottom-center', 'bottom-right', 'center-left', 'center-center', 'center-right', 'top-center', 'top-right'`
       */
      Overlay.prototype.setPositioning = function (value) {
          this._positioning = value;
          viewChange.call(this, true);
          return this;
      };
      /**
       * 设置分发到地图的事件
       */
      Overlay.prototype.setDispatchMapEvent = function (dispatchMapEvent) {
          this._removeProxyEvent();
          this._dispatchMapEvent = dispatchMapEvent;
          this._initProxyEvent();
          return this;
      };
      // /**
      //  * 设置覆盖物容器的className
      //  */
      // setClassName(className: string): Overlay {
      //   this.container.className = this._className = initClassName(
      //     className,
      //     'mti-gis-overlay'
      //   )
      //   return this
      // }
      /**
       * @ignore
       */
      Overlay.prototype.show = function () {
          if (this._visible || !this._position)
              return this;
          this._container.style.display = "block";
          this._visible = true;
          this.dispatchEvent({
              type: BaseEventType.SHOW
          });
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype.hide = function () {
          if (!this._visible)
              return this;
          this._container.style.display = "none";
          this._visible = false;
          this.dispatchEvent({
              type: BaseEventType.HIDE
          });
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype._destroy = function () {
          this.remove();
          this._removeEvent();
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Overlay.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Overlay.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 设置位置高度参考
       *
       * [cesium]
       */
      Overlay.prototype.setHeightReference = function (heightReference) {
          this._heightReference = heightReference;
          this.visible && this.setPosition(this.position);
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype._clearOffsetModify = function () {
          this._currentPositioning = this._currentOffset = void 0;
      };
      /**
       * 设置是否自动调整弹窗位置
       * @param autoAdjustment
       */
      Overlay.prototype.setAutoAdjustment = function (autoAdjustment) {
          this._autoAdjustment = autoAdjustment;
          this.show();
          return;
      };
      return Overlay;
  }(BaseObject));
  function viewChange(isFirstModify) {
      if (isFirstModify === true) {
          this._clearOffsetModify();
      }
      if (this.visible && this.positionC3 && this.map) {
          var visible = getPointVisibility(this.positionC3, this.map.map);
          if (visible) {
              translate.apply(this);
          }
          else {
              this.container.style.display = "none";
          }
      }
      else {
          this.container.style.display = "none";
      }
  }
  function translate() {
      var windowCoordinate = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(this.map.map.scene, this.positionC3);
      if (windowCoordinate) {
          var _a = this.map.map
              .container, containerClientHeight = _a.clientHeight, containerClientWidth = _a.clientWidth;
          var _b = this.element, elementClientHeight = _b.clientHeight, elementClientWidth = _b.clientWidth;
          var pointerX = windowCoordinate.x, pointerY = windowCoordinate.y;
          var _c = __read(this.offset, 2), offsetX = _c[0], offsetY = _c[1];
          var x = Math.round(pointerX);
          var y = Math.round(pointerY);
          var positioning = this.positioning;
          var posX = "0%";
          var posY = "0%";
          if (positioning === Positioning.BOTTOM_RIGHT ||
              positioning === Positioning.CENTER_RIGHT ||
              positioning === Positioning.TOP_RIGHT) {
              posX = "-100%";
          }
          else if (positioning === Positioning.BOTTOM_CENTER ||
              positioning === Positioning.CENTER_CENTER ||
              positioning === Positioning.TOP_CENTER) {
              posX = "-50%";
          }
          if (positioning === Positioning.BOTTOM_LEFT ||
              positioning === Positioning.BOTTOM_CENTER ||
              positioning === Positioning.BOTTOM_RIGHT) {
              posY = "-100%";
          }
          else if (positioning === Positioning.CENTER_LEFT ||
              positioning === Positioning.CENTER_CENTER ||
              positioning === Positioning.CENTER_RIGHT) {
              posY = "-50%";
          }
          if (this.autoAdjustment) {
              if (elementClientWidth !== 0 && elementClientHeight !== 0) {
                  if (!defined$1(this._currentPositioning)) {
                      var top_1 = y + (parseInt(posY) / 100) * elementClientHeight + offsetY;
                      var bottom = containerClientHeight - (y + (parseInt(posY) / 100) * elementClientHeight + elementClientHeight + offsetY);
                      if (top_1 < 0 && bottom > 0) {
                          offsetY = 0;
                          posY = "0%";
                      }
                      else if (top_1 > 0 && bottom < 0) {
                          offsetY = 0;
                          posY = "-100%";
                      }
                      this._currentPositioning = (posY === "0%" ? "top" : posY === "-50%" ? "center" : "bottom");
                      var left = x + (parseInt(posX) / 100) * elementClientWidth + offsetX;
                      var right = containerClientWidth - (x + (parseInt(posX) / 100) * elementClientWidth + elementClientWidth + offsetX);
                      if (left < 0 && right > 0) {
                          offsetX = 0;
                          posX = "0%";
                      }
                      else if (left > 0 && right < 0) {
                          offsetX = 0;
                          posX = "-100%";
                      }
                      this._currentPositioning = (this._currentPositioning +
                          (posX === "0%" ? "-left" : posX === "-50%" ? "-center" : "-right"));
                      this._currentOffset = [offsetX, offsetY];
                  }
                  else {
                      var _d = __read(this._currentPositioning.split("-"), 2), positioningY = _d[0], positioningX = _d[1];
                      posX = positioningX === "left" ? "0%" : positioningX === "center" ? "-50%" : "-100%";
                      posY = positioningY === "top" ? "0%" : positioningY === "center" ? "-50%" : "-100%";
                      offsetY = this._currentOffset[1];
                      offsetX = this._currentOffset[0];
                  }
              }
              if (elementClientHeight !== 0 && elementClientWidth !== 0) {
                  this.container.style.visibility = "visible";
              }
              else {
                  this.container.style.visibility = "hidden";
              }
          }
          this.container.style.transform = "translate(".concat(posX, ", ").concat(posY, ") translate(").concat(x + offsetX, "px, ").concat(y + offsetY, "px)");
          this.container.style.display = "block";
      }
  }
  function proxyHandle(e) {
      this.map.map.cesiumWidget.canvas.dispatchEvent(new WheelEvent(e.type, {
          deltaX: e.deltaX,
          deltaY: e.deltaY,
          deltaZ: e.deltaZ,
          deltaMode: e.deltaMode,
          clientX: e.clientX,
          clientY: e.clientY
      }));
  }

  /**
   * 图片覆盖物类
   */
  var Image$1 = /** @class */ (function (_super) {
      __extends$3(Image, _super);
      function Image(options, map) {
          var img = document.createElement("img");
          img.src = options.img;
          if (options.size) {
              img.width = options.size[0];
              img.height = options.size[1];
          }
          var op = __assign$1({ element: img, positioning: Positioning.CENTER_CENTER, useEvent: false }, options);
          return _super.call(this, op, map) || this;
      }
      Object.defineProperty(Image.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Image.prototype._initEvent = function () {
          var e_1, _a;
          var _this = this;
          _super.prototype._initEvent.call(this);
          this._events = [
              {
                  type: "click",
                  func: function (e) {
                      _this.dispatchEvent({
                          type: BaseEventType.CLICK,
                          originEvent: e
                      });
                  }
              },
              {
                  type: "contextmenu",
                  func: function (e) {
                      _this.dispatchEvent({
                          type: BaseEventType.RIGHT_CLICK,
                          originEvent: e
                      });
                  }
              },
              {
                  type: "dblclick",
                  func: function (e) {
                      _this.dispatchEvent({
                          type: BaseEventType.DOUBLE_CLICK,
                          originEvent: e
                      });
                  }
              },
              {
                  type: "wheel",
                  func: function (e) {
                      _this.map.map.cesiumWidget.canvas.dispatchEvent(new WheelEvent(e.type, {
                          deltaX: e.deltaX,
                          deltaY: e.deltaY,
                          deltaZ: e.deltaZ,
                          deltaMode: e.deltaMode,
                          clientX: e.clientX,
                          clientY: e.clientY
                      }));
                  }
              }
          ];
          try {
              for (var _b = __values(this._events), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var iterator = _c.value;
                  this.element.addEventListener(iterator.type, iterator.func);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Image.prototype._clearEvent = function () {
          var e_2, _a;
          try {
              for (var _b = __values(this._events), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var iterator = _c.value;
                  this.element.removeEventListener(iterator.type, iterator.func);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this._events = [];
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `doubleclick` |  左键双击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `rightclick` |  右键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param type
       * @param listener
       * @return {*}
       */
      Image.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `doubleclick` |  左键双击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `rightclick` |  右键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param type
       * @param listener
       * @return {*}
       */
      Image.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * @ignore
       * @override
       */
      Image.prototype._removeEvent = function () {
          _super.prototype._removeEvent.call(this);
          this._clearEvent();
      };
      return Image;
  }(Overlay));

  /**
   * 提示框定位类别
   *
   * @enum {number}
   */
  var PlacementType;
  (function (PlacementType) {
      PlacementType["TOP"] = "top";
      PlacementType["BOTTOM"] = "bottom";
      PlacementType["LEFT"] = "left";
      PlacementType["RIGHT"] = "right";
  })(PlacementType || (PlacementType = {}));

  /**
   * 提示框类
   */
  var Tooltip = /** @class */ (function (_super) {
      __extends$3(Tooltip, _super);
      function Tooltip(options, map) {
          var _this = this;
          var element = initTooltipElement();
          _this = _super.call(this, __assign$1({ element: element, positioning: Positioning.BOTTOM_CENTER, className: "mti-gis-overlay-tooltip", useEvent: false }, options), map) || this;
          _this._textElement = element.firstElementChild;
          _this._arrowElement = element.lastElementChild;
          options.properties && _this.setProperties(options.properties);
          options.text && _this.setText(options.text);
          _this._element = element;
          _this._theme = "dark";
          options.theme && _this.setTheme(options.theme);
          if (options.placement) {
              _this.setPlacement(options.placement);
          }
          else {
              _this._placement = PlacementType.TOP;
          }
          return _this;
      }
      Object.defineProperty(Tooltip.prototype, "properties", {
          /**
           * 提示框属性
           */
          get: function () {
              return this._properties;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Tooltip.prototype, "text", {
          /**
           * 提示框内容模板
           * @constructor
           */
          get: function () {
              return this._text;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Tooltip.prototype, "placement", {
          /**
           * 提示框定位位置
           */
          get: function () {
              return this._placement;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 设置提示框内容模板,可用`{propertyName}`占位
       * @param text
       */
      Tooltip.prototype.setText = function (text) {
          var e_1, _a;
          this._text = text;
          var template = text;
          if (this.properties && /{|}/g.test(text)) {
              try {
                  for (var _b = __values(Object.keys(this.properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var key = _c.value;
                      template = template.replace(new RegExp("{" + key + "}", "g"), this.properties[key]);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          this._textElement.innerHTML = template;
          this._resetArrow();
          return this;
      };
      /**
       * 设置提示框属性
       * @param properties
       */
      Tooltip.prototype.setProperties = function (properties) {
          this._properties = properties;
          this.setText(this._text);
          return this;
      };
      /**
       * 设置提示框主题
       *
       * 可选值:'dark'(默认),'light'
       * @param theme
       */
      Tooltip.prototype.setTheme = function (theme) {
          if (this._theme === theme)
              return this;
          this._element.classList.replace("is-" + this._theme, "is-" + theme);
          this._theme = theme;
          return this;
      };
      /**
       * 此对象该方法无效
       */
      Tooltip.prototype.setElement = function (value) {
          return this;
      };
      /**
       * 此对象该方法无效
       */
      Tooltip.prototype.setPositioning = function (value) {
          return this;
      };
      /**
       * 设置提示框定位位置
       */
      Tooltip.prototype.setPlacement = function (value) {
          if (this._placement === value)
              return this;
          this._element.classList.replace("is-" + (this._placement || "top"), "is-" + value);
          switch (value) {
              case PlacementType.TOP:
                  _super.prototype.setPositioning.call(this, Positioning.BOTTOM_CENTER);
                  break;
              case PlacementType.BOTTOM:
                  _super.prototype.setPositioning.call(this, Positioning.TOP_CENTER);
                  break;
              case PlacementType.LEFT:
                  _super.prototype.setPositioning.call(this, Positioning.CENTER_RIGHT);
                  break;
              case PlacementType.RIGHT:
                  _super.prototype.setPositioning.call(this, Positioning.CENTER_LEFT);
                  break;
          }
          this._placement = value;
          this._resetArrow();
          return this;
      };
      /**
       * 设置提示框显示位置并显示
       *
       * `position`参数若为`undefined`时,会清除显示位置并隐藏
       */
      Tooltip.prototype.setPosition = function (position) {
          var show = this._position;
          _super.prototype.setPosition.call(this, position);
          show || this._resetArrow();
          return this;
      };
      /**
       * @ignore
       */
      Tooltip.prototype._resetArrow = function () {
          var _this = this;
          if (this.initialized) {
              setTimeout(function () {
                  if (_this._placement === "top" || _this._placement === "bottom") {
                      _this._arrowElement.style.top = "";
                      _this._arrowElement.style.left = _this._element.offsetWidth / 2 - _this._arrowElement.offsetWidth / 2 + "px";
                  }
                  else if (_this.placement === "left" || _this.placement === "right") {
                      _this._arrowElement.style.left = "";
                      _this._arrowElement.style.top = _this._element.offsetHeight / 2 - _this._arrowElement.offsetHeight / 2 + "px";
                  }
              }, 0);
          }
      };
      return Tooltip;
  }(Overlay));

  /**
   * Code
   */

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Overlay: Overlay,
    Image: Image$1,
    Tooltip: Tooltip,
    get PlacementType () { return PlacementType; }
  });

  function cesiumSpaceEventToBaseEvent(type) {
      switch (type) {
          case 2 /* LEFT_CLICK */:
              return BaseEventType.CLICK;
          case 3 /* LEFT_DOUBLE_CLICK */:
              return BaseEventType.DOUBLE_CLICK;
          case 0 /* LEFT_DOWN */:
              return BaseEventType.MOUSE_DOWN;
          case 1 /* LEFT_UP */:
              return BaseEventType.MOUSE_UP;
          case 7 /* RIGHT_CLICK */:
              return BaseEventType.RIGHT_CLICK;
          case 15 /* MOUSE_MOVE */:
              return BaseEventType.MOUSE_MOVE;
      }
  }
  function baseEventToCesiumSpace(type) {
      switch (type) {
          case BaseEventType.CLICK:
              return 2 /* LEFT_CLICK */;
          case BaseEventType.DOUBLE_CLICK:
              return 3 /* LEFT_DOUBLE_CLICK */;
          case BaseEventType.MOUSE_DOWN:
              return 0 /* LEFT_DOWN */;
          case BaseEventType.MOUSE_UP:
              return 1 /* LEFT_UP */;
          case BaseEventType.RIGHT_CLICK:
              return 7 /* RIGHT_CLICK */;
          case BaseEventType.MOUSE_MOVE:
              return 15 /* MOUSE_MOVE */;
      }
  }

  var ModelSection = /** @class */ (function (_super) {
      __extends$3(ModelSection, _super);
      function ModelSection(options, map) {
          var _this = _super.call(this) || this;
          _this._distance = 0;
          _this._interaction = false;
          _this._options = __assign$1({ axisType: "x", sectionColor: "rgba(255,255,255,0.3)", direction: 1, planeCenterPosition: [0, 0, 0] }, options);
          _this._glTFModel = options.model;
          if (defined$1(map)) {
              _this.init(map);
          }
          return _this;
      }
      Object.defineProperty(ModelSection.prototype, "map", {
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      ModelSection.prototype.init = function (map) {
          if (this._map) {
              return;
          }
          this._map = map;
          this._initEvent();
          this._initClippingPlanes();
      };
      ModelSection.prototype._destroy = function () {
          this._clearEvent();
          this._map.map.entities.remove(this._clippingPlanEntity);
          this._clippingPlanes.remove(this._clippingPlane);
          this._clippingPlanEntity = undefined;
          this._clippingPlanes = undefined;
          this._map = undefined;
          this._glTFModel = undefined;
      };
      ModelSection.prototype._initEvent = function () {
          var canvas = this._map.map.scene.canvas;
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(canvas);
          this._eventHandler.setInputAction(this._mouseDown.bind(this), 0 /* LEFT_DOWN */);
          this._eventHandler.setInputAction(this._mouseUp.bind(this), 1 /* LEFT_UP */);
          this._eventHandler.setInputAction(this._mouseMove.bind(this), 15 /* MOUSE_MOVE */);
      };
      ModelSection.prototype._clearEvent = function () {
          this._eventHandler && this._eventHandler.destroy();
          this._eventHandler = undefined;
      };
      ModelSection.prototype._initClippingPlanes = function () {
          return __awaiter$8(this, void 0, void 0, function () {
              var boundingSphere, width, positionDegrees, defaultDistance, position;
              var _a;
              return __generator$1(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          if (this._glTFModel.clippingPlanes) {
                              this._clippingPlanes = this._glTFModel.clippingPlanes;
                          }
                          else {
                              this._clippingPlanes = new Cesium__namespace.ClippingPlaneCollection({ edgeWidth: 1 });
                              this._glTFModel.setClippingPlanes(this._clippingPlanes);
                          }
                          this._inverseMatrix4 = Cesium__namespace.Matrix4.inverseTransformation(this._glTFModel.modelMatrix, new Cesium__namespace.Matrix4());
                          return [4 /*yield*/, this._glTFModel.boundingSphere];
                      case 1:
                          boundingSphere = _b.sent();
                          width = this._options.planeWith || Number.parseInt(String(boundingSphere.radius)) * 2;
                          positionDegrees = cartesian3ToDegrees(Cesium__namespace.Matrix4.multiplyByPoint(this._glTFModel.modelMatrix, new ((_a = Cesium__namespace.Cartesian3).bind.apply(_a, __spreadArray$1([void 0], __read(this._options.planeCenterPosition), false)))(), new Cesium__namespace.Cartesian3()), this._map);
                          defaultDistance = 0;
                          if (this._options.axisType !== "z") {
                              positionDegrees[2] = cartesian3ToDegrees(boundingSphere.center, this._map)[2];
                          }
                          else {
                              defaultDistance = cartesian3ToDegrees(boundingSphere.center, this._map)[2] - positionDegrees[2];
                          }
                          position = degreesToCartesian3(positionDegrees, this._map);
                          // const position = boundingSphere.center.clone()
                          // 创建平面实体
                          this._clippingPlanEntity = new Cesium__namespace.Entity({
                              id: this._glTFModel.model.id + "-plane-" + this._options.axisType,
                              position: position,
                              // @ts-ignore
                              orientation: Cesium__namespace.Transforms.headingPitchRollQuaternion(position, 
                              // @ts-ignore 从一个特定参考系的变换计算头滚转角
                              Cesium__namespace.Transforms.fixedFrameToHeadingPitchRoll(this._glTFModel.modelMatrix)),
                              // @ts-ignore
                              plane: new Cesium__namespace.PlaneGraphics({
                                  plane: new Cesium__namespace.CallbackProperty(this._createPlaneUpdateFunction(), false),
                                  dimensions: new Cesium__namespace.Cartesian2(width, width),
                                  material: Cesium__namespace.Color.fromCssColorString(this._options.sectionColor),
                                  outline: true
                              })
                          });
                          this._map.map.entities.add(this._clippingPlanEntity);
                          // const boundingSphere = await this._glTFModel.getBoundingSphere()
                          this._distance = defaultDistance * this._options.direction;
                          // boundingSphere.center[this._options.axisType] *
                          // (this._options.axisType === 'z' ? this._options.direction : 1)
                          this._clippingPlane = new Cesium__namespace.ClippingPlane(new Cesium__namespace.Cartesian3(this._options.axisType === "x" ? this._options.direction : 0.0, this._options.axisType === "y" ? this._options.direction : 0, this._options.axisType === "z" ? -1.0 * this._options.direction : 0.0), 0);
                          this._clippingPlanes.add(this._clippingPlane);
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * 从平面上的点和法线创建一个平面
       *
       * @ignore
       */
      ModelSection.prototype._getPlane = function () {
          switch (this._options.axisType) {
              case "x":
                  return Cesium__namespace.Plane.fromPointNormal(Cesium__namespace.Cartesian3.UNIT_X, Cesium__namespace.Cartesian3.UNIT_Z);
              case "y":
                  return Cesium__namespace.Plane.fromPointNormal(Cesium__namespace.Cartesian3.UNIT_Y, Cesium__namespace.Cartesian3.UNIT_Z);
              case "z":
                  return Cesium__namespace.Plane.fromPointNormal(Cesium__namespace.Cartesian3.UNIT_X, Cesium__namespace.Cartesian3.UNIT_Y);
          }
      };
      /**
       * 计算默认距离
       *
       * @ignore
       */
      ModelSection.prototype._createPlaneUpdateFunction = function () {
          var _this = this;
          return function () {
              _this._clippingPlane.distance = _this._distance;
              return _this._clippingPlane;
          };
      };
      ModelSection.prototype._mouseDown = function (mousement) {
          var pickedObject = this._map.map.scene.pick(mousement.position);
          if (Cesium__namespace.defined(pickedObject) &&
              pickedObject.id.id === this._glTFModel.model.id + "-plane-" + this._options.axisType) {
              this._map.map.scene.screenSpaceCameraController.enableInputs = false;
              this._interaction = true;
          }
      };
      ModelSection.prototype._mouseUp = function () {
          this._map.map.scene.screenSpaceCameraController.enableInputs = true;
          this._interaction = false;
      };
      ModelSection.prototype._mouseMove = function (movement) {
          if (this._interaction) {
              var viewer = this._map.map;
              var startCartesian3 = viewer.scene.pickPosition(movement.startPosition);
              var endCartesian3 = viewer.scene.pickPosition(movement.endPosition);
              var startPosition = Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, startCartesian3, new Cesium__namespace.Cartesian3());
              var endPosition = Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, endCartesian3, new Cesium__namespace.Cartesian3());
              var cameraPosition = Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, this._map.map.camera.position, new Cesium__namespace.Cartesian3());
              var startDirection = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(startPosition, cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
              var endDirection = Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(endPosition, cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3());
              var temPlane = this._getPlane();
              // 表示从所提供的原点沿所提供的方向无限延伸的射线。
              var startRay = new Cesium__namespace.Ray(cameraPosition, startDirection);
              var endRay = new Cesium__namespace.Ray(cameraPosition, endDirection);
              // 计算光线与平面的交点
              var startIntersectionPoint = Cesium__namespace.IntersectionTests.rayPlane(startRay, temPlane);
              var endIntersectionPoint = Cesium__namespace.IntersectionTests.rayPlane(endRay, temPlane);
              this._distance +=
                  (startIntersectionPoint[this._options.axisType] - endIntersectionPoint[this._options.axisType]) *
                      (this._options.axisType === "z" ? -1 : 1) *
                      this._options.direction;
          }
      };
      return ModelSection;
  }(Destroyer));

  /**
   * glTF模型类
   */
  var GLTF = /** @class */ (function (_super) {
      __extends$3(GLTF, _super);
      function GLTF(options, map) {
          var _this = _super.call(this, __assign$1({ type: ModelType.MODEL_ENTITY }, options), map) || this;
          /**
           * @ignore
           */
          _this._sectionStore = {};
          return _this;
      }
      Object.defineProperty(GLTF.prototype, "model", {
          get: function () {
              return this._model;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "position", {
          get: function () {
              return this._position;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "rotate", {
          get: function () {
              var hpr = Cesium__namespace.Transforms.fixedFrameToHeadingPitchRoll(this.modelMatrix, this.map.map.scene.globe.ellipsoid);
              return [Cesium__namespace.Math.toDegrees(hpr.heading), Cesium__namespace.Math.toDegrees(hpr.pitch), Cesium__namespace.Math.toDegrees(hpr.roll)];
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "modelMatrix", {
          get: function () {
              if (this._options.type === ModelType.MODEL) {
                  return this.model.modelMatrix.clone();
              }
              else {
                  return this.model.computeModelMatrix(this.map.map.clock.currentTime);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "scale", {
          /**
           * 模型缩放值
           */
          get: function () {
              if (this._options.type === ModelType.MODEL) {
                  return this.model.scale;
              }
              else {
                  return this.model.model.scale.getValue(this.map.map.clock.currentTime);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "clippingPlanes", {
          /**
           * @ignore
           */
          get: function () {
              var _a;
              if (this._options.type === ModelType.MODEL) {
                  return this.model.clippingPlanes;
              }
              else {
                  return (_a = this.model.model.clippingPlanes) === null || _a === void 0 ? void 0 : _a.getValue(this.map.map.clock.currentTime);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(GLTF.prototype, "boundingSphere", {
          /**
           * @ignore
           */
          get: function () {
              var _this = this;
              if (this._model instanceof Cesium__namespace.Model) {
                  if (this._model.ready) {
                      var bs = this._model.boundingSphere;
                      bs.center = Cesium__namespace.Matrix4.multiplyByPoint(this._model.modelMatrix, bs.center, new Cesium__namespace.Cartesian3());
                      return Promise.resolve(bs);
                  }
                  else {
                      return new Promise(function (resolve) {
                          _this._model.readyPromise.then(function () {
                              var bs = _this._model.boundingSphere;
                              bs.center = Cesium__namespace.Matrix4.multiplyByPoint(_this._model.modelMatrix, bs.center, new Cesium__namespace.Cartesian3());
                              resolve(bs);
                          });
                      });
                  }
              }
              else if (this._model instanceof Cesium__namespace.Entity) {
                  var bs_1 = new Cesium__namespace.BoundingSphere();
                  var state_1;
                  return new Promise(function (resolve) {
                      var clearInterval = setInterval(function () {
                          //@ts-ignore
                          state_1 = _this.map.map.dataSourceDisplay.getBoundingSphere(_this.model, false, bs_1);
                          //@ts-ignore
                          if (state_1 !== Cesium__namespace.BoundingSphereState.DONE) ;
                          else {
                              window.clearInterval(clearInterval);
                              resolve(bs_1);
                          }
                      }, 500);
                  });
              }
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      GLTF.prototype.init = function () {
          var e_1, _a;
          var _b;
          this._position = this.options.position;
          if (this._options.type === ModelType.MODEL) {
              this._model = _createGlTFModel.apply(this);
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              this._model = _buildModelEntity.apply(this);
          }
          if (this._sectionStore) {
              try {
                  for (var _c = __values(Object.keys(this._sectionStore)), _d = _c.next(); !_d.done; _d = _c.next()) {
                      var key = _d.value;
                      (_b = this._sectionStore[key]) === null || _b === void 0 ? void 0 : _b.init(this.map);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
      };
      /**
       * @ignore
       */
      GLTF.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          if (this._options.type === ModelType.MODEL_ENTITY) {
              this.map.map.entities.add(this._model);
              if (this._options.autoRotate) {
                  this.autoRotate();
              }
          }
          if (this._options.type === ModelType.MODEL) {
              this.map.map.scene.primitives.add(this._model);
              if (this._options.autoRotate) {
                  console.warn(ErrorNotification.NOT_MODELTYPE_SUPPORTED);
              }
          }
      };
      /**
       * @ignore
       */
      GLTF.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              this.map && this.map.map.entities.remove(this._model);
          }
          if (this._options.type === ModelType.MODEL) {
              this.map && this.map.map.scene.primitives.remove(this._model);
          }
          this.map = void 0;
      };
      /**
       * 设置模型位置
       * @param position
       * @returns
       */
      GLTF.prototype.setPosition = function (position) {
          var _a, _b, _c;
          this._position = position;
          if (this._options.type === ModelType.MODEL) {
              var matrix4_ = Cesium__namespace.Transforms.headingPitchRollToFixedFrame((_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._position), false)), new ((_b = Cesium__namespace.HeadingPitchRoll).bind.apply(_b, __spreadArray$1([void 0], __read(orientationToRadians(this.rotate)), false)))());
              this._model.modelMatrix = matrix4_;
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              this._model.position = new Cesium__namespace.ConstantPositionProperty((_c = Cesium__namespace.Cartesian3).fromDegrees.apply(_c, __spreadArray$1([], __read(this._position), false)));
          }
          return this;
      };
      /**
       * 设置模型方向
       *
       * @param rotate 第一元素航向角、第二个元素俯仰角、第三个翻滚角
       * @returns
       */
      GLTF.prototype.setRotate = function (rotate) {
          var _a, _b, _c, _d;
          if (this._options.type === ModelType.MODEL) {
              var matrix4_ = Cesium__namespace.Transforms.headingPitchRollToFixedFrame((_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._position), false)), new ((_b = Cesium__namespace.HeadingPitchRoll).bind.apply(_b, __spreadArray$1([void 0], __read(orientationToRadians(rotate)), false)))());
              this._model.modelMatrix = matrix4_;
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              var orientation_ = Cesium__namespace.Transforms.headingPitchRollQuaternion((_c = Cesium__namespace.Cartesian3).fromDegrees.apply(_c, __spreadArray$1([], __read(this._position), false)), new ((_d = Cesium__namespace.HeadingPitchRoll).bind.apply(_d, __spreadArray$1([void 0], __read(orientationToRadians(rotate)), false)))());
              this._model.orientation = new Cesium__namespace.ConstantProperty(orientation_);
          }
          return this;
      };
      /**
       * 改变模型的颜色
       * @param  {string} color
       */
      GLTF.prototype.setColor = function (color) {
          if (this._options.type === ModelType.MODEL) {
              this._model.color = Cesium__namespace.Color.fromCssColorString(color);
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              this._model.model.color = Cesium__namespace.Color.fromCssColorString(color);
          }
          return this;
      };
      /**
       * 设置模型截面
       *
       * @param {*} axis 与截面垂直的轴
       */
      GLTF.prototype.setPlanClip = function (axis) {
          var e_2, _a;
          if (defined$1(axis)) {
              this._sectionStore[axis] = new ModelSection({ model: this, axisType: axis }, this.map);
          }
          else {
              try {
                  for (var _b = __values(Object.keys(this._sectionStore)), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var axis_1 = _c.value;
                      this._sectionStore[axis_1].destroy();
                      delete this._sectionStore[axis_1];
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
          return this;
      };
      /**
       * 显示
       * @ignore
       */
      GLTF.prototype.show = function () {
          if (this.visible)
              return;
          _super.prototype.show.call(this);
          this._model.show = this.visible;
          return this;
      };
      /**
       * 隐藏
       * @ignore
       */
      GLTF.prototype.hide = function () {
          if (!this.visible)
              return;
          _super.prototype.hide.call(this);
          this._model.show = this.visible;
          return this;
      };
      /**
       *  设置模型透明度
       * @param  {number}  opacity
       
       * @ignore
       */
      GLTF.prototype.setOpacity = function (opacity) {
          if (this._options.type === ModelType.MODEL) {
              var modelColor = Cesium__namespace.Color.clone(this._model.color);
              this._model.color = modelColor.withAlpha(opacity);
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              var modelColor = Cesium__namespace.Color.clone(this._model.model.color.getValue(Cesium__namespace.JulianDate.fromDate(new Date())));
              this._model.model.color = modelColor.withAlpha(opacity);
          }
      };
      /**
       * 沿模型当前位置为坐标原点东北向上坐标系的轴移动模型
       *
       * @param {number | [number, number, number]} translation 移动的偏移量以米为单位 大于等于零的值
       * @param {DirectionType} translationType 移动的方向
       */
      GLTF.prototype.setTranslation = function (translation) {
          var _a;
          // 判断模型是否加载完毕准备渲染
          if (!this._model.ready) {
              return;
          }
          var _translation;
          if (Array.isArray(translation)) {
              _translation = (_a = Cesium__namespace.Cartesian3).fromElements.apply(_a, __spreadArray$1([], __read(translation), false));
          }
          var translationMatrix = Cesium__namespace.Matrix4.fromTranslation(_translation);
          this.setModelMatrix(translationMatrix);
          return this;
      };
      /**
       * @ignore
       */
      GLTF.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._model.isDestroyed() || this._model.destroy();
          this._model = void 0;
      };
      /**
       * @ignore
       */
      GLTF.prototype.setModelMatrix = function (modelMatrix) {
          var ps = new Cesium__namespace.Cartesian3();
          Cesium__namespace.Matrix4.getTranslation(modelMatrix, ps);
          if (this._options.type === ModelType.MODEL) {
              var mm = this.model.modelMatrix;
              for (var index = 0; index < mm.length; index++) {
                  //@ts-ignore
                  mm[index] = modelMatrix[index];
              }
          }
          if (this._options.type === ModelType.MODEL_ENTITY) {
              var _entity = this.model;
              var _position = _entity.position;
              _position.setValue(ps);
              var matrix3 = new Cesium__namespace.Matrix3();
              Cesium__namespace.Matrix4.getMatrix3(modelMatrix, matrix3);
              this.model.orientation.setValue(Cesium__namespace.Quaternion.fromRotationMatrix(matrix3));
          }
          this._position = cartesian3ToDegrees(ps, this.map);
          return this;
      };
      /**
       * 均匀地改变模型大小
       *
       * scale > 1模型变大, scale < 1 模型变小
       * @param  {number} scale 删除该模型时是否销毁该模型
       
       */
      GLTF.prototype.setScale = function (scale) {
          if (this._options.type === ModelType.MODEL) {
              this.model.scale = scale;
          }
          else {
              this.model.model.scale.setValue(scale);
          }
          return this;
      };
      /**
       * @ignore
       */
      GLTF.prototype.setClippingPlanes = function (clippingPlanes) {
          if (this._options.type === ModelType.MODEL) {
              this.model.clippingPlanes = clippingPlanes;
          }
          else {
              // @ts-ignore
              this.model.model.clippingPlanes = clippingPlanes;
          }
          return this;
      };
      GLTF.prototype.autoRotate = function () {
          if (this._options.type === ModelType.MODEL) {
              console.warn(ErrorNotification.NOT_MODELTYPE_SUPPORTED);
          }
          else {
              var entity_ = this.model;
              var origin_1 = entity_.position.getValue(Cesium__namespace.JulianDate.now());
              var head_1 = 0;
              var delta_1 = Math.PI / 20;
              entity_.orientation = new Cesium__namespace.CallbackProperty(function () {
                  if (head_1 > Math.PI * 2) {
                      head_1 = 0;
                  }
                  var hpr = new Cesium__namespace.HeadingPitchRoll(head_1, 0, 0);
                  head_1 += delta_1;
                  return Cesium__namespace.Transforms.headingPitchRollQuaternion(origin_1, hpr);
              }, false);
          }
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      GLTF.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      GLTF.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return GLTF;
  }(Model));
  /**
   * 返回模型对象的工厂方法
   */
  function _createGlTFModel() {
      var _a, _b;
      var baseOptions = Object.assign({}, this.options);
      delete baseOptions.type;
      delete baseOptions.position;
      delete baseOptions.orientation;
      var _model = Cesium__namespace.Model.fromGltf(__assign$1({ modelMatrix: Cesium__namespace.Transforms.headingPitchRollToFixedFrame((_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._position), false)), new ((_b = Cesium__namespace.HeadingPitchRoll).bind.apply(_b, __spreadArray$1([void 0], __read(orientationToRadians(this.options.rotate)), false)))()), id: this.options }, baseOptions));
      _model.readyPromise.then(function (model) {
          // 如果glTF含有动画，是否播放动画
          // 为模型中的每个动画创建并添加具有指定初始属性的动画到集合中
          model.activeAnimations.addAll({
              loop: 1 /* REPEAT */
          });
      });
      _model.id = this;
      return _model;
  }
  // 构建实体模型-
  function _buildModelEntity() {
      var _a;
      var baseOptions = Object.assign({}, this.options);
      baseOptions["uri"] = baseOptions.url;
      delete baseOptions.url;
      delete baseOptions.type;
      delete baseOptions.position;
      delete baseOptions.orientation;
      var _position = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._position), false));
      var _model = new Cesium__namespace.Entity({
          position: _position,
          orientation: buildModelDirection({ position: this.position, orientation: this.options.rotate }),
          model: __assign$1({}, baseOptions)
      });
      _model[MODEL_LINK] = this;
      return _model;
  }

  /**
   *  根据样式配置对象构建Cesium.Cesium3DTileStyle类示例对象
   * @param {Object} style
   */
  function Cesium3DTileStyleCreator(style, styleField) {
      return new Cesium__namespace.Cesium3DTileStyle(getStyleOptions(style, styleField));
  }
  /**
   *  根据样式配置对象构建Cesium.Cesium3DTileStyle类的构造参数
   * @param {Object} style
   */
  function getStyleOptions(style, styleField) {
      var e_1, _a;
      var res = {
          color: {
              conditions: []
          },
          show: {
              conditions: []
          }
      };
      if (Array.isArray(style)) {
          if (!Cesium__namespace.defined(styleField)) {
              throw new Cesium__namespace.DeveloperError("当样式为数组类型时，分类字段不能为空！！");
          }
          try {
              for (var style_1 = __values(style), style_1_1 = style_1.next(); !style_1_1.done; style_1_1 = style_1.next()) {
                  var iterator = style_1_1.value;
                  var isDefault = false;
                  var type = void 0;
                  // 唯一值专题图、范围专题图
                  if (Object.hasOwnProperty.call(iterator, "value")) {
                      type = "value";
                      iterator.value = [].concat(iterator.value);
                  }
                  else if (Object.hasOwnProperty.call(iterator, "range")) {
                      type = "range";
                  }
                  else {
                      isDefault = true;
                  }
                  // 默认----
                  if (isDefault) {
                      res.color.conditions.push(["true", iterator.style.color]);
                      res.show.conditions.push(["true", "".concat(iterator.style.show)]);
                      // 唯一值------专题图
                  }
                  else if (type === "value") {
                      var conditionStr = _valueConditionCreater(iterator, styleField);
                      // 那些要素使用该颜色显示--
                      res.color.conditions.push([conditionStr, iterator.style.color]);
                      // 那些要素要显示----
                      res.show.conditions.push([conditionStr, "".concat(iterator.style.show)]);
                      // 范围专题图-----
                  }
                  else if (type === "range") {
                      var conditionStr = _rangeConditionCreater(iterator, styleField);
                      res.color.conditions.push([conditionStr, iterator.style.color]);
                      res.show.conditions.push([conditionStr, "".concat(iterator.style.show)]);
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (style_1_1 && !style_1_1.done && (_a = style_1.return)) _a.call(style_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return res;
      }
      else {
          return style;
      }
  }
  /**
   *  值条件创建器
   * @param {Object} style
   * @param {Object} option
   */
  function _valueConditionCreater(style, styleField) {
      var e_2, _a;
      var conditionStr = "";
      try {
          for (var _b = __values(style.value), _c = _b.next(); !_c.done; _c = _b.next()) {
              var val = _c.value;
              if (conditionStr.length !== 0) {
                  conditionStr += "||";
              }
              if (typeof val === "string") {
                  conditionStr += " (${".concat(styleField, "} === '").concat(val, "') ");
              }
              else if (typeof val === "number") {
                  conditionStr += " (${".concat(styleField, "} === ").concat(val, ") ");
              }
          }
      }
      catch (e_2_1) { e_2 = { error: e_2_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_2) throw e_2.error; }
      }
      return conditionStr;
  }
  /**
   *  范围条件创建器
   * @param {Object} style
   * @param {Object} option
   */
  function _rangeConditionCreater(style, styleField) {
      var conditionStr = "";
      conditionStr += " (Number(${".concat(styleField, "}) >= ").concat(style.range[0], ") ");
      if (style.range.length === 2) {
          conditionStr += "&& (Number(${".concat(styleField, "}) < ").concat(style.range[1], ") ");
      }
      return conditionStr;
  }

  /**
   * Cesium 3D Tile 模型实现类
   */
  var Cesium3DTile = /** @class */ (function (_super) {
      __extends$3(Cesium3DTile, _super);
      function Cesium3DTile(options, 
      /**
       * 地球对象
       */
      map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Cesium3DTile.prototype, "boundingSphere", {
          /**
           * 获取边界球
           *
           * @returns {Promise<Cesium.BoundingSphere>}
           */
          get: function () {
              var _this = this;
              return this.model.ready
                  ? Promise.resolve(this.model.boundingSphere)
                  : new Promise(function (resolve, reject) {
                      _this.model.readyPromise.then(function () {
                          resolve(_this.model.boundingSphere);
                      });
                  });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Cesium3DTile.prototype, "translation", {
          /**
           * 获取平移
           *
           */
          get: function () {
              var ps = new Cesium__namespace.Cartesian3();
              Cesium__namespace.Matrix4.getTranslation(this.model.modelMatrix, ps);
              return [ps.x, ps.y, ps.z];
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Cesium3DTile.prototype, "rotate", {
          get: function () {
              var hpr = Cesium__namespace.Transforms.fixedFrameToHeadingPitchRoll(this.model.modelMatrix, this.map.map.scene.globe.ellipsoid);
              return [Cesium__namespace.Math.toDegrees(hpr.heading), Cesium__namespace.Math.toDegrees(hpr.pitch), Cesium__namespace.Math.toDegrees(hpr.roll)];
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @override
       *  @memberof Cesium3DTileModel
       * @ignore
       */
      Cesium3DTile.prototype.init = function () {
          this.initialized = true;
          this.options.style && this.setStyle(this.options.style, this.options.styleField);
          this._model = _create3DTilesModel.apply(this);
      };
      /** 添加到地球上的方法
       * @ignore
       */
      Cesium3DTile.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          this.model.readyPromise.then(function () {
              _this._modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(_this._model.boundingSphere.center);
              if (_this.options.showModelMatrix) {
                  _this._modelMatrixPrimitive = _this.map.map.scene.primitives.add(new Cesium__namespace.DebugModelMatrixPrimitive({
                      modelMatrix: Cesium__namespace.Transforms.eastNorthUpToFixedFrame(_this._model.boundingSphere.center)
                  }));
              }
              _this.setRotate(_this.options.rotate || [0, 0, 0]);
              _this.setTranslation(_this.options.translation || [0, 0, 0]);
          });
          map.setDefaultTextureVisibility(true);
          this.map.map.scene.primitives.add(this._model);
      };
      /**
       * @override
       * @ignore
       */
      Cesium3DTile.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.scene.primitives.remove(this._model);
          this.map.map.scene.primitives.remove(this._modelMatrixPrimitive);
          this._modelMatrixPrimitive = void 0;
          this.map.setDefaultTextureVisibility(false);
          this.map = undefined;
      };
      /**
       *设置样式
       * @param {Object} style
       * @ignore   *
       */
      Cesium3DTile.prototype.setStyle = function (style, styleField) {
          this._style = Cesium3DTileStyleCreator(style, styleField);
          this._setStyle();
          return this;
      };
      /**
       * 销毁方法,重写父类方法
       * @memberof Cesium3DTileModel
       * @ignore
       */
      Cesium3DTile.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._model.isDestroyed() || this._model.destroy();
          this._model = undefined;
      };
      /**
       * 设置旋转偏移---
       * @param rotate
       * @param translation
       */
      Cesium3DTile.prototype.setRotate = function (rotate) {
          var mx = Cesium__namespace.Matrix3.fromRotationX(Cesium__namespace.Math.toRadians(rotate[0]));
          var my = Cesium__namespace.Matrix3.fromRotationY(Cesium__namespace.Math.toRadians(rotate[1]));
          var mz = Cesium__namespace.Matrix3.fromRotationZ(Cesium__namespace.Math.toRadians(rotate[2]));
          var rotationX = Cesium__namespace.Matrix4.fromRotationTranslation(mx);
          var rotationY = Cesium__namespace.Matrix4.fromRotationTranslation(my);
          var rotationZ = Cesium__namespace.Matrix4.fromRotationTranslation(mz);
          var m = new Cesium__namespace.Matrix4();
          Cesium__namespace.Cartographic.fromCartesian(this._model.boundingSphere.center);
          // console.warn("center", center);
          //旋转、平移矩阵相乘
          Cesium__namespace.Matrix4.multiply(this._modelMatrix, rotationX, m);
          Cesium__namespace.Matrix4.multiply(m, rotationY, m);
          Cesium__namespace.Matrix4.multiply(m, rotationZ, m);
          this._model._root.transform = m;
          return this;
      };
      /**
       * 显示
       */
      Cesium3DTile.prototype.show = function () {
          if (this.visible)
              return;
          _super.prototype.show.call(this);
          this._model.show = this.visible;
          return this;
      };
      /**
       * 隐藏
       */
      Cesium3DTile.prototype.hide = function () {
          if (!this.visible)
              return;
          _super.prototype.hide.call(this);
          this._model.show = this.visible;
          return this;
      };
      /**
       * 沿着边界球定义的东北向上坐标系的轴移动模型
       * @param { [number, number, number]} translation 移动的偏移量以米为单位 大于等于零的值
       * @param {DirectionType} translationType 移动的方向
       * @memberof Cesium3DTileModel
       */
      // 默认沿着法线平移---
      Cesium3DTile.prototype.setTranslation = function (translation) {
          // 判断模型是否加载完毕准备渲染----
          if (!this._model.ready) {
              return;
          }
          this._model.modelMatrix = this._getTranslationMatrix(translation);
          return this;
      };
      /**
       * @ignore
       * @param translation
       * @returns
       */
      Cesium3DTile.prototype._getTranslationMatrix = function (translation) {
          var _a;
          if (!this._model.ready) {
              return;
          }
          var localMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(this._model.boundingSphere.center);
          var _translation;
          if (Array.isArray(translation)) {
              _translation = (_a = Cesium__namespace.Cartesian3).fromElements.apply(_a, __spreadArray$1([], __read(translation), false));
          }
          var start = this._model.boundingSphere.center;
          Cesium__namespace.Cartographic.fromCartesian(start);
          //console.warn("center", center);
          var end = Cesium__namespace.Matrix4.multiplyByPoint(localMatrix, _translation, new Cesium__namespace.Cartesian3());
          var translationVector = Cesium__namespace.Cartesian3.subtract(end, start, new Cesium__namespace.Cartesian3());
          return Cesium__namespace.Matrix4.fromTranslation(translationVector);
      };
      /**
       * 设置样式
       * @ignore
       */
      Cesium3DTile.prototype._setStyle = function () {
          if (this._style && this._model) {
              this._model.style = this._style;
          }
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Cesium3DTile.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Cesium3DTile.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Cesium3DTile;
  }(Model));
  function _create3DTilesModel() {
      var baseOptions = Object.assign({}, this.options);
      delete baseOptions.rotate;
      delete baseOptions.translation;
      delete baseOptions.style;
      var tileSet = Object.assign(new Cesium__namespace.Cesium3DTileset(baseOptions), {
          id: this.id
      });
      tileSet[MODEL_LINK] = this;
      return tileSet;
  }

  var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const WOFF = 'application/font-woff';
  const JPEG = 'image/jpeg';
  const mimes = {
      woff: WOFF,
      woff2: WOFF,
      ttf: 'application/font-truetype',
      eot: 'application/vnd.ms-fontobject',
      png: 'image/png',
      jpg: JPEG,
      jpeg: JPEG,
      gif: 'image/gif',
      tiff: 'image/tiff',
      svg: 'image/svg+xml',
  };
  function getExtension(url) {
      const match = /\.([^./]*?)$/g.exec(url);
      return match ? match[1] : '';
  }
  function getMimeType(url) {
      const extension = getExtension(url).toLowerCase();
      return mimes[extension] || '';
  }
  function resolveUrl(url, baseUrl) {
      // url is absolute already
      if (url.match(/^[a-z]+:\/\//i)) {
          return url;
      }
      // url is absolute already, without protocol
      if (url.match(/^\/\//)) {
          return window.location.protocol + url;
      }
      // dataURI, mailto:, tel:, etc.
      if (url.match(/^[a-z]+:/i)) {
          return url;
      }
      const doc = document.implementation.createHTMLDocument();
      const base = doc.createElement('base');
      const a = doc.createElement('a');
      doc.head.appendChild(base);
      doc.body.appendChild(a);
      if (baseUrl) {
          base.href = baseUrl;
      }
      a.href = url;
      return a.href;
  }
  function isDataUrl(url) {
      return url.search(/^(data:)/) !== -1;
  }
  function makeDataUrl(content, mimeType) {
      return `data:${mimeType};base64,${content}`;
  }
  function parseDataUrlContent(dataURL) {
      return dataURL.split(/,/)[1];
  }
  const uuid = (function uuid() {
      // generate uuid for className of pseudo elements.
      // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
      let counter = 0;
      // ref: http://stackoverflow.com/a/6248722/2519373
      const random = () => 
      // eslint-disable-next-line no-bitwise
      `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);
      return () => {
          counter += 1;
          return `u${random()}${counter}`;
      };
  })();
  function toArray$1(arrayLike) {
      const arr = [];
      for (let i = 0, l = arrayLike.length; i < l; i += 1) {
          arr.push(arrayLike[i]);
      }
      return arr;
  }
  function px(node, styleProperty) {
      const val = window.getComputedStyle(node).getPropertyValue(styleProperty);
      return parseFloat(val.replace('px', ''));
  }
  function getNodeWidth(node) {
      const leftBorder = px(node, 'border-left-width');
      const rightBorder = px(node, 'border-right-width');
      return node.clientWidth + leftBorder + rightBorder;
  }
  function getNodeHeight(node) {
      const topBorder = px(node, 'border-top-width');
      const bottomBorder = px(node, 'border-bottom-width');
      return node.clientHeight + topBorder + bottomBorder;
  }
  function getPixelRatio() {
      let ratio;
      let FINAL_PROCESS;
      try {
          FINAL_PROCESS = process;
      }
      catch (e) {
          // pass
      }
      const val = FINAL_PROCESS && FINAL_PROCESS.env
          ? FINAL_PROCESS.env.devicePixelRatio
          : null;
      if (val) {
          ratio = parseInt(val, 10);
          if (Number.isNaN(ratio)) {
              ratio = 1;
          }
      }
      return ratio || window.devicePixelRatio || 1;
  }
  function createImage$1(url) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.crossOrigin = 'anonymous';
          img.decoding = 'sync';
          img.src = url;
      });
  }
  function svgToDataURL(svg) {
      return __awaiter$6(this, void 0, void 0, function* () {
          return Promise.resolve()
              .then(() => new XMLSerializer().serializeToString(svg))
              .then(encodeURIComponent)
              .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
      });
  }
  function nodeToDataURL(node, width, height) {
      return __awaiter$6(this, void 0, void 0, function* () {
          const xmlns = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(xmlns, 'svg');
          const foreignObject = document.createElementNS(xmlns, 'foreignObject');
          svg.setAttribute('width', `${width}`);
          svg.setAttribute('height', `${height}`);
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          foreignObject.setAttribute('width', '100%');
          foreignObject.setAttribute('height', '100%');
          foreignObject.setAttribute('x', '0');
          foreignObject.setAttribute('y', '0');
          foreignObject.setAttribute('externalResourcesRequired', 'true');
          svg.appendChild(foreignObject);
          foreignObject.appendChild(node);
          return svgToDataURL(svg);
      });
  }

  const cache = {};
  function getCacheKey(url) {
      let key = url.replace(/\?.*/, '');
      // font resourse
      if (/ttf|otf|eot|woff2?/i.test(key)) {
          key = key.replace(/.*\//, '');
      }
      return key;
  }
  function getBlobFromURL(url, options) {
      const cacheKey = getCacheKey(url);
      if (cache[cacheKey] != null) {
          return cache[cacheKey];
      }
      // cache bypass so we dont have CORS issues with cached images
      // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
      if (options.cacheBust) {
          // eslint-disable-next-line no-param-reassign
          url += (/\?/.test(url) ? '&' : '?') + new Date().getTime();
      }
      const failed = (reason) => {
          let placeholder = '';
          if (options.imagePlaceholder) {
              const parts = options.imagePlaceholder.split(/,/);
              if (parts && parts[1]) {
                  placeholder = parts[1];
              }
          }
          let msg = `Failed to fetch resource: ${url}`;
          if (reason) {
              msg = typeof reason === 'string' ? reason : reason.message;
          }
          if (msg) {
              console.error(msg);
          }
          return {
              blob: placeholder,
              contentType: '',
          };
      };
      const deferred = window
          .fetch(url)
          .then((res) => 
      // eslint-disable-next-line promise/no-nesting
      res.blob().then((blob) => ({
          blob,
          contentType: res.headers.get('Content-Type') || '',
      })))
          .then(({ blob, contentType }) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve({
              contentType,
              blob: reader.result,
          });
          reader.onerror = reject;
          reader.readAsDataURL(blob);
      }))
          .then(({ blob, contentType }) => ({
          contentType,
          blob: parseDataUrlContent(blob),
      }))
          // on failed
          .catch(failed);
      // cache result
      cache[cacheKey] = deferred;
      return deferred;
  }

  function formatCSSText(style) {
      const content = style.getPropertyValue('content');
      return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`;
  }
  function formatCSSProperties(style) {
      return toArray$1(style)
          .map((name) => {
          const value = style.getPropertyValue(name);
          const priority = style.getPropertyPriority(name);
          return `${name}: ${value}${priority ? ' !important' : ''};`;
      })
          .join(' ');
  }
  function getPseudoElementStyle(className, pseudo, style) {
      const selector = `.${className}:${pseudo}`;
      const cssText = style.cssText
          ? formatCSSText(style)
          : formatCSSProperties(style);
      return document.createTextNode(`${selector}{${cssText}}`);
  }
  function clonePseudoElement(nativeNode, clonedNode, pseudo) {
      const style = window.getComputedStyle(nativeNode, pseudo);
      const content = style.getPropertyValue('content');
      if (content === '' || content === 'none') {
          return;
      }
      const className = uuid();
      try {
          clonedNode.className = `${clonedNode.className} ${className}`;
      }
      catch (err) {
          return;
      }
      const styleElement = document.createElement('style');
      styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
      clonedNode.appendChild(styleElement);
  }
  function clonePseudoElements(nativeNode, clonedNode) {
      clonePseudoElement(nativeNode, clonedNode, ':before');
      clonePseudoElement(nativeNode, clonedNode, ':after');
  }

  var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function cloneCanvasElement(node) {
      return __awaiter$5(this, void 0, void 0, function* () {
          const dataURL = node.toDataURL();
          if (dataURL === 'data:,') {
              return Promise.resolve(node.cloneNode(false));
          }
          return createImage$1(dataURL);
      });
  }
  function cloneVideoElement(node, options) {
      return __awaiter$5(this, void 0, void 0, function* () {
          return Promise.resolve(node.poster)
              .then((url) => getBlobFromURL(url, options))
              .then((data) => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType))
              .then((dataURL) => createImage$1(dataURL));
      });
  }
  function cloneSingleNode(node, options) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (node instanceof HTMLCanvasElement) {
              return cloneCanvasElement(node);
          }
          if (node instanceof HTMLVideoElement && node.poster) {
              return cloneVideoElement(node, options);
          }
          return Promise.resolve(node.cloneNode(false));
      });
  }
  const isSlotElement$1 = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';
  function cloneChildren(nativeNode, clonedNode, options) {
      var _a;
      return __awaiter$5(this, void 0, void 0, function* () {
          const children = isSlotElement$1(nativeNode) && nativeNode.assignedNodes
              ? toArray$1(nativeNode.assignedNodes())
              : toArray$1(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);
          if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {
              return Promise.resolve(clonedNode);
          }
          return children
              .reduce((deferred, child) => deferred
              // eslint-disable-next-line no-use-before-define
              .then(() => cloneNode(child, options))
              .then((clonedChild) => {
              // eslint-disable-next-line promise/always-return
              if (clonedChild) {
                  clonedNode.appendChild(clonedChild);
              }
          }), Promise.resolve())
              .then(() => clonedNode);
      });
  }
  function cloneCSSStyle(nativeNode, clonedNode) {
      const source = window.getComputedStyle(nativeNode);
      const target = clonedNode.style;
      if (!target) {
          return;
      }
      if (source.cssText) {
          target.cssText = source.cssText;
      }
      else {
          toArray$1(source).forEach((name) => {
              target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));
          });
      }
  }
  function cloneInputValue(nativeNode, clonedNode) {
      if (nativeNode instanceof HTMLTextAreaElement) {
          clonedNode.innerHTML = nativeNode.value;
      }
      if (nativeNode instanceof HTMLInputElement) {
          clonedNode.setAttribute('value', nativeNode.value);
      }
  }
  function decorate(nativeNode, clonedNode) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof Element)) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve()
              .then(() => cloneCSSStyle(nativeNode, clonedNode))
              .then(() => clonePseudoElements(nativeNode, clonedNode))
              .then(() => cloneInputValue(nativeNode, clonedNode))
              .then(() => clonedNode);
      });
  }
  function cloneNode(node, options, isRoot) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (!isRoot && options.filter && !options.filter(node)) {
              return Promise.resolve(null);
          }
          return Promise.resolve(node)
              .then((clonedNode) => cloneSingleNode(clonedNode, options))
              .then((clonedNode) => cloneChildren(node, clonedNode, options))
              .then((clonedNode) => decorate(node, clonedNode));
      });
  }

  var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
  const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["'])([^"']+)\1\)/g;
  const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  function toRegex(url) {
      // eslint-disable-next-line no-useless-escape
      const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
      return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g');
  }
  function parseURLs(cssText) {
      const result = [];
      cssText.replace(URL_REGEX, (raw, quotation, url) => {
          result.push(url);
          return raw;
      });
      return result.filter((url) => !isDataUrl(url));
  }
  function embed(cssText, resourceURL, baseURL, options, get) {
      const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
      return Promise.resolve(resolvedURL)
          .then((url) => get ? get(url) : getBlobFromURL(url, options))
          .then((data) => {
          if (typeof data === 'string') {
              return makeDataUrl(data, getMimeType(resourceURL));
          }
          return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);
      })
          .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))
          .then((content) => content, () => resolvedURL);
  }
  function filterPreferredFontFormat(str, { preferredFontFormat }) {
      return !preferredFontFormat
          ? str
          : str.replace(FONT_SRC_REGEX, (match) => {
              // eslint-disable-next-line no-constant-condition
              while (true) {
                  const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
                  if (!format) {
                      return '';
                  }
                  if (format === preferredFontFormat) {
                      return `src: ${src};`;
                  }
              }
          });
  }
  function shouldEmbed(url) {
      return url.search(URL_REGEX) !== -1;
  }
  function embedResources(cssText, baseUrl, options) {
      return __awaiter$4(this, void 0, void 0, function* () {
          if (!shouldEmbed(cssText)) {
              return Promise.resolve(cssText);
          }
          const filteredCSSText = filterPreferredFontFormat(cssText, options);
          return Promise.resolve(filteredCSSText)
              .then(parseURLs)
              .then((urls) => urls.reduce((deferred, url) => 
          // eslint-disable-next-line promise/no-nesting
          deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));
      });
  }

  var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function embedBackground(clonedNode, options) {
      var _a;
      return __awaiter$3(this, void 0, void 0, function* () {
          const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');
          if (!background) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve(background)
              .then((cssString) => embedResources(cssString, null, options))
              .then((cssString) => {
              clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));
              return clonedNode;
          });
      });
  }
  function embedImageNode(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof HTMLImageElement && !isDataUrl(clonedNode.src)) &&
              !(clonedNode instanceof SVGImageElement &&
                  !isDataUrl(clonedNode.href.baseVal))) {
              return Promise.resolve(clonedNode);
          }
          const src = clonedNode instanceof HTMLImageElement
              ? clonedNode.src
              : clonedNode.href.baseVal;
          return Promise.resolve(src)
              .then((url) => getBlobFromURL(url, options))
              .then((data) => makeDataUrl(data.blob, getMimeType(src) || data.contentType))
              .then((dataURL) => new Promise((resolve, reject) => {
              clonedNode.onload = resolve;
              clonedNode.onerror = reject;
              if (clonedNode instanceof HTMLImageElement) {
                  clonedNode.srcset = '';
                  clonedNode.src = dataURL;
              }
              else {
                  clonedNode.href.baseVal = dataURL;
              }
          }))
              .then(() => clonedNode, () => clonedNode);
      });
  }
  function embedChildren(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          const children = toArray$1(clonedNode.childNodes);
          // eslint-disable-next-line no-use-before-define
          const deferreds = children.map((child) => embedImages(child, options));
          return Promise.all(deferreds).then(() => clonedNode);
      });
  }
  function embedImages(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof Element)) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve(clonedNode)
              .then((node) => embedBackground(node, options))
              .then((node) => embedImageNode(node, options))
              .then((node) => embedChildren(node, options));
      });
  }

  function applyStyleWithOptions(node, options) {
      const { style } = node;
      if (options.backgroundColor) {
          style.backgroundColor = options.backgroundColor;
      }
      if (options.width) {
          style.width = `${options.width}px`;
      }
      if (options.height) {
          style.height = `${options.height}px`;
      }
      const manual = options.style;
      if (manual != null) {
          Object.keys(manual).forEach((key) => {
              style[key] = manual[key];
          });
      }
      return node;
  }

  var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const cssFetchCache = {};
  function fetchCSS(url) {
      const cache = cssFetchCache[url];
      if (cache != null) {
          return cache;
      }
      const deferred = window.fetch(url).then((res) => ({
          url,
          cssText: res.text(),
      }));
      cssFetchCache[url] = deferred;
      return deferred;
  }
  function embedFonts(meta) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return meta.cssText.then((raw) => {
              let cssText = raw;
              const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
              const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
              const loadFonts = fontLocs.map((location) => {
                  let url = location.replace(regexUrl, '$1');
                  if (!url.startsWith('https://')) {
                      url = new URL(url, meta.url).href;
                  }
                  // eslint-disable-next-line promise/no-nesting
                  return window
                      .fetch(url)
                      .then((res) => res.blob())
                      .then((blob) => new Promise((resolve, reject) => {
                      const reader = new FileReader();
                      reader.onloadend = () => {
                          // Side Effect
                          cssText = cssText.replace(location, `url(${reader.result})`);
                          resolve([location, reader.result]);
                      };
                      reader.onerror = reject;
                      reader.readAsDataURL(blob);
                  }));
              });
              // eslint-disable-next-line promise/no-nesting
              return Promise.all(loadFonts).then(() => cssText);
          });
      });
  }
  function parseCSS(source) {
      if (source == null) {
          return [];
      }
      const result = [];
      const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
      // strip out comments
      let cssText = source.replace(commentsRegex, '');
      const keyframesRegex = new RegExp('((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})', 'gi');
      // eslint-disable-next-line no-constant-condition
      while (true) {
          const matches = keyframesRegex.exec(cssText);
          if (matches === null) {
              break;
          }
          result.push(matches[0]);
      }
      cssText = cssText.replace(keyframesRegex, '');
      const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
      // to match css & media queries together
      const combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
          '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})';
      // unified regex
      const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');
      // eslint-disable-next-line no-constant-condition
      while (true) {
          let matches = importRegex.exec(cssText);
          if (matches === null) {
              matches = unifiedRegex.exec(cssText);
              if (matches === null) {
                  break;
              }
              else {
                  importRegex.lastIndex = unifiedRegex.lastIndex;
              }
          }
          else {
              unifiedRegex.lastIndex = importRegex.lastIndex;
          }
          result.push(matches[0]);
      }
      return result;
  }
  function getCSSRules(styleSheets) {
      return __awaiter$2(this, void 0, void 0, function* () {
          const ret = [];
          const deferreds = [];
          // First loop inlines imports
          styleSheets.forEach((sheet) => {
              if ('cssRules' in sheet) {
                  try {
                      toArray$1(sheet.cssRules).forEach((item, index) => {
                          if (item.type === CSSRule.IMPORT_RULE) {
                              let importIndex = index + 1;
                              const url = item.href;
                              const deferred = fetchCSS(url)
                                  .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                                  .then((cssText) => parseCSS(cssText).forEach((rule) => {
                                  try {
                                      sheet.insertRule(rule, rule.startsWith('@import')
                                          ? (importIndex += 1)
                                          : sheet.cssRules.length);
                                  }
                                  catch (error) {
                                      console.error('Error inserting rule from remote css', {
                                          rule,
                                          error,
                                      });
                                  }
                              }))
                                  .catch((e) => {
                                  console.error('Error loading remote css', e.toString());
                              });
                              deferreds.push(deferred);
                          }
                      });
                  }
                  catch (e) {
                      const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
                      if (sheet.href != null) {
                          deferreds.push(fetchCSS(sheet.href)
                              .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                              .then((cssText) => parseCSS(cssText).forEach((rule) => {
                              inline.insertRule(rule, sheet.cssRules.length);
                          }))
                              .catch((err) => {
                              console.error('Error loading remote stylesheet', err.toString());
                          }));
                      }
                      console.error('Error inlining remote css file', e.toString());
                  }
              }
          });
          return Promise.all(deferreds).then(() => {
              // Second loop parses rules
              styleSheets.forEach((sheet) => {
                  if ('cssRules' in sheet) {
                      try {
                          toArray$1(sheet.cssRules).forEach((item) => {
                              ret.push(item);
                          });
                      }
                      catch (e) {
                          console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());
                      }
                  }
              });
              return ret;
          });
      });
  }
  function getWebFontRules(cssRules) {
      return cssRules
          .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
          .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));
  }
  function parseWebFontRules(node) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
              if (node.ownerDocument == null) {
                  reject(new Error('Provided element is not within a Document'));
              }
              resolve(toArray$1(node.ownerDocument.styleSheets));
          })
              .then((styleSheets) => getCSSRules(styleSheets))
              .then(getWebFontRules);
      });
  }
  function getWebFontCSS(node, options) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return parseWebFontRules(node)
              .then((rules) => Promise.all(rules.map((rule) => {
              const baseUrl = rule.parentStyleSheet
                  ? rule.parentStyleSheet.href
                  : null;
              return embedResources(rule.cssText, baseUrl, options);
          })))
              .then((cssTexts) => cssTexts.join('\n'));
      });
  }
  function embedWebFonts(clonedNode, options) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return (options.fontEmbedCSS != null
              ? Promise.resolve(options.fontEmbedCSS)
              : getWebFontCSS(clonedNode, options)).then((cssText) => {
              const styleNode = document.createElement('style');
              const sytleContent = document.createTextNode(cssText);
              styleNode.appendChild(sytleContent);
              if (clonedNode.firstChild) {
                  clonedNode.insertBefore(styleNode, clonedNode.firstChild);
              }
              else {
                  clonedNode.appendChild(styleNode);
              }
              return clonedNode;
          });
      });
  }

  var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function getImageSize(node, options = {}) {
      const width = options.width || getNodeWidth(node);
      const height = options.height || getNodeHeight(node);
      return { width, height };
  }
  function toSvg(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          const { width, height } = getImageSize(node, options);
          return Promise.resolve(node)
              .then((nativeNode) => cloneNode(nativeNode, options, true))
              .then((clonedNode) => embedWebFonts(clonedNode, options))
              .then((clonedNode) => embedImages(clonedNode, options))
              .then((clonedNode) => applyStyleWithOptions(clonedNode, options))
              .then((clonedNode) => nodeToDataURL(clonedNode, width, height));
      });
  }
  const dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
  function checkCanvasDimensions(canvas) {
      if (canvas.width > dimensionCanvasLimit ||
          canvas.height > dimensionCanvasLimit) {
          if (canvas.width > dimensionCanvasLimit &&
              canvas.height > dimensionCanvasLimit) {
              if (canvas.width > canvas.height) {
                  canvas.height *= dimensionCanvasLimit / canvas.width;
                  canvas.width = dimensionCanvasLimit;
              }
              else {
                  canvas.width *= dimensionCanvasLimit / canvas.height;
                  canvas.height = dimensionCanvasLimit;
              }
          }
          else if (canvas.width > dimensionCanvasLimit) {
              canvas.height *= dimensionCanvasLimit / canvas.width;
              canvas.width = dimensionCanvasLimit;
          }
          else {
              canvas.width *= dimensionCanvasLimit / canvas.height;
              canvas.height = dimensionCanvasLimit;
          }
      }
  }
  function toCanvas(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toSvg(node, options)
              .then(createImage$1)
              .then((img) => {
              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              const ratio = options.pixelRatio || getPixelRatio();
              const { width, height } = getImageSize(node, options);
              const canvasWidth = options.canvasWidth || width;
              const canvasHeight = options.canvasHeight || height;
              canvas.width = canvasWidth * ratio;
              canvas.height = canvasHeight * ratio;
              if (!options.skipAutoScale) {
                  checkCanvasDimensions(canvas);
              }
              canvas.style.width = `${canvasWidth}`;
              canvas.style.height = `${canvasHeight}`;
              if (options.backgroundColor) {
                  context.fillStyle = options.backgroundColor;
                  context.fillRect(0, 0, canvas.width, canvas.height);
              }
              context.drawImage(img, 0, 0, canvas.width, canvas.height);
              return canvas;
          });
      });
  }
  function toPng(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toCanvas(node, options).then((canvas) => canvas.toDataURL());
      });
  }
  function toJpeg(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toCanvas(node, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));
      });
  }

  function _typeof$2(obj) {
    "@babel/helpers - typeof";

    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$2(obj);
  }

  // DEFLATE is a complex format; to read this code, you should probably check the RFC first:
  // https://tools.ietf.org/html/rfc1951
  // You may also wish to take a look at the guide I made about this program:
  // https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
  // Much of the following code is similar to that of UZIP.js:
  // https://github.com/photopea/UZIP.js
  // Many optimizations have been made, so the bundle size is ultimately smaller but performance is similar.
  // Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
  // is better for memory in most engines (I *think*).
  // Mediocre shim
  var Worker;
  try {
      Worker = require('worker_threads').Worker;
  }
  catch (e) {
  }

  // aliases for shorter compressed code (most minifers don't do this)
  var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
  // fixed length extra bits
  var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
  // fixed distance extra bits
  // see fleb note
  var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
  // code length index map
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  // get base, reverse index map from extra bits
  var freb = function (eb, start) {
      var b = new u16(31);
      for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
      }
      // numbers here are at max 18 bits
      var r = new u32(b[30]);
      for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
              r[j] = ((j - b[i]) << 5) | i;
          }
      }
      return [b, r];
  };
  var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
  // we can ignore the fact that the other numbers are wrong; they never happen anyway
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
  // map of value to reverse (assuming 16 bits)
  var rev = new u16(32768);
  for (var i$7 = 0; i$7 < 32768; ++i$7) {
      // reverse table algorithm from SO
      var x$1 = ((i$7 & 0xAAAA) >>> 1) | ((i$7 & 0x5555) << 1);
      x$1 = ((x$1 & 0xCCCC) >>> 2) | ((x$1 & 0x3333) << 2);
      x$1 = ((x$1 & 0xF0F0) >>> 4) | ((x$1 & 0x0F0F) << 4);
      rev[i$7] = (((x$1 & 0xFF00) >>> 8) | ((x$1 & 0x00FF) << 8)) >>> 1;
  }
  // create huffman tree from u8 "map": index -> code length for code index
  // mb (max bits) must be at most 15
  // TODO: optimize/split up?
  var hMap = (function (cd, mb, r) {
      var s = cd.length;
      // index
      var i = 0;
      // u16 "map": index -> # of codes with bit length = index
      var l = new u16(mb);
      // length of cd must be 288 (total # of codes)
      for (; i < s; ++i)
          ++l[cd[i] - 1];
      // u16 "map": index -> minimum code for bit length = index
      var le = new u16(mb);
      for (i = 0; i < mb; ++i) {
          le[i] = (le[i - 1] + l[i - 1]) << 1;
      }
      var co;
      if (r) {
          // u16 "map": index -> number of actual bits, symbol for code
          co = new u16(1 << mb);
          // bits to remove for reverser
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
              // ignore 0 lengths
              if (cd[i]) {
                  // num encoding both symbol and bits read
                  var sv = (i << 4) | cd[i];
                  // free bits
                  var r_1 = mb - cd[i];
                  // start value
                  var v = le[cd[i] - 1]++ << r_1;
                  // m is end value
                  for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                      // every 16 bit value starting with the code yields the same result
                      co[rev[v] >>> rvb] = sv;
                  }
              }
          }
      }
      else {
          co = new u16(s);
          for (i = 0; i < s; ++i)
              co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
      }
      return co;
  });
  // fixed length tree
  var flt = new u8(288);
  for (var i$7 = 0; i$7 < 144; ++i$7)
      flt[i$7] = 8;
  for (var i$7 = 144; i$7 < 256; ++i$7)
      flt[i$7] = 9;
  for (var i$7 = 256; i$7 < 280; ++i$7)
      flt[i$7] = 7;
  for (var i$7 = 280; i$7 < 288; ++i$7)
      flt[i$7] = 8;
  // fixed distance tree
  var fdt = new u8(32);
  for (var i$7 = 0; i$7 < 32; ++i$7)
      fdt[i$7] = 5;
  // fixed length map
  var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
  // fixed distance map
  var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
  // find max of array
  var max$3 = function (a) {
      var m = a[0];
      for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
              m = a[i];
      }
      return m;
  };
  // read d, starting at bit p and mask with m
  var bits = function (d, p, m) {
      var o = (p / 8) >> 0;
      return ((d[o] | (d[o + 1] << 8)) >>> (p & 7)) & m;
  };
  // read d, starting at bit p continuing for at least 16 bits
  var bits16 = function (d, p) {
      var o = (p / 8) >> 0;
      return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >>> (p & 7));
  };
  // get end of byte
  var shft = function (p) { return ((p / 8) >> 0) + (p & 7 && 1); };
  // typed array slice - allows garbage collector to free original reference,
  // while being more compatible than .slice
  var slc = function (v, s, e) {
      if (s == null || s < 0)
          s = 0;
      if (e == null || e > v.length)
          e = v.length;
      // can't use .constructor in case user-supplied
      var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
      n.set(v.subarray(s, e));
      return n;
  };
  // expands raw DEFLATE data
  var inflt = function (dat, buf, st) {
      // source length
      var sl = dat.length;
      // have to estimate size
      var noBuf = !buf || st;
      // no state
      var noSt = !st || st.i;
      if (!st)
          st = {};
      // Assumes roughly 33% compression ratio average
      if (!buf)
          buf = new u8(sl * 3);
      // ensure buffer can fit at least l elements
      var cbuf = function (l) {
          var bl = buf.length;
          // need to increase size to fit
          if (l > bl) {
              // Double or set to necessary, whichever is greater
              var nbuf = new u8(Math.max(bl * 2, l));
              nbuf.set(buf);
              buf = nbuf;
          }
      };
      //  last chunk         bitpos           bytes
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      // total bits
      var tbts = sl * 8;
      do {
          if (!lm) {
              // BFINAL - this is only 1 when last chunk is next
              st.f = final = bits(dat, pos, 1);
              // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
              var type = bits(dat, pos + 1, 3);
              pos += 3;
              if (!type) {
                  // go to end of byte boundary
                  var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                  if (t > sl) {
                      if (noSt)
                          throw 'unexpected EOF';
                      break;
                  }
                  // ensure size
                  if (noBuf)
                      cbuf(bt + l);
                  // Copy over uncompressed data
                  buf.set(dat.subarray(s, t), bt);
                  // Get new bitpos, update byte count
                  st.b = bt += l, st.p = pos = t * 8;
                  continue;
              }
              else if (type == 1)
                  lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
              else if (type == 2) {
                  //  literal                            lengths
                  var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                  var tl = hLit + bits(dat, pos + 5, 31) + 1;
                  pos += 14;
                  // length+distance tree
                  var ldt = new u8(tl);
                  // code length tree
                  var clt = new u8(19);
                  for (var i = 0; i < hcLen; ++i) {
                      // use index map to get real code
                      clt[clim[i]] = bits(dat, pos + i * 3, 7);
                  }
                  pos += hcLen * 3;
                  // code lengths bits
                  var clb = max$3(clt), clbmsk = (1 << clb) - 1;
                  if (!noSt && pos + tl * (clb + 7) > tbts)
                      break;
                  // code lengths map
                  var clm = hMap(clt, clb, 1);
                  for (var i = 0; i < tl;) {
                      var r = clm[bits(dat, pos, clbmsk)];
                      // bits read
                      pos += r & 15;
                      // symbol
                      var s = r >>> 4;
                      // code length to copy
                      if (s < 16) {
                          ldt[i++] = s;
                      }
                      else {
                          //  copy   count
                          var c = 0, n = 0;
                          if (s == 16)
                              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                          else if (s == 17)
                              n = 3 + bits(dat, pos, 7), pos += 3;
                          else if (s == 18)
                              n = 11 + bits(dat, pos, 127), pos += 7;
                          while (n--)
                              ldt[i++] = c;
                      }
                  }
                  //    length tree                 distance tree
                  var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                  // max length bits
                  lbt = max$3(lt);
                  // max dist bits
                  dbt = max$3(dt);
                  lm = hMap(lt, lbt, 1);
                  dm = hMap(dt, dbt, 1);
              }
              else
                  throw 'invalid block type';
              if (pos > tbts)
                  throw 'unexpected EOF';
          }
          // Make sure the buffer can hold this + the largest possible addition
          // Maximum chunk size (practically, theoretically infinite) is 2^17;
          if (noBuf)
              cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var mxa = lbt + dbt + 18;
          while (noSt || pos + mxa < tbts) {
              // bits read, code
              var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
              pos += c & 15;
              if (pos > tbts)
                  throw 'unexpected EOF';
              if (!c)
                  throw 'invalid length/literal';
              if (sym < 256)
                  buf[bt++] = sym;
              else if (sym == 256) {
                  lm = null;
                  break;
              }
              else {
                  var add = sym - 254;
                  // no extra bits needed if less
                  if (sym > 264) {
                      // index
                      var i = sym - 257, b = fleb[i];
                      add = bits(dat, pos, (1 << b) - 1) + fl[i];
                      pos += b;
                  }
                  // dist
                  var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                  if (!d)
                      throw 'invalid distance';
                  pos += d & 15;
                  var dt = fd[dsym];
                  if (dsym > 3) {
                      var b = fdeb[dsym];
                      dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                  }
                  if (pos > tbts)
                      throw 'unexpected EOF';
                  if (noBuf)
                      cbuf(bt + 131072);
                  var end = bt + add;
                  for (; bt < end; bt += 4) {
                      buf[bt] = buf[bt - dt];
                      buf[bt + 1] = buf[bt + 1 - dt];
                      buf[bt + 2] = buf[bt + 2 - dt];
                      buf[bt + 3] = buf[bt + 3 - dt];
                  }
                  bt = end;
              }
          }
          st.l = lm, st.p = pos, st.b = bt;
          if (lm)
              final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  // starting at p, write the minimum number of bits that can hold v to d
  var wbits = function (d, p, v) {
      v <<= p & 7;
      var o = (p / 8) >> 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
  };
  // starting at p, write the minimum number of bits (>8) that can hold v to d
  var wbits16 = function (d, p, v) {
      v <<= p & 7;
      var o = (p / 8) >> 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
      d[o + 2] |= v >>> 16;
  };
  // creates code lengths from a frequency table
  var hTree = function (d, mb) {
      // Need extra info to make a tree
      var t = [];
      for (var i = 0; i < d.length; ++i) {
          if (d[i])
              t.push({ s: i, f: d[i] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
          return [new u8(0), 0];
      if (s == 1) {
          var v = new u8(t[0].s + 1);
          v[t[0].s] = 1;
          return [v, 1];
      }
      t.sort(function (a, b) { return a.f - b.f; });
      // after i2 reaches last ind, will be stopped
      // freq must be greater than largest possible number of symbols
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
      t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
      // efficient algorithm from UZIP.js
      // i0 is lookbehind, i2 is lookahead - after processing two low-freq
      // symbols that combined have high freq, will start processing i2 (high-freq,
      // non-composite) symbols instead
      // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
      while (i1 != s - 1) {
          l = t[t[i0].f < t[i2].f ? i0++ : i2++];
          r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
          t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
      }
      var maxSym = t2[0].s;
      for (var i = 1; i < s; ++i) {
          if (t2[i].s > maxSym)
              maxSym = t2[i].s;
      }
      // code lengths
      var tr = new u16(maxSym + 1);
      // max bits in tree
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
          // more algorithms from UZIP.js
          // TODO: find out how this code works (debt)
          //  ind    debt
          var i = 0, dt = 0;
          //    left            cost
          var lft = mbt - mb, cst = 1 << lft;
          t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
          for (; i < s; ++i) {
              var i2_1 = t2[i].s;
              if (tr[i2_1] > mb) {
                  dt += cst - (1 << (mbt - tr[i2_1]));
                  tr[i2_1] = mb;
              }
              else
                  break;
          }
          dt >>>= lft;
          while (dt > 0) {
              var i2_2 = t2[i].s;
              if (tr[i2_2] < mb)
                  dt -= 1 << (mb - tr[i2_2]++ - 1);
              else
                  ++i;
          }
          for (; i >= 0 && dt; --i) {
              var i2_3 = t2[i].s;
              if (tr[i2_3] == mb) {
                  --tr[i2_3];
                  ++dt;
              }
          }
          mbt = mb;
      }
      return [new u8(tr), mbt];
  };
  // get the max length and assign length codes
  var ln = function (n, l, d) {
      return n.s == -1
          ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
          : (l[n.s] = d);
  };
  // length codes generation
  var lc = function (c) {
      var s = c.length;
      // Note that the semicolon was intentional
      while (s && !c[--s])
          ;
      var cl = new u16(++s);
      //  ind      num         streak
      var cli = 0, cln = c[0], cls = 1;
      var w = function (v) { cl[cli++] = v; };
      for (var i = 1; i <= s; ++i) {
          if (c[i] == cln && i != s)
              ++cls;
          else {
              if (!cln && cls > 2) {
                  for (; cls > 138; cls -= 138)
                      w(32754);
                  if (cls > 2) {
                      w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                      cls = 0;
                  }
              }
              else if (cls > 3) {
                  w(cln), --cls;
                  for (; cls > 6; cls -= 6)
                      w(8304);
                  if (cls > 2)
                      w(((cls - 3) << 5) | 8208), cls = 0;
              }
              while (cls--)
                  w(cln);
              cls = 1;
              cln = c[i];
          }
      }
      return [cl.subarray(0, cli), s];
  };
  // calculate the length of output from tree, code lengths
  var clen = function (cf, cl) {
      var l = 0;
      for (var i = 0; i < cl.length; ++i)
          l += cf[i] * cl[i];
      return l;
  };
  // writes a fixed block
  // returns the new bit pos
  var wfblk = function (out, pos, dat) {
      // no need to write 00 as type: TypedArray defaults to 0
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >>> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i = 0; i < s; ++i)
          out[o + i + 4] = dat[i];
      return (o + 4 + s) * 8;
  };
  // writes a block
  var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
      var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
      var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
      var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
      var lcfreq = new u16(19);
      for (var i = 0; i < lclt.length; ++i)
          lcfreq[lclt[i] & 31]++;
      for (var i = 0; i < lcdt.length; ++i)
          lcfreq[lcdt[i] & 31]++;
      var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
          ;
      var flen = (bl + 5) << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
      if (flen <= ftlen && flen <= dtlen)
          return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
          lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
          var llm = hMap(lct, mlcb, 0);
          wbits(out, p, nlc - 257);
          wbits(out, p + 5, ndc - 1);
          wbits(out, p + 10, nlcc - 4);
          p += 14;
          for (var i = 0; i < nlcc; ++i)
              wbits(out, p + 3 * i, lct[clim[i]]);
          p += 3 * nlcc;
          var lcts = [lclt, lcdt];
          for (var it = 0; it < 2; ++it) {
              var clct = lcts[it];
              for (var i = 0; i < clct.length; ++i) {
                  var len = clct[i] & 31;
                  wbits(out, p, llm[len]), p += lct[len];
                  if (len > 15)
                      wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
              }
          }
      }
      else {
          lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i = 0; i < li; ++i) {
          if (syms[i] > 255) {
              var len = (syms[i] >>> 18) & 31;
              wbits16(out, p, lm[len + 257]), p += ll[len + 257];
              if (len > 7)
                  wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
              var dst = syms[i] & 31;
              wbits16(out, p, dm[dst]), p += dl[dst];
              if (dst > 3)
                  wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
          }
          else {
              wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
          }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
  };
  // deflate options (nice << 13) | chain
  var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  // empty
  var et$1 = /*#__PURE__*/ new u8(0);
  // compresses data into a raw DEFLATE buffer
  var dflt = function (dat, lvl, plvl, pre, post, lst) {
      var s = dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post);
      // writing to this writes to the output buffer
      var w = o.subarray(pre, o.length - post);
      var pos = 0;
      if (!lvl || s < 8) {
          for (var i = 0; i <= s; i += 65535) {
              // end
              var e = i + 65535;
              if (e < s) {
                  // write full block
                  pos = wfblk(w, pos, dat.subarray(i, e));
              }
              else {
                  // write final block
                  w[i] = lst;
                  pos = wfblk(w, pos, dat.subarray(i, s));
              }
          }
      }
      else {
          var opt = deo[lvl - 1];
          var n = opt >>> 13, c = opt & 8191;
          var msk_1 = (1 << plvl) - 1;
          //    prev 2-byte val map    curr 2-byte val map
          var prev = new u16(32768), head = new u16(msk_1 + 1);
          var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
          var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
          // 24576 is an arbitrary number of maximum symbols per block
          // 424 buffer for last block
          var syms = new u32(25000);
          // length/literal freq   distance freq
          var lf = new u16(288), df = new u16(32);
          //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
          var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
          for (; i < s; ++i) {
              // hash value
              var hv = hsh(i);
              // index mod 32768
              var imod = i & 32767;
              // previous index with this value
              var pimod = head[hv];
              prev[imod] = pimod;
              head[hv] = imod;
              // We always should modify head and prev, but only add symbols if
              // this data is not yet processed ("wait" for wait index)
              if (wi <= i) {
                  // bytes remaining
                  var rem = s - i;
                  if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                      pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                      li = lc_1 = eb = 0, bs = i;
                      for (var j = 0; j < 286; ++j)
                          lf[j] = 0;
                      for (var j = 0; j < 30; ++j)
                          df[j] = 0;
                  }
                  //  len    dist   chain
                  var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
                  if (rem > 2 && hv == hsh(i - dif)) {
                      var maxn = Math.min(n, rem) - 1;
                      var maxd = Math.min(32767, i);
                      // max possible length
                      // not capped at dif because decompressors implement "rolling" index population
                      var ml = Math.min(258, rem);
                      while (dif <= maxd && --ch_1 && imod != pimod) {
                          if (dat[i + l] == dat[i + l - dif]) {
                              var nl = 0;
                              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                  ;
                              if (nl > l) {
                                  l = nl, d = dif;
                                  // break out early when we reach "nice" (we are satisfied enough)
                                  if (nl > maxn)
                                      break;
                                  // now, find the rarest 2-byte sequence within this
                                  // length of literals and search for that instead.
                                  // Much faster than just using the start
                                  var mmd = Math.min(dif, nl - 2);
                                  var md = 0;
                                  for (var j = 0; j < mmd; ++j) {
                                      var ti = (i - dif + j + 32768) & 32767;
                                      var pti = prev[ti];
                                      var cd = (ti - pti + 32768) & 32767;
                                      if (cd > md)
                                          md = cd, pimod = ti;
                                  }
                              }
                          }
                          // check the previous match
                          imod = pimod, pimod = prev[imod];
                          dif += (imod - pimod + 32768) & 32767;
                      }
                  }
                  // d will be nonzero only when a match was found
                  if (d) {
                      // store both dist and len data in one Uint32
                      // Make sure this is recognized as a len/dist with 28th bit (2^28)
                      syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                      var lin = revfl[l] & 31, din = revfd[d] & 31;
                      eb += fleb[lin] + fdeb[din];
                      ++lf[257 + lin];
                      ++df[din];
                      wi = i + l;
                      ++lc_1;
                  }
                  else {
                      syms[li++] = dat[i];
                      ++lf[dat[i]];
                  }
              }
          }
          pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
          // this is the easiest way to avoid needing to maintain state
          if (!lst)
              pos = wfblk(w, pos, et$1);
      }
      return slc(o, 0, pre + shft(pos) + post);
  };
  // Alder32
  var adler = function () {
      var a = 1, b = 0;
      return {
          p: function (d) {
              // closures have awful performance
              var n = a, m = b;
              var l = d.length;
              for (var i = 0; i != l;) {
                  var e = Math.min(i + 5552, l);
                  for (; i < e; ++i)
                      n += d[i], m += n;
                  n %= 65521, m %= 65521;
              }
              a = n, b = m;
          },
          d: function () { return ((a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)) + ((a & 255) << 23) * 2; }
      };
  };
  // deflate with opts
  var dopt = function (dat, opt, pre, post, st) {
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
  };
  // write bytes
  var wbytes = function (d, b, v) {
      for (; v; ++b)
          d[b] = v, v >>>= 8;
  };
  // zlib header
  var zlh = function (c, o) {
      var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);
  };
  // zlib valid
  var zlv = function (d) {
      if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
          throw 'invalid zlib data';
      if (d[1] & 32)
          throw 'invalid zlib data: preset dictionaries not supported';
  };
  /**
   * Compress data with Zlib
   * @param data The data to compress
   * @param opts The compression options
   * @returns The zlib-compressed version of the data
   */
  function zlibSync(data, opts) {
      if (opts === void 0) { opts = {}; }
      var a = adler();
      a.p(data);
      var d = dopt(data, opts, 2, 4);
      return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
  }
  /**
   * Expands Zlib data
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */
  function unzlibSync(data, out) {
      return inflt((zlv(data), data.subarray(2, -4)), out);
  }

  /** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   */
  var n$1=function(){return "undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this}();function i$6(){n$1.console&&"function"==typeof n$1.console.log&&n$1.console.log.apply(n$1.console,arguments);}var a$2={log:i$6,warn:function(t){n$1.console&&("function"==typeof n$1.console.warn?n$1.console.warn.apply(n$1.console,arguments):i$6.call(null,arguments));},error:function(t){n$1.console&&("function"==typeof n$1.console.error?n$1.console.error.apply(n$1.console,arguments):i$6(t));}};function o$1(t,e,r){var n=new XMLHttpRequest;n.open("GET",t),n.responseType="blob",n.onload=function(){l$1(n.response,e,r);},n.onerror=function(){a$2.error("could not download file");},n.send();}function s$1(t){var e=new XMLHttpRequest;e.open("HEAD",t,!1);try{e.send();}catch(t){}return e.status>=200&&e.status<=299}function c$2(t){try{t.dispatchEvent(new MouseEvent("click"));}catch(r){var e=document.createEvent("MouseEvents");e.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),t.dispatchEvent(e);}}var u$2,h$1,l$1=n$1.saveAs||("object"!==("undefined"==typeof window?"undefined":_typeof$2(window))||window!==n$1?function(){}:"undefined"!=typeof HTMLAnchorElement&&"download"in HTMLAnchorElement.prototype?function(t,e,r){var i=n$1.URL||n$1.webkitURL,a=document.createElement("a");e=e||t.name||"download",a.download=e,a.rel="noopener","string"==typeof t?(a.href=t,a.origin!==location.origin?s$1(a.href)?o$1(t,e,r):c$2(a,a.target="_blank"):c$2(a)):(a.href=i.createObjectURL(t),setTimeout((function(){i.revokeObjectURL(a.href);}),4e4),setTimeout((function(){c$2(a);}),0));}:"msSaveOrOpenBlob"in navigator?function(e,r,n){if(r=r||e.name||"download","string"==typeof e)if(s$1(e))o$1(e,r,n);else {var i=document.createElement("a");i.href=e,i.target="_blank",setTimeout((function(){c$2(i);}));}else navigator.msSaveOrOpenBlob(function(e,r){return void 0===r?r={autoBom:!1}:"object"!==_typeof$2(r)&&(a$2.warn("Deprecated: Expected third argument to be a object"),r={autoBom:!r}),r.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e}(e,n),r);}:function(e,r,i,a){if((a=a||open("","_blank"))&&(a.document.title=a.document.body.innerText="downloading..."),"string"==typeof e)return o$1(e,r,i);var s="application/octet-stream"===e.type,c=/constructor/i.test(n$1.HTMLElement)||n$1.safari,u=/CriOS\/[\d]+/.test(navigator.userAgent);if((u||s&&c)&&"object"===("undefined"==typeof FileReader?"undefined":_typeof$2(FileReader))){var h=new FileReader;h.onloadend=function(){var t=h.result;t=u?t:t.replace(/^data:[^;]*;/,"data:attachment/file;"),a?a.location.href=t:location=t,a=null;},h.readAsDataURL(e);}else {var l=n$1.URL||n$1.webkitURL,f=l.createObjectURL(e);a?a.location=f:location.href=f,a=null,setTimeout((function(){l.revokeObjectURL(f);}),4e4);}});
  /**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   */function f$2(t){var e;t=t||"",this.ok=!1,"#"==t.charAt(0)&&(t=t.substr(1,6));t={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"}[t=(t=t.replace(/ /g,"")).toLowerCase()]||t;for(var r=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example:["rgb(123, 234, 45)","rgb(255,234,245)"],process:function(t){return [parseInt(t[1]),parseInt(t[2]),parseInt(t[3])]}},{re:/^(\w{2})(\w{2})(\w{2})$/,example:["#00ff00","336699"],process:function(t){return [parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,example:["#fb0","f0f"],process:function(t){return [parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}}],n=0;n<r.length;n++){var i=r[n].re,a=r[n].process,o=i.exec(t);o&&(e=a(o),this.r=e[0],this.g=e[1],this.b=e[2],this.ok=!0);}this.r=this.r<0||isNaN(this.r)?0:this.r>255?255:this.r,this.g=this.g<0||isNaN(this.g)?0:this.g>255?255:this.g,this.b=this.b<0||isNaN(this.b)?0:this.b>255?255:this.b,this.toRGB=function(){return "rgb("+this.r+", "+this.g+", "+this.b+")"},this.toHex=function(){var t=this.r.toString(16),e=this.g.toString(16),r=this.b.toString(16);return 1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==r.length&&(r="0"+r),"#"+t+e+r};}
  /**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   */
  function d(t,e){var r=t[0],n=t[1],i=t[2],a=t[3];r=g(r,n,i,a,e[0],7,-680876936),a=g(a,r,n,i,e[1],12,-389564586),i=g(i,a,r,n,e[2],17,606105819),n=g(n,i,a,r,e[3],22,-1044525330),r=g(r,n,i,a,e[4],7,-176418897),a=g(a,r,n,i,e[5],12,1200080426),i=g(i,a,r,n,e[6],17,-1473231341),n=g(n,i,a,r,e[7],22,-45705983),r=g(r,n,i,a,e[8],7,1770035416),a=g(a,r,n,i,e[9],12,-1958414417),i=g(i,a,r,n,e[10],17,-42063),n=g(n,i,a,r,e[11],22,-1990404162),r=g(r,n,i,a,e[12],7,1804603682),a=g(a,r,n,i,e[13],12,-40341101),i=g(i,a,r,n,e[14],17,-1502002290),r=m$2(r,n=g(n,i,a,r,e[15],22,1236535329),i,a,e[1],5,-165796510),a=m$2(a,r,n,i,e[6],9,-1069501632),i=m$2(i,a,r,n,e[11],14,643717713),n=m$2(n,i,a,r,e[0],20,-373897302),r=m$2(r,n,i,a,e[5],5,-701558691),a=m$2(a,r,n,i,e[10],9,38016083),i=m$2(i,a,r,n,e[15],14,-660478335),n=m$2(n,i,a,r,e[4],20,-405537848),r=m$2(r,n,i,a,e[9],5,568446438),a=m$2(a,r,n,i,e[14],9,-1019803690),i=m$2(i,a,r,n,e[3],14,-187363961),n=m$2(n,i,a,r,e[8],20,1163531501),r=m$2(r,n,i,a,e[13],5,-1444681467),a=m$2(a,r,n,i,e[2],9,-51403784),i=m$2(i,a,r,n,e[7],14,1735328473),r=v$1(r,n=m$2(n,i,a,r,e[12],20,-1926607734),i,a,e[5],4,-378558),a=v$1(a,r,n,i,e[8],11,-2022574463),i=v$1(i,a,r,n,e[11],16,1839030562),n=v$1(n,i,a,r,e[14],23,-35309556),r=v$1(r,n,i,a,e[1],4,-1530992060),a=v$1(a,r,n,i,e[4],11,1272893353),i=v$1(i,a,r,n,e[7],16,-155497632),n=v$1(n,i,a,r,e[10],23,-1094730640),r=v$1(r,n,i,a,e[13],4,681279174),a=v$1(a,r,n,i,e[0],11,-358537222),i=v$1(i,a,r,n,e[3],16,-722521979),n=v$1(n,i,a,r,e[6],23,76029189),r=v$1(r,n,i,a,e[9],4,-640364487),a=v$1(a,r,n,i,e[12],11,-421815835),i=v$1(i,a,r,n,e[15],16,530742520),r=b(r,n=v$1(n,i,a,r,e[2],23,-995338651),i,a,e[0],6,-198630844),a=b(a,r,n,i,e[7],10,1126891415),i=b(i,a,r,n,e[14],15,-1416354905),n=b(n,i,a,r,e[5],21,-57434055),r=b(r,n,i,a,e[12],6,1700485571),a=b(a,r,n,i,e[3],10,-1894986606),i=b(i,a,r,n,e[10],15,-1051523),n=b(n,i,a,r,e[1],21,-2054922799),r=b(r,n,i,a,e[8],6,1873313359),a=b(a,r,n,i,e[15],10,-30611744),i=b(i,a,r,n,e[6],15,-1560198380),n=b(n,i,a,r,e[13],21,1309151649),r=b(r,n,i,a,e[4],6,-145523070),a=b(a,r,n,i,e[11],10,-1120210379),i=b(i,a,r,n,e[2],15,718787259),n=b(n,i,a,r,e[9],21,-343485551),t[0]=_$1(r,t[0]),t[1]=_$1(n,t[1]),t[2]=_$1(i,t[2]),t[3]=_$1(a,t[3]);}function p$1(t,e,r,n,i,a){return e=_$1(_$1(e,t),_$1(n,a)),_$1(e<<i|e>>>32-i,r)}function g(t,e,r,n,i,a,o){return p$1(e&r|~e&n,t,e,i,a,o)}function m$2(t,e,r,n,i,a,o){return p$1(e&n|r&~n,t,e,i,a,o)}function v$1(t,e,r,n,i,a,o){return p$1(e^r^n,t,e,i,a,o)}function b(t,e,r,n,i,a,o){return p$1(r^(e|~n),t,e,i,a,o)}function y$1(t){var e,r=t.length,n=[1732584193,-271733879,-1732584194,271733878];for(e=64;e<=t.length;e+=64)d(n,w(t.substring(e-64,e)));t=t.substring(e-64);var i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(e=0;e<t.length;e++)i[e>>2]|=t.charCodeAt(e)<<(e%4<<3);if(i[e>>2]|=128<<(e%4<<3),e>55)for(d(n,i),e=0;e<16;e++)i[e]=0;return i[14]=8*r,d(n,i),n}function w(t){var e,r=[];for(e=0;e<64;e+=4)r[e>>2]=t.charCodeAt(e)+(t.charCodeAt(e+1)<<8)+(t.charCodeAt(e+2)<<16)+(t.charCodeAt(e+3)<<24);return r}u$2=n$1.atob.bind(n$1),h$1=n$1.btoa.bind(n$1);var N$1="0123456789abcdef".split("");function L$1(t){for(var e="",r=0;r<4;r++)e+=N$1[t>>8*r+4&15]+N$1[t>>8*r&15];return e}function A$1(t){return String.fromCharCode((255&t)>>0,(65280&t)>>8,(16711680&t)>>16,(4278190080&t)>>24)}function x(t){return y$1(t).map(A$1).join("")}var S="5d41402abc4b2a76b9719d911017c592"!=function(t){for(var e=0;e<t.length;e++)t[e]=L$1(t[e]);return t.join("")}(y$1("hello"));function _$1(t,e){if(S){var r=(65535&t)+(65535&e);return (t>>16)+(e>>16)+(r>>16)<<16|65535&r}return t+e&4294967295}
  /**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   */function P(t,e){var r,n,i,a;if(t!==r){for(var o=(i=t,a=1+(256/t.length>>0),new Array(a+1).join(i)),s=[],c=0;c<256;c++)s[c]=c;var u=0;for(c=0;c<256;c++){var h=s[c];u=(u+h+o.charCodeAt(c))%256,s[c]=s[u],s[u]=h;}r=t,n=s;}else s=n;var l=e.length,f=0,d=0,p="";for(c=0;c<l;c++)d=(d+(h=s[f=(f+1)%256]))%256,s[f]=s[d],s[d]=h,o=s[(s[f]+s[d])%256],p+=String.fromCharCode(e.charCodeAt(c)^o);return p}
  /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   */var k={print:4,modify:8,copy:16,"annot-forms":32};function I(t,e,r,n){this.v=1,this.r=2;var i=192;t.forEach((function(t){i+=k[t];})),this.padding="(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";var a=(e+this.padding).substr(0,32),o=(r+this.padding).substr(0,32);this.O=this.processOwnerPassword(a,o),this.P=-(1+(255^i)),this.encryptionKey=x(a+this.O+this.lsbFirstWord(this.P)+this.hexToBytes(n)).substr(0,5),this.U=P(this.encryptionKey,this.padding);}function F$1(t){if(/[^\u0000-\u00ff]/.test(t))throw new Error("Invalid PDF Name Object: "+t+", Only accept ASCII characters.");for(var e="",r=t.length,n=0;n<r;n++){var i=t.charCodeAt(n);if(i<33||35===i||37===i||40===i||41===i||47===i||60===i||62===i||91===i||93===i||123===i||125===i||i>126)e+="#"+("0"+i.toString(16)).slice(-2);else e+=t[n];}return e}function C(e){if("object"!==_typeof$2(e))throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");var r={};this.subscribe=function(t,e,n){if(n=n||!1,"string"!=typeof t||"function"!=typeof e||"boolean"!=typeof n)throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");r.hasOwnProperty(t)||(r[t]={});var i=Math.random().toString(35);return r[t][i]=[e,!!n],i},this.unsubscribe=function(t){for(var e in r)if(r[e][t])return delete r[e][t],0===Object.keys(r[e]).length&&delete r[e],!0;return !1},this.publish=function(t){if(r.hasOwnProperty(t)){var i=Array.prototype.slice.call(arguments,1),o=[];for(var s in r[t]){var c=r[t][s];try{c[0].apply(e,i);}catch(t){n$1.console&&a$2.error("jsPDF PubSub Error",t.message,t);}c[1]&&o.push(s);}o.length&&o.forEach(this.unsubscribe);}},this.getTopics=function(){return r};}function j(t){if(!(this instanceof j))return new j(t);var e="opacity,stroke-opacity".split(",");for(var r in t)t.hasOwnProperty(r)&&e.indexOf(r)>=0&&(this[r]=t[r]);this.id="",this.objectNumber=-1;}function O$1(t,e){this.gState=t,this.matrix=e,this.id="",this.objectNumber=-1;}function B(t,e,r,n,i){if(!(this instanceof B))return new B(t,e,r,n,i);this.type="axial"===t?2:3,this.coords=e,this.colors=r,O$1.call(this,n,i);}function M(t,e,r,n,i){if(!(this instanceof M))return new M(t,e,r,n,i);this.boundingBox=t,this.xStep=e,this.yStep=r,this.stream="",this.cloneIndex=0,O$1.call(this,n,i);}function E$1(e){var r,i="string"==typeof arguments[0]?arguments[0]:"p",o=arguments[1],s=arguments[2],c=arguments[3],u=[],d=1,p=16,g="S",m=null;"object"===_typeof$2(e=e||{})&&(i=e.orientation,o=e.unit||o,s=e.format||s,c=e.compress||e.compressPdf||c,null!==(m=e.encryption||null)&&(m.userPassword=m.userPassword||"",m.ownerPassword=m.ownerPassword||"",m.userPermissions=m.userPermissions||[]),d="number"==typeof e.userUnit?Math.abs(e.userUnit):1,void 0!==e.precision&&(r=e.precision),void 0!==e.floatPrecision&&(p=e.floatPrecision),g=e.defaultPathOperation||"S"),u=e.filters||(!0===c?["FlateEncode"]:u),o=o||"mm",i=(""+(i||"P")).toLowerCase();var v=e.putOnlyUsedFonts||!1,b={},y={internal:{},__private__:{}};y.__private__.PubSub=C;var w="1.3",N=y.__private__.getPdfVersion=function(){return w};y.__private__.setPdfVersion=function(t){w=t;};var L={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};y.__private__.getPageFormats=function(){return L};var A=y.__private__.getPageFormat=function(t){return L[t]};s=s||"a4";var x={COMPAT:"compat",ADVANCED:"advanced"},S=x.COMPAT;function _(){this.saveGraphicsState(),lt(new Vt(_t,0,0,-_t,0,Rr()*_t).toString()+" cm"),this.setFontSize(this.getFontSize()/_t),g="n",S=x.ADVANCED;}function P(){this.restoreGraphicsState(),g="S",S=x.COMPAT;}var k=y.__private__.combineFontStyleAndFontWeight=function(t,e){if("bold"==t&&"normal"==e||"bold"==t&&400==e||"normal"==t&&"italic"==e||"bold"==t&&"italic"==e)throw new Error("Invalid Combination of fontweight and fontstyle");return e&&(t=400==e||"normal"===e?"italic"===t?"italic":"normal":700!=e&&"bold"!==e||"normal"!==t?(700==e?"bold":e)+""+t:"bold"),t};y.advancedAPI=function(t){var e=S===x.COMPAT;return e&&_.call(this),"function"!=typeof t||(t(this),e&&P.call(this)),this},y.compatAPI=function(t){var e=S===x.ADVANCED;return e&&P.call(this),"function"!=typeof t||(t(this),e&&_.call(this)),this},y.isAdvancedAPI=function(){return S===x.ADVANCED};var O,q=function(t){if(S!==x.ADVANCED)throw new Error(t+" is only available in 'advanced' API mode. You need to call advancedAPI() first.")},D=y.roundToPrecision=y.__private__.roundToPrecision=function(t,e){var n=r||e;if(isNaN(t)||isNaN(n))throw new Error("Invalid argument passed to jsPDF.roundToPrecision");return t.toFixed(n).replace(/0+$/,"")};O=y.hpf=y.__private__.hpf="number"==typeof p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,p)}:"smart"===p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,t>-1&&t<1?16:5)}:function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,16)};var R=y.f2=y.__private__.f2=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f2");return D(t,2)},T=y.__private__.f3=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f3");return D(t,3)},U=y.scale=y.__private__.scale=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.scale");return S===x.COMPAT?t*_t:S===x.ADVANCED?t:void 0},z=function(t){return S===x.COMPAT?Rr()-t:S===x.ADVANCED?t:void 0},H=function(t){return U(z(t))};y.__private__.setPrecision=y.setPrecision=function(t){"number"==typeof parseInt(t,10)&&(r=parseInt(t,10));};var W,V="00000000000000000000000000000000",G=y.__private__.getFileId=function(){return V},Y=y.__private__.setFileId=function(t){return V=void 0!==t&&/^[a-fA-F0-9]{32}$/.test(t)?t.toUpperCase():V.split("").map((function(){return "ABCDEF0123456789".charAt(Math.floor(16*Math.random()))})).join(""),null!==m&&(Ye=new I(m.userPermissions,m.userPassword,m.ownerPassword,V)),V};y.setFileId=function(t){return Y(t),this},y.getFileId=function(){return G()};var J=y.__private__.convertDateToPDFDate=function(t){var e=t.getTimezoneOffset(),r=e<0?"+":"-",n=Math.floor(Math.abs(e/60)),i=Math.abs(e%60),a=[r,Q(n),"'",Q(i),"'"].join("");return ["D:",t.getFullYear(),Q(t.getMonth()+1),Q(t.getDate()),Q(t.getHours()),Q(t.getMinutes()),Q(t.getSeconds()),a].join("")},X=y.__private__.convertPDFDateToDate=function(t){var e=parseInt(t.substr(2,4),10),r=parseInt(t.substr(6,2),10)-1,n=parseInt(t.substr(8,2),10),i=parseInt(t.substr(10,2),10),a=parseInt(t.substr(12,2),10),o=parseInt(t.substr(14,2),10);return new Date(e,r,n,i,a,o,0)},K=y.__private__.setCreationDate=function(t){var e;if(void 0===t&&(t=new Date),t instanceof Date)e=J(t);else {if(!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t))throw new Error("Invalid argument passed to jsPDF.setCreationDate");e=t;}return W=e},Z=y.__private__.getCreationDate=function(t){var e=W;return "jsDate"===t&&(e=X(W)),e};y.setCreationDate=function(t){return K(t),this},y.getCreationDate=function(t){return Z(t)};var $,Q=y.__private__.padd2=function(t){return ("0"+parseInt(t)).slice(-2)},tt=y.__private__.padd2Hex=function(t){return ("00"+(t=t.toString())).substr(t.length)},et=0,rt=[],nt=[],it=0,at=[],ot=[],st=!1,ct=nt,ut=function(){et=0,it=0,nt=[],rt=[],at=[],Qt=Kt(),te=Kt();};y.__private__.setCustomOutputDestination=function(t){st=!0,ct=t;};var ht=function(t){st||(ct=t);};y.__private__.resetCustomOutputDestination=function(){st=!1,ct=nt;};var lt=y.__private__.out=function(t){return t=t.toString(),it+=t.length+1,ct.push(t),ct},ft=y.__private__.write=function(t){return lt(1===arguments.length?t.toString():Array.prototype.join.call(arguments," "))},dt=y.__private__.getArrayBuffer=function(t){for(var e=t.length,r=new ArrayBuffer(e),n=new Uint8Array(r);e--;)n[e]=t.charCodeAt(e);return r},pt=[["Helvetica","helvetica","normal","WinAnsiEncoding"],["Helvetica-Bold","helvetica","bold","WinAnsiEncoding"],["Helvetica-Oblique","helvetica","italic","WinAnsiEncoding"],["Helvetica-BoldOblique","helvetica","bolditalic","WinAnsiEncoding"],["Courier","courier","normal","WinAnsiEncoding"],["Courier-Bold","courier","bold","WinAnsiEncoding"],["Courier-Oblique","courier","italic","WinAnsiEncoding"],["Courier-BoldOblique","courier","bolditalic","WinAnsiEncoding"],["Times-Roman","times","normal","WinAnsiEncoding"],["Times-Bold","times","bold","WinAnsiEncoding"],["Times-Italic","times","italic","WinAnsiEncoding"],["Times-BoldItalic","times","bolditalic","WinAnsiEncoding"],["ZapfDingbats","zapfdingbats","normal",null],["Symbol","symbol","normal",null]];y.__private__.getStandardFonts=function(){return pt};var gt=e.fontSize||16;y.__private__.setFontSize=y.setFontSize=function(t){return gt=S===x.ADVANCED?t/_t:t,this};var mt,vt=y.__private__.getFontSize=y.getFontSize=function(){return S===x.COMPAT?gt:gt*_t},bt=e.R2L||!1;y.__private__.setR2L=y.setR2L=function(t){return bt=t,this},y.__private__.getR2L=y.getR2L=function(){return bt};var yt,wt=y.__private__.setZoomMode=function(t){var e=[void 0,null,"fullwidth","fullheight","fullpage","original"];if(/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t))mt=t;else if(isNaN(t)){if(-1===e.indexOf(t))throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "'+t+'" is not recognized.');mt=t;}else mt=parseInt(t,10);};y.__private__.getZoomMode=function(){return mt};var Nt,Lt=y.__private__.setPageMode=function(t){if(-1==[void 0,null,"UseNone","UseOutlines","UseThumbs","FullScreen"].indexOf(t))throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "'+t+'" is not recognized.');yt=t;};y.__private__.getPageMode=function(){return yt};var At=y.__private__.setLayoutMode=function(t){if(-1==[void 0,null,"continuous","single","twoleft","tworight","two"].indexOf(t))throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "'+t+'" is not recognized.');Nt=t;};y.__private__.getLayoutMode=function(){return Nt},y.__private__.setDisplayMode=y.setDisplayMode=function(t,e,r){return wt(t),At(e),Lt(r),this};var xt={title:"",subject:"",author:"",keywords:"",creator:""};y.__private__.getDocumentProperty=function(t){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");return xt[t]},y.__private__.getDocumentProperties=function(){return xt},y.__private__.setDocumentProperties=y.setProperties=y.setDocumentProperties=function(t){for(var e in xt)xt.hasOwnProperty(e)&&t[e]&&(xt[e]=t[e]);return this},y.__private__.setDocumentProperty=function(t,e){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");return xt[t]=e};var St,_t,Pt,kt,It,Ft={},Ct={},jt=[],Ot={},Bt={},Mt={},Et={},qt=null,Dt=0,Rt=[],Tt=new C(y),Ut=e.hotfixes||[],zt={},Ht={},Wt=[],Vt=function t(e,r,n,i,a,o){if(!(this instanceof t))return new t(e,r,n,i,a,o);isNaN(e)&&(e=1),isNaN(r)&&(r=0),isNaN(n)&&(n=0),isNaN(i)&&(i=1),isNaN(a)&&(a=0),isNaN(o)&&(o=0),this._matrix=[e,r,n,i,a,o];};Object.defineProperty(Vt.prototype,"sx",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Vt.prototype,"shy",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Vt.prototype,"shx",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Vt.prototype,"sy",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Vt.prototype,"tx",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Vt.prototype,"ty",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Vt.prototype,"a",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Vt.prototype,"b",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Vt.prototype,"c",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Vt.prototype,"d",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Vt.prototype,"e",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Vt.prototype,"f",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Vt.prototype,"rotation",{get:function(){return Math.atan2(this.shx,this.sx)}}),Object.defineProperty(Vt.prototype,"scaleX",{get:function(){return this.decompose().scale.sx}}),Object.defineProperty(Vt.prototype,"scaleY",{get:function(){return this.decompose().scale.sy}}),Object.defineProperty(Vt.prototype,"isIdentity",{get:function(){return 1===this.sx&&(0===this.shy&&(0===this.shx&&(1===this.sy&&(0===this.tx&&0===this.ty))))}}),Vt.prototype.join=function(t){return [this.sx,this.shy,this.shx,this.sy,this.tx,this.ty].map(O).join(t)},Vt.prototype.multiply=function(t){var e=t.sx*this.sx+t.shy*this.shx,r=t.sx*this.shy+t.shy*this.sy,n=t.shx*this.sx+t.sy*this.shx,i=t.shx*this.shy+t.sy*this.sy,a=t.tx*this.sx+t.ty*this.shx+this.tx,o=t.tx*this.shy+t.ty*this.sy+this.ty;return new Vt(e,r,n,i,a,o)},Vt.prototype.decompose=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty,o=Math.sqrt(t*t+e*e),s=(t/=o)*r+(e/=o)*n;r-=t*s,n-=e*s;var c=Math.sqrt(r*r+n*n);return s/=c,t*(n/=c)<e*(r/=c)&&(t=-t,e=-e,s=-s,o=-o),{scale:new Vt(o,0,0,c,0,0),translate:new Vt(1,0,0,1,i,a),rotate:new Vt(t,e,-e,t,0,0),skew:new Vt(1,0,s,1,0,0)}},Vt.prototype.toString=function(t){return this.join(" ")},Vt.prototype.inversed=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty,o=1/(t*n-e*r),s=n*o,c=-e*o,u=-r*o,h=t*o;return new Vt(s,c,u,h,-s*i-u*a,-c*i-h*a)},Vt.prototype.applyToPoint=function(t){var e=t.x*this.sx+t.y*this.shx+this.tx,r=t.x*this.shy+t.y*this.sy+this.ty;return new Cr(e,r)},Vt.prototype.applyToRectangle=function(t){var e=this.applyToPoint(t),r=this.applyToPoint(new Cr(t.x+t.w,t.y+t.h));return new jr(e.x,e.y,r.x-e.x,r.y-e.y)},Vt.prototype.clone=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty;return new Vt(t,e,r,n,i,a)},y.Matrix=Vt;var Gt=y.matrixMult=function(t,e){return e.multiply(t)},Yt=new Vt(1,0,0,1,0,0);y.unitMatrix=y.identityMatrix=Yt;var Jt=function(t,e){if(!Bt[t]){var r=(e instanceof B?"Sh":"P")+(Object.keys(Ot).length+1).toString(10);e.id=r,Bt[t]=r,Ot[r]=e,Tt.publish("addPattern",e);}};y.ShadingPattern=B,y.TilingPattern=M,y.addShadingPattern=function(t,e){return q("addShadingPattern()"),Jt(t,e),this},y.beginTilingPattern=function(t){q("beginTilingPattern()"),Br(t.boundingBox[0],t.boundingBox[1],t.boundingBox[2]-t.boundingBox[0],t.boundingBox[3]-t.boundingBox[1],t.matrix);},y.endTilingPattern=function(t,e){q("endTilingPattern()"),e.stream=ot[$].join("\n"),Jt(t,e),Tt.publish("endTilingPattern",e),Wt.pop().restore();};var Xt=y.__private__.newObject=function(){var t=Kt();return Zt(t,!0),t},Kt=y.__private__.newObjectDeferred=function(){return et++,rt[et]=function(){return it},et},Zt=function(t,e){return e="boolean"==typeof e&&e,rt[t]=it,e&&lt(t+" 0 obj"),t},$t=y.__private__.newAdditionalObject=function(){var t={objId:Kt(),content:""};return at.push(t),t},Qt=Kt(),te=Kt(),ee=y.__private__.decodeColorString=function(t){var e=t.split(" ");if(2!==e.length||"g"!==e[1]&&"G"!==e[1]){if(5===e.length&&("k"===e[4]||"K"===e[4])){e=[(1-e[0])*(1-e[3]),(1-e[1])*(1-e[3]),(1-e[2])*(1-e[3]),"r"];}}else {var r=parseFloat(e[0]);e=[r,r,r,"r"];}for(var n="#",i=0;i<3;i++)n+=("0"+Math.floor(255*parseFloat(e[i])).toString(16)).slice(-2);return n},re=y.__private__.encodeColorString=function(e){var r;"string"==typeof e&&(e={ch1:e});var n=e.ch1,i=e.ch2,a=e.ch3,o=e.ch4,s="draw"===e.pdfColorType?["G","RG","K"]:["g","rg","k"];if("string"==typeof n&&"#"!==n.charAt(0)){var c=new f$2(n);if(c.ok)n=c.toHex();else if(!/^\d*\.?\d*$/.test(n))throw new Error('Invalid color "'+n+'" passed to jsPDF.encodeColorString.')}if("string"==typeof n&&/^#[0-9A-Fa-f]{3}$/.test(n)&&(n="#"+n[1]+n[1]+n[2]+n[2]+n[3]+n[3]),"string"==typeof n&&/^#[0-9A-Fa-f]{6}$/.test(n)){var u=parseInt(n.substr(1),16);n=u>>16&255,i=u>>8&255,a=255&u;}if(void 0===i||void 0===o&&n===i&&i===a)if("string"==typeof n)r=n+" "+s[0];else switch(e.precision){case 2:r=R(n/255)+" "+s[0];break;case 3:default:r=T(n/255)+" "+s[0];}else if(void 0===o||"object"===_typeof$2(o)){if(o&&!isNaN(o.a)&&0===o.a)return r=["1.","1.","1.",s[1]].join(" ");if("string"==typeof n)r=[n,i,a,s[1]].join(" ");else switch(e.precision){case 2:r=[R(n/255),R(i/255),R(a/255),s[1]].join(" ");break;default:case 3:r=[T(n/255),T(i/255),T(a/255),s[1]].join(" ");}}else if("string"==typeof n)r=[n,i,a,o,s[2]].join(" ");else switch(e.precision){case 2:r=[R(n),R(i),R(a),R(o),s[2]].join(" ");break;case 3:default:r=[T(n),T(i),T(a),T(o),s[2]].join(" ");}return r},ne=y.__private__.getFilters=function(){return u},ie=y.__private__.putStream=function(t){var e=(t=t||{}).data||"",r=t.filters||ne(),n=t.alreadyAppliedFilters||[],i=t.addLength1||!1,a=e.length,o=t.objectId,s=function(t){return t};if(null!==m&&void 0===o)throw new Error("ObjectId must be passed to putStream for file encryption");null!==m&&(s=Ye.encryptor(o,0));var c={};!0===r&&(r=["FlateEncode"]);var u=t.additionalKeyValues||[],h=(c=void 0!==E$1.API.processDataByFilters?E$1.API.processDataByFilters(e,r):{data:e,reverseChain:[]}).reverseChain+(Array.isArray(n)?n.join(" "):n.toString());if(0!==c.data.length&&(u.push({key:"Length",value:c.data.length}),!0===i&&u.push({key:"Length1",value:a})),0!=h.length)if(h.split("/").length-1==1)u.push({key:"Filter",value:h});else {u.push({key:"Filter",value:"["+h+"]"});for(var l=0;l<u.length;l+=1)if("DecodeParms"===u[l].key){for(var f=[],d=0;d<c.reverseChain.split("/").length-1;d+=1)f.push("null");f.push(u[l].value),u[l].value="["+f.join(" ")+"]";}}lt("<<");for(var p=0;p<u.length;p++)lt("/"+u[p].key+" "+u[p].value);lt(">>"),0!==c.data.length&&(lt("stream"),lt(s(c.data)),lt("endstream"));},ae=y.__private__.putPage=function(t){var e=t.number,r=t.data,n=t.objId,i=t.contentsObjId;Zt(n,!0),lt("<</Type /Page"),lt("/Parent "+t.rootDictionaryObjId+" 0 R"),lt("/Resources "+t.resourceDictionaryObjId+" 0 R"),lt("/MediaBox ["+parseFloat(O(t.mediaBox.bottomLeftX))+" "+parseFloat(O(t.mediaBox.bottomLeftY))+" "+O(t.mediaBox.topRightX)+" "+O(t.mediaBox.topRightY)+"]"),null!==t.cropBox&&lt("/CropBox ["+O(t.cropBox.bottomLeftX)+" "+O(t.cropBox.bottomLeftY)+" "+O(t.cropBox.topRightX)+" "+O(t.cropBox.topRightY)+"]"),null!==t.bleedBox&&lt("/BleedBox ["+O(t.bleedBox.bottomLeftX)+" "+O(t.bleedBox.bottomLeftY)+" "+O(t.bleedBox.topRightX)+" "+O(t.bleedBox.topRightY)+"]"),null!==t.trimBox&&lt("/TrimBox ["+O(t.trimBox.bottomLeftX)+" "+O(t.trimBox.bottomLeftY)+" "+O(t.trimBox.topRightX)+" "+O(t.trimBox.topRightY)+"]"),null!==t.artBox&&lt("/ArtBox ["+O(t.artBox.bottomLeftX)+" "+O(t.artBox.bottomLeftY)+" "+O(t.artBox.topRightX)+" "+O(t.artBox.topRightY)+"]"),"number"==typeof t.userUnit&&1!==t.userUnit&&lt("/UserUnit "+t.userUnit),Tt.publish("putPage",{objId:n,pageContext:Rt[e],pageNumber:e,page:r}),lt("/Contents "+i+" 0 R"),lt(">>"),lt("endobj");var a=r.join("\n");return S===x.ADVANCED&&(a+="\nQ"),Zt(i,!0),ie({data:a,filters:ne(),objectId:i}),lt("endobj"),n},oe=y.__private__.putPages=function(){var t,e,r=[];for(t=1;t<=Dt;t++)Rt[t].objId=Kt(),Rt[t].contentsObjId=Kt();for(t=1;t<=Dt;t++)r.push(ae({number:t,data:ot[t],objId:Rt[t].objId,contentsObjId:Rt[t].contentsObjId,mediaBox:Rt[t].mediaBox,cropBox:Rt[t].cropBox,bleedBox:Rt[t].bleedBox,trimBox:Rt[t].trimBox,artBox:Rt[t].artBox,userUnit:Rt[t].userUnit,rootDictionaryObjId:Qt,resourceDictionaryObjId:te}));Zt(Qt,!0),lt("<</Type /Pages");var n="/Kids [";for(e=0;e<Dt;e++)n+=r[e]+" 0 R ";lt(n+"]"),lt("/Count "+Dt),lt(">>"),lt("endobj"),Tt.publish("postPutPages");},se=function(t){Tt.publish("putFont",{font:t,out:lt,newObject:Xt,putStream:ie}),!0!==t.isAlreadyPutted&&(t.objectNumber=Xt(),lt("<<"),lt("/Type /Font"),lt("/BaseFont /"+F$1(t.postScriptName)),lt("/Subtype /Type1"),"string"==typeof t.encoding&&lt("/Encoding /"+t.encoding),lt("/FirstChar 32"),lt("/LastChar 255"),lt(">>"),lt("endobj"));},ce=function(){for(var t in Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&se(Ft[t]);},ue=function(t){t.objectNumber=Xt();var e=[];e.push({key:"Type",value:"/XObject"}),e.push({key:"Subtype",value:"/Form"}),e.push({key:"BBox",value:"["+[O(t.x),O(t.y),O(t.x+t.width),O(t.y+t.height)].join(" ")+"]"}),e.push({key:"Matrix",value:"["+t.matrix.toString()+"]"});var r=t.pages[1].join("\n");ie({data:r,additionalKeyValues:e,objectId:t.objectNumber}),lt("endobj");},he=function(){for(var t in zt)zt.hasOwnProperty(t)&&ue(zt[t]);},le=function(t,e){var r,n=[],i=1/(e-1);for(r=0;r<1;r+=i)n.push(r);if(n.push(1),0!=t[0].offset){var a={offset:0,color:t[0].color};t.unshift(a);}if(1!=t[t.length-1].offset){var o={offset:1,color:t[t.length-1].color};t.push(o);}for(var s="",c=0,u=0;u<n.length;u++){for(r=n[u];r>t[c+1].offset;)c++;var h=t[c].offset,l=(r-h)/(t[c+1].offset-h),f=t[c].color,d=t[c+1].color;s+=tt(Math.round((1-l)*f[0]+l*d[0]).toString(16))+tt(Math.round((1-l)*f[1]+l*d[1]).toString(16))+tt(Math.round((1-l)*f[2]+l*d[2]).toString(16));}return s.trim()},fe=function(t,e){e||(e=21);var r=Xt(),n=le(t.colors,e),i=[];i.push({key:"FunctionType",value:"0"}),i.push({key:"Domain",value:"[0.0 1.0]"}),i.push({key:"Size",value:"["+e+"]"}),i.push({key:"BitsPerSample",value:"8"}),i.push({key:"Range",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),i.push({key:"Decode",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),ie({data:n,additionalKeyValues:i,alreadyAppliedFilters:["/ASCIIHexDecode"],objectId:r}),lt("endobj"),t.objectNumber=Xt(),lt("<< /ShadingType "+t.type),lt("/ColorSpace /DeviceRGB");var a="/Coords ["+O(parseFloat(t.coords[0]))+" "+O(parseFloat(t.coords[1]))+" ";2===t.type?a+=O(parseFloat(t.coords[2]))+" "+O(parseFloat(t.coords[3])):a+=O(parseFloat(t.coords[2]))+" "+O(parseFloat(t.coords[3]))+" "+O(parseFloat(t.coords[4]))+" "+O(parseFloat(t.coords[5])),lt(a+="]"),t.matrix&&lt("/Matrix ["+t.matrix.toString()+"]"),lt("/Function "+r+" 0 R"),lt("/Extend [true true]"),lt(">>"),lt("endobj");},de=function(t,e){var r=Kt(),n=Xt();e.push({resourcesOid:r,objectOid:n}),t.objectNumber=n;var i=[];i.push({key:"Type",value:"/Pattern"}),i.push({key:"PatternType",value:"1"}),i.push({key:"PaintType",value:"1"}),i.push({key:"TilingType",value:"1"}),i.push({key:"BBox",value:"["+t.boundingBox.map(O).join(" ")+"]"}),i.push({key:"XStep",value:O(t.xStep)}),i.push({key:"YStep",value:O(t.yStep)}),i.push({key:"Resources",value:r+" 0 R"}),t.matrix&&i.push({key:"Matrix",value:"["+t.matrix.toString()+"]"}),ie({data:t.stream,additionalKeyValues:i,objectId:t.objectNumber}),lt("endobj");},pe=function(t){var e;for(e in Ot)Ot.hasOwnProperty(e)&&(Ot[e]instanceof B?fe(Ot[e]):Ot[e]instanceof M&&de(Ot[e],t));},ge=function(t){for(var e in t.objectNumber=Xt(),lt("<<"),t)switch(e){case"opacity":lt("/ca "+R(t[e]));break;case"stroke-opacity":lt("/CA "+R(t[e]));}lt(">>"),lt("endobj");},me=function(){var t;for(t in Mt)Mt.hasOwnProperty(t)&&ge(Mt[t]);},ve=function(){for(var t in lt("/XObject <<"),zt)zt.hasOwnProperty(t)&&zt[t].objectNumber>=0&&lt("/"+t+" "+zt[t].objectNumber+" 0 R");Tt.publish("putXobjectDict"),lt(">>");},be=function(){Ye.oid=Xt(),lt("<<"),lt("/Filter /Standard"),lt("/V "+Ye.v),lt("/R "+Ye.r),lt("/U <"+Ye.toHexString(Ye.U)+">"),lt("/O <"+Ye.toHexString(Ye.O)+">"),lt("/P "+Ye.P),lt(">>"),lt("endobj");},ye=function(){for(var t in lt("/Font <<"),Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&lt("/"+t+" "+Ft[t].objectNumber+" 0 R");lt(">>");},we=function(){if(Object.keys(Ot).length>0){for(var t in lt("/Shading <<"),Ot)Ot.hasOwnProperty(t)&&Ot[t]instanceof B&&Ot[t].objectNumber>=0&&lt("/"+t+" "+Ot[t].objectNumber+" 0 R");Tt.publish("putShadingPatternDict"),lt(">>");}},Ne=function(t){if(Object.keys(Ot).length>0){for(var e in lt("/Pattern <<"),Ot)Ot.hasOwnProperty(e)&&Ot[e]instanceof y.TilingPattern&&Ot[e].objectNumber>=0&&Ot[e].objectNumber<t&&lt("/"+e+" "+Ot[e].objectNumber+" 0 R");Tt.publish("putTilingPatternDict"),lt(">>");}},Le=function(){if(Object.keys(Mt).length>0){var t;for(t in lt("/ExtGState <<"),Mt)Mt.hasOwnProperty(t)&&Mt[t].objectNumber>=0&&lt("/"+t+" "+Mt[t].objectNumber+" 0 R");Tt.publish("putGStateDict"),lt(">>");}},Ae=function(t){Zt(t.resourcesOid,!0),lt("<<"),lt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"),ye(),we(),Ne(t.objectOid),Le(),ve(),lt(">>"),lt("endobj");},xe=function(){var t=[];ce(),me(),he(),pe(t),Tt.publish("putResources"),t.forEach(Ae),Ae({resourcesOid:te,objectOid:Number.MAX_SAFE_INTEGER}),Tt.publish("postPutResources");},Se=function(){Tt.publish("putAdditionalObjects");for(var t=0;t<at.length;t++){var e=at[t];Zt(e.objId,!0),lt(e.content),lt("endobj");}Tt.publish("postPutAdditionalObjects");},_e=function(t){Ct[t.fontName]=Ct[t.fontName]||{},Ct[t.fontName][t.fontStyle]=t.id;},Pe=function(t,e,r,n,i){var a={id:"F"+(Object.keys(Ft).length+1).toString(10),postScriptName:t,fontName:e,fontStyle:r,encoding:n,isStandardFont:i||!1,metadata:{}};return Tt.publish("addFont",{font:a,instance:this}),Ft[a.id]=a,_e(a),a.id},ke=function(t){for(var e=0,r=pt.length;e<r;e++){var n=Pe.call(this,t[e][0],t[e][1],t[e][2],pt[e][3],!0);!1===v&&(b[n]=!0);var i=t[e][0].split("-");_e({id:n,fontName:i[0],fontStyle:i[1]||""});}Tt.publish("addFonts",{fonts:Ft,dictionary:Ct});},Ie=function(t){return t.foo=function(){try{return t.apply(this,arguments)}catch(t){var e=t.stack||"";~e.indexOf(" at ")&&(e=e.split(" at ")[1]);var r="Error in function "+e.split("\n")[0].split("<")[0]+": "+t.message;if(!n$1.console)throw new Error(r);n$1.console.error(r,t),n$1.alert&&alert(r);}},t.foo.bar=t,t.foo},Fe=function(t,e){var r,n,i,a,o,s,c,u,h;if(i=(e=e||{}).sourceEncoding||"Unicode",o=e.outputEncoding,(e.autoencode||o)&&Ft[St].metadata&&Ft[St].metadata[i]&&Ft[St].metadata[i].encoding&&(a=Ft[St].metadata[i].encoding,!o&&Ft[St].encoding&&(o=Ft[St].encoding),!o&&a.codePages&&(o=a.codePages[0]),"string"==typeof o&&(o=a[o]),o)){for(c=!1,s=[],r=0,n=t.length;r<n;r++)(u=o[t.charCodeAt(r)])?s.push(String.fromCharCode(u)):s.push(t[r]),s[r].charCodeAt(0)>>8&&(c=!0);t=s.join("");}for(r=t.length;void 0===c&&0!==r;)t.charCodeAt(r-1)>>8&&(c=!0),r--;if(!c)return t;for(s=e.noBOM?[]:[254,255],r=0,n=t.length;r<n;r++){if((h=(u=t.charCodeAt(r))>>8)>>8)throw new Error("Character at position "+r+" of string '"+t+"' exceeds 16bits. Cannot be encoded into UCS-2 BE");s.push(h),s.push(u-(h<<8));}return String.fromCharCode.apply(void 0,s)},Ce=y.__private__.pdfEscape=y.pdfEscape=function(t,e){return Fe(t,e).replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},je=y.__private__.beginPage=function(t){ot[++Dt]=[],Rt[Dt]={objId:0,contentsObjId:0,userUnit:Number(d),artBox:null,bleedBox:null,cropBox:null,trimBox:null,mediaBox:{bottomLeftX:0,bottomLeftY:0,topRightX:Number(t[0]),topRightY:Number(t[1])}},Me(Dt),ht(ot[$]);},Oe=function(t,e){var r,n,o;switch(i=e||i,"string"==typeof t&&(r=A(t.toLowerCase()),Array.isArray(r)&&(n=r[0],o=r[1])),Array.isArray(t)&&(n=t[0]*_t,o=t[1]*_t),isNaN(n)&&(n=s[0],o=s[1]),(n>14400||o>14400)&&(a$2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"),n=Math.min(14400,n),o=Math.min(14400,o)),s=[n,o],i.substr(0,1)){case"l":o>n&&(s=[o,n]);break;case"p":n>o&&(s=[o,n]);}je(s),pr(fr),lt(Lr),0!==kr&&lt(kr+" J"),0!==Ir&&lt(Ir+" j"),Tt.publish("addPage",{pageNumber:Dt});},Be=function(t){t>0&&t<=Dt&&(ot.splice(t,1),Rt.splice(t,1),Dt--,$>Dt&&($=Dt),this.setPage($));},Me=function(t){t>0&&t<=Dt&&($=t);},Ee=y.__private__.getNumberOfPages=y.getNumberOfPages=function(){return ot.length-1},qe=function(t,e,r){var n,i=void 0;return r=r||{},t=void 0!==t?t:Ft[St].fontName,e=void 0!==e?e:Ft[St].fontStyle,n=t.toLowerCase(),void 0!==Ct[n]&&void 0!==Ct[n][e]?i=Ct[n][e]:void 0!==Ct[t]&&void 0!==Ct[t][e]?i=Ct[t][e]:!1===r.disableWarning&&a$2.warn("Unable to look up font label for font '"+t+"', '"+e+"'. Refer to getFontList() for available fonts."),i||r.noFallback||null==(i=Ct.times[e])&&(i=Ct.times.normal),i},De=y.__private__.putInfo=function(){var t=Xt(),e=function(t){return t};for(var r in null!==m&&(e=Ye.encryptor(t,0)),lt("<<"),lt("/Producer ("+Ce(e("jsPDF "+E$1.version))+")"),xt)xt.hasOwnProperty(r)&&xt[r]&&lt("/"+r.substr(0,1).toUpperCase()+r.substr(1)+" ("+Ce(e(xt[r]))+")");lt("/CreationDate ("+Ce(e(W))+")"),lt(">>"),lt("endobj");},Re=y.__private__.putCatalog=function(t){var e=(t=t||{}).rootDictionaryObjId||Qt;switch(Xt(),lt("<<"),lt("/Type /Catalog"),lt("/Pages "+e+" 0 R"),mt||(mt="fullwidth"),mt){case"fullwidth":lt("/OpenAction [3 0 R /FitH null]");break;case"fullheight":lt("/OpenAction [3 0 R /FitV null]");break;case"fullpage":lt("/OpenAction [3 0 R /Fit]");break;case"original":lt("/OpenAction [3 0 R /XYZ null null 1]");break;default:var r=""+mt;"%"===r.substr(r.length-1)&&(mt=parseInt(mt)/100),"number"==typeof mt&&lt("/OpenAction [3 0 R /XYZ null null "+R(mt)+"]");}switch(Nt||(Nt="continuous"),Nt){case"continuous":lt("/PageLayout /OneColumn");break;case"single":lt("/PageLayout /SinglePage");break;case"two":case"twoleft":lt("/PageLayout /TwoColumnLeft");break;case"tworight":lt("/PageLayout /TwoColumnRight");}yt&&lt("/PageMode /"+yt),Tt.publish("putCatalog"),lt(">>"),lt("endobj");},Te=y.__private__.putTrailer=function(){lt("trailer"),lt("<<"),lt("/Size "+(et+1)),lt("/Root "+et+" 0 R"),lt("/Info "+(et-1)+" 0 R"),null!==m&&lt("/Encrypt "+Ye.oid+" 0 R"),lt("/ID [ <"+V+"> <"+V+"> ]"),lt(">>");},Ue=y.__private__.putHeader=function(){lt("%PDF-"+w),lt("%ºß¬à");},ze=y.__private__.putXRef=function(){var t="0000000000";lt("xref"),lt("0 "+(et+1)),lt("0000000000 65535 f ");for(var e=1;e<=et;e++){"function"==typeof rt[e]?lt((t+rt[e]()).slice(-10)+" 00000 n "):void 0!==rt[e]?lt((t+rt[e]).slice(-10)+" 00000 n "):lt("0000000000 00000 n ");}},He=y.__private__.buildDocument=function(){ut(),ht(nt),Tt.publish("buildDocument"),Ue(),oe(),Se(),xe(),null!==m&&be(),De(),Re();var t=it;return ze(),Te(),lt("startxref"),lt(""+t),lt("%%EOF"),ht(ot[$]),nt.join("\n")},We=y.__private__.getBlob=function(t){return new Blob([dt(t)],{type:"application/pdf"})},Ve=y.output=y.__private__.output=Ie((function(t,e){switch("string"==typeof(e=e||{})?e={filename:e}:e.filename=e.filename||"generated.pdf",t){case void 0:return He();case"save":y.save(e.filename);break;case"arraybuffer":return dt(He());case"blob":return We(He());case"bloburi":case"bloburl":if(void 0!==n$1.URL&&"function"==typeof n$1.URL.createObjectURL)return n$1.URL&&n$1.URL.createObjectURL(We(He()))||void 0;a$2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");break;case"datauristring":case"dataurlstring":var r="",i=He();try{r=h$1(i);}catch(t){r=h$1(unescape(encodeURIComponent(i)));}return "data:application/pdf;filename="+e.filename+";base64,"+r;case"pdfobjectnewwindow":if("[object Window]"===Object.prototype.toString.call(n$1)){var o="https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js",s=' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';e.pdfObjectUrl&&(o=e.pdfObjectUrl,s="");var c='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="'+o+'"'+s+'><\/script><script >PDFObject.embed("'+this.output("dataurlstring")+'", '+JSON.stringify(e)+");<\/script></body></html>",u=n$1.open();return null!==u&&u.document.write(c),u}throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");case"pdfjsnewwindow":if("[object Window]"===Object.prototype.toString.call(n$1)){var l='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="'+(e.pdfJsUrl||"examples/PDF.js/web/viewer.html")+"?file=&downloadName="+e.filename+'" width="500px" height="400px" /></body></html>',f=n$1.open();if(null!==f){f.document.write(l);var d=this;f.document.documentElement.querySelector("#pdfViewer").onload=function(){f.document.title=e.filename,f.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d.output("bloburl"));};}return f}throw new Error("The option pdfjsnewwindow just works in a browser-environment.");case"dataurlnewwindow":if("[object Window]"!==Object.prototype.toString.call(n$1))throw new Error("The option dataurlnewwindow just works in a browser-environment.");var p='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="'+this.output("datauristring",e)+'"></iframe></body></html>',g=n$1.open();if(null!==g&&(g.document.write(p),g.document.title=e.filename),g||"undefined"==typeof safari)return g;break;case"datauri":case"dataurl":return n$1.document.location.href=this.output("datauristring",e);default:return null}})),Ge=function(t){return !0===Array.isArray(Ut)&&Ut.indexOf(t)>-1};switch(o){case"pt":_t=1;break;case"mm":_t=72/25.4;break;case"cm":_t=72/2.54;break;case"in":_t=72;break;case"px":_t=1==Ge("px_scaling")?.75:96/72;break;case"pc":case"em":_t=12;break;case"ex":_t=6;break;default:if("number"!=typeof o)throw new Error("Invalid unit: "+o);_t=o;}var Ye=null;K(),Y();var Je=function(t){return null!==m?Ye.encryptor(t,0):function(t){return t}},Xe=y.__private__.getPageInfo=y.getPageInfo=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfo");return {objId:Rt[t].objId,pageNumber:t,pageContext:Rt[t]}},Ke=y.__private__.getPageInfoByObjId=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");for(var e in Rt)if(Rt[e].objId===t)break;return Xe(e)},Ze=y.__private__.getCurrentPageInfo=y.getCurrentPageInfo=function(){return {objId:Rt[$].objId,pageNumber:$,pageContext:Rt[$]}};y.addPage=function(){return Oe.apply(this,arguments),this},y.setPage=function(){return Me.apply(this,arguments),ht.call(this,ot[$]),this},y.insertPage=function(t){return this.addPage(),this.movePage($,t),this},y.movePage=function(t,e){var r,n;if(t>e){r=ot[t],n=Rt[t];for(var i=t;i>e;i--)ot[i]=ot[i-1],Rt[i]=Rt[i-1];ot[e]=r,Rt[e]=n,this.setPage(e);}else if(t<e){r=ot[t],n=Rt[t];for(var a=t;a<e;a++)ot[a]=ot[a+1],Rt[a]=Rt[a+1];ot[e]=r,Rt[e]=n,this.setPage(e);}return this},y.deletePage=function(){return Be.apply(this,arguments),this},y.__private__.text=y.text=function(e,r,n,i,a){var o,s,c,u,h,l,f,d,p,g=(i=i||{}).scope||this;if("number"==typeof e&&"number"==typeof r&&("string"==typeof n||Array.isArray(n))){var m=n;n=r,r=e,e=m;}if(arguments[3]instanceof Vt==!1?(c=arguments[4],u=arguments[5],"object"===_typeof$2(f=arguments[3])&&null!==f||("string"==typeof c&&(u=c,c=null),"string"==typeof f&&(u=f,f=null),"number"==typeof f&&(c=f,f=null),i={flags:f,angle:c,align:u})):(q("The transform parameter of text() with a Matrix value"),p=a),isNaN(r)||isNaN(n)||null==e)throw new Error("Invalid arguments passed to jsPDF.text");if(0===e.length)return g;var v="",y=!1,w="number"==typeof i.lineHeightFactor?i.lineHeightFactor:lr,N=g.internal.scaleFactor;function L(t){return t=t.split("\t").join(Array(i.TabLen||9).join(" ")),Ce(t,f)}function A(t){for(var e,r=t.concat(),n=[],i=r.length;i--;)"string"==typeof(e=r.shift())?n.push(e):Array.isArray(t)&&(1===e.length||void 0===e[1]&&void 0===e[2])?n.push(e[0]):n.push([e[0],e[1],e[2]]);return n}function _(t,e){var r;if("string"==typeof t)r=e(t)[0];else if(Array.isArray(t)){for(var n,i,a=t.concat(),o=[],s=a.length;s--;)"string"==typeof(n=a.shift())?o.push(e(n)[0]):Array.isArray(n)&&"string"==typeof n[0]&&(i=e(n[0],n[1],n[2]),o.push([i[0],i[1],i[2]]));r=o;}return r}var P=!1,k=!0;if("string"==typeof e)P=!0;else if(Array.isArray(e)){var I=e.concat();s=[];for(var F,C=I.length;C--;)("string"!=typeof(F=I.shift())||Array.isArray(F)&&"string"!=typeof F[0])&&(k=!1);P=k;}if(!1===P)throw new Error('Type of text must be string or Array. "'+e+'" is not recognized.');"string"==typeof e&&(e=e.match(/[\r?\n]/)?e.split(/\r\n|\r|\n/g):[e]);var j=gt/g.internal.scaleFactor,B=j*(w-1);switch(i.baseline){case"bottom":n-=B;break;case"top":n+=j-B;break;case"hanging":n+=j-2*B;break;case"middle":n+=j/2-B;}if((l=i.maxWidth||0)>0&&("string"==typeof e?e=g.splitTextToSize(e,l):"[object Array]"===Object.prototype.toString.call(e)&&(e=e.reduce((function(t,e){return t.concat(g.splitTextToSize(e,l))}),[]))),o={text:e,x:r,y:n,options:i,mutex:{pdfEscape:Ce,activeFontKey:St,fonts:Ft,activeFontSize:gt}},Tt.publish("preProcessText",o),e=o.text,c=(i=o.options).angle,p instanceof Vt==!1&&c&&"number"==typeof c){c*=Math.PI/180,0===i.rotationDirection&&(c=-c),S===x.ADVANCED&&(c=-c);var M=Math.cos(c),E=Math.sin(c);p=new Vt(M,E,-E,M,0,0);}else c&&c instanceof Vt&&(p=c);S!==x.ADVANCED||p||(p=Yt),void 0!==(h=i.charSpace||_r)&&(v+=O(U(h))+" Tc\n",this.setCharSpace(this.getCharSpace()||0)),void 0!==(d=i.horizontalScale)&&(v+=O(100*d)+" Tz\n");i.lang;var D=-1,R=void 0!==i.renderingMode?i.renderingMode:i.stroke,T=g.internal.getCurrentPageInfo().pageContext;switch(R){case 0:case!1:case"fill":D=0;break;case 1:case!0:case"stroke":D=1;break;case 2:case"fillThenStroke":D=2;break;case 3:case"invisible":D=3;break;case 4:case"fillAndAddForClipping":D=4;break;case 5:case"strokeAndAddPathForClipping":D=5;break;case 6:case"fillThenStrokeAndAddToPathForClipping":D=6;break;case 7:case"addToPathForClipping":D=7;}var z=void 0!==T.usedRenderingMode?T.usedRenderingMode:-1;-1!==D?v+=D+" Tr\n":-1!==z&&(v+="0 Tr\n"),-1!==D&&(T.usedRenderingMode=D),u=i.align||"left";var H,W=gt*w,V=g.internal.pageSize.getWidth(),G=Ft[St];h=i.charSpace||_r,l=i.maxWidth||0,f=Object.assign({autoencode:!0,noBOM:!0},i.flags);var Y=[];if("[object Array]"===Object.prototype.toString.call(e)){var J;s=A(e),"left"!==u&&(H=s.map((function(t){return g.getStringUnitWidth(t,{font:G,charSpace:h,fontSize:gt,doKerning:!1})*gt/N})));var X,K=0;if("right"===u){r-=H[0],e=[],C=s.length;for(var Z=0;Z<C;Z++)0===Z?(X=br(r),J=yr(n)):(X=U(K-H[Z]),J=-W),e.push([s[Z],X,J]),K=H[Z];}else if("center"===u){r-=H[0]/2,e=[],C=s.length;for(var $=0;$<C;$++)0===$?(X=br(r),J=yr(n)):(X=U((K-H[$])/2),J=-W),e.push([s[$],X,J]),K=H[$];}else if("left"===u){e=[],C=s.length;for(var Q=0;Q<C;Q++)e.push(s[Q]);}else {if("justify"!==u)throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');e=[],C=s.length,l=0!==l?l:V;for(var tt=0;tt<C;tt++)J=0===tt?yr(n):-W,X=0===tt?br(r):0,tt<C-1?Y.push(O(U((l-H[tt])/(s[tt].split(" ").length-1)))):Y.push(0),e.push([s[tt],X,J]);}}var et="boolean"==typeof i.R2L?i.R2L:bt;!0===et&&(e=_(e,(function(t,e,r){return [t.split("").reverse().join(""),e,r]}))),o={text:e,x:r,y:n,options:i,mutex:{pdfEscape:Ce,activeFontKey:St,fonts:Ft,activeFontSize:gt}},Tt.publish("postProcessText",o),e=o.text,y=o.mutex.isHex||!1;var rt=Ft[St].encoding;"WinAnsiEncoding"!==rt&&"StandardEncoding"!==rt||(e=_(e,(function(t,e,r){return [L(t),e,r]}))),s=A(e),e=[];for(var nt,it,at,ot=0,st=1,ct=Array.isArray(s[0])?st:ot,ut="",ht=function(t,e,r){var n="";return r instanceof Vt?(r="number"==typeof i.angle?Gt(r,new Vt(1,0,0,1,t,e)):Gt(new Vt(1,0,0,1,t,e),r),S===x.ADVANCED&&(r=Gt(new Vt(1,0,0,-1,0,0),r)),n=r.join(" ")+" Tm\n"):n=O(t)+" "+O(e)+" Td\n",n},ft=0;ft<s.length;ft++){switch(ut="",ct){case st:at=(y?"<":"(")+s[ft][0]+(y?">":")"),nt=parseFloat(s[ft][1]),it=parseFloat(s[ft][2]);break;case ot:at=(y?"<":"(")+s[ft]+(y?">":")"),nt=br(r),it=yr(n);}void 0!==Y&&void 0!==Y[ft]&&(ut=Y[ft]+" Tw\n"),0===ft?e.push(ut+ht(nt,it,p)+at):ct===ot?e.push(ut+at):ct===st&&e.push(ut+ht(nt,it,p)+at);}e=ct===ot?e.join(" Tj\nT* "):e.join(" Tj\n"),e+=" Tj\n";var dt="BT\n/";return dt+=St+" "+gt+" Tf\n",dt+=O(gt*w)+" TL\n",dt+=xr+"\n",dt+=v,dt+=e,lt(dt+="ET"),b[St]=!0,g};var $e=y.__private__.clip=y.clip=function(t){return lt("evenodd"===t?"W*":"W"),this};y.clipEvenOdd=function(){return $e("evenodd")},y.__private__.discardPath=y.discardPath=function(){return lt("n"),this};var Qe=y.__private__.isValidStyle=function(t){var e=!1;return -1!==[void 0,null,"S","D","F","DF","FD","f","f*","B","B*","n"].indexOf(t)&&(e=!0),e};y.__private__.setDefaultPathOperation=y.setDefaultPathOperation=function(t){return Qe(t)&&(g=t),this};var tr=y.__private__.getStyle=y.getStyle=function(t){var e=g;switch(t){case"D":case"S":e="S";break;case"F":e="f";break;case"FD":case"DF":e="B";break;case"f":case"f*":case"B":case"B*":e=t;}return e},er=y.close=function(){return lt("h"),this};y.stroke=function(){return lt("S"),this},y.fill=function(t){return rr("f",t),this},y.fillEvenOdd=function(t){return rr("f*",t),this},y.fillStroke=function(t){return rr("B",t),this},y.fillStrokeEvenOdd=function(t){return rr("B*",t),this};var rr=function(e,r){"object"===_typeof$2(r)?ar(r,e):lt(e);},nr=function(t){null===t||S===x.ADVANCED&&void 0===t||(t=tr(t),lt(t));};function ir(t,e,r,n,i){var a=new M(e||this.boundingBox,r||this.xStep,n||this.yStep,this.gState,i||this.matrix);a.stream=this.stream;var o=t+"$$"+this.cloneIndex+++"$$";return Jt(o,a),a}var ar=function(t,e){var r=Bt[t.key],n=Ot[r];if(n instanceof B)lt("q"),lt(or(e)),n.gState&&y.setGState(n.gState),lt(t.matrix.toString()+" cm"),lt("/"+r+" sh"),lt("Q");else if(n instanceof M){var i=new Vt(1,0,0,-1,0,Rr());t.matrix&&(i=i.multiply(t.matrix||Yt),r=ir.call(n,t.key,t.boundingBox,t.xStep,t.yStep,i).id),lt("q"),lt("/Pattern cs"),lt("/"+r+" scn"),n.gState&&y.setGState(n.gState),lt(e),lt("Q");}},or=function(t){switch(t){case"f":case"F":return "W n";case"f*":return "W* n";case"B":return "W S";case"B*":return "W* S";case"S":return "W S";case"n":return "W n"}},sr=y.moveTo=function(t,e){return lt(O(U(t))+" "+O(H(e))+" m"),this},cr=y.lineTo=function(t,e){return lt(O(U(t))+" "+O(H(e))+" l"),this},ur=y.curveTo=function(t,e,r,n,i,a){return lt([O(U(t)),O(H(e)),O(U(r)),O(H(n)),O(U(i)),O(H(a)),"c"].join(" ")),this};y.__private__.line=y.line=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.line");return S===x.COMPAT?this.lines([[r-t,n-e]],t,e,[1,1],i||"S"):this.lines([[r-t,n-e]],t,e,[1,1]).stroke()},y.__private__.lines=y.lines=function(t,e,r,n,i,a){var o,s,c,u,h,l,f,d,p,g,m,v;if("number"==typeof t&&(v=r,r=e,e=t,t=v),n=n||[1,1],a=a||!1,isNaN(e)||isNaN(r)||!Array.isArray(t)||!Array.isArray(n)||!Qe(i)||"boolean"!=typeof a)throw new Error("Invalid arguments passed to jsPDF.lines");for(sr(e,r),o=n[0],s=n[1],u=t.length,g=e,m=r,c=0;c<u;c++)2===(h=t[c]).length?(g=h[0]*o+g,m=h[1]*s+m,cr(g,m)):(l=h[0]*o+g,f=h[1]*s+m,d=h[2]*o+g,p=h[3]*s+m,g=h[4]*o+g,m=h[5]*s+m,ur(l,f,d,p,g,m));return a&&er(),nr(i),this},y.path=function(t){for(var e=0;e<t.length;e++){var r=t[e],n=r.c;switch(r.op){case"m":sr(n[0],n[1]);break;case"l":cr(n[0],n[1]);break;case"c":ur.apply(this,n);break;case"h":er();}}return this},y.__private__.rect=y.rect=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.rect");return S===x.COMPAT&&(n=-n),lt([O(U(t)),O(H(e)),O(U(r)),O(U(n)),"re"].join(" ")),nr(i),this},y.__private__.triangle=y.triangle=function(t,e,r,n,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(a)||!Qe(o))throw new Error("Invalid arguments passed to jsPDF.triangle");return this.lines([[r-t,n-e],[i-r,a-n],[t-i,e-a]],t,e,[1,1],o,!0),this},y.__private__.roundedRect=y.roundedRect=function(t,e,r,n,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(a)||!Qe(o))throw new Error("Invalid arguments passed to jsPDF.roundedRect");var s=4/3*(Math.SQRT2-1);return i=Math.min(i,.5*r),a=Math.min(a,.5*n),this.lines([[r-2*i,0],[i*s,0,i,a-a*s,i,a],[0,n-2*a],[0,a*s,-i*s,a,-i,a],[2*i-r,0],[-i*s,0,-i,-a*s,-i,-a],[0,2*a-n],[0,-a*s,i*s,-a,i,-a]],t+i,e,[1,1],o,!0),this},y.__private__.ellipse=y.ellipse=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.ellipse");var a=4/3*(Math.SQRT2-1)*r,o=4/3*(Math.SQRT2-1)*n;return sr(t+r,e),ur(t+r,e-o,t+a,e-n,t,e-n),ur(t-a,e-n,t-r,e-o,t-r,e),ur(t-r,e+o,t-a,e+n,t,e+n),ur(t+a,e+n,t+r,e+o,t+r,e),nr(i),this},y.__private__.circle=y.circle=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||!Qe(n))throw new Error("Invalid arguments passed to jsPDF.circle");return this.ellipse(t,e,r,r,n)},y.setFont=function(t,e,r){return r&&(e=k(e,r)),St=qe(t,e,{disableWarning:!1}),this};var hr=y.__private__.getFont=y.getFont=function(){return Ft[qe.apply(y,arguments)]};y.__private__.getFontList=y.getFontList=function(){var t,e,r={};for(t in Ct)if(Ct.hasOwnProperty(t))for(e in r[t]=[],Ct[t])Ct[t].hasOwnProperty(e)&&r[t].push(e);return r},y.addFont=function(t,e,r,n,i){var a=["StandardEncoding","MacRomanEncoding","Identity-H","WinAnsiEncoding"];return arguments[3]&&-1!==a.indexOf(arguments[3])?i=arguments[3]:arguments[3]&&-1==a.indexOf(arguments[3])&&(r=k(r,n)),i=i||"Identity-H",Pe.call(this,t,e,r,i)};var lr,fr=e.lineWidth||.200025,dr=y.__private__.getLineWidth=y.getLineWidth=function(){return fr},pr=y.__private__.setLineWidth=y.setLineWidth=function(t){return fr=t,lt(O(U(t))+" w"),this};y.__private__.setLineDash=E$1.API.setLineDash=E$1.API.setLineDashPattern=function(t,e){if(t=t||[],e=e||0,isNaN(e)||!Array.isArray(t))throw new Error("Invalid arguments passed to jsPDF.setLineDash");return t=t.map((function(t){return O(U(t))})).join(" "),e=O(U(e)),lt("["+t+"] "+e+" d"),this};var gr=y.__private__.getLineHeight=y.getLineHeight=function(){return gt*lr};y.__private__.getLineHeight=y.getLineHeight=function(){return gt*lr};var mr=y.__private__.setLineHeightFactor=y.setLineHeightFactor=function(t){return "number"==typeof(t=t||1.15)&&(lr=t),this},vr=y.__private__.getLineHeightFactor=y.getLineHeightFactor=function(){return lr};mr(e.lineHeight);var br=y.__private__.getHorizontalCoordinate=function(t){return U(t)},yr=y.__private__.getVerticalCoordinate=function(t){return S===x.ADVANCED?t:Rt[$].mediaBox.topRightY-Rt[$].mediaBox.bottomLeftY-U(t)},wr=y.__private__.getHorizontalCoordinateString=y.getHorizontalCoordinateString=function(t){return O(br(t))},Nr=y.__private__.getVerticalCoordinateString=y.getVerticalCoordinateString=function(t){return O(yr(t))},Lr=e.strokeColor||"0 G";y.__private__.getStrokeColor=y.getDrawColor=function(){return ee(Lr)},y.__private__.setStrokeColor=y.setDrawColor=function(t,e,r,n){return Lr=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"draw",precision:2}),lt(Lr),this};var Ar=e.fillColor||"0 g";y.__private__.getFillColor=y.getFillColor=function(){return ee(Ar)},y.__private__.setFillColor=y.setFillColor=function(t,e,r,n){return Ar=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"fill",precision:2}),lt(Ar),this};var xr=e.textColor||"0 g",Sr=y.__private__.getTextColor=y.getTextColor=function(){return ee(xr)};y.__private__.setTextColor=y.setTextColor=function(t,e,r,n){return xr=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"text",precision:3}),this};var _r=e.charSpace,Pr=y.__private__.getCharSpace=y.getCharSpace=function(){return parseFloat(_r||0)};y.__private__.setCharSpace=y.setCharSpace=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.setCharSpace");return _r=t,this};var kr=0;y.CapJoinStyles={0:0,butt:0,but:0,miter:0,1:1,round:1,rounded:1,circle:1,2:2,projecting:2,project:2,square:2,bevel:2},y.__private__.setLineCap=y.setLineCap=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line cap style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return kr=e,lt(e+" J"),this};var Ir=0;y.__private__.setLineJoin=y.setLineJoin=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line join style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return Ir=e,lt(e+" j"),this},y.__private__.setLineMiterLimit=y.__private__.setMiterLimit=y.setLineMiterLimit=y.setMiterLimit=function(t){if(t=t||0,isNaN(t))throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");return lt(O(U(t))+" M"),this},y.GState=j,y.setGState=function(t){(t="string"==typeof t?Mt[Et[t]]:Fr(null,t)).equals(qt)||(lt("/"+t.id+" gs"),qt=t);};var Fr=function(t,e){if(!t||!Et[t]){var r=!1;for(var n in Mt)if(Mt.hasOwnProperty(n)&&Mt[n].equals(e)){r=!0;break}if(r)e=Mt[n];else {var i="GS"+(Object.keys(Mt).length+1).toString(10);Mt[i]=e,e.id=i;}return t&&(Et[t]=e.id),Tt.publish("addGState",e),e}};y.addGState=function(t,e){return Fr(t,e),this},y.saveGraphicsState=function(){return lt("q"),jt.push({key:St,size:gt,color:xr}),this},y.restoreGraphicsState=function(){lt("Q");var t=jt.pop();return St=t.key,gt=t.size,xr=t.color,qt=null,this},y.setCurrentTransformationMatrix=function(t){return lt(t.toString()+" cm"),this},y.comment=function(t){return lt("#"+t),this};var Cr=function(t,e){var r=t||0;Object.defineProperty(this,"x",{enumerable:!0,get:function(){return r},set:function(t){isNaN(t)||(r=parseFloat(t));}});var n=e||0;Object.defineProperty(this,"y",{enumerable:!0,get:function(){return n},set:function(t){isNaN(t)||(n=parseFloat(t));}});var i="pt";return Object.defineProperty(this,"type",{enumerable:!0,get:function(){return i},set:function(t){i=t.toString();}}),this},jr=function(t,e,r,n){Cr.call(this,t,e),this.type="rect";var i=r||0;Object.defineProperty(this,"w",{enumerable:!0,get:function(){return i},set:function(t){isNaN(t)||(i=parseFloat(t));}});var a=n||0;return Object.defineProperty(this,"h",{enumerable:!0,get:function(){return a},set:function(t){isNaN(t)||(a=parseFloat(t));}}),this},Or=function(){this.page=Dt,this.currentPage=$,this.pages=ot.slice(0),this.pagesContext=Rt.slice(0),this.x=Pt,this.y=kt,this.matrix=It,this.width=qr($),this.height=Rr($),this.outputDestination=ct,this.id="",this.objectNumber=-1;};Or.prototype.restore=function(){Dt=this.page,$=this.currentPage,Rt=this.pagesContext,ot=this.pages,Pt=this.x,kt=this.y,It=this.matrix,Dr($,this.width),Tr($,this.height),ct=this.outputDestination;};var Br=function(t,e,r,n,i){Wt.push(new Or),Dt=$=0,ot=[],Pt=t,kt=e,It=i,je([r,n]);},Mr=function(t){if(Ht[t])Wt.pop().restore();else {var e=new Or,r="Xo"+(Object.keys(zt).length+1).toString(10);e.id=r,Ht[t]=r,zt[r]=e,Tt.publish("addFormObject",e),Wt.pop().restore();}};for(var Er in y.beginFormObject=function(t,e,r,n,i){return Br(t,e,r,n,i),this},y.endFormObject=function(t){return Mr(t),this},y.doFormObject=function(t,e){var r=zt[Ht[t]];return lt("q"),lt(e.toString()+" cm"),lt("/"+r.id+" Do"),lt("Q"),this},y.getFormObject=function(t){var e=zt[Ht[t]];return {x:e.x,y:e.y,width:e.width,height:e.height,matrix:e.matrix}},y.save=function(t,e){return t=t||"generated.pdf",(e=e||{}).returnPromise=e.returnPromise||!1,!1===e.returnPromise?(l$1(We(He()),t),"function"==typeof l$1.unload&&n$1.setTimeout&&setTimeout(l$1.unload,911),this):new Promise((function(e,r){try{var i=l$1(We(He()),t);"function"==typeof l$1.unload&&n$1.setTimeout&&setTimeout(l$1.unload,911),e(i);}catch(t){r(t.message);}}))},E$1.API)E$1.API.hasOwnProperty(Er)&&("events"===Er&&E$1.API.events.length?function(t,e){var r,n,i;for(i=e.length-1;-1!==i;i--)r=e[i][0],n=e[i][1],t.subscribe.apply(t,[r].concat("function"==typeof n?[n]:n));}(Tt,E$1.API.events):y[Er]=E$1.API[Er]);var qr=y.getPageWidth=function(t){return (Rt[t=t||$].mediaBox.topRightX-Rt[t].mediaBox.bottomLeftX)/_t},Dr=y.setPageWidth=function(t,e){Rt[t].mediaBox.topRightX=e*_t+Rt[t].mediaBox.bottomLeftX;},Rr=y.getPageHeight=function(t){return (Rt[t=t||$].mediaBox.topRightY-Rt[t].mediaBox.bottomLeftY)/_t},Tr=y.setPageHeight=function(t,e){Rt[t].mediaBox.topRightY=e*_t+Rt[t].mediaBox.bottomLeftY;};return y.internal={pdfEscape:Ce,getStyle:tr,getFont:hr,getFontSize:vt,getCharSpace:Pr,getTextColor:Sr,getLineHeight:gr,getLineHeightFactor:vr,getLineWidth:dr,write:ft,getHorizontalCoordinate:br,getVerticalCoordinate:yr,getCoordinateString:wr,getVerticalCoordinateString:Nr,collections:{},newObject:Xt,newAdditionalObject:$t,newObjectDeferred:Kt,newObjectDeferredBegin:Zt,getFilters:ne,putStream:ie,events:Tt,scaleFactor:_t,pageSize:{getWidth:function(){return qr($)},setWidth:function(t){Dr($,t);},getHeight:function(){return Rr($)},setHeight:function(t){Tr($,t);}},encryptionOptions:m,encryption:Ye,getEncryptor:Je,output:Ve,getNumberOfPages:Ee,pages:ot,out:lt,f2:R,f3:T,getPageInfo:Xe,getPageInfoByObjId:Ke,getCurrentPageInfo:Ze,getPDFVersion:N,Point:Cr,Rectangle:jr,Matrix:Vt,hasHotfix:Ge},Object.defineProperty(y.internal.pageSize,"width",{get:function(){return qr($)},set:function(t){Dr($,t);},enumerable:!0,configurable:!0}),Object.defineProperty(y.internal.pageSize,"height",{get:function(){return Rr($)},set:function(t){Tr($,t);},enumerable:!0,configurable:!0}),ke.call(y,pt),St="F1",Oe(s,i),Tt.publish("initialized"),y}I.prototype.lsbFirstWord=function(t){return String.fromCharCode(t>>0&255,t>>8&255,t>>16&255,t>>24&255)},I.prototype.toHexString=function(t){return t.split("").map((function(t){return ("0"+(255&t.charCodeAt(0)).toString(16)).slice(-2)})).join("")},I.prototype.hexToBytes=function(t){for(var e=[],r=0;r<t.length;r+=2)e.push(String.fromCharCode(parseInt(t.substr(r,2),16)));return e.join("")},I.prototype.processOwnerPassword=function(t,e){return P(x(e).substr(0,5),t)},I.prototype.encryptor=function(t,e){var r=x(this.encryptionKey+String.fromCharCode(255&t,t>>8&255,t>>16&255,255&e,e>>8&255)).substr(0,10);return function(t){return P(r,t)}},j.prototype.equals=function(e){var r,n="id,objectNumber,equals";if(!e||_typeof$2(e)!==_typeof$2(this))return !1;var i=0;for(r in this)if(!(n.indexOf(r)>=0)){if(this.hasOwnProperty(r)&&!e.hasOwnProperty(r))return !1;if(this[r]!==e[r])return !1;i++;}for(r in e)e.hasOwnProperty(r)&&n.indexOf(r)<0&&i--;return 0===i},E$1.API={events:[]},E$1.version="2.5.1";var q=E$1.API,D=1,R=function(t){return t.replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},T$2=function(t){return t.replace(/\\\\/g,"\\").replace(/\\\(/g,"(").replace(/\\\)/g,")")},U$1=function(t){return t.toFixed(2)},z$1=function(t){return t.toFixed(5)};q.__acroform__={};var H=function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t;},W=function(t){return t*D},V$1=function(t){var e=new ut,r=At.internal.getHeight(t)||0,n=At.internal.getWidth(t)||0;return e.BBox=[0,0,Number(U$1(n)),Number(U$1(r))],e},G=q.__acroform__.setBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");return t|=1<<e},Y=q.__acroform__.clearBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");return t&=~(1<<e)},J=q.__acroform__.getBit=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");return 0==(t&1<<e)?0:1},X=q.__acroform__.getBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");return J(t,e-1)},K=q.__acroform__.setBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");return G(t,e-1)},Z$1=q.__acroform__.clearBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");return Y(t,e-1)},$$a=q.__acroform__.calculateCoordinates=function(t,e){var r=e.internal.getHorizontalCoordinate,n=e.internal.getVerticalCoordinate,i=t[0],a=t[1],o=t[2],s=t[3],c={};return c.lowerLeft_X=r(i)||0,c.lowerLeft_Y=n(a+s)||0,c.upperRight_X=r(i+o)||0,c.upperRight_Y=n(a)||0,[Number(U$1(c.lowerLeft_X)),Number(U$1(c.lowerLeft_Y)),Number(U$1(c.upperRight_X)),Number(U$1(c.upperRight_Y))]},Q=function(t){if(t.appearanceStreamContent)return t.appearanceStreamContent;if(t.V||t.DV){var e=[],r=t._V||t.DV,n=tt(t,r),i=t.scope.internal.getFont(t.fontName,t.fontStyle).id;e.push("/Tx BMC"),e.push("q"),e.push("BT"),e.push(t.scope.__private__.encodeColorString(t.color)),e.push("/"+i+" "+U$1(n.fontSize)+" Tf"),e.push("1 0 0 1 0 0 Tm"),e.push(n.text),e.push("ET"),e.push("Q"),e.push("EMC");var a=V$1(t);return a.scope=t.scope,a.stream=e.join("\n"),a}},tt=function(t,e){var r=0===t.fontSize?t.maxFontSize:t.fontSize,n={text:"",fontSize:""},i=(e=")"==(e="("==e.substr(0,1)?e.substr(1):e).substr(e.length-1)?e.substr(0,e.length-1):e).split(" ");i=t.multiline?i.map((function(t){return t.split("\n")})):i.map((function(t){return [t]}));var a=r,o=At.internal.getHeight(t)||0;o=o<0?-o:o;var s=At.internal.getWidth(t)||0;s=s<0?-s:s;var c=function(e,r,n){if(e+1<i.length){var a=r+" "+i[e+1][0];return et(a,t,n).width<=s-4}return !1};a++;t:for(;a>0;){e="",a--;var u,h,l=et("3",t,a).height,f=t.multiline?o-a:(o-l)/2,d=f+=2,p=0,g=0,m=0;if(a<=0){e="(...) Tj\n",e+="% Width of Text: "+et(e,t,a=12).width+", FieldWidth:"+s+"\n";break}for(var v="",b=0,y=0;y<i.length;y++)if(i.hasOwnProperty(y)){var w=!1;if(1!==i[y].length&&m!==i[y].length-1){if((l+2)*(b+2)+2>o)continue t;v+=i[y][m],w=!0,g=y,y--;}else {v=" "==(v+=i[y][m]+" ").substr(v.length-1)?v.substr(0,v.length-1):v;var N=parseInt(y),L=c(N,v,a),A=y>=i.length-1;if(L&&!A){v+=" ",m=0;continue}if(L||A){if(A)g=N;else if(t.multiline&&(l+2)*(b+2)+2>o)continue t}else {if(!t.multiline)continue t;if((l+2)*(b+2)+2>o)continue t;g=N;}}for(var x="",S=p;S<=g;S++){var _=i[S];if(t.multiline){if(S===g){x+=_[m]+" ",m=(m+1)%_.length;continue}if(S===p){x+=_[_.length-1]+" ";continue}}x+=_[0]+" ";}switch(x=" "==x.substr(x.length-1)?x.substr(0,x.length-1):x,h=et(x,t,a).width,t.textAlign){case"right":u=s-h-2;break;case"center":u=(s-h)/2;break;case"left":default:u=2;}e+=U$1(u)+" "+U$1(d)+" Td\n",e+="("+R(x)+") Tj\n",e+=-U$1(u)+" 0 Td\n",d=-(a+2),h=0,p=w?g:g+1,b++,v="";}break}return n.text=e,n.fontSize=a,n},et=function(t,e,r){var n=e.scope.internal.getFont(e.fontName,e.fontStyle),i=e.scope.getStringUnitWidth(t,{font:n,fontSize:parseFloat(r),charSpace:0})*parseFloat(r);return {height:e.scope.getStringUnitWidth("3",{font:n,fontSize:parseFloat(r),charSpace:0})*parseFloat(r)*1.5,width:i}},rt={fields:[],xForms:[],acroFormDictionaryRoot:null,printedOut:!1,internal:null,isInitialized:!1},nt=function(t,e){var r={type:"reference",object:t};void 0===e.internal.getPageInfo(t.page).pageContext.annotations.find((function(t){return t.type===r.type&&t.object===r.object}))&&e.internal.getPageInfo(t.page).pageContext.annotations.push(r);},it$1=function(e,r){for(var n in e)if(e.hasOwnProperty(n)){var i=n,a=e[n];r.internal.newObjectDeferredBegin(a.objId,!0),"object"===_typeof$2(a)&&"function"==typeof a.putStream&&a.putStream(),delete e[i];}},at=function(e,r){if(r.scope=e,void 0!==e.internal&&(void 0===e.internal.acroformPlugin||!1===e.internal.acroformPlugin.isInitialized)){if(lt$1.FieldNum=0,e.internal.acroformPlugin=JSON.parse(JSON.stringify(rt)),e.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("Exception while creating AcroformDictionary");D=e.internal.scaleFactor,e.internal.acroformPlugin.acroFormDictionaryRoot=new ht,e.internal.acroformPlugin.acroFormDictionaryRoot.scope=e,e.internal.acroformPlugin.acroFormDictionaryRoot._eventID=e.internal.events.subscribe("postPutResources",(function(){!function(t){t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID),delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID,t.internal.acroformPlugin.printedOut=!0;}(e);})),e.internal.events.subscribe("buildDocument",(function(){!function(t){t.internal.acroformPlugin.acroFormDictionaryRoot.objId=void 0;var e=t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];n.objId=void 0,n.hasAnnotation&&nt(n,t);}}(e);})),e.internal.events.subscribe("putCatalog",(function(){!function(t){if(void 0===t.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("putCatalogCallback: Root missing.");t.internal.write("/AcroForm "+t.internal.acroformPlugin.acroFormDictionaryRoot.objId+" 0 R");}(e);})),e.internal.events.subscribe("postPutPages",(function(r){!function(e,r){var n=!e;for(var i in e||(r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId,!0),r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()),e=e||r.internal.acroformPlugin.acroFormDictionaryRoot.Kids)if(e.hasOwnProperty(i)){var a=e[i],o=[],s=a.Rect;if(a.Rect&&(a.Rect=$$a(a.Rect,r)),r.internal.newObjectDeferredBegin(a.objId,!0),a.DA=At.createDefaultAppearanceStream(a),"object"===_typeof$2(a)&&"function"==typeof a.getKeyValueListForStream&&(o=a.getKeyValueListForStream()),a.Rect=s,a.hasAppearanceStream&&!a.appearanceStreamContent){var c=Q(a);o.push({key:"AP",value:"<</N "+c+">>"}),r.internal.acroformPlugin.xForms.push(c);}if(a.appearanceStreamContent){var u="";for(var h in a.appearanceStreamContent)if(a.appearanceStreamContent.hasOwnProperty(h)){var l=a.appearanceStreamContent[h];if(u+="/"+h+" ",u+="<<",Object.keys(l).length>=1||Array.isArray(l)){for(var i in l)if(l.hasOwnProperty(i)){var f=l[i];"function"==typeof f&&(f=f.call(r,a)),u+="/"+i+" "+f+" ",r.internal.acroformPlugin.xForms.indexOf(f)>=0||r.internal.acroformPlugin.xForms.push(f);}}else "function"==typeof(f=l)&&(f=f.call(r,a)),u+="/"+i+" "+f,r.internal.acroformPlugin.xForms.indexOf(f)>=0||r.internal.acroformPlugin.xForms.push(f);u+=">>";}o.push({key:"AP",value:"<<\n"+u+">>"});}r.internal.putStream({additionalKeyValues:o,objectId:a.objId}),r.internal.out("endobj");}n&&it$1(r.internal.acroformPlugin.xForms,r);}(r,e);})),e.internal.acroformPlugin.isInitialized=!0;}},ot=q.__acroform__.arrayToPdfArray=function(e,r,n){var i=function(t){return t};if(Array.isArray(e)){for(var a="[",o=0;o<e.length;o++)switch(0!==o&&(a+=" "),_typeof$2(e[o])){case"boolean":case"number":case"object":a+=e[o].toString();break;case"string":"/"!==e[o].substr(0,1)?(void 0!==r&&n&&(i=n.internal.getEncryptor(r)),a+="("+R(i(e[o].toString()))+")"):a+=e[o].toString();}return a+="]"}throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray")};var st=function(t,e,r){var n=function(t){return t};return void 0!==e&&r&&(n=r.internal.getEncryptor(e)),(t=t||"").toString(),t="("+R(n(t))+")"},ct=function(){this._objId=void 0,this._scope=void 0,Object.defineProperty(this,"objId",{get:function(){if(void 0===this._objId){if(void 0===this.scope)return;this._objId=this.scope.internal.newObjectDeferred();}return this._objId},set:function(t){this._objId=t;}}),Object.defineProperty(this,"scope",{value:this._scope,writable:!0});};ct.prototype.toString=function(){return this.objId+" 0 R"},ct.prototype.putStream=function(){var t=this.getKeyValueListForStream();this.scope.internal.putStream({data:this.stream,additionalKeyValues:t,objectId:this.objId}),this.scope.internal.out("endobj");},ct.prototype.getKeyValueListForStream=function(){var t=[],e=Object.getOwnPropertyNames(this).filter((function(t){return "content"!=t&&"appearanceStreamContent"!=t&&"scope"!=t&&"objId"!=t&&"_"!=t.substring(0,1)}));for(var r in e)if(!1===Object.getOwnPropertyDescriptor(this,e[r]).configurable){var n=e[r],i=this[n];i&&(Array.isArray(i)?t.push({key:n,value:ot(i,this.objId,this.scope)}):i instanceof ct?(i.scope=this.scope,t.push({key:n,value:i.objId+" 0 R"})):"function"!=typeof i&&t.push({key:n,value:i}));}return t};var ut=function(){ct.call(this),Object.defineProperty(this,"Type",{value:"/XObject",configurable:!1,writable:!0}),Object.defineProperty(this,"Subtype",{value:"/Form",configurable:!1,writable:!0}),Object.defineProperty(this,"FormType",{value:1,configurable:!1,writable:!0});var t,e=[];Object.defineProperty(this,"BBox",{configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"Resources",{value:"2 0 R",configurable:!1,writable:!0}),Object.defineProperty(this,"stream",{enumerable:!1,configurable:!0,set:function(e){t=e.trim();},get:function(){return t||null}});};H(ut,ct);var ht=function(){ct.call(this);var t,e=[];Object.defineProperty(this,"Kids",{enumerable:!1,configurable:!0,get:function(){return e.length>0?e:void 0}}),Object.defineProperty(this,"Fields",{enumerable:!1,configurable:!1,get:function(){return e}}),Object.defineProperty(this,"DA",{enumerable:!1,configurable:!1,get:function(){if(t){var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+R(e(t))+")"}},set:function(e){t=e;}});};H(ht,ct);var lt$1=function t(){ct.call(this);var e=4;Object.defineProperty(this,"F",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute F supplied.');e=t;}}),Object.defineProperty(this,"showWhenPrinted",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(e,3))},set:function(t){!0===Boolean(t)?this.F=K(e,3):this.F=Z$1(e,3);}});var r=0;Object.defineProperty(this,"Ff",{enumerable:!1,configurable:!1,get:function(){return r},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute Ff supplied.');r=t;}});var n=[];Object.defineProperty(this,"Rect",{enumerable:!1,configurable:!1,get:function(){if(0!==n.length)return n},set:function(t){n=void 0!==t?t:[];}}),Object.defineProperty(this,"x",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[0])?0:n[0]},set:function(t){n[0]=t;}}),Object.defineProperty(this,"y",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[1])?0:n[1]},set:function(t){n[1]=t;}}),Object.defineProperty(this,"width",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[2])?0:n[2]},set:function(t){n[2]=t;}}),Object.defineProperty(this,"height",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[3])?0:n[3]},set:function(t){n[3]=t;}});var i="";Object.defineProperty(this,"FT",{enumerable:!0,configurable:!1,get:function(){return i},set:function(t){switch(t){case"/Btn":case"/Tx":case"/Ch":case"/Sig":i=t;break;default:throw new Error('Invalid value "'+t+'" for attribute FT supplied.')}}});var a=null;Object.defineProperty(this,"T",{enumerable:!0,configurable:!1,get:function(){if(!a||a.length<1){if(this instanceof yt)return;a="FieldObject"+t.FieldNum++;}var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+R(e(a))+")"},set:function(t){a=t.toString();}}),Object.defineProperty(this,"fieldName",{configurable:!0,enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o="helvetica";Object.defineProperty(this,"fontName",{enumerable:!0,configurable:!0,get:function(){return o},set:function(t){o=t;}});var s="normal";Object.defineProperty(this,"fontStyle",{enumerable:!0,configurable:!0,get:function(){return s},set:function(t){s=t;}});var c=0;Object.defineProperty(this,"fontSize",{enumerable:!0,configurable:!0,get:function(){return c},set:function(t){c=t;}});var u=void 0;Object.defineProperty(this,"maxFontSize",{enumerable:!0,configurable:!0,get:function(){return void 0===u?50/D:u},set:function(t){u=t;}});var h="black";Object.defineProperty(this,"color",{enumerable:!0,configurable:!0,get:function(){return h},set:function(t){h=t;}});var l="/F1 0 Tf 0 g";Object.defineProperty(this,"DA",{enumerable:!0,configurable:!1,get:function(){if(!(!l||this instanceof yt||this instanceof Nt))return st(l,this.objId,this.scope)},set:function(t){t=t.toString(),l=t;}});var f=null;Object.defineProperty(this,"DV",{enumerable:!1,configurable:!1,get:function(){if(f)return this instanceof mt==!1?st(f,this.objId,this.scope):f},set:function(t){t=t.toString(),f=this instanceof mt==!1?"("===t.substr(0,1)?T$2(t.substr(1,t.length-2)):T$2(t):t;}}),Object.defineProperty(this,"defaultValue",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt==!0?T$2(f.substr(1,f.length-1)):f},set:function(t){t=t.toString(),f=this instanceof mt==!0?"/"+t:t;}});var d=null;Object.defineProperty(this,"_V",{enumerable:!1,configurable:!1,get:function(){if(d)return d},set:function(t){this.V=t;}}),Object.defineProperty(this,"V",{enumerable:!1,configurable:!1,get:function(){if(d)return this instanceof mt==!1?st(d,this.objId,this.scope):d},set:function(t){t=t.toString(),d=this instanceof mt==!1?"("===t.substr(0,1)?T$2(t.substr(1,t.length-2)):T$2(t):t;}}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt==!0?T$2(d.substr(1,d.length-1)):d},set:function(t){t=t.toString(),d=this instanceof mt==!0?"/"+t:t;}}),Object.defineProperty(this,"hasAnnotation",{enumerable:!0,configurable:!0,get:function(){return this.Rect}}),Object.defineProperty(this,"Type",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Annot":null}}),Object.defineProperty(this,"Subtype",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Widget":null}});var p,g=!1;Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return g},set:function(t){t=Boolean(t),g=t;}}),Object.defineProperty(this,"page",{enumerable:!0,configurable:!0,get:function(){if(p)return p},set:function(t){p=t;}}),Object.defineProperty(this,"readOnly",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,1))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,1):this.Ff=Z$1(this.Ff,1);}}),Object.defineProperty(this,"required",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,2))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,2):this.Ff=Z$1(this.Ff,2);}}),Object.defineProperty(this,"noExport",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,3))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,3):this.Ff=Z$1(this.Ff,3);}});var m=null;Object.defineProperty(this,"Q",{enumerable:!0,configurable:!1,get:function(){if(null!==m)return m},set:function(t){if(-1===[0,1,2].indexOf(t))throw new Error('Invalid value "'+t+'" for attribute Q supplied.');m=t;}}),Object.defineProperty(this,"textAlign",{get:function(){var t;switch(m){case 0:default:t="left";break;case 1:t="center";break;case 2:t="right";}return t},configurable:!0,enumerable:!0,set:function(t){switch(t){case"right":case 2:m=2;break;case"center":case 1:m=1;break;case"left":case 0:default:m=0;}}});};H(lt$1,ct);var ft=function(){lt$1.call(this),this.FT="/Ch",this.V="()",this.fontName="zapfdingbats";var t=0;Object.defineProperty(this,"TI",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"topIndex",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){t=e;}});var e=[];Object.defineProperty(this,"Opt",{enumerable:!0,configurable:!1,get:function(){return ot(e,this.objId,this.scope)},set:function(t){var r,n;n=[],"string"==typeof(r=t)&&(n=function(t,e,r){r||(r=1);for(var n,i=[];n=e.exec(t);)i.push(n[r]);return i}(r,/\((.*?)\)/g)),e=n;}}),this.getOptions=function(){return e},this.setOptions=function(t){e=t,this.sort&&e.sort();},this.addOption=function(t){t=(t=t||"").toString(),e.push(t),this.sort&&e.sort();},this.removeOption=function(t,r){for(r=r||!1,t=(t=t||"").toString();-1!==e.indexOf(t)&&(e.splice(e.indexOf(t),1),!1!==r););},Object.defineProperty(this,"combo",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,18))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,18):this.Ff=Z$1(this.Ff,18);}}),Object.defineProperty(this,"edit",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,19))},set:function(t){!0===this.combo&&(!0===Boolean(t)?this.Ff=K(this.Ff,19):this.Ff=Z$1(this.Ff,19));}}),Object.defineProperty(this,"sort",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,20))},set:function(t){!0===Boolean(t)?(this.Ff=K(this.Ff,20),e.sort()):this.Ff=Z$1(this.Ff,20);}}),Object.defineProperty(this,"multiSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,22))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,22):this.Ff=Z$1(this.Ff,22);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,23):this.Ff=Z$1(this.Ff,23);}}),Object.defineProperty(this,"commitOnSelChange",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,27))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,27):this.Ff=Z$1(this.Ff,27);}}),this.hasAppearanceStream=!1;};H(ft,lt$1);var dt=function(){ft.call(this),this.fontName="helvetica",this.combo=!1;};H(dt,ft);var pt=function(){dt.call(this),this.combo=!0;};H(pt,dt);var gt$1=function(){pt.call(this),this.edit=!0;};H(gt$1,pt);var mt=function(){lt$1.call(this),this.FT="/Btn",Object.defineProperty(this,"noToggleToOff",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,15))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,15):this.Ff=Z$1(this.Ff,15);}}),Object.defineProperty(this,"radio",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,16))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,16):this.Ff=Z$1(this.Ff,16);}}),Object.defineProperty(this,"pushButton",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,17))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,17):this.Ff=Z$1(this.Ff,17);}}),Object.defineProperty(this,"radioIsUnison",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,26):this.Ff=Z$1(this.Ff,26);}});var e,r={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};if(this.scope&&(t=this.scope.internal.getEncryptor(this.objId)),0!==Object.keys(r).length){var e,n=[];for(e in n.push("<<"),r)n.push("/"+e+" ("+R(t(r[e]))+")");return n.push(">>"),n.join("\n")}},set:function(e){"object"===_typeof$2(e)&&(r=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return r.CA||""},set:function(t){"string"==typeof t&&(r.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return e.substr(1,e.length-1)},set:function(t){e="/"+t;}});};H(mt,lt$1);var vt=function(){mt.call(this),this.pushButton=!0;};H(vt,mt);var bt=function(){mt.call(this),this.radio=!0,this.pushButton=!1;var t=[];Object.defineProperty(this,"Kids",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=void 0!==e?e:[];}});};H(bt,mt);var yt=function(){var e,r;lt$1.call(this),Object.defineProperty(this,"Parent",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"optionName",{enumerable:!1,configurable:!0,get:function(){return r},set:function(t){r=t;}});var n,i={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};this.scope&&(t=this.scope.internal.getEncryptor(this.objId));var e,r=[];for(e in r.push("<<"),i)r.push("/"+e+" ("+R(t(i[e]))+")");return r.push(">>"),r.join("\n")},set:function(e){"object"===_typeof$2(e)&&(i=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return i.CA||""},set:function(t){"string"==typeof t&&(i.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return n},set:function(t){n=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return n.substr(1,n.length-1)},set:function(t){n="/"+t;}}),this.caption="l",this.appearanceState="Off",this._AppearanceType=At.RadioButton.Circle,this.appearanceStreamContent=this._AppearanceType.createAppearanceStream(this.optionName);};H(yt,lt$1),bt.prototype.setAppearance=function(t){if(!("createAppearanceStream"in t)||!("getCA"in t))throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");for(var e in this.Kids)if(this.Kids.hasOwnProperty(e)){var r=this.Kids[e];r.appearanceStreamContent=t.createAppearanceStream(r.optionName),r.caption=t.getCA();}},bt.prototype.createOption=function(t){var e=new yt;return e.Parent=this,e.optionName=t,this.Kids.push(e),xt.call(this.scope,e),e};var wt=function(){mt.call(this),this.fontName="zapfdingbats",this.caption="3",this.appearanceState="On",this.value="On",this.textAlign="center",this.appearanceStreamContent=At.CheckBox.createAppearanceStream();};H(wt,mt);var Nt=function(){lt$1.call(this),this.FT="/Tx",Object.defineProperty(this,"multiline",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,13))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,13):this.Ff=Z$1(this.Ff,13);}}),Object.defineProperty(this,"fileSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,21))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,21):this.Ff=Z$1(this.Ff,21);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,23):this.Ff=Z$1(this.Ff,23);}}),Object.defineProperty(this,"doNotScroll",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,24))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,24):this.Ff=Z$1(this.Ff,24);}}),Object.defineProperty(this,"comb",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,25))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,25):this.Ff=Z$1(this.Ff,25);}}),Object.defineProperty(this,"richText",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,26):this.Ff=Z$1(this.Ff,26);}});var t=null;Object.defineProperty(this,"MaxLen",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"maxLength",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){Number.isInteger(e)&&(t=e);}}),Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return this.V||this.DV}});};H(Nt,lt$1);var Lt$1=function(){Nt.call(this),Object.defineProperty(this,"password",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,14))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,14):this.Ff=Z$1(this.Ff,14);}}),this.password=!0;};H(Lt$1,Nt);var At={CheckBox:{createAppearanceStream:function(){return {N:{On:At.CheckBox.YesNormal},D:{On:At.CheckBox.YesPushDown,Off:At.CheckBox.OffPushDown}}},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=t.scope.internal.getFont(t.fontName,t.fontStyle).id,i=t.scope.__private__.encodeColorString(t.color),a=tt(t,t.caption);return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),r.push("BMC"),r.push("q"),r.push("0 0 1 rg"),r.push("/"+n+" "+U$1(a.fontSize)+" Tf "+i),r.push("BT"),r.push(a.text),r.push("ET"),r.push("Q"),r.push("EMC"),e.stream=r.join("\n"),e},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=t.scope.internal.getFont(t.fontName,t.fontStyle).id,n=t.scope.__private__.encodeColorString(t.color),i=[],a=At.internal.getHeight(t),o=At.internal.getWidth(t),s=tt(t,t.caption);return i.push("1 g"),i.push("0 0 "+U$1(o)+" "+U$1(a)+" re"),i.push("f"),i.push("q"),i.push("0 0 1 rg"),i.push("0 0 "+U$1(o-1)+" "+U$1(a-1)+" re"),i.push("W"),i.push("n"),i.push("0 g"),i.push("BT"),i.push("/"+r+" "+U$1(s.fontSize)+" Tf "+n),i.push(s.text),i.push("ET"),i.push("Q"),e.stream=i.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[];return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),e.stream=r.join("\n"),e}},RadioButton:{Circle:{createAppearanceStream:function(t){var e={D:{Off:At.RadioButton.Circle.OffPushDown},N:{}};return e.N[t]=At.RadioButton.Circle.YesNormal,e.D[t]=At.RadioButton.Circle.YesPushDown,e},getCA:function(){return "l"},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=At.internal.Bezier_C,a=Number((n*i).toFixed(5));return r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(n+" 0 m"),r.push(n+" "+a+" "+a+" "+n+" 0 "+n+" c"),r.push("-"+a+" "+n+" -"+n+" "+a+" -"+n+" 0 c"),r.push("-"+n+" -"+a+" -"+a+" -"+n+" 0 -"+n+" c"),r.push(a+" -"+n+" "+n+" -"+a+" "+n+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=Number((2*n).toFixed(5)),a=Number((i*At.internal.Bezier_C).toFixed(5)),o=Number((n*At.internal.Bezier_C).toFixed(5));return r.push("0.749023 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(i+" 0 m"),r.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),r.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),r.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),r.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),r.push("f"),r.push("Q"),r.push("0 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(n+" 0 m"),r.push(n+" "+o+" "+o+" "+n+" 0 "+n+" c"),r.push("-"+o+" "+n+" -"+n+" "+o+" -"+n+" 0 c"),r.push("-"+n+" -"+o+" -"+o+" -"+n+" 0 -"+n+" c"),r.push(o+" -"+n+" "+n+" -"+o+" "+n+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=Number((2*n).toFixed(5)),a=Number((i*At.internal.Bezier_C).toFixed(5));return r.push("0.749023 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(i+" 0 m"),r.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),r.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),r.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),r.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e}},Cross:{createAppearanceStream:function(t){var e={D:{Off:At.RadioButton.Cross.OffPushDown},N:{}};return e.N[t]=At.RadioButton.Cross.YesNormal,e.D[t]=At.RadioButton.Cross.YesPushDown,e},getCA:function(){return "8"},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.calculateCross(t);return r.push("q"),r.push("1 1 "+U$1(At.internal.getWidth(t)-2)+" "+U$1(At.internal.getHeight(t)-2)+" re"),r.push("W"),r.push("n"),r.push(U$1(n.x1.x)+" "+U$1(n.x1.y)+" m"),r.push(U$1(n.x2.x)+" "+U$1(n.x2.y)+" l"),r.push(U$1(n.x4.x)+" "+U$1(n.x4.y)+" m"),r.push(U$1(n.x3.x)+" "+U$1(n.x3.y)+" l"),r.push("s"),r.push("Q"),e.stream=r.join("\n"),e},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=At.internal.calculateCross(t),n=[];return n.push("0.749023 g"),n.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),n.push("f"),n.push("q"),n.push("1 1 "+U$1(At.internal.getWidth(t)-2)+" "+U$1(At.internal.getHeight(t)-2)+" re"),n.push("W"),n.push("n"),n.push(U$1(r.x1.x)+" "+U$1(r.x1.y)+" m"),n.push(U$1(r.x2.x)+" "+U$1(r.x2.y)+" l"),n.push(U$1(r.x4.x)+" "+U$1(r.x4.y)+" m"),n.push(U$1(r.x3.x)+" "+U$1(r.x3.y)+" l"),n.push("s"),n.push("Q"),e.stream=n.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[];return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),e.stream=r.join("\n"),e}}},createDefaultAppearanceStream:function(t){var e=t.scope.internal.getFont(t.fontName,t.fontStyle).id,r=t.scope.__private__.encodeColorString(t.color);return "/"+e+" "+t.fontSize+" Tf "+r}};At.internal={Bezier_C:.551915024494,calculateCross:function(t){var e=At.internal.getWidth(t),r=At.internal.getHeight(t),n=Math.min(e,r);return {x1:{x:(e-n)/2,y:(r-n)/2+n},x2:{x:(e-n)/2+n,y:(r-n)/2},x3:{x:(e-n)/2,y:(r-n)/2},x4:{x:(e-n)/2+n,y:(r-n)/2+n}}}},At.internal.getWidth=function(e){var r=0;return "object"===_typeof$2(e)&&(r=W(e.Rect[2])),r},At.internal.getHeight=function(e){var r=0;return "object"===_typeof$2(e)&&(r=W(e.Rect[3])),r};var xt=q.addField=function(t){if(at(this,t),!(t instanceof lt$1))throw new Error("Invalid argument passed to jsPDF.addField.");var e;return (e=t).scope.internal.acroformPlugin.printedOut&&(e.scope.internal.acroformPlugin.printedOut=!1,e.scope.internal.acroformPlugin.acroFormDictionaryRoot=null),e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e),t.page=t.scope.internal.getCurrentPageInfo().pageNumber,this};q.AcroFormChoiceField=ft,q.AcroFormListBox=dt,q.AcroFormComboBox=pt,q.AcroFormEditBox=gt$1,q.AcroFormButton=mt,q.AcroFormPushButton=vt,q.AcroFormRadioButton=bt,q.AcroFormCheckBox=wt,q.AcroFormTextField=Nt,q.AcroFormPasswordField=Lt$1,q.AcroFormAppearance=At,q.AcroForm={ChoiceField:ft,ListBox:dt,ComboBox:pt,EditBox:gt$1,Button:mt,PushButton:vt,RadioButton:bt,CheckBox:wt,TextField:Nt,PasswordField:Lt$1,Appearance:At},E$1.AcroForm={ChoiceField:ft,ListBox:dt,ComboBox:pt,EditBox:gt$1,Button:mt,PushButton:vt,RadioButton:bt,CheckBox:wt,TextField:Nt,PasswordField:Lt$1,Appearance:At};function _t(t){return t.reduce((function(t,e,r){return t[e]=r,t}),{})}!function(e){e.__addimage__={};var r="UNKNOWN",n={PNG:[[137,80,78,71]],TIFF:[[77,77,0,42],[73,73,42,0]],JPEG:[[255,216,255,224,void 0,void 0,74,70,73,70,0],[255,216,255,225,void 0,void 0,69,120,105,102,0,0],[255,216,255,219],[255,216,255,238]],JPEG2000:[[0,0,0,12,106,80,32,32]],GIF87a:[[71,73,70,56,55,97]],GIF89a:[[71,73,70,56,57,97]],WEBP:[[82,73,70,70,void 0,void 0,void 0,void 0,87,69,66,80]],BMP:[[66,77],[66,65],[67,73],[67,80],[73,67],[80,84]]},i=e.__addimage__.getImageFileTypeByImageData=function(t,e){var i,a,o,s,c,u=r;if("RGBA"===(e=e||r)||void 0!==t.data&&t.data instanceof Uint8ClampedArray&&"height"in t&&"width"in t)return "RGBA";if(x(t))for(c in n)for(o=n[c],i=0;i<o.length;i+=1){for(s=!0,a=0;a<o[i].length;a+=1)if(void 0!==o[i][a]&&o[i][a]!==t[a]){s=!1;break}if(!0===s){u=c;break}}else for(c in n)for(o=n[c],i=0;i<o.length;i+=1){for(s=!0,a=0;a<o[i].length;a+=1)if(void 0!==o[i][a]&&o[i][a]!==t.charCodeAt(a)){s=!1;break}if(!0===s){u=c;break}}return u===r&&e!==r&&(u=e),u},a=function t(e){for(var r=this.internal.write,n=this.internal.putStream,i=(0, this.internal.getFilters)();-1!==i.indexOf("FlateEncode");)i.splice(i.indexOf("FlateEncode"),1);e.objectId=this.internal.newObject();var a=[];if(a.push({key:"Type",value:"/XObject"}),a.push({key:"Subtype",value:"/Image"}),a.push({key:"Width",value:e.width}),a.push({key:"Height",value:e.height}),e.colorSpace===b.INDEXED?a.push({key:"ColorSpace",value:"[/Indexed /DeviceRGB "+(e.palette.length/3-1)+" "+("sMask"in e&&void 0!==e.sMask?e.objectId+2:e.objectId+1)+" 0 R]"}):(a.push({key:"ColorSpace",value:"/"+e.colorSpace}),e.colorSpace===b.DEVICE_CMYK&&a.push({key:"Decode",value:"[1 0 1 0 1 0 1 0]"})),a.push({key:"BitsPerComponent",value:e.bitsPerComponent}),"decodeParameters"in e&&void 0!==e.decodeParameters&&a.push({key:"DecodeParms",value:"<<"+e.decodeParameters+">>"}),"transparency"in e&&Array.isArray(e.transparency)){for(var o="",s=0,c=e.transparency.length;s<c;s++)o+=e.transparency[s]+" "+e.transparency[s]+" ";a.push({key:"Mask",value:"["+o+"]"});}void 0!==e.sMask&&a.push({key:"SMask",value:e.objectId+1+" 0 R"});var u=void 0!==e.filter?["/"+e.filter]:void 0;if(n({data:e.data,additionalKeyValues:a,alreadyAppliedFilters:u,objectId:e.objectId}),r("endobj"),"sMask"in e&&void 0!==e.sMask){var h="/Predictor "+e.predictor+" /Colors 1 /BitsPerComponent "+e.bitsPerComponent+" /Columns "+e.width,l={width:e.width,height:e.height,colorSpace:"DeviceGray",bitsPerComponent:e.bitsPerComponent,decodeParameters:h,data:e.sMask};"filter"in e&&(l.filter=e.filter),t.call(this,l);}if(e.colorSpace===b.INDEXED){var f=this.internal.newObject();n({data:_(new Uint8Array(e.palette)),objectId:f}),r("endobj");}},o=function(){var t=this.internal.collections.addImage_images;for(var e in t)a.call(this,t[e]);},s=function(){var t,e=this.internal.collections.addImage_images,r=this.internal.write;for(var n in e)r("/I"+(t=e[n]).index,t.objectId,"0","R");},c=function(){this.internal.collections.addImage_images||(this.internal.collections.addImage_images={},this.internal.events.subscribe("putResources",o),this.internal.events.subscribe("putXobjectDict",s));},h=function(){var t=this.internal.collections.addImage_images;return c.call(this),t},l=function(){return Object.keys(this.internal.collections.addImage_images).length},f=function(t){return "function"==typeof e["process"+t.toUpperCase()]},d=function(e){return "object"===_typeof$2(e)&&1===e.nodeType},p=function(t,r){if("IMG"===t.nodeName&&t.hasAttribute("src")){var n=""+t.getAttribute("src");if(0===n.indexOf("data:image/"))return u$2(unescape(n).split("base64,").pop());var i=e.loadFile(n,!0);if(void 0!==i)return i}if("CANVAS"===t.nodeName){if(0===t.width||0===t.height)throw new Error("Given canvas must have data. Canvas width: "+t.width+", height: "+t.height);var a;switch(r){case"PNG":a="image/png";break;case"WEBP":a="image/webp";break;case"JPEG":case"JPG":default:a="image/jpeg";}return u$2(t.toDataURL(a,1).split("base64,").pop())}},g=function(t){var e=this.internal.collections.addImage_images;if(e)for(var r in e)if(t===e[r].alias)return e[r]},m=function(t,e,r){return t||e||(t=-96,e=-96),t<0&&(t=-1*r.width*72/t/this.internal.scaleFactor),e<0&&(e=-1*r.height*72/e/this.internal.scaleFactor),0===t&&(t=e*r.width/r.height),0===e&&(e=t*r.height/r.width),[t,e]},v=function(t,e,r,n,i,a){var o=m.call(this,r,n,i),s=this.internal.getCoordinateString,c=this.internal.getVerticalCoordinateString,u=h.call(this);if(r=o[0],n=o[1],u[i.index]=i,a){a*=Math.PI/180;var l=Math.cos(a),f=Math.sin(a),d=function(t){return t.toFixed(4)},p=[d(l),d(f),d(-1*f),d(l),0,0,"cm"];}this.internal.write("q"),a?(this.internal.write([1,"0","0",1,s(t),c(e+n),"cm"].join(" ")),this.internal.write(p.join(" ")),this.internal.write([s(r),"0","0",s(n),"0","0","cm"].join(" "))):this.internal.write([s(r),"0","0",s(n),s(t),c(e+n),"cm"].join(" ")),this.isAdvancedAPI()&&this.internal.write([1,0,0,-1,0,0,"cm"].join(" ")),this.internal.write("/I"+i.index+" Do"),this.internal.write("Q");},b=e.color_spaces={DEVICE_RGB:"DeviceRGB",DEVICE_GRAY:"DeviceGray",DEVICE_CMYK:"DeviceCMYK",CAL_GREY:"CalGray",CAL_RGB:"CalRGB",LAB:"Lab",ICC_BASED:"ICCBased",INDEXED:"Indexed",PATTERN:"Pattern",SEPARATION:"Separation",DEVICE_N:"DeviceN"};e.decode={DCT_DECODE:"DCTDecode",FLATE_DECODE:"FlateDecode",LZW_DECODE:"LZWDecode",JPX_DECODE:"JPXDecode",JBIG2_DECODE:"JBIG2Decode",ASCII85_DECODE:"ASCII85Decode",ASCII_HEX_DECODE:"ASCIIHexDecode",RUN_LENGTH_DECODE:"RunLengthDecode",CCITT_FAX_DECODE:"CCITTFaxDecode"};var y=e.image_compression={NONE:"NONE",FAST:"FAST",MEDIUM:"MEDIUM",SLOW:"SLOW"},w=e.__addimage__.sHashCode=function(t){var e,r,n=0;if("string"==typeof t)for(r=t.length,e=0;e<r;e++)n=(n<<5)-n+t.charCodeAt(e),n|=0;else if(x(t))for(r=t.byteLength/2,e=0;e<r;e++)n=(n<<5)-n+t[e],n|=0;return n},N=e.__addimage__.validateStringAsBase64=function(t){(t=t||"").toString().trim();var e=!0;return 0===t.length&&(e=!1),t.length%4!=0&&(e=!1),!1===/^[A-Za-z0-9+/]+$/.test(t.substr(0,t.length-2))&&(e=!1),!1===/^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t.substr(-2))&&(e=!1),e},L=e.__addimage__.extractImageFromDataUrl=function(t){var e=(t=t||"").split("base64,"),r=null;if(2===e.length){var n=/^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e[0]);Array.isArray(n)&&(r={mimeType:n[1],charset:n[2],data:e[1]});}return r},A=e.__addimage__.supportsArrayBuffer=function(){return "undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array};e.__addimage__.isArrayBuffer=function(t){return A()&&t instanceof ArrayBuffer};var x=e.__addimage__.isArrayBufferView=function(t){return A()&&"undefined"!=typeof Uint32Array&&(t instanceof Int8Array||t instanceof Uint8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array)},S=e.__addimage__.binaryStringToUint8Array=function(t){for(var e=t.length,r=new Uint8Array(e),n=0;n<e;n++)r[n]=t.charCodeAt(n);return r},_=e.__addimage__.arrayBufferToBinaryString=function(t){for(var e="",r=x(t)?t:new Uint8Array(t),n=0;n<r.length;n+=8192)e+=String.fromCharCode.apply(null,r.subarray(n,n+8192));return e};e.addImage=function(){var e,n,i,a,o,s,u,h,l;if("number"==typeof arguments[1]?(n=r,i=arguments[1],a=arguments[2],o=arguments[3],s=arguments[4],u=arguments[5],h=arguments[6],l=arguments[7]):(n=arguments[1],i=arguments[2],a=arguments[3],o=arguments[4],s=arguments[5],u=arguments[6],h=arguments[7],l=arguments[8]),"object"===_typeof$2(e=arguments[0])&&!d(e)&&"imageData"in e){var f=e;e=f.imageData,n=f.format||n||r,i=f.x||i||0,a=f.y||a||0,o=f.w||f.width||o,s=f.h||f.height||s,u=f.alias||u,h=f.compression||h,l=f.rotation||f.angle||l;}var p=this.internal.getFilters();if(void 0===h&&-1!==p.indexOf("FlateEncode")&&(h="SLOW"),isNaN(i)||isNaN(a))throw new Error("Invalid coordinates passed to jsPDF.addImage");c.call(this);var g=P.call(this,e,n,u,h);return v.call(this,i,a,o,s,g,l),this};var P=function(t,n,a,o){var s,c,u;if("string"==typeof t&&i(t)===r){t=unescape(t);var h=k(t,!1);(""!==h||void 0!==(h=e.loadFile(t,!0)))&&(t=h);}if(d(t)&&(t=p(t,n)),n=i(t,n),!f(n))throw new Error("addImage does not support files of type '"+n+"', please ensure that a plugin for '"+n+"' support is added.");if((null==(u=a)||0===u.length)&&(a=function(t){return "string"==typeof t||x(t)?w(t):x(t.data)?w(t.data):null}(t)),(s=g.call(this,a))||(A()&&(t instanceof Uint8Array||"RGBA"===n||(c=t,t=S(t))),s=this["process"+n.toUpperCase()](t,l.call(this),a,function(t){return t&&"string"==typeof t&&(t=t.toUpperCase()),t in e.image_compression?t:y.NONE}(o),c)),!s)throw new Error("An unknown error occurred whilst processing the image.");return s},k=e.__addimage__.convertBase64ToBinaryString=function(t,e){var r;e="boolean"!=typeof e||e;var n,i="";if("string"==typeof t){n=null!==(r=L(t))?r.data:t;try{i=u$2(n);}catch(t){if(e)throw N(n)?new Error("atob-Error in jsPDF.convertBase64ToBinaryString "+t.message):new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ")}}return i};e.getImageProperties=function(t){var n,a,o="";if(d(t)&&(t=p(t)),"string"==typeof t&&i(t)===r&&(""===(o=k(t,!1))&&(o=e.loadFile(t)||""),t=o),a=i(t),!f(a))throw new Error("addImage does not support files of type '"+a+"', please ensure that a plugin for '"+a+"' support is added.");if(!A()||t instanceof Uint8Array||(t=S(t)),!(n=this["process"+a.toUpperCase()](t)))throw new Error("An unknown error occurred whilst processing the image");return n.fileType=a,n};}(E$1.API),
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(t){if(void 0!==t&&""!=t)return !0};E$1.API.events.push(["addPage",function(t){this.internal.getPageInfo(t.pageNumber).pageContext.annotations=[];}]),t.events.push(["putPage",function(t){for(var r,n,i,a=this.internal.getCoordinateString,o=this.internal.getVerticalCoordinateString,s=this.internal.getPageInfoByObjId(t.objId),c=t.pageContext.annotations,u=!1,h=0;h<c.length&&!u;h++)switch((r=c[h]).type){case"link":(e(r.options.url)||e(r.options.pageNumber))&&(u=!0);break;case"reference":case"text":case"freetext":u=!0;}if(0!=u){this.internal.write("/Annots [");for(var l=0;l<c.length;l++){r=c[l];var f=this.internal.pdfEscape,d=this.internal.getEncryptor(t.objId);switch(r.type){case"reference":this.internal.write(" "+r.object.objId+" 0 R ");break;case"text":var p=this.internal.newAdditionalObject(),g=this.internal.newAdditionalObject(),m=this.internal.getEncryptor(p.objId),v=r.title||"Note";i="<</Type /Annot /Subtype /Text "+(n="/Rect ["+a(r.bounds.x)+" "+o(r.bounds.y+r.bounds.h)+" "+a(r.bounds.x+r.bounds.w)+" "+o(r.bounds.y)+"] ")+"/Contents ("+f(m(r.contents))+")",i+=" /Popup "+g.objId+" 0 R",i+=" /P "+s.objId+" 0 R",i+=" /T ("+f(m(v))+") >>",p.content=i;var b=p.objId+" 0 R";i="<</Type /Annot /Subtype /Popup "+(n="/Rect ["+a(r.bounds.x+30)+" "+o(r.bounds.y+r.bounds.h)+" "+a(r.bounds.x+r.bounds.w+30)+" "+o(r.bounds.y)+"] ")+" /Parent "+b,r.open&&(i+=" /Open true"),i+=" >>",g.content=i,this.internal.write(p.objId,"0 R",g.objId,"0 R");break;case"freetext":n="/Rect ["+a(r.bounds.x)+" "+o(r.bounds.y)+" "+a(r.bounds.x+r.bounds.w)+" "+o(r.bounds.y+r.bounds.h)+"] ";var y=r.color||"#000000";i="<</Type /Annot /Subtype /FreeText "+n+"/Contents ("+f(d(r.contents))+")",i+=" /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#"+y+")",i+=" /Border [0 0 0]",i+=" >>",this.internal.write(i);break;case"link":if(r.options.name){var w=this.annotations._nameMap[r.options.name];r.options.pageNumber=w.page,r.options.top=w.y;}else r.options.top||(r.options.top=0);if(n="/Rect ["+r.finalBounds.x+" "+r.finalBounds.y+" "+r.finalBounds.w+" "+r.finalBounds.h+"] ",i="",r.options.url)i="<</Type /Annot /Subtype /Link "+n+"/Border [0 0 0] /A <</S /URI /URI ("+f(d(r.options.url))+") >>";else if(r.options.pageNumber){switch(i="<</Type /Annot /Subtype /Link "+n+"/Border [0 0 0] /Dest ["+this.internal.getPageInfo(r.options.pageNumber).objId+" 0 R",r.options.magFactor=r.options.magFactor||"XYZ",r.options.magFactor){case"Fit":i+=" /Fit]";break;case"FitH":i+=" /FitH "+r.options.top+"]";break;case"FitV":r.options.left=r.options.left||0,i+=" /FitV "+r.options.left+"]";break;case"XYZ":default:var N=o(r.options.top);r.options.left=r.options.left||0,void 0===r.options.zoom&&(r.options.zoom=0),i+=" /XYZ "+r.options.left+" "+N+" "+r.options.zoom+"]";}}""!=i&&(i+=" >>",this.internal.write(i));}}this.internal.write("]");}}]),t.createAnnotation=function(t){var e=this.internal.getCurrentPageInfo();switch(t.type){case"link":this.link(t.bounds.x,t.bounds.y,t.bounds.w,t.bounds.h,t);break;case"text":case"freetext":e.pageContext.annotations.push(t);}},t.link=function(t,e,r,n,i){var a=this.internal.getCurrentPageInfo(),o=this.internal.getCoordinateString,s=this.internal.getVerticalCoordinateString;a.pageContext.annotations.push({finalBounds:{x:o(t),y:s(e),w:o(t+r),h:s(e+n)},options:i,type:"link"});},t.textWithLink=function(t,e,r,n){var i,a,o=this.getTextWidth(t),s=this.internal.getLineHeight()/this.internal.scaleFactor;if(void 0!==n.maxWidth){a=n.maxWidth;var c=this.splitTextToSize(t,a).length;i=Math.ceil(s*c);}else a=o,i=s;return this.text(t,e,r,n),r+=.2*s,"center"===n.align&&(e-=o/2),"right"===n.align&&(e-=o),this.link(e,r-s,a,i,n),o},t.getTextWidth=function(t){var e=this.internal.getFontSize();return this.getStringUnitWidth(t)*e/this.internal.scaleFactor};}(E$1.API),
  /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e={1569:[65152],1570:[65153,65154],1571:[65155,65156],1572:[65157,65158],1573:[65159,65160],1574:[65161,65162,65163,65164],1575:[65165,65166],1576:[65167,65168,65169,65170],1577:[65171,65172],1578:[65173,65174,65175,65176],1579:[65177,65178,65179,65180],1580:[65181,65182,65183,65184],1581:[65185,65186,65187,65188],1582:[65189,65190,65191,65192],1583:[65193,65194],1584:[65195,65196],1585:[65197,65198],1586:[65199,65200],1587:[65201,65202,65203,65204],1588:[65205,65206,65207,65208],1589:[65209,65210,65211,65212],1590:[65213,65214,65215,65216],1591:[65217,65218,65219,65220],1592:[65221,65222,65223,65224],1593:[65225,65226,65227,65228],1594:[65229,65230,65231,65232],1601:[65233,65234,65235,65236],1602:[65237,65238,65239,65240],1603:[65241,65242,65243,65244],1604:[65245,65246,65247,65248],1605:[65249,65250,65251,65252],1606:[65253,65254,65255,65256],1607:[65257,65258,65259,65260],1608:[65261,65262],1609:[65263,65264,64488,64489],1610:[65265,65266,65267,65268],1649:[64336,64337],1655:[64477],1657:[64358,64359,64360,64361],1658:[64350,64351,64352,64353],1659:[64338,64339,64340,64341],1662:[64342,64343,64344,64345],1663:[64354,64355,64356,64357],1664:[64346,64347,64348,64349],1667:[64374,64375,64376,64377],1668:[64370,64371,64372,64373],1670:[64378,64379,64380,64381],1671:[64382,64383,64384,64385],1672:[64392,64393],1676:[64388,64389],1677:[64386,64387],1678:[64390,64391],1681:[64396,64397],1688:[64394,64395],1700:[64362,64363,64364,64365],1702:[64366,64367,64368,64369],1705:[64398,64399,64400,64401],1709:[64467,64468,64469,64470],1711:[64402,64403,64404,64405],1713:[64410,64411,64412,64413],1715:[64406,64407,64408,64409],1722:[64414,64415],1723:[64416,64417,64418,64419],1726:[64426,64427,64428,64429],1728:[64420,64421],1729:[64422,64423,64424,64425],1733:[64480,64481],1734:[64473,64474],1735:[64471,64472],1736:[64475,64476],1737:[64482,64483],1739:[64478,64479],1740:[64508,64509,64510,64511],1744:[64484,64485,64486,64487],1746:[64430,64431],1747:[64432,64433]},r={65247:{65154:65269,65156:65271,65160:65273,65166:65275},65248:{65154:65270,65156:65272,65160:65274,65166:65276},65165:{65247:{65248:{65258:65010}}},1617:{1612:64606,1613:64607,1614:64608,1615:64609,1616:64610}},n={1612:64606,1613:64607,1614:64608,1615:64609,1616:64610},i=[1570,1571,1573,1575];t.__arabicParser__={};var a=t.__arabicParser__.isInArabicSubstitutionA=function(t){return void 0!==e[t.charCodeAt(0)]},o=t.__arabicParser__.isArabicLetter=function(t){return "string"==typeof t&&/^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t)},s=t.__arabicParser__.isArabicEndLetter=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length<=2},c=t.__arabicParser__.isArabicAlfLetter=function(t){return o(t)&&i.indexOf(t.charCodeAt(0))>=0};t.__arabicParser__.arabicLetterHasIsolatedForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=1};var u=t.__arabicParser__.arabicLetterHasFinalForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=2};t.__arabicParser__.arabicLetterHasInitialForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=3};var h=t.__arabicParser__.arabicLetterHasMedialForm=function(t){return o(t)&&a(t)&&4==e[t.charCodeAt(0)].length},l=t.__arabicParser__.resolveLigatures=function(t){var e=0,n=r,i="",a=0;for(e=0;e<t.length;e+=1)void 0!==n[t.charCodeAt(e)]?(a++,"number"==typeof(n=n[t.charCodeAt(e)])&&(i+=String.fromCharCode(n),n=r,a=0),e===t.length-1&&(n=r,i+=t.charAt(e-(a-1)),e-=a-1,a=0)):(n=r,i+=t.charAt(e-a),e-=a,a=0);return i};t.__arabicParser__.isArabicDiacritic=function(t){return void 0!==t&&void 0!==n[t.charCodeAt(0)]};var f=t.__arabicParser__.getCorrectForm=function(t,e,r){return o(t)?!1===a(t)?-1:!u(t)||!o(e)&&!o(r)||!o(r)&&s(e)||s(t)&&!o(e)||s(t)&&c(e)||s(t)&&s(e)?0:h(t)&&o(e)&&!s(e)&&o(r)&&u(r)?3:s(t)||!o(r)?1:2:-1},d=function(t){var r=0,n=0,i=0,a="",s="",c="",u=(t=t||"").split("\\s+"),h=[];for(r=0;r<u.length;r+=1){for(h.push(""),n=0;n<u[r].length;n+=1)a=u[r][n],s=u[r][n-1],c=u[r][n+1],o(a)?(i=f(a,s,c),h[r]+=-1!==i?String.fromCharCode(e[a.charCodeAt(0)][i]):a):h[r]+=a;h[r]=l(h[r]);}return h.join(" ")},p=t.__arabicParser__.processArabic=t.processArabic=function(){var t,e="string"==typeof arguments[0]?arguments[0]:arguments[0].text,r=[];if(Array.isArray(e)){var n=0;for(r=[],n=0;n<e.length;n+=1)Array.isArray(e[n])?r.push([d(e[n][0]),e[n][1],e[n][2]]):r.push([d(e[n])]);t=r;}else t=d(e);return "string"==typeof arguments[0]?t:(arguments[0].text=t,arguments[0])};t.events.push(["preProcessText",p]);}(E$1.API),E$1.API.autoPrint=function(t){var e;switch((t=t||{}).variant=t.variant||"non-conform",t.variant){case"javascript":this.addJS("print({});");break;case"non-conform":default:this.internal.events.subscribe("postPutResources",(function(){e=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /Named"),this.internal.out("/Type /Action"),this.internal.out("/N /Print"),this.internal.out(">>"),this.internal.out("endobj");})),this.internal.events.subscribe("putCatalog",(function(){this.internal.out("/OpenAction "+e+" 0 R");}));}return this},
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(){var t=void 0;Object.defineProperty(this,"pdf",{get:function(){return t},set:function(e){t=e;}});var e=150;Object.defineProperty(this,"width",{get:function(){return e},set:function(t){e=isNaN(t)||!1===Number.isInteger(t)||t<0?150:t,this.getContext("2d").pageWrapXEnabled&&(this.getContext("2d").pageWrapX=e+1);}});var r=300;Object.defineProperty(this,"height",{get:function(){return r},set:function(t){r=isNaN(t)||!1===Number.isInteger(t)||t<0?300:t,this.getContext("2d").pageWrapYEnabled&&(this.getContext("2d").pageWrapY=r+1);}});var n=[];Object.defineProperty(this,"childNodes",{get:function(){return n},set:function(t){n=t;}});var i={};Object.defineProperty(this,"style",{get:function(){return i},set:function(t){i=t;}}),Object.defineProperty(this,"parentNode",{});};e.prototype.getContext=function(t,e){var r;if("2d"!==(t=t||"2d"))return null;for(r in e)this.pdf.context2d.hasOwnProperty(r)&&(this.pdf.context2d[r]=e[r]);return this.pdf.context2d._canvas=this,this.pdf.context2d},e.prototype.toDataURL=function(){throw new Error("toDataURL is not implemented.")},t.events.push(["initialized",function(){this.canvas=new e,this.canvas.pdf=this;}]);}(E$1.API),function(e){var r={left:0,top:0,bottom:0,right:0},n=!1,i=function(){void 0===this.internal.__cell__&&(this.internal.__cell__={},this.internal.__cell__.padding=3,this.internal.__cell__.headerFunction=void 0,this.internal.__cell__.margins=Object.assign({},r),this.internal.__cell__.margins.width=this.getPageWidth(),a.call(this));},a=function(){this.internal.__cell__.lastCell=new o,this.internal.__cell__.pages=1;},o=function(){var t=arguments[0];Object.defineProperty(this,"x",{enumerable:!0,get:function(){return t},set:function(e){t=e;}});var e=arguments[1];Object.defineProperty(this,"y",{enumerable:!0,get:function(){return e},set:function(t){e=t;}});var r=arguments[2];Object.defineProperty(this,"width",{enumerable:!0,get:function(){return r},set:function(t){r=t;}});var n=arguments[3];Object.defineProperty(this,"height",{enumerable:!0,get:function(){return n},set:function(t){n=t;}});var i=arguments[4];Object.defineProperty(this,"text",{enumerable:!0,get:function(){return i},set:function(t){i=t;}});var a=arguments[5];Object.defineProperty(this,"lineNumber",{enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o=arguments[6];return Object.defineProperty(this,"align",{enumerable:!0,get:function(){return o},set:function(t){o=t;}}),this};o.prototype.clone=function(){return new o(this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align)},o.prototype.toArray=function(){return [this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align]},e.setHeaderFunction=function(t){return i.call(this),this.internal.__cell__.headerFunction="function"==typeof t?t:void 0,this},e.getTextDimensions=function(t,e){i.call(this);var r=(e=e||{}).fontSize||this.getFontSize(),n=e.font||this.getFont(),a=e.scaleFactor||this.internal.scaleFactor,o=0,s=0,c=0,u=this;if(!Array.isArray(t)&&"string"!=typeof t){if("number"!=typeof t)throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");t=String(t);}var h=e.maxWidth;h>0?"string"==typeof t?t=this.splitTextToSize(t,h):"[object Array]"===Object.prototype.toString.call(t)&&(t=t.reduce((function(t,e){return t.concat(u.splitTextToSize(e,h))}),[])):t=Array.isArray(t)?t:[t];for(var l=0;l<t.length;l++)o<(c=this.getStringUnitWidth(t[l],{font:n})*r)&&(o=c);return 0!==o&&(s=t.length),{w:o/=a,h:Math.max((s*r*this.getLineHeightFactor()-r*(this.getLineHeightFactor()-1))/a,0)}},e.cellAddPage=function(){i.call(this),this.addPage();var t=this.internal.__cell__.margins||r;return this.internal.__cell__.lastCell=new o(t.left,t.top,void 0,void 0),this.internal.__cell__.pages+=1,this};var s=e.cell=function(){var t;t=arguments[0]instanceof o?arguments[0]:new o(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]),i.call(this);var e=this.internal.__cell__.lastCell,a=this.internal.__cell__.padding,s=this.internal.__cell__.margins||r,c=this.internal.__cell__.tableHeaderRow,u=this.internal.__cell__.printHeaders;return void 0!==e.lineNumber&&(e.lineNumber===t.lineNumber?(t.x=(e.x||0)+(e.width||0),t.y=e.y||0):e.y+e.height+t.height+s.bottom>this.getPageHeight()?(this.cellAddPage(),t.y=s.top,u&&c&&(this.printHeaderRow(t.lineNumber,!0),t.y+=c[0].height)):t.y=e.y+e.height||t.y),void 0!==t.text[0]&&(this.rect(t.x,t.y,t.width,t.height,!0===n?"FD":void 0),"right"===t.align?this.text(t.text,t.x+t.width-a,t.y+a,{align:"right",baseline:"top"}):"center"===t.align?this.text(t.text,t.x+t.width/2,t.y+a,{align:"center",baseline:"top",maxWidth:t.width-a-a}):this.text(t.text,t.x+a,t.y+a,{align:"left",baseline:"top",maxWidth:t.width-a-a})),this.internal.__cell__.lastCell=t,this};e.table=function(e,n,u,h,l){if(i.call(this),!u)throw new Error("No data for PDF table.");var f,d,p,g,m=[],v=[],b=[],y={},w={},N=[],L=[],A=(l=l||{}).autoSize||!1,x=!1!==l.printHeaders,S=l.css&&void 0!==l.css["font-size"]?16*l.css["font-size"]:l.fontSize||12,_=l.margins||Object.assign({width:this.getPageWidth()},r),P="number"==typeof l.padding?l.padding:3,k=l.headerBackgroundColor||"#c8c8c8",I=l.headerTextColor||"#000";if(a.call(this),this.internal.__cell__.printHeaders=x,this.internal.__cell__.margins=_,this.internal.__cell__.table_font_size=S,this.internal.__cell__.padding=P,this.internal.__cell__.headerBackgroundColor=k,this.internal.__cell__.headerTextColor=I,this.setFontSize(S),null==h)v=m=Object.keys(u[0]),b=m.map((function(){return "left"}));else if(Array.isArray(h)&&"object"===_typeof$2(h[0]))for(m=h.map((function(t){return t.name})),v=h.map((function(t){return t.prompt||t.name||""})),b=h.map((function(t){return t.align||"left"})),f=0;f<h.length;f+=1)w[h[f].name]=h[f].width*(19.049976/25.4);else Array.isArray(h)&&"string"==typeof h[0]&&(v=m=h,b=m.map((function(){return "left"})));if(A||Array.isArray(h)&&"string"==typeof h[0])for(f=0;f<m.length;f+=1){for(y[g=m[f]]=u.map((function(t){return t[g]})),this.setFont(void 0,"bold"),N.push(this.getTextDimensions(v[f],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w),d=y[g],this.setFont(void 0,"normal"),p=0;p<d.length;p+=1)N.push(this.getTextDimensions(d[p],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w);w[g]=Math.max.apply(null,N)+P+P,N=[];}if(x){var F={};for(f=0;f<m.length;f+=1)F[m[f]]={},F[m[f]].text=v[f],F[m[f]].align=b[f];var C=c.call(this,F,w);L=m.map((function(t){return new o(e,n,w[t],C,F[t].text,void 0,F[t].align)})),this.setTableHeaderRow(L),this.printHeaderRow(1,!1);}var j=h.reduce((function(t,e){return t[e.name]=e.align,t}),{});for(f=0;f<u.length;f+=1){"rowStart"in l&&l.rowStart instanceof Function&&l.rowStart({row:f,data:u[f]},this);var O=c.call(this,u[f],w);for(p=0;p<m.length;p+=1){var B=u[f][m[p]];"cellStart"in l&&l.cellStart instanceof Function&&l.cellStart({row:f,col:p,data:B},this),s.call(this,new o(e,n,w[m[p]],O,B,f+2,j[m[p]]));}}return this.internal.__cell__.table_x=e,this.internal.__cell__.table_y=n,this};var c=function(t,e){var r=this.internal.__cell__.padding,n=this.internal.__cell__.table_font_size,i=this.internal.scaleFactor;return Object.keys(t).map((function(n){var i=t[n];return this.splitTextToSize(i.hasOwnProperty("text")?i.text:i,e[n]-r-r)}),this).map((function(t){return this.getLineHeightFactor()*t.length*n/i+r+r}),this).reduce((function(t,e){return Math.max(t,e)}),0)};e.setTableHeaderRow=function(t){i.call(this),this.internal.__cell__.tableHeaderRow=t;},e.printHeaderRow=function(t,e){if(i.call(this),!this.internal.__cell__.tableHeaderRow)throw new Error("Property tableHeaderRow does not exist.");var r;if(n=!0,"function"==typeof this.internal.__cell__.headerFunction){var a=this.internal.__cell__.headerFunction(this,this.internal.__cell__.pages);this.internal.__cell__.lastCell=new o(a[0],a[1],a[2],a[3],void 0,-1);}this.setFont(void 0,"bold");for(var c=[],u=0;u<this.internal.__cell__.tableHeaderRow.length;u+=1){r=this.internal.__cell__.tableHeaderRow[u].clone(),e&&(r.y=this.internal.__cell__.margins.top||0,c.push(r)),r.lineNumber=t;var h=this.getTextColor();this.setTextColor(this.internal.__cell__.headerTextColor),this.setFillColor(this.internal.__cell__.headerBackgroundColor),s.call(this,r),this.setTextColor(h);}c.length>0&&this.setTableHeaderRow(c),this.setFont(void 0,"normal"),n=!1;};}(E$1.API);var Pt={italic:["italic","oblique","normal"],oblique:["oblique","italic","normal"],normal:["normal","oblique","italic"]},kt=["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded"],It=_t(kt),Ft=[100,200,300,400,500,600,700,800,900],Ct=_t(Ft);function jt(t){var e=t.family.replace(/"|'/g,"").toLowerCase(),r=function(t){return Pt[t=t||"normal"]?t:"normal"}(t.style),n=function(t){if(!t)return 400;if("number"==typeof t)return t>=100&&t<=900&&t%100==0?t:400;if(/^\d00$/.test(t))return parseInt(t);switch(t){case"bold":return 700;case"normal":default:return 400}}(t.weight),i=function(t){return "number"==typeof It[t=t||"normal"]?t:"normal"}(t.stretch);return {family:e,style:r,weight:n,stretch:i,src:t.src||[],ref:t.ref||{name:e,style:[i,r,n].join(" ")}}}function Ot(t,e,r,n){var i;for(i=r;i>=0&&i<e.length;i+=n)if(t[e[i]])return t[e[i]];for(i=r;i>=0&&i<e.length;i-=n)if(t[e[i]])return t[e[i]]}var Bt={"sans-serif":"helvetica",fixed:"courier",monospace:"courier",terminal:"courier",cursive:"times",fantasy:"times",serif:"times"},Mt={caption:"times",icon:"times",menu:"times","message-box":"times","small-caption":"times","status-bar":"times"};function Et(t){return [t.stretch,t.style,t.weight,t.family].join(" ")}function qt(t,e,r){for(var n=(r=r||{}).defaultFontFamily||"times",i=Object.assign({},Bt,r.genericFontFamilies||{}),a=null,o=null,s=0;s<e.length;++s)if(i[(a=jt(e[s])).family]&&(a.family=i[a.family]),t.hasOwnProperty(a.family)){o=t[a.family];break}if(!(o=o||t[n]))throw new Error("Could not find a font-family for the rule '"+Et(a)+"' and default family '"+n+"'.");if(o=function(t,e){if(e[t])return e[t];var r=It[t],n=r<=It.normal?-1:1,i=Ot(e,kt,r,n);if(!i)throw new Error("Could not find a matching font-stretch value for "+t);return i}(a.stretch,o),o=function(t,e){if(e[t])return e[t];for(var r=Pt[t],n=0;n<r.length;++n)if(e[r[n]])return e[r[n]];throw new Error("Could not find a matching font-style for "+t)}(a.style,o),!(o=function(t,e){if(e[t])return e[t];if(400===t&&e[500])return e[500];if(500===t&&e[400])return e[400];var r=Ct[t],n=Ot(e,Ft,r,t<400?-1:1);if(!n)throw new Error("Could not find a matching font-weight for value "+t);return n}(a.weight,o)))throw new Error("Failed to resolve a font for the rule '"+Et(a)+"'.");return o}function Dt(t){return t.trimLeft()}function Rt(t,e){for(var r=0;r<t.length;){if(t.charAt(r)===e)return [t.substring(0,r),t.substring(r+1)];r+=1;}return null}function Tt(t){var e=t.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);return null===e?null:[e[0],t.substring(e[0].length)]}var Ut,zt,Ht,Wt=["times"];!function(e){var r,n,i,o,s,c,u,h,l,d=function(t){return t=t||{},this.isStrokeTransparent=t.isStrokeTransparent||!1,this.strokeOpacity=t.strokeOpacity||1,this.strokeStyle=t.strokeStyle||"#000000",this.fillStyle=t.fillStyle||"#000000",this.isFillTransparent=t.isFillTransparent||!1,this.fillOpacity=t.fillOpacity||1,this.font=t.font||"10px sans-serif",this.textBaseline=t.textBaseline||"alphabetic",this.textAlign=t.textAlign||"left",this.lineWidth=t.lineWidth||1,this.lineJoin=t.lineJoin||"miter",this.lineCap=t.lineCap||"butt",this.path=t.path||[],this.transform=void 0!==t.transform?t.transform.clone():new h,this.globalCompositeOperation=t.globalCompositeOperation||"normal",this.globalAlpha=t.globalAlpha||1,this.clip_path=t.clip_path||[],this.currentPoint=t.currentPoint||new c,this.miterLimit=t.miterLimit||10,this.lastPoint=t.lastPoint||new c,this.lineDashOffset=t.lineDashOffset||0,this.lineDash=t.lineDash||[],this.margin=t.margin||[0,0,0,0],this.prevPageLastElemOffset=t.prevPageLastElemOffset||0,this.ignoreClearRect="boolean"!=typeof t.ignoreClearRect||t.ignoreClearRect,this};e.events.push(["initialized",function(){this.context2d=new p(this),r=this.internal.f2,n=this.internal.getCoordinateString,i=this.internal.getVerticalCoordinateString,o=this.internal.getHorizontalCoordinate,s=this.internal.getVerticalCoordinate,c=this.internal.Point,u=this.internal.Rectangle,h=this.internal.Matrix,l=new d;}]);var p=function(t){Object.defineProperty(this,"canvas",{get:function(){return {parentNode:!1,style:!1}}});var e=t;Object.defineProperty(this,"pdf",{get:function(){return e}});var r=!1;Object.defineProperty(this,"pageWrapXEnabled",{get:function(){return r},set:function(t){r=Boolean(t);}});var n=!1;Object.defineProperty(this,"pageWrapYEnabled",{get:function(){return n},set:function(t){n=Boolean(t);}});var i=0;Object.defineProperty(this,"posX",{get:function(){return i},set:function(t){isNaN(t)||(i=t);}});var a=0;Object.defineProperty(this,"posY",{get:function(){return a},set:function(t){isNaN(t)||(a=t);}}),Object.defineProperty(this,"margin",{get:function(){return l.margin},set:function(t){var e;"number"==typeof t?e=[t,t,t,t]:((e=new Array(4))[0]=t[0],e[1]=t.length>=2?t[1]:e[0],e[2]=t.length>=3?t[2]:e[0],e[3]=t.length>=4?t[3]:e[1]),l.margin=e;}});var o=!1;Object.defineProperty(this,"autoPaging",{get:function(){return o},set:function(t){o=t;}});var s=0;Object.defineProperty(this,"lastBreak",{get:function(){return s},set:function(t){s=t;}});var c=[];Object.defineProperty(this,"pageBreaks",{get:function(){return c},set:function(t){c=t;}}),Object.defineProperty(this,"ctx",{get:function(){return l},set:function(t){t instanceof d&&(l=t);}}),Object.defineProperty(this,"path",{get:function(){return l.path},set:function(t){l.path=t;}});var u=[];Object.defineProperty(this,"ctxStack",{get:function(){return u},set:function(t){u=t;}}),Object.defineProperty(this,"fillStyle",{get:function(){return this.ctx.fillStyle},set:function(t){var e;e=g(t),this.ctx.fillStyle=e.style,this.ctx.isFillTransparent=0===e.a,this.ctx.fillOpacity=e.a,this.pdf.setFillColor(e.r,e.g,e.b,{a:e.a}),this.pdf.setTextColor(e.r,e.g,e.b,{a:e.a});}}),Object.defineProperty(this,"strokeStyle",{get:function(){return this.ctx.strokeStyle},set:function(t){var e=g(t);this.ctx.strokeStyle=e.style,this.ctx.isStrokeTransparent=0===e.a,this.ctx.strokeOpacity=e.a,0===e.a?this.pdf.setDrawColor(255,255,255):(e.a,this.pdf.setDrawColor(e.r,e.g,e.b));}}),Object.defineProperty(this,"lineCap",{get:function(){return this.ctx.lineCap},set:function(t){-1!==["butt","round","square"].indexOf(t)&&(this.ctx.lineCap=t,this.pdf.setLineCap(t));}}),Object.defineProperty(this,"lineWidth",{get:function(){return this.ctx.lineWidth},set:function(t){isNaN(t)||(this.ctx.lineWidth=t,this.pdf.setLineWidth(t));}}),Object.defineProperty(this,"lineJoin",{get:function(){return this.ctx.lineJoin},set:function(t){-1!==["bevel","round","miter"].indexOf(t)&&(this.ctx.lineJoin=t,this.pdf.setLineJoin(t));}}),Object.defineProperty(this,"miterLimit",{get:function(){return this.ctx.miterLimit},set:function(t){isNaN(t)||(this.ctx.miterLimit=t,this.pdf.setMiterLimit(t));}}),Object.defineProperty(this,"textBaseline",{get:function(){return this.ctx.textBaseline},set:function(t){this.ctx.textBaseline=t;}}),Object.defineProperty(this,"textAlign",{get:function(){return this.ctx.textAlign},set:function(t){-1!==["right","end","center","left","start"].indexOf(t)&&(this.ctx.textAlign=t);}});var h=null;function f(t,e){if(null===h){var r=function(t){var e=[];return Object.keys(t).forEach((function(r){t[r].forEach((function(t){var n=null;switch(t){case"bold":n={family:r,weight:"bold"};break;case"italic":n={family:r,style:"italic"};break;case"bolditalic":n={family:r,weight:"bold",style:"italic"};break;case"":case"normal":n={family:r};}null!==n&&(n.ref={name:r,style:t},e.push(n));}));})),e}(t.getFontList());h=function(t){for(var e={},r=0;r<t.length;++r){var n=jt(t[r]),i=n.family,a=n.stretch,o=n.style,s=n.weight;e[i]=e[i]||{},e[i][a]=e[i][a]||{},e[i][a][o]=e[i][a][o]||{},e[i][a][o][s]=n;}return e}(r.concat(e));}return h}var p=null;Object.defineProperty(this,"fontFaces",{get:function(){return p},set:function(t){h=null,p=t;}}),Object.defineProperty(this,"font",{get:function(){return this.ctx.font},set:function(t){var e;if(this.ctx.font=t,null!==(e=/^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t))){var r=e[1],n=(e[2],e[3]),i=e[4],a=(e[5],e[6]),o=/^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i)[2];i="px"===o?Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor):"em"===o?Math.floor(parseFloat(i)*this.pdf.getFontSize()):Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor),this.pdf.setFontSize(i);var s=function(t){var e,r,n=[],i=t.trim();if(""===i)return Wt;if(i in Mt)return [Mt[i]];for(;""!==i;){switch(r=null,e=(i=Dt(i)).charAt(0)){case'"':case"'":r=Rt(i.substring(1),e);break;default:r=Tt(i);}if(null===r)return Wt;if(n.push(r[0]),""!==(i=Dt(r[1]))&&","!==i.charAt(0))return Wt;i=i.replace(/^,/,"");}return n}(a);if(this.fontFaces){var c=qt(f(this.pdf,this.fontFaces),s.map((function(t){return {family:t,stretch:"normal",weight:n,style:r}})));this.pdf.setFont(c.ref.name,c.ref.style);}else {var u="";("bold"===n||parseInt(n,10)>=700||"bold"===r)&&(u="bold"),"italic"===r&&(u+="italic"),0===u.length&&(u="normal");for(var h="",l={arial:"Helvetica",Arial:"Helvetica",verdana:"Helvetica",Verdana:"Helvetica",helvetica:"Helvetica",Helvetica:"Helvetica","sans-serif":"Helvetica",fixed:"Courier",monospace:"Courier",terminal:"Courier",cursive:"Times",fantasy:"Times",serif:"Times"},d=0;d<s.length;d++){if(void 0!==this.pdf.internal.getFont(s[d],u,{noFallback:!0,disableWarning:!0})){h=s[d];break}if("bolditalic"===u&&void 0!==this.pdf.internal.getFont(s[d],"bold",{noFallback:!0,disableWarning:!0}))h=s[d],u="bold";else if(void 0!==this.pdf.internal.getFont(s[d],"normal",{noFallback:!0,disableWarning:!0})){h=s[d],u="normal";break}}if(""===h)for(var p=0;p<s.length;p++)if(l[s[p]]){h=l[s[p]];break}h=""===h?"Times":h,this.pdf.setFont(h,u);}}}}),Object.defineProperty(this,"globalCompositeOperation",{get:function(){return this.ctx.globalCompositeOperation},set:function(t){this.ctx.globalCompositeOperation=t;}}),Object.defineProperty(this,"globalAlpha",{get:function(){return this.ctx.globalAlpha},set:function(t){this.ctx.globalAlpha=t;}}),Object.defineProperty(this,"lineDashOffset",{get:function(){return this.ctx.lineDashOffset},set:function(t){this.ctx.lineDashOffset=t,T.call(this);}}),Object.defineProperty(this,"lineDash",{get:function(){return this.ctx.lineDash},set:function(t){this.ctx.lineDash=t,T.call(this);}}),Object.defineProperty(this,"ignoreClearRect",{get:function(){return this.ctx.ignoreClearRect},set:function(t){this.ctx.ignoreClearRect=Boolean(t);}});};p.prototype.setLineDash=function(t){this.lineDash=t;},p.prototype.getLineDash=function(){return this.lineDash.length%2?this.lineDash.concat(this.lineDash):this.lineDash.slice()},p.prototype.fill=function(){A.call(this,"fill",!1);},p.prototype.stroke=function(){A.call(this,"stroke",!1);},p.prototype.beginPath=function(){this.path=[{type:"begin"}];},p.prototype.moveTo=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.moveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.moveTo");var r=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"mt",x:r.x,y:r.y}),this.ctx.lastPoint=new c(t,e);},p.prototype.closePath=function(){var e=new c(0,0),r=0;for(r=this.path.length-1;-1!==r;r--)if("begin"===this.path[r].type&&"object"===_typeof$2(this.path[r+1])&&"number"==typeof this.path[r+1].x){e=new c(this.path[r+1].x,this.path[r+1].y);break}this.path.push({type:"close"}),this.ctx.lastPoint=new c(e.x,e.y);},p.prototype.lineTo=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.lineTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.lineTo");var r=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"lt",x:r.x,y:r.y}),this.ctx.lastPoint=new c(r.x,r.y);},p.prototype.clip=function(){this.ctx.clip_path=JSON.parse(JSON.stringify(this.path)),A.call(this,null,!0);},p.prototype.quadraticCurveTo=function(t,e,r,n){if(isNaN(r)||isNaN(n)||isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");var i=this.ctx.transform.applyToPoint(new c(r,n)),o=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"qct",x1:o.x,y1:o.y,x:i.x,y:i.y}),this.ctx.lastPoint=new c(i.x,i.y);},p.prototype.bezierCurveTo=function(t,e,r,n,i,o){if(isNaN(i)||isNaN(o)||isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");var s=this.ctx.transform.applyToPoint(new c(i,o)),u=this.ctx.transform.applyToPoint(new c(t,e)),h=this.ctx.transform.applyToPoint(new c(r,n));this.path.push({type:"bct",x1:u.x,y1:u.y,x2:h.x,y2:h.y,x:s.x,y:s.y}),this.ctx.lastPoint=new c(s.x,s.y);},p.prototype.arc=function(t,e,r,n,i,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i))throw a$2.error("jsPDF.context2d.arc: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.arc");if(o=Boolean(o),!this.ctx.transform.isIdentity){var s=this.ctx.transform.applyToPoint(new c(t,e));t=s.x,e=s.y;var u=this.ctx.transform.applyToPoint(new c(0,r)),h=this.ctx.transform.applyToPoint(new c(0,0));r=Math.sqrt(Math.pow(u.x-h.x,2)+Math.pow(u.y-h.y,2));}Math.abs(i-n)>=2*Math.PI&&(n=0,i=2*Math.PI),this.path.push({type:"arc",x:t,y:e,radius:r,startAngle:n,endAngle:i,counterclockwise:o});},p.prototype.arcTo=function(t,e,r,n,i){throw new Error("arcTo not implemented.")},p.prototype.rect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.rect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rect");this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+n),this.lineTo(t,e+n),this.lineTo(t,e),this.lineTo(t+r,e),this.lineTo(t,e);},p.prototype.fillRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.fillRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillRect");if(!m.call(this)){var i={};"butt"!==this.lineCap&&(i.lineCap=this.lineCap,this.lineCap="butt"),"miter"!==this.lineJoin&&(i.lineJoin=this.lineJoin,this.lineJoin="miter"),this.beginPath(),this.rect(t,e,r,n),this.fill(),i.hasOwnProperty("lineCap")&&(this.lineCap=i.lineCap),i.hasOwnProperty("lineJoin")&&(this.lineJoin=i.lineJoin);}},p.prototype.strokeRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.strokeRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");v.call(this)||(this.beginPath(),this.rect(t,e,r,n),this.stroke());},p.prototype.clearRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.clearRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.clearRect");this.ignoreClearRect||(this.fillStyle="#ffffff",this.fillRect(t,e,r,n));},p.prototype.save=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,r=0;r<this.pdf.internal.getNumberOfPages();r++)this.pdf.setPage(r+1),this.pdf.internal.out("q");if(this.pdf.setPage(e),t){this.ctx.fontSize=this.pdf.internal.getFontSize();var n=new d(this.ctx);this.ctxStack.push(this.ctx),this.ctx=n;}},p.prototype.restore=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,r=0;r<this.pdf.internal.getNumberOfPages();r++)this.pdf.setPage(r+1),this.pdf.internal.out("Q");this.pdf.setPage(e),t&&0!==this.ctxStack.length&&(this.ctx=this.ctxStack.pop(),this.fillStyle=this.ctx.fillStyle,this.strokeStyle=this.ctx.strokeStyle,this.font=this.ctx.font,this.lineCap=this.ctx.lineCap,this.lineWidth=this.ctx.lineWidth,this.lineJoin=this.ctx.lineJoin,this.lineDash=this.ctx.lineDash,this.lineDashOffset=this.ctx.lineDashOffset);},p.prototype.toDataURL=function(){throw new Error("toDataUrl not implemented.")};var g=function(t){var e,r,n,i;if(!0===t.isCanvasGradient&&(t=t.getColor()),!t)return {r:0,g:0,b:0,a:0,style:t};if(/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t))e=0,r=0,n=0,i=0;else {var a=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);if(null!==a)e=parseInt(a[1]),r=parseInt(a[2]),n=parseInt(a[3]),i=1;else if(null!==(a=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t)))e=parseInt(a[1]),r=parseInt(a[2]),n=parseInt(a[3]),i=parseFloat(a[4]);else {if(i=1,"string"==typeof t&&"#"!==t.charAt(0)){var o=new f$2(t);t=o.ok?o.toHex():"#000000";}4===t.length?(e=t.substring(1,2),e+=e,r=t.substring(2,3),r+=r,n=t.substring(3,4),n+=n):(e=t.substring(1,3),r=t.substring(3,5),n=t.substring(5,7)),e=parseInt(e,16),r=parseInt(r,16),n=parseInt(n,16);}}return {r:e,g:r,b:n,a:i,style:t}},m=function(){return this.ctx.isFillTransparent||0==this.globalAlpha},v=function(){return Boolean(this.ctx.isStrokeTransparent||0==this.globalAlpha)};p.prototype.fillText=function(t,e,r,n){if(isNaN(e)||isNaN(r)||"string"!=typeof t)throw a$2.error("jsPDF.context2d.fillText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillText");if(n=isNaN(n)?void 0:n,!m.call(this)){var i=q(this.ctx.transform.rotation),o=this.ctx.transform.scaleX;C.call(this,{text:t,x:e,y:r,scale:o,angle:i,align:this.textAlign,maxWidth:n});}},p.prototype.strokeText=function(t,e,r,n){if(isNaN(e)||isNaN(r)||"string"!=typeof t)throw a$2.error("jsPDF.context2d.strokeText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeText");if(!v.call(this)){n=isNaN(n)?void 0:n;var i=q(this.ctx.transform.rotation),o=this.ctx.transform.scaleX;C.call(this,{text:t,x:e,y:r,scale:o,renderingMode:"stroke",angle:i,align:this.textAlign,maxWidth:n});}},p.prototype.measureText=function(t){if("string"!=typeof t)throw a$2.error("jsPDF.context2d.measureText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.measureText");var e=this.pdf,r=this.pdf.internal.scaleFactor,n=e.internal.getFontSize(),i=e.getStringUnitWidth(t)*n/e.internal.scaleFactor,o=function(t){var e=(t=t||{}).width||0;return Object.defineProperty(this,"width",{get:function(){return e}}),this};return new o({width:i*=Math.round(96*r/72*1e4)/1e4})},p.prototype.scale=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.scale: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.scale");var r=new h(t,0,0,e,0,0);this.ctx.transform=this.ctx.transform.multiply(r);},p.prototype.rotate=function(t){if(isNaN(t))throw a$2.error("jsPDF.context2d.rotate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rotate");var e=new h(Math.cos(t),Math.sin(t),-Math.sin(t),Math.cos(t),0,0);this.ctx.transform=this.ctx.transform.multiply(e);},p.prototype.translate=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.translate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.translate");var r=new h(1,0,0,1,t,e);this.ctx.transform=this.ctx.transform.multiply(r);},p.prototype.transform=function(t,e,r,n,i,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(o))throw a$2.error("jsPDF.context2d.transform: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.transform");var s=new h(t,e,r,n,i,o);this.ctx.transform=this.ctx.transform.multiply(s);},p.prototype.setTransform=function(t,e,r,n,i,a){t=isNaN(t)?1:t,e=isNaN(e)?0:e,r=isNaN(r)?0:r,n=isNaN(n)?1:n,i=isNaN(i)?0:i,a=isNaN(a)?0:a,this.ctx.transform=new h(t,e,r,n,i,a);};var b=function(){return this.margin[0]>0||this.margin[1]>0||this.margin[2]>0||this.margin[3]>0};p.prototype.drawImage=function(t,e,r,n,i,a,o,s,c){var l=this.pdf.getImageProperties(t),f=1,d=1,p=1,g=1;void 0!==n&&void 0!==s&&(p=s/n,g=c/i,f=l.width/n*s/n,d=l.height/i*c/i),void 0===a&&(a=e,o=r,e=0,r=0),void 0!==n&&void 0===s&&(s=n,c=i),void 0===n&&void 0===s&&(s=l.width,c=l.height);for(var m,v=this.ctx.transform.decompose(),w=q(v.rotate.shx),A=new h,S=(A=(A=(A=A.multiply(v.translate)).multiply(v.skew)).multiply(v.scale)).applyToRectangle(new u(a-e*p,o-r*g,n*f,i*d)),_=y.call(this,S),P=[],k=0;k<_.length;k+=1)-1===P.indexOf(_[k])&&P.push(_[k]);if(L(P),this.autoPaging)for(var I=P[0],F=P[P.length-1],C=I;C<F+1;C++){this.pdf.setPage(C);var j=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],O=1===C?this.posY+this.margin[0]:this.margin[0],B=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],M=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],E=1===C?0:B+(C-2)*M;if(0!==this.ctx.clip_path.length){var D=this.path;m=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(m,this.posX+this.margin[3],-E+O+this.ctx.prevPageLastElemOffset),x.call(this,"fill",!0),this.path=D;}var R=JSON.parse(JSON.stringify(S));R=N([R],this.posX+this.margin[3],-E+O+this.ctx.prevPageLastElemOffset)[0];var T=(C>I||C<F)&&b.call(this);T&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],j,M,null).clip().discardPath()),this.pdf.addImage(t,"JPEG",R.x,R.y,R.w,R.h,null,null,w),T&&this.pdf.restoreGraphicsState();}else this.pdf.addImage(t,"JPEG",S.x,S.y,S.w,S.h,null,null,w);};var y=function(t,e,r){var n=[];e=e||this.pdf.internal.pageSize.width,r=r||this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2];var i=this.posY+this.ctx.prevPageLastElemOffset;switch(t.type){default:case"mt":case"lt":n.push(Math.floor((t.y+i)/r)+1);break;case"arc":n.push(Math.floor((t.y+i-t.radius)/r)+1),n.push(Math.floor((t.y+i+t.radius)/r)+1);break;case"qct":var a=D(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x,t.y);n.push(Math.floor((a.y+i)/r)+1),n.push(Math.floor((a.y+a.h+i)/r)+1);break;case"bct":var o=R(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x2,t.y2,t.x,t.y);n.push(Math.floor((o.y+i)/r)+1),n.push(Math.floor((o.y+o.h+i)/r)+1);break;case"rect":n.push(Math.floor((t.y+i)/r)+1),n.push(Math.floor((t.y+t.h+i)/r)+1);}for(var s=0;s<n.length;s+=1)for(;this.pdf.internal.getNumberOfPages()<n[s];)w.call(this);return n},w=function(){var t=this.fillStyle,e=this.strokeStyle,r=this.font,n=this.lineCap,i=this.lineWidth,a=this.lineJoin;this.pdf.addPage(),this.fillStyle=t,this.strokeStyle=e,this.font=r,this.lineCap=n,this.lineWidth=i,this.lineJoin=a;},N=function(t,e,r){for(var n=0;n<t.length;n++)switch(t[n].type){case"bct":t[n].x2+=e,t[n].y2+=r;case"qct":t[n].x1+=e,t[n].y1+=r;case"mt":case"lt":case"arc":default:t[n].x+=e,t[n].y+=r;}return t},L=function(t){return t.sort((function(t,e){return t-e}))},A=function(t,e){for(var r,n,i=this.fillStyle,a=this.strokeStyle,o=this.lineCap,s=this.lineWidth,c=Math.abs(s*this.ctx.transform.scaleX),u=this.lineJoin,h=JSON.parse(JSON.stringify(this.path)),l=JSON.parse(JSON.stringify(this.path)),f=[],d=0;d<l.length;d++)if(void 0!==l[d].x)for(var p=y.call(this,l[d]),g=0;g<p.length;g+=1)-1===f.indexOf(p[g])&&f.push(p[g]);for(var m=0;m<f.length;m++)for(;this.pdf.internal.getNumberOfPages()<f[m];)w.call(this);if(L(f),this.autoPaging)for(var v=f[0],A=f[f.length-1],S=v;S<A+1;S++){this.pdf.setPage(S),this.fillStyle=i,this.strokeStyle=a,this.lineCap=o,this.lineWidth=c,this.lineJoin=u;var _=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],P=1===S?this.posY+this.margin[0]:this.margin[0],k=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],I=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],F=1===S?0:k+(S-2)*I;if(0!==this.ctx.clip_path.length){var C=this.path;r=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(r,this.posX+this.margin[3],-F+P+this.ctx.prevPageLastElemOffset),x.call(this,t,!0),this.path=C;}if(n=JSON.parse(JSON.stringify(h)),this.path=N(n,this.posX+this.margin[3],-F+P+this.ctx.prevPageLastElemOffset),!1===e||0===S){var j=(S>v||S<A)&&b.call(this);j&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],_,I,null).clip().discardPath()),x.call(this,t,e),j&&this.pdf.restoreGraphicsState();}this.lineWidth=s;}else this.lineWidth=c,x.call(this,t,e),this.lineWidth=s;this.path=h;},x=function(t,e){if(("stroke"!==t||e||!v.call(this))&&("stroke"===t||e||!m.call(this))){for(var r,n,i=[],a=this.path,o=0;o<a.length;o++){var s=a[o];switch(s.type){case"begin":i.push({begin:!0});break;case"close":i.push({close:!0});break;case"mt":i.push({start:s,deltas:[],abs:[]});break;case"lt":var c=i.length;if(a[o-1]&&!isNaN(a[o-1].x)&&(r=[s.x-a[o-1].x,s.y-a[o-1].y],c>0))for(;c>=0;c--)if(!0!==i[c-1].close&&!0!==i[c-1].begin){i[c-1].deltas.push(r),i[c-1].abs.push(s);break}break;case"bct":r=[s.x1-a[o-1].x,s.y1-a[o-1].y,s.x2-a[o-1].x,s.y2-a[o-1].y,s.x-a[o-1].x,s.y-a[o-1].y],i[i.length-1].deltas.push(r);break;case"qct":var u=a[o-1].x+2/3*(s.x1-a[o-1].x),h=a[o-1].y+2/3*(s.y1-a[o-1].y),l=s.x+2/3*(s.x1-s.x),f=s.y+2/3*(s.y1-s.y),d=s.x,p=s.y;r=[u-a[o-1].x,h-a[o-1].y,l-a[o-1].x,f-a[o-1].y,d-a[o-1].x,p-a[o-1].y],i[i.length-1].deltas.push(r);break;case"arc":i.push({deltas:[],abs:[],arc:!0}),Array.isArray(i[i.length-1].abs)&&i[i.length-1].abs.push(s);}}n=e?null:"stroke"===t?"stroke":"fill";for(var g=!1,b=0;b<i.length;b++)if(i[b].arc)for(var y=i[b].abs,w=0;w<y.length;w++){var N=y[w];"arc"===N.type?P.call(this,N.x,N.y,N.radius,N.startAngle,N.endAngle,N.counterclockwise,void 0,e,!g):j.call(this,N.x,N.y),g=!0;}else if(!0===i[b].close)this.pdf.internal.out("h"),g=!1;else if(!0!==i[b].begin){var L=i[b].start.x,A=i[b].start.y;O.call(this,i[b].deltas,L,A),g=!0;}n&&k.call(this,n),e&&I.call(this);}},S=function(t){var e=this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor,r=e*(this.pdf.internal.getLineHeightFactor()-1);switch(this.ctx.textBaseline){case"bottom":return t-r;case"top":return t+e-r;case"hanging":return t+e-2*r;case"middle":return t+e/2-r;case"ideographic":return t;case"alphabetic":default:return t}},_=function(t){return t+this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor*(this.pdf.internal.getLineHeightFactor()-1)};p.prototype.createLinearGradient=function(){var t=function(){};return t.colorStops=[],t.addColorStop=function(t,e){this.colorStops.push([t,e]);},t.getColor=function(){return 0===this.colorStops.length?"#000000":this.colorStops[0][1]},t.isCanvasGradient=!0,t},p.prototype.createPattern=function(){return this.createLinearGradient()},p.prototype.createRadialGradient=function(){return this.createLinearGradient()};var P=function(t,e,r,n,i,a,o,s,c){for(var u=M.call(this,r,n,i,a),h=0;h<u.length;h++){var l=u[h];0===h&&(c?F.call(this,l.x1+t,l.y1+e):j.call(this,l.x1+t,l.y1+e)),B.call(this,t,e,l.x2,l.y2,l.x3,l.y3,l.x4,l.y4);}s?I.call(this):k.call(this,o);},k=function(t){switch(t){case"stroke":this.pdf.internal.out("S");break;case"fill":this.pdf.internal.out("f");}},I=function(){this.pdf.clip(),this.pdf.discardPath();},F=function(t,e){this.pdf.internal.out(n(t)+" "+i(e)+" m");},C=function(t){var e;switch(t.align){case"right":case"end":e="right";break;case"center":e="center";break;case"left":case"start":default:e="left";}var r=this.pdf.getTextDimensions(t.text),n=S.call(this,t.y),i=_.call(this,n)-r.h,a=this.ctx.transform.applyToPoint(new c(t.x,n)),o=this.ctx.transform.decompose(),s=new h;s=(s=(s=s.multiply(o.translate)).multiply(o.skew)).multiply(o.scale);for(var l,f,d,p=this.ctx.transform.applyToRectangle(new u(t.x,n,r.w,r.h)),g=s.applyToRectangle(new u(t.x,i,r.w,r.h)),m=y.call(this,g),v=[],w=0;w<m.length;w+=1)-1===v.indexOf(m[w])&&v.push(m[w]);if(L(v),this.autoPaging)for(var A=v[0],P=v[v.length-1],k=A;k<P+1;k++){this.pdf.setPage(k);var I=1===k?this.posY+this.margin[0]:this.margin[0],F=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],C=this.pdf.internal.pageSize.height-this.margin[2],j=C-this.margin[0],O=this.pdf.internal.pageSize.width-this.margin[1],B=O-this.margin[3],M=1===k?0:F+(k-2)*j;if(0!==this.ctx.clip_path.length){var E=this.path;l=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(l,this.posX+this.margin[3],-1*M+I),x.call(this,"fill",!0),this.path=E;}var q=N([JSON.parse(JSON.stringify(g))],this.posX+this.margin[3],-M+I+this.ctx.prevPageLastElemOffset)[0];t.scale>=.01&&(f=this.pdf.internal.getFontSize(),this.pdf.setFontSize(f*t.scale),d=this.lineWidth,this.lineWidth=d*t.scale);var D="text"!==this.autoPaging;if(D||q.y+q.h<=C){if(D||q.y>=I&&q.x<=O){var R=D?t.text:this.pdf.splitTextToSize(t.text,t.maxWidth||O-q.x)[0],T=N([JSON.parse(JSON.stringify(p))],this.posX+this.margin[3],-M+I+this.ctx.prevPageLastElemOffset)[0],U=D&&(k>A||k<P)&&b.call(this);U&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],B,j,null).clip().discardPath()),this.pdf.text(R,T.x,T.y,{angle:t.angle,align:e,renderingMode:t.renderingMode}),U&&this.pdf.restoreGraphicsState();}}else q.y<C&&(this.ctx.prevPageLastElemOffset+=C-q.y);t.scale>=.01&&(this.pdf.setFontSize(f),this.lineWidth=d);}else t.scale>=.01&&(f=this.pdf.internal.getFontSize(),this.pdf.setFontSize(f*t.scale),d=this.lineWidth,this.lineWidth=d*t.scale),this.pdf.text(t.text,a.x+this.posX,a.y+this.posY,{angle:t.angle,align:e,renderingMode:t.renderingMode,maxWidth:t.maxWidth}),t.scale>=.01&&(this.pdf.setFontSize(f),this.lineWidth=d);},j=function(t,e,r,a){r=r||0,a=a||0,this.pdf.internal.out(n(t+r)+" "+i(e+a)+" l");},O=function(t,e,r){return this.pdf.lines(t,e,r,null,null)},B=function(t,e,n,i,a,c,u,h){this.pdf.internal.out([r(o(n+t)),r(s(i+e)),r(o(a+t)),r(s(c+e)),r(o(u+t)),r(s(h+e)),"c"].join(" "));},M=function(t,e,r,n){for(var i=2*Math.PI,a=Math.PI/2;e>r;)e-=i;var o=Math.abs(r-e);o<i&&n&&(o=i-o);for(var s=[],c=n?-1:1,u=e;o>1e-5;){var h=u+c*Math.min(o,a);s.push(E.call(this,t,u,h)),o-=Math.abs(h-u),u=h;}return s},E=function(t,e,r){var n=(r-e)/2,i=t*Math.cos(n),a=t*Math.sin(n),o=i,s=-a,c=o*o+s*s,u=c+o*i+s*a,h=4/3*(Math.sqrt(2*c*u)-u)/(o*a-s*i),l=o-h*s,f=s+h*o,d=l,p=-f,g=n+e,m=Math.cos(g),v=Math.sin(g);return {x1:t*Math.cos(e),y1:t*Math.sin(e),x2:l*m-f*v,y2:l*v+f*m,x3:d*m-p*v,y3:d*v+p*m,x4:t*Math.cos(r),y4:t*Math.sin(r)}},q=function(t){return 180*t/Math.PI},D=function(t,e,r,n,i,a){var o=t+.5*(r-t),s=e+.5*(n-e),c=i+.5*(r-i),h=a+.5*(n-a),l=Math.min(t,i,o,c),f=Math.max(t,i,o,c),d=Math.min(e,a,s,h),p=Math.max(e,a,s,h);return new u(l,d,f-l,p-d)},R=function(t,e,r,n,i,a,o,s){var c,h,l,f,d,p,g,m,v,b,y,w,N,L,A=r-t,x=n-e,S=i-r,_=a-n,P=o-i,k=s-a;for(h=0;h<41;h++)v=(g=(l=t+(c=h/40)*A)+c*((d=r+c*S)-l))+c*(d+c*(i+c*P-d)-g),b=(m=(f=e+c*x)+c*((p=n+c*_)-f))+c*(p+c*(a+c*k-p)-m),0==h?(y=v,w=b,N=v,L=b):(y=Math.min(y,v),w=Math.min(w,b),N=Math.max(N,v),L=Math.max(L,b));return new u(Math.round(y),Math.round(w),Math.round(N-y),Math.round(L-w))},T=function(){if(this.prevLineDash||this.ctx.lineDash.length||this.ctx.lineDashOffset){var t,e,r=(t=this.ctx.lineDash,e=this.ctx.lineDashOffset,JSON.stringify({lineDash:t,lineDashOffset:e}));this.prevLineDash!==r&&(this.pdf.setLineDash(this.ctx.lineDash,this.ctx.lineDashOffset),this.prevLineDash=r);}};}(E$1.API),
  /**
   * @license
   * jsPDF filters PlugIn
   * Copyright (c) 2014 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var r=function(t){var e,r,n,i,a,o,s,c,u,h;for(/[^\x00-\xFF]/.test(t),r=[],n=0,i=(t+=e="\0\0\0\0".slice(t.length%4||4)).length;i>n;n+=4)0!==(a=(t.charCodeAt(n)<<24)+(t.charCodeAt(n+1)<<16)+(t.charCodeAt(n+2)<<8)+t.charCodeAt(n+3))?(o=(a=((a=((a=((a=(a-(h=a%85))/85)-(u=a%85))/85)-(c=a%85))/85)-(s=a%85))/85)%85,r.push(o+33,s+33,c+33,u+33,h+33)):r.push(122);return function(t,e){for(var r=e;r>0;r--)t.pop();}(r,e.length),String.fromCharCode.apply(String,r)+"~>"},n=function(t){var e,r,n,i,a,o=String,s="length",c=255,u="charCodeAt",h="slice",l="replace";for(t[h](-2),t=t[h](0,-2)[l](/\s/g,"")[l]("z","!!!!!"),n=[],i=0,a=(t+=e="uuuuu"[h](t[s]%5||5))[s];a>i;i+=5)r=52200625*(t[u](i)-33)+614125*(t[u](i+1)-33)+7225*(t[u](i+2)-33)+85*(t[u](i+3)-33)+(t[u](i+4)-33),n.push(c&r>>24,c&r>>16,c&r>>8,c&r);return function(t,e){for(var r=e;r>0;r--)t.pop();}(n,e[s]),o.fromCharCode.apply(o,n)},i=function(t){var e=new RegExp(/^([0-9A-Fa-f]{2})+$/);if(-1!==(t=t.replace(/\s/g,"")).indexOf(">")&&(t=t.substr(0,t.indexOf(">"))),t.length%2&&(t+="0"),!1===e.test(t))return "";for(var r="",n=0;n<t.length;n+=2)r+=String.fromCharCode("0x"+(t[n]+t[n+1]));return r},a=function(t){for(var r=new Uint8Array(t.length),n=t.length;n--;)r[n]=t.charCodeAt(n);return t=(r=zlibSync(r)).reduce((function(t,e){return t+String.fromCharCode(e)}),"")};t.processDataByFilters=function(t,e){var o=0,s=t||"",c=[];for("string"==typeof(e=e||[])&&(e=[e]),o=0;o<e.length;o+=1)switch(e[o]){case"ASCII85Decode":case"/ASCII85Decode":s=n(s),c.push("/ASCII85Encode");break;case"ASCII85Encode":case"/ASCII85Encode":s=r(s),c.push("/ASCII85Decode");break;case"ASCIIHexDecode":case"/ASCIIHexDecode":s=i(s),c.push("/ASCIIHexEncode");break;case"ASCIIHexEncode":case"/ASCIIHexEncode":s=s.split("").map((function(t){return ("0"+t.charCodeAt().toString(16)).slice(-2)})).join("")+">",c.push("/ASCIIHexDecode");break;case"FlateEncode":case"/FlateEncode":s=a(s),c.push("/FlateDecode");break;default:throw new Error('The filter: "'+e[o]+'" is not implemented')}return {data:s,reverseChain:c.reverse().join(" ")}};}(E$1.API),
  /**
   * @license
   * jsPDF fileloading PlugIn
   * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.loadFile=function(t,e,r){return function(t,e,r){e=!1!==e,r="function"==typeof r?r:function(){};var n=void 0;try{n=function(t,e,r){var n=new XMLHttpRequest,i=0,a=function(t){var e=t.length,r=[],n=String.fromCharCode;for(i=0;i<e;i+=1)r.push(n(255&t.charCodeAt(i)));return r.join("")};if(n.open("GET",t,!e),n.overrideMimeType("text/plain; charset=x-user-defined"),!1===e&&(n.onload=function(){200===n.status?r(a(this.responseText)):r(void 0);}),n.send(null),e&&200===n.status)return a(n.responseText)}(t,e,r);}catch(t){}return n}(t,e,r)},t.loadImageFile=t.loadFile;}(E$1.API),function(e){function r(){return (n$1.html2canvas?Promise.resolve(n$1.html2canvas):Promise.resolve().then(function () { return html2canvas_esm; })).catch((function(t){return Promise.reject(new Error("Could not load html2canvas: "+t))})).then((function(t){return t.default?t.default:t}))}function i(){return (n$1.DOMPurify?Promise.resolve(n$1.DOMPurify):Promise.resolve().then(function () { return purify_es; })).catch((function(t){return Promise.reject(new Error("Could not load dompurify: "+t))})).then((function(t){return t.default?t.default:t}))}var a=function(e){var r=_typeof$2(e);return "undefined"===r?"undefined":"string"===r||e instanceof String?"string":"number"===r||e instanceof Number?"number":"function"===r||e instanceof Function?"function":e&&e.constructor===Array?"array":e&&1===e.nodeType?"element":"object"===r?"object":"unknown"},o=function(t,e){var r=document.createElement(t);for(var n in e.className&&(r.className=e.className),e.innerHTML&&e.dompurify&&(r.innerHTML=e.dompurify.sanitize(e.innerHTML)),e.style)r.style[n]=e.style[n];return r},s=function t(e){var r=Object.assign(t.convert(Promise.resolve()),JSON.parse(JSON.stringify(t.template))),n=t.convert(Promise.resolve(),r);return n=(n=n.setProgress(1,t,1,[t])).set(e)};(s.prototype=Object.create(Promise.prototype)).constructor=s,s.convert=function(t,e){return t.__proto__=e||s.prototype,t},s.template={prop:{src:null,container:null,overlay:null,canvas:null,img:null,pdf:null,pageSize:null,callback:function(){}},progress:{val:0,state:null,n:0,stack:[]},opt:{filename:"file.pdf",margin:[0,0,0,0],enableLinks:!0,x:0,y:0,html2canvas:{},jsPDF:{},backgroundColor:"transparent"}},s.prototype.from=function(t,e){return this.then((function(){switch(e=e||function(t){switch(a(t)){case"string":return "string";case"element":return "canvas"===t.nodeName.toLowerCase()?"canvas":"element";default:return "unknown"}}(t)){case"string":return this.then(i).then((function(e){return this.set({src:o("div",{innerHTML:t,dompurify:e})})}));case"element":return this.set({src:t});case"canvas":return this.set({canvas:t});case"img":return this.set({img:t});default:return this.error("Unknown source type.")}}))},s.prototype.to=function(t){switch(t){case"container":return this.toContainer();case"canvas":return this.toCanvas();case"img":return this.toImg();case"pdf":return this.toPdf();default:return this.error("Invalid target.")}},s.prototype.toContainer=function(){return this.thenList([function(){return this.prop.src||this.error("Cannot duplicate - no source HTML.")},function(){return this.prop.pageSize||this.setPageSize()}]).then((function(){var t={position:"relative",display:"inline-block",width:("number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?Math.max(this.prop.src.clientWidth,this.prop.src.scrollWidth,this.prop.src.offsetWidth):this.opt.windowWidth)+"px",left:0,right:0,top:0,margin:"auto",backgroundColor:this.opt.backgroundColor},e=function t(e,r){for(var n=3===e.nodeType?document.createTextNode(e.nodeValue):e.cloneNode(!1),i=e.firstChild;i;i=i.nextSibling)!0!==r&&1===i.nodeType&&"SCRIPT"===i.nodeName||n.appendChild(t(i,r));return 1===e.nodeType&&("CANVAS"===e.nodeName?(n.width=e.width,n.height=e.height,n.getContext("2d").drawImage(e,0,0)):"TEXTAREA"!==e.nodeName&&"SELECT"!==e.nodeName||(n.value=e.value),n.addEventListener("load",(function(){n.scrollTop=e.scrollTop,n.scrollLeft=e.scrollLeft;}),!0)),n}(this.prop.src,this.opt.html2canvas.javascriptEnabled);"BODY"===e.tagName&&(t.height=Math.max(document.body.scrollHeight,document.body.offsetHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight)+"px"),this.prop.overlay=o("div",{className:"html2pdf__overlay",style:{position:"fixed",overflow:"hidden",zIndex:1e3,left:"-100000px",right:0,bottom:0,top:0}}),this.prop.container=o("div",{className:"html2pdf__container",style:t}),this.prop.container.appendChild(e),this.prop.container.firstChild.appendChild(o("div",{style:{clear:"both",border:"0 none transparent",margin:0,padding:0,height:0}})),this.prop.container.style.float="none",this.prop.overlay.appendChild(this.prop.container),document.body.appendChild(this.prop.overlay),this.prop.container.firstChild.style.position="relative",this.prop.container.height=Math.max(this.prop.container.firstChild.clientHeight,this.prop.container.firstChild.scrollHeight,this.prop.container.firstChild.offsetHeight)+"px";}))},s.prototype.toCanvas=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(r).then((function(t){var e=Object.assign({},this.opt.html2canvas);return delete e.onrendered,t(this.prop.container,e)})).then((function(t){(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);}))},s.prototype.toContext2d=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(r).then((function(t){var e=this.opt.jsPDF,r=this.opt.fontFaces,n="number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?1:this.opt.width/this.opt.windowWidth,i=Object.assign({async:!0,allowTaint:!0,scale:n,scrollX:this.opt.scrollX||0,scrollY:this.opt.scrollY||0,backgroundColor:"#ffffff",imageTimeout:15e3,logging:!0,proxy:null,removeContainer:!0,foreignObjectRendering:!1,useCORS:!1},this.opt.html2canvas);if(delete i.onrendered,e.context2d.autoPaging=void 0===this.opt.autoPaging||this.opt.autoPaging,e.context2d.posX=this.opt.x,e.context2d.posY=this.opt.y,e.context2d.margin=this.opt.margin,e.context2d.fontFaces=r,r)for(var a=0;a<r.length;++a){var o=r[a],s=o.src.find((function(t){return "truetype"===t.format}));s&&e.addFont(s.url,o.ref.name,o.ref.style);}return i.windowHeight=i.windowHeight||0,i.windowHeight=0==i.windowHeight?Math.max(this.prop.container.clientHeight,this.prop.container.scrollHeight,this.prop.container.offsetHeight):i.windowHeight,e.context2d.save(!0),t(this.prop.container,i)})).then((function(t){this.opt.jsPDF.context2d.restore(!0),(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);}))},s.prototype.toImg=function(){return this.thenList([function(){return this.prop.canvas||this.toCanvas()}]).then((function(){var t=this.prop.canvas.toDataURL("image/"+this.opt.image.type,this.opt.image.quality);this.prop.img=document.createElement("img"),this.prop.img.src=t;}))},s.prototype.toPdf=function(){return this.thenList([function(){return this.toContext2d()}]).then((function(){this.prop.pdf=this.prop.pdf||this.opt.jsPDF;}))},s.prototype.output=function(t,e,r){return "img"===(r=r||"pdf").toLowerCase()||"image"===r.toLowerCase()?this.outputImg(t,e):this.outputPdf(t,e)},s.prototype.outputPdf=function(t,e){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then((function(){return this.prop.pdf.output(t,e)}))},s.prototype.outputImg=function(t){return this.thenList([function(){return this.prop.img||this.toImg()}]).then((function(){switch(t){case void 0:case"img":return this.prop.img;case"datauristring":case"dataurlstring":return this.prop.img.src;case"datauri":case"dataurl":return document.location.href=this.prop.img.src;default:throw 'Image output type "'+t+'" is not supported.'}}))},s.prototype.save=function(t){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).set(t?{filename:t}:null).then((function(){this.prop.pdf.save(this.opt.filename);}))},s.prototype.doCallback=function(){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then((function(){this.prop.callback(this.prop.pdf);}))},s.prototype.set=function(t){if("object"!==a(t))return this;var e=Object.keys(t||{}).map((function(e){if(e in s.template.prop)return function(){this.prop[e]=t[e];};switch(e){case"margin":return this.setMargin.bind(this,t.margin);case"jsPDF":return function(){return this.opt.jsPDF=t.jsPDF,this.setPageSize()};case"pageSize":return this.setPageSize.bind(this,t.pageSize);default:return function(){this.opt[e]=t[e];}}}),this);return this.then((function(){return this.thenList(e)}))},s.prototype.get=function(t,e){return this.then((function(){var r=t in s.template.prop?this.prop[t]:this.opt[t];return e?e(r):r}))},s.prototype.setMargin=function(t){return this.then((function(){switch(a(t)){case"number":t=[t,t,t,t];case"array":if(2===t.length&&(t=[t[0],t[1],t[0],t[1]]),4===t.length)break;default:return this.error("Invalid margin array.")}this.opt.margin=t;})).then(this.setPageSize)},s.prototype.setPageSize=function(t){function e(t,e){return Math.floor(t*e/72*96)}return this.then((function(){(t=t||E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner")||(t.inner={width:t.width-this.opt.margin[1]-this.opt.margin[3],height:t.height-this.opt.margin[0]-this.opt.margin[2]},t.inner.px={width:e(t.inner.width,t.k),height:e(t.inner.height,t.k)},t.inner.ratio=t.inner.height/t.inner.width),this.prop.pageSize=t;}))},s.prototype.setProgress=function(t,e,r,n){return null!=t&&(this.progress.val=t),null!=e&&(this.progress.state=e),null!=r&&(this.progress.n=r),null!=n&&(this.progress.stack=n),this.progress.ratio=this.progress.val/this.progress.state,this},s.prototype.updateProgress=function(t,e,r,n){return this.setProgress(t?this.progress.val+t:null,e||null,r?this.progress.n+r:null,n?this.progress.stack.concat(n):null)},s.prototype.then=function(t,e){var r=this;return this.thenCore(t,e,(function(t,e){return r.updateProgress(null,null,1,[t]),Promise.prototype.then.call(this,(function(e){return r.updateProgress(null,t),e})).then(t,e).then((function(t){return r.updateProgress(1),t}))}))},s.prototype.thenCore=function(t,e,r){r=r||Promise.prototype.then;t&&(t=t.bind(this)),e&&(e=e.bind(this));var n=-1!==Promise.toString().indexOf("[native code]")&&"Promise"===Promise.name?this:s.convert(Object.assign({},this),Promise.prototype),i=r.call(n,t,e);return s.convert(i,this.__proto__)},s.prototype.thenExternal=function(t,e){return Promise.prototype.then.call(this,t,e)},s.prototype.thenList=function(t){var e=this;return t.forEach((function(t){e=e.thenCore(t);})),e},s.prototype.catch=function(t){t&&(t=t.bind(this));var e=Promise.prototype.catch.call(this,t);return s.convert(e,this)},s.prototype.catchExternal=function(t){return Promise.prototype.catch.call(this,t)},s.prototype.error=function(t){return this.then((function(){throw new Error(t)}))},s.prototype.using=s.prototype.set,s.prototype.saveAs=s.prototype.save,s.prototype.export=s.prototype.output,s.prototype.run=s.prototype.then,E$1.getPageSize=function(e,r,n){if("object"===_typeof$2(e)){var i=e;e=i.orientation,r=i.unit||r,n=i.format||n;}r=r||"mm",n=n||"a4",e=(""+(e||"P")).toLowerCase();var a,o=(""+n).toLowerCase(),s={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};switch(r){case"pt":a=1;break;case"mm":a=72/25.4;break;case"cm":a=72/2.54;break;case"in":a=72;break;case"px":a=.75;break;case"pc":case"em":a=12;break;case"ex":a=6;break;default:throw "Invalid unit: "+r}var c,u=0,h=0;if(s.hasOwnProperty(o))u=s[o][1]/a,h=s[o][0]/a;else try{u=n[1],h=n[0];}catch(t){throw new Error("Invalid format: "+n)}if("p"===e||"portrait"===e)e="p",h>u&&(c=h,h=u,u=c);else {if("l"!==e&&"landscape"!==e)throw "Invalid orientation: "+e;e="l",u>h&&(c=h,h=u,u=c);}return {width:h,height:u,unit:r,k:a,orientation:e}},e.html=function(t,e){(e=e||{}).callback=e.callback||function(){},e.html2canvas=e.html2canvas||{},e.html2canvas.canvas=e.html2canvas.canvas||this.canvas,e.jsPDF=e.jsPDF||this,e.fontFaces=e.fontFaces?e.fontFaces.map(jt):null;var r=new s(e);return e.worker?r:r.from(t).doCallback()};}(E$1.API),E$1.API.addJS=function(t){return Ht=t,this.internal.events.subscribe("postPutResources",(function(){Ut=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/Names [(EmbeddedJS) "+(Ut+1)+" 0 R]"),this.internal.out(">>"),this.internal.out("endobj"),zt=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /JavaScript"),this.internal.out("/JS ("+Ht+")"),this.internal.out(">>"),this.internal.out("endobj");})),this.internal.events.subscribe("putCatalog",(function(){void 0!==Ut&&void 0!==zt&&this.internal.out("/Names <</JavaScript "+Ut+" 0 R>>");})),this},
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e;t.events.push(["postPutResources",function(){var t=this,r=/^(\d+) 0 obj$/;if(this.outline.root.children.length>0)for(var n=t.outline.render().split(/\r\n/),i=0;i<n.length;i++){var a=n[i],o=r.exec(a);if(null!=o){var s=o[1];t.internal.newObjectDeferredBegin(s,!1);}t.internal.write(a);}if(this.outline.createNamedDestinations){var c=this.internal.pages.length,u=[];for(i=0;i<c;i++){var h=t.internal.newObject();u.push(h);var l=t.internal.getPageInfo(i+1);t.internal.write("<< /D["+l.objId+" 0 R /XYZ null null null]>> endobj");}var f=t.internal.newObject();t.internal.write("<< /Names [ ");for(i=0;i<u.length;i++)t.internal.write("(page_"+(i+1)+")"+u[i]+" 0 R");t.internal.write(" ] >>","endobj"),e=t.internal.newObject(),t.internal.write("<< /Dests "+f+" 0 R"),t.internal.write(">>","endobj");}}]),t.events.push(["putCatalog",function(){this.outline.root.children.length>0&&(this.internal.write("/Outlines",this.outline.makeRef(this.outline.root)),this.outline.createNamedDestinations&&this.internal.write("/Names "+e+" 0 R"));}]),t.events.push(["initialized",function(){var t=this;t.outline={createNamedDestinations:!1,root:{children:[]}},t.outline.add=function(t,e,r){var n={title:e,options:r,children:[]};return null==t&&(t=this.root),t.children.push(n),n},t.outline.render=function(){return this.ctx={},this.ctx.val="",this.ctx.pdf=t,this.genIds_r(this.root),this.renderRoot(this.root),this.renderItems(this.root),this.ctx.val},t.outline.genIds_r=function(e){e.id=t.internal.newObjectDeferred();for(var r=0;r<e.children.length;r++)this.genIds_r(e.children[r]);},t.outline.renderRoot=function(t){this.objStart(t),this.line("/Type /Outlines"),t.children.length>0&&(this.line("/First "+this.makeRef(t.children[0])),this.line("/Last "+this.makeRef(t.children[t.children.length-1]))),this.line("/Count "+this.count_r({count:0},t)),this.objEnd();},t.outline.renderItems=function(e){for(var r=this.ctx.pdf.internal.getVerticalCoordinateString,n=0;n<e.children.length;n++){var i=e.children[n];this.objStart(i),this.line("/Title "+this.makeString(i.title)),this.line("/Parent "+this.makeRef(e)),n>0&&this.line("/Prev "+this.makeRef(e.children[n-1])),n<e.children.length-1&&this.line("/Next "+this.makeRef(e.children[n+1])),i.children.length>0&&(this.line("/First "+this.makeRef(i.children[0])),this.line("/Last "+this.makeRef(i.children[i.children.length-1])));var a=this.count=this.count_r({count:0},i);if(a>0&&this.line("/Count "+a),i.options&&i.options.pageNumber){var o=t.internal.getPageInfo(i.options.pageNumber);this.line("/Dest ["+o.objId+" 0 R /XYZ 0 "+r(0)+" 0]");}this.objEnd();}for(var s=0;s<e.children.length;s++)this.renderItems(e.children[s]);},t.outline.line=function(t){this.ctx.val+=t+"\r\n";},t.outline.makeRef=function(t){return t.id+" 0 R"},t.outline.makeString=function(e){return "("+t.internal.pdfEscape(e)+")"},t.outline.objStart=function(t){this.ctx.val+="\r\n"+t.id+" 0 obj\r\n<<\r\n";},t.outline.objEnd=function(){this.ctx.val+=">> \r\nendobj\r\n";},t.outline.count_r=function(t,e){for(var r=0;r<e.children.length;r++)t.count++,this.count_r(t,e.children[r]);return t.count};}]);}(E$1.API),
  /**
   * @license
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=[192,193,194,195,196,197,198,199];t.processJPEG=function(t,r,n,i,a,o){var s,c=this.decode.DCT_DECODE,u=null;if("string"==typeof t||this.__addimage__.isArrayBuffer(t)||this.__addimage__.isArrayBufferView(t)){switch(t=a||t,t=this.__addimage__.isArrayBuffer(t)?new Uint8Array(t):t,(s=function(t){for(var r,n=256*t.charCodeAt(4)+t.charCodeAt(5),i=t.length,a={width:0,height:0,numcomponents:1},o=4;o<i;o+=2){if(o+=n,-1!==e.indexOf(t.charCodeAt(o+1))){r=256*t.charCodeAt(o+5)+t.charCodeAt(o+6),a={width:256*t.charCodeAt(o+7)+t.charCodeAt(o+8),height:r,numcomponents:t.charCodeAt(o+9)};break}n=256*t.charCodeAt(o+2)+t.charCodeAt(o+3);}return a}(t=this.__addimage__.isArrayBufferView(t)?this.__addimage__.arrayBufferToBinaryString(t):t)).numcomponents){case 1:o=this.color_spaces.DEVICE_GRAY;break;case 4:o=this.color_spaces.DEVICE_CMYK;break;case 3:o=this.color_spaces.DEVICE_RGB;}u={data:t,width:s.width,height:s.height,colorSpace:o,bitsPerComponent:8,filter:c,index:r,alias:n};}return u};}(E$1.API);var Vt,Gt$1,Yt,Jt,Xt,Kt=function(){var t,e,i;function a(t){var e,r,n,i,a,o,s,c,u,h,l,f,d,p;for(this.data=t,this.pos=8,this.palette=[],this.imgData=[],this.transparency={},this.animation=null,this.text={},o=null;;){switch(e=this.readUInt32(),u=function(){var t,e;for(e=[],t=0;t<4;++t)e.push(String.fromCharCode(this.data[this.pos++]));return e}.call(this).join("")){case"IHDR":this.width=this.readUInt32(),this.height=this.readUInt32(),this.bits=this.data[this.pos++],this.colorType=this.data[this.pos++],this.compressionMethod=this.data[this.pos++],this.filterMethod=this.data[this.pos++],this.interlaceMethod=this.data[this.pos++];break;case"acTL":this.animation={numFrames:this.readUInt32(),numPlays:this.readUInt32()||1/0,frames:[]};break;case"PLTE":this.palette=this.read(e);break;case"fcTL":o&&this.animation.frames.push(o),this.pos+=4,o={width:this.readUInt32(),height:this.readUInt32(),xOffset:this.readUInt32(),yOffset:this.readUInt32()},a=this.readUInt16(),i=this.readUInt16()||100,o.delay=1e3*a/i,o.disposeOp=this.data[this.pos++],o.blendOp=this.data[this.pos++],o.data=[];break;case"IDAT":case"fdAT":for("fdAT"===u&&(this.pos+=4,e-=4),t=(null!=o?o.data:void 0)||this.imgData,f=0;0<=e?f<e:f>e;0<=e?++f:--f)t.push(this.data[this.pos++]);break;case"tRNS":switch(this.transparency={},this.colorType){case 3:if(n=this.palette.length/3,this.transparency.indexed=this.read(e),this.transparency.indexed.length>n)throw new Error("More transparent colors than palette size");if((h=n-this.transparency.indexed.length)>0)for(d=0;0<=h?d<h:d>h;0<=h?++d:--d)this.transparency.indexed.push(255);break;case 0:this.transparency.grayscale=this.read(e)[0];break;case 2:this.transparency.rgb=this.read(e);}break;case"tEXt":s=(l=this.read(e)).indexOf(0),c=String.fromCharCode.apply(String,l.slice(0,s)),this.text[c]=String.fromCharCode.apply(String,l.slice(s+1));break;case"IEND":return o&&this.animation.frames.push(o),this.colors=function(){switch(this.colorType){case 0:case 3:case 4:return 1;case 2:case 6:return 3}}.call(this),this.hasAlphaChannel=4===(p=this.colorType)||6===p,r=this.colors+(this.hasAlphaChannel?1:0),this.pixelBitlength=this.bits*r,this.colorSpace=function(){switch(this.colors){case 1:return "DeviceGray";case 3:return "DeviceRGB"}}.call(this),void(this.imgData=new Uint8Array(this.imgData));default:this.pos+=e;}if(this.pos+=4,this.pos>this.data.length)throw new Error("Incomplete or corrupt PNG file")}}a.prototype.read=function(t){var e,r;for(r=[],e=0;0<=t?e<t:e>t;0<=t?++e:--e)r.push(this.data[this.pos++]);return r},a.prototype.readUInt32=function(){return this.data[this.pos++]<<24|this.data[this.pos++]<<16|this.data[this.pos++]<<8|this.data[this.pos++]},a.prototype.readUInt16=function(){return this.data[this.pos++]<<8|this.data[this.pos++]},a.prototype.decodePixels=function(t){var e=this.pixelBitlength/8,n=new Uint8Array(this.width*this.height*e),i=0,a=this;if(null==t&&(t=this.imgData),0===t.length)return new Uint8Array(0);function o(r,o,s,c){var u,h,l,f,d,p,g,m,v,b,y,w,N,L,A,x,S,_,P,k,I,F=Math.ceil((a.width-r)/s),C=Math.ceil((a.height-o)/c),j=a.width==F&&a.height==C;for(L=e*F,w=j?n:new Uint8Array(L*C),p=t.length,N=0,h=0;N<C&&i<p;){switch(t[i++]){case 0:for(f=S=0;S<L;f=S+=1)w[h++]=t[i++];break;case 1:for(f=_=0;_<L;f=_+=1)u=t[i++],d=f<e?0:w[h-e],w[h++]=(u+d)%256;break;case 2:for(f=P=0;P<L;f=P+=1)u=t[i++],l=(f-f%e)/e,A=N&&w[(N-1)*L+l*e+f%e],w[h++]=(A+u)%256;break;case 3:for(f=k=0;k<L;f=k+=1)u=t[i++],l=(f-f%e)/e,d=f<e?0:w[h-e],A=N&&w[(N-1)*L+l*e+f%e],w[h++]=(u+Math.floor((d+A)/2))%256;break;case 4:for(f=I=0;I<L;f=I+=1)u=t[i++],l=(f-f%e)/e,d=f<e?0:w[h-e],0===N?A=x=0:(A=w[(N-1)*L+l*e+f%e],x=l&&w[(N-1)*L+(l-1)*e+f%e]),g=d+A-x,m=Math.abs(g-d),b=Math.abs(g-A),y=Math.abs(g-x),v=m<=b&&m<=y?d:b<=y?A:x,w[h++]=(u+v)%256;break;default:throw new Error("Invalid filter algorithm: "+t[i-1])}if(!j){var O=((o+N*c)*a.width+r)*e,B=N*L;for(f=0;f<F;f+=1){for(var M=0;M<e;M+=1)n[O++]=w[B++];O+=(s-1)*e;}}N++;}}return t=unzlibSync(t),1==a.interlaceMethod?(o(0,0,8,8),o(4,0,8,8),o(0,4,4,8),o(2,0,4,4),o(0,2,2,4),o(1,0,2,2),o(0,1,1,2)):o(0,0,1,1),n},a.prototype.decodePalette=function(){var t,e,r,n,i,a,o,s,c;for(r=this.palette,a=this.transparency.indexed||[],i=new Uint8Array((a.length||0)+r.length),n=0,t=0,e=o=0,s=r.length;o<s;e=o+=3)i[n++]=r[e],i[n++]=r[e+1],i[n++]=r[e+2],i[n++]=null!=(c=a[t++])?c:255;return i},a.prototype.copyToImageData=function(t,e){var r,n,i,a,o,s,c,u,h,l,f;if(n=this.colors,h=null,r=this.hasAlphaChannel,this.palette.length&&(h=null!=(f=this._decodedPalette)?f:this._decodedPalette=this.decodePalette(),n=4,r=!0),u=(i=t.data||t).length,o=h||e,a=s=0,1===n)for(;a<u;)c=h?4*e[a/4]:s,l=o[c++],i[a++]=l,i[a++]=l,i[a++]=l,i[a++]=r?o[c++]:255,s=c;else for(;a<u;)c=h?4*e[a/4]:s,i[a++]=o[c++],i[a++]=o[c++],i[a++]=o[c++],i[a++]=r?o[c++]:255,s=c;},a.prototype.decode=function(){var t;return t=new Uint8Array(this.width*this.height*4),this.copyToImageData(t,this.decodePixels()),t};var o=function(){if("[object Window]"===Object.prototype.toString.call(n$1)){try{e=n$1.document.createElement("canvas"),i=e.getContext("2d");}catch(t){return !1}return !0}return !1};return o(),t=function(t){var r;if(!0===o())return i.width=t.width,i.height=t.height,i.clearRect(0,0,t.width,t.height),i.putImageData(t,0,0),(r=new Image).src=e.toDataURL(),r;throw new Error("This method requires a Browser with Canvas-capability.")},a.prototype.decodeFrames=function(e){var r,n,i,a,o,s,c,u;if(this.animation){for(u=[],n=o=0,s=(c=this.animation.frames).length;o<s;n=++o)r=c[n],i=e.createImageData(r.width,r.height),a=this.decodePixels(new Uint8Array(r.data)),this.copyToImageData(i,a),r.imageData=i,u.push(r.image=t(i));return u}},a.prototype.renderFrame=function(t,e){var r,n,i;return r=(n=this.animation.frames)[e],i=n[e-1],0===e&&t.clearRect(0,0,this.width,this.height),1===(null!=i?i.disposeOp:void 0)?t.clearRect(i.xOffset,i.yOffset,i.width,i.height):2===(null!=i?i.disposeOp:void 0)&&t.putImageData(i.imageData,i.xOffset,i.yOffset),0===r.blendOp&&t.clearRect(r.xOffset,r.yOffset,r.width,r.height),t.drawImage(r.image,r.xOffset,r.yOffset)},a.prototype.animate=function(t){var e,r,n,i,a,o,s=this;return r=0,o=this.animation,i=o.numFrames,n=o.frames,a=o.numPlays,(e=function(){var o,c;if(o=r++%i,c=n[o],s.renderFrame(t,o),i>1&&r/i<a)return s.animation._timeout=setTimeout(e,c.delay)})()},a.prototype.stopAnimation=function(){var t;return clearTimeout(null!=(t=this.animation)?t._timeout:void 0)},a.prototype.render=function(t){var e,r;return t._png&&t._png.stopAnimation(),t._png=this,t.width=this.width,t.height=this.height,e=t.getContext("2d"),this.animation?(this.decodeFrames(e),this.animate(e)):(r=e.createImageData(this.width,this.height),this.copyToImageData(r,this.decodePixels()),e.putImageData(r,0,0))},a}();
  /**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  /**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   */
  function Zt(t){var e=0;if(71!==t[e++]||73!==t[e++]||70!==t[e++]||56!==t[e++]||56!=(t[e++]+1&253)||97!==t[e++])throw new Error("Invalid GIF 87a/89a header.");var r=t[e++]|t[e++]<<8,n=t[e++]|t[e++]<<8,i=t[e++],a=i>>7,o=1<<(7&i)+1;t[e++];t[e++];var s=null,c=null;a&&(s=e,c=o,e+=3*o);var u=!0,h=[],l=0,f=null,d=0,p=null;for(this.width=r,this.height=n;u&&e<t.length;)switch(t[e++]){case 33:switch(t[e++]){case 255:if(11!==t[e]||78==t[e+1]&&69==t[e+2]&&84==t[e+3]&&83==t[e+4]&&67==t[e+5]&&65==t[e+6]&&80==t[e+7]&&69==t[e+8]&&50==t[e+9]&&46==t[e+10]&&48==t[e+11]&&3==t[e+12]&&1==t[e+13]&&0==t[e+16])e+=14,p=t[e++]|t[e++]<<8,e++;else for(e+=12;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;case 249:if(4!==t[e++]||0!==t[e+4])throw new Error("Invalid graphics extension block.");var g=t[e++];l=t[e++]|t[e++]<<8,f=t[e++],0==(1&g)&&(f=null),d=g>>2&7,e++;break;case 254:for(;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;default:throw new Error("Unknown graphic control label: 0x"+t[e-1].toString(16))}break;case 44:var m=t[e++]|t[e++]<<8,v=t[e++]|t[e++]<<8,b=t[e++]|t[e++]<<8,y=t[e++]|t[e++]<<8,w=t[e++],N=w>>6&1,L=1<<(7&w)+1,A=s,x=c,S=!1;if(w>>7){S=!0;A=e,x=L,e+=3*L;}var _=e;for(e++;;){var P;if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}h.push({x:m,y:v,width:b,height:y,has_local_palette:S,palette_offset:A,palette_size:x,data_offset:_,data_length:e-_,transparent_index:f,interlaced:!!N,delay:l,disposal:d});break;case 59:u=!1;break;default:throw new Error("Unknown gif block: 0x"+t[e-1].toString(16))}this.numFrames=function(){return h.length},this.loopCount=function(){return p},this.frameInfo=function(t){if(t<0||t>=h.length)throw new Error("Frame index out of range.");return h[t]},this.decodeAndBlitFrameBGRA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);$t(t,i.data_offset,o,a);var s=i.palette_offset,c=i.transparent_index;null===c&&(c=256);var u=i.width,h=r-u,l=u,f=4*(i.y*r+i.x),d=4*((i.y+i.height)*r+i.x),p=f,g=4*h;!0===i.interlaced&&(g+=4*r*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===l&&(l=u,(p+=g)>=d&&(g=4*h+4*r*(m-1),p=f+(u+h)*(m<<1),m>>=1)),y===c)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];n[p++]=L,n[p++]=N,n[p++]=w,n[p++]=255;}--l;}},this.decodeAndBlitFrameRGBA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);$t(t,i.data_offset,o,a);var s=i.palette_offset,c=i.transparent_index;null===c&&(c=256);var u=i.width,h=r-u,l=u,f=4*(i.y*r+i.x),d=4*((i.y+i.height)*r+i.x),p=f,g=4*h;!0===i.interlaced&&(g+=4*r*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===l&&(l=u,(p+=g)>=d&&(g=4*h+4*r*(m-1),p=f+(u+h)*(m<<1),m>>=1)),y===c)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];n[p++]=w,n[p++]=N,n[p++]=L,n[p++]=255;}--l;}};}function $t(t,e,r,n){for(var i=t[e++],o=1<<i,s=o+1,c=s+1,u=i+1,h=(1<<u)-1,l=0,f=0,d=0,p=t[e++],g=new Int32Array(4096),m=null;;){for(;l<16&&0!==p;)f|=t[e++]<<l,l+=8,1===p?p=t[e++]:--p;if(l<u)break;var v=f&h;if(f>>=u,l-=u,v!==o){if(v===s)break;for(var b=v<c?v:m,y=0,w=b;w>o;)w=g[w]>>8,++y;var N=w;if(d+y+(b!==v?1:0)>n)return void a$2.log("Warning, gif stream longer than expected.");r[d++]=N;var L=d+=y;for(b!==v&&(r[d++]=N),w=b;y--;)w=g[w],r[--L]=255&w,w>>=8;null!==m&&c<4096&&(g[c++]=m<<8|N,c>=h+1&&u<12&&(++u,h=h<<1|1)),m=v;}else c=s+1,h=(1<<(u=i+1))-1,m=null;}return d!==n&&a$2.log("Warning, gif stream shorter than expected."),r}
  /**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */function Qt(t){var e,r,n,i,a,o=Math.floor,s=new Array(64),c=new Array(64),u=new Array(64),h=new Array(64),l=new Array(65535),f=new Array(65535),d=new Array(64),p=new Array(64),g=[],m=0,v=7,b=new Array(64),y=new Array(64),w=new Array(64),N=new Array(256),L=new Array(2048),A=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],x=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],S=[0,1,2,3,4,5,6,7,8,9,10,11],_=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],P=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],k=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],I=[0,1,2,3,4,5,6,7,8,9,10,11],F=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],C=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function j(t,e){for(var r=0,n=0,i=new Array,a=1;a<=16;a++){for(var o=1;o<=t[a];o++)i[e[n]]=[],i[e[n]][0]=r,i[e[n]][1]=a,n++,r++;r*=2;}return i}function O(t){for(var e=t[0],r=t[1]-1;r>=0;)e&1<<r&&(m|=1<<v),r--,--v<0&&(255==m?(B(255),B(0)):B(m),v=7,m=0);}function B(t){g.push(t);}function M(t){B(t>>8&255),B(255&t);}function E(t,e,r,n,i){for(var a,o=i[0],s=i[240],c=function(t,e){var r,n,i,a,o,s,c,u,h,l,f=0;for(h=0;h<8;++h){r=t[f],n=t[f+1],i=t[f+2],a=t[f+3],o=t[f+4],s=t[f+5],c=t[f+6];var p=r+(u=t[f+7]),g=r-u,m=n+c,v=n-c,b=i+s,y=i-s,w=a+o,N=a-o,L=p+w,A=p-w,x=m+b,S=m-b;t[f]=L+x,t[f+4]=L-x;var _=.707106781*(S+A);t[f+2]=A+_,t[f+6]=A-_;var P=.382683433*((L=N+y)-(S=v+g)),k=.5411961*L+P,I=1.306562965*S+P,F=.707106781*(x=y+v),C=g+F,j=g-F;t[f+5]=j+k,t[f+3]=j-k,t[f+1]=C+I,t[f+7]=C-I,f+=8;}for(f=0,h=0;h<8;++h){r=t[f],n=t[f+8],i=t[f+16],a=t[f+24],o=t[f+32],s=t[f+40],c=t[f+48];var O=r+(u=t[f+56]),B=r-u,M=n+c,E=n-c,q=i+s,D=i-s,R=a+o,T=a-o,U=O+R,z=O-R,H=M+q,W=M-q;t[f]=U+H,t[f+32]=U-H;var V=.707106781*(W+z);t[f+16]=z+V,t[f+48]=z-V;var G=.382683433*((U=T+D)-(W=E+B)),Y=.5411961*U+G,J=1.306562965*W+G,X=.707106781*(H=D+E),K=B+X,Z=B-X;t[f+40]=Z+Y,t[f+24]=Z-Y,t[f+8]=K+J,t[f+56]=K-J,f++;}for(h=0;h<64;++h)l=t[h]*e[h],d[h]=l>0?l+.5|0:l-.5|0;return d}(t,e),u=0;u<64;++u)p[A[u]]=c[u];var h=p[0]-r;r=p[0],0==h?O(n[0]):(O(n[f[a=32767+h]]),O(l[a]));for(var g=63;g>0&&0==p[g];)g--;if(0==g)return O(o),r;for(var m,v=1;v<=g;){for(var b=v;0==p[v]&&v<=g;)++v;var y=v-b;if(y>=16){m=y>>4;for(var w=1;w<=m;++w)O(s);y&=15;}a=32767+p[v],O(i[(y<<4)+f[a]]),O(l[a]),v++;}return 63!=g&&O(o),r}function q(t){(t=Math.min(Math.max(t,1),100),a!=t)&&(!function(t){for(var e=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],r=0;r<64;r++){var n=o((e[r]*t+50)/100);n=Math.min(Math.max(n,1),255),s[A[r]]=n;}for(var i=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],a=0;a<64;a++){var l=o((i[a]*t+50)/100);l=Math.min(Math.max(l,1),255),c[A[a]]=l;}for(var f=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],d=0,p=0;p<8;p++)for(var g=0;g<8;g++)u[d]=1/(s[A[d]]*f[p]*f[g]*8),h[d]=1/(c[A[d]]*f[p]*f[g]*8),d++;}(t<50?Math.floor(5e3/t):Math.floor(200-2*t)),a=t);}this.encode=function(t,a){a&&q(a),g=new Array,m=0,v=7,M(65496),M(65504),M(16),B(74),B(70),B(73),B(70),B(0),B(1),B(1),B(0),M(1),M(1),B(0),B(0),function(){M(65499),M(132),B(0);for(var t=0;t<64;t++)B(s[t]);B(1);for(var e=0;e<64;e++)B(c[e]);}(),function(t,e){M(65472),M(17),B(8),M(e),M(t),B(3),B(1),B(17),B(0),B(2),B(17),B(1),B(3),B(17),B(1);}(t.width,t.height),function(){M(65476),M(418),B(0);for(var t=0;t<16;t++)B(x[t+1]);for(var e=0;e<=11;e++)B(S[e]);B(16);for(var r=0;r<16;r++)B(_[r+1]);for(var n=0;n<=161;n++)B(P[n]);B(1);for(var i=0;i<16;i++)B(k[i+1]);for(var a=0;a<=11;a++)B(I[a]);B(17);for(var o=0;o<16;o++)B(F[o+1]);for(var s=0;s<=161;s++)B(C[s]);}(),M(65498),M(12),B(3),B(1),B(0),B(2),B(17),B(3),B(17),B(0),B(63),B(0);var o=0,l=0,f=0;m=0,v=7,this.encode.displayName="_encode_";for(var d,p,N,A,j,D,R,T,U,z=t.data,H=t.width,W=t.height,V=4*H,G=0;G<W;){for(d=0;d<V;){for(j=V*G+d,R=-1,T=0,U=0;U<64;U++)D=j+(T=U>>3)*V+(R=4*(7&U)),G+T>=W&&(D-=V*(G+1+T-W)),d+R>=V&&(D-=d+R-V+4),p=z[D++],N=z[D++],A=z[D++],b[U]=(L[p]+L[N+256>>0]+L[A+512>>0]>>16)-128,y[U]=(L[p+768>>0]+L[N+1024>>0]+L[A+1280>>0]>>16)-128,w[U]=(L[p+1280>>0]+L[N+1536>>0]+L[A+1792>>0]>>16)-128;o=E(b,u,o,e,n),l=E(y,h,l,r,i),f=E(w,h,f,r,i),d+=32;}G+=8;}if(v>=0){var Y=[];Y[1]=v+1,Y[0]=(1<<v+1)-1,O(Y);}return M(65497),new Uint8Array(g)},t=t||50,function(){for(var t=String.fromCharCode,e=0;e<256;e++)N[e]=t(e);}(),e=j(x,S),r=j(k,I),n=j(_,P),i=j(F,C),function(){for(var t=1,e=2,r=1;r<=15;r++){for(var n=t;n<e;n++)f[32767+n]=r,l[32767+n]=[],l[32767+n][1]=r,l[32767+n][0]=n;for(var i=-(e-1);i<=-t;i++)f[32767+i]=r,l[32767+i]=[],l[32767+i][1]=r,l[32767+i][0]=e-1+i;t<<=1,e<<=1;}}(),function(){for(var t=0;t<256;t++)L[t]=19595*t,L[t+256>>0]=38470*t,L[t+512>>0]=7471*t+32768,L[t+768>>0]=-11059*t,L[t+1024>>0]=-21709*t,L[t+1280>>0]=32768*t+8421375,L[t+1536>>0]=-27439*t,L[t+1792>>0]=-5329*t;}(),q(t);}
  /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */function te(t,e){if(this.pos=0,this.buffer=t,this.datav=new DataView(t.buffer),this.is_with_alpha=!!e,this.bottom_up=!0,this.flag=String.fromCharCode(this.buffer[0])+String.fromCharCode(this.buffer[1]),this.pos+=2,-1===["BM","BA","CI","CP","IC","PT"].indexOf(this.flag))throw new Error("Invalid BMP File");this.parseHeader(),this.parseBGR();}function ee$1(t){function e(t){if(!t)throw Error("assert :P")}function r(t,e,r){for(var n=0;4>n;n++)if(t[e+n]!=r.charCodeAt(n))return !0;return !1}function n(t,e,r,n,i){for(var a=0;a<i;a++)t[e+a]=r[n+a];}function i(t,e,r,n){for(var i=0;i<n;i++)t[e+i]=r;}function a(t){return new Int32Array(t)}function o(t,e){for(var r=[],n=0;n<t;n++)r.push(new e);return r}function s(t,e){var r=[];return function t(r,n,i){for(var a=i[n],o=0;o<a&&(r.push(i.length>n+1?[]:new e),!(i.length<n+1));o++)t(r[o],n+1,i);}(r,0,t),r}var c=function(){var t=this;function c(t,e){for(var r=1<<e-1>>>0;t&r;)r>>>=1;return r?(t&r-1)+r:t}function u(t,r,n,i,a){e(!(i%n));do{t[r+(i-=n)]=a;}while(0<i)}function h(t,r,n,i,o){if(e(2328>=o),512>=o)var s=a(512);else if(null==(s=a(o)))return 0;return function(t,r,n,i,o,s){var h,f,d=r,p=1<<n,g=a(16),m=a(16);for(e(0!=o),e(null!=i),e(null!=t),e(0<n),f=0;f<o;++f){if(15<i[f])return 0;++g[i[f]];}if(g[0]==o)return 0;for(m[1]=0,h=1;15>h;++h){if(g[h]>1<<h)return 0;m[h+1]=m[h]+g[h];}for(f=0;f<o;++f)h=i[f],0<i[f]&&(s[m[h]++]=f);if(1==m[15])return (i=new l).g=0,i.value=s[0],u(t,d,1,p,i),p;var v,b=-1,y=p-1,w=0,N=1,L=1,A=1<<n;for(f=0,h=1,o=2;h<=n;++h,o<<=1){if(N+=L<<=1,0>(L-=g[h]))return 0;for(;0<g[h];--g[h])(i=new l).g=h,i.value=s[f++],u(t,d+w,o,A,i),w=c(w,h);}for(h=n+1,o=2;15>=h;++h,o<<=1){if(N+=L<<=1,0>(L-=g[h]))return 0;for(;0<g[h];--g[h]){if(i=new l,(w&y)!=b){for(d+=A,v=1<<(b=h)-n;15>b&&!(0>=(v-=g[b]));)++b,v<<=1;p+=A=1<<(v=b-n),t[r+(b=w&y)].g=v+n,t[r+b].value=d-r-b;}i.g=h-n,i.value=s[f++],u(t,d+(w>>n),o,A,i),w=c(w,h);}}return N!=2*m[15]-1?0:p}(t,r,n,i,o,s)}function l(){this.value=this.g=0;}function f(){this.value=this.g=0;}function d(){this.G=o(5,l),this.H=a(5),this.jc=this.Qb=this.qb=this.nd=0,this.pd=o(Dr,f);}function p(t,r,n,i){e(null!=t),e(null!=r),e(2147483648>i),t.Ca=254,t.I=0,t.b=-8,t.Ka=0,t.oa=r,t.pa=n,t.Jd=r,t.Yc=n+i,t.Zc=4<=i?n+i-4+1:n,_(t);}function g(t,e){for(var r=0;0<e--;)r|=k(t,128)<<e;return r}function m(t,e){var r=g(t,e);return P(t)?-r:r}function v(t,r,n,i){var a,o=0;for(e(null!=t),e(null!=r),e(4294967288>i),t.Sb=i,t.Ra=0,t.u=0,t.h=0,4<i&&(i=4),a=0;a<i;++a)o+=r[n+a]<<8*a;t.Ra=o,t.bb=i,t.oa=r,t.pa=n;}function b(t){for(;8<=t.u&&t.bb<t.Sb;)t.Ra>>>=8,t.Ra+=t.oa[t.pa+t.bb]<<Ur-8>>>0,++t.bb,t.u-=8;A(t)&&(t.h=1,t.u=0);}function y(t,r){if(e(0<=r),!t.h&&r<=Tr){var n=L(t)&Rr[r];return t.u+=r,b(t),n}return t.h=1,t.u=0}function w(){this.b=this.Ca=this.I=0,this.oa=[],this.pa=0,this.Jd=[],this.Yc=0,this.Zc=[],this.Ka=0;}function N(){this.Ra=0,this.oa=[],this.h=this.u=this.bb=this.Sb=this.pa=0;}function L(t){return t.Ra>>>(t.u&Ur-1)>>>0}function A(t){return e(t.bb<=t.Sb),t.h||t.bb==t.Sb&&t.u>Ur}function x(t,e){t.u=e,t.h=A(t);}function S(t){t.u>=zr&&(e(t.u>=zr),b(t));}function _(t){e(null!=t&&null!=t.oa),t.pa<t.Zc?(t.I=(t.oa[t.pa++]|t.I<<8)>>>0,t.b+=8):(e(null!=t&&null!=t.oa),t.pa<t.Yc?(t.b+=8,t.I=t.oa[t.pa++]|t.I<<8):t.Ka?t.b=0:(t.I<<=8,t.b+=8,t.Ka=1));}function P(t){return g(t,1)}function k(t,e){var r=t.Ca;0>t.b&&_(t);var n=t.b,i=r*e>>>8,a=(t.I>>>n>i)+0;for(a?(r-=i,t.I-=i+1<<n>>>0):r=i+1,n=r,i=0;256<=n;)i+=8,n>>=8;return n=7^i+Hr[n],t.b-=n,t.Ca=(r<<n)-1,a}function I(t,e,r){t[e+0]=r>>24&255,t[e+1]=r>>16&255,t[e+2]=r>>8&255,t[e+3]=r>>0&255;}function F(t,e){return t[e+0]<<0|t[e+1]<<8}function C(t,e){return F(t,e)|t[e+2]<<16}function j(t,e){return F(t,e)|F(t,e+2)<<16}function O(t,r){var n=1<<r;return e(null!=t),e(0<r),t.X=a(n),null==t.X?0:(t.Mb=32-r,t.Xa=r,1)}function B(t,r){e(null!=t),e(null!=r),e(t.Xa==r.Xa),n(r.X,0,t.X,0,1<<r.Xa);}function M(){this.X=[],this.Xa=this.Mb=0;}function E(t,r,n,i){e(null!=n),e(null!=i);var a=n[0],o=i[0];return 0==a&&(a=(t*o+r/2)/r),0==o&&(o=(r*a+t/2)/t),0>=a||0>=o?0:(n[0]=a,i[0]=o,1)}function q(t,e){return t+(1<<e)-1>>>e}function D(t,e){return ((4278255360&t)+(4278255360&e)>>>0&4278255360)+((16711935&t)+(16711935&e)>>>0&16711935)>>>0}function R(e,r){t[r]=function(r,n,i,a,o,s,c){var u;for(u=0;u<o;++u){var h=t[e](s[c+u-1],i,a+u);s[c+u]=D(r[n+u],h);}};}function T(){this.ud=this.hd=this.jd=0;}function U(t,e){return ((4278124286&(t^e))>>>1)+(t&e)>>>0}function z(t){return 0<=t&&256>t?t:0>t?0:255<t?255:void 0}function H(t,e){return z(t+(t-e+.5>>1))}function W(t,e,r){return Math.abs(e-r)-Math.abs(t-r)}function V(t,e,r,n,i,a,o){for(n=a[o-1],r=0;r<i;++r)a[o+r]=n=D(t[e+r],n);}function G(t,e,r,n,i){var a;for(a=0;a<r;++a){var o=t[e+a],s=o>>8&255,c=16711935&(c=(c=16711935&o)+((s<<16)+s));n[i+a]=(4278255360&o)+c>>>0;}}function Y(t,e){e.jd=t>>0&255,e.hd=t>>8&255,e.ud=t>>16&255;}function J(t,e,r,n,i,a){var o;for(o=0;o<n;++o){var s=e[r+o],c=s>>>8,u=s,h=255&(h=(h=s>>>16)+((t.jd<<24>>24)*(c<<24>>24)>>>5));u=255&(u=(u=u+((t.hd<<24>>24)*(c<<24>>24)>>>5))+((t.ud<<24>>24)*(h<<24>>24)>>>5));i[a+o]=(4278255360&s)+(h<<16)+u;}}function X(e,r,n,i,a){t[r]=function(t,e,r,n,o,s,c,u,h){for(n=c;n<u;++n)for(c=0;c<h;++c)o[s++]=a(r[i(t[e++])]);},t[e]=function(e,r,o,s,c,u,h){var l=8>>e.b,f=e.Ea,d=e.K[0],p=e.w;if(8>l)for(e=(1<<e.b)-1,p=(1<<l)-1;r<o;++r){var g,m=0;for(g=0;g<f;++g)g&e||(m=i(s[c++])),u[h++]=a(d[m&p]),m>>=l;}else t["VP8LMapColor"+n](s,c,d,p,u,h,r,o,f);};}function K(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>16&255,n[i++]=a>>8&255,n[i++]=a>>0&255;}}function Z(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>16&255,n[i++]=a>>8&255,n[i++]=a>>0&255,n[i++]=a>>24&255;}}function $(t,e,r,n,i){for(r=e+r;e<r;){var a=(o=t[e++])>>16&240|o>>12&15,o=o>>0&240|o>>28&15;n[i++]=a,n[i++]=o;}}function Q(t,e,r,n,i){for(r=e+r;e<r;){var a=(o=t[e++])>>16&248|o>>13&7,o=o>>5&224|o>>3&31;n[i++]=a,n[i++]=o;}}function tt(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>0&255,n[i++]=a>>8&255,n[i++]=a>>16&255;}}function et(t,e,r,i,a,o){if(0==o)for(r=e+r;e<r;)I(i,((o=t[e++])[0]>>24|o[1]>>8&65280|o[2]<<8&16711680|o[3]<<24)>>>0),a+=32;else n(i,a,t,e,r);}function rt(e,r){t[r][0]=t[e+"0"],t[r][1]=t[e+"1"],t[r][2]=t[e+"2"],t[r][3]=t[e+"3"],t[r][4]=t[e+"4"],t[r][5]=t[e+"5"],t[r][6]=t[e+"6"],t[r][7]=t[e+"7"],t[r][8]=t[e+"8"],t[r][9]=t[e+"9"],t[r][10]=t[e+"10"],t[r][11]=t[e+"11"],t[r][12]=t[e+"12"],t[r][13]=t[e+"13"],t[r][14]=t[e+"0"],t[r][15]=t[e+"0"];}function nt(t){return t==Hn||t==Wn||t==Vn||t==Gn}function it(){this.eb=[],this.size=this.A=this.fb=0;}function at(){this.y=[],this.f=[],this.ea=[],this.F=[],this.Tc=this.Ed=this.Cd=this.Fd=this.lb=this.Db=this.Ab=this.fa=this.J=this.W=this.N=this.O=0;}function ot(){this.Rd=this.height=this.width=this.S=0,this.f={},this.f.RGBA=new it,this.f.kb=new at,this.sd=null;}function st(){this.width=[0],this.height=[0],this.Pd=[0],this.Qd=[0],this.format=[0];}function ct(){this.Id=this.fd=this.Md=this.hb=this.ib=this.da=this.bd=this.cd=this.j=this.v=this.Da=this.Sd=this.ob=0;}function ut(t){return alert("todo:WebPSamplerProcessPlane"),t.T}function ht(t,e){var r=t.T,i=e.ba.f.RGBA,a=i.eb,o=i.fb+t.ka*i.A,s=vi[e.ba.S],c=t.y,u=t.O,h=t.f,l=t.N,f=t.ea,d=t.W,p=e.cc,g=e.dc,m=e.Mc,v=e.Nc,b=t.ka,y=t.ka+t.T,w=t.U,N=w+1>>1;for(0==b?s(c,u,null,null,h,l,f,d,h,l,f,d,a,o,null,null,w):(s(e.ec,e.fc,c,u,p,g,m,v,h,l,f,d,a,o-i.A,a,o,w),++r);b+2<y;b+=2)p=h,g=l,m=f,v=d,l+=t.Rc,d+=t.Rc,o+=2*i.A,s(c,(u+=2*t.fa)-t.fa,c,u,p,g,m,v,h,l,f,d,a,o-i.A,a,o,w);return u+=t.fa,t.j+y<t.o?(n(e.ec,e.fc,c,u,w),n(e.cc,e.dc,h,l,N),n(e.Mc,e.Nc,f,d,N),r--):1&y||s(c,u,null,null,h,l,f,d,h,l,f,d,a,o+i.A,null,null,w),r}function lt(t,r,n){var i=t.F,a=[t.J];if(null!=i){var o=t.U,s=r.ba.S,c=s==Tn||s==Vn;r=r.ba.f.RGBA;var u=[0],h=t.ka;u[0]=t.T,t.Kb&&(0==h?--u[0]:(--h,a[0]-=t.width),t.j+t.ka+t.T==t.o&&(u[0]=t.o-t.j-h));var l=r.eb;h=r.fb+h*r.A;t=Sn(i,a[0],t.width,o,u,l,h+(c?0:3),r.A),e(n==u),t&&nt(s)&&An(l,h,c,o,u,r.A);}return 0}function ft(t){var e=t.ma,r=e.ba.S,n=11>r,i=r==qn||r==Rn||r==Tn||r==Un||12==r||nt(r);if(e.memory=null,e.Ib=null,e.Jb=null,e.Nd=null,!Mr(e.Oa,t,i?11:12))return 0;if(i&&nt(r)&&br(),t.da)alert("todo:use_scaling");else {if(n){if(e.Ib=ut,t.Kb){if(r=t.U+1>>1,e.memory=a(t.U+2*r),null==e.memory)return 0;e.ec=e.memory,e.fc=0,e.cc=e.ec,e.dc=e.fc+t.U,e.Mc=e.cc,e.Nc=e.dc+r,e.Ib=ht,br();}}else alert("todo:EmitYUV");i&&(e.Jb=lt,n&&mr());}if(n&&!Ci){for(t=0;256>t;++t)ji[t]=89858*(t-128)+_i>>Si,Mi[t]=-22014*(t-128)+_i,Bi[t]=-45773*(t-128),Oi[t]=113618*(t-128)+_i>>Si;for(t=Pi;t<ki;++t)e=76283*(t-16)+_i>>Si,Ei[t-Pi]=Vt(e,255),qi[t-Pi]=Vt(e+8>>4,15);Ci=1;}return 1}function dt(t){var r=t.ma,n=t.U,i=t.T;return e(!(1&t.ka)),0>=n||0>=i?0:(n=r.Ib(t,r),null!=r.Jb&&r.Jb(t,r,n),r.Dc+=n,1)}function pt(t){t.ma.memory=null;}function gt(t,e,r,n){return 47!=y(t,8)?0:(e[0]=y(t,14)+1,r[0]=y(t,14)+1,n[0]=y(t,1),0!=y(t,3)?0:!t.h)}function mt(t,e){if(4>t)return t+1;var r=t-2>>1;return (2+(1&t)<<r)+y(e,r)+1}function vt(t,e){return 120<e?e-120:1<=(r=((r=$n[e-1])>>4)*t+(8-(15&r)))?r:1;var r;}function bt(t,e,r){var n=L(r),i=t[e+=255&n].g-8;return 0<i&&(x(r,r.u+8),n=L(r),e+=t[e].value,e+=n&(1<<i)-1),x(r,r.u+t[e].g),t[e].value}function yt(t,r,n){return n.g+=t.g,n.value+=t.value<<r>>>0,e(8>=n.g),t.g}function wt(t,r,n){var i=t.xc;return e((r=0==i?0:t.vc[t.md*(n>>i)+(r>>i)])<t.Wb),t.Ya[r]}function Nt(t,r,i,a){var o=t.ab,s=t.c*r,c=t.C;r=c+r;var u=i,h=a;for(a=t.Ta,i=t.Ua;0<o--;){var l=t.gc[o],f=c,d=r,p=u,g=h,m=(h=a,u=i,l.Ea);switch(e(f<d),e(d<=l.nc),l.hc){case 2:Gr(p,g,(d-f)*m,h,u);break;case 0:var v=f,b=d,y=h,w=u,N=(_=l).Ea;0==v&&(Wr(p,g,null,null,1,y,w),V(p,g+1,0,0,N-1,y,w+1),g+=N,w+=N,++v);for(var L=1<<_.b,A=L-1,x=q(N,_.b),S=_.K,_=_.w+(v>>_.b)*x;v<b;){var P=S,k=_,I=1;for(Vr(p,g,y,w-N,1,y,w);I<N;){var F=(I&~A)+L;F>N&&(F=N),(0, Zr[P[k++]>>8&15])(p,g+ +I,y,w+I-N,F-I,y,w+I),I=F;}g+=N,w+=N,++v&A||(_+=x);}d!=l.nc&&n(h,u-m,h,u+(d-f-1)*m,m);break;case 1:for(m=p,b=g,N=(p=l.Ea)-(w=p&~(y=(g=1<<l.b)-1)),v=q(p,l.b),L=l.K,l=l.w+(f>>l.b)*v;f<d;){for(A=L,x=l,S=new T,_=b+w,P=b+p;b<_;)Y(A[x++],S),$r(S,m,b,g,h,u),b+=g,u+=g;b<P&&(Y(A[x++],S),$r(S,m,b,N,h,u),b+=N,u+=N),++f&y||(l+=v);}break;case 3:if(p==h&&g==u&&0<l.b){for(b=h,p=m=u+(d-f)*m-(w=(d-f)*q(l.Ea,l.b)),g=h,y=u,v=[],w=(N=w)-1;0<=w;--w)v[w]=g[y+w];for(w=N-1;0<=w;--w)b[p+w]=v[w];Yr(l,f,d,h,m,h,u);}else Yr(l,f,d,p,g,h,u);}u=a,h=i;}h!=i&&n(a,i,u,h,s);}function Lt(t,r){var n=t.V,i=t.Ba+t.c*t.C,a=r-t.C;if(e(r<=t.l.o),e(16>=a),0<a){var o=t.l,s=t.Ta,c=t.Ua,u=o.width;if(Nt(t,a,n,i),a=c=[c],e((n=t.C)<(i=r)),e(o.v<o.va),i>o.o&&(i=o.o),n<o.j){var h=o.j-n;n=o.j;a[0]+=h*u;}if(n>=i?n=0:(a[0]+=4*o.v,o.ka=n-o.j,o.U=o.va-o.v,o.T=i-n,n=1),n){if(c=c[0],11>(n=t.ca).S){var l=n.f.RGBA,f=(i=n.S,a=o.U,o=o.T,h=l.eb,l.A),d=o;for(l=l.fb+t.Ma*l.A;0<d--;){var p=s,g=c,m=a,v=h,b=l;switch(i){case En:Qr(p,g,m,v,b);break;case qn:tn(p,g,m,v,b);break;case Hn:tn(p,g,m,v,b),An(v,b,0,m,1,0);break;case Dn:nn(p,g,m,v,b);break;case Rn:et(p,g,m,v,b,1);break;case Wn:et(p,g,m,v,b,1),An(v,b,0,m,1,0);break;case Tn:et(p,g,m,v,b,0);break;case Vn:et(p,g,m,v,b,0),An(v,b,1,m,1,0);break;case Un:en(p,g,m,v,b);break;case Gn:en(p,g,m,v,b),xn(v,b,m,1,0);break;case zn:rn(p,g,m,v,b);break;default:e(0);}c+=u,l+=f;}t.Ma+=o;}else alert("todo:EmitRescaledRowsYUVA");e(t.Ma<=n.height);}}t.C=r,e(t.C<=t.i);}function At(t){var e;if(0<t.ua)return 0;for(e=0;e<t.Wb;++e){var r=t.Ya[e].G,n=t.Ya[e].H;if(0<r[1][n[1]+0].g||0<r[2][n[2]+0].g||0<r[3][n[3]+0].g)return 0}return 1}function xt(t,r,n,i,a,o){if(0!=t.Z){var s=t.qd,c=t.rd;for(e(null!=mi[t.Z]);r<n;++r)mi[t.Z](s,c,i,a,i,a,o),s=i,c=a,a+=o;t.qd=s,t.rd=c;}}function St(t,r){var n=t.l.ma,i=0==n.Z||1==n.Z?t.l.j:t.C;i=t.C<i?i:t.C;if(e(r<=t.l.o),r>i){var a=t.l.width,o=n.ca,s=n.tb+a*i,c=t.V,u=t.Ba+t.c*i,h=t.gc;e(1==t.ab),e(3==h[0].hc),Xr(h[0],i,r,c,u,o,s),xt(n,i,r,o,s,a);}t.C=t.Ma=r;}function _t(t,r,n,i,a,o,s){var c=t.$/i,u=t.$%i,h=t.m,l=t.s,f=n+t.$,d=f;a=n+i*a;var p=n+i*o,g=280+l.ua,m=t.Pb?c:16777216,v=0<l.ua?l.Wa:null,b=l.wc,y=f<p?wt(l,u,c):null;e(t.C<o),e(p<=a);var w=!1;t:for(;;){for(;w||f<p;){var N=0;if(c>=m){var _=f-n;e((m=t).Pb),m.wd=m.m,m.xd=_,0<m.s.ua&&B(m.s.Wa,m.s.vb),m=c+ti;}if(u&b||(y=wt(l,u,c)),e(null!=y),y.Qb&&(r[f]=y.qb,w=!0),!w)if(S(h),y.jc){N=h,_=r;var P=f,k=y.pd[L(N)&Dr-1];e(y.jc),256>k.g?(x(N,N.u+k.g),_[P]=k.value,N=0):(x(N,N.u+k.g-256),e(256<=k.value),N=k.value),0==N&&(w=!0);}else N=bt(y.G[0],y.H[0],h);if(h.h)break;if(w||256>N){if(!w)if(y.nd)r[f]=(y.qb|N<<8)>>>0;else {if(S(h),w=bt(y.G[1],y.H[1],h),S(h),_=bt(y.G[2],y.H[2],h),P=bt(y.G[3],y.H[3],h),h.h)break;r[f]=(P<<24|w<<16|N<<8|_)>>>0;}if(w=!1,++f,++u>=i&&(u=0,++c,null!=s&&c<=o&&!(c%16)&&s(t,c),null!=v))for(;d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else if(280>N){if(N=mt(N-256,h),_=bt(y.G[4],y.H[4],h),S(h),_=vt(i,_=mt(_,h)),h.h)break;if(f-n<_||a-f<N)break t;for(P=0;P<N;++P)r[f+P]=r[f+P-_];for(f+=N,u+=N;u>=i;)u-=i,++c,null!=s&&c<=o&&!(c%16)&&s(t,c);if(e(f<=a),u&b&&(y=wt(l,u,c)),null!=v)for(;d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else {if(!(N<g))break t;for(w=N-280,e(null!=v);d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;N=f,e(!(w>>>(_=v).Xa)),r[N]=_.X[w],w=!0;}w||e(h.h==A(h));}if(t.Pb&&h.h&&f<a)e(t.m.h),t.a=5,t.m=t.wd,t.$=t.xd,0<t.s.ua&&B(t.s.vb,t.s.Wa);else {if(h.h)break t;null!=s&&s(t,c>o?o:c),t.a=0,t.$=f-n;}return 1}return t.a=3,0}function Pt(t){e(null!=t),t.vc=null,t.yc=null,t.Ya=null;var r=t.Wa;null!=r&&(r.X=null),t.vb=null,e(null!=t);}function kt(){var e=new or;return null==e?null:(e.a=0,e.xb=gi,rt("Predictor","VP8LPredictors"),rt("Predictor","VP8LPredictors_C"),rt("PredictorAdd","VP8LPredictorsAdd"),rt("PredictorAdd","VP8LPredictorsAdd_C"),Gr=G,$r=J,Qr=K,tn=Z,en=$,rn=Q,nn=tt,t.VP8LMapColor32b=Jr,t.VP8LMapColor8b=Kr,e)}function It(t,r,n,s,c){var u=1,f=[t],p=[r],g=s.m,m=s.s,v=null,b=0;t:for(;;){if(n)for(;u&&y(g,1);){var w=f,N=p,A=s,_=1,P=A.m,k=A.gc[A.ab],I=y(P,2);if(A.Oc&1<<I)u=0;else {switch(A.Oc|=1<<I,k.hc=I,k.Ea=w[0],k.nc=N[0],k.K=[null],++A.ab,e(4>=A.ab),I){case 0:case 1:k.b=y(P,3)+2,_=It(q(k.Ea,k.b),q(k.nc,k.b),0,A,k.K),k.K=k.K[0];break;case 3:var F,C=y(P,8)+1,j=16<C?0:4<C?1:2<C?2:3;if(w[0]=q(k.Ea,j),k.b=j,F=_=It(C,1,0,A,k.K)){var B,M=C,E=k,R=1<<(8>>E.b),T=a(R);if(null==T)F=0;else {var U=E.K[0],z=E.w;for(T[0]=E.K[0][0],B=1;B<1*M;++B)T[B]=D(U[z+B],T[B-1]);for(;B<4*R;++B)T[B]=0;E.K[0]=null,E.K[0]=T,F=1;}}_=F;break;case 2:break;default:e(0);}u=_;}}if(f=f[0],p=p[0],u&&y(g,1)&&!(u=1<=(b=y(g,4))&&11>=b)){s.a=3;break t}var H;if(H=u)e:{var W,V,G,Y=s,J=f,X=p,K=b,Z=n,$=Y.m,Q=Y.s,tt=[null],et=1,rt=0,nt=Qn[K];r:for(;;){if(Z&&y($,1)){var it=y($,3)+2,at=q(J,it),ot=q(X,it),st=at*ot;if(!It(at,ot,0,Y,tt))break r;for(tt=tt[0],Q.xc=it,W=0;W<st;++W){var ct=tt[W]>>8&65535;tt[W]=ct,ct>=et&&(et=ct+1);}}if($.h)break r;for(V=0;5>V;++V){var ut=Xn[V];!V&&0<K&&(ut+=1<<K),rt<ut&&(rt=ut);}var ht=o(et*nt,l),lt=et,ft=o(lt,d);if(null==ft)var dt=null;else e(65536>=lt),dt=ft;var pt=a(rt);if(null==dt||null==pt||null==ht){Y.a=1;break r}var gt=ht;for(W=G=0;W<et;++W){var mt=dt[W],vt=mt.G,bt=mt.H,wt=0,Nt=1,Lt=0;for(V=0;5>V;++V){ut=Xn[V],vt[V]=gt,bt[V]=G,!V&&0<K&&(ut+=1<<K);n:{var At,xt=ut,St=Y,kt=pt,Ft=gt,Ct=G,jt=0,Ot=St.m,Bt=y(Ot,1);if(i(kt,0,0,xt),Bt){var Mt=y(Ot,1)+1,Et=y(Ot,1),qt=y(Ot,0==Et?1:8);kt[qt]=1,2==Mt&&(kt[qt=y(Ot,8)]=1);var Dt=1;}else {var Rt=a(19),Tt=y(Ot,4)+4;if(19<Tt){St.a=3;var Ut=0;break n}for(At=0;At<Tt;++At)Rt[Zn[At]]=y(Ot,3);var zt=void 0,Ht=void 0,Wt=St,Vt=Rt,Gt=xt,Yt=kt,Jt=0,Xt=Wt.m,Kt=8,Zt=o(128,l);i:for(;h(Zt,0,7,Vt,19);){if(y(Xt,1)){var $t=2+2*y(Xt,3);if((zt=2+y(Xt,$t))>Gt)break i}else zt=Gt;for(Ht=0;Ht<Gt&&zt--;){S(Xt);var Qt=Zt[0+(127&L(Xt))];x(Xt,Xt.u+Qt.g);var te=Qt.value;if(16>te)Yt[Ht++]=te,0!=te&&(Kt=te);else {var ee=16==te,re=te-16,ne=Jn[re],ie=y(Xt,Yn[re])+ne;if(Ht+ie>Gt)break i;for(var ae=ee?Kt:0;0<ie--;)Yt[Ht++]=ae;}}Jt=1;break i}Jt||(Wt.a=3),Dt=Jt;}(Dt=Dt&&!Ot.h)&&(jt=h(Ft,Ct,8,kt,xt)),Dt&&0!=jt?Ut=jt:(St.a=3,Ut=0);}if(0==Ut)break r;if(Nt&&1==Kn[V]&&(Nt=0==gt[G].g),wt+=gt[G].g,G+=Ut,3>=V){var oe,se=pt[0];for(oe=1;oe<ut;++oe)pt[oe]>se&&(se=pt[oe]);Lt+=se;}}if(mt.nd=Nt,mt.Qb=0,Nt&&(mt.qb=(vt[3][bt[3]+0].value<<24|vt[1][bt[1]+0].value<<16|vt[2][bt[2]+0].value)>>>0,0==wt&&256>vt[0][bt[0]+0].value&&(mt.Qb=1,mt.qb+=vt[0][bt[0]+0].value<<8)),mt.jc=!mt.Qb&&6>Lt,mt.jc){var ce,ue=mt;for(ce=0;ce<Dr;++ce){var he=ce,le=ue.pd[he],fe=ue.G[0][ue.H[0]+he];256<=fe.value?(le.g=fe.g+256,le.value=fe.value):(le.g=0,le.value=0,he>>=yt(fe,8,le),he>>=yt(ue.G[1][ue.H[1]+he],16,le),he>>=yt(ue.G[2][ue.H[2]+he],0,le),yt(ue.G[3][ue.H[3]+he],24,le));}}}Q.vc=tt,Q.Wb=et,Q.Ya=dt,Q.yc=ht,H=1;break e}H=0;}if(!(u=H)){s.a=3;break t}if(0<b){if(m.ua=1<<b,!O(m.Wa,b)){s.a=1,u=0;break t}}else m.ua=0;var de=s,pe=f,ge=p,me=de.s,ve=me.xc;if(de.c=pe,de.i=ge,me.md=q(pe,ve),me.wc=0==ve?-1:(1<<ve)-1,n){s.xb=pi;break t}if(null==(v=a(f*p))){s.a=1,u=0;break t}u=(u=_t(s,v,0,f,p,p,null))&&!g.h;break t}return u?(null!=c?c[0]=v:(e(null==v),e(n)),s.$=0,n||Pt(m)):Pt(m),u}function Ft(t,r){var n=t.c*t.i,i=n+r+16*r;return e(t.c<=r),t.V=a(i),null==t.V?(t.Ta=null,t.Ua=0,t.a=1,0):(t.Ta=t.V,t.Ua=t.Ba+n+r,1)}function Ct(t,r){var n=t.C,i=r-n,a=t.V,o=t.Ba+t.c*n;for(e(r<=t.l.o);0<i;){var s=16<i?16:i,c=t.l.ma,u=t.l.width,h=u*s,l=c.ca,f=c.tb+u*n,d=t.Ta,p=t.Ua;Nt(t,s,a,o),_n(d,p,l,f,h),xt(c,n,n+s,l,f,u),i-=s,a+=s*t.c,n+=s;}e(n==r),t.C=t.Ma=r;}function jt(){this.ub=this.yd=this.td=this.Rb=0;}function Ot(){this.Kd=this.Ld=this.Ud=this.Td=this.i=this.c=0;}function Bt(){this.Fb=this.Bb=this.Cb=0,this.Zb=a(4),this.Lb=a(4);}function Mt(){this.Yb=function(){var t=[];return function t(e,r,n){for(var i=n[r],a=0;a<i&&(e.push(n.length>r+1?[]:0),!(n.length<r+1));a++)t(e[a],r+1,n);}(t,0,[3,11]),t}();}function Et(){this.jb=a(3),this.Wc=s([4,8],Mt),this.Xc=s([4,17],Mt);}function qt(){this.Pc=this.wb=this.Tb=this.zd=0,this.vd=new a(4),this.od=new a(4);}function Dt(){this.ld=this.La=this.dd=this.tc=0;}function Rt(){this.Na=this.la=0;}function Tt(){this.Sc=[0,0],this.Eb=[0,0],this.Qc=[0,0],this.ia=this.lc=0;}function Ut(){this.ad=a(384),this.Za=0,this.Ob=a(16),this.$b=this.Ad=this.ia=this.Gc=this.Hc=this.Dd=0;}function zt(){this.uc=this.M=this.Nb=0,this.wa=Array(new Dt),this.Y=0,this.ya=Array(new Ut),this.aa=0,this.l=new Gt;}function Ht(){this.y=a(16),this.f=a(8),this.ea=a(8);}function Wt(){this.cb=this.a=0,this.sc="",this.m=new w,this.Od=new jt,this.Kc=new Ot,this.ed=new qt,this.Qa=new Bt,this.Ic=this.$c=this.Aa=0,this.D=new zt,this.Xb=this.Va=this.Hb=this.zb=this.yb=this.Ub=this.za=0,this.Jc=o(8,w),this.ia=0,this.pb=o(4,Tt),this.Pa=new Et,this.Bd=this.kc=0,this.Ac=[],this.Bc=0,this.zc=[0,0,0,0],this.Gd=Array(new Ht),this.Hd=0,this.rb=Array(new Rt),this.sb=0,this.wa=Array(new Dt),this.Y=0,this.oc=[],this.pc=0,this.sa=[],this.ta=0,this.qa=[],this.ra=0,this.Ha=[],this.B=this.R=this.Ia=0,this.Ec=[],this.M=this.ja=this.Vb=this.Fc=0,this.ya=Array(new Ut),this.L=this.aa=0,this.gd=s([4,2],Dt),this.ga=null,this.Fa=[],this.Cc=this.qc=this.P=0,this.Gb=[],this.Uc=0,this.mb=[],this.nb=0,this.rc=[],this.Ga=this.Vc=0;}function Vt(t,e){return 0>t?0:t>e?e:t}function Gt(){this.T=this.U=this.ka=this.height=this.width=0,this.y=[],this.f=[],this.ea=[],this.Rc=this.fa=this.W=this.N=this.O=0,this.ma="void",this.put="VP8IoPutHook",this.ac="VP8IoSetupHook",this.bc="VP8IoTeardownHook",this.ha=this.Kb=0,this.data=[],this.hb=this.ib=this.da=this.o=this.j=this.va=this.v=this.Da=this.ob=this.w=0,this.F=[],this.J=0;}function Yt(){var t=new Wt;return null!=t&&(t.a=0,t.sc="OK",t.cb=0,t.Xb=0,ni||(ni=Zt)),t}function Jt(t,e,r){return 0==t.a&&(t.a=e,t.sc=r,t.cb=0),0}function Xt(t,e,r){return 3<=r&&157==t[e+0]&&1==t[e+1]&&42==t[e+2]}function Kt(t,r){if(null==t)return 0;if(t.a=0,t.sc="OK",null==r)return Jt(t,2,"null VP8Io passed to VP8GetHeaders()");var n=r.data,a=r.w,o=r.ha;if(4>o)return Jt(t,7,"Truncated header.");var s=n[a+0]|n[a+1]<<8|n[a+2]<<16,c=t.Od;if(c.Rb=!(1&s),c.td=s>>1&7,c.yd=s>>4&1,c.ub=s>>5,3<c.td)return Jt(t,3,"Incorrect keyframe parameters.");if(!c.yd)return Jt(t,4,"Frame not displayable.");a+=3,o-=3;var u=t.Kc;if(c.Rb){if(7>o)return Jt(t,7,"cannot parse picture header");if(!Xt(n,a,o))return Jt(t,3,"Bad code word");u.c=16383&(n[a+4]<<8|n[a+3]),u.Td=n[a+4]>>6,u.i=16383&(n[a+6]<<8|n[a+5]),u.Ud=n[a+6]>>6,a+=7,o-=7,t.za=u.c+15>>4,t.Ub=u.i+15>>4,r.width=u.c,r.height=u.i,r.Da=0,r.j=0,r.v=0,r.va=r.width,r.o=r.height,r.da=0,r.ib=r.width,r.hb=r.height,r.U=r.width,r.T=r.height,i((s=t.Pa).jb,0,255,s.jb.length),e(null!=(s=t.Qa)),s.Cb=0,s.Bb=0,s.Fb=1,i(s.Zb,0,0,s.Zb.length),i(s.Lb,0,0,s.Lb);}if(c.ub>o)return Jt(t,7,"bad partition length");p(s=t.m,n,a,c.ub),a+=c.ub,o-=c.ub,c.Rb&&(u.Ld=P(s),u.Kd=P(s)),u=t.Qa;var h,l=t.Pa;if(e(null!=s),e(null!=u),u.Cb=P(s),u.Cb){if(u.Bb=P(s),P(s)){for(u.Fb=P(s),h=0;4>h;++h)u.Zb[h]=P(s)?m(s,7):0;for(h=0;4>h;++h)u.Lb[h]=P(s)?m(s,6):0;}if(u.Bb)for(h=0;3>h;++h)l.jb[h]=P(s)?g(s,8):255;}else u.Bb=0;if(s.Ka)return Jt(t,3,"cannot parse segment header");if((u=t.ed).zd=P(s),u.Tb=g(s,6),u.wb=g(s,3),u.Pc=P(s),u.Pc&&P(s)){for(l=0;4>l;++l)P(s)&&(u.vd[l]=m(s,6));for(l=0;4>l;++l)P(s)&&(u.od[l]=m(s,6));}if(t.L=0==u.Tb?0:u.zd?1:2,s.Ka)return Jt(t,3,"cannot parse filter header");var f=o;if(o=h=a,a=h+f,u=f,t.Xb=(1<<g(t.m,2))-1,f<3*(l=t.Xb))n=7;else {for(h+=3*l,u-=3*l,f=0;f<l;++f){var d=n[o+0]|n[o+1]<<8|n[o+2]<<16;d>u&&(d=u),p(t.Jc[+f],n,h,d),h+=d,u-=d,o+=3;}p(t.Jc[+l],n,h,u),n=h<a?0:5;}if(0!=n)return Jt(t,n,"cannot parse partitions");for(n=g(h=t.m,7),o=P(h)?m(h,4):0,a=P(h)?m(h,4):0,u=P(h)?m(h,4):0,l=P(h)?m(h,4):0,h=P(h)?m(h,4):0,f=t.Qa,d=0;4>d;++d){if(f.Cb){var v=f.Zb[d];f.Fb||(v+=n);}else {if(0<d){t.pb[d]=t.pb[0];continue}v=n;}var b=t.pb[d];b.Sc[0]=ei[Vt(v+o,127)],b.Sc[1]=ri[Vt(v+0,127)],b.Eb[0]=2*ei[Vt(v+a,127)],b.Eb[1]=101581*ri[Vt(v+u,127)]>>16,8>b.Eb[1]&&(b.Eb[1]=8),b.Qc[0]=ei[Vt(v+l,117)],b.Qc[1]=ri[Vt(v+h,127)],b.lc=v+h;}if(!c.Rb)return Jt(t,4,"Not a key frame.");for(P(s),c=t.Pa,n=0;4>n;++n){for(o=0;8>o;++o)for(a=0;3>a;++a)for(u=0;11>u;++u)l=k(s,ui[n][o][a][u])?g(s,8):si[n][o][a][u],c.Wc[n][o].Yb[a][u]=l;for(o=0;17>o;++o)c.Xc[n][o]=c.Wc[n][hi[o]];}return t.kc=P(s),t.kc&&(t.Bd=g(s,8)),t.cb=1}function Zt(t,e,r,n,i,a,o){var s=e[i].Yb[r];for(r=0;16>i;++i){if(!k(t,s[r+0]))return i;for(;!k(t,s[r+1]);)if(s=e[++i].Yb[0],r=0,16==i)return 16;var c=e[i+1].Yb;if(k(t,s[r+2])){var u=t,h=0;if(k(u,(f=s)[(l=r)+3]))if(k(u,f[l+6])){for(s=0,l=2*(h=k(u,f[l+8]))+(f=k(u,f[l+9+h])),h=0,f=ii[l];f[s];++s)h+=h+k(u,f[s]);h+=3+(8<<l);}else k(u,f[l+7])?(h=7+2*k(u,165),h+=k(u,145)):h=5+k(u,159);else h=k(u,f[l+4])?3+k(u,f[l+5]):2;s=c[2];}else h=1,s=c[1];c=o+ai[i],0>(u=t).b&&_(u);var l,f=u.b,d=(l=u.Ca>>1)-(u.I>>f)>>31;--u.b,u.Ca+=d,u.Ca|=1,u.I-=(l+1&d)<<f,a[c]=((h^d)-d)*n[(0<i)+0];}return 16}function $t(t){var e=t.rb[t.sb-1];e.la=0,e.Na=0,i(t.zc,0,0,t.zc.length),t.ja=0;}function Qt(t,r){if(null==t)return 0;if(null==r)return Jt(t,2,"NULL VP8Io parameter in VP8Decode().");if(!t.cb&&!Kt(t,r))return 0;if(e(t.cb),null==r.ac||r.ac(r)){r.ob&&(t.L=0);var s=Ri[t.L];if(2==t.L?(t.yb=0,t.zb=0):(t.yb=r.v-s>>4,t.zb=r.j-s>>4,0>t.yb&&(t.yb=0),0>t.zb&&(t.zb=0)),t.Va=r.o+15+s>>4,t.Hb=r.va+15+s>>4,t.Hb>t.za&&(t.Hb=t.za),t.Va>t.Ub&&(t.Va=t.Ub),0<t.L){var c=t.ed;for(s=0;4>s;++s){var u;if(t.Qa.Cb){var h=t.Qa.Lb[s];t.Qa.Fb||(h+=c.Tb);}else h=c.Tb;for(u=0;1>=u;++u){var l=t.gd[s][u],f=h;if(c.Pc&&(f+=c.vd[0],u&&(f+=c.od[0])),0<(f=0>f?0:63<f?63:f)){var d=f;0<c.wb&&((d=4<c.wb?d>>2:d>>1)>9-c.wb&&(d=9-c.wb)),1>d&&(d=1),l.dd=d,l.tc=2*f+d,l.ld=40<=f?2:15<=f?1:0;}else l.tc=0;l.La=u;}}}s=0;}else Jt(t,6,"Frame setup failed"),s=t.a;if(s=0==s){if(s){t.$c=0,0<t.Aa||(t.Ic=Ui);t:{s=t.Ic;c=4*(d=t.za);var p=32*d,g=d+1,m=0<t.L?d*(0<t.Aa?2:1):0,v=(2==t.Aa?2:1)*d;if((l=c+832+(u=3*(16*s+Ri[t.L])/2*p)+(h=null!=t.Fa&&0<t.Fa.length?t.Kc.c*t.Kc.i:0))!=l)s=0;else {if(l>t.Vb){if(t.Vb=0,t.Ec=a(l),t.Fc=0,null==t.Ec){s=Jt(t,1,"no memory during frame initialization.");break t}t.Vb=l;}l=t.Ec,f=t.Fc,t.Ac=l,t.Bc=f,f+=c,t.Gd=o(p,Ht),t.Hd=0,t.rb=o(g+1,Rt),t.sb=1,t.wa=m?o(m,Dt):null,t.Y=0,t.D.Nb=0,t.D.wa=t.wa,t.D.Y=t.Y,0<t.Aa&&(t.D.Y+=d),e(!0),t.oc=l,t.pc=f,f+=832,t.ya=o(v,Ut),t.aa=0,t.D.ya=t.ya,t.D.aa=t.aa,2==t.Aa&&(t.D.aa+=d),t.R=16*d,t.B=8*d,d=(p=Ri[t.L])*t.R,p=p/2*t.B,t.sa=l,t.ta=f+d,t.qa=t.sa,t.ra=t.ta+16*s*t.R+p,t.Ha=t.qa,t.Ia=t.ra+8*s*t.B+p,t.$c=0,f+=u,t.mb=h?l:null,t.nb=h?f:null,e(f+h<=t.Fc+t.Vb),$t(t),i(t.Ac,t.Bc,0,c),s=1;}}if(s){if(r.ka=0,r.y=t.sa,r.O=t.ta,r.f=t.qa,r.N=t.ra,r.ea=t.Ha,r.Vd=t.Ia,r.fa=t.R,r.Rc=t.B,r.F=null,r.J=0,!Cn){for(s=-255;255>=s;++s)Pn[255+s]=0>s?-s:s;for(s=-1020;1020>=s;++s)kn[1020+s]=-128>s?-128:127<s?127:s;for(s=-112;112>=s;++s)In[112+s]=-16>s?-16:15<s?15:s;for(s=-255;510>=s;++s)Fn[255+s]=0>s?0:255<s?255:s;Cn=1;}an=ue,on=ae,cn=oe,un=se,hn=ce,sn=ie,ln=Je,fn=Xe,dn=$e,pn=Qe,gn=Ke,mn=Ze,vn=tr,bn=er,yn=ze,wn=He,Nn=We,Ln=Ve,fi[0]=xe,fi[1]=le,fi[2]=Le,fi[3]=Ae,fi[4]=Se,fi[5]=Pe,fi[6]=_e,fi[7]=ke,fi[8]=Fe,fi[9]=Ie,li[0]=ve,li[1]=de,li[2]=pe,li[3]=ge,li[4]=be,li[5]=ye,li[6]=we,di[0]=Be,di[1]=fe,di[2]=Ce,di[3]=je,di[4]=Ee,di[5]=Me,di[6]=qe,s=1;}else s=0;}s&&(s=function(t,r){for(t.M=0;t.M<t.Va;++t.M){var o,s=t.Jc[t.M&t.Xb],c=t.m,u=t;for(o=0;o<u.za;++o){var h=c,l=u,f=l.Ac,d=l.Bc+4*o,p=l.zc,g=l.ya[l.aa+o];if(l.Qa.Bb?g.$b=k(h,l.Pa.jb[0])?2+k(h,l.Pa.jb[2]):k(h,l.Pa.jb[1]):g.$b=0,l.kc&&(g.Ad=k(h,l.Bd)),g.Za=!k(h,145)+0,g.Za){var m=g.Ob,v=0;for(l=0;4>l;++l){var b,y=p[0+l];for(b=0;4>b;++b){y=ci[f[d+b]][y];for(var w=oi[k(h,y[0])];0<w;)w=oi[2*w+k(h,y[w])];y=-w,f[d+b]=y;}n(m,v,f,d,4),v+=4,p[0+l]=y;}}else y=k(h,156)?k(h,128)?1:3:k(h,163)?2:0,g.Ob[0]=y,i(f,d,y,4),i(p,0,y,4);g.Dd=k(h,142)?k(h,114)?k(h,183)?1:3:2:0;}if(u.m.Ka)return Jt(t,7,"Premature end-of-partition0 encountered.");for(;t.ja<t.za;++t.ja){if(u=s,h=(c=t).rb[c.sb-1],f=c.rb[c.sb+c.ja],o=c.ya[c.aa+c.ja],d=c.kc?o.Ad:0)h.la=f.la=0,o.Za||(h.Na=f.Na=0),o.Hc=0,o.Gc=0,o.ia=0;else {var N,L;h=f,f=u,d=c.Pa.Xc,p=c.ya[c.aa+c.ja],g=c.pb[p.$b];if(l=p.ad,m=0,v=c.rb[c.sb-1],y=b=0,i(l,m,0,384),p.Za)var A=0,x=d[3];else {w=a(16);var S=h.Na+v.Na;if(S=ni(f,d[1],S,g.Eb,0,w,0),h.Na=v.Na=(0<S)+0,1<S)an(w,0,l,m);else {var _=w[0]+3>>3;for(w=0;256>w;w+=16)l[m+w]=_;}A=1,x=d[0];}var P=15&h.la,I=15&v.la;for(w=0;4>w;++w){var F=1&I;for(_=L=0;4>_;++_)P=P>>1|(F=(S=ni(f,x,S=F+(1&P),g.Sc,A,l,m))>A)<<7,L=L<<2|(3<S?3:1<S?2:0!=l[m+0]),m+=16;P>>=4,I=I>>1|F<<7,b=(b<<8|L)>>>0;}for(x=P,A=I>>4,N=0;4>N;N+=2){for(L=0,P=h.la>>4+N,I=v.la>>4+N,w=0;2>w;++w){for(F=1&I,_=0;2>_;++_)S=F+(1&P),P=P>>1|(F=0<(S=ni(f,d[2],S,g.Qc,0,l,m)))<<3,L=L<<2|(3<S?3:1<S?2:0!=l[m+0]),m+=16;P>>=2,I=I>>1|F<<5;}y|=L<<4*N,x|=P<<4<<N,A|=(240&I)<<N;}h.la=x,v.la=A,p.Hc=b,p.Gc=y,p.ia=43690&y?0:g.ia,d=!(b|y);}if(0<c.L&&(c.wa[c.Y+c.ja]=c.gd[o.$b][o.Za],c.wa[c.Y+c.ja].La|=!d),u.Ka)return Jt(t,7,"Premature end-of-file encountered.")}if($t(t),c=r,u=1,o=(s=t).D,h=0<s.L&&s.M>=s.zb&&s.M<=s.Va,0==s.Aa)t:{if(o.M=s.M,o.uc=h,Or(s,o),u=1,o=(L=s.D).Nb,h=(y=Ri[s.L])*s.R,f=y/2*s.B,w=16*o*s.R,_=8*o*s.B,d=s.sa,p=s.ta-h+w,g=s.qa,l=s.ra-f+_,m=s.Ha,v=s.Ia-f+_,I=0==(P=L.M),b=P>=s.Va-1,2==s.Aa&&Or(s,L),L.uc)for(F=(S=s).D.M,e(S.D.uc),L=S.yb;L<S.Hb;++L){A=L,x=F;var C=(j=(U=S).D).Nb;N=U.R;var j=j.wa[j.Y+A],O=U.sa,B=U.ta+16*C*N+16*A,M=j.dd,E=j.tc;if(0!=E)if(e(3<=E),1==U.L)0<A&&wn(O,B,N,E+4),j.La&&Ln(O,B,N,E),0<x&&yn(O,B,N,E+4),j.La&&Nn(O,B,N,E);else {var q=U.B,D=U.qa,R=U.ra+8*C*q+8*A,T=U.Ha,U=U.Ia+8*C*q+8*A;C=j.ld;0<A&&(fn(O,B,N,E+4,M,C),pn(D,R,T,U,q,E+4,M,C)),j.La&&(mn(O,B,N,E,M,C),bn(D,R,T,U,q,E,M,C)),0<x&&(ln(O,B,N,E+4,M,C),dn(D,R,T,U,q,E+4,M,C)),j.La&&(gn(O,B,N,E,M,C),vn(D,R,T,U,q,E,M,C));}}if(s.ia&&alert("todo:DitherRow"),null!=c.put){if(L=16*P,P=16*(P+1),I?(c.y=s.sa,c.O=s.ta+w,c.f=s.qa,c.N=s.ra+_,c.ea=s.Ha,c.W=s.Ia+_):(L-=y,c.y=d,c.O=p,c.f=g,c.N=l,c.ea=m,c.W=v),b||(P-=y),P>c.o&&(P=c.o),c.F=null,c.J=null,null!=s.Fa&&0<s.Fa.length&&L<P&&(c.J=lr(s,c,L,P-L),c.F=s.mb,null==c.F&&0==c.F.length)){u=Jt(s,3,"Could not decode alpha data.");break t}L<c.j&&(y=c.j-L,L=c.j,e(!(1&y)),c.O+=s.R*y,c.N+=s.B*(y>>1),c.W+=s.B*(y>>1),null!=c.F&&(c.J+=c.width*y)),L<P&&(c.O+=c.v,c.N+=c.v>>1,c.W+=c.v>>1,null!=c.F&&(c.J+=c.v),c.ka=L-c.j,c.U=c.va-c.v,c.T=P-L,u=c.put(c));}o+1!=s.Ic||b||(n(s.sa,s.ta-h,d,p+16*s.R,h),n(s.qa,s.ra-f,g,l+8*s.B,f),n(s.Ha,s.Ia-f,m,v+8*s.B,f));}if(!u)return Jt(t,6,"Output aborted.")}return 1}(t,r)),null!=r.bc&&r.bc(r),s&=1;}return s?(t.cb=0,s):0}function te(t,e,r,n,i){i=t[e+r+32*n]+(i>>3),t[e+r+32*n]=-256&i?0>i?0:255:i;}function ee(t,e,r,n,i,a){te(t,e,0,r,n+i),te(t,e,1,r,n+a),te(t,e,2,r,n-a),te(t,e,3,r,n-i);}function re(t){return (20091*t>>16)+t}function ne(t,e,r,n){var i,o=0,s=a(16);for(i=0;4>i;++i){var c=t[e+0]+t[e+8],u=t[e+0]-t[e+8],h=(35468*t[e+4]>>16)-re(t[e+12]),l=re(t[e+4])+(35468*t[e+12]>>16);s[o+0]=c+l,s[o+1]=u+h,s[o+2]=u-h,s[o+3]=c-l,o+=4,e++;}for(i=o=0;4>i;++i)c=(t=s[o+0]+4)+s[o+8],u=t-s[o+8],h=(35468*s[o+4]>>16)-re(s[o+12]),te(r,n,0,0,c+(l=re(s[o+4])+(35468*s[o+12]>>16))),te(r,n,1,0,u+h),te(r,n,2,0,u-h),te(r,n,3,0,c-l),o++,n+=32;}function ie(t,e,r,n){var i=t[e+0]+4,a=35468*t[e+4]>>16,o=re(t[e+4]),s=35468*t[e+1]>>16;ee(r,n,0,i+o,t=re(t[e+1]),s),ee(r,n,1,i+a,t,s),ee(r,n,2,i-a,t,s),ee(r,n,3,i-o,t,s);}function ae(t,e,r,n,i){ne(t,e,r,n),i&&ne(t,e+16,r,n+4);}function oe(t,e,r,n){on(t,e+0,r,n,1),on(t,e+32,r,n+128,1);}function se(t,e,r,n){var i;for(t=t[e+0]+4,i=0;4>i;++i)for(e=0;4>e;++e)te(r,n,e,i,t);}function ce(t,e,r,n){t[e+0]&&un(t,e+0,r,n),t[e+16]&&un(t,e+16,r,n+4),t[e+32]&&un(t,e+32,r,n+128),t[e+48]&&un(t,e+48,r,n+128+4);}function ue(t,e,r,n){var i,o=a(16);for(i=0;4>i;++i){var s=t[e+0+i]+t[e+12+i],c=t[e+4+i]+t[e+8+i],u=t[e+4+i]-t[e+8+i],h=t[e+0+i]-t[e+12+i];o[0+i]=s+c,o[8+i]=s-c,o[4+i]=h+u,o[12+i]=h-u;}for(i=0;4>i;++i)s=(t=o[0+4*i]+3)+o[3+4*i],c=o[1+4*i]+o[2+4*i],u=o[1+4*i]-o[2+4*i],h=t-o[3+4*i],r[n+0]=s+c>>3,r[n+16]=h+u>>3,r[n+32]=s-c>>3,r[n+48]=h-u>>3,n+=64;}function he(t,e,r){var n,i=e-32,a=Bn,o=255-t[i-1];for(n=0;n<r;++n){var s,c=a,u=o+t[e-1];for(s=0;s<r;++s)t[e+s]=c[u+t[i+s]];e+=32;}}function le(t,e){he(t,e,4);}function fe(t,e){he(t,e,8);}function de(t,e){he(t,e,16);}function pe(t,e){var r;for(r=0;16>r;++r)n(t,e+32*r,t,e-32,16);}function ge(t,e){var r;for(r=16;0<r;--r)i(t,e,t[e-1],16),e+=32;}function me(t,e,r){var n;for(n=0;16>n;++n)i(e,r+32*n,t,16);}function ve(t,e){var r,n=16;for(r=0;16>r;++r)n+=t[e-1+32*r]+t[e+r-32];me(n>>5,t,e);}function be(t,e){var r,n=8;for(r=0;16>r;++r)n+=t[e-1+32*r];me(n>>4,t,e);}function ye(t,e){var r,n=8;for(r=0;16>r;++r)n+=t[e+r-32];me(n>>4,t,e);}function we(t,e){me(128,t,e);}function Ne(t,e,r){return t+2*e+r+2>>2}function Le(t,e){var r,i=e-32;i=new Uint8Array([Ne(t[i-1],t[i+0],t[i+1]),Ne(t[i+0],t[i+1],t[i+2]),Ne(t[i+1],t[i+2],t[i+3]),Ne(t[i+2],t[i+3],t[i+4])]);for(r=0;4>r;++r)n(t,e+32*r,i,0,i.length);}function Ae(t,e){var r=t[e-1],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96];I(t,e+0,16843009*Ne(t[e-1-32],r,n)),I(t,e+32,16843009*Ne(r,n,i)),I(t,e+64,16843009*Ne(n,i,a)),I(t,e+96,16843009*Ne(i,a,a));}function xe(t,e){var r,n=4;for(r=0;4>r;++r)n+=t[e+r-32]+t[e-1+32*r];for(n>>=3,r=0;4>r;++r)i(t,e+32*r,n,4);}function Se(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],c=t[e+2-32],u=t[e+3-32];t[e+0+96]=Ne(n,i,t[e-1+96]),t[e+1+96]=t[e+0+64]=Ne(r,n,i),t[e+2+96]=t[e+1+64]=t[e+0+32]=Ne(a,r,n),t[e+3+96]=t[e+2+64]=t[e+1+32]=t[e+0+0]=Ne(o,a,r),t[e+3+64]=t[e+2+32]=t[e+1+0]=Ne(s,o,a),t[e+3+32]=t[e+2+0]=Ne(c,s,o),t[e+3+0]=Ne(u,c,s);}function _e(t,e){var r=t[e+1-32],n=t[e+2-32],i=t[e+3-32],a=t[e+4-32],o=t[e+5-32],s=t[e+6-32],c=t[e+7-32];t[e+0+0]=Ne(t[e+0-32],r,n),t[e+1+0]=t[e+0+32]=Ne(r,n,i),t[e+2+0]=t[e+1+32]=t[e+0+64]=Ne(n,i,a),t[e+3+0]=t[e+2+32]=t[e+1+64]=t[e+0+96]=Ne(i,a,o),t[e+3+32]=t[e+2+64]=t[e+1+96]=Ne(a,o,s),t[e+3+64]=t[e+2+96]=Ne(o,s,c),t[e+3+96]=Ne(s,c,c);}function Pe(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],c=t[e+2-32],u=t[e+3-32];t[e+0+0]=t[e+1+64]=a+o+1>>1,t[e+1+0]=t[e+2+64]=o+s+1>>1,t[e+2+0]=t[e+3+64]=s+c+1>>1,t[e+3+0]=c+u+1>>1,t[e+0+96]=Ne(i,n,r),t[e+0+64]=Ne(n,r,a),t[e+0+32]=t[e+1+96]=Ne(r,a,o),t[e+1+32]=t[e+2+96]=Ne(a,o,s),t[e+2+32]=t[e+3+96]=Ne(o,s,c),t[e+3+32]=Ne(s,c,u);}function ke(t,e){var r=t[e+0-32],n=t[e+1-32],i=t[e+2-32],a=t[e+3-32],o=t[e+4-32],s=t[e+5-32],c=t[e+6-32],u=t[e+7-32];t[e+0+0]=r+n+1>>1,t[e+1+0]=t[e+0+64]=n+i+1>>1,t[e+2+0]=t[e+1+64]=i+a+1>>1,t[e+3+0]=t[e+2+64]=a+o+1>>1,t[e+0+32]=Ne(r,n,i),t[e+1+32]=t[e+0+96]=Ne(n,i,a),t[e+2+32]=t[e+1+96]=Ne(i,a,o),t[e+3+32]=t[e+2+96]=Ne(a,o,s),t[e+3+64]=Ne(o,s,c),t[e+3+96]=Ne(s,c,u);}function Ie(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96];t[e+0+0]=r+n+1>>1,t[e+2+0]=t[e+0+32]=n+i+1>>1,t[e+2+32]=t[e+0+64]=i+a+1>>1,t[e+1+0]=Ne(r,n,i),t[e+3+0]=t[e+1+32]=Ne(n,i,a),t[e+3+32]=t[e+1+64]=Ne(i,a,a),t[e+3+64]=t[e+2+64]=t[e+0+96]=t[e+1+96]=t[e+2+96]=t[e+3+96]=a;}function Fe(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96],o=t[e-1-32],s=t[e+0-32],c=t[e+1-32],u=t[e+2-32];t[e+0+0]=t[e+2+32]=r+o+1>>1,t[e+0+32]=t[e+2+64]=n+r+1>>1,t[e+0+64]=t[e+2+96]=i+n+1>>1,t[e+0+96]=a+i+1>>1,t[e+3+0]=Ne(s,c,u),t[e+2+0]=Ne(o,s,c),t[e+1+0]=t[e+3+32]=Ne(r,o,s),t[e+1+32]=t[e+3+64]=Ne(n,r,o),t[e+1+64]=t[e+3+96]=Ne(i,n,r),t[e+1+96]=Ne(a,i,n);}function Ce(t,e){var r;for(r=0;8>r;++r)n(t,e+32*r,t,e-32,8);}function je(t,e){var r;for(r=0;8>r;++r)i(t,e,t[e-1],8),e+=32;}function Oe(t,e,r){var n;for(n=0;8>n;++n)i(e,r+32*n,t,8);}function Be(t,e){var r,n=8;for(r=0;8>r;++r)n+=t[e+r-32]+t[e-1+32*r];Oe(n>>4,t,e);}function Me(t,e){var r,n=4;for(r=0;8>r;++r)n+=t[e+r-32];Oe(n>>3,t,e);}function Ee(t,e){var r,n=4;for(r=0;8>r;++r)n+=t[e-1+32*r];Oe(n>>3,t,e);}function qe(t,e){Oe(128,t,e);}function De(t,e,r){var n=t[e-r],i=t[e+0],a=3*(i-n)+jn[1020+t[e-2*r]-t[e+r]],o=On[112+(a+4>>3)];t[e-r]=Bn[255+n+On[112+(a+3>>3)]],t[e+0]=Bn[255+i-o];}function Re(t,e,r,n){var i=t[e+0],a=t[e+r];return Mn[255+t[e-2*r]-t[e-r]]>n||Mn[255+a-i]>n}function Te(t,e,r,n){return 4*Mn[255+t[e-r]-t[e+0]]+Mn[255+t[e-2*r]-t[e+r]]<=n}function Ue(t,e,r,n,i){var a=t[e-3*r],o=t[e-2*r],s=t[e-r],c=t[e+0],u=t[e+r],h=t[e+2*r],l=t[e+3*r];return 4*Mn[255+s-c]+Mn[255+o-u]>n?0:Mn[255+t[e-4*r]-a]<=i&&Mn[255+a-o]<=i&&Mn[255+o-s]<=i&&Mn[255+l-h]<=i&&Mn[255+h-u]<=i&&Mn[255+u-c]<=i}function ze(t,e,r,n){var i=2*n+1;for(n=0;16>n;++n)Te(t,e+n,r,i)&&De(t,e+n,r);}function He(t,e,r,n){var i=2*n+1;for(n=0;16>n;++n)Te(t,e+n*r,1,i)&&De(t,e+n*r,1);}function We(t,e,r,n){var i;for(i=3;0<i;--i)ze(t,e+=4*r,r,n);}function Ve(t,e,r,n){var i;for(i=3;0<i;--i)He(t,e+=4,r,n);}function Ge(t,e,r,n,i,a,o,s){for(a=2*a+1;0<i--;){if(Ue(t,e,r,a,o))if(Re(t,e,r,s))De(t,e,r);else {var c=t,u=e,h=r,l=c[u-2*h],f=c[u-h],d=c[u+0],p=c[u+h],g=c[u+2*h],m=27*(b=jn[1020+3*(d-f)+jn[1020+l-p]])+63>>7,v=18*b+63>>7,b=9*b+63>>7;c[u-3*h]=Bn[255+c[u-3*h]+b],c[u-2*h]=Bn[255+l+v],c[u-h]=Bn[255+f+m],c[u+0]=Bn[255+d-m],c[u+h]=Bn[255+p-v],c[u+2*h]=Bn[255+g-b];}e+=n;}}function Ye(t,e,r,n,i,a,o,s){for(a=2*a+1;0<i--;){if(Ue(t,e,r,a,o))if(Re(t,e,r,s))De(t,e,r);else {var c=t,u=e,h=r,l=c[u-h],f=c[u+0],d=c[u+h],p=On[112+((g=3*(f-l))+4>>3)],g=On[112+(g+3>>3)],m=p+1>>1;c[u-2*h]=Bn[255+c[u-2*h]+m],c[u-h]=Bn[255+l+g],c[u+0]=Bn[255+f-p],c[u+h]=Bn[255+d-m];}e+=n;}}function Je(t,e,r,n,i,a){Ge(t,e,r,1,16,n,i,a);}function Xe(t,e,r,n,i,a){Ge(t,e,1,r,16,n,i,a);}function Ke(t,e,r,n,i,a){var o;for(o=3;0<o;--o)Ye(t,e+=4*r,r,1,16,n,i,a);}function Ze(t,e,r,n,i,a){var o;for(o=3;0<o;--o)Ye(t,e+=4,1,r,16,n,i,a);}function $e(t,e,r,n,i,a,o,s){Ge(t,e,i,1,8,a,o,s),Ge(r,n,i,1,8,a,o,s);}function Qe(t,e,r,n,i,a,o,s){Ge(t,e,1,i,8,a,o,s),Ge(r,n,1,i,8,a,o,s);}function tr(t,e,r,n,i,a,o,s){Ye(t,e+4*i,i,1,8,a,o,s),Ye(r,n+4*i,i,1,8,a,o,s);}function er(t,e,r,n,i,a,o,s){Ye(t,e+4,1,i,8,a,o,s),Ye(r,n+4,1,i,8,a,o,s);}function rr(){this.ba=new ot,this.ec=[],this.cc=[],this.Mc=[],this.Dc=this.Nc=this.dc=this.fc=0,this.Oa=new ct,this.memory=0,this.Ib="OutputFunc",this.Jb="OutputAlphaFunc",this.Nd="OutputRowFunc";}function nr(){this.data=[],this.offset=this.kd=this.ha=this.w=0,this.na=[],this.xa=this.gb=this.Ja=this.Sa=this.P=0;}function ir(){this.nc=this.Ea=this.b=this.hc=0,this.K=[],this.w=0;}function ar(){this.ua=0,this.Wa=new M,this.vb=new M,this.md=this.xc=this.wc=0,this.vc=[],this.Wb=0,this.Ya=new d,this.yc=new l;}function or(){this.xb=this.a=0,this.l=new Gt,this.ca=new ot,this.V=[],this.Ba=0,this.Ta=[],this.Ua=0,this.m=new N,this.Pb=0,this.wd=new N,this.Ma=this.$=this.C=this.i=this.c=this.xd=0,this.s=new ar,this.ab=0,this.gc=o(4,ir),this.Oc=0;}function sr(){this.Lc=this.Z=this.$a=this.i=this.c=0,this.l=new Gt,this.ic=0,this.ca=[],this.tb=0,this.qd=null,this.rd=0;}function cr(t,e,r,n,i,a,o){for(t=null==t?0:t[e+0],e=0;e<o;++e)i[a+e]=t+r[n+e]&255,t=i[a+e];}function ur(t,e,r,n,i,a,o){var s;if(null==t)cr(null,null,r,n,i,a,o);else for(s=0;s<o;++s)i[a+s]=t[e+s]+r[n+s]&255;}function hr(t,e,r,n,i,a,o){if(null==t)cr(null,null,r,n,i,a,o);else {var s,c=t[e+0],u=c,h=c;for(s=0;s<o;++s)u=h+(c=t[e+s])-u,h=r[n+s]+(-256&u?0>u?0:255:u)&255,u=c,i[a+s]=h;}}function lr(t,r,i,o){var s=r.width,c=r.o;if(e(null!=t&&null!=r),0>i||0>=o||i+o>c)return null;if(!t.Cc){if(null==t.ga){var u;if(t.ga=new sr,(u=null==t.ga)||(u=r.width*r.o,e(0==t.Gb.length),t.Gb=a(u),t.Uc=0,null==t.Gb?u=0:(t.mb=t.Gb,t.nb=t.Uc,t.rc=null,u=1),u=!u),!u){u=t.ga;var h=t.Fa,l=t.P,f=t.qc,d=t.mb,p=t.nb,g=l+1,m=f-1,b=u.l;if(e(null!=h&&null!=d&&null!=r),mi[0]=null,mi[1]=cr,mi[2]=ur,mi[3]=hr,u.ca=d,u.tb=p,u.c=r.width,u.i=r.height,e(0<u.c&&0<u.i),1>=f)r=0;else if(u.$a=h[l+0]>>0&3,u.Z=h[l+0]>>2&3,u.Lc=h[l+0]>>4&3,l=h[l+0]>>6&3,0>u.$a||1<u.$a||4<=u.Z||1<u.Lc||l)r=0;else if(b.put=dt,b.ac=ft,b.bc=pt,b.ma=u,b.width=r.width,b.height=r.height,b.Da=r.Da,b.v=r.v,b.va=r.va,b.j=r.j,b.o=r.o,u.$a)t:{e(1==u.$a),r=kt();e:for(;;){if(null==r){r=0;break t}if(e(null!=u),u.mc=r,r.c=u.c,r.i=u.i,r.l=u.l,r.l.ma=u,r.l.width=u.c,r.l.height=u.i,r.a=0,v(r.m,h,g,m),!It(u.c,u.i,1,r,null))break e;if(1==r.ab&&3==r.gc[0].hc&&At(r.s)?(u.ic=1,h=r.c*r.i,r.Ta=null,r.Ua=0,r.V=a(h),r.Ba=0,null==r.V?(r.a=1,r=0):r=1):(u.ic=0,r=Ft(r,u.c)),!r)break e;r=1;break t}u.mc=null,r=0;}else r=m>=u.c*u.i;u=!r;}if(u)return null;1!=t.ga.Lc?t.Ga=0:o=c-i;}e(null!=t.ga),e(i+o<=c);t:{if(r=(h=t.ga).c,c=h.l.o,0==h.$a){if(g=t.rc,m=t.Vc,b=t.Fa,l=t.P+1+i*r,f=t.mb,d=t.nb+i*r,e(l<=t.P+t.qc),0!=h.Z)for(e(null!=mi[h.Z]),u=0;u<o;++u)mi[h.Z](g,m,b,l,f,d,r),g=f,m=d,d+=r,l+=r;else for(u=0;u<o;++u)n(f,d,b,l,r),g=f,m=d,d+=r,l+=r;t.rc=g,t.Vc=m;}else {if(e(null!=h.mc),r=i+o,e(null!=(u=h.mc)),e(r<=u.i),u.C>=r)r=1;else if(h.ic||mr(),h.ic){h=u.V,g=u.Ba,m=u.c;var y=u.i,w=(b=1,l=u.$/m,f=u.$%m,d=u.m,p=u.s,u.$),N=m*y,L=m*r,x=p.wc,_=w<L?wt(p,f,l):null;e(w<=N),e(r<=y),e(At(p));e:for(;;){for(;!d.h&&w<L;){if(f&x||(_=wt(p,f,l)),e(null!=_),S(d),256>(y=bt(_.G[0],_.H[0],d)))h[g+w]=y,++w,++f>=m&&(f=0,++l<=r&&!(l%16)&&St(u,l));else {if(!(280>y)){b=0;break e}y=mt(y-256,d);var P,k=bt(_.G[4],_.H[4],d);if(S(d),!(w>=(k=vt(m,k=mt(k,d)))&&N-w>=y)){b=0;break e}for(P=0;P<y;++P)h[g+w+P]=h[g+w+P-k];for(w+=y,f+=y;f>=m;)f-=m,++l<=r&&!(l%16)&&St(u,l);w<L&&f&x&&(_=wt(p,f,l));}e(d.h==A(d));}St(u,l>r?r:l);break e}!b||d.h&&w<N?(b=0,u.a=d.h?5:3):u.$=w,r=b;}else r=_t(u,u.V,u.Ba,u.c,u.i,r,Ct);if(!r){o=0;break t}}i+o>=c&&(t.Cc=1),o=1;}if(!o)return null;if(t.Cc&&(null!=(o=t.ga)&&(o.mc=null),t.ga=null,0<t.Ga))return alert("todo:WebPDequantizeLevels"),null}return t.nb+i*s}function fr(t,e,r,n,i,a){for(;0<i--;){var o,s=t,c=e+(r?1:0),u=t,h=e+(r?0:3);for(o=0;o<n;++o){var l=u[h+4*o];255!=l&&(l*=32897,s[c+4*o+0]=s[c+4*o+0]*l>>23,s[c+4*o+1]=s[c+4*o+1]*l>>23,s[c+4*o+2]=s[c+4*o+2]*l>>23);}e+=a;}}function dr(t,e,r,n,i){for(;0<n--;){var a;for(a=0;a<r;++a){var o=t[e+2*a+0],s=15&(u=t[e+2*a+1]),c=4369*s,u=(240&u|u>>4)*c>>16;t[e+2*a+0]=(240&o|o>>4)*c>>16&240|(15&o|o<<4)*c>>16>>4&15,t[e+2*a+1]=240&u|s;}e+=i;}}function pr(t,e,r,n,i,a,o,s){var c,u,h=255;for(u=0;u<i;++u){for(c=0;c<n;++c){var l=t[e+c];a[o+4*c]=l,h&=l;}e+=r,o+=s;}return 255!=h}function gr(t,e,r,n,i){var a;for(a=0;a<i;++a)r[n+a]=t[e+a]>>8;}function mr(){An=fr,xn=dr,Sn=pr,_n=gr;}function vr(r,n,i){t[r]=function(t,r,a,o,s,c,u,h,l,f,d,p,g,m,v,b,y){var w,N=y-1>>1,L=s[c+0]|u[h+0]<<16,A=l[f+0]|d[p+0]<<16;e(null!=t);var x=3*L+A+131074>>2;for(n(t[r+0],255&x,x>>16,g,m),null!=a&&(x=3*A+L+131074>>2,n(a[o+0],255&x,x>>16,v,b)),w=1;w<=N;++w){var S=s[c+w]|u[h+w]<<16,_=l[f+w]|d[p+w]<<16,P=L+S+A+_+524296,k=P+2*(S+A)>>3;x=k+L>>1,L=(P=P+2*(L+_)>>3)+S>>1,n(t[r+2*w-1],255&x,x>>16,g,m+(2*w-1)*i),n(t[r+2*w-0],255&L,L>>16,g,m+(2*w-0)*i),null!=a&&(x=P+A>>1,L=k+_>>1,n(a[o+2*w-1],255&x,x>>16,v,b+(2*w-1)*i),n(a[o+2*w+0],255&L,L>>16,v,b+(2*w+0)*i)),L=S,A=_;}1&y||(x=3*L+A+131074>>2,n(t[r+y-1],255&x,x>>16,g,m+(y-1)*i),null!=a&&(x=3*A+L+131074>>2,n(a[o+y-1],255&x,x>>16,v,b+(y-1)*i)));};}function br(){vi[En]=bi,vi[qn]=wi,vi[Dn]=yi,vi[Rn]=Ni,vi[Tn]=Li,vi[Un]=Ai,vi[zn]=xi,vi[Hn]=wi,vi[Wn]=Ni,vi[Vn]=Li,vi[Gn]=Ai;}function yr(t){return t&~Fi?0>t?0:255:t>>Ii}function wr(t,e){return yr((19077*t>>8)+(26149*e>>8)-14234)}function Nr(t,e,r){return yr((19077*t>>8)-(6419*e>>8)-(13320*r>>8)+8708)}function Lr(t,e){return yr((19077*t>>8)+(33050*e>>8)-17685)}function Ar(t,e,r,n,i){n[i+0]=wr(t,r),n[i+1]=Nr(t,e,r),n[i+2]=Lr(t,e);}function xr(t,e,r,n,i){n[i+0]=Lr(t,e),n[i+1]=Nr(t,e,r),n[i+2]=wr(t,r);}function Sr(t,e,r,n,i){var a=Nr(t,e,r);e=a<<3&224|Lr(t,e)>>3,n[i+0]=248&wr(t,r)|a>>5,n[i+1]=e;}function _r(t,e,r,n,i){var a=240&Lr(t,e)|15;n[i+0]=240&wr(t,r)|Nr(t,e,r)>>4,n[i+1]=a;}function Pr(t,e,r,n,i){n[i+0]=255,Ar(t,e,r,n,i+1);}function kr(t,e,r,n,i){xr(t,e,r,n,i),n[i+3]=255;}function Ir(t,e,r,n,i){Ar(t,e,r,n,i),n[i+3]=255;}function Vt(t,e){return 0>t?0:t>e?e:t}function Fr(e,r,n){t[e]=function(t,e,i,a,o,s,c,u,h){for(var l=u+(-2&h)*n;u!=l;)r(t[e+0],i[a+0],o[s+0],c,u),r(t[e+1],i[a+0],o[s+0],c,u+n),e+=2,++a,++s,u+=2*n;1&h&&r(t[e+0],i[a+0],o[s+0],c,u);};}function Cr(t,e,r){return 0==r?0==t?0==e?6:5:0==e?4:0:r}function jr(t,e,r,n,i){switch(t>>>30){case 3:on(e,r,n,i,0);break;case 2:sn(e,r,n,i);break;case 1:un(e,r,n,i);}}function Or(t,e){var r,a,o=e.M,s=e.Nb,c=t.oc,u=t.pc+40,h=t.oc,l=t.pc+584,f=t.oc,d=t.pc+600;for(r=0;16>r;++r)c[u+32*r-1]=129;for(r=0;8>r;++r)h[l+32*r-1]=129,f[d+32*r-1]=129;for(0<o?c[u-1-32]=h[l-1-32]=f[d-1-32]=129:(i(c,u-32-1,127,21),i(h,l-32-1,127,9),i(f,d-32-1,127,9)),a=0;a<t.za;++a){var p=e.ya[e.aa+a];if(0<a){for(r=-1;16>r;++r)n(c,u+32*r-4,c,u+32*r+12,4);for(r=-1;8>r;++r)n(h,l+32*r-4,h,l+32*r+4,4),n(f,d+32*r-4,f,d+32*r+4,4);}var g=t.Gd,m=t.Hd+a,v=p.ad,b=p.Hc;if(0<o&&(n(c,u-32,g[m].y,0,16),n(h,l-32,g[m].f,0,8),n(f,d-32,g[m].ea,0,8)),p.Za){var y=c,w=u-32+16;for(0<o&&(a>=t.za-1?i(y,w,g[m].y[15],4):n(y,w,g[m+1].y,0,4)),r=0;4>r;r++)y[w+128+r]=y[w+256+r]=y[w+384+r]=y[w+0+r];for(r=0;16>r;++r,b<<=2)y=c,w=u+Di[r],fi[p.Ob[r]](y,w),jr(b,v,16*+r,y,w);}else if(y=Cr(a,o,p.Ob[0]),li[y](c,u),0!=b)for(r=0;16>r;++r,b<<=2)jr(b,v,16*+r,c,u+Di[r]);for(r=p.Gc,y=Cr(a,o,p.Dd),di[y](h,l),di[y](f,d),b=v,y=h,w=l,255&(p=r>>0)&&(170&p?cn(b,256,y,w):hn(b,256,y,w)),p=f,b=d,255&(r>>=8)&&(170&r?cn(v,320,p,b):hn(v,320,p,b)),o<t.Ub-1&&(n(g[m].y,0,c,u+480,16),n(g[m].f,0,h,l+224,8),n(g[m].ea,0,f,d+224,8)),r=8*s*t.B,g=t.sa,m=t.ta+16*a+16*s*t.R,v=t.qa,p=t.ra+8*a+r,b=t.Ha,y=t.Ia+8*a+r,r=0;16>r;++r)n(g,m+r*t.R,c,u+32*r,16);for(r=0;8>r;++r)n(v,p+r*t.B,h,l+32*r,8),n(b,y+r*t.B,f,d+32*r,8);}}function Br(t,n,i,a,o,s,c,u,h){var l=[0],f=[0],d=0,p=null!=h?h.kd:0,g=null!=h?h:new nr;if(null==t||12>i)return 7;g.data=t,g.w=n,g.ha=i,n=[n],i=[i],g.gb=[g.gb];t:{var m=n,b=i,y=g.gb;if(e(null!=t),e(null!=b),e(null!=y),y[0]=0,12<=b[0]&&!r(t,m[0],"RIFF")){if(r(t,m[0]+8,"WEBP")){y=3;break t}var w=j(t,m[0]+4);if(12>w||4294967286<w){y=3;break t}if(p&&w>b[0]-8){y=7;break t}y[0]=w,m[0]+=12,b[0]-=12;}y=0;}if(0!=y)return y;for(w=0<g.gb[0],i=i[0];;){t:{var L=t;b=n,y=i;var A=l,x=f,S=m=[0];if((k=d=[d])[0]=0,8>y[0])y=7;else {if(!r(L,b[0],"VP8X")){if(10!=j(L,b[0]+4)){y=3;break t}if(18>y[0]){y=7;break t}var _=j(L,b[0]+8),P=1+C(L,b[0]+12);if(2147483648<=P*(L=1+C(L,b[0]+15))){y=3;break t}null!=S&&(S[0]=_),null!=A&&(A[0]=P),null!=x&&(x[0]=L),b[0]+=18,y[0]-=18,k[0]=1;}y=0;}}if(d=d[0],m=m[0],0!=y)return y;if(b=!!(2&m),!w&&d)return 3;if(null!=s&&(s[0]=!!(16&m)),null!=c&&(c[0]=b),null!=u&&(u[0]=0),c=l[0],m=f[0],d&&b&&null==h){y=0;break}if(4>i){y=7;break}if(w&&d||!w&&!d&&!r(t,n[0],"ALPH")){i=[i],g.na=[g.na],g.P=[g.P],g.Sa=[g.Sa];t:{_=t,y=n,w=i;var k=g.gb;A=g.na,x=g.P,S=g.Sa;P=22,e(null!=_),e(null!=w),L=y[0];var I=w[0];for(e(null!=A),e(null!=S),A[0]=null,x[0]=null,S[0]=0;;){if(y[0]=L,w[0]=I,8>I){y=7;break t}var F=j(_,L+4);if(4294967286<F){y=3;break t}var O=8+F+1&-2;if(P+=O,0<k&&P>k){y=3;break t}if(!r(_,L,"VP8 ")||!r(_,L,"VP8L")){y=0;break t}if(I[0]<O){y=7;break t}r(_,L,"ALPH")||(A[0]=_,x[0]=L+8,S[0]=F),L+=O,I-=O;}}if(i=i[0],g.na=g.na[0],g.P=g.P[0],g.Sa=g.Sa[0],0!=y)break}i=[i],g.Ja=[g.Ja],g.xa=[g.xa];t:if(k=t,y=n,w=i,A=g.gb[0],x=g.Ja,S=g.xa,_=y[0],L=!r(k,_,"VP8 "),P=!r(k,_,"VP8L"),e(null!=k),e(null!=w),e(null!=x),e(null!=S),8>w[0])y=7;else {if(L||P){if(k=j(k,_+4),12<=A&&k>A-12){y=3;break t}if(p&&k>w[0]-8){y=7;break t}x[0]=k,y[0]+=8,w[0]-=8,S[0]=P;}else S[0]=5<=w[0]&&47==k[_+0]&&!(k[_+4]>>5),x[0]=w[0];y=0;}if(i=i[0],g.Ja=g.Ja[0],g.xa=g.xa[0],n=n[0],0!=y)break;if(4294967286<g.Ja)return 3;if(null==u||b||(u[0]=g.xa?2:1),c=[c],m=[m],g.xa){if(5>i){y=7;break}u=c,p=m,b=s,null==t||5>i?t=0:5<=i&&47==t[n+0]&&!(t[n+4]>>5)?(w=[0],k=[0],A=[0],v(x=new N,t,n,i),gt(x,w,k,A)?(null!=u&&(u[0]=w[0]),null!=p&&(p[0]=k[0]),null!=b&&(b[0]=A[0]),t=1):t=0):t=0;}else {if(10>i){y=7;break}u=m,null==t||10>i||!Xt(t,n+3,i-3)?t=0:(p=t[n+0]|t[n+1]<<8|t[n+2]<<16,b=16383&(t[n+7]<<8|t[n+6]),t=16383&(t[n+9]<<8|t[n+8]),1&p||3<(p>>1&7)||!(p>>4&1)||p>>5>=g.Ja||!b||!t?t=0:(c&&(c[0]=b),u&&(u[0]=t),t=1));}if(!t)return 3;if(c=c[0],m=m[0],d&&(l[0]!=c||f[0]!=m))return 3;null!=h&&(h[0]=g,h.offset=n-h.w,e(4294967286>n-h.w),e(h.offset==h.ha-i));break}return 0==y||7==y&&d&&null==h?(null!=s&&(s[0]|=null!=g.na&&0<g.na.length),null!=a&&(a[0]=c),null!=o&&(o[0]=m),0):y}function Mr(t,e,r){var n=e.width,i=e.height,a=0,o=0,s=n,c=i;if(e.Da=null!=t&&0<t.Da,e.Da&&(s=t.cd,c=t.bd,a=t.v,o=t.j,11>r||(a&=-2,o&=-2),0>a||0>o||0>=s||0>=c||a+s>n||o+c>i))return 0;if(e.v=a,e.j=o,e.va=a+s,e.o=o+c,e.U=s,e.T=c,e.da=null!=t&&0<t.da,e.da){if(!E(s,c,r=[t.ib],a=[t.hb]))return 0;e.ib=r[0],e.hb=a[0];}return e.ob=null!=t&&t.ob,e.Kb=null==t||!t.Sd,e.da&&(e.ob=e.ib<3*n/4&&e.hb<3*i/4,e.Kb=0),1}function Er(t){if(null==t)return 2;if(11>t.S){var e=t.f.RGBA;e.fb+=(t.height-1)*e.A,e.A=-e.A;}else e=t.f.kb,t=t.height,e.O+=(t-1)*e.fa,e.fa=-e.fa,e.N+=(t-1>>1)*e.Ab,e.Ab=-e.Ab,e.W+=(t-1>>1)*e.Db,e.Db=-e.Db,null!=e.F&&(e.J+=(t-1)*e.lb,e.lb=-e.lb);return 0}function qr(t,e,r,n){if(null==n||0>=t||0>=e)return 2;if(null!=r){if(r.Da){var i=r.cd,o=r.bd,s=-2&r.v,c=-2&r.j;if(0>s||0>c||0>=i||0>=o||s+i>t||c+o>e)return 2;t=i,e=o;}if(r.da){if(!E(t,e,i=[r.ib],o=[r.hb]))return 2;t=i[0],e=o[0];}}n.width=t,n.height=e;t:{var u=n.width,h=n.height;if(t=n.S,0>=u||0>=h||!(t>=En&&13>t))t=2;else {if(0>=n.Rd&&null==n.sd){s=o=i=e=0;var l=(c=u*zi[t])*h;if(11>t||(o=(h+1)/2*(e=(u+1)/2),12==t&&(s=(i=u)*h)),null==(h=a(l+2*o+s))){t=1;break t}n.sd=h,11>t?((u=n.f.RGBA).eb=h,u.fb=0,u.A=c,u.size=l):((u=n.f.kb).y=h,u.O=0,u.fa=c,u.Fd=l,u.f=h,u.N=0+l,u.Ab=e,u.Cd=o,u.ea=h,u.W=0+l+o,u.Db=e,u.Ed=o,12==t&&(u.F=h,u.J=0+l+2*o),u.Tc=s,u.lb=i);}if(e=1,i=n.S,o=n.width,s=n.height,i>=En&&13>i)if(11>i)t=n.f.RGBA,e&=(c=Math.abs(t.A))*(s-1)+o<=t.size,e&=c>=o*zi[i],e&=null!=t.eb;else {t=n.f.kb,c=(o+1)/2,l=(s+1)/2,u=Math.abs(t.fa);h=Math.abs(t.Ab);var f=Math.abs(t.Db),d=Math.abs(t.lb),p=d*(s-1)+o;e&=u*(s-1)+o<=t.Fd,e&=h*(l-1)+c<=t.Cd,e=(e&=f*(l-1)+c<=t.Ed)&u>=o&h>=c&f>=c,e&=null!=t.y,e&=null!=t.f,e&=null!=t.ea,12==i&&(e&=d>=o,e&=p<=t.Tc,e&=null!=t.F);}else e=0;t=e?0:2;}}return 0!=t||null!=r&&r.fd&&(t=Er(n)),t}var Dr=64,Rr=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215],Tr=24,Ur=32,zr=8,Hr=[0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7];R("Predictor0","PredictorAdd0"),t.Predictor0=function(){return 4278190080},t.Predictor1=function(t){return t},t.Predictor2=function(t,e,r){return e[r+0]},t.Predictor3=function(t,e,r){return e[r+1]},t.Predictor4=function(t,e,r){return e[r-1]},t.Predictor5=function(t,e,r){return U(U(t,e[r+1]),e[r+0])},t.Predictor6=function(t,e,r){return U(t,e[r-1])},t.Predictor7=function(t,e,r){return U(t,e[r+0])},t.Predictor8=function(t,e,r){return U(e[r-1],e[r+0])},t.Predictor9=function(t,e,r){return U(e[r+0],e[r+1])},t.Predictor10=function(t,e,r){return U(U(t,e[r-1]),U(e[r+0],e[r+1]))},t.Predictor11=function(t,e,r){var n=e[r+0];return 0>=W(n>>24&255,t>>24&255,(e=e[r-1])>>24&255)+W(n>>16&255,t>>16&255,e>>16&255)+W(n>>8&255,t>>8&255,e>>8&255)+W(255&n,255&t,255&e)?n:t},t.Predictor12=function(t,e,r){var n=e[r+0];return (z((t>>24&255)+(n>>24&255)-((e=e[r-1])>>24&255))<<24|z((t>>16&255)+(n>>16&255)-(e>>16&255))<<16|z((t>>8&255)+(n>>8&255)-(e>>8&255))<<8|z((255&t)+(255&n)-(255&e)))>>>0},t.Predictor13=function(t,e,r){var n=e[r-1];return (H((t=U(t,e[r+0]))>>24&255,n>>24&255)<<24|H(t>>16&255,n>>16&255)<<16|H(t>>8&255,n>>8&255)<<8|H(t>>0&255,n>>0&255))>>>0};var Wr=t.PredictorAdd0;t.PredictorAdd1=V,R("Predictor2","PredictorAdd2"),R("Predictor3","PredictorAdd3"),R("Predictor4","PredictorAdd4"),R("Predictor5","PredictorAdd5"),R("Predictor6","PredictorAdd6"),R("Predictor7","PredictorAdd7"),R("Predictor8","PredictorAdd8"),R("Predictor9","PredictorAdd9"),R("Predictor10","PredictorAdd10"),R("Predictor11","PredictorAdd11"),R("Predictor12","PredictorAdd12"),R("Predictor13","PredictorAdd13");var Vr=t.PredictorAdd2;X("ColorIndexInverseTransform","MapARGB","32b",(function(t){return t>>8&255}),(function(t){return t})),X("VP8LColorIndexInverseTransformAlpha","MapAlpha","8b",(function(t){return t}),(function(t){return t>>8&255}));var Gr,Yr=t.ColorIndexInverseTransform,Jr=t.MapARGB,Xr=t.VP8LColorIndexInverseTransformAlpha,Kr=t.MapAlpha,Zr=t.VP8LPredictorsAdd=[];Zr.length=16,(t.VP8LPredictors=[]).length=16,(t.VP8LPredictorsAdd_C=[]).length=16,(t.VP8LPredictors_C=[]).length=16;var $r,Qr,tn,en,rn,nn,an,on,sn,cn,un,hn,ln,fn,dn,pn,gn,mn,vn,bn,yn,wn,Nn,Ln,An,xn,Sn,_n,Pn=a(511),kn=a(2041),In=a(225),Fn=a(767),Cn=0,jn=kn,On=In,Bn=Fn,Mn=Pn,En=0,qn=1,Dn=2,Rn=3,Tn=4,Un=5,zn=6,Hn=7,Wn=8,Vn=9,Gn=10,Yn=[2,3,7],Jn=[3,3,11],Xn=[280,256,256,256,40],Kn=[0,1,1,1,0],Zn=[17,18,0,1,2,3,4,5,16,6,7,8,9,10,11,12,13,14,15],$n=[24,7,23,25,40,6,39,41,22,26,38,42,56,5,55,57,21,27,54,58,37,43,72,4,71,73,20,28,53,59,70,74,36,44,88,69,75,52,60,3,87,89,19,29,86,90,35,45,68,76,85,91,51,61,104,2,103,105,18,30,102,106,34,46,84,92,67,77,101,107,50,62,120,1,119,121,83,93,17,31,100,108,66,78,118,122,33,47,117,123,49,63,99,109,82,94,0,116,124,65,79,16,32,98,110,48,115,125,81,95,64,114,126,97,111,80,113,127,96,112],Qn=[2954,2956,2958,2962,2970,2986,3018,3082,3212,3468,3980,5004],ti=8,ei=[4,5,6,7,8,9,10,10,11,12,13,14,15,16,17,17,18,19,20,20,21,21,22,22,23,23,24,25,25,26,27,28,29,30,31,32,33,34,35,36,37,37,38,39,40,41,42,43,44,45,46,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,93,95,96,98,100,101,102,104,106,108,110,112,114,116,118,122,124,126,128,130,132,134,136,138,140,143,145,148,151,154,157],ri=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,177,181,185,189,193,197,201,205,209,213,217,221,225,229,234,239,245,249,254,259,264,269,274,279,284],ni=null,ii=[[173,148,140,0],[176,155,140,135,0],[180,157,141,134,130,0],[254,254,243,230,196,177,153,140,133,130,129,0]],ai=[0,1,4,8,5,2,3,6,9,12,13,10,7,11,14,15],oi=[-0,1,-1,2,-2,3,4,6,-3,5,-4,-5,-6,7,-7,8,-8,-9],si=[[[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]],[[253,136,254,255,228,219,128,128,128,128,128],[189,129,242,255,227,213,255,219,128,128,128],[106,126,227,252,214,209,255,255,128,128,128]],[[1,98,248,255,236,226,255,255,128,128,128],[181,133,238,254,221,234,255,154,128,128,128],[78,134,202,247,198,180,255,219,128,128,128]],[[1,185,249,255,243,255,128,128,128,128,128],[184,150,247,255,236,224,128,128,128,128,128],[77,110,216,255,236,230,128,128,128,128,128]],[[1,101,251,255,241,255,128,128,128,128,128],[170,139,241,252,236,209,255,255,128,128,128],[37,116,196,243,228,255,255,255,128,128,128]],[[1,204,254,255,245,255,128,128,128,128,128],[207,160,250,255,238,128,128,128,128,128,128],[102,103,231,255,211,171,128,128,128,128,128]],[[1,152,252,255,240,255,128,128,128,128,128],[177,135,243,255,234,225,128,128,128,128,128],[80,129,211,255,194,224,128,128,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[246,1,255,128,128,128,128,128,128,128,128],[255,128,128,128,128,128,128,128,128,128,128]]],[[[198,35,237,223,193,187,162,160,145,155,62],[131,45,198,221,172,176,220,157,252,221,1],[68,47,146,208,149,167,221,162,255,223,128]],[[1,149,241,255,221,224,255,255,128,128,128],[184,141,234,253,222,220,255,199,128,128,128],[81,99,181,242,176,190,249,202,255,255,128]],[[1,129,232,253,214,197,242,196,255,255,128],[99,121,210,250,201,198,255,202,128,128,128],[23,91,163,242,170,187,247,210,255,255,128]],[[1,200,246,255,234,255,128,128,128,128,128],[109,178,241,255,231,245,255,255,128,128,128],[44,130,201,253,205,192,255,255,128,128,128]],[[1,132,239,251,219,209,255,165,128,128,128],[94,136,225,251,218,190,255,255,128,128,128],[22,100,174,245,186,161,255,199,128,128,128]],[[1,182,249,255,232,235,128,128,128,128,128],[124,143,241,255,227,234,128,128,128,128,128],[35,77,181,251,193,211,255,205,128,128,128]],[[1,157,247,255,236,231,255,255,128,128,128],[121,141,235,255,225,227,255,255,128,128,128],[45,99,188,251,195,217,255,224,128,128,128]],[[1,1,251,255,213,255,128,128,128,128,128],[203,1,248,255,255,128,128,128,128,128,128],[137,1,177,255,224,255,128,128,128,128,128]]],[[[253,9,248,251,207,208,255,192,128,128,128],[175,13,224,243,193,185,249,198,255,255,128],[73,17,171,221,161,179,236,167,255,234,128]],[[1,95,247,253,212,183,255,255,128,128,128],[239,90,244,250,211,209,255,255,128,128,128],[155,77,195,248,188,195,255,255,128,128,128]],[[1,24,239,251,218,219,255,205,128,128,128],[201,51,219,255,196,186,128,128,128,128,128],[69,46,190,239,201,218,255,228,128,128,128]],[[1,191,251,255,255,128,128,128,128,128,128],[223,165,249,255,213,255,128,128,128,128,128],[141,124,248,255,255,128,128,128,128,128,128]],[[1,16,248,255,255,128,128,128,128,128,128],[190,36,230,255,236,255,128,128,128,128,128],[149,1,255,128,128,128,128,128,128,128,128]],[[1,226,255,128,128,128,128,128,128,128,128],[247,192,255,128,128,128,128,128,128,128,128],[240,128,255,128,128,128,128,128,128,128,128]],[[1,134,252,255,255,128,128,128,128,128,128],[213,62,250,255,255,128,128,128,128,128,128],[55,93,255,128,128,128,128,128,128,128,128]],[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]]],[[[202,24,213,235,186,191,220,160,240,175,255],[126,38,182,232,169,184,228,174,255,187,128],[61,46,138,219,151,178,240,170,255,216,128]],[[1,112,230,250,199,191,247,159,255,255,128],[166,109,228,252,211,215,255,174,128,128,128],[39,77,162,232,172,180,245,178,255,255,128]],[[1,52,220,246,198,199,249,220,255,255,128],[124,74,191,243,183,193,250,221,255,255,128],[24,71,130,219,154,170,243,182,255,255,128]],[[1,182,225,249,219,240,255,224,128,128,128],[149,150,226,252,216,205,255,171,128,128,128],[28,108,170,242,183,194,254,223,255,255,128]],[[1,81,230,252,204,203,255,192,128,128,128],[123,102,209,247,188,196,255,233,128,128,128],[20,95,153,243,164,173,255,203,128,128,128]],[[1,222,248,255,216,213,128,128,128,128,128],[168,175,246,252,235,205,255,255,128,128,128],[47,116,215,255,211,212,255,255,128,128,128]],[[1,121,236,253,212,214,255,255,128,128,128],[141,84,213,252,201,202,255,219,128,128,128],[42,80,160,240,162,185,255,205,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[244,1,255,128,128,128,128,128,128,128,128],[238,1,255,128,128,128,128,128,128,128,128]]]],ci=[[[231,120,48,89,115,113,120,152,112],[152,179,64,126,170,118,46,70,95],[175,69,143,80,85,82,72,155,103],[56,58,10,171,218,189,17,13,152],[114,26,17,163,44,195,21,10,173],[121,24,80,195,26,62,44,64,85],[144,71,10,38,171,213,144,34,26],[170,46,55,19,136,160,33,206,71],[63,20,8,114,114,208,12,9,226],[81,40,11,96,182,84,29,16,36]],[[134,183,89,137,98,101,106,165,148],[72,187,100,130,157,111,32,75,80],[66,102,167,99,74,62,40,234,128],[41,53,9,178,241,141,26,8,107],[74,43,26,146,73,166,49,23,157],[65,38,105,160,51,52,31,115,128],[104,79,12,27,217,255,87,17,7],[87,68,71,44,114,51,15,186,23],[47,41,14,110,182,183,21,17,194],[66,45,25,102,197,189,23,18,22]],[[88,88,147,150,42,46,45,196,205],[43,97,183,117,85,38,35,179,61],[39,53,200,87,26,21,43,232,171],[56,34,51,104,114,102,29,93,77],[39,28,85,171,58,165,90,98,64],[34,22,116,206,23,34,43,166,73],[107,54,32,26,51,1,81,43,31],[68,25,106,22,64,171,36,225,114],[34,19,21,102,132,188,16,76,124],[62,18,78,95,85,57,50,48,51]],[[193,101,35,159,215,111,89,46,111],[60,148,31,172,219,228,21,18,111],[112,113,77,85,179,255,38,120,114],[40,42,1,196,245,209,10,25,109],[88,43,29,140,166,213,37,43,154],[61,63,30,155,67,45,68,1,209],[100,80,8,43,154,1,51,26,71],[142,78,78,16,255,128,34,197,171],[41,40,5,102,211,183,4,1,221],[51,50,17,168,209,192,23,25,82]],[[138,31,36,171,27,166,38,44,229],[67,87,58,169,82,115,26,59,179],[63,59,90,180,59,166,93,73,154],[40,40,21,116,143,209,34,39,175],[47,15,16,183,34,223,49,45,183],[46,17,33,183,6,98,15,32,183],[57,46,22,24,128,1,54,17,37],[65,32,73,115,28,128,23,128,205],[40,3,9,115,51,192,18,6,223],[87,37,9,115,59,77,64,21,47]],[[104,55,44,218,9,54,53,130,226],[64,90,70,205,40,41,23,26,57],[54,57,112,184,5,41,38,166,213],[30,34,26,133,152,116,10,32,134],[39,19,53,221,26,114,32,73,255],[31,9,65,234,2,15,1,118,73],[75,32,12,51,192,255,160,43,51],[88,31,35,67,102,85,55,186,85],[56,21,23,111,59,205,45,37,192],[55,38,70,124,73,102,1,34,98]],[[125,98,42,88,104,85,117,175,82],[95,84,53,89,128,100,113,101,45],[75,79,123,47,51,128,81,171,1],[57,17,5,71,102,57,53,41,49],[38,33,13,121,57,73,26,1,85],[41,10,67,138,77,110,90,47,114],[115,21,2,10,102,255,166,23,6],[101,29,16,10,85,128,101,196,26],[57,18,10,102,102,213,34,20,43],[117,20,15,36,163,128,68,1,26]],[[102,61,71,37,34,53,31,243,192],[69,60,71,38,73,119,28,222,37],[68,45,128,34,1,47,11,245,171],[62,17,19,70,146,85,55,62,70],[37,43,37,154,100,163,85,160,1],[63,9,92,136,28,64,32,201,85],[75,15,9,9,64,255,184,119,16],[86,6,28,5,64,255,25,248,1],[56,8,17,132,137,255,55,116,128],[58,15,20,82,135,57,26,121,40]],[[164,50,31,137,154,133,25,35,218],[51,103,44,131,131,123,31,6,158],[86,40,64,135,148,224,45,183,128],[22,26,17,131,240,154,14,1,209],[45,16,21,91,64,222,7,1,197],[56,21,39,155,60,138,23,102,213],[83,12,13,54,192,255,68,47,28],[85,26,85,85,128,128,32,146,171],[18,11,7,63,144,171,4,4,246],[35,27,10,146,174,171,12,26,128]],[[190,80,35,99,180,80,126,54,45],[85,126,47,87,176,51,41,20,32],[101,75,128,139,118,146,116,128,85],[56,41,15,176,236,85,37,9,62],[71,30,17,119,118,255,17,18,138],[101,38,60,138,55,70,43,26,142],[146,36,19,30,171,255,97,27,20],[138,45,61,62,219,1,81,188,64],[32,41,20,117,151,142,20,21,163],[112,19,12,61,195,128,48,4,24]]],ui=[[[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[176,246,255,255,255,255,255,255,255,255,255],[223,241,252,255,255,255,255,255,255,255,255],[249,253,253,255,255,255,255,255,255,255,255]],[[255,244,252,255,255,255,255,255,255,255,255],[234,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255]],[[255,246,254,255,255,255,255,255,255,255,255],[239,253,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[251,255,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[251,254,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,254,253,255,254,255,255,255,255,255,255],[250,255,254,255,254,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[217,255,255,255,255,255,255,255,255,255,255],[225,252,241,253,255,255,254,255,255,255,255],[234,250,241,250,253,255,253,254,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[223,254,254,255,255,255,255,255,255,255,255],[238,253,254,254,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[249,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,255,255,255,255,255,255,255,255,255],[247,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[252,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[186,251,250,255,255,255,255,255,255,255,255],[234,251,244,254,255,255,255,255,255,255,255],[251,251,243,253,254,255,254,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[236,253,254,255,255,255,255,255,255,255,255],[251,253,253,254,254,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[254,254,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[254,254,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[248,255,255,255,255,255,255,255,255,255,255],[250,254,252,254,255,255,255,255,255,255,255],[248,254,249,253,255,255,255,255,255,255,255]],[[255,253,253,255,255,255,255,255,255,255,255],[246,253,253,255,255,255,255,255,255,255,255],[252,254,251,254,254,255,255,255,255,255,255]],[[255,254,252,255,255,255,255,255,255,255,255],[248,254,253,255,255,255,255,255,255,255,255],[253,255,254,254,255,255,255,255,255,255,255]],[[255,251,254,255,255,255,255,255,255,255,255],[245,251,254,255,255,255,255,255,255,255,255],[253,253,254,255,255,255,255,255,255,255,255]],[[255,251,253,255,255,255,255,255,255,255,255],[252,253,254,255,255,255,255,255,255,255,255],[255,254,255,255,255,255,255,255,255,255,255]],[[255,252,255,255,255,255,255,255,255,255,255],[249,255,254,255,255,255,255,255,255,255,255],[255,255,254,255,255,255,255,255,255,255,255]],[[255,255,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]]],hi=[0,1,2,3,6,4,5,6,6,6,6,6,6,6,6,7,0],li=[],fi=[],di=[],pi=1,gi=2,mi=[],vi=[];vr("UpsampleRgbLinePair",Ar,3),vr("UpsampleBgrLinePair",xr,3),vr("UpsampleRgbaLinePair",Ir,4),vr("UpsampleBgraLinePair",kr,4),vr("UpsampleArgbLinePair",Pr,4),vr("UpsampleRgba4444LinePair",_r,2),vr("UpsampleRgb565LinePair",Sr,2);var bi=t.UpsampleRgbLinePair,yi=t.UpsampleBgrLinePair,wi=t.UpsampleRgbaLinePair,Ni=t.UpsampleBgraLinePair,Li=t.UpsampleArgbLinePair,Ai=t.UpsampleRgba4444LinePair,xi=t.UpsampleRgb565LinePair,Si=16,_i=1<<Si-1,Pi=-227,ki=482,Ii=6,Fi=(256<<Ii)-1,Ci=0,ji=a(256),Oi=a(256),Bi=a(256),Mi=a(256),Ei=a(ki-Pi),qi=a(ki-Pi);Fr("YuvToRgbRow",Ar,3),Fr("YuvToBgrRow",xr,3),Fr("YuvToRgbaRow",Ir,4),Fr("YuvToBgraRow",kr,4),Fr("YuvToArgbRow",Pr,4),Fr("YuvToRgba4444Row",_r,2),Fr("YuvToRgb565Row",Sr,2);var Di=[0,4,8,12,128,132,136,140,256,260,264,268,384,388,392,396],Ri=[0,2,8],Ti=[8,7,6,4,4,2,2,2,1,1,1,1],Ui=1;this.WebPDecodeRGBA=function(t,r,n,i,a){var o=qn,s=new rr,c=new ot;s.ba=c,c.S=o,c.width=[c.width],c.height=[c.height];var u=c.width,h=c.height,l=new st;if(null==l||null==t)var f=2;else e(null!=l),f=Br(t,r,n,l.width,l.height,l.Pd,l.Qd,l.format,null);if(0!=f?u=0:(null!=u&&(u[0]=l.width[0]),null!=h&&(h[0]=l.height[0]),u=1),u){c.width=c.width[0],c.height=c.height[0],null!=i&&(i[0]=c.width),null!=a&&(a[0]=c.height);t:{if(i=new Gt,(a=new nr).data=t,a.w=r,a.ha=n,a.kd=1,r=[0],e(null!=a),(0==(t=Br(a.data,a.w,a.ha,null,null,null,r,null,a))||7==t)&&r[0]&&(t=4),0==(r=t)){if(e(null!=s),i.data=a.data,i.w=a.w+a.offset,i.ha=a.ha-a.offset,i.put=dt,i.ac=ft,i.bc=pt,i.ma=s,a.xa){if(null==(t=kt())){s=1;break t}if(function(t,r){var n=[0],i=[0],a=[0];e:for(;;){if(null==t)return 0;if(null==r)return t.a=2,0;if(t.l=r,t.a=0,v(t.m,r.data,r.w,r.ha),!gt(t.m,n,i,a)){t.a=3;break e}if(t.xb=gi,r.width=n[0],r.height=i[0],!It(n[0],i[0],1,t,null))break e;return 1}return e(0!=t.a),0}(t,i)){if(i=0==(r=qr(i.width,i.height,s.Oa,s.ba))){e:{i=t;r:for(;;){if(null==i){i=0;break e}if(e(null!=i.s.yc),e(null!=i.s.Ya),e(0<i.s.Wb),e(null!=(n=i.l)),e(null!=(a=n.ma)),0!=i.xb){if(i.ca=a.ba,i.tb=a.tb,e(null!=i.ca),!Mr(a.Oa,n,Rn)){i.a=2;break r}if(!Ft(i,n.width))break r;if(n.da)break r;if((n.da||nt(i.ca.S))&&mr(),11>i.ca.S||(alert("todo:WebPInitConvertARGBToYUV"),null!=i.ca.f.kb.F&&mr()),i.Pb&&0<i.s.ua&&null==i.s.vb.X&&!O(i.s.vb,i.s.Wa.Xa)){i.a=1;break r}i.xb=0;}if(!_t(i,i.V,i.Ba,i.c,i.i,n.o,Lt))break r;a.Dc=i.Ma,i=1;break e}e(0!=i.a),i=0;}i=!i;}i&&(r=t.a);}else r=t.a;}else {if(null==(t=new Yt)){s=1;break t}if(t.Fa=a.na,t.P=a.P,t.qc=a.Sa,Kt(t,i)){if(0==(r=qr(i.width,i.height,s.Oa,s.ba))){if(t.Aa=0,n=s.Oa,e(null!=(a=t)),null!=n){if(0<(u=0>(u=n.Md)?0:100<u?255:255*u/100)){for(h=l=0;4>h;++h)12>(f=a.pb[h]).lc&&(f.ia=u*Ti[0>f.lc?0:f.lc]>>3),l|=f.ia;l&&(alert("todo:VP8InitRandom"),a.ia=1);}a.Ga=n.Id,100<a.Ga?a.Ga=100:0>a.Ga&&(a.Ga=0);}Qt(t,i)||(r=t.a);}}else r=t.a;}0==r&&null!=s.Oa&&s.Oa.fd&&(r=Er(s.ba));}s=r;}o=0!=s?null:11>o?c.f.RGBA.eb:c.f.kb.y;}else o=null;return o};var zi=[3,4,3,4,4,2,2,4,4,4,2,1,1];};function u(t,e){for(var r="",n=0;n<4;n++)r+=String.fromCharCode(t[e++]);return r}function h(t,e){return (t[e+0]<<0|t[e+1]<<8|t[e+2]<<16)>>>0}function l(t,e){return (t[e+0]<<0|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}new c;var f=[0],d=[0],p=[],g=new c,m=t,v=function(t,e){var r={},n=0,i=!1,a=0,o=0;if(r.frames=[],!
  /** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
  function(t,e,r,n){for(var i=0;i<n;i++)if(t[e+i]!=r.charCodeAt(i))return !0;return !1}(t,e,"RIFF",4)){var s,c;l(t,e+=4);for(e+=8;e<t.length;){var f=u(t,e),d=l(t,e+=4);e+=4;var p=d+(1&d);switch(f){case"VP8 ":case"VP8L":void 0===r.frames[n]&&(r.frames[n]={});(v=r.frames[n]).src_off=i?o:e-8,v.src_size=a+d+8,n++,i&&(i=!1,a=0,o=0);break;case"VP8X":(v=r.header={}).feature_flags=t[e];var g=e+4;v.canvas_width=1+h(t,g);g+=3;v.canvas_height=1+h(t,g);g+=3;break;case"ALPH":i=!0,a=p+8,o=e-8;break;case"ANIM":(v=r.header).bgcolor=l(t,e);g=e+4;v.loop_count=(s=t)[(c=g)+0]<<0|s[c+1]<<8;g+=2;break;case"ANMF":var m,v;(v=r.frames[n]={}).offset_x=2*h(t,e),e+=3,v.offset_y=2*h(t,e),e+=3,v.width=1+h(t,e),e+=3,v.height=1+h(t,e),e+=3,v.duration=h(t,e),e+=3,m=t[e++],v.dispose=1&m,v.blend=m>>1&1;}"ANMF"!=f&&(e+=p);}return r}}(m,0);v.response=m,v.rgbaoutput=!0,v.dataurl=!1;var b=v.header?v.header:null,y=v.frames?v.frames:null;if(b){b.loop_counter=b.loop_count,f=[b.canvas_height],d=[b.canvas_width];for(var w=0;w<y.length&&0!=y[w].blend;w++);}var N=y[0],L=g.WebPDecodeRGBA(m,N.src_off,N.src_size,d,f);N.rgba=L,N.imgwidth=d[0],N.imgheight=f[0];for(var A=0;A<d[0]*f[0]*4;A++)p[A]=L[A];return this.width=d,this.height=f,this.data=p,this}!function(t){var r=function(){return "function"==typeof zlibSync},n=function(r,n,a,h){var l=4,f=s;switch(h){case t.image_compression.FAST:l=1,f=o;break;case t.image_compression.MEDIUM:l=6,f=c;break;case t.image_compression.SLOW:l=9,f=u;}r=i(r,n,a,f);var d=zlibSync(r,{level:l});return t.__addimage__.arrayBufferToBinaryString(d)},i=function(t,e,r,n){for(var i,a,o,s=t.length/e,c=new Uint8Array(t.length+s),u=l(),h=0;h<s;h+=1){if(o=h*e,i=t.subarray(o,o+e),n)c.set(n(i,r,a),o+h);else {for(var d,p=u.length,g=[];d<p;d+=1)g[d]=u[d](i,r,a);var m=f(g.concat());c.set(g[m],o+h);}a=i;}return c},a=function(t){var e=Array.apply([],t);return e.unshift(0),e},o=function(t,e){var r,n=[],i=t.length;n[0]=1;for(var a=0;a<i;a+=1)r=t[a-e]||0,n[a+1]=t[a]-r+256&255;return n},s=function(t,e,r){var n,i=[],a=t.length;i[0]=2;for(var o=0;o<a;o+=1)n=r&&r[o]||0,i[o+1]=t[o]-n+256&255;return i},c=function(t,e,r){var n,i,a=[],o=t.length;a[0]=3;for(var s=0;s<o;s+=1)n=t[s-e]||0,i=r&&r[s]||0,a[s+1]=t[s]+256-(n+i>>>1)&255;return a},u=function(t,e,r){var n,i,a,o,s=[],c=t.length;s[0]=4;for(var u=0;u<c;u+=1)n=t[u-e]||0,i=r&&r[u]||0,a=r&&r[u-e]||0,o=h(n,i,a),s[u+1]=t[u]-o+256&255;return s},h=function(t,e,r){if(t===e&&e===r)return t;var n=Math.abs(e-r),i=Math.abs(t-r),a=Math.abs(t+e-r-r);return n<=i&&n<=a?t:i<=a?e:r},l=function(){return [a,o,s,c,u]},f=function(t){var e=t.map((function(t){return t.reduce((function(t,e){return t+Math.abs(e)}),0)}));return e.indexOf(Math.min.apply(null,e))};t.processPNG=function(e,i,a,o){var s,c,u,h,l,f,d,p,g,m,v,b,y,w,N,L=this.decode.FLATE_DECODE,A="";if(this.__addimage__.isArrayBuffer(e)&&(e=new Uint8Array(e)),this.__addimage__.isArrayBufferView(e)){if(e=(u=new Kt(e)).imgData,c=u.bits,s=u.colorSpace,l=u.colors,-1!==[4,6].indexOf(u.colorType)){if(8===u.bits){g=(p=32==u.pixelBitlength?new Uint32Array(u.decodePixels().buffer):16==u.pixelBitlength?new Uint16Array(u.decodePixels().buffer):new Uint8Array(u.decodePixels().buffer)).length,v=new Uint8Array(g*u.colors),m=new Uint8Array(g);var x,S=u.pixelBitlength-u.bits;for(w=0,N=0;w<g;w++){for(y=p[w],x=0;x<S;)v[N++]=y>>>x&255,x+=u.bits;m[w]=y>>>x&255;}}if(16===u.bits){g=(p=new Uint32Array(u.decodePixels().buffer)).length,v=new Uint8Array(g*(32/u.pixelBitlength)*u.colors),m=new Uint8Array(g*(32/u.pixelBitlength)),b=u.colors>1,w=0,N=0;for(var _=0;w<g;)y=p[w++],v[N++]=y>>>0&255,b&&(v[N++]=y>>>16&255,y=p[w++],v[N++]=y>>>0&255),m[_++]=y>>>16&255;c=8;}o!==t.image_compression.NONE&&r()?(e=n(v,u.width*u.colors,u.colors,o),d=n(m,u.width,1,o)):(e=v,d=m,L=void 0);}if(3===u.colorType&&(s=this.color_spaces.INDEXED,f=u.palette,u.transparency.indexed)){var P=u.transparency.indexed,k=0;for(w=0,g=P.length;w<g;++w)k+=P[w];if((k/=255)===g-1&&-1!==P.indexOf(0))h=[P.indexOf(0)];else if(k!==g){for(p=u.decodePixels(),m=new Uint8Array(p.length),w=0,g=p.length;w<g;w++)m[w]=P[p[w]];d=n(m,u.width,1);}}var I=function(e){var r;switch(e){case t.image_compression.FAST:r=11;break;case t.image_compression.MEDIUM:r=13;break;case t.image_compression.SLOW:r=14;break;default:r=12;}return r}(o);return L===this.decode.FLATE_DECODE&&(A="/Predictor "+I+" "),A+="/Colors "+l+" /BitsPerComponent "+c+" /Columns "+u.width,(this.__addimage__.isArrayBuffer(e)||this.__addimage__.isArrayBufferView(e))&&(e=this.__addimage__.arrayBufferToBinaryString(e)),(d&&this.__addimage__.isArrayBuffer(d)||this.__addimage__.isArrayBufferView(d))&&(d=this.__addimage__.arrayBufferToBinaryString(d)),{alias:a,data:e,index:i,filter:L,decodeParameters:A,transparency:h,palette:f,sMask:d,predictor:I,width:u.width,height:u.height,bitsPerComponent:c,colorSpace:s}}};}(E$1.API),function(t){t.processGIF89A=function(e,r,n,i){var a=new Zt(e),o=a.width,s=a.height,c=[];a.decodeAndBlitFrameRGBA(0,c);var u={data:c,width:o,height:s},h=new Qt(100).encode(u,100);return t.processJPEG.call(this,h,r,n,i)},t.processGIF87A=t.processGIF89A;}(E$1.API),te.prototype.parseHeader=function(){if(this.fileSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.reserved=this.datav.getUint32(this.pos,!0),this.pos+=4,this.offset=this.datav.getUint32(this.pos,!0),this.pos+=4,this.headerSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.width=this.datav.getUint32(this.pos,!0),this.pos+=4,this.height=this.datav.getInt32(this.pos,!0),this.pos+=4,this.planes=this.datav.getUint16(this.pos,!0),this.pos+=2,this.bitPP=this.datav.getUint16(this.pos,!0),this.pos+=2,this.compress=this.datav.getUint32(this.pos,!0),this.pos+=4,this.rawSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.hr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.vr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.colors=this.datav.getUint32(this.pos,!0),this.pos+=4,this.importantColors=this.datav.getUint32(this.pos,!0),this.pos+=4,16===this.bitPP&&this.is_with_alpha&&(this.bitPP=15),this.bitPP<15){var t=0===this.colors?1<<this.bitPP:this.colors;this.palette=new Array(t);for(var e=0;e<t;e++){var r=this.datav.getUint8(this.pos++,!0),n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0);this.palette[e]={red:i,green:n,blue:r,quad:a};}}this.height<0&&(this.height*=-1,this.bottom_up=!1);},te.prototype.parseBGR=function(){this.pos=this.offset;try{var t="bit"+this.bitPP,e=this.width*this.height*4;this.data=new Uint8Array(e),this[t]();}catch(t){a$2.log("bit decode error:"+t);}},te.prototype.bit1=function(){var t,e=Math.ceil(this.width/8),r=e%4;for(t=this.height-1;t>=0;t--){for(var n=this.bottom_up?t:this.height-1-t,i=0;i<e;i++)for(var a=this.datav.getUint8(this.pos++,!0),o=n*this.width*4+8*i*4,s=0;s<8&&8*i+s<this.width;s++){var c=this.palette[a>>7-s&1];this.data[o+4*s]=c.blue,this.data[o+4*s+1]=c.green,this.data[o+4*s+2]=c.red,this.data[o+4*s+3]=255;}0!==r&&(this.pos+=4-r);}},te.prototype.bit4=function(){for(var t=Math.ceil(this.width/2),e=t%4,r=this.height-1;r>=0;r--){for(var n=this.bottom_up?r:this.height-1-r,i=0;i<t;i++){var a=this.datav.getUint8(this.pos++,!0),o=n*this.width*4+2*i*4,s=a>>4,c=15&a,u=this.palette[s];if(this.data[o]=u.blue,this.data[o+1]=u.green,this.data[o+2]=u.red,this.data[o+3]=255,2*i+1>=this.width)break;u=this.palette[c],this.data[o+4]=u.blue,this.data[o+4+1]=u.green,this.data[o+4+2]=u.red,this.data[o+4+3]=255;}0!==e&&(this.pos+=4-e);}},te.prototype.bit8=function(){for(var t=this.width%4,e=this.height-1;e>=0;e--){for(var r=this.bottom_up?e:this.height-1-e,n=0;n<this.width;n++){var i=this.datav.getUint8(this.pos++,!0),a=r*this.width*4+4*n;if(i<this.palette.length){var o=this.palette[i];this.data[a]=o.red,this.data[a+1]=o.green,this.data[a+2]=o.blue,this.data[a+3]=255;}else this.data[a]=255,this.data[a+1]=255,this.data[a+2]=255,this.data[a+3]=255;}0!==t&&(this.pos+=4-t);}},te.prototype.bit15=function(){for(var t=this.width%3,e=parseInt("11111",2),r=this.height-1;r>=0;r--){for(var n=this.bottom_up?r:this.height-1-r,i=0;i<this.width;i++){var a=this.datav.getUint16(this.pos,!0);this.pos+=2;var o=(a&e)/e*255|0,s=(a>>5&e)/e*255|0,c=(a>>10&e)/e*255|0,u=a>>15?255:0,h=n*this.width*4+4*i;this.data[h]=c,this.data[h+1]=s,this.data[h+2]=o,this.data[h+3]=u;}this.pos+=t;}},te.prototype.bit16=function(){for(var t=this.width%3,e=parseInt("11111",2),r=parseInt("111111",2),n=this.height-1;n>=0;n--){for(var i=this.bottom_up?n:this.height-1-n,a=0;a<this.width;a++){var o=this.datav.getUint16(this.pos,!0);this.pos+=2;var s=(o&e)/e*255|0,c=(o>>5&r)/r*255|0,u=(o>>11)/e*255|0,h=i*this.width*4+4*a;this.data[h]=u,this.data[h+1]=c,this.data[h+2]=s,this.data[h+3]=255;}this.pos+=t;}},te.prototype.bit24=function(){for(var t=this.height-1;t>=0;t--){for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=e*this.width*4+4*r;this.data[o]=a,this.data[o+1]=i,this.data[o+2]=n,this.data[o+3]=255;}this.pos+=this.width%4;}},te.prototype.bit32=function(){for(var t=this.height-1;t>=0;t--)for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0),s=e*this.width*4+4*r;this.data[s]=a,this.data[s+1]=i,this.data[s+2]=n,this.data[s+3]=o;}},te.prototype.getData=function(){return this.data},
  /**
   * @license
   * Copyright (c) 2018 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.processBMP=function(e,r,n,i){var a=new te(e,!1),o=a.width,s=a.height,c={data:a.getData(),width:o,height:s},u=new Qt(100).encode(c,100);return t.processJPEG.call(this,u,r,n,i)};}(E$1.API),ee$1.prototype.getData=function(){return this.data},
  /**
   * @license
   * Copyright (c) 2019 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.processWEBP=function(e,r,n,i){var a=new ee$1(e,!1),o=a.width,s=a.height,c={data:a.getData(),width:o,height:s},u=new Qt(100).encode(c,100);return t.processJPEG.call(this,u,r,n,i)};}(E$1.API),E$1.API.processRGBA=function(t,e,r){for(var n=t.data,i=n.length,a=new Uint8Array(i/4*3),o=new Uint8Array(i/4),s=0,c=0,u=0;u<i;u+=4){var h=n[u],l=n[u+1],f=n[u+2],d=n[u+3];a[s++]=h,a[s++]=l,a[s++]=f,o[c++]=d;}var p=this.__addimage__.arrayBufferToBinaryString(a);return {alpha:this.__addimage__.arrayBufferToBinaryString(o),data:p,index:e,alias:r,colorSpace:"DeviceRGB",bitsPerComponent:8,width:t.width,height:t.height}},E$1.API.setLanguage=function(t){return void 0===this.internal.languageSettings&&(this.internal.languageSettings={},this.internal.languageSettings.isSubscribed=!1),void 0!=={af:"Afrikaans",sq:"Albanian",ar:"Arabic (Standard)","ar-DZ":"Arabic (Algeria)","ar-BH":"Arabic (Bahrain)","ar-EG":"Arabic (Egypt)","ar-IQ":"Arabic (Iraq)","ar-JO":"Arabic (Jordan)","ar-KW":"Arabic (Kuwait)","ar-LB":"Arabic (Lebanon)","ar-LY":"Arabic (Libya)","ar-MA":"Arabic (Morocco)","ar-OM":"Arabic (Oman)","ar-QA":"Arabic (Qatar)","ar-SA":"Arabic (Saudi Arabia)","ar-SY":"Arabic (Syria)","ar-TN":"Arabic (Tunisia)","ar-AE":"Arabic (U.A.E.)","ar-YE":"Arabic (Yemen)",an:"Aragonese",hy:"Armenian",as:"Assamese",ast:"Asturian",az:"Azerbaijani",eu:"Basque",be:"Belarusian",bn:"Bengali",bs:"Bosnian",br:"Breton",bg:"Bulgarian",my:"Burmese",ca:"Catalan",ch:"Chamorro",ce:"Chechen",zh:"Chinese","zh-HK":"Chinese (Hong Kong)","zh-CN":"Chinese (PRC)","zh-SG":"Chinese (Singapore)","zh-TW":"Chinese (Taiwan)",cv:"Chuvash",co:"Corsican",cr:"Cree",hr:"Croatian",cs:"Czech",da:"Danish",nl:"Dutch (Standard)","nl-BE":"Dutch (Belgian)",en:"English","en-AU":"English (Australia)","en-BZ":"English (Belize)","en-CA":"English (Canada)","en-IE":"English (Ireland)","en-JM":"English (Jamaica)","en-NZ":"English (New Zealand)","en-PH":"English (Philippines)","en-ZA":"English (South Africa)","en-TT":"English (Trinidad & Tobago)","en-GB":"English (United Kingdom)","en-US":"English (United States)","en-ZW":"English (Zimbabwe)",eo:"Esperanto",et:"Estonian",fo:"Faeroese",fj:"Fijian",fi:"Finnish",fr:"French (Standard)","fr-BE":"French (Belgium)","fr-CA":"French (Canada)","fr-FR":"French (France)","fr-LU":"French (Luxembourg)","fr-MC":"French (Monaco)","fr-CH":"French (Switzerland)",fy:"Frisian",fur:"Friulian",gd:"Gaelic (Scots)","gd-IE":"Gaelic (Irish)",gl:"Galacian",ka:"Georgian",de:"German (Standard)","de-AT":"German (Austria)","de-DE":"German (Germany)","de-LI":"German (Liechtenstein)","de-LU":"German (Luxembourg)","de-CH":"German (Switzerland)",el:"Greek",gu:"Gujurati",ht:"Haitian",he:"Hebrew",hi:"Hindi",hu:"Hungarian",is:"Icelandic",id:"Indonesian",iu:"Inuktitut",ga:"Irish",it:"Italian (Standard)","it-CH":"Italian (Switzerland)",ja:"Japanese",kn:"Kannada",ks:"Kashmiri",kk:"Kazakh",km:"Khmer",ky:"Kirghiz",tlh:"Klingon",ko:"Korean","ko-KP":"Korean (North Korea)","ko-KR":"Korean (South Korea)",la:"Latin",lv:"Latvian",lt:"Lithuanian",lb:"Luxembourgish",mk:"North Macedonia",ms:"Malay",ml:"Malayalam",mt:"Maltese",mi:"Maori",mr:"Marathi",mo:"Moldavian",nv:"Navajo",ng:"Ndonga",ne:"Nepali",no:"Norwegian",nb:"Norwegian (Bokmal)",nn:"Norwegian (Nynorsk)",oc:"Occitan",or:"Oriya",om:"Oromo",fa:"Persian","fa-IR":"Persian/Iran",pl:"Polish",pt:"Portuguese","pt-BR":"Portuguese (Brazil)",pa:"Punjabi","pa-IN":"Punjabi (India)","pa-PK":"Punjabi (Pakistan)",qu:"Quechua",rm:"Rhaeto-Romanic",ro:"Romanian","ro-MO":"Romanian (Moldavia)",ru:"Russian","ru-MO":"Russian (Moldavia)",sz:"Sami (Lappish)",sg:"Sango",sa:"Sanskrit",sc:"Sardinian",sd:"Sindhi",si:"Singhalese",sr:"Serbian",sk:"Slovak",sl:"Slovenian",so:"Somani",sb:"Sorbian",es:"Spanish","es-AR":"Spanish (Argentina)","es-BO":"Spanish (Bolivia)","es-CL":"Spanish (Chile)","es-CO":"Spanish (Colombia)","es-CR":"Spanish (Costa Rica)","es-DO":"Spanish (Dominican Republic)","es-EC":"Spanish (Ecuador)","es-SV":"Spanish (El Salvador)","es-GT":"Spanish (Guatemala)","es-HN":"Spanish (Honduras)","es-MX":"Spanish (Mexico)","es-NI":"Spanish (Nicaragua)","es-PA":"Spanish (Panama)","es-PY":"Spanish (Paraguay)","es-PE":"Spanish (Peru)","es-PR":"Spanish (Puerto Rico)","es-ES":"Spanish (Spain)","es-UY":"Spanish (Uruguay)","es-VE":"Spanish (Venezuela)",sx:"Sutu",sw:"Swahili",sv:"Swedish","sv-FI":"Swedish (Finland)","sv-SV":"Swedish (Sweden)",ta:"Tamil",tt:"Tatar",te:"Teluga",th:"Thai",tig:"Tigre",ts:"Tsonga",tn:"Tswana",tr:"Turkish",tk:"Turkmen",uk:"Ukrainian",hsb:"Upper Sorbian",ur:"Urdu",ve:"Venda",vi:"Vietnamese",vo:"Volapuk",wa:"Walloon",cy:"Welsh",xh:"Xhosa",ji:"Yiddish",zu:"Zulu"}[t]&&(this.internal.languageSettings.languageCode=t,!1===this.internal.languageSettings.isSubscribed&&(this.internal.events.subscribe("putCatalog",(function(){this.internal.write("/Lang ("+this.internal.languageSettings.languageCode+")");})),this.internal.languageSettings.isSubscribed=!0)),this},Vt=E$1.API,Gt$1=Vt.getCharWidthsArray=function(e,r){var n,i,a=(r=r||{}).font||this.internal.getFont(),o=r.fontSize||this.internal.getFontSize(),s=r.charSpace||this.internal.getCharSpace(),c=r.widths?r.widths:a.metadata.Unicode.widths,u=c.fof?c.fof:1,h=r.kerning?r.kerning:a.metadata.Unicode.kerning,l=h.fof?h.fof:1,f=!1!==r.doKerning,d=0,p=e.length,g=0,m=c[0]||u,v=[];for(n=0;n<p;n++)i=e.charCodeAt(n),"function"==typeof a.metadata.widthOfString?v.push((a.metadata.widthOfGlyph(a.metadata.characterToGlyph(i))+s*(1e3/o)||0)/1e3):(d=f&&"object"===_typeof$2(h[i])&&!isNaN(parseInt(h[i][g],10))?h[i][g]/l:0,v.push((c[i]||m)/u+d)),g=i;return v},Yt=Vt.getStringUnitWidth=function(t,e){var r=(e=e||{}).fontSize||this.internal.getFontSize(),n=e.font||this.internal.getFont(),i=e.charSpace||this.internal.getCharSpace();return Vt.processArabic&&(t=Vt.processArabic(t)),"function"==typeof n.metadata.widthOfString?n.metadata.widthOfString(t,r,i)/r:Gt$1.apply(this,arguments).reduce((function(t,e){return t+e}),0)},Jt=function(t,e,r,n){for(var i=[],a=0,o=t.length,s=0;a!==o&&s+e[a]<r;)s+=e[a],a++;i.push(t.slice(0,a));var c=a;for(s=0;a!==o;)s+e[a]>n&&(i.push(t.slice(c,a)),s=0,c=a),s+=e[a],a++;return c!==a&&i.push(t.slice(c,a)),i},Xt=function(t,e,r){r||(r={});var n,i,a,o,s,c,u,h=[],l=[h],f=r.textIndent||0,d=0,p=0,g=t.split(" "),m=Gt$1.apply(this,[" ",r])[0];if(c=-1===r.lineIndent?g[0].length+2:r.lineIndent||0){var v=Array(c).join(" "),b=[];g.map((function(t){(t=t.split(/\s*\n/)).length>1?b=b.concat(t.map((function(t,e){return (e&&t.length?"\n":"")+t}))):b.push(t[0]);})),g=b,c=Yt.apply(this,[v,r]);}for(a=0,o=g.length;a<o;a++){var y=0;if(n=g[a],c&&"\n"==n[0]&&(n=n.substr(1),y=1),f+d+(p=(i=Gt$1.apply(this,[n,r])).reduce((function(t,e){return t+e}),0))>e||y){if(p>e){for(s=Jt.apply(this,[n,i,e-(f+d),e]),h.push(s.shift()),h=[s.pop()];s.length;)l.push([s.shift()]);p=i.slice(n.length-(h[0]?h[0].length:0)).reduce((function(t,e){return t+e}),0);}else h=[n];l.push(h),f=p+c,d=m;}else h.push(n),f+=d+p,d=m;}return u=c?function(t,e){return (e?v:"")+t.join(" ")}:function(t){return t.join(" ")},l.map(u)},Vt.splitTextToSize=function(t,e,r){var n,i=(r=r||{}).fontSize||this.internal.getFontSize(),a=function(t){if(t.widths&&t.kerning)return {widths:t.widths,kerning:t.kerning};var e=this.internal.getFont(t.fontName,t.fontStyle);return e.metadata.Unicode?{widths:e.metadata.Unicode.widths||{0:1},kerning:e.metadata.Unicode.kerning||{}}:{font:e.metadata,fontSize:this.internal.getFontSize(),charSpace:this.internal.getCharSpace()}}.call(this,r);n=Array.isArray(t)?t:String(t).split(/\r?\n/);var o=1*this.internal.scaleFactor*e/i;a.textIndent=r.textIndent?1*r.textIndent*this.internal.scaleFactor/i:0,a.lineIndent=r.lineIndent;var s,c,u=[];for(s=0,c=n.length;s<c;s++)u=u.concat(Xt.apply(this,[n[s],o,a]));return u},function(e){e.__fontmetrics__=e.__fontmetrics__||{};for(var r="klmnopqrstuvwxyz",n={},i={},a=0;a<r.length;a++)n[r[a]]="0123456789abcdef"[a],i["0123456789abcdef"[a]]=r[a];var o=function(t){return "0x"+parseInt(t,10).toString(16)},s=e.__fontmetrics__.compress=function(e){var r,n,a,c,u=["{"];for(var h in e){if(r=e[h],isNaN(parseInt(h,10))?n="'"+h+"'":(h=parseInt(h,10),n=(n=o(h).slice(2)).slice(0,-1)+i[n.slice(-1)]),"number"==typeof r)r<0?(a=o(r).slice(3),c="-"):(a=o(r).slice(2),c=""),a=c+a.slice(0,-1)+i[a.slice(-1)];else {if("object"!==_typeof$2(r))throw new Error("Don't know what to do with value type "+_typeof$2(r)+".");a=s(r);}u.push(n+a);}return u.push("}"),u.join("")},c=e.__fontmetrics__.uncompress=function(t){if("string"!=typeof t)throw new Error("Invalid argument passed to uncompress.");for(var e,r,i,a,o={},s=1,c=o,u=[],h="",l="",f=t.length-1,d=1;d<f;d+=1)"'"==(a=t[d])?e?(i=e.join(""),e=void 0):e=[]:e?e.push(a):"{"==a?(u.push([c,i]),c={},i=void 0):"}"==a?((r=u.pop())[0][r[1]]=c,i=void 0,c=r[0]):"-"==a?s=-1:void 0===i?n.hasOwnProperty(a)?(h+=n[a],i=parseInt(h,16)*s,s=1,h=""):h+=a:n.hasOwnProperty(a)?(l+=n[a],c[i]=parseInt(l,16)*s,s=1,i=void 0,l=""):l+=a;return o},u={codePages:["WinAnsiEncoding"],WinAnsiEncoding:c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")},h={Unicode:{Courier:u,"Courier-Bold":u,"Courier-BoldOblique":u,"Courier-Oblique":u,Helvetica:u,"Helvetica-Bold":u,"Helvetica-BoldOblique":u,"Helvetica-Oblique":u,"Times-Roman":u,"Times-Bold":u,"Times-BoldItalic":u,"Times-Italic":u}},l={Unicode:{"Courier-Oblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-BoldItalic":c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),"Helvetica-Bold":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),Courier:c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-BoldOblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Bold":c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),Symbol:c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),Helvetica:c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),"Helvetica-BoldOblique":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),ZapfDingbats:c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-Bold":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Italic":c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),"Times-Roman":c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),"Helvetica-Oblique":c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}};e.events.push(["addFont",function(t){var e=t.font,r=l.Unicode[e.postScriptName];r&&(e.metadata.Unicode={},e.metadata.Unicode.widths=r.widths,e.metadata.Unicode.kerning=r.kerning);var n=h.Unicode[e.postScriptName];n&&(e.metadata.Unicode.encoding=n,e.encoding=n.codePages[0]);}]);}(E$1.API),
  /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(t){for(var e=t.length,r=new Uint8Array(e),n=0;n<e;n++)r[n]=t.charCodeAt(n);return r};t.API.events.push(["addFont",function(r){var n=void 0,i=r.font,a=r.instance;if(!i.isStandardFont){if(void 0===a)throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");if("string"!=typeof(n=!1===a.existsFileInVFS(i.postScriptName)?a.loadFile(i.postScriptName):a.getFileFromVFS(i.postScriptName)))throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");!function(r,n){n=/^\x00\x01\x00\x00/.test(n)?e(n):e(u$2(n)),r.metadata=t.API.TTFFont.open(n),r.metadata.Unicode=r.metadata.Unicode||{encoding:{},kerning:{},widths:[]},r.metadata.glyIdsUsed=[0];}(i,n);}}]);}(E$1),
  /** @license
   * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  function(t){function e(){return (n$1.canvg?Promise.resolve(n$1.canvg):Promise.resolve().then(function () { return index_es; })).catch((function(t){return Promise.reject(new Error("Could not load canvg: "+t))})).then((function(t){return t.default?t.default:t}))}E$1.API.addSvgAsImage=function(t,r,n,i,o,s,c,u){if(isNaN(r)||isNaN(n))throw a$2.error("jsPDF.addSvgAsImage: Invalid coordinates",arguments),new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");if(isNaN(i)||isNaN(o))throw a$2.error("jsPDF.addSvgAsImage: Invalid measurements",arguments),new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");var h=document.createElement("canvas");h.width=i,h.height=o;var l=h.getContext("2d");l.fillStyle="#fff",l.fillRect(0,0,h.width,h.height);var f={ignoreMouse:!0,ignoreAnimation:!0,ignoreDimensions:!0},d=this;return e().then((function(e){return e.fromString(l,t,f)}),(function(){return Promise.reject(new Error("Could not load canvg."))})).then((function(t){return t.render(f)})).then((function(){d.addImage(h.toDataURL("image/jpeg",1),r,n,i,o,c,u);}))};}(),E$1.API.putTotalPages=function(t){var e,r=0;parseInt(this.internal.getFont().id.substr(1),10)<15?(e=new RegExp(t,"g"),r=this.internal.getNumberOfPages()):(e=new RegExp(this.pdfEscape16(t,this.internal.getFont()),"g"),r=this.pdfEscape16(this.internal.getNumberOfPages()+"",this.internal.getFont()));for(var n=1;n<=this.internal.getNumberOfPages();n++)for(var i=0;i<this.internal.pages[n].length;i++)this.internal.pages[n][i]=this.internal.pages[n][i].replace(e,r);return this},E$1.API.viewerPreferences=function(e,r){var n;e=e||{},r=r||!1;var i,a,o,s={HideToolbar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideMenubar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideWindowUI:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},FitWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},CenterWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},DisplayDocTitle:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.4},NonFullScreenPageMode:{defaultValue:"UseNone",value:"UseNone",type:"name",explicitSet:!1,valueSet:["UseNone","UseOutlines","UseThumbs","UseOC"],pdfVersion:1.3},Direction:{defaultValue:"L2R",value:"L2R",type:"name",explicitSet:!1,valueSet:["L2R","R2L"],pdfVersion:1.3},ViewArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},ViewClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintScaling:{defaultValue:"AppDefault",value:"AppDefault",type:"name",explicitSet:!1,valueSet:["AppDefault","None"],pdfVersion:1.6},Duplex:{defaultValue:"",value:"none",type:"name",explicitSet:!1,valueSet:["Simplex","DuplexFlipShortEdge","DuplexFlipLongEdge","none"],pdfVersion:1.7},PickTrayByPDFSize:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.7},PrintPageRange:{defaultValue:"",value:"",type:"array",explicitSet:!1,valueSet:null,pdfVersion:1.7},NumCopies:{defaultValue:1,value:1,type:"integer",explicitSet:!1,valueSet:null,pdfVersion:1.7}},c=Object.keys(s),u=[],h=0,l=0,f=0;function d(t,e){var r,n=!1;for(r=0;r<t.length;r+=1)t[r]===e&&(n=!0);return n}if(void 0===this.internal.viewerpreferences&&(this.internal.viewerpreferences={},this.internal.viewerpreferences.configuration=JSON.parse(JSON.stringify(s)),this.internal.viewerpreferences.isSubscribed=!1),n=this.internal.viewerpreferences.configuration,"reset"===e||!0===r){var p=c.length;for(f=0;f<p;f+=1)n[c[f]].value=n[c[f]].defaultValue,n[c[f]].explicitSet=!1;}if("object"===_typeof$2(e))for(a in e)if(o=e[a],d(c,a)&&void 0!==o){if("boolean"===n[a].type&&"boolean"==typeof o)n[a].value=o;else if("name"===n[a].type&&d(n[a].valueSet,o))n[a].value=o;else if("integer"===n[a].type&&Number.isInteger(o))n[a].value=o;else if("array"===n[a].type){for(h=0;h<o.length;h+=1)if(i=!0,1===o[h].length&&"number"==typeof o[h][0])u.push(String(o[h]-1));else if(o[h].length>1){for(l=0;l<o[h].length;l+=1)"number"!=typeof o[h][l]&&(i=!1);!0===i&&u.push([o[h][0]-1,o[h][1]-1].join(" "));}n[a].value="["+u.join(" ")+"]";}else n[a].value=n[a].defaultValue;n[a].explicitSet=!0;}return !1===this.internal.viewerpreferences.isSubscribed&&(this.internal.events.subscribe("putCatalog",(function(){var t,e=[];for(t in n)!0===n[t].explicitSet&&("name"===n[t].type?e.push("/"+t+" /"+n[t].value):e.push("/"+t+" "+n[t].value));0!==e.length&&this.internal.write("/ViewerPreferences\n<<\n"+e.join("\n")+"\n>>");})),this.internal.viewerpreferences.isSubscribed=!0),this.internal.viewerpreferences.configuration=n,this},
  /** ====================================================================
   * @license
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  function(t){var e=function(){var t='<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="'+this.internal.__metadata__.namespaceuri+'"><jspdf:metadata>',e=unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')),r=unescape(encodeURIComponent(t)),n=unescape(encodeURIComponent(this.internal.__metadata__.metadata)),i=unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")),a=unescape(encodeURIComponent("</x:xmpmeta>")),o=r.length+n.length+i.length+e.length+a.length;this.internal.__metadata__.metadata_object_number=this.internal.newObject(),this.internal.write("<< /Type /Metadata /Subtype /XML /Length "+o+" >>"),this.internal.write("stream"),this.internal.write(e+r+n+i+a),this.internal.write("endstream"),this.internal.write("endobj");},r=function(){this.internal.__metadata__.metadata_object_number&&this.internal.write("/Metadata "+this.internal.__metadata__.metadata_object_number+" 0 R");};t.addMetadata=function(t,n){return void 0===this.internal.__metadata__&&(this.internal.__metadata__={metadata:t,namespaceuri:n||"http://jspdf.default.namespaceuri/"},this.internal.events.subscribe("putCatalog",r),this.internal.events.subscribe("postPutResources",e)),this};}(E$1.API),function(t){var e=t.API,r=e.pdfEscape16=function(t,e){for(var r,n=e.metadata.Unicode.widths,i=["","0","00","000","0000"],a=[""],o=0,s=t.length;o<s;++o){if(r=e.metadata.characterToGlyph(t.charCodeAt(o)),e.metadata.glyIdsUsed.push(r),e.metadata.toUnicode[r]=t.charCodeAt(o),-1==n.indexOf(r)&&(n.push(r),n.push([parseInt(e.metadata.widthOfGlyph(r),10)])),"0"==r)return a.join("");r=r.toString(16),a.push(i[4-r.length],r);}return a.join("")},n=function(t){var e,r,n,i,a,o,s;for(a="/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange",n=[],o=0,s=(r=Object.keys(t).sort((function(t,e){return t-e}))).length;o<s;o++)e=r[o],n.length>=100&&(a+="\n"+n.length+" beginbfchar\n"+n.join("\n")+"\nendbfchar",n=[]),void 0!==t[e]&&null!==t[e]&&"function"==typeof t[e].toString&&(i=("0000"+t[e].toString(16)).slice(-4),e=("0000"+(+e).toString(16)).slice(-4),n.push("<"+e+"><"+i+">"));return n.length&&(a+="\n"+n.length+" beginbfchar\n"+n.join("\n")+"\nendbfchar\n"),a+="endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"};e.events.push(["putFont",function(e){!function(e){var r=e.font,i=e.out,a=e.newObject,o=e.putStream;if(r.metadata instanceof t.API.TTFFont&&"Identity-H"===r.encoding){for(var s=r.metadata.Unicode.widths,c=r.metadata.subset.encode(r.metadata.glyIdsUsed,1),u="",h=0;h<c.length;h++)u+=String.fromCharCode(c[h]);var l=a();o({data:u,addLength1:!0,objectId:l}),i("endobj");var f=a();o({data:n(r.metadata.toUnicode),addLength1:!0,objectId:f}),i("endobj");var d=a();i("<<"),i("/Type /FontDescriptor"),i("/FontName /"+F$1(r.fontName)),i("/FontFile2 "+l+" 0 R"),i("/FontBBox "+t.API.PDFObject.convert(r.metadata.bbox)),i("/Flags "+r.metadata.flags),i("/StemV "+r.metadata.stemV),i("/ItalicAngle "+r.metadata.italicAngle),i("/Ascent "+r.metadata.ascender),i("/Descent "+r.metadata.decender),i("/CapHeight "+r.metadata.capHeight),i(">>"),i("endobj");var p=a();i("<<"),i("/Type /Font"),i("/BaseFont /"+F$1(r.fontName)),i("/FontDescriptor "+d+" 0 R"),i("/W "+t.API.PDFObject.convert(s)),i("/CIDToGIDMap /Identity"),i("/DW 1000"),i("/Subtype /CIDFontType2"),i("/CIDSystemInfo"),i("<<"),i("/Supplement 0"),i("/Registry (Adobe)"),i("/Ordering ("+r.encoding+")"),i(">>"),i(">>"),i("endobj"),r.objectNumber=a(),i("<<"),i("/Type /Font"),i("/Subtype /Type0"),i("/ToUnicode "+f+" 0 R"),i("/BaseFont /"+F$1(r.fontName)),i("/Encoding /"+r.encoding),i("/DescendantFonts ["+p+" 0 R]"),i(">>"),i("endobj"),r.isAlreadyPutted=!0;}}(e);}]);e.events.push(["putFont",function(e){!function(e){var r=e.font,i=e.out,a=e.newObject,o=e.putStream;if(r.metadata instanceof t.API.TTFFont&&"WinAnsiEncoding"===r.encoding){for(var s=r.metadata.rawData,c="",u=0;u<s.length;u++)c+=String.fromCharCode(s[u]);var h=a();o({data:c,addLength1:!0,objectId:h}),i("endobj");var l=a();o({data:n(r.metadata.toUnicode),addLength1:!0,objectId:l}),i("endobj");var f=a();i("<<"),i("/Descent "+r.metadata.decender),i("/CapHeight "+r.metadata.capHeight),i("/StemV "+r.metadata.stemV),i("/Type /FontDescriptor"),i("/FontFile2 "+h+" 0 R"),i("/Flags 96"),i("/FontBBox "+t.API.PDFObject.convert(r.metadata.bbox)),i("/FontName /"+F$1(r.fontName)),i("/ItalicAngle "+r.metadata.italicAngle),i("/Ascent "+r.metadata.ascender),i(">>"),i("endobj"),r.objectNumber=a();for(var d=0;d<r.metadata.hmtx.widths.length;d++)r.metadata.hmtx.widths[d]=parseInt(r.metadata.hmtx.widths[d]*(1e3/r.metadata.head.unitsPerEm));i("<</Subtype/TrueType/Type/Font/ToUnicode "+l+" 0 R/BaseFont/"+F$1(r.fontName)+"/FontDescriptor "+f+" 0 R/Encoding/"+r.encoding+" /FirstChar 29 /LastChar 255 /Widths "+t.API.PDFObject.convert(r.metadata.hmtx.widths)+">>"),i("endobj"),r.isAlreadyPutted=!0;}}(e);}]);var i=function(t){var e,n=t.text||"",i=t.x,a=t.y,o=t.options||{},s=t.mutex||{},c=s.pdfEscape,u=s.activeFontKey,h=s.fonts,l=u,f="",d=0,p="",g=h[l].encoding;if("Identity-H"!==h[l].encoding)return {text:n,x:i,y:a,options:o,mutex:s};for(p=n,l=u,Array.isArray(n)&&(p=n[0]),d=0;d<p.length;d+=1)h[l].metadata.hasOwnProperty("cmap")&&(e=h[l].metadata.cmap.unicode.codeMap[p[d].charCodeAt(0)]),e||p[d].charCodeAt(0)<256&&h[l].metadata.hasOwnProperty("Unicode")?f+=p[d]:f+="";var m="";return parseInt(l.slice(1))<14||"WinAnsiEncoding"===g?m=c(f,l).split("").map((function(t){return t.charCodeAt(0).toString(16)})).join(""):"Identity-H"===g&&(m=r(f,h[l])),s.isHex=!0,{text:m,x:i,y:a,options:o,mutex:s}};e.events.push(["postProcessText",function(t){var e=t.text||"",r=[],n={text:e,x:t.x,y:t.y,options:t.options,mutex:t.mutex};if(Array.isArray(e)){var a=0;for(a=0;a<e.length;a+=1)Array.isArray(e[a])&&3===e[a].length?r.push([i(Object.assign({},n,{text:e[a][0]})).text,e[a][1],e[a][2]]):r.push(i(Object.assign({},n,{text:e[a]})).text);t.text=r;}else t.text=i(Object.assign({},n,{text:e})).text;}]);}(E$1),
  /**
   * @license
   * jsPDF virtual FileSystem functionality
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(){return void 0===this.internal.vFS&&(this.internal.vFS={}),!0};t.existsFileInVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]},t.addFileToVFS=function(t,r){return e.call(this),this.internal.vFS[t]=r,this},t.getFileFromVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]?this.internal.vFS[t]:null};}(E$1.API),
  /**
   * @license
   * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
   * MIT License
   */
  function(t){t.__bidiEngine__=t.prototype.__bidiEngine__=function(t){var r,n,i,a,o,s,c,u=e,h=[[0,3,0,1,0,0,0],[0,3,0,1,2,2,0],[0,3,0,17,2,0,1],[0,3,5,5,4,1,0],[0,3,21,21,4,0,1],[0,3,5,5,4,2,0]],l=[[2,0,1,1,0,1,0],[2,0,1,1,0,2,0],[2,0,2,1,3,2,0],[2,0,2,33,3,1,1]],f={L:0,R:1,EN:2,AN:3,N:4,B:5,S:6},d={0:0,5:1,6:2,7:3,32:4,251:5,254:6,255:7},p=["(",")","(","<",">","<","[","]","[","{","}","{","«","»","«","‹","›","‹","⁅","⁆","⁅","⁽","⁾","⁽","₍","₎","₍","≤","≥","≤","〈","〉","〈","﹙","﹚","﹙","﹛","﹜","﹛","﹝","﹞","﹝","﹤","﹥","﹤"],g=new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/),m=!1,v=0;this.__bidiEngine__={};var b=function(t){var e=t.charCodeAt(),r=e>>8,n=d[r];return void 0!==n?u[256*n+(255&e)]:252===r||253===r?"AL":g.test(r)?"L":8===r?"R":"N"},y=function(t){for(var e,r=0;r<t.length;r++){if("L"===(e=b(t.charAt(r))))return !1;if("R"===e)return !0}return !1},w=function(t,e,o,s){var c,u,h,l,f=e[s];switch(f){case"L":case"R":m=!1;break;case"N":case"AN":break;case"EN":m&&(f="AN");break;case"AL":m=!0,f="R";break;case"WS":f="N";break;case"CS":s<1||s+1>=e.length||"EN"!==(c=o[s-1])&&"AN"!==c||"EN"!==(u=e[s+1])&&"AN"!==u?f="N":m&&(u="AN"),f=u===c?u:"N";break;case"ES":f="EN"===(c=s>0?o[s-1]:"B")&&s+1<e.length&&"EN"===e[s+1]?"EN":"N";break;case"ET":if(s>0&&"EN"===o[s-1]){f="EN";break}if(m){f="N";break}for(h=s+1,l=e.length;h<l&&"ET"===e[h];)h++;f=h<l&&"EN"===e[h]?"EN":"N";break;case"NSM":if(i&&!a){for(l=e.length,h=s+1;h<l&&"NSM"===e[h];)h++;if(h<l){var d=t[s],p=d>=1425&&d<=2303||64286===d;if(c=e[h],p&&("R"===c||"AL"===c)){f="R";break}}}f=s<1||"B"===(c=e[s-1])?"N":o[s-1];break;case"B":m=!1,r=!0,f=v;break;case"S":n=!0,f="N";break;case"LRE":case"RLE":case"LRO":case"RLO":case"PDF":m=!1;break;case"BN":f="N";}return f},N=function(t,e,r){var n=t.split("");return r&&L(n,r,{hiLevel:v}),n.reverse(),e&&e.reverse(),n.join("")},L=function(t,e,i){var a,o,s,c,u,d=-1,p=t.length,g=0,y=[],N=v?l:h,L=[];for(m=!1,r=!1,n=!1,o=0;o<p;o++)L[o]=b(t[o]);for(s=0;s<p;s++){if(u=g,y[s]=w(t,L,y,s),a=240&(g=N[u][f[y[s]]]),g&=15,e[s]=c=N[g][5],a>0)if(16===a){for(o=d;o<s;o++)e[o]=1;d=-1;}else d=-1;if(N[g][6])-1===d&&(d=s);else if(d>-1){for(o=d;o<s;o++)e[o]=c;d=-1;}"B"===L[s]&&(e[s]=0),i.hiLevel|=c;}n&&function(t,e,r){for(var n=0;n<r;n++)if("S"===t[n]){e[n]=v;for(var i=n-1;i>=0&&"WS"===t[i];i--)e[i]=v;}}(L,e,p);},A=function(t,e,n,i,a){if(!(a.hiLevel<t)){if(1===t&&1===v&&!r)return e.reverse(),void(n&&n.reverse());for(var o,s,c,u,h=e.length,l=0;l<h;){if(i[l]>=t){for(c=l+1;c<h&&i[c]>=t;)c++;for(u=l,s=c-1;u<s;u++,s--)o=e[u],e[u]=e[s],e[s]=o,n&&(o=n[u],n[u]=n[s],n[s]=o);l=c;}l++;}}},x=function(t,e,r){var n=t.split(""),i={hiLevel:v};return r||(r=[]),L(n,r,i),function(t,e,r){if(0!==r.hiLevel&&c)for(var n,i=0;i<t.length;i++)1===e[i]&&(n=p.indexOf(t[i]))>=0&&(t[i]=p[n+1]);}(n,r,i),A(2,n,e,r,i),A(1,n,e,r,i),n.join("")};return this.__bidiEngine__.doBidiReorder=function(t,e,r){if(function(t,e){if(e)for(var r=0;r<t.length;r++)e[r]=r;void 0===a&&(a=y(t)),void 0===s&&(s=y(t));}(t,e),i||!o||s)if(i&&o&&a^s)v=a?1:0,t=N(t,e,r);else if(!i&&o&&s)v=a?1:0,t=x(t,e,r),t=N(t,e);else if(!i||a||o||s){if(i&&!o&&a^s)t=N(t,e),a?(v=0,t=x(t,e,r)):(v=1,t=x(t,e,r),t=N(t,e));else if(i&&a&&!o&&s)v=1,t=x(t,e,r),t=N(t,e);else if(!i&&!o&&a^s){var n=c;a?(v=1,t=x(t,e,r),v=0,c=!1,t=x(t,e,r),c=n):(v=0,t=x(t,e,r),t=N(t,e),v=1,c=!1,t=x(t,e,r),c=n,t=N(t,e));}}else v=0,t=x(t,e,r);else v=a?1:0,t=x(t,e,r);return t},this.__bidiEngine__.setOptions=function(t){t&&(i=t.isInputVisual,o=t.isOutputVisual,a=t.isInputRtl,s=t.isOutputRtl,c=t.isSymmetricSwapping);},this.__bidiEngine__.setOptions(t),this.__bidiEngine__};var e=["BN","BN","BN","BN","BN","BN","BN","BN","BN","S","B","S","WS","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","B","B","B","S","WS","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","BN","BN","BN","BN","BN","BN","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","CS","N","ET","ET","ET","ET","N","N","N","N","L","N","N","BN","N","N","ET","ET","EN","EN","N","L","N","N","N","EN","L","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","N","N","N","N","N","ET","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","NSM","R","NSM","NSM","R","NSM","NSM","R","NSM","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","N","N","N","N","N","R","R","R","R","R","N","N","N","N","N","N","N","N","N","N","N","AN","AN","AN","AN","AN","AN","N","N","AL","ET","ET","AL","CS","AL","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","AN","AN","AN","AN","AN","AN","AN","AN","AN","ET","AN","AN","AL","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","N","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","NSM","NSM","N","NSM","NSM","NSM","NSM","AL","AL","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","R","N","N","N","N","R","N","N","N","N","N","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","BN","BN","BN","L","R","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","B","LRE","RLE","PDF","LRO","RLO","CS","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","BN","BN","BN","BN","BN","N","LRI","RLI","FSI","PDI","BN","BN","BN","BN","BN","BN","EN","L","N","N","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","L","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","N","N","N","N","N","R","NSM","R","R","R","R","R","R","R","R","R","R","ES","R","R","R","R","R","R","R","R","R","R","R","R","R","N","R","R","R","R","R","N","R","N","R","R","N","R","R","N","R","R","R","R","R","R","R","R","R","R","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","CS","N","N","CS","N","N","N","N","N","N","N","N","N","ET","N","N","ES","ES","N","N","N","N","N","ET","ET","N","N","N","N","N","AL","AL","AL","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","BN","N","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","N","N","N","ET","ET","N","N","N","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N"],r=new t.__bidiEngine__({isInputVisual:!0});t.API.events.push(["postProcessText",function(t){var e=t.text,n=(t.x,t.y,t.options||{}),i=(t.mutex,n.lang,[]);if(n.isInputVisual="boolean"!=typeof n.isInputVisual||n.isInputVisual,r.setOptions(n),"[object Array]"===Object.prototype.toString.call(e)){var a=0;for(i=[],a=0;a<e.length;a+=1)"[object Array]"===Object.prototype.toString.call(e[a])?i.push([r.doBidiReorder(e[a][0]),e[a][1],e[a][2]]):i.push([r.doBidiReorder(e[a])]);t.text=i;}else t.text=r.doBidiReorder(e);r.setOptions({isInputVisual:!0});}]);}(E$1),E$1.API.TTFFont=function(){function t(t){var e;if(this.rawData=t,e=this.contents=new ne$1(t),this.contents.pos=4,"ttcf"===e.readString(4))throw new Error("TTCF not supported.");e.pos=0,this.parse(),this.subset=new Le(this),this.registerTTF();}return t.open=function(e){return new t(e)},t.prototype.parse=function(){return this.directory=new ie(this.contents),this.head=new se(this),this.name=new pe(this),this.cmap=new ue(this),this.toUnicode={},this.hhea=new he(this),this.maxp=new ge$1(this),this.hmtx=new me(this),this.post=new fe(this),this.os2=new le$1(this),this.loca=new Ne(this),this.glyf=new be(this),this.ascender=this.os2.exists&&this.os2.ascender||this.hhea.ascender,this.decender=this.os2.exists&&this.os2.decender||this.hhea.decender,this.lineGap=this.os2.exists&&this.os2.lineGap||this.hhea.lineGap,this.bbox=[this.head.xMin,this.head.yMin,this.head.xMax,this.head.yMax]},t.prototype.registerTTF=function(){var t,e,r,n,i;if(this.scaleFactor=1e3/this.head.unitsPerEm,this.bbox=function(){var e,r,n,i;for(i=[],e=0,r=(n=this.bbox).length;e<r;e++)t=n[e],i.push(Math.round(t*this.scaleFactor));return i}.call(this),this.stemV=0,this.post.exists?(r=255&(n=this.post.italic_angle),0!=(32768&(e=n>>16))&&(e=-(1+(65535^e))),this.italicAngle=+(e+"."+r)):this.italicAngle=0,this.ascender=Math.round(this.ascender*this.scaleFactor),this.decender=Math.round(this.decender*this.scaleFactor),this.lineGap=Math.round(this.lineGap*this.scaleFactor),this.capHeight=this.os2.exists&&this.os2.capHeight||this.ascender,this.xHeight=this.os2.exists&&this.os2.xHeight||0,this.familyClass=(this.os2.exists&&this.os2.familyClass||0)>>8,this.isSerif=1===(i=this.familyClass)||2===i||3===i||4===i||5===i||7===i,this.isScript=10===this.familyClass,this.flags=0,this.post.isFixedPitch&&(this.flags|=1),this.isSerif&&(this.flags|=2),this.isScript&&(this.flags|=8),0!==this.italicAngle&&(this.flags|=64),this.flags|=32,!this.cmap.unicode)throw new Error("No unicode cmap for font")},t.prototype.characterToGlyph=function(t){var e;return (null!=(e=this.cmap.unicode)?e.codeMap[t]:void 0)||0},t.prototype.widthOfGlyph=function(t){var e;return e=1e3/this.head.unitsPerEm,this.hmtx.forGlyph(t).advance*e},t.prototype.widthOfString=function(t,e,r){var n,i,a,o;for(a=0,i=0,o=(t=""+t).length;0<=o?i<o:i>o;i=0<=o?++i:--i)n=t.charCodeAt(i),a+=this.widthOfGlyph(this.characterToGlyph(n))+r*(1e3/e)||0;return a*(e/1e3)},t.prototype.lineHeight=function(t,e){var r;return null==e&&(e=!1),r=e?this.lineGap:0,(this.ascender+r-this.decender)/1e3*t},t}();var re$1,ne$1=function(){function t(t){this.data=null!=t?t:[],this.pos=0,this.length=this.data.length;}return t.prototype.readByte=function(){return this.data[this.pos++]},t.prototype.writeByte=function(t){return this.data[this.pos++]=t},t.prototype.readUInt32=function(){return 16777216*this.readByte()+(this.readByte()<<16)+(this.readByte()<<8)+this.readByte()},t.prototype.writeUInt32=function(t){return this.writeByte(t>>>24&255),this.writeByte(t>>16&255),this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt32=function(){var t;return (t=this.readUInt32())>=2147483648?t-4294967296:t},t.prototype.writeInt32=function(t){return t<0&&(t+=4294967296),this.writeUInt32(t)},t.prototype.readUInt16=function(){return this.readByte()<<8|this.readByte()},t.prototype.writeUInt16=function(t){return this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt16=function(){var t;return (t=this.readUInt16())>=32768?t-65536:t},t.prototype.writeInt16=function(t){return t<0&&(t+=65536),this.writeUInt16(t)},t.prototype.readString=function(t){var e,r;for(r=[],e=0;0<=t?e<t:e>t;e=0<=t?++e:--e)r[e]=String.fromCharCode(this.readByte());return r.join("")},t.prototype.writeString=function(t){var e,r,n;for(n=[],e=0,r=t.length;0<=r?e<r:e>r;e=0<=r?++e:--e)n.push(this.writeByte(t.charCodeAt(e)));return n},t.prototype.readShort=function(){return this.readInt16()},t.prototype.writeShort=function(t){return this.writeInt16(t)},t.prototype.readLongLong=function(){var t,e,r,n,i,a,o,s;return t=this.readByte(),e=this.readByte(),r=this.readByte(),n=this.readByte(),i=this.readByte(),a=this.readByte(),o=this.readByte(),s=this.readByte(),128&t?-1*(72057594037927940*(255^t)+281474976710656*(255^e)+1099511627776*(255^r)+4294967296*(255^n)+16777216*(255^i)+65536*(255^a)+256*(255^o)+(255^s)+1):72057594037927940*t+281474976710656*e+1099511627776*r+4294967296*n+16777216*i+65536*a+256*o+s},t.prototype.writeLongLong=function(t){var e,r;return e=Math.floor(t/4294967296),r=4294967295&t,this.writeByte(e>>24&255),this.writeByte(e>>16&255),this.writeByte(e>>8&255),this.writeByte(255&e),this.writeByte(r>>24&255),this.writeByte(r>>16&255),this.writeByte(r>>8&255),this.writeByte(255&r)},t.prototype.readInt=function(){return this.readInt32()},t.prototype.writeInt=function(t){return this.writeInt32(t)},t.prototype.read=function(t){var e,r;for(e=[],r=0;0<=t?r<t:r>t;r=0<=t?++r:--r)e.push(this.readByte());return e},t.prototype.write=function(t){var e,r,n,i;for(i=[],r=0,n=t.length;r<n;r++)e=t[r],i.push(this.writeByte(e));return i},t}(),ie=function(){var t;function e(t){var e,r,n;for(this.scalarType=t.readInt(),this.tableCount=t.readShort(),this.searchRange=t.readShort(),this.entrySelector=t.readShort(),this.rangeShift=t.readShort(),this.tables={},r=0,n=this.tableCount;0<=n?r<n:r>n;r=0<=n?++r:--r)e={tag:t.readString(4),checksum:t.readInt(),offset:t.readInt(),length:t.readInt()},this.tables[e.tag]=e;}return e.prototype.encode=function(e){var r,n,i,a,o,s,c,u,h,l,f,d,p;for(p in f=Object.keys(e).length,s=Math.log(2),h=16*Math.floor(Math.log(f)/s),a=Math.floor(h/s),u=16*f-h,(n=new ne$1).writeInt(this.scalarType),n.writeShort(f),n.writeShort(h),n.writeShort(a),n.writeShort(u),i=16*f,c=n.pos+i,o=null,d=[],e)for(l=e[p],n.writeString(p),n.writeInt(t(l)),n.writeInt(c),n.writeInt(l.length),d=d.concat(l),"head"===p&&(o=c),c+=l.length;c%4;)d.push(0),c++;return n.write(d),r=2981146554-t(n.data),n.pos=o+8,n.writeUInt32(r),n.data},t=function(t){var e,r,n,i;for(t=ve.call(t);t.length%4;)t.push(0);for(n=new ne$1(t),r=0,e=0,i=t.length;e<i;e=e+=4)r+=n.readUInt32();return 4294967295&r},e}(),ae={}.hasOwnProperty,oe=function(t,e){for(var r in e)ae.call(e,r)&&(t[r]=e[r]);function n(){this.constructor=t;}return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t};re$1=function(){function t(t){var e;this.file=t,e=this.file.directory.tables[this.tag],this.exists=!!e,e&&(this.offset=e.offset,this.length=e.length,this.parse(this.file.contents));}return t.prototype.parse=function(){},t.prototype.encode=function(){},t.prototype.raw=function(){return this.exists?(this.file.contents.pos=this.offset,this.file.contents.read(this.length)):null},t}();var se=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="head",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.revision=t.readInt(),this.checkSumAdjustment=t.readInt(),this.magicNumber=t.readInt(),this.flags=t.readShort(),this.unitsPerEm=t.readShort(),this.created=t.readLongLong(),this.modified=t.readLongLong(),this.xMin=t.readShort(),this.yMin=t.readShort(),this.xMax=t.readShort(),this.yMax=t.readShort(),this.macStyle=t.readShort(),this.lowestRecPPEM=t.readShort(),this.fontDirectionHint=t.readShort(),this.indexToLocFormat=t.readShort(),this.glyphDataFormat=t.readShort()},e.prototype.encode=function(t){var e;return (e=new ne$1).writeInt(this.version),e.writeInt(this.revision),e.writeInt(this.checkSumAdjustment),e.writeInt(this.magicNumber),e.writeShort(this.flags),e.writeShort(this.unitsPerEm),e.writeLongLong(this.created),e.writeLongLong(this.modified),e.writeShort(this.xMin),e.writeShort(this.yMin),e.writeShort(this.xMax),e.writeShort(this.yMax),e.writeShort(this.macStyle),e.writeShort(this.lowestRecPPEM),e.writeShort(this.fontDirectionHint),e.writeShort(t),e.writeShort(this.glyphDataFormat),e.data},e}(),ce=function(){function t(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m,v,b;switch(this.platformID=t.readUInt16(),this.encodingID=t.readShort(),this.offset=e+t.readInt(),h=t.pos,t.pos=this.offset,this.format=t.readUInt16(),this.length=t.readUInt16(),this.language=t.readUInt16(),this.isUnicode=3===this.platformID&&1===this.encodingID&&4===this.format||0===this.platformID&&4===this.format,this.codeMap={},this.format){case 0:for(s=0;s<256;++s)this.codeMap[s]=t.readByte();break;case 4:for(f=t.readUInt16(),l=f/2,t.pos+=6,i=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),t.pos+=2,p=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),c=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),u=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),n=(this.length-t.pos+this.offset)/2,o=function(){var e,r;for(r=[],s=e=0;0<=n?e<n:e>n;s=0<=n?++e:--e)r.push(t.readUInt16());return r}(),s=m=0,b=i.length;m<b;s=++m)for(g=i[s],r=v=d=p[s];d<=g?v<=g:v>=g;r=d<=g?++v:--v)0===u[s]?a=r+c[s]:0!==(a=o[u[s]/2+(r-d)-(l-s)]||0)&&(a+=c[s]),this.codeMap[r]=65535&a;}t.pos=h;}return t.encode=function(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m,v,b,y,w,N,L,A,x,S,_,P,k,I,F,C,j,O,B,M,E,q,D,R,T,U,z,H,W,V,G,Y;switch(I=new ne$1,a=Object.keys(t).sort((function(t,e){return t-e})),e){case"macroman":for(p=0,g=function(){var t=[];for(d=0;d<256;++d)t.push(0);return t}(),v={0:0},i={},F=0,B=a.length;F<B;F++)null==v[W=t[n=a[F]]]&&(v[W]=++p),i[n]={old:t[n],new:v[t[n]]},g[n]=v[t[n]];return I.writeUInt16(1),I.writeUInt16(0),I.writeUInt32(12),I.writeUInt16(0),I.writeUInt16(262),I.writeUInt16(0),I.write(g),{charMap:i,subtable:I.data,maxGlyphID:p+1};case"unicode":for(P=[],h=[],b=0,v={},r={},m=c=null,C=0,M=a.length;C<M;C++)null==v[w=t[n=a[C]]]&&(v[w]=++b),r[n]={old:w,new:v[w]},o=v[w]-n,null!=m&&o===c||(m&&h.push(m),P.push(n),c=o),m=n;for(m&&h.push(m),h.push(65535),P.push(65535),S=2*(x=P.length),A=2*Math.pow(Math.log(x)/Math.LN2,2),l=Math.log(A/2)/Math.LN2,L=2*x-A,s=[],N=[],f=[],d=j=0,E=P.length;j<E;d=++j){if(_=P[d],u=h[d],65535===_){s.push(0),N.push(0);break}if(_-(k=r[_].new)>=32768)for(s.push(0),N.push(2*(f.length+x-d)),n=O=_;_<=u?O<=u:O>=u;n=_<=u?++O:--O)f.push(r[n].new);else s.push(k-_),N.push(0);}for(I.writeUInt16(3),I.writeUInt16(1),I.writeUInt32(12),I.writeUInt16(4),I.writeUInt16(16+8*x+2*f.length),I.writeUInt16(0),I.writeUInt16(S),I.writeUInt16(A),I.writeUInt16(l),I.writeUInt16(L),z=0,q=h.length;z<q;z++)n=h[z],I.writeUInt16(n);for(I.writeUInt16(0),H=0,D=P.length;H<D;H++)n=P[H],I.writeUInt16(n);for(V=0,R=s.length;V<R;V++)o=s[V],I.writeUInt16(o);for(G=0,T=N.length;G<T;G++)y=N[G],I.writeUInt16(y);for(Y=0,U=f.length;Y<U;Y++)p=f[Y],I.writeUInt16(p);return {charMap:r,subtable:I.data,maxGlyphID:b+1}}},t}(),ue=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="cmap",e.prototype.parse=function(t){var e,r,n;for(t.pos=this.offset,this.version=t.readUInt16(),n=t.readUInt16(),this.tables=[],this.unicode=null,r=0;0<=n?r<n:r>n;r=0<=n?++r:--r)e=new ce(t,this.offset),this.tables.push(e),e.isUnicode&&null==this.unicode&&(this.unicode=e);return !0},e.encode=function(t,e){var r,n;return null==e&&(e="macroman"),r=ce.encode(t,e),(n=new ne$1).writeUInt16(0),n.writeUInt16(1),r.table=n.data.concat(r.subtable),r},e}(),he=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="hhea",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.ascender=t.readShort(),this.decender=t.readShort(),this.lineGap=t.readShort(),this.advanceWidthMax=t.readShort(),this.minLeftSideBearing=t.readShort(),this.minRightSideBearing=t.readShort(),this.xMaxExtent=t.readShort(),this.caretSlopeRise=t.readShort(),this.caretSlopeRun=t.readShort(),this.caretOffset=t.readShort(),t.pos+=8,this.metricDataFormat=t.readShort(),this.numberOfMetrics=t.readUInt16()},e}(),le$1=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="OS/2",e.prototype.parse=function(t){if(t.pos=this.offset,this.version=t.readUInt16(),this.averageCharWidth=t.readShort(),this.weightClass=t.readUInt16(),this.widthClass=t.readUInt16(),this.type=t.readShort(),this.ySubscriptXSize=t.readShort(),this.ySubscriptYSize=t.readShort(),this.ySubscriptXOffset=t.readShort(),this.ySubscriptYOffset=t.readShort(),this.ySuperscriptXSize=t.readShort(),this.ySuperscriptYSize=t.readShort(),this.ySuperscriptXOffset=t.readShort(),this.ySuperscriptYOffset=t.readShort(),this.yStrikeoutSize=t.readShort(),this.yStrikeoutPosition=t.readShort(),this.familyClass=t.readShort(),this.panose=function(){var e,r;for(r=[],e=0;e<10;++e)r.push(t.readByte());return r}(),this.charRange=function(){var e,r;for(r=[],e=0;e<4;++e)r.push(t.readInt());return r}(),this.vendorID=t.readString(4),this.selection=t.readShort(),this.firstCharIndex=t.readShort(),this.lastCharIndex=t.readShort(),this.version>0&&(this.ascent=t.readShort(),this.descent=t.readShort(),this.lineGap=t.readShort(),this.winAscent=t.readShort(),this.winDescent=t.readShort(),this.codePageRange=function(){var e,r;for(r=[],e=0;e<2;e=++e)r.push(t.readInt());return r}(),this.version>1))return this.xHeight=t.readShort(),this.capHeight=t.readShort(),this.defaultChar=t.readShort(),this.breakChar=t.readShort(),this.maxContext=t.readShort()},e}(),fe=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="post",e.prototype.parse=function(t){var e,r,n;switch(t.pos=this.offset,this.format=t.readInt(),this.italicAngle=t.readInt(),this.underlinePosition=t.readShort(),this.underlineThickness=t.readShort(),this.isFixedPitch=t.readInt(),this.minMemType42=t.readInt(),this.maxMemType42=t.readInt(),this.minMemType1=t.readInt(),this.maxMemType1=t.readInt(),this.format){case 65536:break;case 131072:var i;for(r=t.readUInt16(),this.glyphNameIndex=[],i=0;0<=r?i<r:i>r;i=0<=r?++i:--i)this.glyphNameIndex.push(t.readUInt16());for(this.names=[],n=[];t.pos<this.offset+this.length;)e=t.readByte(),n.push(this.names.push(t.readString(e)));return n;case 151552:return r=t.readUInt16(),this.offsets=t.read(r);case 196608:break;case 262144:return this.map=function(){var e,r,n;for(n=[],i=e=0,r=this.file.maxp.numGlyphs;0<=r?e<r:e>r;i=0<=r?++e:--e)n.push(t.readUInt32());return n}.call(this)}},e}(),de=function(t,e){this.raw=t,this.length=t.length,this.platformID=e.platformID,this.encodingID=e.encodingID,this.languageID=e.languageID;},pe=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="name",e.prototype.parse=function(t){var e,r,n,i,a,o,s,c,u,h,l;for(t.pos=this.offset,t.readShort(),e=t.readShort(),o=t.readShort(),r=[],i=0;0<=e?i<e:i>e;i=0<=e?++i:--i)r.push({platformID:t.readShort(),encodingID:t.readShort(),languageID:t.readShort(),nameID:t.readShort(),length:t.readShort(),offset:this.offset+o+t.readShort()});for(s={},i=u=0,h=r.length;u<h;i=++u)n=r[i],t.pos=n.offset,c=t.readString(n.length),a=new de(c,n),null==s[l=n.nameID]&&(s[l]=[]),s[n.nameID].push(a);this.strings=s,this.copyright=s[0],this.fontFamily=s[1],this.fontSubfamily=s[2],this.uniqueSubfamily=s[3],this.fontName=s[4],this.version=s[5];try{this.postscriptName=s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}catch(t){this.postscriptName=s[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}return this.trademark=s[7],this.manufacturer=s[8],this.designer=s[9],this.description=s[10],this.vendorUrl=s[11],this.designerUrl=s[12],this.license=s[13],this.licenseUrl=s[14],this.preferredFamily=s[15],this.preferredSubfamily=s[17],this.compatibleFull=s[18],this.sampleText=s[19]},e}(),ge$1=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="maxp",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.numGlyphs=t.readUInt16(),this.maxPoints=t.readUInt16(),this.maxContours=t.readUInt16(),this.maxCompositePoints=t.readUInt16(),this.maxComponentContours=t.readUInt16(),this.maxZones=t.readUInt16(),this.maxTwilightPoints=t.readUInt16(),this.maxStorage=t.readUInt16(),this.maxFunctionDefs=t.readUInt16(),this.maxInstructionDefs=t.readUInt16(),this.maxStackElements=t.readUInt16(),this.maxSizeOfInstructions=t.readUInt16(),this.maxComponentElements=t.readUInt16(),this.maxComponentDepth=t.readUInt16()},e}(),me=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="hmtx",e.prototype.parse=function(t){var e,r,n,i,a,o,s;for(t.pos=this.offset,this.metrics=[],e=0,o=this.file.hhea.numberOfMetrics;0<=o?e<o:e>o;e=0<=o?++e:--e)this.metrics.push({advance:t.readUInt16(),lsb:t.readInt16()});for(n=this.file.maxp.numGlyphs-this.file.hhea.numberOfMetrics,this.leftSideBearings=function(){var r,i;for(i=[],e=r=0;0<=n?r<n:r>n;e=0<=n?++r:--r)i.push(t.readInt16());return i}(),this.widths=function(){var t,e,r,n;for(n=[],t=0,e=(r=this.metrics).length;t<e;t++)i=r[t],n.push(i.advance);return n}.call(this),r=this.widths[this.widths.length-1],s=[],e=a=0;0<=n?a<n:a>n;e=0<=n?++a:--a)s.push(this.widths.push(r));return s},e.prototype.forGlyph=function(t){return t in this.metrics?this.metrics[t]:{advance:this.metrics[this.metrics.length-1].advance,lsb:this.leftSideBearings[t-this.metrics.length]}},e}(),ve=[].slice,be=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="glyf",e.prototype.parse=function(){return this.cache={}},e.prototype.glyphFor=function(t){var e,r,n,i,a,o,s,c,u,h;return t in this.cache?this.cache[t]:(i=this.file.loca,e=this.file.contents,r=i.indexOf(t),0===(n=i.lengthOf(t))?this.cache[t]=null:(e.pos=this.offset+r,a=(o=new ne$1(e.read(n))).readShort(),c=o.readShort(),h=o.readShort(),s=o.readShort(),u=o.readShort(),this.cache[t]=-1===a?new we(o,c,h,s,u):new ye(o,a,c,h,s,u),this.cache[t]))},e.prototype.encode=function(t,e,r){var n,i,a,o,s;for(a=[],i=[],o=0,s=e.length;o<s;o++)n=t[e[o]],i.push(a.length),n&&(a=a.concat(n.encode(r)));return i.push(a.length),{table:a,offsets:i}},e}(),ye=function(){function t(t,e,r,n,i,a){this.raw=t,this.numberOfContours=e,this.xMin=r,this.yMin=n,this.xMax=i,this.yMax=a,this.compound=!1;}return t.prototype.encode=function(){return this.raw.data},t}(),we=function(){function t(t,e,r,n,i){var a,o;for(this.raw=t,this.xMin=e,this.yMin=r,this.xMax=n,this.yMax=i,this.compound=!0,this.glyphIDs=[],this.glyphOffsets=[],a=this.raw;o=a.readShort(),this.glyphOffsets.push(a.pos),this.glyphIDs.push(a.readUInt16()),32&o;)a.pos+=1&o?4:2,128&o?a.pos+=8:64&o?a.pos+=4:8&o&&(a.pos+=2);}return t.prototype.encode=function(){var t,e,r;for(e=new ne$1(ve.call(this.raw.data)),t=0,r=this.glyphIDs.length;t<r;++t)e.pos=this.glyphOffsets[t];return e.data},t}(),Ne=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re$1),e.prototype.tag="loca",e.prototype.parse=function(t){var e,r;return t.pos=this.offset,e=this.file.head.indexToLocFormat,this.offsets=0===e?function(){var e,n;for(n=[],r=0,e=this.length;r<e;r+=2)n.push(2*t.readUInt16());return n}.call(this):function(){var e,n;for(n=[],r=0,e=this.length;r<e;r+=4)n.push(t.readUInt32());return n}.call(this)},e.prototype.indexOf=function(t){return this.offsets[t]},e.prototype.lengthOf=function(t){return this.offsets[t+1]-this.offsets[t]},e.prototype.encode=function(t,e){for(var r=new Uint32Array(this.offsets.length),n=0,i=0,a=0;a<r.length;++a)if(r[a]=n,i<e.length&&e[i]==a){++i,r[a]=n;var o=this.offsets[a],s=this.offsets[a+1]-o;s>0&&(n+=s);}for(var c=new Array(4*r.length),u=0;u<r.length;++u)c[4*u+3]=255&r[u],c[4*u+2]=(65280&r[u])>>8,c[4*u+1]=(16711680&r[u])>>16,c[4*u]=(4278190080&r[u])>>24;return c},e}(),Le=function(){function t(t){this.font=t,this.subset={},this.unicodes={},this.next=33;}return t.prototype.generateCmap=function(){var t,e,r,n,i;for(e in n=this.font.cmap.tables[0].codeMap,t={},i=this.subset)r=i[e],t[e]=n[r];return t},t.prototype.glyphsFor=function(t){var e,r,n,i,a,o,s;for(n={},a=0,o=t.length;a<o;a++)n[i=t[a]]=this.font.glyf.glyphFor(i);for(i in e=[],n)(null!=(r=n[i])?r.compound:void 0)&&e.push.apply(e,r.glyphIDs);if(e.length>0)for(i in s=this.glyphsFor(e))r=s[i],n[i]=r;return n},t.prototype.encode=function(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m;for(n in r=ue.encode(this.generateCmap(),"unicode"),a=this.glyphsFor(t),f={0:0},m=r.charMap)f[(s=m[n]).old]=s.new;for(d in l=r.maxGlyphID,a)d in f||(f[d]=l++);return u=function(t){var e,r;for(e in r={},t)r[t[e]]=e;return r}(f),h=Object.keys(u).sort((function(t,e){return t-e})),p=function(){var t,e,r;for(r=[],t=0,e=h.length;t<e;t++)o=h[t],r.push(u[o]);return r}(),i=this.font.glyf.encode(a,p,f),c=this.font.loca.encode(i.offsets,p),g={cmap:this.font.cmap.raw(),glyf:i.table,loca:c,hmtx:this.font.hmtx.raw(),hhea:this.font.hhea.raw(),maxp:this.font.maxp.raw(),post:this.font.post.raw(),name:this.font.name.raw(),head:this.font.head.encode(e)},this.font.os2.exists&&(g["OS/2"]=this.font.os2.raw()),this.font.directory.encode(g)},t}();E$1.API.PDFObject=function(){var t;function e(){}return t=function(t,e){return (Array(e+1).join("0")+t).slice(-e)},e.convert=function(r){var n,i,a,o;if(Array.isArray(r))return "["+function(){var t,i,a;for(a=[],t=0,i=r.length;t<i;t++)n=r[t],a.push(e.convert(n));return a}().join(" ")+"]";if("string"==typeof r)return "/"+r;if(null!=r?r.isString:void 0)return "("+r+")";if(r instanceof Date)return "(D:"+t(r.getUTCFullYear(),4)+t(r.getUTCMonth(),2)+t(r.getUTCDate(),2)+t(r.getUTCHours(),2)+t(r.getUTCMinutes(),2)+t(r.getUTCSeconds(),2)+"Z)";if("[object Object]"==={}.toString.call(r)){for(i in a=["<<"],r)o=r[i],a.push("/"+i+" "+e.convert(o));return a.push(">>"),a.join("\n")}return ""+r},e}();

  var scratchLookAtHeadingPitchRangeOffset = new Cesium__namespace.Cartesian3();
  var scratchLookAtHeadingPitchRangeQuaternion1 = new Cesium__namespace.Quaternion();
  var scratchLookAtHeadingPitchRangeQuaternion2 = new Cesium__namespace.Quaternion();
  var scratchHeadingPitchRangeMatrix3 = new Cesium__namespace.Matrix3();
  var scratchflyToBoundingSphereTransform = new Cesium__namespace.Matrix4();
  function reviseRange(range, pitch, heading, boundingSphere) {
      if (!defined$1(range)) {
          return void 0;
      }
      var newRange = range / Math.cos(Math.PI * 0.5 - Math.abs(pitch));
      var pitchNew = Cesium__namespace.Math.clamp(pitch, -Cesium__namespace.Math.PI_OVER_TWO, Cesium__namespace.Math.PI_OVER_TWO);
      var headingNew = Cesium__namespace.Math.zeroToTwoPi(heading) - Cesium__namespace.Math.PI_OVER_TWO;
      var pitchQuat = Cesium__namespace.Quaternion.fromAxisAngle(Cesium__namespace.Cartesian3.UNIT_Y, -pitchNew, scratchLookAtHeadingPitchRangeQuaternion1);
      var headingQuat = Cesium__namespace.Quaternion.fromAxisAngle(Cesium__namespace.Cartesian3.UNIT_Z, -headingNew, scratchLookAtHeadingPitchRangeQuaternion2);
      var rotQuat = Cesium__namespace.Quaternion.multiply(headingQuat, pitchQuat, headingQuat);
      var rotMatrix = Cesium__namespace.Matrix3.fromQuaternion(rotQuat, scratchHeadingPitchRangeMatrix3);
      var transform = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(boundingSphere.center, Cesium__namespace.Ellipsoid.WGS84, scratchflyToBoundingSphereTransform);
      var positionCartographic = new Cesium__namespace.Cartographic();
      var minRange = 0;
      var maxRange = newRange;
      var currentHeight;
      do {
          var offset = Cesium__namespace.Cartesian3.clone(Cesium__namespace.Cartesian3.UNIT_X, scratchLookAtHeadingPitchRangeOffset);
          Cesium__namespace.Matrix3.multiplyByVector(rotMatrix, offset, offset);
          Cesium__namespace.Cartesian3.negate(offset, offset);
          Cesium__namespace.Cartesian3.multiplyByScalar(offset, newRange, offset);
          Cesium__namespace.Matrix4.multiplyByPoint(transform, offset, offset);
          currentHeight = this.map.scene.globe.ellipsoid.cartesianToCartographic(offset, positionCartographic).height;
          if (parseInt(range + "") === parseInt(currentHeight)) {
              break;
          }
          else if (range < currentHeight) {
              maxRange = newRange;
              newRange = (maxRange - minRange) / 2 + minRange;
          }
          else {
              minRange = newRange;
              newRange = (maxRange - minRange) / 2 + minRange;
          }
      } while (true);
      return newRange;
  }

  var BaseViewerOptions = {
      rotate: true,
      animation: false,
      baseLayerPicker: false,
      geocoder: false,
      timeline: false,
      sceneModePicker: false,
      navigationHelpButton: false,
      infoBox: false,
      fullscreenButton: false,
      homeButton: false,
      selectionIndicator: false,
      navigationInstructionsInitiallyVisible: false,
      shouldAnimate: true,
      // creditContainer:document.createElement('div'),
      imageryProvider: false,
      // terrainProvider:Cesium.createWorldTerrain({}),
      contextOptions: {
          webgl: {
              preserveDrawingBuffer: true
          },
          allowTextureFilterAnisotropic: true
      }
  };
  var clickHandleLauncher;
  /**
   * 地球拾取触发模式
   */
  var PickModelEnum;
  (function (PickModelEnum) {
      /**
       * 单选模式
       */
      PickModelEnum["SINGLE"] = "single";
      /**
       * 多选模式
       */
      PickModelEnum["MULTI"] = "multi";
  })(PickModelEnum || (PickModelEnum = {}));
  /**
   * 地图类
   */
  var Map$1 = /** @class */ (function (_super) {
      __extends$3(Map, _super);
      function Map(options) {
          var _this = _super.call(this) || this;
          /**
           * @ignore
           */
          _this._depthAgainstTerrain = false;
          /**
           * @ignore
           */
          _this._layerCollection = new BaseCollection({ id: "layer-collection" });
          /**
           * @ignore
           */
          _this._overlayCollection = new BaseCollection({ id: "overlay-collection" });
          /**
           * @ignore
           */
          _this._componentCollection = new BaseCollection({
              id: "component-collection"
          });
          /**
           * @ignore
           */
          _this._modelCollection = new BaseCollection({
              id: "model-collection"
          });
          /**
           * @ignore
           */
          _this._billboardCollectionStore = [];
          /**
           * @ignore
           */
          _this._labelCollectionStore = [];
          /**
           * @ignore
           */
          _this._pointCollectionStore = [];
          vertifyParam(options, ["target", "center"]);
          if (!defined$1(options.zoom)) {
              options.zoom = PUBLIC_CONFIG.zoom;
          }
          if (options.zoom < options.minZoom) {
              options.zoom = options.minZoom;
          }
          if (options.zoom > options.maxZoom) {
              options.zoom = options.maxZoom;
          }
          if (defined$1(options.extent)) {
              _this._extent = options.extent;
          }
          _this._options = options;
          _this._events = [];
          // TODO:地图初始化参数固定
          var destination = options.center; // [...options.center]
          var viewer = new Cesium__namespace.Viewer(options.target, merge$2({}, BaseViewerOptions, options));
          _this._map = viewer;
          _this.setZoom(destination.length > 2 ? heightToZoom(destination[2]) : options.zoom);
          _this.setCenter(options.center);
          _this.setMaxPitch(options.maxPitch);
          _this.setMinPitch(options.minPitch);
          if (defined$1(options.orientation)) {
              _this.setOrientation(options.orientation);
          }
          else {
              options.orientation = [0, -90, 0];
          }
          _this.setDepthAgainstTerrain(defined$1(options.depthAgainstTerrain) ? options.depthAgainstTerrain : false);
          _this.setFxaa(defined$1(options.fxaa) ? options.fxaa : false);
          _this.setDefaultTextureVisibility(defined$1(options.defaultTextureVisibility) ? options.defaultTextureVisibility : false);
          _this.setBrightness(defined$1(options.brightness) ? options.brightness : 1);
          //最大显示级别
          if (defined$1(options.maxZoom)) {
              viewer.scene.screenSpaceCameraController.minimumZoomDistance = zoomToHeight(options.maxZoom);
          }
          //最小显示级别
          if (defined$1(options.minZoom)) {
              viewer.scene.screenSpaceCameraController.maximumZoomDistance = zoomToHeight(options.minZoom);
          }
          // 默认禁止触发双击
          viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
          /* 修改默认移除基元销毁 */
          viewer.scene.primitives.destroyPrimitives = false;
          viewer.scene.groundPrimitives.destroyPrimitives = false;
          /*------------------- */
          viewer.resolutionScale = window.devicePixelRatio; //设置为屏幕的放缩比例
          viewer.container.getElementsByClassName("cesium-widget-credits")[0].style.display = "none";
          /* 定义默认鼠标控制 */
          /**
           * 右键拖拽控制相机的倾斜
           * 鼠标滚轮控制相机的高度变化
           */
          _this.map.scene.screenSpaceCameraController.tiltEventTypes = [
              1 /* RIGHT_DRAG */,
              4 /* PINCH */
          ];
          _this.map.scene.screenSpaceCameraController.zoomEventTypes = [
              3 /* WHEEL */,
              4 /* PINCH */
          ];
          /* ------------- */
          /* 覆盖物DOM容器初始化 */
          _this._overlayContainerStopEvent = document.createElement("div");
          _this._overlayContainerStopEvent.className = "cesium-viewer-overlay-container-stopevent";
          _this._overlayContainer = document.createElement("div");
          _this._overlayContainer.className = "cesium-viewer-overlay-container";
          // @ts-ignore
          viewer._element.appendChild(_this._overlayContainer);
          // @ts-ignore
          viewer._element.appendChild(_this._overlayContainerStopEvent);
          /*---------------- */
          _this._initEvent();
          // 相机约束
          _this.map.camera.moveEnd.addEventListener(function () {
              if (!defined$1(_this.extent)) {
                  return;
              }
              var _a = __read(_this.extent, 4), xMin = _a[0], yMin = _a[1], xMax = _a[2], yMax = _a[3];
              var center = _this.center;
              if (!Turf__namespace.booleanPointInPolygon(center, Turf__namespace.bboxPolygon(_this.extent))) {
                  var lng = 0;
                  var lat = 0;
                  if ((center[0] - xMin) * (center[0] - xMax) > 0) {
                      lng = center[0] < xMin ? center[0] - xMin : center[0] - xMax;
                  }
                  if ((center[1] - yMin) * (center[1] - yMax) > 0) {
                      lat = center[1] < yMin ? center[1] - yMin : center[1] - yMax;
                  }
                  center[0] -= lng;
                  center[1] -= lat;
                  _this.flyTo({ center: center, duration: 0.2 });
              }
          });
          return _this;
      }
      Object.defineProperty(Map.prototype, "map", {
          /**
           * @ignore
           */
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "position", {
          /**
           * 地图定位参数
           */
          get: function () {
              return {
                  center: this.center,
                  zoom: this.zoom,
                  orientation: this.orientation
              };
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "zoom", {
          /**
           * 显示级别
           */
          get: function () {
              return getZoom(this);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "center", {
          /**
           * 地图中心坐标
           *
           */
          get: function () {
              return getCenter$1(this);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "orientation", {
          /**
           * 视图方向
           *
           */
          get: function () {
              return getDegreesOfCamera(this).orientation.map(function (i) { return parseFloat(i.toFixed(3)) % 360; });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "depthAgainstTerrain", {
          /**
           * 地形深度检测开启状态
           *
           * [cesium]
           */
          get: function () {
              return this._depthAgainstTerrain;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "fxaa", {
          /**
           * 抗锯齿开启状态
           *
           * [cesium]
           */
          get: function () {
              return this._fxaa;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "defaultTextureVisibility", {
          /**
           * 默认纹理可见性
           *
           * [cesium]
           */
          get: function () {
              return this._defaultTextureVisibility;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "brightness", {
          /**
           * 环境光数值
           *
           * [cesium]
           *
           */
          get: function () {
              return this._brightness;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "eventOverlayContainer", {
          /**
           * 不可触发事件的overlay容器
           */
          get: function () {
              return this._overlayContainer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "stopEventOverlayContainer", {
          /**
           * 可触发事件的overlay容器
           */
          get: function () {
              return this._overlayContainerStopEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "layers", {
          /**
           * 全部图层
           *
           */
          get: function () {
              return this._layerCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "overlays", {
          /**
           * 全部覆盖物
           *
           */
          get: function () {
              return this._overlayCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "components", {
          /**
           * 全部组件
           *
           */
          get: function () {
              return this._componentCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "models", {
          /**
           * 全部模型
           *
           */
          get: function () {
              return this._modelCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "options", {
          /**
           * @ignore
           */
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "currentExtent", {
          /**
           * 当前地图范围
           */
          get: function () {
              var rectangle = this.map.camera.computeViewRectangle(this.map.scene.globe.ellipsoid);
              if (!defined$1(rectangle)) {
                  var leftTop = this.map.scene.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(0, 0), this.map.scene.globe.ellipsoid);
                  var rightDown = this.map.scene.camera.pickEllipsoid(new Cesium__namespace.Cartesian2(this.map.scene.canvas.width, this.map.scene.canvas.height), this.map.scene.globe.ellipsoid);
                  var leftTopCartographic = this.map.scene.globe.ellipsoid.cartesianToCartographic(leftTop);
                  var rightDownCartographic = this.map.scene.globe.ellipsoid.cartesianToCartographic(rightDown);
                  rectangle = new Cesium__namespace.Rectangle(leftTopCartographic.longitude, rightDownCartographic.latitude, rightDownCartographic.longitude, leftTopCartographic.latitude);
              }
              if (Cesium__namespace.defined(rectangle.west) &&
                  Cesium__namespace.defined(rectangle.south) &&
                  Cesium__namespace.defined(rectangle.east) &&
                  Cesium__namespace.defined(rectangle.north)) {
                  return transformInternal([
                      Cesium__namespace.Math.toDegrees(rectangle.west),
                      Cesium__namespace.Math.toDegrees(rectangle.south),
                      Cesium__namespace.Math.toDegrees(rectangle.east),
                      Cesium__namespace.Math.toDegrees(rectangle.north)
                  ], {
                      source: PUBLIC_CONFIG.projection,
                      destination: PUBLIC_CONFIG.dataProjection
                  });
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "extent", {
          /**
           * 地图显示范围约束
           */
          get: function () {
              return this._extent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "jobScheduler", {
          get: function () {
              this._jobScheduler || (this._jobScheduler = new JobScheduler());
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "maxPitch", {
          /**
           * 最大地图俯仰角
           *
           *
           */
          get: function () {
              return this._maxPitch;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "minPitch", {
          /**
           * 最小地图俯仰角
           */
          get: function () {
              return this._minPitch;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Map.prototype._initEvent = function () {
          var _this = this;
          if (this._eventHelper && this._eventHandler) {
              this._eventHelper.removeAll();
          }
          else {
              this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.canvas);
              this._eventHelper = new Cesium__namespace.EventHelper();
          }
          this._updateScreenSpaceEventHandler();
          this._eventHelper.add(this.map.scene.postRender, cesiumPostRender.bind(this));
          this.map.camera.percentageChanged = 0.2;
          var zoom, center;
          this._eventHelper.add(this.map.camera.changed, function () {
              var currZoom = parseFloat(_this.zoom.toFixed(1));
              var currCenter = _this.center.map(function (n) { return parseFloat(n.toFixed(3)); });
              if (zoom !== currZoom) {
                  _this.dispatchEvent({
                      type: BaseEventType.ZOOM_CHANGED,
                      zoom: currZoom
                  });
                  zoom = currZoom;
              }
              if (center[0] !== currCenter[0] && center[1] !== currCenter[1]) {
                  _this.dispatchEvent({
                      type: BaseEventType.CENTER_CHANGED,
                      center: currCenter
                  });
                  center = currCenter;
              }
          });
          this._eventHelper.add(this.map.camera.moveStart, function () {
              zoom = parseFloat(_this.zoom.toFixed(1));
              center = _this.center.map(function (n) { return parseFloat(n.toFixed(3)); });
              _this.dispatchEvent({ type: BaseEventType.MOVE_START });
          });
          this._eventHelper.add(this.map.camera.moveEnd, function () {
              _this.dispatchEvent({ type: BaseEventType.MOVE_END });
          });
      };
      /**
       * @ignore
       */
      Map.prototype._updateScreenSpaceEventHandler = function () {
          var _this = this;
          // @ts-ignore
          Object.keys(this._eventHandler._inputEvents).forEach(function (key) {
              if (!_this._events.includes(cesiumSpaceEventToBaseEvent(parseInt(key)))) {
                  _this._eventHandler.removeInputAction(Number(key));
              }
          });
          this._events.forEach(function (type) {
              // 是否注册过该类型的监听
              if (!_this._eventHandler.getInputAction(baseEventToCesiumSpace(type))) {
                  // 注册事件监听
                  _this._eventHandler.setInputAction(function (mousement) {
                      if (type === BaseEventType.CLICK) {
                          if (defined$1(clickHandleLauncher)) {
                              clearTimeout(clickHandleLauncher);
                              clickHandleLauncher = void 0;
                          }
                          else {
                              clickHandleLauncher = setTimeout(function () {
                                  clickHandleLauncher = void 0;
                                  eventHandler.call(_this, mousement, type);
                              }, 250);
                          }
                      }
                      else {
                          eventHandler.call(_this, mousement, type);
                      }
                  }, baseEventToCesiumSpace(type));
              }
          });
      };
      /**
       * @ignore
       */
      Map.prototype._add = function (type, item) {
          if (item.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          this["_".concat(type, "Collection")].add(item);
          item.addTo(this);
          var event;
          switch (type) {
              case "model":
                  event = {
                      type: BaseEventType.ADD_MODEL,
                      model: item
                  };
                  break;
              case "layer":
                  event = {
                      type: BaseEventType.ADD_LAYER,
                      layer: item
                  };
                  break;
              case "overlay":
                  event = {
                      type: BaseEventType.ADD_OVERLAY,
                      overlay: item
                  };
                  break;
              case "component":
                  event = {
                      type: BaseEventType.ADD_COMPONENT,
                      component: item
                  };
                  break;
          }
          this.dispatchEvent(event);
      };
      /**
       * @ignore
       */
      Map.prototype._remove = function (type, item, destroy) {
          var temItem = typeof item === "string" ? this["_".concat(type, "Collection")].getItem(item) : item;
          if (temItem) {
              temItem.remove(destroy);
              this["_".concat(type, "Collection")].remove(temItem);
              var event_1;
              switch (type) {
                  case "model":
                      event_1 = {
                          type: BaseEventType.REMOVE_MODEL,
                          model: item
                      };
                      break;
                  case "layer":
                      event_1 = {
                          type: BaseEventType.REMOVE_LAYER,
                          layer: item
                      };
                      break;
                  case "overlay":
                      event_1 = {
                          type: BaseEventType.REMOVE_OVERLAY,
                          overlay: item
                      };
                      break;
                  case "component":
                      event_1 = {
                          type: BaseEventType.REMOVE_COMPONENT,
                          component: item
                      };
                      break;
              }
              this.dispatchEvent(event_1);
          }
      };
      /**
       * @ignore
       */
      Map.prototype._get = function (type, id) {
          return this["_".concat(type, "Collection")].getItem(id);
      };
      /**
       * @ignore
       */
      Map.prototype._has = function (type, id) {
          return this["_".concat(type, "Collection")].include(id);
      };
      /**
       * @ignore
       */
      Map.prototype._clearAll = function (type, destroy, filter) {
          var e_1, _a;
          try {
              for (var _b = __values(this["_".concat(type, "Collection")]), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var i = _c.value;
                  if (defined$1(filter) && !filter(i)) {
                      continue;
                  }
                  this["remove".concat(upperCaseFirstWord(type))](i, destroy);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Map.prototype._getAll = function (type) {
          return this["_".concat(type, "Collection")].getArray();
      };
      // /**
      //  *
      //  * @param data
      //  * @param options
      //  */
      // addData(data, options) {}
      /**
       * 获取图层
       *
       * @param id 图层id
       * @return {*}
       */
      Map.prototype.getLayer = function (id) {
          return this._get("layer", id);
      };
      /**
       * 获取全部图层
       *
       * @return {*}
       */
      Map.prototype.getLayers = function () {
          return this._getAll("layer");
      };
      /**
       * 图层是否存在
       *
       * @param {string} id 图层id
       * @return {*}
       */
      Map.prototype.hasLayer = function (id) {
          return this._has("layer", id);
      };
      /**
       * 图层添加到地图
       *
       * @param {Layer} layer 图层对象
       * @return {*}
       */
      Map.prototype.addLayer = function (layer) {
          this._add("layer", layer);
          return this;
      };
      /**
       * 移除图层
       *
       * @param {(string | Layer)} layer 图层对象或id
       * @param {boolean} [destroy=false] 是否销毁
       * @return {*}
       */
      Map.prototype.removeLayer = function (layer, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("layer", layer, destroy);
          return this;
      };
      /**
       * 显示图层
       *
       * @param {(string | Layer)} layer 图层对象或id
       * @return {*}
       */
      Map.prototype.showLayer = function (layer) {
          if (typeof layer === "string") {
              layer = this.getLayer(layer);
          }
          if (defined$1(layer)) {
              layer.show();
          }
          return this;
      };
      /**
       * 隐藏图层
       *
       * @param {(string | Layer)} layer
       * @return {*}
       */
      Map.prototype.hideLayer = function (layer) {
          if (typeof layer === "string") {
              layer = this.getLayer(layer);
          }
          if (defined$1(layer)) {
              layer.hide();
          }
          return this;
      };
      /**
       * 清空图层
       *
       * @param destroy 是否销毁清除的图层
       * @param clearBasemap 是否清除basemap为true的图层
       * @return {*}
       */
      Map.prototype.clearLayers = function (destroy, clearBasemap) {
          if (destroy === void 0) { destroy = false; }
          if (clearBasemap === void 0) { clearBasemap = false; }
          this._clearAll("layer", destroy, clearBasemap ? void 0 : function (item) { return item.basemap === false; });
          return this;
      };
      /**
       * 获取覆盖物
       *
       * @param id 覆盖物id
       * @return {*}
       */
      Map.prototype.getOverlay = function (id) {
          return this._get("overlay", id);
      };
      /**
       * 获取全部覆盖物
       *
       * @return {*}
       */
      Map.prototype.getOverlays = function () {
          return this._getAll("overlay");
      };
      /**
       * 覆盖物是否存在
       *
       * @param {string} id 覆盖物id
       * @return {*}
       */
      Map.prototype.hasOverlay = function (id) {
          return this._has("overlay", id);
      };
      /**
       * 覆盖物添加到地图
       *
       * @param {Overlay} overlay 覆盖物对象
       * @return {*}
       */
      Map.prototype.addOverlay = function (overlay) {
          this._add("overlay", overlay);
          return this;
      };
      /**
       * 移除覆盖物
       *
       * @param {(string | Overlay)} overlay 覆盖物对象或id
       * @param {boolean} [destroy=false] 是否销毁
       * @return {*}
       */
      Map.prototype.removeOverlay = function (overlay, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("overlay", overlay, destroy);
          return this;
      };
      /**
       * 清空全部覆盖物
       *
       * @param [destroy=false]
       * @return {*}
       */
      Map.prototype.clearOverlays = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this._clearAll("overlay", destroy);
          return this;
      };
      /**
       * 获取组件
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.getComponent = function (id) {
          return this._get("component", id);
      };
      /**
       * 获取全部组件
       *
       * @return {*}
       */
      Map.prototype.getComponents = function () {
          return this._getAll("component");
      };
      /**
       * 组件是否存在
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.hasComponent = function (id) {
          return this._has("component", id);
      };
      /**
       * 组件添加到地图
       *
       * @param {Component} component
       * @return {*}
       */
      Map.prototype.addComponent = function (component) {
          this._add("component", component);
          return this;
      };
      /**
       * 移除组件
       *
       * @param {(string | Component)} component
       * @param {boolean} [destroy=false]
       * @return {*}
       */
      Map.prototype.removeComponent = function (component, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("component", component, destroy);
          return this;
      };
      /**
       * 清空组件
       *
       * @return {*}
       */
      Map.prototype.clearComponents = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this._clearAll("component", destroy);
          return this;
      };
      /**
       * 获取模型
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.getModel = function (id) {
          return this._get("model", id);
      };
      /**
       * 获取全部模型
       *
       * @return {*}
       */
      Map.prototype.getModels = function () {
          return this._getAll("model");
      };
      /**
       * 模型是否存在
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.hasModel = function (id) {
          return this._has("model", id);
      };
      /**
       * 添加模型到地图
       *
       * @param {Model} model
       * @return {*}
       */
      Map.prototype.addModel = function (model) {
          this._add("model", model);
          return this;
      };
      /**
       * 移除模型
       *
       * @param {(string | Model)} model
       * @param {boolean} [destroy=false]
       * @return {*}
       */
      Map.prototype.removeModel = function (model, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("model", model, destroy);
          return this;
      };
      /**
       * 清空模型
       *
       * @return {*}
       */
      Map.prototype.clearModels = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this._clearAll("model", destroy);
          return this;
      };
      /**
       * 地图切换到二维视角
       *
       * [cesium]
       */
      Map.prototype.switchTo2D = function (duration) {
          var _this = this;
          if (duration === void 0) { duration = 2; }
          var _a = this, center = _a.center, orientation = _a.orientation, zoom = _a.zoom;
          var map = this.map;
          // @ts-ignore
          if (defined$1(Cesium__namespace.SuperMapVersion)) {
              map.scene.mode = 2 /* SCENE2D */;
              this.setCenter(center);
          }
          else {
              var clear_1 = map.scene.morphComplete.addEventListener(function (e) {
                  clear_1();
                  _this.setCenter(center);
                  _this.setOrientation(orientation);
                  _this.setZoom(zoom);
              });
              map.scene.morphTo2D(duration);
          }
          return this;
      };
      /**
       * 地图切换到三维视角
       *
       * [cesium]
       */
      Map.prototype.switchTo3D = function (duration) {
          var _this = this;
          if (duration === void 0) { duration = 2; }
          var _a = this, center = _a.center, orientation = _a.orientation, zoom = _a.zoom;
          var map = this.map;
          // @ts-ignore
          if (defined$1(Cesium__namespace.SuperMapVersion)) {
              map.scene.mode = 3 /* SCENE3D */;
              this.setCenter(center);
          }
          else {
              var clear_2 = map.scene.morphComplete.addEventListener(function (e) {
                  clear_2();
                  _this.setCenter(center);
                  _this.setOrientation(orientation);
                  _this.setZoom(zoom);
              });
              map.scene.morphTo3D(duration);
          }
          return this;
      };
      /**
       * 设置相机按目标位置环绕
       *
       *
       * [cesium]
       *
       * @param options
       * @returns
       */
      Map.prototype.aroundTarget = function (options) {
          var isAround = defined$1(options.isAround) ? options.isAround : true;
          this._aroundTargetListener && this._aroundTargetListener();
          if (isAround === false) {
              this._aroundTargetListener = undefined;
              this.map.entities.remove(this._aroundTargeEntity);
              this._aroundTargeEntity = undefined;
              return;
          }
          var config = getDegreesOfCamera(this);
          var position = degreesToCartesian3(options.destination, this);
          var pitch = Cesium__namespace.Math.toRadians(config.orientation[1]);
          var heading = Cesium__namespace.Math.toRadians(config.orientation[0]);
          var speed = (options.speed || 1) / 60;
          var distance = options.distance || 2000;
          this._aroundTargeEntity ||
              (this._aroundTargeEntity = this.map.entities.add({
                  position: position,
                  point: {
                      color: Cesium__namespace.Color.RED,
                      pixelSize: 20
                  }
              }));
          this._aroundTargetListener = this.map.scene.postRender.addEventListener(function (scene, time) {
              heading = heading + speed;
              if (heading >= 2 * Math.PI) {
                  heading = 0;
              }
              var offset = new Cesium__namespace.HeadingPitchRange(heading, pitch, distance);
              this.map.zoomTo(this._aroundTargeEntity, offset);
          }, this);
          return this;
      };
      /**
       * 设置相机按自身位置环绕
       *
       * [cesium]
       */
      Map.prototype.aroundCamera = function (options) {
          var isAround = defined$1(options.isAround) ? options.isAround : true;
          this._aroundCameraListener && this._aroundCameraListener();
          if (isAround === false) {
              this._aroundCameraListener = undefined;
              return;
          }
          var config = getDegreesOfCamera(this);
          var position = degreesToCartesian3(config.destination, this);
          var pitch = Cesium__namespace.Math.toRadians(config.orientation[1]);
          var heading = Cesium__namespace.Math.toRadians(config.orientation[0]);
          var speed = (options.speed || 1) / 60;
          var camera = this.map.camera;
          this._aroundCameraListener = this.map.scene.postRender.addEventListener(function (scene, time) {
              heading = heading + speed;
              if (heading >= 2 * Math.PI) {
                  heading = 0;
              }
              camera.setView({
                  destination: position,
                  orientation: {
                      heading: heading,
                      pitch: pitch,
                      roll: Cesium__namespace.Math.toRadians(0)
                  }
              });
          }, this);
          return this;
      };
      /**
       * 飞到指定位置
       *
       * @return {*}
       */
      Map.prototype.flyTo = function (options) {
          var _this = this;
          var orientation = getDegreesOfCamera(this).orientation;
          var temFeatureCollection, range;
          if (defined$1(options.zoom)) {
              if (options.zoom < this.options.minZoom) {
                  options.zoom = this.options.minZoom;
              }
              if (options.zoom > this.options.maxZoom) {
                  options.zoom = this.options.maxZoom;
              }
              range = zoomToHeight(options.zoom);
          }
          if (defined$1(range)) {
              range =
                  this.map.scene.screenSpaceCameraController.minimumZoomDistance > range
                      ? this.map.scene.screenSpaceCameraController.minimumZoomDistance
                      : range;
          }
          var heading = Cesium__namespace.Math.toRadians(360 - (options.orientation ? options.orientation[0] : orientation[0]));
          var pitch = Cesium__namespace.Math.toRadians(options.orientation ? options.orientation[1] : orientation[1]);
          if (defined$1(options.center)) {
              if (Array.isArray(options.center)) {
                  if (options.center.length === 0) {
                      throw new Error(ErrorNotification.UNSUPPORTED_PARAM);
                  }
                  else if (typeof options.center[0] === "number") {
                      temFeatureCollection = featureCollection([
                          point([options.center[0], options.center[1]])
                      ]);
                  }
                  else {
                      temFeatureCollection = featureCollection(options.center.map(function (i) { return i.geoJson; }));
                  }
              }
              else {
                  if (options.center instanceof GLTF || options.center instanceof Cesium3DTile) {
                      return new Promise(function (resolve, reject) {
                          options.center.boundingSphere.then(function (bs) {
                              if (defined$1(range)) {
                                  range = reviseRange.call(_this, range, pitch, heading, bs);
                              }
                              _this.map.camera.flyToBoundingSphere(bs, __assign$1(__assign$1(__assign$1(__assign$1({}, options), { duration: options.duration ? options.duration : 0 }), (range ? { offset: new Cesium__namespace.HeadingPitchRange(heading, pitch, range) } : {})), { complete: function () {
                                      resolve(true);
                                  }, cancel: function () {
                                      resolve(false);
                                  } }));
                          });
                      });
                  }
                  if (options.center instanceof VectorLayer) {
                      temFeatureCollection = options.center.geoJson;
                  }
                  if (options.center instanceof Feature) {
                      temFeatureCollection = featureCollection([options.center.geoJson]);
                  }
              }
          }
          else {
              temFeatureCollection = featureCollection([point(this.center)]);
          }
          if (!defined$1(range) &&
              defined$1(temFeatureCollection) &&
              temFeatureCollection.features.length === 1 &&
              (temFeatureCollection.features[0].geometry.type === GeoJsonGeometryType.POINT ||
                  temFeatureCollection.features[0].geometry.type === GeoJsonGeometryType.MULTI_POINT)) {
              range = zoomToHeight(defined$1(options.zoom) ? options.zoom : this.zoom);
          }
          var boundingSphere = computeBoundingSphere(temFeatureCollection, this);
          var newRange = reviseRange.call(this, range, pitch, heading, boundingSphere);
          return new Promise(function (resolve) {
              _this.map.camera.flyToBoundingSphere(boundingSphere, __assign$1(__assign$1({}, options), { duration: options.duration ? options.duration : 0, offset: new Cesium__namespace.HeadingPitchRange(heading, pitch, newRange), complete: function () {
                      resolve(true);
                  }, cancel: function () {
                      resolve(false);
                  } }));
          });
      };
      /**
       * 设置地图缩放级别
       *
       * @param {number} zoom
       * @return {*}
       */
      Map.prototype.setZoom = function (zoom) {
          this.map.camera.cancelFlight();
          this.flyTo({ zoom: zoom });
          this.map.camera.completeFlight && this.map.camera.completeFlight();
          return this;
      };
      /**
       * 设置地图中心坐标
       *
       * @param {PointCoordinate} center
       * @return {*}
       */
      Map.prototype.setCenter = function (center) {
          this.map.camera.cancelFlight();
          this.flyTo({ center: center });
          this.map.camera.completeFlight && this.map.camera.completeFlight();
          return this;
      };
      /**
       * 设置相机观察点
       *
       * 传入参数为`false`时，取消固定观察点
       *
       * [cesium]
       */
      Map.prototype.lookAt = function (options) {
          var _a, _b;
          var _direction = getDegreesOfCamera(this);
          var _orientation = _direction.orientation;
          if (typeof options === "boolean") {
              var range = zoomToHeight(this.zoom);
              if (options) {
                  this.map.camera.lookAt((_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this.center), false)), new Cesium__namespace.HeadingPitchRange(Cesium__namespace.Math.toRadians(_orientation[0]), Cesium__namespace.Math.toRadians(_orientation[1]), range));
              }
              else {
                  this.map.camera.lookAtTransform(Cesium__namespace.Matrix4.IDENTITY);
              }
          }
          if (options instanceof Object) {
              var range = zoomToHeight(options.zoom || this.zoom);
              this.map.camera.lookAt((_b = Cesium__namespace.Cartesian3).fromDegrees.apply(_b, __spreadArray$1([], __read(options.center), false)), new Cesium__namespace.HeadingPitchRange(Cesium__namespace.Math.toRadians(_orientation[0]), Cesium__namespace.Math.toRadians(_orientation[1]), range));
          }
          return this;
      };
      Map.prototype.dragPan = function (flag) {
          if (flag === void 0) { flag = true; }
          this.map.scene.screenSpaceCameraController.enableRotate = flag;
          this.map.scene.screenSpaceCameraController.enableTranslate = flag;
          return this;
      };
      Map.prototype.dragRotate = function (flag) {
          if (flag === void 0) { flag = true; }
          this.map.scene.screenSpaceCameraController.enableTilt = flag;
          return this;
      };
      Map.prototype.wheelZoom = function (flag) {
          if (flag === void 0) { flag = true; }
          this.map.scene.screenSpaceCameraController.enableZoom = flag;
          return this;
      };
      /**
       * @param {{ fileName: string; fileType: string; target: string }} options
       * @returns
       */
      Map.prototype.print = function (options) {
          this._print(options);
          return this;
      };
      /**
       * @ignore
       * @param options
       */
      Map.prototype._print = function (options) {
          var _options = Object.assign({
              fileName: "map",
              fileType: "png"
          }, options || {});
          var mapElement = null;
          if (_options.target) {
              mapElement = document.getElementById(_options.target);
          }
          else {
              mapElement = this.map.container;
          }
          if (!mapElement) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          var exportOptions = {};
          if (_options.fileType === "pdf") {
              toJpeg(mapElement, __assign$1({ quality: 0.92 }, exportOptions)).then(function (dataUrl) {
                  var offsetHeight = mapElement.offsetHeight, offsetWidth = mapElement.offsetWidth;
                  var doc = new E$1({
                      orientation: "l",
                      unit: "pt",
                      format: [offsetWidth + 20, offsetHeight + 20]
                  });
                  doc.addImage(dataUrl, "JPEG", 10, 10, offsetWidth, offsetHeight);
                  doc.save("".concat(_options.fileName, ".").concat(_options.fileType));
              });
          }
          else {
              var f = void 0;
              if (_options.fileType === "png") {
                  f = toPng;
              }
              else if (_options.fileType === "jpg" || _options.fileType === "jpeg") {
                  f = toJpeg;
                  exportOptions = __assign$1({ quality: 0.92 }, exportOptions);
              }
              f(mapElement, exportOptions).then(function (dataUrl) {
                  saveDataURL("".concat(_options.fileName, ".").concat(_options.fileType), dataUrl, _options.fileType === "png" ? "image/png" : "image/jpg");
              });
          }
      };
      /**
       * 设置地图视角方向
       *
       * @param {[number, number, number]} orientation
       * @return {*}
       */
      Map.prototype.setOrientation = function (orientation) {
          this.map.camera.cancelFlight();
          this.flyTo({ orientation: orientation });
          this.map.camera.completeFlight && this.map.camera.completeFlight();
          return this;
      };
      /**
       * 设置地形深度检测开启状态
       *
       * [cesium]
       *
       * @param {boolean} status
       * @return {*}
       */
      Map.prototype.setDepthAgainstTerrain = function (status) {
          this._depthAgainstTerrain = status;
          this.map.scene.globe.depthTestAgainstTerrain = status;
          return this;
      };
      /**
       * 设置抗锯齿开启状态
       *
       * [cesium]
       *
       * @param {boolean} status
       * @return {*}
       */
      Map.prototype.setFxaa = function (status) {
          this._fxaa = status;
          this.map.scene.postProcessStages.fxaa.enabled = status;
          return this;
      };
      /**
       * 设置默认纹理可见性
       *
       * [cesium]
       *
       * @param {*} visible
       * @return {*}
       */
      Map.prototype.setDefaultTextureVisibility = function (visible) {
          this._defaultTextureVisibility = visible;
          // @ts-ignore
          this.map.scene.context._defaultTexture = new Cesium__namespace.Texture({
              //@ts-ignore
              context: this.map.scene.context,
              source: {
                  width: 1,
                  height: 1,
                  arrayBufferView: new Uint8Array([255, 255, 255, this._defaultTextureVisibility ? 255 : 0])
              },
              flipY: false
          });
          return this;
      };
      /**
       * 设置环境光数值
       *
       * [cesium]
       *
       * @param {number} brightness
       * @return {*}
       */
      Map.prototype.setBrightness = function (brightness) {
          this._brightness = brightness;
          var scene = this.map.scene, stages = scene.postProcessStages;
          //@ts-ignore
          scene.brightness =
              //@ts-ignore
              scene.brightness ||
                  stages.add(Cesium__namespace.PostProcessStageLibrary.createBrightnessStage());
          //@ts-ignore
          scene.brightness.enabled = true;
          //@ts-ignore
          scene.brightness.uniforms.brightness = Number(brightness);
          return this;
      };
      /**内部调用启用注册事件
       * @ignore
       */
      Map.prototype.registerEventEnable = function (type) {
          type = pickEventTypeToClickType(type);
          if (!isMapMouseEventType(type))
              return;
          this._registeredEventNumberStore || (this._registeredEventNumberStore = {});
          if (defined$1(this._registeredEventNumberStore[type])) {
              this._registeredEventNumberStore[type] += 1;
          }
          else {
              this._registeredEventNumberStore[type] = 1;
          }
          // 是否包含该事件类型，不包含添加该事件类型
          if (!this._events.includes(type)) {
              this._events.push(type);
          }
          this._updateScreenSpaceEventHandler();
          return;
      };
      /**注销注册事件
       * @ignore
       */
      Map.prototype.unregisterEventEnable = function (type) {
          type = pickEventTypeToClickType(type);
          if (!isMapMouseEventType(type))
              return;
          this._registeredEventNumberStore || (this._registeredEventNumberStore = {});
          if (defined$1(this._registeredEventNumberStore[type])) {
              this._registeredEventNumberStore[type] -= 1;
          }
          else {
              this._registeredEventNumberStore[type] = 0;
          }
          if (this._events.includes(type) && this._registeredEventNumberStore[type] === 0) {
              this._events = this._events.filter(function (i) { return i !== type; });
          }
          this._updateScreenSpaceEventHandler();
          return;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `rightclick` |  右键单击  | (pixel : [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `addmodel` | 添加模型 | (model: [[Model]])-模型对象
       *  `addlayer` | 添加图层 | (layer: [[Layer]])-图层对象
       *  `addoverlay` | 添加覆盖物 | (overlay: [[Overlay]])-覆盖物对象
       *  `addcomponent` | 添加组件 | (component: [[Component]])-组件对象
       *  `removemodel` | 移除模型 | (model: [[Model]])-模型对象
       *  `removelayer` | 移除图层 | (layer: [[Layer]])-图层对象
       *  `removeoverlay` | 移除覆盖物 | (overlay: [[Overlay]])-覆盖物对象
       *  `removecomponent` | 移除组件 | (component: [[Component]])-组件对象
       *  `postrender` | 渲染完成 |
       *  `movestart` | 移动开始 |
       *  `moveend` | 移动结束 |
       *  `zoomchanged` | 地图缩放变化 | (zoom:number)-地图缩放值
       *  `centerchanged` | 地图中心变化 | (center: [[PointCoordinate]])-地图中心点坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Map.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标, (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `addmodel` | 添加模型 | (model: [[Model]])-模型对象
       *  `addlayer` | 添加图层 | (layer: [[Layer]])-图层对象
       *  `addoverlay` | 添加覆盖物 | (overlay: [[Overlay]])-覆盖物对象
       *  `addcomponent` | 添加组件 | (component: [[Component]])-组件对象
       *  `removemodel` | 移除模型 | (model: [[Model]])-模型对象
       *  `removelayer` | 移除图层 | (layer: [[Layer]])-图层对象
       *  `removeoverlay` | 移除覆盖物 | (overlay: [[Overlay]])-覆盖物对象
       *  `removecomponent` | 移除组件 | (component: [[Component]])-组件对象
       *  `postrender` | 渲染完成 |
       *  `movestart` | 移动开始 |
       *  `moveend` | 移动结束 |
       *  `zoomchanged` | 地图缩放变化 | (zoom:number)-地图缩放值
       *  `centerchanged` | 地图中心变化 | (center: [[PointCoordinate]])-地图中心点坐标
       *
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Map.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 屏幕像素坐标转为经纬度坐标
       *
       * @param pixel
       * @returns
       */
      Map.prototype.pixelToCoordinate = function (pixel) {
          var _a;
          return cartesian3ToDegrees(this.map.scene.globe.pick(this.map.camera.getPickRay(new ((_a = Cesium__namespace.Cartesian2).bind.apply(_a, __spreadArray$1([void 0], __read(pixel), false)))()), this.map.scene), this);
      };
      /**
       * 经纬度坐标转为屏幕像素坐标
       *
       * @param coordinate
       * @returns
       */
      Map.prototype.coordinateToPixel = function (coordinate) {
          var _a = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(this.map.scene, degreesToCartesian3(coordinate, this)), x = _a.x, y = _a.y;
          return [x, y];
      };
      /**
       * 销毁地图
       */
      Map.prototype.destroy = function () {
          _super.prototype.destroy.call(this);
          clearProperty(this);
      };
      /**
       * @ignore
       */
      Map.prototype._destroy = function () {
          var _this = this;
          _super.prototype._destroy.call(this);
          ["component", "layer", "model", "overlay"].forEach(function (name) {
              _this["clear".concat(upperCaseFirstWord(name), "s")](true);
          });
          this.removePitchLimit();
          this.map.destroy();
          this._map = void 0;
      };
      /**
       * 设置最大地图俯仰角
       *
       * [cesium]
       */
      Map.prototype.setMaxPitch = function (maxPitch) {
          var _this = this;
          this._maxPitch = maxPitch;
          setTimeout(function () {
              _this._updatePitchLimit();
          }, 0);
          return this;
      };
      /**
       * 设置最小地图俯仰角
       *
       * [cesium]
       */
      Map.prototype.setMinPitch = function (minPitch) {
          var _this = this;
          this._minPitch = minPitch;
          setTimeout(function () {
              _this._updatePitchLimit();
          }, 0);
          return this;
      };
      /**
       * @ignore
       */
      Map.prototype._updatePitchLimit = function () {
          var _this = this;
          if (defined$1(this.minPitch) || defined$1(this.maxPitch)) {
              // @ts-ignore
              if (!defined$1(this._removeCallbackPitchLimit)) {
                  var viewer = this.map;
                  viewer.scene.globe;
                  var camera_1 = viewer.scene.camera;
                  if ((defined$1(this.maxPitch) &&
                      defined$1(this.minPitch) &&
                      (toDegrees(this.map.camera.pitch) >= this.maxPitch || toDegrees(this.map.camera.pitch) <= this.minPitch)) ||
                      (defined$1(this.maxPitch) && !defined$1(this.minPitch) && toDegrees(this.map.camera.pitch) >= this.maxPitch) ||
                      (defined$1(this.minPitch) && !defined$1(this.maxPitch) && toDegrees(this.map.camera.pitch) <= this.minPitch)) {
                      var min = this.minPitch || -90;
                      var max = this.maxPitch || 0;
                      camera_1.setView({
                          destination: camera_1.position,
                          orientation: {
                              heading: camera_1.heading,
                              pitch: Cesium__namespace.Math.toRadians((max - min) / 2 + min),
                              roll: camera_1.roll
                          }
                      });
                  }
                  new Cesium__namespace.Cartesian3();
                  var previousPosition_1 = new Cesium__namespace.Cartesian3();
                  var previousDirection_1 = new Cesium__namespace.Cartesian3();
                  var previousUp_1 = new Cesium__namespace.Cartesian3();
                  var previousRight_1 = new Cesium__namespace.Cartesian3();
                  // @ts-ignore
                  this._removeCallbackPitchLimit = viewer.scene.postUpdate.addEventListener(function () {
                      // const normal = globe.ellipsoid.geodeticSurfaceNormal(camera.position, scratchNormal);
                      // const dotProduct = Cesium.Cartesian3.dot(camera.direction, normal);
                      var dotProduct = _this.map.camera.pitch;
                      if ((defined$1(_this.maxPitch) &&
                          defined$1(_this.minPitch) &&
                          (dotProduct >= toRadians(_this.maxPitch) || dotProduct <= toRadians(_this.minPitch))) ||
                          (defined$1(_this.maxPitch) && !defined$1(_this.minPitch) && dotProduct >= toRadians(_this.maxPitch)) ||
                          (defined$1(_this.minPitch) && !defined$1(_this.maxPitch) && dotProduct <= toRadians(_this.minPitch))) {
                          camera_1.position = Cesium__namespace.Cartesian3.clone(previousPosition_1, camera_1.position);
                          camera_1.direction = Cesium__namespace.Cartesian3.clone(previousDirection_1, camera_1.direction);
                          camera_1.up = Cesium__namespace.Cartesian3.clone(previousUp_1, camera_1.up);
                          camera_1.right = Cesium__namespace.Cartesian3.clone(previousRight_1, camera_1.right);
                      }
                      else {
                          previousPosition_1 = Cesium__namespace.Cartesian3.clone(camera_1.position, previousPosition_1);
                          previousDirection_1 = Cesium__namespace.Cartesian3.clone(camera_1.direction, previousDirection_1);
                          previousUp_1 = Cesium__namespace.Cartesian3.clone(camera_1.up, previousUp_1);
                          previousRight_1 = Cesium__namespace.Cartesian3.clone(camera_1.right, previousRight_1);
                      }
                  });
              }
          }
          else {
              this.removePitchLimit();
          }
      };
      /**
       * @ignore
       */
      Map.prototype.removePitchLimit = function () {
          var _a;
          // @ts-ignore
          (_a = this._removeCallbackPitchLimit) === null || _a === void 0 ? void 0 : _a.call(this), (this._removeCallbackPitchLimit = void 0);
      };
      /**
       * @ignore
       */
      Map.prototype.getOrCreateCesiumCollection = function (name) {
          var item;
          switch (name) {
              case "billboard":
                  item = this._billboardCollectionStore.shift();
                  if (!defined$1(item)) {
                      item = this.map.scene.primitives.add(new Cesium__namespace.BillboardCollection({
                          scene: this.map.scene,
                          show: false
                      }));
                  }
                  break;
              case "label":
                  item = this._labelCollectionStore.shift();
                  if (!defined$1(item)) {
                      item = this.map.scene.primitives.add(new Cesium__namespace.LabelCollection({
                          scene: this.map.scene,
                          show: false
                      }));
                  }
                  break;
              case "point":
                  item = this._pointCollectionStore.shift();
                  if (!defined$1(item)) {
                      item = this.map.scene.primitives.add(new Cesium__namespace.PointPrimitiveCollection({
                          show: false
                      }));
                  }
                  break;
          }
          return item;
      };
      /**
       * @ignore
       */
      Map.prototype.storeCesiumCollection = function (item) {
          item.show = false;
          if (item instanceof Cesium__namespace.BillboardCollection) {
              this._billboardCollectionStore.push(item);
          }
          else if (item instanceof Cesium__namespace.LabelCollection) {
              this._labelCollectionStore.push(item);
          }
          else if (item instanceof Cesium__namespace.PointPrimitiveCollection) {
              this._pointCollectionStore.push(item);
          }
      };
      return Map;
  }(Observable));
  function cesiumPostRender(scene, time) {
      var _a;
      this.dispatchEvent({ type: BaseEventType.POST_RENDER });
      (_a = this._overlayCollection) === null || _a === void 0 ? void 0 : _a.forEach(function (overlay) {
          overlay.visible &&
              overlay.dispatchEvent({
                  type: BaseEventType.POST_RENDER,
                  scene: scene,
                  time: time
              });
      });
  }
  /**
   *   根据鼠标位置以及对象
   * @param scene
   * @param cartesian2
   * @param noPickEntity
   * @param pickMode
   * @returns
   */
  function pickPositionAndObj(scene, cartesian2, noPickEntity, pickMode) {
      if (noPickEntity === void 0) { noPickEntity = void 0; }
      if (pickMode === void 0) { pickMode = PickModelEnum.SINGLE; }
      var cartesian3, pickObjects;
      try {
          // 钻取拾取
          pickObjects = scene.drillPick(cartesian2, 20, 5, 5);
          // 如果拾取多个图元、以及拾取模式为单选
          if (pickObjects.length >= 2 && pickMode === PickModelEnum.SINGLE) {
              pickObjects.length = 1;
          }
          scene.pick(cartesian2, 5, 5);
      }
      catch (error) {
          console.error(error);
      }
      if (scene.pickPositionSupported &&
          Cesium__namespace.defined(pickObjects) &&
          pickObjects.length > 0 &&
          !(function (pickObj, entity) {
              // 如果该对象id定义
              if (Cesium__namespace.defined(pickObj.id)) {
                  var obj = pickObj.id;
                  if (obj._noMousePick)
                      return obj;
                  if (entity && obj === entity)
                      return obj;
              }
              if (Cesium__namespace.defined(pickObj.primitive)) {
                  var obj = pickObj.primitive;
                  if (obj._noMousePick)
                      return obj;
                  if (entity && obj === entity)
                      return obj;
              }
              // cesium3DTile
              if (Cesium__namespace.defined(pickObj.tileset)) {
                  var obj = pickObj.tileset;
                  if (obj._noMousePick)
                      return obj;
                  if (entity && obj === entity)
                      return obj;
              }
              return null;
          })(pickObjects[0], noPickEntity) &&
          // 是否拾取位置---
          ((cartesian3 = scene.pickPosition(cartesian2)), Cesium__namespace.defined(cartesian3))) {
          // 笛卡尔坐标转化为地理坐标
          var cartographic = Cesium__namespace.Cartographic.fromCartesian(cartesian3);
          // 判断高度，如果小于零，
          if (cartographic.height >= 0) {
              return { cartesian3: cartesian3, pickObjects: pickObjects };
          }
          // 含义
          if (pickObjects.length > 0 && !Cesium__namespace.defined(pickObjects[0].id) && cartographic.height >= -500) {
              return { cartesian3: cartesian3, pickObjects: pickObjects };
          }
      }
      // @ts-ignore
      if (scene.onlyPickModelPosition) {
          return { cartesian3: cartesian3, pickObjects: pickObjects };
      }
      // 三维场景模式----
      if (scene.mode === 3 /* SCENE3D */) {
          var ray = scene.camera.getPickRay(cartesian2);
          cartesian3 = scene.globe.pick(ray, scene);
      }
      else {
          cartesian3 = scene.camera.pickEllipsoid(cartesian2, scene.globe.ellipsoid);
      }
      // 坐标存在、相机高度判读，该点的高度判读
      if (Cesium__namespace.defined(cartesian3) &&
          scene.camera.positionCartographic.height < 10000 &&
          Cesium__namespace.Cartographic.fromCartesian(cartesian3).height < -5000) {
          return { cartesian3: void 0, pickObjects: pickObjects };
      }
      return { cartesian3: cartesian3, pickObjects: pickObjects };
  }
  /**
   * 地图事件处理器
   * @param mousement
   * @param type
   */
  function eventHandler(mousement, type) {
      var e_2, _a, e_3, _b;
      var _c, _d, _e;
      // 鼠标位置
      var position = mousement.endPosition || mousement.position;
      var _f = pickPositionAndObj(this.map.scene, position, void 0, PickModelEnum.MULTI), cartesian3 = _f.cartesian3, pickObjects = _f.pickObjects;
      var pixel = [position.x, position.y];
      if (defined$1(cartesian3)) {
          var layers = [];
          // 经纬度坐标
          var coordinate_1 = cartesian3ToDegrees(cartesian3, this);
          if (Cesium__namespace.defined(pickObjects) && pickObjects.length > 0) {
              var fireLayer = new window.Map();
              var fireComponent = new window.Set();
              var modelComponent = new window.Set();
              var fireFeature = new WeakSet();
              try {
                  for (var pickObjects_1 = __values(pickObjects), pickObjects_1_1 = pickObjects_1.next(); !pickObjects_1_1.done; pickObjects_1_1 = pickObjects_1.next()) {
                      var pickObj = pickObjects_1_1.value;
                      if (pickObj.id instanceof Feature || ((_c = pickObj.id) === null || _c === void 0 ? void 0 : _c[FEATURE_LINK]) instanceof Feature) {
                          var feature = pickObj.id[FEATURE_LINK] || pickObj.id;
                          var layer = feature.layer;
                          if (fireFeature.has(feature)) {
                              continue;
                          }
                          fireFeature.add(feature);
                          feature.dispatchEvent({
                              type: type,
                              pixel: pixel,
                              map: this,
                              coordinate: coordinate_1,
                              layer: layer,
                              feature: feature
                          });
                          var list = fireLayer.get(layer) || [];
                          fireLayer.set(layer, list.concat(feature));
                      }
                      else if (defined$1((_d = pickObj.id) === null || _d === void 0 ? void 0 : _d[COMPONENT_LINK]) && pickObj.id[COMPONENT_LINK] instanceof Component$1) {
                          fireComponent.add(pickObj.id[COMPONENT_LINK]);
                      }
                      else if (pickObj instanceof Cesium__namespace.Cesium3DTileFeature ||
                          pickObj.id instanceof Model ||
                          ((_e = pickObj.id) === null || _e === void 0 ? void 0 : _e[MODEL_LINK]) instanceof Model) {
                          var model = (pickObj.tileset && pickObj.tileset[MODEL_LINK]) || pickObj.id[MODEL_LINK] || pickObj.id;
                          modelComponent.add(model);
                      }
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (pickObjects_1_1 && !pickObjects_1_1.done && (_a = pickObjects_1.return)) _a.call(pickObjects_1);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
              var pickType = toPickEventType(type);
              var fired = !pickType;
              try {
                  for (var fireLayer_1 = __values(fireLayer), fireLayer_1_1 = fireLayer_1.next(); !fireLayer_1_1.done; fireLayer_1_1 = fireLayer_1.next()) {
                      var _g = __read(fireLayer_1_1.value, 2), layer = _g[0], features = _g[1];
                      if (!fired) {
                          fired = true;
                          var fs = [features[0]];
                          features[0].dispatchEvent({
                              type: pickType,
                              pixel: pixel,
                              map: this,
                              coordinate: coordinate_1,
                              layer: features[0].layer,
                              feature: features[0]
                          });
                          layer.dispatchEvent({
                              type: pickType,
                              pixel: pixel,
                              map: this,
                              layer: layer,
                              coordinate: coordinate_1,
                              features: fs
                          });
                      }
                      layers.push({ layer: layer, features: features });
                      layer.dispatchEvent({
                          type: type,
                          pixel: pixel,
                          map: this,
                          layer: layer,
                          coordinate: coordinate_1,
                          features: features
                      });
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (fireLayer_1_1 && !fireLayer_1_1.done && (_b = fireLayer_1.return)) _b.call(fireLayer_1);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
              // 组件分发事件----
              fireComponent.forEach(function (component) {
                  component.dispatchEvent({
                      type: type,
                      pixel: pixel,
                      coordinate: coordinate_1
                  });
              });
              // 模型分发事件
              modelComponent.forEach(function (model) {
                  model.dispatchEvent({
                      type: type,
                      pixel: pixel,
                      coordinate: coordinate_1
                  });
              });
          }
          // 地图分发事件
          this.dispatchEvent({
              type: type,
              pixel: pixel,
              coordinate: coordinate_1,
              layers: layers,
              pickObjects: pickObjects
          });
      }
  }

  /**
   * 组件基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Component = /** @class */ (function (_super) {
      __extends$3(Component, _super);
      function Component(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           * @private
           */
          _this._initialized = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Component.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化组件
       *
       * @ignore
       */
      Component.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Component.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this._initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Component.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      return Component;
  }(BaseObject));

  /**
   * 常量定义----
   */
  var Constants = {
      TWO_PI: Math.PI * 2,
      HALF_PI: Math.PI / 2,
      FITTING_COUNT: 100,
      ZERO_TOLERANCE: 0.0005
  };

  /**
   *
   * 常用的空间函数
   */
  function distance$1(pnt1, pnt2) {
      return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
  }
  function wholeDistance(points) {
      var dis = 0;
      for (var i = 0; i < points.length - 1; i++)
          dis += distance$1(points[i], points[i + 1]);
      return dis;
  }
  function getBaseLength(points) {
      return Math.pow(wholeDistance(points), 0.99);
  }
  /**
   * 获取两点之间的中点
   * @param pnt1 PointCoordinate
   * @param pnt2 PointCoordinate
   * @returns
   */
  function middle(pnt1, pnt2) {
      return [(pnt1[0] + pnt2[0]) / 2, (pnt1[1] + pnt2[1]) / 2];
  }
  /**
   * 从三点确定一圆，计算其外接圆的中心点
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function getCircleCenterOfThreePoints(pnt1, pnt2, pnt3) {
      var pntA = [(pnt1[0] + pnt2[0]) / 2, (pnt1[1] + pnt2[1]) / 2];
      var pntB = [pntA[0] - pnt1[1] + pnt2[1], pntA[1] + pnt1[0] - pnt2[0]];
      var pntC = [(pnt1[0] + pnt3[0]) / 2, (pnt1[1] + pnt3[1]) / 2];
      var pntD = [pntC[0] - pnt1[1] + pnt3[1], pntC[1] + pnt1[0] - pnt3[0]];
      return getIntersectPoint(pntA, pntB, pntC, pntD);
  }
  /**
   * 计算相交点坐标
   * @param pntA
   * @param pntB
   * @param pntC
   * @param pntD
   * @returns
   */
  function getIntersectPoint(pntA, pntB, pntC, pntD) {
      if (pntA[1] === pntB[1]) {
          var f_1 = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
          var x_1 = f_1 * (pntA[1] - pntC[1]) + pntC[0];
          var y_1 = pntA[1];
          return [x_1, y_1];
      }
      if (pntC[1] === pntD[1]) {
          var e_1 = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
          var x_2 = e_1 * (pntC[1] - pntA[1]) + pntA[0];
          var y_2 = pntC[1];
          return [x_2, y_2];
      }
      var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
      var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
      var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
      var x = e * y - e * pntA[1] + pntA[0];
      return [x, y];
  }
  // 计算方位角
  function getAzimuth(startPnt, endPnt) {
      var azimuth;
      var angle = Math.asin(Math.abs(endPnt[1] - startPnt[1]) / distance$1(startPnt, endPnt));
      if (endPnt[1] >= startPnt[1] && endPnt[0] >= startPnt[0])
          azimuth = angle + Math.PI;
      else if (endPnt[1] >= startPnt[1] && endPnt[0] < startPnt[0])
          azimuth = Constants.TWO_PI - angle;
      else if (endPnt[1] < startPnt[1] && endPnt[0] < startPnt[0])
          azimuth = angle;
      else if (endPnt[1] < startPnt[1] && endPnt[0] >= startPnt[0])
          azimuth = Math.PI - angle;
      return azimuth;
  }
  /**
   * 计算三点之间夹角
   * @param pntA
   * @param pntB
   * @param pntC
   * @returns
   */
  function getAngleOfThreePoints(pntA, pntB, pntC) {
      var angle = getAzimuth(pntB, pntA) - getAzimuth(pntB, pntC);
      return angle < 0 ? angle + Constants.TWO_PI : angle;
  }
  /**
   *  是否顺时针---
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function isClockWise(pnt1, pnt2, pnt3) {
      return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
  }
  function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
      t = Math.max(Math.min(t, 1), 0);
      var tp = 1 - t;
      var t2 = t * t;
      var t3 = t2 * t;
      var tp2 = tp * tp;
      var tp3 = tp2 * tp;
      var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
      var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
      return [x, y, 0];
  }
  function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
      var azimuth = getAzimuth(startPnt, endPnt);
      var alpha = clockWise ? azimuth + angle : azimuth - angle;
      var dx = distance * Math.cos(alpha);
      var dy = distance * Math.sin(alpha);
      return [endPnt[0] + dx, endPnt[1] + dy, 0];
  }
  /**
   *  根据圆心、起始角度、半径计算构成圆弧的点位置坐标数组
   * @param center
   * @param radius
   * @param startAngle
   * @param endAngle
   * @returns
   */
  function getArcPoints(center, radius, startAngle, endAngle) {
      var x;
      var y;
      var pnts = [];
      var angleDiff = endAngle - startAngle;
      angleDiff = angleDiff < 0 ? angleDiff + Constants.TWO_PI : angleDiff;
      for (var i = 0; i <= Constants.FITTING_COUNT; i++) {
          var angle = startAngle + (angleDiff * i) / Constants.FITTING_COUNT;
          x = center[0] + radius * Math.cos(angle);
          y = center[1] + radius * Math.sin(angle);
          pnts.push([x, y]);
      }
      return pnts;
  }
  function getBisectorNormals(t, pnt1, pnt2, pnt3) {
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var uX = normal[0] / dist;
      var uY = normal[1] / dist;
      var d1 = distance$1(pnt1, pnt2);
      var d2 = distance$1(pnt2, pnt3);
      var bisectorNormalRight;
      var bisectorNormalLeft;
      if (dist > Constants.ZERO_TOLERANCE) {
          if (isClockWise(pnt1, pnt2, pnt3)) {
              var dt = t * d1;
              var x = pnt2[0] - dt * uY;
              var y = pnt2[1] + dt * uX;
              bisectorNormalRight = [x, y, 0];
              dt = t * d2;
              x = pnt2[0] + dt * uY;
              y = pnt2[1] - dt * uX;
              bisectorNormalLeft = [x, y, 0];
          }
          else {
              var dt = t * d1;
              var x = pnt2[0] + dt * uY;
              var y = pnt2[1] - dt * uX;
              bisectorNormalRight = [x, y, 0];
              dt = t * d2;
              x = pnt2[0] - dt * uY;
              y = pnt2[1] + dt * uX;
              bisectorNormalLeft = [x, y, 0];
          }
      }
      else {
          var x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
          var y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
          bisectorNormalRight = [x, y, 0];
          x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
          y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
          bisectorNormalLeft = [x, y, 0];
      }
      return [bisectorNormalRight, bisectorNormalLeft];
  }
  /**
   * 获取法线
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function getNormal(pnt1, pnt2, pnt3) {
      var dX1 = pnt1[0] - pnt2[0];
      var dY1 = pnt1[1] - pnt2[1];
      var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
      dX1 /= d1;
      dY1 /= d1;
      var dX2 = pnt3[0] - pnt2[0];
      var dY2 = pnt3[1] - pnt2[1];
      var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
      dX2 /= d2;
      dY2 /= d2;
      var uX = dX1 + dX2;
      var uY = dY1 + dY2;
      return [uX, uY];
  }
  function getCurvePoints$1(t, controlPoints) {
      var leftControl = getLeftMostControlPoint(controlPoints, t);
      var normals = [leftControl];
      for (var i = 0; i < controlPoints.length - 2; i++) {
          var pnt1 = controlPoints[i];
          var pnt2 = controlPoints[i + 1];
          var pnt3 = controlPoints[i + 2];
          var normalPoints = getBisectorNormals(t, pnt1, pnt2, pnt3);
          normals = normals.concat(normalPoints);
      }
      var rightControl = getRightMostControlPoint(controlPoints, t);
      normals.push(rightControl);
      var points = [];
      for (var i = 0; i < controlPoints.length - 1; i++) {
          var pnt1 = controlPoints[i];
          var pnt2 = controlPoints[i + 1];
          points.push(pnt1);
          for (var t_1 = 0; t_1 < Constants.FITTING_COUNT; t_1++) {
              var pnt = getCubicValue(t_1 / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
              points.push(pnt);
          }
          points.push(pnt2);
      }
      return points;
  }
  function getLeftMostControlPoint(controlPoints, t) {
      var pnt1 = controlPoints[0];
      var pnt2 = controlPoints[1];
      var pnt3 = controlPoints[2];
      var pnts = getBisectorNormals(0, pnt1, pnt2, pnt3);
      var normalRight = pnts[0];
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var controlX;
      var controlY;
      if (dist > Constants.ZERO_TOLERANCE) {
          var mid = middle(pnt1, pnt2);
          var pX = pnt1[0] - mid[0];
          var pY = pnt1[1] - mid[1];
          var d1 = distance$1(pnt1, pnt2);
          // normal at midpoint
          var n = 2.0 / d1;
          var nX = -n * pY;
          var nY = n * pX;
          // upper triangle of symmetric transform matrix
          var a11 = nX * nX - nY * nY;
          var a12 = 2 * nX * nY;
          var a22 = nY * nY - nX * nX;
          var dX = normalRight[0] - mid[0];
          var dY = normalRight[1] - mid[1];
          // coordinates of reflected vector
          controlX = mid[0] + a11 * dX + a12 * dY;
          controlY = mid[1] + a12 * dX + a22 * dY;
      }
      else {
          controlX = pnt1[0] + t * (pnt2[0] - pnt1[0]);
          controlY = pnt1[1] + t * (pnt2[1] - pnt1[1]);
      }
      return [controlX, controlY, 0];
  }
  function getRightMostControlPoint(controlPoints, t) {
      var count = controlPoints.length;
      var pnt1 = controlPoints[count - 3];
      var pnt2 = controlPoints[count - 2];
      var pnt3 = controlPoints[count - 1];
      var pnts = getBisectorNormals(0, pnt1, pnt2, pnt3);
      var normalLeft = pnts[1];
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var controlX;
      var controlY;
      if (dist > Constants.ZERO_TOLERANCE) {
          var mid = middle(pnt2, pnt3);
          var pX = pnt3[0] - mid[0];
          var pY = pnt3[1] - mid[1];
          var d1 = distance$1(pnt2, pnt3);
          // normal at midpoint
          var n = 2.0 / d1;
          var nX = -n * pY;
          var nY = n * pX;
          // upper triangle of symmetric transform matrix
          var a11 = nX * nX - nY * nY;
          var a12 = 2 * nX * nY;
          var a22 = nY * nY - nX * nX;
          var dX = normalLeft[0] - mid[0];
          var dY = normalLeft[1] - mid[1];
          // coordinates of reflected vector
          controlX = mid[0] + a11 * dX + a12 * dY;
          controlY = mid[1] + a12 * dX + a22 * dY;
      }
      else {
          controlX = pnt3[0] + t * (pnt2[0] - pnt3[0]);
          controlY = pnt3[1] + t * (pnt2[1] - pnt3[1]);
      }
      return [controlX, controlY, 0];
  }
  function getBezierPoints(points) {
      if (points.length <= 2)
          return points;
      var bezierPoints = [];
      var n = points.length - 1;
      for (var t = 0; t <= 1; t += 0.01) {
          var x = 0;
          var y = 0;
          for (var index = 0; index <= n; index++) {
              var factor = getBinomialFactor(n, index);
              var a = Math.pow(t, index);
              var b = Math.pow(1 - t, n - index);
              x += factor * a * b * points[index][0];
              y += factor * a * b * points[index][1];
          }
          bezierPoints.push([x, y]);
      }
      bezierPoints.push(points[n]);
      return bezierPoints;
  }
  function getBinomialFactor(n, index) {
      return getFactorial(n) / (getFactorial(index) * getFactorial(n - index));
  }
  function getFactorial(n) {
      if (n <= 1)
          return 1;
      if (n === 2)
          return 2;
      if (n === 3)
          return 6;
      if (n === 4)
          return 24;
      if (n === 5)
          return 120;
      var result = 1;
      for (var i = 1; i <= n; i++)
          result *= i;
      return result;
  }
  function getQBSplinePoints(points) {
      if (points.length <= 2)
          return points;
      var n = 2;
      var bSplinePoints = [];
      var m = points.length - n - 1;
      bSplinePoints.push(points[0]);
      for (var i = 0; i <= m; i++) {
          for (var t = 0; t <= 1; t += 0.05) {
              var x = 0;
              var y = 0;
              for (var k = 0; k <= n; k++) {
                  var factor = getQuadricBSplineFactor(k, t);
                  x += factor * points[i + k][0];
                  y += factor * points[i + k][1];
              }
              bSplinePoints.push([x, y]);
          }
      }
      bSplinePoints.push(points[points.length - 1]);
      return bSplinePoints;
  }
  function getQuadricBSplineFactor(k, t) {
      if (k === 0)
          return Math.pow(t - 1, 2) / 2;
      if (k === 1)
          return (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
      if (k === 2)
          return Math.pow(t, 2) / 2;
      return 0;
  }
  // // 默认样式
  // export const defaultStyle = {
  //   plotFillColor: "#ffd500",
  //   plotAlpha: 0.6,
  //   drawPointColor: "blue",
  //   drawPointAlpha: 0.8,
  //   drawPointWidth: 10,
  //   drawPointOutlineColor: "white",
  //   drawPointActiveColor: "purple",
  //   drawPointOutlineWidth: 2
  // };
  // // 构造GeoJSON 要素
  // function createFeature(coord, type) {
  //   return {
  //     type: "Feature",
  //     properties: {
  //       type
  //     },
  //     geometry: {
  //       type: "Polygon",
  //       coordinates: [coord]
  //     }
  //   };
  // }
  // export function JsonToGeojson(jsonData) {
  //   if (!jsonData) {
  //     return;
  //   }
  //   const geojson = {
  //     type: "FeatureCollection",
  //     features: []
  //   };
  //   Object.keys(jsonData).forEach((key, i) => {
  //     if (key === "straightArrowData") {
  //       const value: any = Object.values(jsonData);
  //       if (value.length) {
  //         value[i].forEach((coord) => {
  //           const feature = createFeature(coord, DrawType.STRAIGHT_ARROW);
  //           geojson.features.push(feature);
  //         });
  //       }
  //     }
  //     if (key === "attackArrowData") {
  //       const value: any = Object.values(jsonData);
  //       if (value.length) {
  //         value[i].forEach((coord) => {
  //           const feature = createFeature(coord, DrawType.ATTACK_ARROW);
  //           geojson.features.push(feature);
  //         });
  //       }
  //     }
  //   });
  //   return geojson;
  // }
  // export function exportGeoJSON(geojsonData) {
  //   const content = JSON.stringify(geojsonData);
  //   const eleLink = document.createElement("a");
  //   eleLink.download = "plotData.json";
  //   eleLink.style.display = "none";
  //   const blob = new Blob([content]);
  //   eleLink.href = URL.createObjectURL(blob);
  //   document.body.appendChild(eleLink);
  //   eleLink.click();
  //   document.body.removeChild(eleLink);
  // }
  // export function GeojsonToJson(datas) {
  //   const jsonObj = JSON.parse(datas);
  //   const json = {
  //     straightArrowData: [],
  //     attackArrowData: []
  //   };
  //   jsonObj.features.forEach((item) => {
  //     switch (item.properties.type) {
  //       case DrawType.STRAIGHT_ARROW:
  //         json.straightArrowData.push(item.geometry.coordinates[0]);
  //         break;
  //       case DrawType.ATTACK_ARROW:
  //         json.attackArrowData.push(item.geometry.coordinates[0]);
  //         break;
  //     }
  //   });
  //   return json;
  // }
  // /**
  //  * 获取目标点被平移后新的点位 （平移矩阵的积运算  平移矩阵 * 原始位置）
  //  * @ignore
  //  * @export
  //  * @param {Cesium.Cartesian3} currentMousePoint 鼠标当前的点位
  //  * @param {Cesium.Cartesian3} lastMousePoint 上次鼠标移动的点位
  //  * @param {Cesium.Cartesian3} targetPoint 需要被移动的点位
  //  * @returns {Cesium.Cartesian3} 该点被移动后新的点位
  //  */
  // export function getNewPosition(currentMousePoint, lastMousePoint, targetPoint) {
  //   // 平移量（当前鼠标点的偏移量） ，如果不对，互换一下当前点与上一次移动点的位置。
  //   const translation = Cesium.Cartesian3.subtract(currentMousePoint, lastMousePoint, new Cesium.Cartesian3());
  //   // 创建一个平移矩阵(当前鼠标移动产生的平移矩阵)
  //   const matrix4 = Cesium.Matrix4.fromTranslation(translation);
  //   // 计算目标点的被移动后的位置
  //   const cart3 = Cesium.Matrix4.multiplyByPoint(matrix4, targetPoint, new Cesium.Cartesian3());
  //   return cart3;
  // }
  // /* 笛卡尔转经纬度 */
  // export function cartesianToLatlng(cartesian, viewer) {
  //   const latlng = viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);
  //   const lat = Cesium.Math.toDegrees(latlng.latitude);
  //   const lng = Cesium.Math.toDegrees(latlng.longitude);
  //   return [lng, lat];
  // }
  // /**
  //  * 拾取坐标与转换
  //  * @ignore
  //  * @param {Object} px 屏幕坐标
  //  * @param {Object} viewer 视图容器
  //  */
  // export function getCatesian3FromPX(px, viewer) {
  //   const picks = viewer.scene.drillPick(px);
  //   viewer.render();
  //   let cartesian = null;
  //   let isOn3dtiles = true;
  //   for (let i = 0; i < picks.length; i++) {
  //     if ((picks[i] && picks[i].primitive) || picks[i] instanceof Cesium.Cesium3DTileFeature) {
  //       // 模型上拾取
  //       isOn3dtiles = true;
  //     }
  //   }
  //   if (isOn3dtiles) {
  //     cartesian = viewer.scene.pickPosition(px);
  //   } else {
  //     const ray = viewer.camera.getPickRay(px);
  //     if (!ray) return null;
  //     cartesian = viewer.scene.globe.pick(ray, viewer.scene);
  //   }
  //   return cartesian;
  // }
  // /**
  //  * 创建编辑点
  //  * @ignore
  //  * @param {Cesium.Cartesian3} cartesian 笛卡尔坐标
  //  * @returns {Cesium.Entity<PointGraphics>}
  //  */
  // export function creatPoint(cartesian, style, viewer) {
  //   const { drawPointColor, drawPointOutlineColor, drawPointOutlineWidth, drawPointAlpha, drawPointWidth } = style;
  //   const point = viewer.entities.add({
  //     position: cartesian,
  //     point: {
  //       pixelSize: drawPointWidth,
  //       color: Cesium.Color.fromCssColorString(drawPointColor).withAlpha(drawPointAlpha),
  //       outlineWidth: drawPointOutlineWidth,
  //       outlineColor: Cesium.Color.fromCssColorString(drawPointOutlineColor).withAlpha(drawPointAlpha),
  //       heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
  //       disableDepthTestDistance: Number.POSITIVE_INFINITY
  //     }
  //   });
  //   point.attr = "editPoint";
  //   return point;
  // }
  // /* 两点的中点坐标 */
  // export function getCenterOfCartesian3(points) {
  //   const x = (points[0].x + points[1].x) / 2;
  //   const y = (points[0].y + points[1].y) / 2;
  //   const z = (points[0].z + points[1].z) / 2;
  //   return { x, y, z };
  // }
  // /* 平移矩阵 */
  // export function moveMatrix(pos) {
  //   const translation = Cesium.Cartesian3.fromArray([pos.x, pos.y, pos.z]);
  //   const mat4 = Cesium.Matrix4.fromTranslation(translation);
  //   return mat4;
  // }
  // export function getPointByDistance(position, distance, pos) {
  //   // 以点为原点建立局部坐标系（东方向为x轴,北方向为y轴,垂直于地面为z轴），得到一个局部坐标到世界坐标转换的变换矩阵
  //   const localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
  //   return Cesium.Matrix4.multiplyByPoint(
  //     localToWorld_Matrix,
  //     Cesium.Cartesian3.fromElements(0, distance, 0),
  //     new Cesium.Cartesian3()
  //   );
  // }

  /**
   * 圆弧扩展类
   * huhongxn
   */
  var Arc = /** @class */ (function (_super) {
      __extends$3(Arc, _super);
      function Arc(points) {
          var _this = _super.call(this, DrawType.ARC, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      // 重写父类方法
      Arc.prototype.generate = function () {
          var _points = this.getPoints();
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates(_points);
          }
          else {
              var startAngle = void 0;
              var endAngle = void 0;
              var pnt1 = _points[0];
              var pnt2 = _points[1];
              var pnt3 = _points[2];
              var center = getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
              var radius = distance$1(pnt1, center);
              var angle1 = getAzimuth(pnt1, center);
              var angle2 = getAzimuth(pnt2, center);
              if (isClockWise(pnt1, pnt2, pnt3)) {
                  startAngle = angle2;
                  endAngle = angle1;
              }
              else {
                  startAngle = angle1;
                  endAngle = angle2;
              }
              this.setCoordinates(getArcPoints(center, radius, startAngle, endAngle));
          }
      };
      return Arc;
  }(Geometry));

  /**
   * 椭圆扩展类
   * 胡红勋
   *
   */
  var Ellipse = /** @class */ (function (_super) {
      __extends$3(Ellipse, _super);
      function Ellipse(points) {
          var _this = _super.call(this, DrawType.ELLIPSE, points) || this;
          _this.fixPointCount = 2;
          return _this;
      }
      Ellipse.prototype.generate = function () {
          var count = this.getPointCount();
          var _points = this.getPoints();
          if (count < 2) {
              return;
          }
          var pnt1 = _points[0];
          var pnt2 = _points[1];
          var center = middle(pnt1, pnt2);
          var majorRadius = Math.abs((pnt1[0] - pnt2[0]) / 2);
          var minorRadius = Math.abs((pnt1[1] - pnt2[1]) / 2);
          this.setCoordinates([this.generatePoints(center, majorRadius, minorRadius)]);
      };
      Ellipse.prototype.generatePoints = function (center, majorRadius, minorRadius) {
          var x, y, angle;
          var points = [];
          for (var i = 0; i <= Constants.FITTING_COUNT; i++) {
              angle = (Math.PI * 2 * i) / Constants.FITTING_COUNT;
              x = center[0] + majorRadius * Math.cos(angle);
              y = center[1] + minorRadius * Math.sin(angle);
              points.push([x, y]);
          }
          return points;
      };
      return Ellipse;
  }(Geometry));

  /**
   * 曲线扩展类
   * huhongxun
   */
  var Curve = /** @class */ (function (_super) {
      __extends$3(Curve, _super);
      function Curve(points) {
          var _this = _super.call(this, DrawType.CURVE, points) || this;
          _this._t = 0.3;
          return _this;
      }
      Curve.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates(this.getPoints());
          }
          else {
              this.setCoordinates(getCurvePoints$1(this._t, this.getPoints()));
          }
      };
      return Curve;
  }(Geometry));

  /**
   * 闭合曲线扩展类
   * huhongunxun
   */
  var ClosedCurve = /** @class */ (function (_super) {
      __extends$3(ClosedCurve, _super);
      function ClosedCurve(points) {
          var _this = _super.call(this, DrawType.CLOSED_CURVE, points) || this;
          _this._t = 0.3;
          return _this;
      }
      ClosedCurve.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates([this.getPoints()]);
          }
          else {
              var pnts = this.getPoints();
              pnts.push(pnts[0], pnts[1]);
              var normals = [];
              for (var i = 0; i < pnts.length - 2; i++) {
                  var normalPoints = getBisectorNormals(this._t, pnts[i], pnts[i + 1], pnts[i + 2]);
                  normals = normals.concat(normalPoints);
              }
              var count_1 = normals.length;
              normals = [normals[count_1 - 1]].concat(normals.slice(0, count_1 - 1));
              var pList = [];
              for (var i = 0; i < pnts.length - 2; i++) {
                  var pnt1 = pnts[i];
                  var pnt2 = pnts[i + 1];
                  pList.push(pnt1);
                  for (var t = 0; t <= Constants.FITTING_COUNT; t++) {
                      var pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
                      pList.push(pnt);
                  }
                  pList.push(pnt2);
              }
              this.setCoordinates([pList]);
          }
      };
      return ClosedCurve;
  }(Geometry));

  /**
   * huhongxun
   * 面扩展类, 钳击
   */
  var Lune = /** @class */ (function (_super) {
      __extends$3(Lune, _super);
      function Lune(points) {
          var _this = _super.call(this, DrawType.LUNE, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      Lune.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          var pnts = this.getPoints();
          if (this.getPointCount() === 2) {
              var mid = middle(pnts[0], pnts[1]);
              var d = distance$1(pnts[0], mid);
              var pnt = getThirdPoint(pnts[0], mid, Constants.HALF_PI, d, false);
              pnts.push(pnt);
          }
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var pnt3 = pnts[2];
          var center = getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
          var radius = distance$1(pnt1, center);
          var angle1 = getAzimuth(pnt1, center);
          var angle2 = getAzimuth(pnt2, center);
          var startAngle = angle1;
          var endAngle = angle2;
          if (isClockWise(pnt1, pnt2, pnt3)) {
              startAngle = angle2;
              endAngle = angle1;
          }
          var _points = getArcPoints(center, radius, startAngle, endAngle);
          _points.push(pnts[0]);
          this.setCoordinates([_points]);
      };
      return Lune;
  }(Geometry));

  /**
   * 扇形扩展类
   * huhongxun
   */
  var Sector = /** @class */ (function (_super) {
      __extends$3(Sector, _super);
      function Sector(points) {
          var _this = _super.call(this, DrawType.SECTOR, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      Sector.prototype.generate = function () {
          if (this.getPointCount() < 2)
              return;
          if (this.getPointCount() === 2)
              this.setCoordinates([this.getPoints()]);
          else {
              var pnts = this.getPoints();
              var center = pnts[0];
              var pnt2 = pnts[1];
              var pnt3 = pnts[2];
              var radius = distance$1(pnt2, center);
              var startAngle = getAzimuth(pnt2, center);
              var endAngle = getAzimuth(pnt3, center);
              var pList = getArcPoints(center, radius, startAngle, endAngle);
              pList.push(center, pList[0]);
              this.setCoordinates([pList]);
          }
      };
      return Sector;
  }(Geometry));

  /**
   * 聚集地扩展类
   * 胡红勋
   */
  var GatheringPlace = /** @class */ (function (_super) {
      __extends$3(GatheringPlace, _super);
      function GatheringPlace(points) {
          var _this = _super.call(this, DrawType.GATHERING_PLACE, points) || this;
          _this._t = 0.4;
          _this.fixPointCount = 3;
          return _this;
      }
      GatheringPlace.prototype.generate = function () {
          var pnts = this.getPoints();
          if (pnts.length < 2) {
              return;
          }
          if (this.getPointCount() === 2) {
              var mid = middle(pnts[0], pnts[1]);
              var d = distance$1(pnts[0], mid) / 0.9;
              var pnt = getThirdPoint(pnts[0], mid, Constants.HALF_PI, d, true);
              pnts = [pnts[0], pnt, pnts[1]];
          }
          var middle$1 = middle(pnts[0], pnts[2]);
          pnts.push(middle$1, pnts[0], pnts[1]);
          var normals = [];
          for (var i = 0; i < pnts.length - 2; i++) {
              var pnt1 = pnts[i];
              var pnt2 = pnts[i + 1];
              var pnt3 = pnts[i + 2];
              var normalPoints = getBisectorNormals(this._t, pnt1, pnt2, pnt3);
              normals = normals.concat(normalPoints);
          }
          var count = normals.length;
          normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
          var pList = [];
          for (var i = 0; i < pnts.length - 2; i++) {
              var pnt1 = pnts[i];
              var pnt2 = pnts[i + 1];
              pList.push(pnt1);
              for (var t = 0; t <= Constants.FITTING_COUNT; t++) {
                  var pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
                  pList.push(pnt);
              }
              pList.push(pnt2);
          }
          this.setCoordinates([pList]);
      };
      return GatheringPlace;
  }(Geometry));

  /**
   * 直线箭头扩展类
   * 胡红勋
   */
  var StraightArrow = /** @class */ (function (_super) {
      __extends$3(StraightArrow, _super);
      function StraightArrow(points) {
          var _this = _super.call(this, DrawType.STRAIGHT_ARROW, points) || this;
          _this._maxArrowLength = 3000000;
          _this._arrowLengthScale = 40;
          _this.fixPointCount = 2;
          return _this;
      }
      StraightArrow.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          var pnts = this.getPoints();
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var distance = distance$1(pnt1, pnt2);
          var len = distance / this._arrowLengthScale;
          len = len > this._maxArrowLength ? this._maxArrowLength : len;
          var leftPnt = getThirdPoint(pnt1, pnt2, Math.PI / 5, len, false);
          var rightPnt = getThirdPoint(pnt1, pnt2, Math.PI / 5, len, true);
          this.setCoordinates([pnt1, pnt2, leftPnt, pnt2, rightPnt]);
      };
      return StraightArrow;
  }(Geometry));

  /**
   * 单箭头扩展类
   * 胡红勋
   */
  var FineArrow = /** @class */ (function (_super) {
      __extends$3(FineArrow, _super);
      function FineArrow(points) {
          var _this = _super.call(this, DrawType.FINE_ARROW, points) || this;
          _this._tailWidthFactor = 0.15;
          _this._neckWidthFactor = 0.2;
          _this._headWidthFactor = 0.25;
          _this._headAngle = Math.PI / 8.5;
          _this._neckAngle = Math.PI / 13;
          _this.fixPointCount = 2;
          return _this;
      }
      Object.defineProperty(FineArrow.prototype, "neckWidthFactor", {
          get: function () {
              return this._neckWidthFactor;
          },
          set: function (count) {
              this._neckWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "headWidthFactor", {
          get: function () {
              return this._headWidthFactor;
          },
          set: function (count) {
              this._headWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "headAngle", {
          get: function () {
              return this._headAngle;
          },
          set: function (count) {
              this._headAngle = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "neckAngle", {
          get: function () {
              return this._neckAngle;
          },
          set: function (count) {
              this._neckAngle = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "tailWidthFactor", {
          get: function () {
              return this._tailWidthFactor;
          },
          set: function (count) {
              this._tailWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      FineArrow.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var len = getBaseLength(pnts);
          var tailWidth = len * this._tailWidthFactor;
          var neckWidth = len * this._neckWidthFactor;
          var headWidth = len * this._headWidthFactor;
          var tailLeft = getThirdPoint(pnt2, pnt1, Constants.HALF_PI, tailWidth, true);
          var tailRight = getThirdPoint(pnt2, pnt1, Constants.HALF_PI, tailWidth, false);
          var headLeft = getThirdPoint(pnt1, pnt2, this._headAngle, headWidth, false);
          var headRight = getThirdPoint(pnt1, pnt2, this._headAngle, headWidth, true);
          var neckLeft = getThirdPoint(pnt1, pnt2, this._neckAngle, neckWidth, false);
          var neckRight = getThirdPoint(pnt1, pnt2, this._neckAngle, neckWidth, true);
          var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];
          this.setCoordinates([pList]);
      };
      return FineArrow;
  }(Geometry));

  /**
   * 方向箭头扩展类
   * 胡红勋
   */
  var AssaultDirection = /** @class */ (function (_super) {
      __extends$3(AssaultDirection, _super);
      function AssaultDirection(points) {
          var _this = _super.call(this, points) || this;
          _this.type = DrawType.ASSAULT_DIRECTION;
          _this.tailWidthFactor = 0.2;
          _this.neckWidthFactor = 0.25;
          _this.headWidthFactor = 0.3;
          _this.headAngle = Math.PI / 4;
          _this.neckAngle = Math.PI * 0.17741;
          return _this;
      }
      return AssaultDirection;
  }(FineArrow));

  /**
   * 攻击箭头类扩展
   * huhongxun
   */
  var AttackArrow = /** @class */ (function (_super) {
      __extends$3(AttackArrow, _super);
      function AttackArrow(points) {
          var _this = _super.call(this, DrawType.ATTACK_ARROW, points) || this;
          _this._headHeightFactor = 0.18;
          _this._headWidthFactor = 0.3;
          _this._neckHeightFactor = 0.85;
          _this._neckWidthFactor = 0.15;
          _this._headTailFactor = 0.8;
          return _this;
      }
      Object.defineProperty(AttackArrow.prototype, "headHeightFactor", {
          get: function () {
              return this._headHeightFactor;
          },
          set: function (count) {
              this._headHeightFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "headWidthFactor", {
          get: function () {
              return this._headWidthFactor;
          },
          set: function (count) {
              this._headWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "neckHeightFactor", {
          get: function () {
              return this._neckHeightFactor;
          },
          set: function (count) {
              this._neckHeightFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "neckWidthFactor", {
          get: function () {
              return this._neckWidthFactor;
          },
          set: function (count) {
              this._neckWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "headTailFactor", {
          get: function () {
              return this._headTailFactor;
          },
          set: function (count) {
              this._headTailFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      AttackArrow.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          if (this.getPointCount() === 2) {
              this.setCoordinates([this.getPoints()]);
              return;
          }
          var pnts = this.getPoints();
          // 计算箭尾
          var tailLeft = pnts[0];
          var tailRight = pnts[1];
          if (isClockWise(pnts[0], pnts[1], pnts[2])) {
              tailLeft = pnts[1];
              tailRight = pnts[0];
          }
          var midTail = middle(tailLeft, tailRight);
          var bonePnts = [midTail].concat(pnts.slice(2));
          // 计算箭头
          var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var tailWidthFactor = distance$1(tailLeft, tailRight) / getBaseLength(bonePnts);
          // 计算箭身
          var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
          // 整合
          var count = bodyPnts.length;
          var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse());
          this.setCoordinates([coords]);
      };
      AttackArrow.prototype.getArrowHeadPoints = function (points, tailLeft, tailRight) {
          var len = getBaseLength(points);
          var headHeight = len * this._headHeightFactor;
          var headPnt = points[points.length - 1];
          len = distance$1(headPnt, points[points.length - 2]);
          var tailWidth = distance$1(tailLeft, tailRight);
          if (headHeight > tailWidth * this._headTailFactor) {
              headHeight = tailWidth * this._headTailFactor;
          }
          var headWidth = headHeight * this._headWidthFactor;
          var neckWidth = headHeight * this._neckWidthFactor;
          headHeight = headHeight > len ? len : headHeight;
          var neckHeight = headHeight * this._neckHeightFactor;
          var headEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
          var neckEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
          var headLeft = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, false);
          var headRight = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, true);
          var neckLeft = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, false);
          var neckRight = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, true);
          return [neckLeft, headLeft, headPnt, headRight, neckRight];
      };
      AttackArrow.prototype.getArrowBodyPoints = function (points, neckLeft, neckRight, tailWidthFactor) {
          var allLen = wholeDistance(points);
          var len = getBaseLength(points);
          var tailWidth = len * tailWidthFactor;
          var neckWidth = distance$1(neckLeft, neckRight);
          var widthDif = (tailWidth - neckWidth) / 2;
          var tempLen = 0;
          var leftBodyPnts = [];
          var rightBodyPnts = [];
          for (var i = 1; i < points.length - 1; i++) {
              var angle = getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
              tempLen += distance$1(points[i - 1], points[i]);
              var w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
              var left = getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
              var right = getThirdPoint(points[i - 1], points[i], angle, w, false);
              leftBodyPnts.push(left);
              rightBodyPnts.push(right);
          }
          return leftBodyPnts.concat(rightBodyPnts);
      };
      return AttackArrow;
  }(Geometry));

  /**
   * 双箭头类扩展
   * 胡红勋
   */
  var DoubleArrow = /** @class */ (function (_super) {
      __extends$3(DoubleArrow, _super);
      function DoubleArrow(points) {
          var _this = _super.call(this, DrawType.DOUBLE_ARROW, points) || this;
          _this._connPoint = null;
          _this._tempPoint4 = null;
          _this.fixPointCount = 4;
          _this._headHeightFactor = 0.25;
          _this._headWidthFactor = 0.3;
          _this._neckHeightFactor = 0.85;
          _this._neckWidthFactor = 0.15;
          return _this;
      }
      DoubleArrow.prototype.finishDrawing = function () {
          if (this.getPointCount() === 3 && this._tempPoint4 !== null)
              this.getPoints().push(this._tempPoint4);
          if (this._connPoint !== null)
              this.getPoints().push(this._connPoint);
      };
      DoubleArrow.prototype.generate = function () {
          var count = this.getPointCount();
          var _points = this.getPoints();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates([_points]);
              return;
          }
          var pnt1 = _points[0];
          var pnt2 = _points[1];
          var pnt3 = _points[2];
          if (count === 3) {
              this._tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
          }
          else {
              this._tempPoint4 = _points[3];
          }
          if (count === 3 || count === 4) {
              this._connPoint = middle(pnt1, pnt2);
          }
          else {
              this._connPoint = _points[4];
          }
          var leftArrowPnts, rightArrowPnts;
          if (isClockWise(pnt1, pnt2, pnt3)) {
              leftArrowPnts = this.getArrowPoints(pnt1, this._connPoint, this._tempPoint4, false);
              rightArrowPnts = this.getArrowPoints(this._connPoint, pnt2, pnt3, true);
          }
          else {
              leftArrowPnts = this.getArrowPoints(pnt2, this._connPoint, pnt3, false);
              rightArrowPnts = this.getArrowPoints(this._connPoint, pnt1, this._tempPoint4, true);
          }
          var m = leftArrowPnts.length;
          var t = (m - 5) / 2;
          var llBodyPnts = leftArrowPnts.slice(0, t);
          var lArrowPnts = leftArrowPnts.slice(t, t + 5);
          var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
          var rlBodyPnts = rightArrowPnts.slice(0, t);
          var rArrowPnts = rightArrowPnts.slice(t, t + 5);
          var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
          rlBodyPnts = getBezierPoints(rlBodyPnts);
          var bodyPnts = getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
          lrBodyPnts = getBezierPoints(lrBodyPnts);
          var pnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);
          this.setCoordinates([pnts]);
      };
      DoubleArrow.prototype.getArrowPoints = function (pnt1, pnt2, pnt3, clockWise) {
          var midPnt = middle(pnt1, pnt2);
          var len = distance$1(midPnt, pnt3);
          var midPnt1 = getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
          var midPnt2 = getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
          //var midPnt3=PlotUtils.getThirdPoint(pnt3, midPnt, 0, len * 0.7, true);
          midPnt1 = getThirdPoint(midPnt, midPnt1, Constants.HALF_PI, len / 5, clockWise);
          midPnt2 = getThirdPoint(midPnt, midPnt2, Constants.HALF_PI, len / 4, clockWise);
          //midPnt3=PlotUtils.getThirdPoint(midPnt, midPnt3, Constants.HALF_PI, len / 5, clockWise);
          var points = [midPnt, midPnt1, midPnt2, pnt3];
          // 计算箭头部分
          var arrowPnts = this.getArrowHeadPoints(points, this._headHeightFactor || 0.25, this._headWidthFactor || 0.3);
          var neckLeftPoint = arrowPnts[0];
          var neckRightPoint = arrowPnts[4];
          // 计算箭身部分
          var tailWidthFactor = distance$1(pnt1, pnt2) / getBaseLength(points) / 2;
          var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
          var n = bodyPnts.length;
          var lPoints = bodyPnts.slice(0, n / 2);
          var rPoints = bodyPnts.slice(n / 2, n);
          lPoints.push(neckLeftPoint);
          rPoints.push(neckRightPoint);
          lPoints = lPoints.reverse();
          lPoints.push(pnt2);
          rPoints = rPoints.reverse();
          rPoints.push(pnt1);
          return lPoints.reverse().concat(arrowPnts, rPoints);
      };
      DoubleArrow.prototype.getArrowHeadPoints = function (points, tailLeft, tailRight) {
          var len = getBaseLength(points);
          var headHeight = len * (this._headHeightFactor || 0.25);
          var headPnt = points[points.length - 1];
          distance$1(tailLeft, tailRight);
          var headWidth = headHeight * (this._headWidthFactor || 0.3);
          var neckWidth = headHeight * (this._neckWidthFactor || 0.15);
          var neckHeight = headHeight * (this._neckHeightFactor || 0.85);
          var headEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
          var neckEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
          var headLeft = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, false);
          var headRight = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, true);
          var neckLeft = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, false);
          var neckRight = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, true);
          return [neckLeft, headLeft, headPnt, headRight, neckRight];
      };
      DoubleArrow.prototype.getArrowBodyPoints = function (points, neckLeft, neckRight, tailWidthFactor) {
          var allLen = wholeDistance(points);
          var len = getBaseLength(points);
          var tailWidth = len * tailWidthFactor;
          var neckWidth = distance$1(neckLeft, neckRight);
          var widthDif = (tailWidth - neckWidth) / 2;
          var tempLen = 0;
          var leftBodyPnts = [];
          var rightBodyPnts = [];
          for (var i = 1; i < points.length - 1; i++) {
              var angle = getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
              tempLen += distance$1(points[i - 1], points[i]);
              var w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
              var left = getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
              var right = getThirdPoint(points[i - 1], points[i], angle, w, false);
              leftBodyPnts.push(left);
              rightBodyPnts.push(right);
          }
          return leftBodyPnts.concat(rightBodyPnts);
      };
      // 计算对称点
      DoubleArrow.prototype.getTempPoint4 = function (linePnt1, linePnt2, point) {
          var midPnt = middle(linePnt1, linePnt2);
          var len = distance$1(midPnt, point);
          var angle = getAngleOfThreePoints(linePnt1, midPnt, point);
          var symPnt, distance1, distance2, mid;
          if (angle < Constants.HALF_PI) {
              distance1 = len * Math.sin(angle);
              distance2 = len * Math.cos(angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, false);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, true);
          }
          else if (angle >= Constants.HALF_PI && angle < Math.PI) {
              distance1 = len * Math.sin(Math.PI - angle);
              distance2 = len * Math.cos(Math.PI - angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, false);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, false);
          }
          else if (angle >= Math.PI && angle < Math.PI * 1.5) {
              distance1 = len * Math.sin(angle - Math.PI);
              distance2 = len * Math.cos(angle - Math.PI);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, true);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, true);
          }
          else {
              distance1 = len * Math.sin(Math.PI * 2 - angle);
              distance2 = len * Math.cos(Math.PI * 2 - angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, true);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, false);
          }
          return symPnt;
      };
      return DoubleArrow;
  }(Geometry));

  /**
   * 攻击箭头扩展类
   * 胡红勋
   */
  var SquadCombat = /** @class */ (function (_super) {
      __extends$3(SquadCombat, _super);
      function SquadCombat(points) {
          var _this = _super.call(this, points) || this;
          _this._tailWidthFactor = 0.1;
          _this.headHeightFactor = 0.18;
          _this.headWidthFactor = 0.3;
          _this.neckHeightFactor = 0.85;
          _this.neckWidthFactor = 0.15;
          _this.type = DrawType.SQUAD_COMBAT;
          return _this;
      }
      SquadCombat.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var tailPnts = this.getTailPoints(pnts);
          var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this._tailWidthFactor);
          count = bodyPnts.length;
          var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse());
          this.setCoordinates([coords]);
      };
      SquadCombat.prototype.getTailPoints = function (points) {
          var allLen = getBaseLength(points);
          var tailWidth = allLen * this._tailWidthFactor;
          var tailLeft = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, false);
          var tailRight = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, true);
          return [tailLeft, tailRight];
      };
      return SquadCombat;
  }(AttackArrow));

  /**
   * 攻击箭头扩展类
   * huhongxun
   */
  var TailedSquadCombat = /** @class */ (function (_super) {
      __extends$3(TailedSquadCombat, _super);
      function TailedSquadCombat(points) {
          var _this = _super.call(this, points) || this;
          _this._tailWidthFactor = 0.1;
          _this._swallowTailFactor = 1;
          _this.type = DrawType.TAILED_SQUAD_COMBAT;
          _this.headHeightFactor = 0.18;
          _this.headWidthFactor = 0.3;
          _this.neckHeightFactor = 0.85;
          _this.neckWidthFactor = 0.15;
          return _this;
      }
      TailedSquadCombat.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var tailPnts = this.getTailPoints(pnts);
          var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this._tailWidthFactor);
          count = bodyPnts.length;
          var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);
          this.setCoordinates([coords]);
      };
      TailedSquadCombat.prototype.getTailPoints = function (points) {
          var allLen = getBaseLength(points);
          var tailWidth = allLen * this._tailWidthFactor;
          var tailLeft = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, false);
          var tailRight = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, true);
          var len = tailWidth * this._swallowTailFactor;
          var swallowTailPnt = getThirdPoint(points[1], points[0], 0, len, true);
          return [tailLeft, swallowTailPnt, tailRight];
      };
      return TailedSquadCombat;
  }(AttackArrow));

  /**
   * 军事标绘多变形扩展类
   * huhongxun
   */
  var Polygon = /** @class */ (function (_super) {
      __extends$3(Polygon, _super);
      function Polygon(points) {
          return _super.call(this, DrawType.POLYGON, points) || this;
      }
      Polygon.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          this.setCoordinates([this.getPoints()]);
      };
      return Polygon;
  }(Geometry));

  /**
   * huhongxun
   * 标记类
   *
   */
  var Marker = /** @class */ (function (_super) {
      __extends$3(Marker, _super);
      function Marker(points) {
          var _this = _super.call(this, DrawType.POINT, points) || this;
          _this.fixPointCount = 1;
          return _this;
      }
      Marker.prototype.generate = function () {
          var pnt = this.getPoints()[0];
          this.setCoordinates(pnt);
      };
      return Marker;
  }(Geometry));

  /**
   * 矩形类扩展类
   * huhongxun

   */
  var Rectangle = /** @class */ (function (_super) {
      __extends$3(Rectangle, _super);
      function Rectangle(points) {
          var _this = _super.call(this, DrawType.RECTANGLE, points) || this;
          _this.fixPointCount = 2;
          return _this;
      }
      Rectangle.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          else {
              var pnt1 = this.getPoints()[0];
              var pnt2 = this.getPoints()[1];
              var xmin = Math.min(pnt1[0], pnt2[0]);
              var xmax = Math.max(pnt1[0], pnt2[0]);
              var ymin = Math.min(pnt1[1], pnt2[1]);
              var ymax = Math.max(pnt1[1], pnt2[1]);
              var tl = [xmin, ymax];
              var tr = [xmax, ymax];
              var br = [xmax, ymin];
              var bl = [xmin, ymin];
              this.setCoordinates([[tl, tr, br, bl, tl]]);
          }
      };
      return Rectangle;
  }(Geometry));

  /**
   * huhongxun
   * 线的扩展类
   */
  var Polyline = /** @class */ (function (_super) {
      __extends$3(Polyline, _super);
      function Polyline(points) {
          return _super.call(this, DrawType.POLYLINE, points) || this;
      }
      Polyline.prototype.generate = function () {
          var count = this.getPointCount();
          if (count <= 1) {
              return;
          }
          this.setCoordinates(this.getPoints());
      };
      return Polyline;
  }(Geometry));

  /**
   * huhongxun 军事标绘的工厂方法---
   * @param {*} type  标绘类型---
   * @param {*} points  点数组
   */
  function createDraw(type, points) {
      switch (type) {
          case DrawType.ARC:
              return new Arc(points);
          case DrawType.ELLIPSE:
              return new Ellipse(points);
          case DrawType.CURVE:
              return new Curve(points);
          case DrawType.CLOSED_CURVE:
              return new ClosedCurve(points);
          case DrawType.LUNE:
              return new Lune(points);
          case DrawType.SECTOR:
              return new Sector(points);
          case DrawType.GATHERING_PLACE:
              return new GatheringPlace(points);
          case DrawType.STRAIGHT_ARROW:
              return new StraightArrow(points);
          case DrawType.ASSAULT_DIRECTION:
              return new AssaultDirection(points);
          case DrawType.ATTACK_ARROW:
              return new AttackArrow(points);
          case DrawType.FINE_ARROW:
              return new FineArrow(points);
          case DrawType.DOUBLE_ARROW:
              return new DoubleArrow(points);
          case DrawType.SQUAD_COMBAT:
              return new SquadCombat(points);
          case DrawType.TAILED_SQUAD_COMBAT:
              return new TailedSquadCombat(points);
          case DrawType.POLYGON:
              return new Polygon(points);
          case DrawType.POINT:
              return new Marker(points);
          case DrawType.RECTANGLE:
              return new Rectangle(points);
          case DrawType.POLYLINE:
              return new Polyline(points);
          case DrawType.CIRCLE:
              return new Circle$1(points);
      }
      return null;
  }

  /**
   *  绘制组件
   */
  var Draw$3 = /** @class */ (function (_super) {
      __extends$3(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, edit: true }, (options || {})), map) || this;
          /**
           * @ignore
           *
           * @type {PointCoordinate[]}
           */
          _this._points = [];
          return _this;
      }
      Object.defineProperty(Draw.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "drawing", {
          get: function () {
              return defined$1(this._handler.getInputAction(2 /* LEFT_CLICK */));
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Draw.prototype.init = function () {
          this.initialized = true;
          this._style = {
              point: this.options.pointStyle || DRAW_STYLE.point,
              polygon: this.options.polygonStyle || DRAW_STYLE.polygon,
              polyline: this.options.polylineStyle || DRAW_STYLE.polyline
          };
          this._initTip();
          this._initEvent();
      };
      /**
       * @ignore
       */
      Draw.prototype._initEvent = function () {
          // 事件处理器是否销毁，如果未销毁，则销毁
          this._handler && !this._handler.isDestroyed && this._handler.destroy();
          this._handler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
      };
      /**
       * @ignore
       */
      Draw.prototype._firstClickEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.position);
          if (!obj.cartesian3) {
              return;
          }
          this._tip.element.innerHTML = "单击继续绘制要素，双击完成要素绘制!";
          this._points.push(cartesian3ToDegrees(obj.cartesian3, this.map));
          this._plot = createDraw(this.type, this._points.slice());
          if (this.type === DrawType.CIRCLE) {
              // @ts-ignore
              this._plot.minRadius = this.options.minRadius / 1000 || 50 / 1000;
              // @ts-ignore
              this._plot.maxRadius = this.options.maxRadius / 1000 || Number.MAX_VALUE;
          }
          this._feature = this._createFeauture();
          this.map.map.entities.add(this._feature);
          this._handler.removeInputAction(2 /* LEFT_CLICK */);
          this._handler.removeInputAction(15 /* MOUSE_MOVE */);
          this.dispatchEvent({
              type: BaseEventType.DRAW_START
          });
          // 特殊类型几何体需要几个点来插值生成特殊几何体
          if (this._plot.fixPointCount === this._plot.getPointCount()) {
              this._doubleClickEventHandler();
              return;
          }
          this._handler.setInputAction(this._nextClickEventHandler.bind(this), 2 /* LEFT_CLICK */);
          this._handler.setInputAction(this._mouseMoveEventHandler.bind(this), 15 /* MOUSE_MOVE */);
          this._handler.setInputAction(this._doubleClickEventHandler.bind(this), 3 /* LEFT_DOUBLE_CLICK */);
      };
      /**
       * @ignore
       */
      Draw.prototype._nextClickEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.position);
          if (!obj.cartesian3) {
              return;
          }
          var _coord = cartesian3ToDegrees(obj.cartesian3, this.map);
          var distance = distance$1(_coord, this._points[this._points.length - 1]);
          if (distance > Constants.ZERO_TOLERANCE) {
              this._points.push(_coord);
              this._plot.setPoints(this._points.slice());
              // 添加节点触发节点增加事件---
              this.dispatchEvent({
                  type: "nodeadd",
                  target: this,
                  positions: this._points.slice()
              });
              if (this._plot.fixPointCount === this._plot.getPointCount()) {
                  // 结束绘制----销毁资源
                  this._doubleClickEventHandler();
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._doubleClickEventHandler = function () {
          var feature_;
          if (this._feature.point) {
              feature_ = new Point$1({ coordinates: this._plot.coordinates.slice() });
          }
          if (this._feature.polyline) {
              feature_ = new Polyline$1({
                  coordinates: this._plot.coordinates.slice().map(function (i) {
                      return [i[0], i[1]];
                  })
              });
          }
          if (this._feature.polygon) {
              // TODO:坐标格式化
              var cd = this._plot.coordinates.slice();
              cd.forEach(function (i) {
                  i.forEach(function (c) {
                      c.length = 2;
                  });
                  i.push(i[0]);
              });
              if (this.type === DrawType.CIRCLE) {
                  feature_ = new Circle({
                      radius: this._plot.ellipsoidRaduis * 1000,
                      center: this._plot.center
                  });
              }
              else {
                  feature_ = new Polygon$1({ coordinates: cd });
              }
          }
          feature_.set("plot", this._plot.getPoints());
          feature_.set("plotType", this.type);
          feature_.setProperties({ plot: this._plot.getPoints(), plotType: this.type });
          this.options.target && this.options.target.addFeature(feature_);
          this.dispatchEvent({
              type: BaseEventType.DRAW_END,
              feature: feature_
          });
          this.deactive();
      };
      /**
       * @ignore
       */
      Draw.prototype._mouseMoveEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.endPosition);
          if (!obj.cartesian3) {
              return;
          }
          var _coord = cartesian3ToDegrees(obj.cartesian3, this.map);
          this._tip.setPosition(cartesian3ToDegrees(obj.cartesian3, this.map));
          if (distance$1(_coord, this._points[this._points.length - 1]) > Constants.ZERO_TOLERANCE) {
              this._plot.setPoints(this._points.concat([_coord]).slice(0));
              if (this._points.concat([_coord]).length > 1) {
                  this.dispatchEvent({
                      type: "nodemove",
                      target: this,
                      positions: this._points.concat([_coord]).slice(0)
                  });
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._destroyEvent = function () {
          this._handler.isDestroyed && this._handler.destroy();
          this._handler = undefined;
      };
      // 交互失效
      Draw.prototype.deactive = function () {
          this._feature && this.map.map.entities.remove(this._feature);
          this._points = [];
          this._tip.hide();
          this._tip.element.innerHTML = "单击地图绘制要素";
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this._plot = undefined;
          this._feature = undefined;
          if (this._handler && !this._handler.isDestroyed()) {
              this._handler.getInputAction(2 /* LEFT_CLICK */) &&
                  this._handler.removeInputAction(2 /* LEFT_CLICK */);
              this._handler.getInputAction(15 /* MOUSE_MOVE */) &&
                  this._handler.removeInputAction(15 /* MOUSE_MOVE */);
              this._handler.getInputAction(3 /* LEFT_DOUBLE_CLICK */) &&
                  this._handler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
          }
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.initialized = false;
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this.map = undefined;
      };
      /**
       * 激活绘制组件
       *
       *
       */
      Draw.prototype.active = function (type) {
          var _this = this;
          this.deactive();
          this._defaultCursor = this.map.map.container.style.cursor;
          // @ts-ignore
          this.map.map.container.style.cursor = "crosshair";
          this._type = type;
          this._handler.setInputAction(this._firstClickEventHandler.bind(this), 2 /* LEFT_CLICK */);
          this._handler.setInputAction(function (evt) {
              var obj = pickPositionAndObj(_this.map.map.scene, evt.endPosition);
              if (!obj.cartesian3) {
                  return;
              }
              _this._tip.setPosition(cartesian3ToDegrees(obj.cartesian3, _this.map));
          }, 15 /* MOUSE_MOVE */);
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype._destroy = function () {
          this.remove();
          this._style = undefined;
          this._destroyEvent();
          _super.prototype._destroy.call(this);
      };
      /**
       * 清除全部标绘
       */
      Draw.prototype.clearAll = function () {
          this.options.target && this.options.target.clearFeatures();
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype._initTip = function () {
          var _element = document.createElement("span");
          _element.className = "mti-measure-tool mti-measure-tool-length";
          _element.innerHTML = "单击地图绘制要素";
          this._tip = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: _element,
              offset: [0, 18]
          }, this.map);
          this._tip.setPositioning(Positioning.TOP_LEFT);
      };
      /**
       * @ignore
       */
      Draw.prototype._createFeauture = function () {
          var _a;
          var _this = this;
          var _entity;
          if (this.type === DrawType.POINT) {
              var _coordinates = this._plot.coordinates;
              var _style = transformParams(this._style.point[0]);
              _entity = new Cesium__namespace.Entity(__assign$1({ position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_coordinates), false)), point: __assign$1({}, _style) }, _style));
          }
          else if (this.type === DrawType.POLYLINE ||
              this.type === DrawType.ARC ||
              this.type === DrawType.CURVE ||
              this.type === DrawType.STRAIGHT_ARROW) {
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates || [];
                  var _pos = _coordinates.slice().map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return _pos;
              }, false);
              var _style = transformParams(this._style.polyline[0]);
              _entity = new Cesium__namespace.Entity({
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_style) }, _style))
              });
          }
          else {
              // 线的回调坐标---
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates.concat() || [];
                  var _coords = [];
                  if (_coordinates[0] && _coordinates[0].length > 2) {
                      //  _coords = Turf.cleanCoords(Turf.lineString(_coordinates[0])).geometry.coordinates;
                      _coords = _coordinates[0];
                      _coords.push(_coords[0]);
                  }
                  var _pos = _coords.map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return _pos;
              }, false);
              var _style = transformParams(this._style.polygon[0]);
              // 面的回调坐标-----开始
              var hierarchy = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates[0] || [];
                  var _pos = _coordinates.slice().map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return new Cesium__namespace.PolygonHierarchy(_pos);
              }, false);
              // 面的回调坐标-----结束---
              _entity = new Cesium__namespace.Entity({
                  polygon: new Cesium__namespace.PolygonGraphics(__assign$1({ hierarchy: hierarchy, material: _style.type === StyleItemType.COLOR
                          ? styleItemFillColorToColorMaterialProperty(__assign$1({}, _style))
                          : styleItemToImageMaterialProperty(__assign$1({}, _style)) }, __assign$1({}, _style))),
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(__assign$1({}, _style)) }, __assign$1({}, _style)))
              });
          }
          return _entity;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成   | (feature: [[Feature]])-要素对象
       *  `nodeadd`    |   绘制要素新增点时         | (positions: [[PointCoordinate]][])-坐标串
       *  `nodemove`   |   移动顶点时              | (positions: [[PointCoordinate]][])-坐标串
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       *  `nodeadd`    |   绘制要素新增点时         | (positions: [[PointCoordinate]][])-坐标串
       *  `nodemove`   |   移动顶点时              | (positions: [[PointCoordinate]][])-坐标串
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Draw;
  }(Component));

  /**
   * 周边搜索组件
   */
  /** @class */ ((function (_super) {
      __extends$3(CircleSearch, _super);
      function CircleSearch(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(CircleSearch.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "minRadius", {
          /**
           * 可拖拽的最小半径  单位: 米
           */
          get: function () {
              return this._minRadius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "maxRadius", {
          /**
           * 可拖拽的最大半径  单位: 米
           */
          get: function () {
              return this._maxRadius;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      CircleSearch.prototype.init = function () {
          var _a = this.options, infoPopup = _a.infoPopup, step = _a.step, _b = _a.minRadius, minRadius = _b === void 0 ? 5 : _b, maxRadius = _a.maxRadius;
          defined$1(this.minRadius) || this.setMinRadius(minRadius);
          defined$1(this.maxRadius) || this.setMaxRadius(maxRadius);
          this._step = step || 1;
          this._dragging = false;
          this._hovering = false;
          this.initialized = true;
          this._layer = new VectorLayer({});
          this._infoPopup = infoPopup;
          this._eventKeys = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          defined$1(this._infoPopup) && this.map.addOverlay(this._infoPopup);
      };
      /**
       * 激活
       * @param feature
       * @returns
       */
      CircleSearch.prototype.active = function (feature) {
          var _this = this;
          this.deactive();
          if (feature instanceof Circle) {
              this._active(feature);
          }
          else if (this.map) {
              this._draw = new Draw$3({}, this.map).active(DrawType.CIRCLE);
              this._draw.once(BaseEventType.DRAW_END, function (_a) {
                  var feature = _a.feature; _a.target;
                  _this._active(feature);
                  _this.dispatchEvent({
                      type: BaseEventType.EDIT_END,
                      radius: feature.radius,
                      center: feature.center,
                      dragPointCoordinate: _this._dragCoordinate
                  });
                  window.setTimeout(function () {
                      _this._removeDraw();
                  });
              });
          }
          return this;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._initEvent = function () {
          this._eventKeys.setInputAction(pointerDownHandler$1.bind(this), 0 /* LEFT_DOWN */);
          this._eventKeys.setInputAction(pointerUpHandler$1.bind(this), 1 /* LEFT_UP */);
          this._eventKeys.setInputAction(pointerMoveHandler$1.bind(this), 15 /* MOUSE_MOVE */);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._clearEvent = function () {
          this._eventKeys.removeInputAction(0 /* LEFT_DOWN */);
          this._eventKeys.removeInputAction(1 /* LEFT_UP */);
          this._eventKeys.removeInputAction(15 /* MOUSE_MOVE */);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._initFeatures = function (feature) {
          var _this = this;
          var _a;
          var centerCoordinates = feature.center;
          centerCoordinates[2] = 0;
          var radius = feature.radius;
          var _b = this.options, linkedLineStyle = _b.linkedLineStyle, centerPointStyle = _b.centerPointStyle, dragPointStyle = _b.dragPointStyle, circleStyle = _b.circleStyle;
          this._inverseMatrix4 = Cesium__namespace.Matrix4.inverse(Cesium__namespace.Transforms.eastNorthUpToFixedFrame(degreesToCartesian3(centerCoordinates, this.map)), new Cesium__namespace.Matrix4());
          this._distance = radius;
          var circleRadiusCallBack = function () {
              return _this._distance;
          };
          var circleRadiusPolylineCallBack = function (styleItem) {
              return function () {
                  return calculateCircleOutlineCartesian3Points(_this._distance, degreesToCartesian3(centerCoordinates, _this.map), centerCoordinates, styleItem, _this.map);
              };
          };
          this._circle = new Circle({ center: centerCoordinates, radius: radius });
          this._circle.setStyle((circleStyle === null || circleStyle === void 0 ? void 0 : circleStyle.map(function (i) { return (__assign$1(__assign$1(__assign$1({}, i), { entity: true, semiMajorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false), semiMinorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false) }), (i.type === StyleItemType.COLOR || i.type === StyleItemType.RADIAL_GRADIENT
              ? { positions: new Cesium__namespace.CallbackProperty(circleRadiusPolylineCallBack(i), false) }
              : {}))); })) ||
              CIRCLE_SEARCH_STYLE.circle.map(function (i) { return (__assign$1(__assign$1(__assign$1({}, i), { semiMajorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false), semiMinorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false) }), (i.type === StyleItemType.COLOR || i.type === StyleItemType.RADIAL_GRADIENT
                  ? { positions: new Cesium__namespace.CallbackProperty(circleRadiusPolylineCallBack(i), false) }
                  : {}))); }));
          this._layer.addFeature(this._circle);
          this._dragCoordinate = computeDragPoint$1.call(this);
          var centerCartesian3 = coordinatesToCartesian3Array([centerCoordinates])[0];
          var linkedLineCoordinatesCallBack = function () {
              return [centerCartesian3, coordinatesToCartesian3Array([_this._dragCoordinate])[0]];
          };
          this._linkedLine = new Polyline$1({ coordinates: [centerCoordinates, centerCoordinates] });
          this._linkedLine.setStyle((linkedLineStyle === null || linkedLineStyle === void 0 ? void 0 : linkedLineStyle.map(function (i) { return (__assign$1(__assign$1({}, i), { entity: true, positions: new Cesium__namespace.CallbackProperty(linkedLineCoordinatesCallBack, false) })); })) ||
              CIRCLE_SEARCH_STYLE.linkedLine.map(function (i) { return (__assign$1(__assign$1({}, i), { positions: new Cesium__namespace.CallbackProperty(linkedLineCoordinatesCallBack, false) })); }));
          this._layer.addFeature(this._linkedLine);
          this._centerPoint = new Point$1({ coordinates: centerCoordinates });
          this._centerPoint.setStyle(centerPointStyle || CIRCLE_SEARCH_STYLE.centerPoint);
          this._layer.addFeature(this._centerPoint);
          this._dragPoint = new Point$1({ coordinates: this._dragCoordinate });
          this._dragPoint.setStyle(dragPointStyle || CIRCLE_SEARCH_STYLE.dragPoint);
          this._layer.addFeature(this._dragPoint);
          (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(this._dragCoordinate);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._active = function (feature) {
          this._initEvent();
          this._initFeatures(feature);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._clearFeatures = function () {
          this._layer.clearFeatures();
          this._centerPoint = this._linkedLine = this._dragPoint = this._circle = void 0;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._removeDraw = function () {
          if (this._draw) {
              this.map.removeComponent(this._draw, true);
              this._draw = void 0;
          }
      };
      /**
       * 清除
       * @returns
       */
      CircleSearch.prototype.deactive = function () {
          if (this._infoPopup) {
              this._infoPopup.setPosition();
          }
          this._removeDraw();
          this._clearFeatures();
          this._clearEvent();
          return this;
      };
      /**
       * 禁用地图平移交互组件
       * @ignore
       */
      CircleSearch.prototype._disableMapDragPan = function () {
          this.map.map.scene.screenSpaceCameraController.enableInputs = false;
      };
      /**
       * 启用地图平移拖拽交互组件
       * @ignore
       */
      CircleSearch.prototype._enableMapDragPan = function () {
          this.map.map.scene.screenSpaceCameraController.enableInputs = true;
      };
      /**
       * 设置周边搜索圆半径
       *
       * @param radius
       * @returns
       */
      CircleSearch.prototype.setCircleRadius = function (radius) {
          if (typeof radius === "number" &&
              radius >= this.minRadius &&
              (!defined$1(this.maxRadius) || radius <= this.maxRadius)) {
              changeCircleRadius$1.call(this, radius);
          }
          return this;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._infoPopup);
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          this._infoPopup = void 0;
          this._eventKeys.destroy();
          this._eventKeys = void 0;
          this._inverseMatrix4 = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `radiuschange`    |   半径变更  | (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *  `editend` |  拖拽修改或绘制结束  |  (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      CircleSearch.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `radiuschange`    |   半径变更  | (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *  `editend` |  拖拽修改或绘制结束  |  (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      CircleSearch.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 设置可拖拽的最小半径  单位: 米
       */
      CircleSearch.prototype.setMinRadius = function (radius) {
          this._minRadius = radius;
          return this;
      };
      /**
       * 设置可拖拽的最大半径  单位: 米
       */
      CircleSearch.prototype.setMaxRadius = function (radius) {
          this._maxRadius = radius;
          return this;
      };
      return CircleSearch;
  })(Component));
  function pointerDownHandler$1(e) {
      if (this._hovering) {
          this._disableMapDragPan();
          this._dragging = true;
      }
  }
  function pointerUpHandler$1() {
      this.map.map.scene.canvas.style.cursor = "";
      if (this._dragging) {
          this._hovering = false;
          this._dragging = false;
          this._enableMapDragPan();
          this.dispatchEvent({
              type: BaseEventType.EDIT_END,
              radius: this._distance,
              center: this._circle.center,
              dragPointCoordinate: this._dragCoordinate
          });
      }
  }
  function pointerMoveHandler$1(movement) {
      var _a;
      if (this._dragging) {
          var startCartesian3 = this.map.map.scene.camera.pickEllipsoid(movement.startPosition, this.map.map.scene.globe.ellipsoid);
          var endCartesian3 = this.map.map.scene.camera.pickEllipsoid(movement.endPosition, this.map.map.scene.globe.ellipsoid);
          if (!(startCartesian3 && endCartesian3)) {
              return;
          }
          var move = computeDistance$1.call(this, startCartesian3, endCartesian3);
          move = move - (move % this._step);
          var newR = this._distance + move;
          if (!(newR >= this.minRadius && (!defined$1(this.maxRadius) || newR <= this.maxRadius))) {
              return;
          }
          changeCircleRadius$1.call(this, newR);
      }
      else {
          var pickObj = this.map.map.scene.pick(movement.endPosition);
          if ((pickObj === null || pickObj === void 0 ? void 0 : pickObj.id) === this._dragPoint || ((_a = pickObj === null || pickObj === void 0 ? void 0 : pickObj.id) === null || _a === void 0 ? void 0 : _a[FEATURE_LINK]) === this._dragPoint) {
              this._hovering = true;
              this.map.map.scene.canvas.style.cursor = "move";
          }
          else if (!this._dragging) {
              this._hovering = false;
              this.map.map.scene.canvas.style.cursor = "";
          }
      }
  }
  function changeCircleRadius$1(radius) {
      var _a;
      if (this._distance === radius) {
          return;
      }
      this._distance = radius;
      this._dragCoordinate = computeDragPoint$1.call(this);
      this._dragPoint.setCoordinates(this._dragCoordinate);
      (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(this._dragCoordinate);
      this.dispatchEvent({
          type: BaseEventType.RADIUS_CHANGE,
          radius: radius,
          center: this._circle.center,
          dragPointCoordinate: this._dragCoordinate
      });
  }
  function computeDistance$1(startCartesian3, endCartesian3) {
      var cameraPosition = Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, this.map.map.camera.position, new Cesium__namespace.Cartesian3());
      // 由平面法线、和平面经过点获取平面方程表示的三维平面
      var temPlane = Cesium__namespace.Plane.fromPointNormal(Cesium__namespace.Cartesian3.UNIT_X, Cesium__namespace.Cartesian3.UNIT_Z);
      return (Cesium__namespace.IntersectionTests.rayPlane(new Cesium__namespace.Ray(cameraPosition, Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, endCartesian3, new Cesium__namespace.Cartesian3()), cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3())), temPlane).x -
          Cesium__namespace.IntersectionTests.rayPlane(new Cesium__namespace.Ray(cameraPosition, Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, startCartesian3, new Cesium__namespace.Cartesian3()), cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3())), temPlane).x);
  }
  function computeDragPoint$1() {
      var _a;
      // @ts-ignore
      var points = Cesium__namespace.EllipseGeometryLibrary.computeEllipsePositions({
          semiMinorAxis: this._distance,
          semiMajorAxis: this._distance,
          rotation: 0,
          granularity: Cesium__namespace.Math.RADIANS_PER_DEGREE,
          center: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._circle.coordinates), false))
      }, true, false).positions;
      var degrees = cartesian3ToDegrees(new Cesium__namespace.Cartesian3(points[0], points[1], points[2]));
      degrees.length = 2;
      return degrees;
  }

  /**
   * 历史轨迹组件
   */
  /** @class */ ((function (_super) {
      __extends$3(HistoryTrack, _super);
      function HistoryTrack(options, map) {
          var _this = _super.call(this, options) || this;
          _this.setLoop(options.loop || false);
          _this.setVelocity(options.velocity || 1);
          _this.setTrack(options.track || false);
          _this._duration = options.duration;
          _this._paused = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(HistoryTrack.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "loop", {
          /**
           * 是否循环
           */
          get: function () {
              return this._loop;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "velocity", {
          /**
           * 速度值 单位: m/s
           *
           * 当duration未定义时,按照设定的真实速度移动
           */
          get: function () {
              return this._velocity;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "track", {
          /**
           * 是否跟踪移动
           */
          get: function () {
              return this._track;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      HistoryTrack.prototype.init = function () {
          this.initialized = true;
          this._eventHelper = new Cesium__namespace.EventHelper();
          this._time = this._distance = 0;
          this._layer = new VectorLayer({});
          var _a = this.options, pathCoordinates = _a.path, targetStyle = _a.targetStyle, pathStyle = _a.pathStyle, originStyle = _a.originStyle, destinationStyle = _a.destinationStyle;
          this._pathGeoJsonFeature = Array.isArray(pathCoordinates) ? lineString(pathCoordinates) : pathCoordinates;
          this._pathCoordinates = this._pathGeoJsonFeature.geometry.coordinates;
          this._pathDistance = Turf__namespace.length(this._pathGeoJsonFeature) * 1000;
          if (pathStyle) {
              this._path = new Polyline$1({ coordinates: this._pathCoordinates });
              this._path.setStyle(pathStyle);
              this._layer.addFeature(this._path);
          }
          if (originStyle) {
              this._origin = new Point$1({ coordinates: this._pathCoordinates[0] });
              this._origin.setStyle(originStyle);
              this._layer.addFeature(this._origin);
          }
          if (destinationStyle) {
              this._destination = new Point$1({ coordinates: this._pathCoordinates[this._pathCoordinates.length - 1] });
              this._destination.setStyle(destinationStyle);
              this._layer.addFeature(this._destination);
          }
          this._target = new Point$1({ coordinates: this._pathCoordinates[0] });
          this._target.setStyle(targetStyle);
          this._layer.addFeature(this._target);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._clearEvent();
          this._reset();
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._pathCoordinates =
              this._target =
                  this._origin =
                      this._path =
                          this._destination =
                              this._layer =
                                  this._pathGeoJsonFeature =
                                      this._eventHelper =
                                          void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._initEvent = function () {
          var e_1, _a;
          var _this = this;
          var previousTime = performance.now();
          var startPosition = degreesToCartesian3(this._target.coordinates, this.map);
          var _b = getPointFeatureModelParams(this._target, this.map), clamped = _b.clamped, hasModel = _b.hasModel;
          if (hasModel && this.track) {
              try {
                  for (var _c = __values(this._target.sourceFeature.entities), _d = _c.next(); !_d.done; _d = _c.next()) {
                      var entity = _d.value;
                      if (defined$1(entity.model)) {
                          entity.viewFrom = new Cesium__namespace.ConstantProperty(new Cesium__namespace.Cartesian3(180, 100, 10000));
                          this.map.map.trackedEntity = entity;
                          break;
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          if (clamped) {
              coordinatesClampToTerrain([this._target.coordinates], this.map).then(function (res) {
                  startPosition = degreesToCartesian3(res[0], _this.map);
              });
          }
          var hasHeight = this._target.coordinates.length > 2;
          this._eventHelper.add(this.map.map.scene.postRender, function () {
              if (!_this._paused) {
                  var rate = void 0;
                  if (defined$1(_this._duration)) {
                      _this._time += (performance.now() - previousTime) / 1000;
                      rate = _this._time / _this._duration;
                  }
                  else {
                      _this._distance += ((performance.now() - previousTime) / 1000) * _this.velocity;
                      rate = _this._distance / _this._pathDistance;
                  }
                  rate = rate >= 1 ? 1 : rate;
                  var slicedLineFeature = Turf__namespace.lineSliceAlong(_this._pathGeoJsonFeature, 0, (_this._pathDistance * rate) / 1000);
                  var slicedCoordinates = slicedLineFeature.geometry.coordinates;
                  var newPointCoordinate = slicedCoordinates[slicedCoordinates.length - 1];
                  if (hasHeight) {
                      var _a = __read(_this._pathGeoJsonFeature.geometry.coordinates[slicedCoordinates.length - 1], 3), lng1 = _a[0], lat1 = _a[1], height1 = _a[2];
                      var _b = __read(_this._pathGeoJsonFeature.geometry.coordinates[slicedCoordinates.length - 2], 3), lng2 = _b[0], lat2 = _b[1], height2 = _b[2];
                      var _c = __read(slicedCoordinates[slicedCoordinates.length - 1], 2), lng3 = _c[0], lat3 = _c[1];
                      var newHeight = void 0;
                      if (lng1 === lng3 && lat1 === lat3) {
                          newHeight = height1;
                      }
                      else {
                          newHeight =
                              height2 -
                                  (Turf__namespace.distance([lng2, lat2], [lng3, lat3]) / Turf__namespace.distance([lng2, lat2], [lng1, lat1])) *
                                      (height2 - height1);
                      }
                      newPointCoordinate[2] = newHeight;
                  }
                  if (_this.track && !hasModel) {
                      _this.map.setCenter(newPointCoordinate);
                  }
                  _this._target.setCoordinates(newPointCoordinate);
                  if (hasModel) {
                      var position1_1 = startPosition;
                      if (clamped) {
                          coordinatesClampToTerrain([newPointCoordinate], _this.map).then(function (res) {
                              var position2 = degreesToCartesian3(res[0]);
                              updateFeatureOrientation(_this._target, position1_1, position2, _this.map.map.scene.globe.ellipsoid);
                              startPosition = position2;
                          });
                      }
                      else {
                          var position2 = degreesToCartesian3(newPointCoordinate);
                          updateFeatureOrientation(_this._target, position1_1, position2, _this.map.map.scene.globe.ellipsoid);
                          startPosition = position2;
                      }
                  }
                  _this.dispatchEvent({
                      type: BaseEventType.MOVE,
                      progress: rate,
                      position: newPointCoordinate
                  });
                  if (rate >= 1) {
                      if (!_this.loop) {
                          _this._clearEvent();
                          _this.dispatchEvent({
                              type: BaseEventType.MOVE_END,
                              progress: rate,
                              position: newPointCoordinate
                          });
                      }
                      else {
                          _this._reset();
                      }
                      return;
                  }
              }
              previousTime = performance.now();
          });
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._clearEvent = function () {
          this._eventHelper.removeAll();
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._reset = function () {
          this._time = this._distance = 0;
          this._target.setCoordinates(this._pathCoordinates[0]);
          this.resume();
      };
      /**
       * 开始
       *
       * @returns
       */
      HistoryTrack.prototype.start = function () {
          if (this._time !== 0 || this._distance !== 0) {
              return this;
          }
          this._reset();
          this._clearEvent();
          this._initEvent();
          return this;
      };
      /**
       * 暂停
       * @returns
       */
      HistoryTrack.prototype.pause = function () {
          this._paused = true;
          return this;
      };
      /**
       * 恢复
       * @returns
       */
      HistoryTrack.prototype.resume = function () {
          this._paused = false;
          return this;
      };
      /**
       * 停止
       * @returns
       */
      HistoryTrack.prototype.stop = function () {
          this._reset();
          this._clearEvent();
          return this;
      };
      /**
       * 设置是否循环
       * @param loop
       * @returns
       */
      HistoryTrack.prototype.setLoop = function (loop) {
          this._loop = loop;
          return this;
      };
      /**
       * 设置速度值 单位: m/s
       *
       * @param velocity
       * @returns
       */
      HistoryTrack.prototype.setVelocity = function (velocity) {
          this._velocity = velocity;
          return this;
      };
      /**
       * 设置是否跟踪
       * @param track
       * @returns
       */
      HistoryTrack.prototype.setTrack = function (track) {
          this._track = track;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `move`    |   移动中  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *  `moveend` |  非循环状态下,移动结束  |  (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      HistoryTrack.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `move`    |   移动中  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *  `moveend` |  非循环状态下,移动结束  |  (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      HistoryTrack.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return HistoryTrack;
  })(Component));

  var PointEntity$1 = /** @class */ (function () {
      function PointEntity(viewer, pixel, style) {
          this.graphic = null;
          this.wp = null;
          this.viewer = viewer;
          this.style = style || PointEntity.defaultStyle();
          this.create(pixel);
      }
      /**
       * 类的静态方法，点实体的默认样式
       */
      PointEntity.defaultStyle = function () {
          return {
              type: StyleItemType.CIRCLE,
              entity: true,
              fillColor: "red",
              outlineColor: "red",
              outlineWidth: 1,
              color: "red",
              pixelSize: 8,
              heightReference: 1 /* CLAMP_TO_GROUND */
          };
      };
      /**
       * 类的静态方法，点实体的编辑样式
       *
       */
      PointEntity.editStyle = function () {
          return {
              type: StyleItemType.ICON,
              image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAANklEQVQ4jWNkCJP/z0BFwMLAwMAQnqR+lhqGrZx305iJGgYhg1EDRw0cNXDUwFEDIYCR2lUAAHrqBxH0XVqDAAAAAElFTkSuQmCC",
              entity: true,
              scale: 0.8,
              heightReference: 0 /* NONE */
          };
      };
      /**
       * 类的静态方法，点实体的选中样式
       *
       */
      PointEntity.selectedStyle = function () {
          return {
              type: StyleItemType.CIRCLE,
              entity: true,
              color: "rgba(0,255,255,1)",
              pixelSize: 5,
              outlineColor: "rgba(0,255,255,1)",
              outlineWidth: 3
          };
      };
      // 将世界坐标系转化为经纬度、高度---
      PointEntity.cartesian3ToLonLat = function (world) {
          return cartesian3ToCartographic(world);
      };
      /**
       * 根据屏幕像素坐标创建实体，并添加到地图上
       *
       * @param {Cesium.Cartesian2} pixel  2d笛卡尔坐标点
       * @return {Cesium.Entity}  实体类对象
       */
      PointEntity.prototype.create = function (pos) {
          var _wp = null;
          if (pos instanceof Cesium__namespace.Cartesian3) {
              _wp = pos;
          }
          else {
              var cartesian3 = pickPositionAndObj(this.viewer.scene, pos).cartesian3;
              if (cartesian3) {
                  _wp = cartesian3;
              }
          }
          var entity = new Cesium__namespace.Entity({
              position: _wp
          });
          if (this.style.type === StyleItemType.ICON && this.style.entity) {
              entity.billboard = new Cesium__namespace.BillboardGraphics(transformParams(this.style));
          }
          if (this.style.type === StyleItemType.CIRCLE && this.style.entity) {
              entity.point = new Cesium__namespace.PointGraphics(transformParams(this.style));
          }
          this.graphic = entity;
          this.wp = _wp;
          return entity;
      };
      /**
       * 实体的清除
       *
       */
      PointEntity.prototype.remove = function () {
          this.viewer.entities.remove(this.graphic);
      };
      return PointEntity;
  }());

  /**
   *编辑组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Edit, _super);
      function Edit(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, minRadius: 50, maxRadius: Number.MAX_VALUE }, (options || {})), map) || this;
          /**
           * @ignore
           */
          _this._editMode = false;
          /**
           * @ignore
           */
          _this._vertices = [];
          /**
           * @ignore
           */
          _this._positions = [];
          return _this;
      }
      Object.defineProperty(Edit.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Edit.prototype.init = function () {
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
          this.initialized = true;
      };
      /**
       * 激活编辑组件
       * 二维可选，三维必传，二维如果编辑军事要素要素必传，
       * @param {Feature} feature 要编辑的要素
       */
      Edit.prototype.active = function (feature) {
          var _this = this;
          if (!defined$1(this.map)) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          if (!defined$1(Feature)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          this.deactive();
          this._editFeature = feature;
          if (Array.isArray(feature.get("plot")) && defined$1(feature.get("plotType"))) {
              feature.set("plot", createDraw(feature.get("plotType"), feature.get("plot")));
          }
          if (this._editFeature.type !== GeoJsonGeometryType.POINT) {
              // 添加编辑节点
              this.addVertices();
          }
          this._eventHandler.setInputAction(function (e) {
              _this._down(e);
          }, 0 /* LEFT_DOWN */);
          // 鼠标弹起事件-----
          this._eventHandler.setInputAction(this._up.bind(this), 1 /* LEFT_UP */);
          // 拖动点改变实体位置---
          this._eventHandler.setInputAction(function (e) {
              _this._move(e);
          }, 15 /* MOUSE_MOVE */);
          return this;
      };
      /**
       *
       * @ignore
       * @param e
       * 鼠标左键按下事件监听程序
       */
      Edit.prototype._down = function (e) {
          if (this._editFeature.type === GeoJsonGeometryType.POINT) {
              var obj = this.map.map.scene.pick(e.position);
              if (Cesium__namespace.defined(obj) && obj.id && this._editFeature.sourceFeature.entities.includes(obj.id)) {
                  // 获取到编辑要拖拽的节点---
                  this._selectedPosition = obj.id.position.getValue(Cesium__namespace.JulianDate.fromDate(new Date()));
                  // @ts-ignore
                  // this.map.map.container.style.cursor =
                  //   "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4jZXTO0sDQRTF8Z8xWIigIEF8dCKIIgQiptZGCFj4KGIU7Kz8FH4AeyvBSkRjYeEDtLGysRBsbCwsxEctEhQtZgNLTDbJhWnOzPnfO7NnO3K5nDZqBmW8oID3VBvmNI4xjGmcortVwCC6sIVKpOWx3ApgBDfC6Oco4RufuE03MQ/hGqPRKmMRq/jAYxJgAFcYi2kF7KNYFRpdIRN1Hq/Rv7AXF+oBMlHniRq9giVcJAH6cYmpOuYVnNV2iwP6InO2jrkofPd/FQf0oLdm/wdrOKlnjgPW8YZZPMXMJRw1MlcBKexEB18xF0E2cJhkJuQ7L7z8Ag6E+07iN5qoM8H/kBaSVa0s5oUH28VmkwGe00LStoU/7T5OFzKflNa7P7UfNc+pDPV+AAAAAElFTkSuQmCC),auto";
                  //  this.map.map.scene.screenSpaceCameraController.enableRotate = false;
                  this.map.dragPan(false);
                  this._selectedVertice = obj.id;
                  this.dispatchEvent({
                      type: BaseEventType.EDIT_START,
                      feature: this._editFeature
                  });
              }
          }
          else {
              var obj = this.map.map.scene.pick(e.position);
              var vertices = this._vertices;
              if (Cesium__namespace.defined(obj) && obj.id && vertices.includes(obj.id)) {
                  console.warn("down", vertices.includes(obj.id));
                  // 获取到编辑要拖拽的节点---
                  this._selectedPosition = obj.id.position.getValue(Cesium__namespace.JulianDate.fromDate(new Date()));
                  // @ts-ignore
                  // this.map.map.container.style.cursor =
                  //   "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4jZXTO0sDQRTF8Z8xWIigIEF8dCKIIgQiptZGCFj4KGIU7Kz8FH4AeyvBSkRjYeEDtLGysRBsbCwsxEctEhQtZgNLTDbJhWnOzPnfO7NnO3K5nDZqBmW8oID3VBvmNI4xjGmcortVwCC6sIVKpOWx3ApgBDfC6Oco4RufuE03MQ/hGqPRKmMRq/jAYxJgAFcYi2kF7KNYFRpdIRN1Hq/Rv7AXF+oBMlHniRq9giVcJAH6cYmpOuYVnNV2iwP6InO2jrkofPd/FQf0oLdm/wdrOKlnjgPW8YZZPMXMJRw1MlcBKexEB18xF0E2cJhkJuQ7L7z8Ag6E+07iN5qoM8H/kBaSVa0s5oUH28VmkwGe00LStoU/7T5OFzKflNa7P7UfNc+pDPV+AAAAAElFTkSuQmCC),auto";
                  // this.map.map.scene.screenSpaceCameraController.enableRotate = false;
                  this.map.dragPan(false);
                  this._selectedVertice = obj.id;
                  this.dispatchEvent({
                      type: BaseEventType.EDIT_START,
                      feature: this._editFeature
                  });
              }
          }
      };
      /**
       *
       *@ignore
       * 鼠标左键弹出事件监听程序
       */
      Edit.prototype._up = function () {
          if (this._selectedPosition && this._selectedVertice) {
              this._selectedPosition = null;
              this._selectedVertice = null;
              this.map.dragPan(true);
              // @ts-ignore
              this.map.map.container.style.cursor = "default";
              this.dispatchEvent({
                  type: BaseEventType.EDIT_END,
                  feature: this._editFeature
              });
          }
      };
      /**
       *@ignore
       * @param event
       * 鼠标移动事件处理程序
       */
      Edit.prototype._move = function (event) {
          if (this._selectedPosition) {
              // 像素坐标转化为世界三维笛卡尔坐标
              var wp = pickPositionAndObj(this.map.map.scene, event.endPosition).cartesian3;
              if (!wp) {
                  return;
              }
              this._selectedPosition = wp;
              // 选中顶点的位置变更
              this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
              // 点要素时
              if (this._editFeature.type === GeoJsonGeometryType.POINT) {
                  this._editFeature.setCoordinates(cartesian3ToDegrees(wp));
                  return;
              }
              var index = this._vertices.indexOf(this._selectedVertice);
              this._positions.splice(index, 1, this._selectedPosition);
              if (this._editFeature.type === GeoJsonGeometryType.LINE_STRING) {
                  if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                      this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                      this._editFeature.setCoordinates(this._editFeature.get("plot").coordinates);
                  }
                  else {
                      this._editFeature.setCoordinates(cartesian3sToDegreesArray(this._positions));
                  }
              }
              if (this._editFeature.type === GeoJsonGeometryType.POLYGON) {
                  if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                      this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                      this._editFeature.setCoordinates(this._editFeature.get("plot").coordinates);
                  }
                  else {
                      this._editFeature.setCoordinates([cartesian3sToDegreesArray(this._positions)]);
                  }
              }
              if (this._editFeature.type === FeatureType.CIRCLE) {
                  if (index === 0) {
                      var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this._editFeature.get("plot").ellipsoidRaduis, 90).geometry.coordinates;
                      this._positions[1] = degreesToCartesian3(dragPointCoordinates);
                      this._vertices[0].position = new Cesium__namespace.ConstantPositionProperty(this._positions[0]);
                      this._vertices[1].position = new Cesium__namespace.ConstantPositionProperty(this._positions[1]);
                      // 判断半径是否超范围
                  }
                  else {
                      var _postions = cartesian3sToDegreesArray(this._positions);
                      var _radius = calculatesRadius(_postions[0], _postions[1]);
                      if (_radius <= this.options.minRadius / 1000) {
                          var _dragCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this.options.minRadius / 1000, 90).geometry.coordinates;
                          this._selectedPosition = degreesToCartesian3(_dragCoordinates);
                          this._positions.splice(index, 1, this._selectedPosition);
                          this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
                      }
                      if (_radius >= this.options.maxRadius / 1000) {
                          var _dragCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this.options.maxRadius / 1000, 90).geometry.coordinates;
                          this._selectedPosition = degreesToCartesian3(_dragCoordinates);
                          this._positions.splice(index, 1, this._selectedPosition);
                          this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
                      }
                  }
                  this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                  this._editFeature.setRadius(this._editFeature.get("plot").ellipsoidRaduis * 1000);
                  this._editFeature.setCenter(this._editFeature.get("plot").center);
              }
              // 非编辑模式--
          }
          else {
              var obj = this.map.map.scene.pick(event.endPosition);
              if (Cesium__namespace.defined(obj) && obj.id) {
                  // @ts-ignore
                  this.map.map.container.style.cursor = "cursor:pointer;cursor: hand;";
              }
              else {
                  // @ts-ignore
                  this.map.map.container.style.cursor = "default";
              }
          }
      };
      /**
       * 设置顶点
       */
      Edit.prototype.addVertices = function () {
          var e_1, _a;
          // 该实体为点实体---
          // 该实体为多线实体
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === GeoJsonGeometryType.LINE_STRING) {
              // 军事标绘要素
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  this._positions = this._editFeature.coordinates.slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          // 该实体为多边形实体
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === GeoJsonGeometryType.POLYGON) {
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  this._positions = this._editFeature.coordinates[0].slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          // 该实体为圆
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === FeatureType.CIRCLE) {
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  var center = this._editFeature.center;
                  var radius = this._editFeature.radius / 1000;
                  var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(center), radius, 90).geometry
                      .coordinates;
                  this._editFeature.set("plot", createDraw(DrawType.CIRCLE, [center, dragPointCoordinates]));
                  //在这做处理---圆可以反算
                  this._positions = [center, dragPointCoordinates].map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          try {
              // 添加顶点----
              for (var _b = __values(this._positions), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var _cartesian = _c.value;
                  var pt = new PointEntity$1(this.map.map, _cartesian, PointEntity$1.defaultStyle());
                  this._vertices.push(pt.graphic);
                  this.map.map.entities.add(pt.graphic);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * 删除编辑顶点
       * @private
       * @ignore
       */
      Edit.prototype._removeVertice = function () {
          var e_2, _a;
          try {
              for (var _b = __values(this._vertices), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var _entity = _c.value;
                  this.map.map.entities.remove(_entity);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this._vertices = [];
      };
      Edit.prototype.deactive = function () {
          this._removeVertice();
          this._eventHandler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
          this._eventHandler.removeInputAction(2 /* LEFT_CLICK */);
          this._eventHandler.removeInputAction(1 /* LEFT_UP */);
          this._eventHandler.removeInputAction(0 /* LEFT_DOWN */);
          this._eventHandler.removeInputAction(15 /* MOUSE_MOVE */);
          this._editFeature = undefined;
          return this;
      };
      /**
       * 注销该对象的绘图事件监听句柄
       * @ignore
       */
      Edit.prototype._destroy = function () {
          this._eventHandler = void 0;
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Edit.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this.map = undefined;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Edit;
  })(Component));

  /**
   * 绘制类别
   *
   * @enum {number}
   */
  var DrawTypeEnum$1;
  (function (DrawTypeEnum) {
      /**
       * 点
       */
      DrawTypeEnum["POINT"] = "point";
      /**
       * 面
       */
      DrawTypeEnum["POLYGON"] = "polygon";
      /**
       * 线
       */
      DrawTypeEnum["POLYLINE"] = "polyline";
  })(DrawTypeEnum$1 || (DrawTypeEnum$1 = {}));
  /**
   * 绘制组件
   */
  var Draw$2 = /** @class */ (function (_super) {
      __extends$3(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, options || {}, map) || this;
          /**
           * @ignore
           * 草图
           */
          _this._tempGraphic = null;
          /**
           * @ignore
           */
          _this._positions = [];
          /**
           * @ignore
           */
          _this._vertices = [];
          /**
           * @ignore
           */
          _this._type = DrawTypeEnum$1.POINT;
          /**
           * @ignore
           */
          _this._tempPositions = [];
          /**
           * @ignore
           */
          _this._isShowTooltip = true;
          return _this;
      }
      Object.defineProperty(Draw.prototype, "isShowTooltip", {
          /**
           * @ignore
           */
          set: function (flag) {
              this._isShowTooltip = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Draw.prototype.init = function () {
          this._layer = this._options.layer;
          this._element = document.createElement("span");
          this._element.className = "mti-measure-tool mti-measure-tool-length";
          this._element.innerHTML = "单击地图绘制要素";
          this._overlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: this._element,
              offset: [5, -15]
          }, this.map);
          var _styleConfig = Cesium__namespace.defaultValue(this._options.style, {});
          if (!Cesium__namespace.defined(_styleConfig.point[0].heightReference)) {
              _styleConfig.point[0].heightReference = 1 /* CLAMP_TO_GROUND */;
          }
          if (!Cesium__namespace.defined(_styleConfig.polyline[0].clampToGround)) {
              _styleConfig.polyline[0].clampToGround = true;
          }
          if (!Cesium__namespace.defined(_styleConfig.polygon[0].clampToGround)) {
              _styleConfig.polygon[0].clampToGround = true;
          }
          this._style = _styleConfig;
          // 已经初始化
          this.initialized = true;
      };
      /**
       * 激活绘制组件
       * @param {string} type 绘制类型
       * @memberof Draw
       */
      Draw.prototype.active = function (type) {
          var _this = this;
          if (Cesium__namespace.defined(this._handler)) {
              this.deactive();
          }
          this._positions = [];
          this._type = type;
          // 激活绘制控件后修改鼠标样式
          this.map.map.scene.canvas.style.cursor = "crosshair";
          // 屏幕事件处理器
          this._handler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.canvas);
          this._handler.setInputAction(function (e) {
              // 绘制点时
              if (_this._type === DrawTypeEnum$1.POINT) {
                  var pt = new PointEntity$1(_this.map.map, e.position, _this._style.point[0]);
                  _this._positions.push(pt.wp);
                  _this._tempGraphic = _this.map.map.entities.add(pt.graphic);
                  var _feature = new Point$1({ coordinates: cartesian3ToDegrees(pt.wp, _this.map) });
                  _this._layer && _this._layer.addFeature(_feature);
                  _this.dispatchEvent({
                      type: BaseEventType.DRAW_END,
                      target: _this,
                      feature: _feature
                  });
                  // 销毁事件监听----
                  _this.deactive();
              }
              else {
                  _this._element.innerHTML = "单击继续绘制,双击结束绘制";
                  _this.onClick(e);
              }
          }, 2 /* LEFT_CLICK */);
          this._handler.setInputAction(function (e) {
              _this.onMove(e);
          }, 15 /* MOUSE_MOVE */);
          if ([DrawTypeEnum$1.POLYLINE, DrawTypeEnum$1.POLYGON].includes(this._type)) {
              this._handler.setInputAction(function (e) {
                  var _feature = _this._createFeature();
                  if (!Cesium__namespace.defined(_feature)) {
                      return;
                  }
                  _this.deactive();
                  _this._layer && _this._layer.addFeature(_feature);
                  var wp = pickPositionAndObj(_this.map.map.scene, e.position).cartesian3;
                  _this.dispatchEvent({
                      type: BaseEventType.DRAW_END,
                      target: _this,
                      feature: _feature,
                      position: cartesian3ToDegrees(wp, _this.map)
                  });
              }, 3 /* LEFT_DOUBLE_CLICK */);
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._createFeature = function () {
          var _this = this;
          var _feature = null;
          var _coods = [];
          if (this._type === DrawTypeEnum$1.POLYGON) {
              if (this._positions.length > 2) {
                  _coods = this._positions.map(function (pos) {
                      var s = cartesian3ToDegrees(pos, _this.map);
                      return [s[0], s[1]];
                  });
                  _coods.push(_coods[0]);
                  _feature = new Polygon$1({ coordinates: [_coods] });
              }
          }
          if (this._type === DrawTypeEnum$1.POLYLINE) {
              if (this._positions.length > 1) {
                  _coods = this._positions.map(function (pos) {
                      var s = cartesian3ToDegrees(pos, _this.map);
                      return [s[0], s[1]];
                  });
                  _feature = new Polyline$1({ coordinates: _coods });
              }
          }
          return _feature;
      };
      /**
       *  鼠标单击事件回调
       * @param e
       * @ignore
       */
      Draw.prototype.onClick = function (e) {
          // 创建临时实体
          if (this._positions.length === 0) {
              this._createTemp();
          }
          var wp = pickPositionAndObj(this.map.map.scene, e.position).cartesian3;
          if (Cesium__namespace.defined(wp)) {
              this._positions.push(wp);
              // 是否保存顶点信息
              var pt = new PointEntity$1(this.map.map, wp, this._style.point[0]);
              this.map.map.entities.add(pt.graphic);
              this._vertices.push(pt.graphic);
          }
          // 添加节点触发节点增加事件---
          this.dispatchEvent({
              type: "nodeAdd",
              target: this,
              positions: this._positions
          });
      };
      /**
       * @ignore
       */
      Draw.prototype.onMove = function (e) {
          var wp = pickPositionAndObj(this.map.map.scene, e.endPosition).cartesian3;
          if (Cesium__namespace.defined(wp)) {
              var _position = cartesian3ToDegrees(wp, this.map);
              if (this._isShowTooltip) {
                  this._overlay.setPosition(_position);
              }
              if (this._type === DrawTypeEnum$1.POINT) {
                  return;
              }
              else {
                  this._tempPositions = this._positions.concat([wp]);
              }
              if (this._positions.length >= 1) {
                  // 点类型直接返回-----
                  // 添加节点移动触发事件
                  this.dispatchEvent({
                      type: "nodeMove",
                      target: this,
                      positions: this._tempPositions
                  });
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._createTemp = function () {
          var _this = this;
          if (this._type === DrawTypeEnum$1.POLYGON) {
              var hierarchy = new Cesium__namespace.CallbackProperty(function () {
                  return new Cesium__namespace.PolygonHierarchy(_this._tempPositions);
              }, false);
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  return __spreadArray$1(__spreadArray$1([], __read(_this._tempPositions), false), [_this._tempPositions[0]], false);
              }, false);
              var _style = transformParams(this._style.polygon[0]);
              var _lstyle = transformParams(this._style.polyline[0]);
              this._tempGraphic = this.map.map.entities.add(new Cesium__namespace.Entity({
                  polygon: new Cesium__namespace.PolygonGraphics(__assign$1({ hierarchy: hierarchy, material: _style.type === StyleItemType.COLOR
                          ? styleItemFillColorToColorMaterialProperty(_style)
                          : styleItemToImageMaterialProperty(_style) }, _style)),
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_lstyle) }, _lstyle))
              }));
          }
          if (this._type === DrawTypeEnum$1.POLYLINE) {
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  return _this._tempPositions;
              }, false);
              var _style = transformParams(this._style.polyline[0]);
              this._tempGraphic = this.map.map.entities.add(new Cesium__namespace.Entity({
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_style) }, _style))
              }));
          }
      };
      /**
       * 移除绘制的对象
       * @private
       * @ignore
       */
      Draw.prototype._removeGraphic = function () {
          if (this._tempGraphic) {
              this.map.map.entities.remove(this._tempGraphic);
              this._tempGraphic = undefined;
          }
          this._removeVertices();
          this._positions = [];
          this._tempPositions = [];
      };
      /**
       * 移除顶点
       * @private
       * @ignore
       */
      Draw.prototype._removeVertices = function () {
          var e_1, _a;
          if (this._vertices) {
              try {
                  for (var _b = __values(this._vertices), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var _entity = _c.value;
                      this.map.map.entities.remove(_entity);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          this._vertices = [];
      };
      // 交互失效
      Draw.prototype.deactive = function () {
          if (this._handler && !this._handler.isDestroyed()) {
              this._handler.getInputAction(2 /* LEFT_CLICK */) &&
                  this._handler.removeInputAction(2 /* LEFT_CLICK */);
              this._handler.getInputAction(3 /* LEFT_DOUBLE_CLICK */) &&
                  this._handler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
              this._handler.getInputAction(15 /* MOUSE_MOVE */) &&
                  this._handler.removeInputAction(15 /* MOUSE_MOVE */);
              this._handler.destroy();
          }
          this._overlay.hide();
          this.map.map.scene.canvas.style.cursor = "default";
          this._handler = undefined;
          this._removeGraphic();
          this._element.innerHTML = "单击地图绘制要素";
      };
      /**
       * @ignore
       */
      Draw.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Draw.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._overlay, false);
          this._element = undefined;
          this.map = undefined;
      };
      return Draw;
  }(Component));

  /**
   * 测量类型
   *
   * @enum {number}
   */
  var MeasureType;
  (function (MeasureType) {
      MeasureType["DISTANCE"] = "distance";
      MeasureType["AREA"] = "area";
  })(MeasureType || (MeasureType = {}));

  /**
   * 测量组件
   *
   * @class Measure
   */
  /** @class */ ((function (_super) {
      __extends$3(Measure, _super);
      // 构造函数---
      function Measure(options, map) {
          var _this = _super.call(this, __assign$1({ measureStyle: __spreadArray$1(__spreadArray$1([], __read(Measure_STYLE.draw), false), __read(Measure_STYLE.finsh), false) }, options), map) || this;
          /**
           * @ignore
           */
          _this._isActive = false;
          /**
           * @ignore
           */
          _this._uuids = [];
          /**
           * @ignore
           */
          _this._components = [];
          /**
           * @ignore
           */
          _this.isFirst = true;
          return _this;
      }
      Object.defineProperty(Measure.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Measure.prototype.init = function () {
          this.initialized = true;
          this._measureType = "";
          this._element = document.createElement("span");
          this._element.className = "mti-measure-tool mti-measure-tool-length";
          this._overlay = new Overlay({
              id: "popup",
              element: this._element,
              offset: [5, -60]
          }, this.map);
          this._tipElement = document.createElement("span");
          this._tipElement.className = "mti-measure-tool mti-measure-tool-length";
          this._tipOverlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: this._tipElement,
              offset: [5, -30]
          }, this.map);
          this._layer = new VectorLayer({
              style: this.options.measureStyle.slice(3).map(function (style) {
                  style.heightReference = 1 /* CLAMP_TO_GROUND */;
                  return style;
              })
          }, this.map);
      };
      /**
       * 添加到地球
       * 重写父类方法---
       * @ignore
       */
      Measure.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
      };
      /**
       * 添加绘制交互组件
       * @param type
       * @ignore
       */
      Measure.prototype._addDrawInteractions = function (type) {
          this._draw = new Draw$2({
              style: {
                  point: [__assign$1({ heightReference: 1 }, this.options.measureStyle[0])],
                  polyline: [__assign$1({ heightReference: 1 }, this.options.measureStyle[1])],
                  polygon: [__assign$1({ heightReference: 1 }, this.options.measureStyle[2])]
              }
          }, this.map);
          var uniqueKey = Cesium__namespace.createGuid();
          this._draw.set("uuid", uniqueKey);
          this._uuids.push(uniqueKey);
          this._draw.on(BaseEventType.DRAW_END, this._drawEndHandle.bind(this));
          this._draw.on("nodeAdd", this._nodeAdded.bind(this));
          this._draw.on("nodeMove", this._nodeMove.bind(this));
          var _type;
          if (type === MeasureType.DISTANCE) {
              _type = DrawTypeEnum$1.POLYLINE;
          }
          if (type === MeasureType.AREA) {
              _type = DrawTypeEnum$1.POLYGON;
          }
          this._draw.active(_type);
          this._draw.set("type", type);
      };
      /**
       * 增加节点时触发的回调
       * @param event
       * @ignore
       */
      Measure.prototype._nodeAdded = function (event) {
          this._tipElement.innerHTML = "单击继续测量，双击结束测量";
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _text = "起点";
              var _position = cartesian3ToDegrees(event.positions[0]);
              if (event.positions.length >= 2) {
                  this._distance = parseFloat(getSpaceDisfromCartesian3Array(event.positions));
                  this._overlay.hide();
                  _text = getSpaceDisfromCartesian3Array(event.positions);
                  _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              }
              var measureResult = document.createElement("span");
              measureResult.className = "mti-measure-tool-overlay-label";
              measureResult.innerHTML = _text;
              var _overlay = new Overlay({
                  id: Cesium__namespace.createGuid(),
                  element: measureResult,
                  offset: [0, -25],
                  positioning: Positioning.TOP_LEFT
              }, this.map);
              _overlay.setPosition(_position);
              _overlay.set("uuid", this._draw.get("uuid"));
              _overlay.set("distance", _text);
          }
      };
      /**
       * 节点移动时的回调
       * @param event
       * @ignore
       */
      Measure.prototype._nodeMove = function (event) {
          // 测量面积
          if (this._draw.get("type") === MeasureType.AREA && event.positions.length > 2) {
              var _positions = cartesian3sToDegreesArray(event.positions);
              var _text = getArea(_positions);
              this._element.innerHTML = _text;
              var _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              this._overlay.setPosition(_position);
          }
          // 测面长度
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              var _text = getSpaceDisfromCartesian3Array(event.positions);
              this._element.innerHTML = _text;
              this._overlay.setPosition(_position);
          }
      };
      /**
       * 绘制完成时的回调
       * @param event
       * @ignore
       */
      Measure.prototype._drawEndHandle = function (event) {
          var _this = this;
          var _overlays = this.map.getOverlays().filter(function (a) {
              return a.get("uuid") === _this._draw.get("uuid");
          });
          var feature = event.feature;
          feature.set("uuid", this._draw.get("uuid"));
          this._layer.addFeature(feature);
          this.map.removeOverlay(_overlays[_overlays.length - 1]);
          this.map.removeOverlay(_overlays[_overlays.length - 2]);
          var _tip = "";
          if (this._draw.get("type") === MeasureType.AREA) {
              var _positions = event.feature.coordinates[0];
              _positions[_positions.length - 1];
              var _text = getArea(_positions);
              _tip = "总面积：<span class='measure-end-label'>" + _text + "</span>";
          }
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _positions = event.feature.coordinates;
              _positions[_positions.length - 1];
              var _text = getSpaceDisfromCartesian3Array(_positions.map(function (_position) {
                  var _a;
                  return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_position), false));
              }));
              _tip = "总长：<span class='measure-end-label'>" + _text + "</span>";
          }
          var measureResult = document.createElement("span");
          measureResult.className = "mti-measure-tool-end-overlay-label";
          measureResult.innerHTML = _tip;
          var _resultOverlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: measureResult,
              offset: [-1, 0],
              positioning: Positioning.TOP_LEFT
          }, this.map);
          _resultOverlay.set("uuid", this._draw.get("uuid"));
          this._overlay.hide();
          _resultOverlay.setPosition(event.position);
          this._tipOverlay.hide();
          this.isFirst = true;
          this.addMeasureRemoveButton(event.position);
          this.removeLastInteraction_();
          this.dispatchEvent(BaseEventType.MEASURE_END);
          this.map.unByKey(this._moveListener);
          this._moveListener = null;
      };
      /**
       * 添加单例清除按钮
       * @param coordinate
       * @ignore
       */
      Measure.prototype.addMeasureRemoveButton = function (_position) {
          var imageButton = document.createElement("img");
          imageButton.src =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEYzMzc1RDY3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEYzMzc1RDc3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0RjMzNzVENDdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0RjMzNzVENTdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsDx84AAAAC3SURBVHjavJIxDoMwDEV/ok5wDCbu0DvAdUBIwMLFSs/AxDXY6tZ2SCGVUikd+ifn20+2k5hHVd0AXJGmGQw+UyWMxY8KQGpbUNcB23aYHIsnuSgIy8dlAQ2DgwWSmD0YE5ReAq5pQOMIrKsDRByjKGC/dsxz2L7XQgU8JB7n4qDoY6SYF4J+p72T7/zeOXqr03SMx8XnsTUX7UgElKVCyDK3s8Tsae6sv/8ceceZ6jr1k99fAgwAsZy0Sa2HgDcAAAAASUVORK5CYII=";
          imageButton.style.cursor = "pointer";
          imageButton.title = "清除测量结果";
          imageButton.onclick = (function (id) {
              return function () {
                  this._removeMeasure(id);
                  this.dispatchEvent(BaseEventType.CLEAR);
              };
          })(this._draw.get("uuid")).bind(this);
          var _overlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: imageButton,
              offset: [-20, 0],
              positioning: Positioning.CENTER_LEFT
          }, this.map);
          _overlay.setPosition(_position);
          _overlay.set("uuid", this._draw.get("uuid"));
      };
      /**
       * 移除测量结果
       * @param uuid
       * @ignore
       */
      Measure.prototype._removeMeasure = function (uuid) {
          var overlays = this.map.getOverlays();
          if (overlays && Array.isArray(overlays)) {
              var length_1 = overlays.length;
              // @ts-ignore
              for (var j = 0, i = 0; j < length_1; j++) {
                  i++;
                  if (overlays[length_1 - i] &&
                      overlays[length_1 - i] instanceof Overlay &&
                      overlays[length_1 - i].get("uuid") === uuid) {
                      this.map.removeOverlay(overlays[length_1 - i]);
                  }
              }
          }
          if (this._layer) {
              var features = this._layer.getFeatures();
              features.forEach(function (feat) {
                  if (feat.get("uuid") === uuid) {
                      this._layer.removeFeature(feat);
                  }
              }, this);
          }
      };
      /**
       * 移除所有测量结果
       */
      Measure.prototype.clear = function () {
          var _this = this;
          if (this._isActive) {
              console.warn("绘制完成，在清除");
              return;
          }
          this._uuids.forEach(function (id) {
              _this._removeMeasure(id);
          });
          return this;
      };
      /**
       * 激活测量组件
       *
       * @param {string} type 量算类型
       */
      Measure.prototype.active = function (type) {
          var _this = this;
          this.removeLastInteraction_();
          this._isActive = true;
          this._type = type;
          this._addDrawInteractions(type);
          this._draw.isShowTooltip = false;
          this._moveListener = this.map.on(BaseEventType.MOUSE_MOVE, function (event) {
              if (_this._isActive) {
                  if (_this.isFirst) {
                      _this._tipElement.innerHTML = "单击地图测量";
                      _this.isFirst = false;
                  }
                  _this._tipOverlay.setPosition(event.coordinate);
              }
          });
          return this;
      };
      /**
       * 失效控件
       */
      Measure.prototype.deactive = function () {
          if (this._isActive) {
              this._removeMeasure(this._draw.get("uuid"));
              this.removeLastInteraction_();
              this._isActive = false;
              this._overlay.hide();
              this._tipOverlay.hide();
          }
          return this;
      };
      /**
       * 移除上一次激活的工具
       * @ignore
       */
      Measure.prototype.removeLastInteraction_ = function () {
          if (this._draw && this.map) {
              this.map.removeComponent(this._draw);
              this._isActive = false;
          }
      };
      /**
       * @ignore
       */
      Measure.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Measure.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.removeLastInteraction_();
          this.clear();
          this._draw = null;
          this.initialized = false;
          this._measureType = "";
          this.map.removeOverlay(this._overlay);
          this.map.removeOverlay(this._tipOverlay);
          this._element = undefined;
          this._tipElement = undefined;
          this.map = undefined;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Measure;
  })(Component));

  var WALL_STYLE_TYPE$1 = [
      StyleItemType.COLOR,
      StyleItemType.IMAGE,
      StyleItemType.LINEAR_GRADIENT,
      StyleItemType.LINEAR_FOW
  ];
  /**
   * 墙组件
   *
   * [cesium]
   */
  /** @class */ ((function (_super) {
      __extends$3(Wall, _super);
      function Wall(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true }, options)) || this;
          _this._visible = _this.options.visible;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Wall.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Wall.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Wall.prototype.init = function () {
          var e_1, _a, _b, e_2, _c, _d, e_3, _e, e_4, _f, _g;
          this._entities = [];
          this.initialized = true;
          var _h = this.options, height = _h.height, data = _h.data;
          var style = this.options.style;
          style = cesiumStyleItemListInit(style);
          try {
              for (var _j = __values(data.features), _k = _j.next(); !_k.done; _k = _j.next()) {
                  var feature = _k.value;
                  switch (feature.geometry.type) {
                      case GeoJsonGeometryType.LINE_STRING:
                          (_b = this._entities).push.apply(_b, __spreadArray$1([], __read(buildEntities$1.call(this, feature.geometry.coordinates, style, height)), false));
                          break;
                      case GeoJsonGeometryType.MULTI_LINE_STRING:
                      case GeoJsonGeometryType.POLYGON:
                          try {
                              for (var _l = (e_2 = void 0, __values(feature.geometry.coordinates)), _m = _l.next(); !_m.done; _m = _l.next()) {
                                  var lineString = _m.value;
                                  (_d = this._entities).push.apply(_d, __spreadArray$1([], __read(buildEntities$1.call(this, lineString, style, height)), false));
                              }
                          }
                          catch (e_2_1) { e_2 = { error: e_2_1 }; }
                          finally {
                              try {
                                  if (_m && !_m.done && (_c = _l.return)) _c.call(_l);
                              }
                              finally { if (e_2) throw e_2.error; }
                          }
                          break;
                      case GeoJsonGeometryType.MULTI_POLYGON:
                          try {
                              for (var _o = (e_3 = void 0, __values(feature.geometry.coordinates)), _p = _o.next(); !_p.done; _p = _o.next()) {
                                  var polygon = _p.value;
                                  try {
                                      for (var _q = (e_4 = void 0, __values(polygon)), _r = _q.next(); !_r.done; _r = _q.next()) {
                                          var iterator = _r.value;
                                          (_g = this._entities).push.apply(_g, __spreadArray$1([], __read(buildEntities$1.call(this, iterator, style, height)), false));
                                      }
                                  }
                                  catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                  finally {
                                      try {
                                          if (_r && !_r.done && (_f = _q.return)) _f.call(_q);
                                      }
                                      finally { if (e_4) throw e_4.error; }
                                  }
                              }
                          }
                          catch (e_3_1) { e_3 = { error: e_3_1 }; }
                          finally {
                              try {
                                  if (_p && !_p.done && (_e = _o.return)) _e.call(_o);
                              }
                              finally { if (e_3) throw e_3.error; }
                          }
                          break;
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       * @param map
       */
      Wall.prototype.addTo = function (map) {
          var e_5, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.add(entity);
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_5) throw e_5.error; }
          }
      };
      /**
       * @ignore
       */
      Wall.prototype.remove = function (destroy) {
          var e_6, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.remove(entity);
              }
          }
          catch (e_6_1) { e_6 = { error: e_6_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_6) throw e_6.error; }
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Wall.prototype._destroy = function () {
          var e_7, _a;
          this.remove();
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  Cesium__namespace.destroyObject(entity);
              }
          }
          catch (e_7_1) { e_7 = { error: e_7_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_7) throw e_7.error; }
          }
          this._entities = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Wall.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Wall.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示墙组件
       */
      Wall.prototype.show = function () {
          var e_8, _a;
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = true;
              }
          }
          catch (e_8_1) { e_8 = { error: e_8_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_8) throw e_8.error; }
          }
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Wall.prototype.hide = function () {
          var e_9, _a;
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = false;
              }
          }
          catch (e_9_1) { e_9 = { error: e_9_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_9) throw e_9.error; }
          }
          return this;
      };
      return Wall;
  })(Component));
  function buildWallPositions$1(coordinates, height) {
      if (coordinates[0].length > 2) {
          return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(coordinates.flat());
      }
      else if (coordinates[0].length === 2 && Cesium__namespace.defined(height)) {
          return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(coordinates.reduce(function (acc, val) { return acc.concat(val, height); }, []));
      }
      throw new Error(ErrorNotification.WALL_COORDINATES_NEED_HEIGHT);
  }
  /** 构建实体 */
  function buildEntities$1(coordinates, style, height) {
      var _this = this;
      var positions = buildWallPositions$1(coordinates, height);
      return style
          .filter(function (i) { return WALL_STYLE_TYPE$1.includes(i.type); })
          .map(function (styleItem) {
          var entity = new Cesium__namespace.Entity({
              show: _this.visible,
              wall: __assign$1({ positions: positions, material: styleItem.type === StyleItemType.COLOR
                      ? styleItemBorderColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem) }, styleItem)
          });
          entity[COMPONENT_LINK] = _this;
          return entity;
      });
  }

  /**
   * 鼠标交互三角测量工具组件
   *
   * @class Triangulation
   */
  /** @class */ ((function (_super) {
      __extends$3(Triangulation, _super);
      function Triangulation(options, map) {
          var _this = _super.call(this, __assign$1({ color: [255, 255, 0, 1], width: 2, label: {} }, (options || {})), map) || this;
          /**
           * @ignore
           */
          _this._entities = [];
          /**
           * @ignore
           */
          _this._active = false; // 是否处于激活状态
          /**
           * @ignore
           */
          _this.interactivePoint = []; // 鼠标点击两次的点
          /**
           * @ignore
           */
          _this._positions = [];
          /**
           * @ignore
           */
          _this._overlayerIds = [];
          /**
           * @ignore
           */
          _this._labelPoint = [
              { type: "a", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "b", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "c", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 }
          ];
          return _this;
      }
      /**
       * @ignore
       */
      Triangulation.prototype.init = function () {
          var e_1, _a, _b, _c;
          this.times = 0;
          var label = __assign$1({ font: "14px sans-serif", outlineWidth: 3, horizontalOrigin: -1 /* RIGHT */, verticalOrigin: 1 /* BOTTOM */, style: 2 /* FILL_AND_OUTLINE */ }, this.options.label);
          try {
              for (var _d = __values(Object.keys(label)), _e = _d.next(); !_e.done; _e = _d.next()) {
                  var key = _e.value;
                  var val = label[key];
                  if (Array.isArray(val)) {
                      if (val.length === 2) {
                          label[key] = new ((_b = Cesium__namespace.Cartesian2).bind.apply(_b, __spreadArray$1([void 0], __read(val), false)))();
                      }
                      else {
                          label[key] = Cesium__namespace.Color.fromAlpha((_c = Cesium__namespace.Color).fromBytes.apply(_c, __spreadArray$1([], __read(val), false)), val.slice(3, 4)[0]);
                      }
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
              }
              finally { if (e_1) throw e_1.error; }
          }
          this._options.label = label;
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Triangulation.prototype._initEvent = function () {
          this._canvas = this.map.map.scene.canvas;
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(this._canvas);
          this._eventHandler.setInputAction(this._mouseClick.bind(this), 2 /* LEFT_CLICK */);
          this._eventHandler.setInputAction(this._mouseMove.bind(this), 15 /* MOUSE_MOVE */);
          this._eventHandler.setInputAction(this._mouseDoubleClick.bind(this), 3 /* LEFT_DOUBLE_CLICK */);
      };
      /**
       * @ignore
       */
      Triangulation.prototype._removeEvent = function () {
          if (this._eventHandler) {
              this._eventHandler.removeInputAction(0 /* LEFT_DOWN */);
              this._eventHandler.removeInputAction(1 /* LEFT_UP */);
              this._eventHandler.removeInputAction(15 /* MOUSE_MOVE */);
              this._eventHandler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
              this._eventHandler.removeInputAction(2 /* LEFT_CLICK */);
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseClick = function (mousement) {
          var position = pickPositionAndObj(this.map.map.scene, mousement.position).cartesian3;
          if (position) {
              if (this._positions.length === 0) {
                  this._positions.push(position, position);
                  this._buildTriangle();
                  this._buildLabel();
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseDoubleClick = function (mousement) {
          var position = pickPositionAndObj(this.map.map.scene, mousement.position).cartesian3;
          if (position) {
              if (this._positions.length > 0) {
                  this._active = false;
                  this.fireEvent();
                  this.closeEdit();
                  this.addCloseBtn(position);
                  this._canvas.style.cursor = this._cursor;
                  this._positions = [];
                  this._removeEvent();
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype.addCloseBtn = function (position) {
          var _this = this;
          this.times += 1;
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          var self = this;
          var map = this.map.map;
          var endPnt = position;
          var closeBtn = document.createElement("div");
          closeBtn.id = "mti3d-closeBtnId" + this.times;
          this._overlayerIds.push("mti3d-closeBtnId" + this.times);
          this.map.stopEventOverlayContainer.appendChild(closeBtn);
          closeBtn.innerHTML = "x";
          closeBtn.style.cssText = "\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    z-index: 9999;\n    border: 1px solid rgb(255, 0, 0);\n    width: 16px;\n    height: 16px;\n    line-height: 11px;\n    text-align: center;\n    cursor: pointer;\n    color: rgb(255, 0, 0);\n    background-color: #f1f1f1;\n    box-shadow: 0.1px 0.1px 5px 1px rgba(0,0,0,0.3);\n    box-sizing: border-box;";
          closeBtn.onclick = (function (_entitys) {
              return function () {
                  _entitys.forEach(function (_entity) {
                      _this.map.map.entities.remove(_entity);
                  });
                  closeBtn.remove();
                  var index_ = _this._overlayerIds.indexOf(closeBtn.id);
                  _this._overlayerIds.splice(index_, 1);
              };
          })(this._entities.slice(this._entities.length - 4, this._entities.length));
          this.showCloseBtn(map, endPnt, closeBtn);
          map.scene.postRender.addEventListener(function () {
              self.showCloseBtn(map, endPnt, closeBtn);
          });
      };
      /**
       * @ignore
       */
      Triangulation.prototype.showCloseBtn = function (viewer, endPnt, closeBtn) {
          if (endPnt) {
              var wp = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, endPnt);
              if (Cesium__namespace.defined(wp)) {
                  closeBtn.style.transform = "translate3d(".concat(wp.x + 10, "px, ").concat(wp.y - 10, "px, 0)");
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseMove = function (movement) {
          if (this._positions.length > 0) {
              var endCartesian3 = pickPositionAndObj(this.map.map.scene, movement.endPosition).cartesian3;
              if (endCartesian3) {
                  this._positions.splice(1, 1, endCartesian3);
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._buildTriangle = function () {
          var _a;
          this._editingEntity = new Cesium__namespace.Entity({
              polyline: new Cesium__namespace.PolylineGraphics({
                  width: this._options.width,
                  positions: new Cesium__namespace.CallbackProperty(this._trianglePositions.bind(this)(), false),
                  material: new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.fromAlpha((_a = Cesium__namespace.Color).fromBytes.apply(_a, __spreadArray$1([], __read(this._options.color), false)), this._options.color.slice(3, 4)[0]))
              })
          });
          this.map.map.entities.add(this._editingEntity);
      };
      /**
       * @ignore
       */
      Triangulation.prototype._buildLabel = function () {
          var _a;
          var _this = this;
          var labelPoint = this._labelPoint;
          (_a = this._entities).push.apply(_a, __spreadArray$1([], __read(labelPoint.map(function (point) {
              return _this.map.map.entities.add(new Cesium__namespace.Entity({
                  // @ts-ignore
                  position: new Cesium__namespace.CallbackProperty(function () {
                      return point.position;
                  }, false),
                  label: new Cesium__namespace.LabelGraphics(__assign$1({ text: new Cesium__namespace.CallbackProperty(function () {
                          return point.text;
                      }, false) }, _this._options.label))
              }));
          })), false));
      };
      /**
       * @ignore
       */
      Triangulation.prototype.fireEvent = function () {
          var e_2, _a;
          var _b = __read(this._positions, 2), startCartesian3 = _b[0], endCartesian3 = _b[1];
          var start = Cesium__namespace.Cartographic.fromCartesian(startCartesian3);
          var end = Cesium__namespace.Cartographic.fromCartesian(endCartesian3);
          var event = {
              type: BaseEventType.MEASURE_END,
              startPoint: [Cesium__namespace.Math.toDegrees(start.longitude), Cesium__namespace.Math.toDegrees(start.latitude), start.height],
              endPoint: [Cesium__namespace.Math.toDegrees(end.longitude), Cesium__namespace.Math.toDegrees(end.latitude), end.height]
          };
          try {
              for (var _c = __values(this._labelPoint), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var point = _d.value;
                  if (point.type === "a") {
                      // @ts-ignore
                      event.height = point.distance;
                  }
                  else if (point.type === "b") {
                      // @ts-ignore
                      event.short = point.distance;
                  }
                  else {
                      // @ts-ignore
                      event.long = point.distance;
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this.dispatchEvent(event);
      };
      /**
       * @ignore
       */
      Triangulation.prototype.closeEdit = function () {
          this._entities.push(this._editingEntity);
          this._positions = [];
          this._labelPoint = [
              { type: "a", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "b", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "c", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 }
          ];
      };
      /**
       * @ignore
       */
      Triangulation.prototype._trianglePositions = function () {
          var positions = this._positions;
          var labelPoint = this._labelPoint;
          return function () {
              var e_3, _a;
              var _b = __read(positions, 2), startCartesian3 = _b[0], endCartesian3 = _b[1];
              // 起始点转化为经纬度高度位置
              var startCartographic = Cesium__namespace.Cartographic.fromCartesian(startCartesian3);
              // 终点转化为经纬度高度位置
              var endCartographic = Cesium__namespace.Cartographic.fromCartesian(endCartesian3);
              var centerCartographic;
              var bc;
              if (startCartographic.height > endCartographic.height) {
                  centerCartographic = endCartographic.clone();
                  centerCartographic.height = startCartographic.height;
                  bc = startCartographic.clone();
              }
              else {
                  centerCartographic = startCartographic.clone();
                  centerCartographic.height = endCartographic.height;
                  bc = endCartographic.clone();
              }
              var height = Math.abs(endCartographic.height - startCartographic.height);
              try {
                  for (var labelPoint_1 = __values(labelPoint), labelPoint_1_1 = labelPoint_1.next(); !labelPoint_1_1.done; labelPoint_1_1 = labelPoint_1.next()) {
                      var label = labelPoint_1_1.value;
                      if (label.type === "a") {
                          label.position = centerCartographic.clone();
                          // @ts-ignore
                          label.position.height -= height / 2;
                          // @ts-ignore
                          label.position = Cesium__namespace.Cartographic.toCartesian(label.position);
                          label.text = numberToString$1(height);
                          label.distance = height;
                      }
                      else if (label.type === "b") {
                          label.distance = getSpaceDistance(centerCartographic, bc);
                          label.text = numberToString$1(label.distance);
                          label.position = Cesium__namespace.Cartographic.toCartesian(new Cesium__namespace.Cartographic((centerCartographic.longitude + bc.longitude) / 2, (centerCartographic.latitude + bc.latitude) / 2, centerCartographic.height));
                      }
                      else {
                          label.distance = getSpaceDistance(endCartographic, startCartographic);
                          label.text = numberToString$1(label.distance);
                          label.position = centerCartographic.clone();
                          // @ts-ignore
                          label.position.height -= height / 2;
                          // @ts-ignore
                          label.position.longitude = (startCartographic.longitude + endCartographic.longitude) / 2;
                          // @ts-ignore
                          label.position.latitude = (startCartographic.latitude + endCartographic.latitude) / 2;
                          // @ts-ignore
                          label.position = Cesium__namespace.Cartographic.toCartesian(label.position);
                      }
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (labelPoint_1_1 && !labelPoint_1_1.done && (_a = labelPoint_1.return)) _a.call(labelPoint_1);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
              return [startCartesian3, endCartesian3, Cesium__namespace.Cartographic.toCartesian(centerCartographic), startCartesian3];
          };
      };
      /**
       * 激活三角测量工具
       *
       * @memberof Triangulation
       */
      Triangulation.prototype.active = function () {
          if (this._active) {
              return;
          }
          this._active = true;
          this._initEvent();
          this._cursor = this._canvas.style.cursor;
          this._canvas.style.cursor = "crosshair";
          return this;
      };
      Triangulation.prototype.deactive = function () {
          var _this = this;
          if (this._active === false) {
              return this;
          }
          this._active = false;
          this._removeEvent();
          (function (_entitys) {
              _entitys.forEach(function (_entity) {
                  _this.map.map.entities.remove(_entity);
              });
          })(this._entities.slice(this._entities.length - 3, this._entities.length));
          this._editingEntity && this.map.map.entities.remove(this._editingEntity);
          this._canvas.style.cursor = this._cursor;
          this._positions = [];
          return this;
      };
      /**
       * 清除当前测量结果
       *
       * @memberof Triangulation
       */
      Triangulation.prototype.clear = function () {
          do {
              // 从数组中删除最后一个元素并返回该元素
              var entity = this._entities.pop();
              if (entity) {
                  this.map.map.entities.remove(entity);
              }
              else {
                  break;
              }
          } while (true);
          this._editingEntity &&
              this.map.map.entities.contains(this._editingEntity) &&
              this.map.map.entities.remove(this._editingEntity);
          this._positions = [];
          this._overlayerIds.forEach(function (id) {
              document.getElementById(id) && document.getElementById(id).remove();
          });
          this._overlayerIds = [];
          return this;
      };
      /**
       * 资源销毁
       *
       * @memberof Triangulation
       * @ignore
       */
      Triangulation.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      Triangulation.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.clear();
          this._removeEvent();
          this._canvas && (this._canvas.style.cursor = this._cursor);
          this.map = void 0;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Triangulation.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Triangulation.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Triangulation;
  })(Component));
  function numberToString$1(num) {
      if (num < 1000) {
          return num.toFixed(2) + "米";
      }
      else {
          return (num / 1000).toFixed(2) + "千米";
      }
  }

  /** @class */ ((function (_super) {
      __extends$3(Snap, _super);
      function Snap(options, map) {
          var _this = _super.call(this, __assign$1({ pixelTolerance: 10 }, (options || {})), map) || this;
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _this;
      }
      Snap.prototype.active = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.deactive = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.addFeatures = function (features) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.removeFeatures = function (features) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.init = function () {
          this.initialized = true;
      };
      Snap.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
          }
          this.map = undefined;
      };
      Snap.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snap;
  })(Component));

  var CIRCLE_WHITE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAVFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////8wXzyWAAAAHHRSTlMABAgMSRgTEDYxHDsgQCQsKERMUFhkcFxUYGxoc2Qx5gAASRpJREFUeNrsnGtz2jAQReuWvps+DBQI//9/FldjX6+PVqtSZhKMrmknIaT9cM5eyebxpqWlpWX16S634ai4DUfLOjJi//vF+P30zSzmR+mvbvrVJsR9xVAfj39N4j9a02rhXqI59rhfp4JqoTXCa8wcusjfOKqDpsDryggmRv+25qiqg7Y9eA1JHIQ+5F4ZqkANWhG8eGaDXwZ/fQIR3rQzhRdLcYNfw/0djliEVgWvJNXsCTyO8YEatCZ48aD2S+wD7LEKWQtaE7xQNPox+xj8x+mITaixoJ0dILfG7ww+yHu86wIl6i1o+JEbDz8HH+yruH9AakygBjkH2obghvGv54fsgbw21AESoAnQA21DcGMFOPqEr6GPub9fxDeBdUALuqUC7cnEW84+m5/wOfYF4nF8DSiBiqD1wO3TOfQFn/QD8FeLUJBADlCC9hTitcMf0ufgR+S/hAk8gAWBA+21BNeHCz/g5we/Dvs3c+huX4WSBIEDrQb+Y/g5+0qZ/YL3PN+/FYJO8C1gEdCB9kLDKzwIZ5/0HfTiKvjfMxnuLqgACdQExR6QAm1XWPmyHh9/Ffw8eYH++b0meQ1cCdgDgwJtN/CvKdHn7As+2BvwYm/yQzcTiOBa4C4GcqBdG6hK6sY6/M7ogz24T+DdSI2FCbAgXwRhDbQK8EL8pC/8DnygJ/T66HehASSwDrAG2magSD7EH9In/Bz4z7XJigAJ6AB7YFKgbQbi4Sd+v/oBn+wL4D99/pRNwQRYQAmy+4HWAtdNP7f9Af0sewO9OpQha0HgQHk30N5thLU/GH7Qx+iDfRb81zAQIWsBioAOsAZaC2D6ve7n8JO+B5/oif1pOJS/3yMZDRwJ4ABqoLWAP/zh9Gv4ffqGfZa8gP96QnB/1gNjgeeAagAtQAUe98WknQzwpp/DT/qED/QGcVWeciL4EtAB1oDfAo/bAfHaz+H36GfZk/vm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";

  /**
   * 扩散圆组件
   */
  /** @class */ ((function (_super) {
      __extends$3(RippleCircle, _super);
      function RippleCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, color: "rgba(255,0,0,1)", height: 0, duration: 3, image: CIRCLE_WHITE_IMAGE }, options), map) || this;
      }
      Object.defineProperty(RippleCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RippleCircle.prototype.init = function () {
          this.initialized = true;
          var op = __assign$1({}, this.options);
          delete op.center;
          delete op.radius;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.RIPPLE }, op)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * 从地球移除
       * @ignore
       */
      RippleCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RippleCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RippleCircle;
  })(Component));

  /**
   * 旋转圆组件
   */
  /** @class */ ((function (_super) {
      __extends$3(RotateCircle, _super);
      function RotateCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, duration: 3, color: "rgba(255,255,255,1)", reverse: false }, options), map) || this;
      }
      Object.defineProperty(RotateCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RotateCircle.prototype.init = function () {
          this.initialized = true;
          var op = __assign$1({}, this.options);
          delete op.center;
          delete op.radius;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.ROTATE }, op)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * 从地球移除
       * @ignore
       */
      RotateCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RotateCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RotateCircle;
  })(Component));

  /**
   * 右键菜单组件
   */
  /** @class */ ((function (_super) {
      __extends$3(ContextMenu, _super);
      function ContextMenu(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(ContextMenu.prototype, "autoClose", {
          get: function () {
              return this._autoClose;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "theme", {
          get: function () {
              return this._theme;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "target", {
          /**
           * 绑定对象
           *
           * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
           */
          get: function () {
              return this._target;
          },
          enumerable: false,
          configurable: true
      });
      ContextMenu.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var _a = this.options, theme = _a.theme, autoClose = _a.autoClose, list = _a.list, target = _a.target;
          if (!defined$1(this._autoClose)) {
              this._autoClose = defined$1(autoClose) ? autoClose : true;
          }
          if (!defined$1(this._theme)) {
              this._theme = theme || "dark";
          }
          if (!defined$1(this.target)) {
              this._target = target;
          }
          var pickLayers, temPickObjects;
          this._overlay = new Overlay({
              element: createContextMenuElement({ list: list || [], theme: this._theme }, function (e) {
                  _this.dispatchEvent({
                      type: BaseEventType.CLICK,
                      item: list.find(function (val) { return String(val.id) === String(e.target.getAttribute("data-id")); }),
                      layers: pickLayers,
                      pickObjects: temPickObjects
                  });
                  if (_this._autoClose) {
                      _this.hide();
                  }
              }),
              useEvent: true
          });
          this._eventKey = this.map.on([BaseEventType.RIGHT_CLICK, BaseEventType.CLICK], function (_a) {
              var coordinate = _a.coordinate, type = _a.type, pixel = _a.pixel, layers = _a.layers, pickObjects = _a.pickObjects;
              if (!defined$1(_this.map)) {
                  return;
              }
              type !== BaseEventType.CLICK && (pickLayers = temPickObjects = void 0);
              if (type !== BaseEventType.CLICK && _this.target) {
                  if (_this.target instanceof VectorLayer && !layers.find(function (i) { return i.layer === _this.target; })) {
                      return;
                  }
                  else if (_this.target instanceof Feature &&
                      !layers.find(function (_a) {
                          var features = _a.features;
                          return features.find(function (feature) { return feature === _this.target; }) !== void 0;
                      })) {
                      return;
                  }
                  else if (typeof _this.target === "function" && !_this.target({ pixel: pixel, coordinate: coordinate, layers: layers, pickObjects: pickObjects })) {
                      return;
                  }
                  else if (Array.isArray(_this.target) &&
                      _this.target[0] instanceof VectorLayer &&
                      !layers.find(function (_a) {
                          var layer = _a.layer;
                          return _this.target.find(function (i) { return i === layer; }) !== void 0;
                      })) {
                      return;
                  }
                  else if (Array.isArray(_this.target) &&
                      _this.target[0] instanceof Feature &&
                      !layers.find(function (_a) {
                          var features = _a.features;
                          return (_this.target.find(function (i) {
                              return features.find(function (f) { return f === i; }) !== void 0;
                          }) !== void 0);
                      })) {
                      return;
                  }
              }
              setTimeout(function () {
                  if (type === BaseEventType.CLICK) {
                      _this.hide();
                      if (_this._overlay.visible) {
                          _this.dispatchEvent({ type: BaseEventType.HIDE });
                      }
                  }
                  else {
                      pickLayers = layers;
                      temPickObjects = pickObjects;
                      _this._overlay.setPosition(coordinate);
                      _this.dispatchEvent({ type: BaseEventType.SHOW, coordinate: coordinate, pixel: pixel, layers: layers, pickObjects: pickObjects });
                  }
              }, 0);
          });
      };
      ContextMenu.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addOverlay(this._overlay);
      };
      /**
       * @ignore
       */
      ContextMenu.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeOverlay(this._overlay);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      ContextMenu.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          clearContextMenuElementEvent(this._overlay.element);
          this._overlay.destroy();
          this._overlay = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 关闭菜单
       */
      ContextMenu.prototype.hide = function () {
          this._overlay.setPosition();
          return this;
      };
      /**
       * 设置右键菜单主题
       */
      ContextMenu.prototype.setTheme = function (
      /**
       * 提示框样式主题
       *
       * 可选值:'dark','light'
       */
      theme) {
          this._overlay.element.classList.replace(this._theme, theme);
          this._theme = theme;
          return this;
      };
      /**
       * 设置绑定对象
       *
       * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
       */
      ContextMenu.prototype.setTarget = function (target) {
          this._target = target;
          this.options.target = target;
          return this;
      };
      /**
       * 设置弹窗是否自动关闭
       */
      ContextMenu.prototype.setAutoClose = function (autoClose) {
          this._autoClose = autoClose;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return ContextMenu;
  })(Component));

  /**
   * 大气对象
   */
  /** @class */ ((function (_super) {
      __extends$3(Atmosphere, _super);
      function Atmosphere(options, map) {
          return _super.call(this, options, map) || this;
      }
      // 重写父类方法
      Atmosphere.prototype.init = function () {
          this.initialized = true;
          var global = this.map.map.scene.globe;
          this._defaultConfig.atmosphereHueShift = global.atmosphereHueShift;
          this._defaultConfig.lightingFadeOutDistance = global.lightingFadeOutDistance;
          this._defaultConfig.lightingFadeInDistance = global.lightingFadeInDistance;
          this.map.map.scene.globe.atmosphereHueShift = this.options.atmosphereHueShift;
          this.map.map.scene.globe.lightingFadeOutDistance = this.options.lightingFadeOutDistance;
          this.map.map.scene.globe.lightingFadeInDistance = this.options.lightingFadeInDistance;
      };
      /**
       * 清除修改、恢复修改之前的设置
       * @memberof Atmosphere
       * @instance
       */
      Atmosphere.prototype.remove = function () {
          this.map.map.scene.globe.atmosphereHueShift = this._defaultConfig.atmosphereHueShift;
          this.map.map.scene.globe.lightingFadeOutDistance = this._defaultConfig.lightingFadeOutDistance;
          this.map.map.scene.globe.lightingFadeInDistance = this._defaultConfig.lightingFadeInDistance;
          this.initialized = false;
      };
      return Atmosphere;
  })(Component));

  var textureRain$1 = "data:image/png;base64,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";
  var textureSnow$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAABTVBMVEVHcEz19fX19fX4+Pj29vb19fX39/f09PT19fX5+fn29vb29vb39/f19fX39/f29vb29vb29vb29vb29vb19fX19fX19fX19fX29vb29vbz8/P29vb39/f29vb29vb4+Pj39/f19fX39/f29vb09PT19fX09PT39/f29vb39/f19fX4+Pj29vb09PT29vb39/fz8/P19fX4+Pj4+Pj29vb29vb4+Pj29vb19fXx8fH19fX39/f29vb4+Pj19fX19fX19fX09PT29vb19fX29vb09PT19fX19fX19fX39/f09PT39/fz8/P39/f29vb39/f39/f29vb29vb29vb19fX19fX09PT29vb29vb4+Pj09PT09PTz8/P39/f29vb29vb09PT4+Pj4+Pj39/f09PT39/f29vb39/f19fX29vb5+fn09PTz8/Py8vL5+fmamtp/AAAAZ3RSTlMAhD/ncQR9AQL/ZROzB8kNnEOImCf+HqWTH/ocwRhh+7wq11nkM/37Fd3e8Vzre/b0++7EMSTSNucJTuo73w+7ObMh8AvDzGmPry6s989tR25RVnaB9cag+vPQ1tuoU4y45eH0dP1KNDOHtAAABh5JREFUWMPdV1dDKjsQDkqTprJcaYJUEZQiKhYUFVAs2OuxHRsnG3b3/7/emQQR9QD6eG8eYMhmZqd882Ug5P+3Flc/7xiCznhLtNv76uvT0x4hhY3HVS5YGnTNz6XRkG20j77hVqbNI5SsjuvJQ77nlpvNYxQCT5SFDL0NmDbBwJwZpBkqayN8L6PQ5joKHkrZTR8DZGCSUvoArjioor3yrflJRn95ITsJShV93ySAC9RhIBbK1NyCCGsbtiyEPFIq31b7GljVwIWoPQkRSK0to0LpLjmBANTTb9TRjS44wduWA4RsgIFn/wE48NhbNVDCT9cFxcVU3dv+8h2jCQiA1fd6VtC4lNw3royRc4YG5Ji1/UiShU0PMZnMVn83CPr4sfy4lMVv5ez90QrEQIco256bm3OsRY7/Xsp5n6bwd4t1V+JB/dFDJkox4ZQsnhdcfzVgPktrmgJnGD93D0FlxkNL9GCKkDPcYTJfipJ2dQmi/OBcj6mqglZoJUyOEtcqhDVDyB9QVxRF1XCljs09UmkdyDzGchizm7gp02T0xTxHqXqre60FZ05PNqb6IsFa1oOF69NnqCWkpWg4hfi1gZ+QghnRm29Q+RKFGmBIc/+MVkYneb7loB4MTEMGlrx2fy/fq/FAuxl2bcbRwC6vmM8b/kdYSu0Wnua6s8nw77VC6+mUA1UHk1xvC4JpQQA+rvfbCNqTdGMfWGAJdMTOWEqR23gCIspwfMqMyYqafktkqUCzI53FdFUEdDAY26SmqbJAkxHAccEdUDWfps3aSuL8ThNw/QENmKuJDd5SyezSfkoDPMFW0UsWoTNk382VxfYPbaS9ojcmOptVrEs4HjIR4k8laHamulqT1nPgg0Q2oa9u9uxkFGqhPPIklJ9AvCt9qpsKx0+A+S8BQ9P8HjgE6eU8ARhaAVIBfbmyJ9KMPn3B1SYcjwxDVyOOk9jzhi2RTG3dRLxrqLTC9ecQl5kOCLgWxgKl5Y0cBOGE39E6CONInh5RgFycGEKApVzwTR9iKVkDXtf83jJcQKFfv/JPycj2C7xvYv9KktL4YtvZ2XlFQGBJ59xHoXh1v7trKzSbIKcia0/F6Wx+xEok+rc1xCmMtjH09aFYxSiRFAaLMka7rM4H76eY4JbJKHGtpyv1SVVVZznrKKoqiI29ERhIqip+gCDw0ajU67l07O7mHHJl9nvDi6sDAzY4Im/pM+fnRTy76ZFuOYYpu3TqftdBaLgtNcthGqrU+O3ac41NDXeya/QF3hXD8hkTqA9APYNvdMcBmyc+kJJlhCGyd/4LDE5Bi15gR57he2+g9+0HCMILRpv3x38WnGghgk1vQZ7Lxz8BEe8C3wM+5pcKvqoGUm7MAx5D4bKpOlK2hTcOWih8gPI8hq0A/ZKFPCQyFTYs6m0Y0w7xx1plRFqWo/z4OVhIdLrgTeJzfvUfXSuq795TaAilHTgtcxd4OSKta03SlEKgw4AT2r/Vnn6HVq90AMVKdtCDoUEgCMZGWmk3vF59yKJOUdrDwMJDLY/+tBwPkgOEwJBu8XDkccfb7UraSnveB7hyGvgnJ8iU7pevOZ6eh3uyeKnc+Su67o56sKpQmmdn61KVfjhvRkBPB2zUQCK6BbaZWPyRvh4cSFsPeSKYNrANYBi3/0C/BATEdCTs4/18R1YQOg7Piv972qPGcdBbsuLMd91gCtCXWxFVDUkZS3TD1ONWDQfd4lKiiKv5VCWUCdpbnPu2nma6z6nj2fYxzoCuqJhG9AIX4rpJuLvNu1VHB+3sdj6xic1ZjQ8wzm4xWAtIP9osNzDY0W6lQUFtIzNO9/rWTqBrCJlZ3+3VYVHE0IH2AaQWCCK53KcApni8SoKtMJzv+0Zku9g38VjF3r6ECeW5HYMJyqpGg4jHb0xKFuTGcIq16sDbK0uZb8GwrVJ60C8IZEIm6zgLON7Au4jkaCYbPoWPDL0XjnQVLwnXKR8xRRFCslbDuQIQXSz3+dcF4SoS/9vQeE9Z2TiD80jpTpvNnvQ2MP8C1ziOAa60kn39/PQop8bivQ3EkwlFzJSrV/qvLHTkOTH3yaF+fMv73/qv/S8xKzSNcc760gAAAABJRU5ErkJggg==";
  var textureFire$1 = "data:image/png;base64,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";
  var textureWater2$1 = "data:image/png;base64,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";
  var textureAir$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAADoCAMAAACtpkq7AAAAz1BMVEVHcEz///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8Z+KahAAAARHRSTlMAFxIiCgUHAQIbHiAMDgRCED0tphRhGO9IftF5wLG4i081Vm8lZySbaoaDKfsVMkyPyvXfxejaOaB1k11TWnKs5JfWfYFa5EcAACAASURBVHjarFhrc5vKEgwPIcGCeFygUOmDACEsiwL8jSh6VPn//6nbPYtsJzfnHvvkbKyH42XZnu7pmeXbt8+O5dtYrVbr9WLhOLYdREFkmmYgw7cdZ4GxXi3/+mpcu1rJGnyt5P9+M3c1j+U85X9n/enQu3m710IA+X7U92aep6YZRUEQ+bZNUNzyb+GsHtfK+0rArWTV39yLYfuAa/XvYlp+DJsw5DiO7wNElPYuh9GDKtMPfP+BafnT5T9fbC/W5HK9lqm/EvUAhEkA9Y5Lg1r+a4CWH7YEhmxKLjVMw/Wapm0b5Xlur/UHTI99vi3wDohgbBmOHtz0PBdv7/eS2zgi5LWMv1Lpn1Aky84pBIpSsuO1yZBgNJ6b9z0EaEaST+sPmHT+yNC7RDjAMNbwZ2Cr5U9DZnOezkxepDP0PbP+HBIBSbxkR8ADSzCU8lSTxHFVDUNnuZ7R94alItGes3jPatki6NB6JaLIDMwIi2hMC07WSfXOpfMY9vxytKDflv0jRLMKFjMcAorMvu/zRnXDEBdhPA1d17k5eDLTiMpb2M68TzE3oUfolSUQkKCHSClUe1bfavEBkNzNdojXBmr+aEIfifUnmB6ZupDoYunggSfP3SSppiouyiKekqZxPdfIqTx/juuslZUmyZbdcYkenhLlhmn20Zx7nLgW+3tI23nM1h/+w0wls37nkl8V3SN/NCAz7XM3d92mG6opDsOwDKdpUFaH1AIibNJ2PozFevG+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";
  var textureAir2$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI8AAADoCAMAAADhTEdDAAAA8FBMVEX///////////////////////////9HcEz///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9Cw+iKAAAAT3RSTlMBGgkgBhAUAAIEFxIiCwMcQQ40Hj1LLWAIKEemOm8xwLgqi4NOk+9orLGGfnmfdVQM/GXpRI+XmyTS21pXxV3X3/Zya8s3Ufp8z+S9o7XIl/40EQAAIABJREFUeNqsWG2TmswWFEaIwsAAM6BwkSp2TZnaeJWyyPNQpeWH3cLy//+i22cG3WziZk1y2WhW15emT5/ucxh9+uEYjUafbjxnjslkOpnQfxO6TfRzN147Mcfou+PTncfoIzyvUOiYTqf6fqKRAdXNl9/AM/oLPN+/+fXTDZq5jbvpmG7j6c8UXdCE+CEO3yIa/T6eH8/nOzgEZGrrY2yOKZ4bXou773gMw5BejP9+IOrP8Yxe6ZkOB0Gw7biJY7tpmiDQmN5WZXTBArBh+Nd4Rj8d+PwLmjl+AtvxY99pYucV0MQIaWBRwxkP76EHbxH9Jj9voVArGeZxvnNiB0D82PXj2MfN1s9NSdoXNIaUqanmFdY0nPw9nuv50ucSOdBN48S+63iej/s4JkRGRZOh4fDNA5WDwC7iD+8l6AM84aBMfPbcDgKg8TzXws0FQQBoamaafxDaGD1ocI7HV1hh+P/BcwFEtQoCVMv1LAt4PNfjvhZ1oL+bLOlKBqCPqQvfAtLa/hDQr/WjAZGih85yauIGcABKUMmaGJjsZm6abzynYzo3ZGpO7fmFreldgN7v98HUrvzMbQjHAhiiRwiZcctxHN9zdPPj7w2BCQLc2Xjc2PpRcPWr6Wvz/xEeg8gIGnjw0bFrccARlmd1XZYktWX5PprfaXx8J3FBBdSqxx1+CYA0bi6A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";

  /**
   * 火焰组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Fire, _super);
      function Fire(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, type: "explosion" }, options), map) || this;
      }
      Fire.prototype.init = function () {
          this.initialized = true;
          this.map.map.clock.shouldAnimate = true;
          switch (this.options.type) {
              case "burning":
                  this._addBurning(this.options);
                  break;
              case "explosion":
                  this._addExplosion(this.options);
                  break;
          }
      };
      Fire.prototype._addExplosion = function (options) {
          var coordinates = options.coordinates, particleSize = options.particleSize;
          var _explosionOptions = {
              emitterModelMatrix: this._computeEmitterModelMatrix(),
              speed: 2.0,
              lifetime: 2,
              emitter: new Cesium__namespace.SphereEmitter(2),
              startScale: 5,
              endScale: 0,
              image: textureFire$1,
              emissionRate: 30,
              bursts: [new Cesium__namespace.ParticleBurst({ time: 10.0, minimum: 60, maximum: 80 })]
          };
          merge$2(_explosionOptions, options);
          merge$2(_explosionOptions, {
              modelMatrix: this._computeModelMatrix(coordinates),
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize)
          });
          this._particleSystem = new Cesium__namespace.ParticleSystem(_explosionOptions);
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      Fire.prototype._addBurning = function (options) {
          var coordinates = options.coordinates, particleSize = options.particleSize;
          var _burningOptions = {
              emitterModelMatrix: this._computeEmitterModelMatrix(),
              speed: 1.0,
              lifetime: 16,
              emitter: new Cesium__namespace.ConeEmitter(Cesium__namespace.Math.toRadians(30.0)),
              startScale: 3.5,
              endScale: 5.0,
              emissionRate: 30.0,
              image: textureFire$1,
              sizeInMeters: true
          };
          merge$2(_burningOptions, options);
          merge$2(_burningOptions, {
              modelMatrix: this._computeModelMatrix(coordinates),
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize)
          });
          this._particleSystem = new Cesium__namespace.ParticleSystem(_burningOptions);
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      Fire.prototype._computeModelMatrix = function (coordinates) {
          var _a;
          var position = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          return Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position);
      };
      Fire.prototype._computeEmitterModelMatrix = function () {
          var hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(0, 0, 0);
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(2.5, 4, 1);
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr);
          var result = Cesium__namespace.Matrix4.fromTranslationRotationScale(trs);
          if (result) {
              return result;
          }
      };
      /**
       * 删除火焰
       */
      Fire.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Fire;
  })(Component));

  /**
   * @class Fountain
   */
  /** @class */ ((function (_super) {
      __extends$3(Fountain, _super);
      function Fountain(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, type: "fountain", hpr: {} }, options), map) || this;
      }
      Fountain.prototype.init = function () {
          this.initialized = true;
          this.map.map.clock.shouldAnimate = true;
          switch (this.options.type) {
              case "watergun":
                  this.fountain1(this.options);
                  break;
              case "fountain":
                  this.fountain2(this.options);
                  break;
          }
      };
      Fountain.prototype.updateCallbackGravity = function () {
          var updateCallbackFun = function (particle, dt) {
              var gravityVector = Cesium__namespace.Cartesian3.normalize(particle.position, new Cesium__namespace.Cartesian3()) || new Cesium__namespace.Cartesian3();
              var heading = -3;
              Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, heading * dt, gravityVector);
              particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
          };
          return updateCallbackFun;
      };
      Fountain.prototype.fountain1 = function (options) {
          var _a;
          var _b = options; _b.id; var type = _b.type, originCoordinates = _b.originCoordinates, hpr = _b.hpr;
          var particleSize = 6;
          var radius = 0.15;
          var speed = 9.5;
          var entity = this.map.map.entities.add({
              id: this.id,
              position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(originCoordinates), false)),
              point: {
                  show: false,
                  pixelSize: 10,
                  color: Cesium__namespace.Color.RED
              }
          });
          this.particle1 = new Cesium__namespace.ParticleSystem({
              startScale: 0.05,
              endScale: 5.0,
              lifetime: 1.5,
              emissionRate: 100,
              speed: speed,
              image: textureAir$1,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              emitter: new Cesium__namespace.CircleEmitter(radius * 1.5),
              modelMatrix: this.computeModelMatrix1(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix1(hpr),
              updateCallback: this.updateCallbackGravity()
          });
          this.particle2 = new Cesium__namespace.ParticleSystem({
              startScale: 0.6,
              endScale: 3.0,
              lifetime: 1.5,
              emissionRate: 100,
              speed: speed,
              image: textureWater2$1,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              emitter: new Cesium__namespace.CircleEmitter(radius),
              modelMatrix: this.computeModelMatrix1(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix1(hpr),
              updateCallback: this.updateCallbackGravity()
          });
          this.particle1["type"] = type;
          this.particle2["type"] = type;
          this.map.map.scene.primitives.add(this.particle1);
          this.map.map.scene.primitives.add(this.particle2);
      };
      Fountain.prototype.computeEmitterModelMatrix1 = function (headingPitchRoll) {
          var hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(0, 0, 0, new Cesium__namespace.HeadingPitchRoll());
          if (Cesium__namespace.defined(headingPitchRoll)) {
              var heading = headingPitchRoll.heading, pitch = headingPitchRoll.pitch, roll = headingPitchRoll.roll;
              hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(Cesium__namespace.defaultValue(heading, 130), Cesium__namespace.defaultValue(pitch, 30), Cesium__namespace.defaultValue(roll, 0), new Cesium__namespace.HeadingPitchRoll());
          }
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(0, 0, 0, new Cesium__namespace.Cartesian3());
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr, new Cesium__namespace.Quaternion());
          return Cesium__namespace.Matrix4.fromTranslationRotationScale(trs, new Cesium__namespace.Matrix4());
      };
      Fountain.prototype.computeModelMatrix1 = function (entity, time) {
          var modelMatrix = null;
          var position = entity.position.getValue(time);
          if (!Cesium__namespace.defined(position)) {
              return undefined;
          }
          var orientation = entity.orientation.getValue(time);
          if (!Cesium__namespace.defined(orientation)) {
              modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position, undefined, new Cesium__namespace.Matrix4());
          }
          else {
              var matrix3 = Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3());
              // 由旋转和转换生成四阶矩阵
              modelMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(matrix3, position, new Cesium__namespace.Matrix4());
          }
          return modelMatrix;
      };
      Fountain.prototype.computeEmitterModelMatrix = function (targetCoordinates) {
          var _a;
          var hpr = (_a = Cesium__namespace.HeadingPitchRoll).fromDegrees.apply(_a, __spreadArray$1([], __read(targetCoordinates), false));
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(0, 0, 1, new Cesium__namespace.Cartesian3());
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr, new Cesium__namespace.Quaternion());
          return Cesium__namespace.Matrix4.fromTranslationRotationScale(trs, new Cesium__namespace.Matrix4());
      };
      Fountain.prototype.computeModelMatrix = function (entity, time) {
          var modelMatrix = null;
          var position = entity.position.getValue(time);
          if (!Cesium__namespace.defined(position)) {
              return undefined;
          }
          var orientation = entity.orientation.getValue(time);
          if (!Cesium__namespace.defined(orientation)) {
              modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position, undefined, new Cesium__namespace.Matrix4());
          }
          else {
              var matrix3 = Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3());
              // 由旋转和转换生成四阶矩阵
              modelMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(matrix3, position, new Cesium__namespace.Matrix4());
          }
          return modelMatrix;
      };
      Fountain.prototype.fountain2 = function (options) {
          var _a;
          var _b = options; _b.id; var type = _b.type, targetCoordinates = _b.targetCoordinates, particleSize = _b.particleSize;
          var originCoordinates = [targetCoordinates[0], targetCoordinates[1], 0];
          var entity = this.map.map.entities.add({
              id: this.id,
              position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(targetCoordinates), false)),
              point: {
                  pixelSize: 10,
                  color: Cesium__namespace.Color.TRANSPARENT,
                  show: false
              }
          });
          this.particle1 = new Cesium__namespace.ParticleSystem({
              startScale: 20.0,
              endScale: 5.0,
              startColor: Cesium__namespace.Color.fromCssColorString("rgba(85, 193, 255, 0.5)"),
              endColor: Cesium__namespace.Color.fromCssColorString("#fff"),
              image: textureAir2$1,
              imageSize: new Cesium__namespace.Cartesian2(particleSize / 2, particleSize),
              lifetime: 16,
              emissionRate: 60.0,
              speed: 60,
              emitter: new Cesium__namespace.SphereEmitter(1),
              modelMatrix: this.computeModelMatrix(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix(originCoordinates),
              updateCallback: function (particle, dt) {
                  var position = particle.position;
                  var gravityVector = Cesium__namespace.Cartesian3.normalize(position, new Cesium__namespace.Cartesian3());
                  Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, -90 * dt, gravityVector);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
              }
          });
          this.particle2 = new Cesium__namespace.ParticleSystem({
              startScale: 0.01,
              endScale: 2.0,
              image: textureRain$1,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              minimumImageSize: new Cesium__namespace.Cartesian2(1.0, 1.0),
              maximumImageSize: new Cesium__namespace.Cartesian2(5.0, 5.0),
              minimumMass: 1,
              maximumMass: 3,
              sizeInMeters: true,
              lifetime: 16,
              emissionRate: 60.2,
              speed: 60.2,
              emitter: new Cesium__namespace.SphereEmitter(1),
              modelMatrix: this.computeModelMatrix(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix(targetCoordinates),
              updateCallback: function (particle, dt) {
                  var gravity = -90; // 重力参数（值为负表示向外弯曲，值为正数的时候表示向内弯曲）
                  var position = particle.position;
                  var gravityVector = Cesium__namespace.Cartesian3.normalize(position, new Cesium__namespace.Cartesian3());
                  Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, gravity * dt, gravityVector);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
              }
          });
          this.particle1["type"] = type;
          this.particle2["type"] = type;
          this.map.map.scene.primitives.add(this.particle1);
          this.map.map.scene.primitives.add(this.particle2);
      };
      Fountain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this.map = undefined;
          this.initialized = false;
          this.map.map.scene.primitives.remove(this.particle1);
          this.map.map.scene.primitives.remove(this.particle2);
          this.map.map.entities.removeById(this.id);
          if (destroy) {
              if (!this.particle1.isDestroyed()) {
                  this.particle1.destroy();
              }
              if (!this.particle2.isDestroyed()) {
                  this.particle2.destroy();
              }
          }
      };
      return Fountain;
  })(Component));

  /**
   * 光照对象
   */
  /** @class */ ((function (_super) {
      __extends$3(Light, _super);
      function Light(options, map) {
          return _super.call(this, __assign$1({ speed: 1000 }, options), map) || this;
      }
      /**
       * @ignore
       */
      Light.prototype.init = function () {
          this.initialized = true;
          var speed = this.options.speed;
          this.map.map.scene.globe.enableLighting = true;
          this._defaultMultiplier = this.map.map.clock.multiplier;
          this.map.map.clock.multiplier = speed;
      };
      /**
       * 关闭
       */
      Light.prototype.remove = function () {
          this.map.map.scene.globe.enableLighting = false;
          this.map.map.clock.multiplier = this._defaultMultiplier;
          this.initialized = false;
      };
      return Light;
  })(Component));

  /**
   * 雨
   */
  /** @class */ ((function (_super) {
      __extends$3(Rain, _super);
      function Rain(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, areaRadius: 200 }, options), map) || this;
      }
      Rain.prototype.init = function () {
          var _a;
          var _this = this;
          this.initialized = true;
          var _b = this.options, coordinates = _b.coordinates, particleSize = _b.particleSize, areaRadius = _b.areaRadius, color = _b.color;
          this.map.map.scene.globe.depthTestAgainstTerrain = true;
          var center = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          var disLength = 100000;
          var dimensions = new Cesium__namespace.Cartesian3(areaRadius * 2, areaRadius * 2, areaRadius * 2);
          this._particleSystem = new Cesium__namespace.ParticleSystem({
              modelMatrix: Cesium__namespace.Matrix4.fromTranslation(center),
              minimumSpeed: 0,
              maximumSpeed: 1,
              lifetime: 15.0,
              emitter: new Cesium__namespace.BoxEmitter(dimensions),
              startScale: 0.5,
              endScale: 1.0,
              image: textureRain$1,
              emissionRate: 100.0,
              startColor: Cesium__namespace.Color.WHITE.withAlpha(0.1),
              endColor: Cesium__namespace.Color.WHITE.withAlpha(1.0),
              color: (color && Cesium__namespace.Color.fromCssColorString(color)) || Cesium__namespace.Color.WHITE,
              minimumImageSize: new Cesium__namespace.Cartesian2(particleSize * 0.5, particleSize * 0.5),
              maximumImageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              updateCallback: function (particle, dt) {
                  _this._snowGravityScratch = new Cesium__namespace.Cartesian3();
                  _this._snowGravityScratch = Cesium__namespace.Cartesian3.normalize(particle.position, _this._snowGravityScratch);
                  Cesium__namespace.Cartesian3.multiplyByScalar(_this._snowGravityScratch, Cesium__namespace.Math.randomBetween(-30.0, -300.0), _this._snowGravityScratch);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, _this._snowGravityScratch, particle.velocity);
                  var distance = Cesium__namespace.Cartesian3.distance(center, particle.position);
                  if (distance > disLength) {
                      particle.endColor.alpha = 0.0;
                  }
                  else {
                      particle.endColor.alpha = _this._particleSystem.endColor.alpha / (distance / disLength + 0.1);
                  }
              }
          });
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      /**
       * 删除
       */
      Rain.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
                  this._snowGravityScratch = null;
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Rain;
  })(Component));

  /**
   * 雪花
   */
  /** @class */ ((function (_super) {
      __extends$3(Snow, _super);
      function Snow(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, areaRadius: 200 }, options), map) || this;
      }
      /**
       * @ignore
       */
      Snow.prototype.init = function () {
          var _a;
          var _this = this;
          this.initialized = true;
          var _b = this.options, coordinates = _b.coordinates, particleSize = _b.particleSize, areaRadius = _b.areaRadius;
          this.map.map.scene.globe.depthTestAgainstTerrain = true;
          var center = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          var disLength = 100000;
          this._particleSystem = new Cesium__namespace.ParticleSystem({
              modelMatrix: Cesium__namespace.Matrix4.fromTranslation(center),
              minimumSpeed: 0,
              maximumSpeed: 1,
              lifetime: 15.0,
              emitter: new Cesium__namespace.SphereEmitter(areaRadius),
              startScale: 0.5,
              endScale: 1.0,
              image: textureSnow$1,
              emissionRate: 300.0,
              startColor: Cesium__namespace.Color.WHITE.withAlpha(0.0),
              endColor: Cesium__namespace.Color.WHITE.withAlpha(1.0),
              minimumImageSize: new Cesium__namespace.Cartesian2(particleSize * 0.5, particleSize * 0.5),
              maximumImageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              updateCallback: function (particle, dt) {
                  _this._snowGravityScratch = new Cesium__namespace.Cartesian3();
                  _this._snowGravityScratch = Cesium__namespace.Cartesian3.normalize(particle.position, _this._snowGravityScratch);
                  Cesium__namespace.Cartesian3.multiplyByScalar(_this._snowGravityScratch, Cesium__namespace.Math.randomBetween(-30.0, -300.0), _this._snowGravityScratch);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, _this._snowGravityScratch, particle.velocity);
                  var distance = Cesium__namespace.Cartesian3.distance(center, particle.position);
                  if (distance > disLength) {
                      particle.endColor.alpha = 0.0;
                  }
                  else {
                      particle.endColor.alpha = _this._particleSystem.endColor.alpha / (distance / disLength + 0.1);
                  }
              }
          });
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      /**
       * 删除
       */
      Snow.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Snow;
  })(Component));

  /**
   * 移动任务队列组件
   *
   * 可触发要素对象的`move`事件,获取当前移动进度和位置
   */
  /** @class */ ((function (_super) {
      __extends$3(TranslationQueue, _super);
      function TranslationQueue(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(TranslationQueue.prototype, "jobScheduler", {
          get: function () {
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      TranslationQueue.prototype.init = function () {
          this.initialized = true;
          this._taskIdStore = {};
          this._jobScheduler = new JobScheduler();
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.stop();
          this.clearTask();
          this._jobScheduler = void 0;
          this._taskIdStore = void 0;
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 添加移动任务
       */
      TranslationQueue.prototype.addTask = function (taskOptions) {
          var _this = this;
          if (this.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          // 移动目标、移动位置、持续时间
          var target = taskOptions.target, coordinates = taskOptions.coordinates, duration = taskOptions.duration;
          var jobSchedulerId = target.id + "-scheduler";
          var _a = getPointFeatureModelParams(target, this.map), clamped = _a.clamped, hasModel = _a.hasModel;
          //  创建基础工作
          var job = new BaseJob({
              tasks: [
                  new FeatureTranslationTask({
                      map: this.map,
                      target: target,
                      duration: duration,
                      coordinates: coordinates,
                      callback: hasModel
                          ? function (_a) {
                              var feature = _a.feature, startPosition = _a.startPosition, endPosition = _a.endPosition;
                              if (clamped) {
                                  coordinatesClampToTerrain([endPosition], _this.map).then(function (res) {
                                      updateFeatureOrientation(feature, degreesToCartesian3(startPosition, _this.map), degreesToCartesian3(res[0], _this.map), _this.map.map.scene.globe.ellipsoid);
                                  });
                              }
                              else {
                                  updateFeatureOrientation(feature, degreesToCartesian3(startPosition, _this.map), degreesToCartesian3(endPosition, _this.map), _this.map.map.scene.globe.ellipsoid);
                              }
                          }
                          : void 0
                  }),
                  new FeatureTranslationOverEventTask({
                      callback: function () {
                          _this._taskIdStore[job.id] = void 0;
                      }
                  })
              ]
          });
          this._jobScheduler.add(job, jobSchedulerId);
          this._taskIdStore[job.id] = jobSchedulerId;
          return job.id;
      };
      /**
       * 移除移动任务
       */
      TranslationQueue.prototype.removeTask = function (taskId) {
          this._jobScheduler.remove(taskId, this._taskIdStore[taskId]);
          return this;
      };
      /**
       * 清空队列
       */
      TranslationQueue.prototype.clearTask = function () {
          this.start();
          this._jobScheduler.clear();
          return this;
      };
      /**
       * 开始
       */
      TranslationQueue.prototype.start = function () {
          this._jobScheduler.resume();
          return this;
      };
      /**
       * 停止
       */
      TranslationQueue.prototype.stop = function () {
          this._jobScheduler.pause();
          return this;
      };
      return TranslationQueue;
  })(Component));

  var markdownItSanitizer = function sanitizer_plugin(md, options) {

    var linkify = md.linkify,
        escapeHtml = md.utils.escapeHtml,
        // <a href="url" title="(optional)"></a>
        patternLinkOpen = '<a\\s([^<>]*href="[^"<>]*"[^<>]*)\\s?>',
        regexpLinkOpen = RegExp(patternLinkOpen, 'i'),
        // <img src="url" alt=""(optional) title=""(optional)>
        patternImage = '<img\\s([^<>]*src="[^"<>]*"[^<>]*)\\s?\\/?>',
        regexpImage = RegExp(patternImage, 'i'),
        regexpImageProtocols = /^(?:https?:)?\/\//i,
        regexpLinkProtocols = /^(?:https?:\/\/|ftp:\/\/|\/\/|mailto:|xmpp:)/i;

    options = options ? options : {};
    var removeUnknown = (typeof options.removeUnknown !== 'undefined') ? options.removeUnknown : false;
    var removeUnbalanced = (typeof options.removeUnbalanced !== 'undefined') ? options.removeUnbalanced : false;
    var imageClass = (typeof options.imageClass !== 'undefined') ? options.imageClass : '';
    var runBalancer = false;
    var j;


    var allowedTags = [ 'a', 'b', 'blockquote', 'code', 'em', 'h1', 'h2', 'h3', 'h4', 'h5',
                       'h6', 'li', 'ol', 'p', 'pre', 's', 'sub', 'sup', 'strong', 'ul' ];
    var openTagCount = new Array(allowedTags.length);
    var removeTag = new Array(allowedTags.length);
    for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }
    for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }

    function getUrl(link) {
      var match = linkify.match(link);
      if (match && match.length === 1 && match[0].index === 0 && match[0].lastIndex === link.length) {
        return match[0].url;
      }
      return null;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    //          REPLACE UNKNOWN TAGS
    /////////////////////////////////////////////////////////////////////////////////////////////////

    function replaceUnknownTags(str) {
      /*
       * it starts with '<' and maybe ends with '>',
       * maybe has a '<' on the right
       * it doesnt have '<' or '>' in between
       * -> it's a tag!
       */
      str = str.replace(/<[^<>]*>?/gi, function (tag) {
        var match, attrs, url, alt, title, tagnameIndex;

        // '<->', '<- ' and '<3 ' look nice, they are harmless
        if (/(^<->|^<-\s|^<3\s)/.test(tag)) { return tag; }

        // images
        match = tag.match(regexpImage);
        if (match) {
          attrs = match[1];
          url   = getUrl(attrs.match(/src="([^"<>]*)"/i)[1]);
          alt   = attrs.match(/alt="([^"<>]*)"/i);
          alt   = (alt && typeof alt[1] !== 'undefined') ? alt[1] : '';
          title = attrs.match(/title="([^"<>]*)"/i);
          title = (title && typeof title[1] !== 'undefined') ? title[1] : '';

          // only http and https are allowed for images
          if (url && regexpImageProtocols.test(url)) {
            if (imageClass !== '') {
              return '<img src="' + url + '" alt="' + alt + '" title="' + title + '" class="' + imageClass + '">';
            }
            return '<img src="' + url + '" alt="' + alt + '" title="' + title + '">';
          }
        }

        // links
        tagnameIndex = allowedTags.indexOf('a');
        match = tag.match(regexpLinkOpen);
        if (match) {
          attrs = match[1];
          url   = getUrl(attrs.match(/href="([^"<>]*)"/i)[1]);
          title = attrs.match(/title="([^"<>]*)"/i);
          title = (title && typeof title[1] !== 'undefined') ? title[1] : '';
          // only http, https, ftp, mailto and xmpp are allowed for links
          if (url && regexpLinkProtocols.test(url)) {
            runBalancer = true;
            openTagCount[tagnameIndex] += 1;
            return '<a href="' + url + '" title="' + title + '" target="_blank">';
          }
        }
        match = /<\/a>/i.test(tag);
        if (match) {
          runBalancer = true;
          openTagCount[tagnameIndex] -= 1;
          if (openTagCount[tagnameIndex] < 0) {
            removeTag[tagnameIndex] = true;
          }
          return '</a>';
        }

        // standalone tags
        match = tag.match(/<(br|hr)\s?\/?>/i);
        if (match) {
          return '<' + match[1].toLowerCase() + '>';
        }

        // whitelisted tags
        match = tag.match(/<(\/?)(b|blockquote|code|em|h[1-6]|li|ol(?: start="\d+")?|p|pre|s|sub|sup|strong|ul)>/i);
        if (match && !/<\/ol start="\d+"/i.test(tag)) {
          runBalancer = true;
          tagnameIndex = allowedTags.indexOf(match[2].toLowerCase().split(' ')[0]);
          if (match[1] === '/') {
            openTagCount[tagnameIndex] -= 1;
          } else {
            openTagCount[tagnameIndex] += 1;
          }
          if (openTagCount[tagnameIndex] < 0) {
            removeTag[tagnameIndex] = true;
          }
          return '<' + match[1] + match[2].toLowerCase() + '>';
        }

        // other tags we don't recognize
        if (removeUnknown === true) {
          return '';
        }
        return escapeHtml(tag);
      });

      return str;
    }


    function sanitizeInlineAndBlock(state) {
      var i, blkIdx, inlineTokens;
      // reset counts
      for (j = 0; j < allowedTags.length; j++) { openTagCount[j] = 0; }
      for (j = 0; j < allowedTags.length; j++) { removeTag[j] = false; }
      runBalancer = false;


      for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {
        if (state.tokens[blkIdx].type === 'html_block') {
          state.tokens[blkIdx].content = replaceUnknownTags(state.tokens[blkIdx].content);
        }
        if (state.tokens[blkIdx].type !== 'inline') {
          continue;
        }

        inlineTokens = state.tokens[blkIdx].children;
        for (i = 0; i < inlineTokens.length; i++) {
          if (inlineTokens[i].type === 'html_inline') {
            inlineTokens[i].content = replaceUnknownTags(inlineTokens[i].content);
          }
        }
      }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////
    //          REPLACE UNBALANCED TAGS
    /////////////////////////////////////////////////////////////////////////////////////////////////

    function balance(state) {
      if (runBalancer === false) { return; }
      var blkIdx, inlineTokens;

      function replaceUnbalancedTag(str, tagname) {
        var openingRegexp, closingRegexp;
        if (tagname === 'a') {
          openingRegexp = RegExp('<a href="[^"<>]*" title="[^"<>]*" target="_blank">', 'g');
        } else if (tagname === 'ol') {
          openingRegexp = /<ol(?: start="\d+")?>/g;
        } else {
          openingRegexp = RegExp('<' + tagname + '>', 'g');
        }
        closingRegexp = RegExp('</' + tagname + '>', 'g');
        if (removeUnbalanced === true) {
          str = str.replace(openingRegexp, '');
          str = str.replace(closingRegexp, '');
        } else {
          str = str.replace(openingRegexp, function (m) { return escapeHtml(m); });
          str = str.replace(closingRegexp, function (m) { return escapeHtml(m); });
        }
        return str;
      }

      function replaceAllUnbalancedTags(str) {
        var i;
        for (i = 0; i < allowedTags.length; i++) {
          if (removeTag[i] === true) {
            str = replaceUnbalancedTag(str, allowedTags[i]);
          }
        }
        return str;
      }

      for (j = 0; j < allowedTags.length; j++) {
        if (openTagCount[j] !== 0) {
          removeTag[j] = true;
        }
      }

      // replace unbalanced tags
      for (blkIdx = 0; blkIdx < state.tokens.length; blkIdx++) {
        if (state.tokens[blkIdx].type === 'html_block') {
          state.tokens[blkIdx].content = replaceAllUnbalancedTags(state.tokens[blkIdx].content);
          continue;
        }
        if (state.tokens[blkIdx].type !== 'inline') {
          continue;
        }
        inlineTokens = state.tokens[blkIdx].children;
        for (j = 0; j < inlineTokens.length; j++) {
          if (inlineTokens[j].type === 'html_inline') {
            inlineTokens[j].content = replaceAllUnbalancedTags(inlineTokens[j].content);
          }
        }
      }
    }

    md.core.ruler.after('linkify', 'sanitize_inline', sanitizeInlineAndBlock);
    md.core.ruler.after('sanitize_inline', 'sanitize_balance', balance);
  };

  var utils$1 = {};

  var Aacute = "Á";
  var aacute = "á";
  var Abreve = "Ă";
  var abreve = "ă";
  var ac = "∾";
  var acd = "∿";
  var acE = "∾̳";
  var Acirc = "Â";
  var acirc = "â";
  var acute = "´";
  var Acy = "А";
  var acy = "а";
  var AElig = "Æ";
  var aelig = "æ";
  var af = "⁡";
  var Afr = "𝔄";
  var afr = "𝔞";
  var Agrave = "À";
  var agrave = "à";
  var alefsym = "ℵ";
  var aleph = "ℵ";
  var Alpha = "Α";
  var alpha = "α";
  var Amacr = "Ā";
  var amacr = "ā";
  var amalg = "⨿";
  var amp = "&";
  var AMP = "&";
  var andand = "⩕";
  var And = "⩓";
  var and = "∧";
  var andd = "⩜";
  var andslope = "⩘";
  var andv = "⩚";
  var ang = "∠";
  var ange = "⦤";
  var angle$1 = "∠";
  var angmsdaa = "⦨";
  var angmsdab = "⦩";
  var angmsdac = "⦪";
  var angmsdad = "⦫";
  var angmsdae = "⦬";
  var angmsdaf = "⦭";
  var angmsdag = "⦮";
  var angmsdah = "⦯";
  var angmsd = "∡";
  var angrt = "∟";
  var angrtvb = "⊾";
  var angrtvbd = "⦝";
  var angsph = "∢";
  var angst = "Å";
  var angzarr = "⍼";
  var Aogon = "Ą";
  var aogon = "ą";
  var Aopf = "𝔸";
  var aopf = "𝕒";
  var apacir = "⩯";
  var ap = "≈";
  var apE = "⩰";
  var ape = "≊";
  var apid = "≋";
  var apos = "'";
  var ApplyFunction = "⁡";
  var approx = "≈";
  var approxeq = "≊";
  var Aring = "Å";
  var aring = "å";
  var Ascr = "𝒜";
  var ascr = "𝒶";
  var Assign = "≔";
  var ast = "*";
  var asymp = "≈";
  var asympeq = "≍";
  var Atilde = "Ã";
  var atilde = "ã";
  var Auml = "Ä";
  var auml = "ä";
  var awconint = "∳";
  var awint = "⨑";
  var backcong = "≌";
  var backepsilon = "϶";
  var backprime = "‵";
  var backsim = "∽";
  var backsimeq = "⋍";
  var Backslash = "∖";
  var Barv = "⫧";
  var barvee = "⊽";
  var barwed = "⌅";
  var Barwed = "⌆";
  var barwedge = "⌅";
  var bbrk = "⎵";
  var bbrktbrk = "⎶";
  var bcong = "≌";
  var Bcy = "Б";
  var bcy = "б";
  var bdquo = "„";
  var becaus = "∵";
  var because = "∵";
  var Because = "∵";
  var bemptyv = "⦰";
  var bepsi = "϶";
  var bernou = "ℬ";
  var Bernoullis = "ℬ";
  var Beta = "Β";
  var beta = "β";
  var beth = "ℶ";
  var between = "≬";
  var Bfr = "𝔅";
  var bfr = "𝔟";
  var bigcap = "⋂";
  var bigcirc = "◯";
  var bigcup = "⋃";
  var bigodot = "⨀";
  var bigoplus = "⨁";
  var bigotimes = "⨂";
  var bigsqcup = "⨆";
  var bigstar = "★";
  var bigtriangledown = "▽";
  var bigtriangleup = "△";
  var biguplus = "⨄";
  var bigvee = "⋁";
  var bigwedge = "⋀";
  var bkarow = "⤍";
  var blacklozenge = "⧫";
  var blacksquare = "▪";
  var blacktriangle = "▴";
  var blacktriangledown = "▾";
  var blacktriangleleft = "◂";
  var blacktriangleright = "▸";
  var blank = "␣";
  var blk12 = "▒";
  var blk14 = "░";
  var blk34 = "▓";
  var block$1 = "█";
  var bne = "=⃥";
  var bnequiv = "≡⃥";
  var bNot = "⫭";
  var bnot = "⌐";
  var Bopf = "𝔹";
  var bopf = "𝕓";
  var bot = "⊥";
  var bottom = "⊥";
  var bowtie = "⋈";
  var boxbox = "⧉";
  var boxdl = "┐";
  var boxdL = "╕";
  var boxDl = "╖";
  var boxDL = "╗";
  var boxdr = "┌";
  var boxdR = "╒";
  var boxDr = "╓";
  var boxDR = "╔";
  var boxh = "─";
  var boxH = "═";
  var boxhd = "┬";
  var boxHd = "╤";
  var boxhD = "╥";
  var boxHD = "╦";
  var boxhu = "┴";
  var boxHu = "╧";
  var boxhU = "╨";
  var boxHU = "╩";
  var boxminus = "⊟";
  var boxplus = "⊞";
  var boxtimes = "⊠";
  var boxul = "┘";
  var boxuL = "╛";
  var boxUl = "╜";
  var boxUL = "╝";
  var boxur = "└";
  var boxuR = "╘";
  var boxUr = "╙";
  var boxUR = "╚";
  var boxv = "│";
  var boxV = "║";
  var boxvh = "┼";
  var boxvH = "╪";
  var boxVh = "╫";
  var boxVH = "╬";
  var boxvl = "┤";
  var boxvL = "╡";
  var boxVl = "╢";
  var boxVL = "╣";
  var boxvr = "├";
  var boxvR = "╞";
  var boxVr = "╟";
  var boxVR = "╠";
  var bprime = "‵";
  var breve = "˘";
  var Breve = "˘";
  var brvbar = "¦";
  var bscr = "𝒷";
  var Bscr = "ℬ";
  var bsemi = "⁏";
  var bsim = "∽";
  var bsime = "⋍";
  var bsolb = "⧅";
  var bsol = "\\";
  var bsolhsub = "⟈";
  var bull = "•";
  var bullet = "•";
  var bump = "≎";
  var bumpE = "⪮";
  var bumpe = "≏";
  var Bumpeq = "≎";
  var bumpeq = "≏";
  var Cacute = "Ć";
  var cacute = "ć";
  var capand = "⩄";
  var capbrcup = "⩉";
  var capcap = "⩋";
  var cap = "∩";
  var Cap = "⋒";
  var capcup = "⩇";
  var capdot = "⩀";
  var CapitalDifferentialD = "ⅅ";
  var caps = "∩︀";
  var caret = "⁁";
  var caron = "ˇ";
  var Cayleys = "ℭ";
  var ccaps = "⩍";
  var Ccaron = "Č";
  var ccaron = "č";
  var Ccedil = "Ç";
  var ccedil = "ç";
  var Ccirc = "Ĉ";
  var ccirc = "ĉ";
  var Cconint = "∰";
  var ccups = "⩌";
  var ccupssm = "⩐";
  var Cdot = "Ċ";
  var cdot = "ċ";
  var cedil = "¸";
  var Cedilla = "¸";
  var cemptyv = "⦲";
  var cent = "¢";
  var centerdot = "·";
  var CenterDot = "·";
  var cfr = "𝔠";
  var Cfr = "ℭ";
  var CHcy = "Ч";
  var chcy = "ч";
  var check$1 = "✓";
  var checkmark = "✓";
  var Chi = "Χ";
  var chi = "χ";
  var circ = "ˆ";
  var circeq = "≗";
  var circlearrowleft = "↺";
  var circlearrowright = "↻";
  var circledast = "⊛";
  var circledcirc = "⊚";
  var circleddash = "⊝";
  var CircleDot = "⊙";
  var circledR = "®";
  var circledS = "Ⓢ";
  var CircleMinus = "⊖";
  var CirclePlus = "⊕";
  var CircleTimes = "⊗";
  var cir = "○";
  var cirE = "⧃";
  var cire = "≗";
  var cirfnint = "⨐";
  var cirmid = "⫯";
  var cirscir = "⧂";
  var ClockwiseContourIntegral = "∲";
  var CloseCurlyDoubleQuote = "”";
  var CloseCurlyQuote = "’";
  var clubs = "♣";
  var clubsuit = "♣";
  var colon = ":";
  var Colon = "∷";
  var Colone = "⩴";
  var colone = "≔";
  var coloneq = "≔";
  var comma = ",";
  var commat = "@";
  var comp = "∁";
  var compfn = "∘";
  var complement = "∁";
  var complexes = "ℂ";
  var cong = "≅";
  var congdot = "⩭";
  var Congruent = "≡";
  var conint = "∮";
  var Conint = "∯";
  var ContourIntegral = "∮";
  var copf = "𝕔";
  var Copf = "ℂ";
  var coprod = "∐";
  var Coproduct = "∐";
  var copy = "©";
  var COPY = "©";
  var copysr = "℗";
  var CounterClockwiseContourIntegral = "∳";
  var crarr = "↵";
  var cross = "✗";
  var Cross = "⨯";
  var Cscr = "𝒞";
  var cscr = "𝒸";
  var csub = "⫏";
  var csube = "⫑";
  var csup = "⫐";
  var csupe = "⫒";
  var ctdot = "⋯";
  var cudarrl = "⤸";
  var cudarrr = "⤵";
  var cuepr = "⋞";
  var cuesc = "⋟";
  var cularr = "↶";
  var cularrp = "⤽";
  var cupbrcap = "⩈";
  var cupcap = "⩆";
  var CupCap = "≍";
  var cup = "∪";
  var Cup = "⋓";
  var cupcup = "⩊";
  var cupdot = "⊍";
  var cupor = "⩅";
  var cups = "∪︀";
  var curarr = "↷";
  var curarrm = "⤼";
  var curlyeqprec = "⋞";
  var curlyeqsucc = "⋟";
  var curlyvee = "⋎";
  var curlywedge = "⋏";
  var curren = "¤";
  var curvearrowleft = "↶";
  var curvearrowright = "↷";
  var cuvee = "⋎";
  var cuwed = "⋏";
  var cwconint = "∲";
  var cwint = "∱";
  var cylcty = "⌭";
  var dagger = "†";
  var Dagger = "‡";
  var daleth = "ℸ";
  var darr = "↓";
  var Darr = "↡";
  var dArr = "⇓";
  var dash = "‐";
  var Dashv = "⫤";
  var dashv = "⊣";
  var dbkarow = "⤏";
  var dblac = "˝";
  var Dcaron = "Ď";
  var dcaron = "ď";
  var Dcy = "Д";
  var dcy = "д";
  var ddagger = "‡";
  var ddarr = "⇊";
  var DD = "ⅅ";
  var dd = "ⅆ";
  var DDotrahd = "⤑";
  var ddotseq = "⩷";
  var deg$1 = "°";
  var Del = "∇";
  var Delta = "Δ";
  var delta$1 = "δ";
  var demptyv = "⦱";
  var dfisht = "⥿";
  var Dfr = "𝔇";
  var dfr = "𝔡";
  var dHar = "⥥";
  var dharl = "⇃";
  var dharr = "⇂";
  var DiacriticalAcute = "´";
  var DiacriticalDot = "˙";
  var DiacriticalDoubleAcute = "˝";
  var DiacriticalGrave = "`";
  var DiacriticalTilde = "˜";
  var diam = "⋄";
  var diamond = "⋄";
  var Diamond = "⋄";
  var diamondsuit = "♦";
  var diams = "♦";
  var die = "¨";
  var DifferentialD = "ⅆ";
  var digamma = "ϝ";
  var disin = "⋲";
  var div = "÷";
  var divide = "÷";
  var divideontimes = "⋇";
  var divonx = "⋇";
  var DJcy = "Ђ";
  var djcy = "ђ";
  var dlcorn = "⌞";
  var dlcrop = "⌍";
  var dollar = "$";
  var Dopf = "𝔻";
  var dopf = "𝕕";
  var Dot = "¨";
  var dot = "˙";
  var DotDot = "⃜";
  var doteq = "≐";
  var doteqdot = "≑";
  var DotEqual = "≐";
  var dotminus = "∸";
  var dotplus = "∔";
  var dotsquare = "⊡";
  var doublebarwedge = "⌆";
  var DoubleContourIntegral = "∯";
  var DoubleDot = "¨";
  var DoubleDownArrow = "⇓";
  var DoubleLeftArrow = "⇐";
  var DoubleLeftRightArrow = "⇔";
  var DoubleLeftTee = "⫤";
  var DoubleLongLeftArrow = "⟸";
  var DoubleLongLeftRightArrow = "⟺";
  var DoubleLongRightArrow = "⟹";
  var DoubleRightArrow = "⇒";
  var DoubleRightTee = "⊨";
  var DoubleUpArrow = "⇑";
  var DoubleUpDownArrow = "⇕";
  var DoubleVerticalBar = "∥";
  var DownArrowBar = "⤓";
  var downarrow = "↓";
  var DownArrow = "↓";
  var Downarrow = "⇓";
  var DownArrowUpArrow = "⇵";
  var DownBreve = "̑";
  var downdownarrows = "⇊";
  var downharpoonleft = "⇃";
  var downharpoonright = "⇂";
  var DownLeftRightVector = "⥐";
  var DownLeftTeeVector = "⥞";
  var DownLeftVectorBar = "⥖";
  var DownLeftVector = "↽";
  var DownRightTeeVector = "⥟";
  var DownRightVectorBar = "⥗";
  var DownRightVector = "⇁";
  var DownTeeArrow = "↧";
  var DownTee = "⊤";
  var drbkarow = "⤐";
  var drcorn = "⌟";
  var drcrop = "⌌";
  var Dscr = "𝒟";
  var dscr = "𝒹";
  var DScy = "Ѕ";
  var dscy = "ѕ";
  var dsol = "⧶";
  var Dstrok = "Đ";
  var dstrok = "đ";
  var dtdot = "⋱";
  var dtri = "▿";
  var dtrif = "▾";
  var duarr = "⇵";
  var duhar = "⥯";
  var dwangle = "⦦";
  var DZcy = "Џ";
  var dzcy = "џ";
  var dzigrarr = "⟿";
  var Eacute = "É";
  var eacute = "é";
  var easter = "⩮";
  var Ecaron = "Ě";
  var ecaron = "ě";
  var Ecirc = "Ê";
  var ecirc = "ê";
  var ecir = "≖";
  var ecolon = "≕";
  var Ecy = "Э";
  var ecy = "э";
  var eDDot = "⩷";
  var Edot = "Ė";
  var edot = "ė";
  var eDot = "≑";
  var ee = "ⅇ";
  var efDot = "≒";
  var Efr = "𝔈";
  var efr = "𝔢";
  var eg = "⪚";
  var Egrave = "È";
  var egrave = "è";
  var egs = "⪖";
  var egsdot = "⪘";
  var el = "⪙";
  var Element$2 = "∈";
  var elinters = "⏧";
  var ell = "ℓ";
  var els = "⪕";
  var elsdot = "⪗";
  var Emacr = "Ē";
  var emacr = "ē";
  var empty$1 = "∅";
  var emptyset = "∅";
  var EmptySmallSquare = "◻";
  var emptyv = "∅";
  var EmptyVerySmallSquare = "▫";
  var emsp13 = " ";
  var emsp14 = " ";
  var emsp = " ";
  var ENG = "Ŋ";
  var eng = "ŋ";
  var ensp = " ";
  var Eogon = "Ę";
  var eogon = "ę";
  var Eopf = "𝔼";
  var eopf = "𝕖";
  var epar = "⋕";
  var eparsl = "⧣";
  var eplus = "⩱";
  var epsi = "ε";
  var Epsilon = "Ε";
  var epsilon = "ε";
  var epsiv = "ϵ";
  var eqcirc = "≖";
  var eqcolon = "≕";
  var eqsim = "≂";
  var eqslantgtr = "⪖";
  var eqslantless = "⪕";
  var Equal = "⩵";
  var equals = "=";
  var EqualTilde = "≂";
  var equest = "≟";
  var Equilibrium = "⇌";
  var equiv = "≡";
  var equivDD = "⩸";
  var eqvparsl = "⧥";
  var erarr = "⥱";
  var erDot = "≓";
  var escr = "ℯ";
  var Escr = "ℰ";
  var esdot = "≐";
  var Esim = "⩳";
  var esim = "≂";
  var Eta = "Η";
  var eta = "η";
  var ETH = "Ð";
  var eth = "ð";
  var Euml = "Ë";
  var euml = "ë";
  var euro = "€";
  var excl = "!";
  var exist = "∃";
  var Exists = "∃";
  var expectation = "ℰ";
  var exponentiale = "ⅇ";
  var ExponentialE = "ⅇ";
  var fallingdotseq = "≒";
  var Fcy = "Ф";
  var fcy = "ф";
  var female = "♀";
  var ffilig = "ﬃ";
  var fflig = "ﬀ";
  var ffllig = "ﬄ";
  var Ffr = "𝔉";
  var ffr = "𝔣";
  var filig = "ﬁ";
  var FilledSmallSquare = "◼";
  var FilledVerySmallSquare = "▪";
  var fjlig = "fj";
  var flat = "♭";
  var fllig = "ﬂ";
  var fltns = "▱";
  var fnof = "ƒ";
  var Fopf = "𝔽";
  var fopf = "𝕗";
  var forall = "∀";
  var ForAll = "∀";
  var fork = "⋔";
  var forkv = "⫙";
  var Fouriertrf = "ℱ";
  var fpartint = "⨍";
  var frac12 = "½";
  var frac13 = "⅓";
  var frac14 = "¼";
  var frac15 = "⅕";
  var frac16 = "⅙";
  var frac18 = "⅛";
  var frac23 = "⅔";
  var frac25 = "⅖";
  var frac34 = "¾";
  var frac35 = "⅗";
  var frac38 = "⅜";
  var frac45 = "⅘";
  var frac56 = "⅚";
  var frac58 = "⅝";
  var frac78 = "⅞";
  var frasl = "⁄";
  var frown = "⌢";
  var fscr = "𝒻";
  var Fscr = "ℱ";
  var gacute = "ǵ";
  var Gamma = "Γ";
  var gamma = "γ";
  var Gammad = "Ϝ";
  var gammad = "ϝ";
  var gap = "⪆";
  var Gbreve = "Ğ";
  var gbreve = "ğ";
  var Gcedil = "Ģ";
  var Gcirc = "Ĝ";
  var gcirc = "ĝ";
  var Gcy = "Г";
  var gcy = "г";
  var Gdot = "Ġ";
  var gdot = "ġ";
  var ge = "≥";
  var gE = "≧";
  var gEl = "⪌";
  var gel = "⋛";
  var geq = "≥";
  var geqq = "≧";
  var geqslant = "⩾";
  var gescc = "⪩";
  var ges = "⩾";
  var gesdot = "⪀";
  var gesdoto = "⪂";
  var gesdotol = "⪄";
  var gesl = "⋛︀";
  var gesles = "⪔";
  var Gfr = "𝔊";
  var gfr = "𝔤";
  var gg = "≫";
  var Gg = "⋙";
  var ggg = "⋙";
  var gimel = "ℷ";
  var GJcy = "Ѓ";
  var gjcy = "ѓ";
  var gla = "⪥";
  var gl = "≷";
  var glE = "⪒";
  var glj = "⪤";
  var gnap = "⪊";
  var gnapprox = "⪊";
  var gne = "⪈";
  var gnE = "≩";
  var gneq = "⪈";
  var gneqq = "≩";
  var gnsim = "⋧";
  var Gopf = "𝔾";
  var gopf = "𝕘";
  var grave = "`";
  var GreaterEqual = "≥";
  var GreaterEqualLess = "⋛";
  var GreaterFullEqual = "≧";
  var GreaterGreater = "⪢";
  var GreaterLess = "≷";
  var GreaterSlantEqual = "⩾";
  var GreaterTilde = "≳";
  var Gscr = "𝒢";
  var gscr = "ℊ";
  var gsim = "≳";
  var gsime = "⪎";
  var gsiml = "⪐";
  var gtcc = "⪧";
  var gtcir = "⩺";
  var gt = ">";
  var GT$1 = ">";
  var Gt = "≫";
  var gtdot = "⋗";
  var gtlPar = "⦕";
  var gtquest = "⩼";
  var gtrapprox = "⪆";
  var gtrarr = "⥸";
  var gtrdot = "⋗";
  var gtreqless = "⋛";
  var gtreqqless = "⪌";
  var gtrless = "≷";
  var gtrsim = "≳";
  var gvertneqq = "≩︀";
  var gvnE = "≩︀";
  var Hacek = "ˇ";
  var hairsp = " ";
  var half = "½";
  var hamilt = "ℋ";
  var HARDcy = "Ъ";
  var hardcy = "ъ";
  var harrcir = "⥈";
  var harr = "↔";
  var hArr = "⇔";
  var harrw = "↭";
  var Hat = "^";
  var hbar = "ℏ";
  var Hcirc = "Ĥ";
  var hcirc = "ĥ";
  var hearts = "♥";
  var heartsuit = "♥";
  var hellip = "…";
  var hercon = "⊹";
  var hfr = "𝔥";
  var Hfr = "ℌ";
  var HilbertSpace = "ℋ";
  var hksearow = "⤥";
  var hkswarow = "⤦";
  var hoarr = "⇿";
  var homtht = "∻";
  var hookleftarrow = "↩";
  var hookrightarrow = "↪";
  var hopf = "𝕙";
  var Hopf = "ℍ";
  var horbar = "―";
  var HorizontalLine = "─";
  var hscr = "𝒽";
  var Hscr = "ℋ";
  var hslash = "ℏ";
  var Hstrok = "Ħ";
  var hstrok = "ħ";
  var HumpDownHump = "≎";
  var HumpEqual = "≏";
  var hybull = "⁃";
  var hyphen = "‐";
  var Iacute = "Í";
  var iacute = "í";
  var ic = "⁣";
  var Icirc = "Î";
  var icirc = "î";
  var Icy = "И";
  var icy = "и";
  var Idot = "İ";
  var IEcy = "Е";
  var iecy = "е";
  var iexcl = "¡";
  var iff = "⇔";
  var ifr = "𝔦";
  var Ifr = "ℑ";
  var Igrave = "Ì";
  var igrave = "ì";
  var ii = "ⅈ";
  var iiiint = "⨌";
  var iiint = "∭";
  var iinfin = "⧜";
  var iiota = "℩";
  var IJlig = "Ĳ";
  var ijlig = "ĳ";
  var Imacr = "Ī";
  var imacr = "ī";
  var image$2 = "ℑ";
  var ImaginaryI = "ⅈ";
  var imagline = "ℐ";
  var imagpart = "ℑ";
  var imath = "ı";
  var Im = "ℑ";
  var imof = "⊷";
  var imped = "Ƶ";
  var Implies = "⇒";
  var incare = "℅";
  var infin = "∞";
  var infintie = "⧝";
  var inodot = "ı";
  var intcal = "⊺";
  var int = "∫";
  var Int = "∬";
  var integers = "ℤ";
  var Integral = "∫";
  var intercal = "⊺";
  var Intersection = "⋂";
  var intlarhk = "⨗";
  var intprod = "⨼";
  var InvisibleComma = "⁣";
  var InvisibleTimes = "⁢";
  var IOcy = "Ё";
  var iocy = "ё";
  var Iogon = "Į";
  var iogon = "į";
  var Iopf = "𝕀";
  var iopf = "𝕚";
  var Iota = "Ι";
  var iota = "ι";
  var iprod = "⨼";
  var iquest = "¿";
  var iscr = "𝒾";
  var Iscr = "ℐ";
  var isin = "∈";
  var isindot = "⋵";
  var isinE = "⋹";
  var isins = "⋴";
  var isinsv = "⋳";
  var isinv = "∈";
  var it = "⁢";
  var Itilde = "Ĩ";
  var itilde = "ĩ";
  var Iukcy = "І";
  var iukcy = "і";
  var Iuml = "Ï";
  var iuml = "ï";
  var Jcirc = "Ĵ";
  var jcirc = "ĵ";
  var Jcy = "Й";
  var jcy = "й";
  var Jfr = "𝔍";
  var jfr = "𝔧";
  var jmath = "ȷ";
  var Jopf = "𝕁";
  var jopf = "𝕛";
  var Jscr = "𝒥";
  var jscr = "𝒿";
  var Jsercy = "Ј";
  var jsercy = "ј";
  var Jukcy = "Є";
  var jukcy = "є";
  var Kappa = "Κ";
  var kappa = "κ";
  var kappav = "ϰ";
  var Kcedil = "Ķ";
  var kcedil = "ķ";
  var Kcy = "К";
  var kcy = "к";
  var Kfr = "𝔎";
  var kfr = "𝔨";
  var kgreen = "ĸ";
  var KHcy = "Х";
  var khcy = "х";
  var KJcy = "Ќ";
  var kjcy = "ќ";
  var Kopf = "𝕂";
  var kopf = "𝕜";
  var Kscr = "𝒦";
  var kscr = "𝓀";
  var lAarr = "⇚";
  var Lacute = "Ĺ";
  var lacute = "ĺ";
  var laemptyv = "⦴";
  var lagran = "ℒ";
  var Lambda = "Λ";
  var lambda = "λ";
  var lang = "⟨";
  var Lang = "⟪";
  var langd = "⦑";
  var langle = "⟨";
  var lap = "⪅";
  var Laplacetrf = "ℒ";
  var laquo = "«";
  var larrb = "⇤";
  var larrbfs = "⤟";
  var larr = "←";
  var Larr = "↞";
  var lArr = "⇐";
  var larrfs = "⤝";
  var larrhk = "↩";
  var larrlp = "↫";
  var larrpl = "⤹";
  var larrsim = "⥳";
  var larrtl = "↢";
  var latail = "⤙";
  var lAtail = "⤛";
  var lat = "⪫";
  var late = "⪭";
  var lates = "⪭︀";
  var lbarr = "⤌";
  var lBarr = "⤎";
  var lbbrk = "❲";
  var lbrace = "{";
  var lbrack = "[";
  var lbrke = "⦋";
  var lbrksld = "⦏";
  var lbrkslu = "⦍";
  var Lcaron = "Ľ";
  var lcaron = "ľ";
  var Lcedil = "Ļ";
  var lcedil = "ļ";
  var lceil = "⌈";
  var lcub = "{";
  var Lcy = "Л";
  var lcy = "л";
  var ldca = "⤶";
  var ldquo = "“";
  var ldquor = "„";
  var ldrdhar = "⥧";
  var ldrushar = "⥋";
  var ldsh = "↲";
  var le = "≤";
  var lE = "≦";
  var LeftAngleBracket = "⟨";
  var LeftArrowBar = "⇤";
  var leftarrow = "←";
  var LeftArrow = "←";
  var Leftarrow = "⇐";
  var LeftArrowRightArrow = "⇆";
  var leftarrowtail = "↢";
  var LeftCeiling = "⌈";
  var LeftDoubleBracket = "⟦";
  var LeftDownTeeVector = "⥡";
  var LeftDownVectorBar = "⥙";
  var LeftDownVector = "⇃";
  var LeftFloor = "⌊";
  var leftharpoondown = "↽";
  var leftharpoonup = "↼";
  var leftleftarrows = "⇇";
  var leftrightarrow = "↔";
  var LeftRightArrow = "↔";
  var Leftrightarrow = "⇔";
  var leftrightarrows = "⇆";
  var leftrightharpoons = "⇋";
  var leftrightsquigarrow = "↭";
  var LeftRightVector = "⥎";
  var LeftTeeArrow = "↤";
  var LeftTee = "⊣";
  var LeftTeeVector = "⥚";
  var leftthreetimes = "⋋";
  var LeftTriangleBar = "⧏";
  var LeftTriangle = "⊲";
  var LeftTriangleEqual = "⊴";
  var LeftUpDownVector = "⥑";
  var LeftUpTeeVector = "⥠";
  var LeftUpVectorBar = "⥘";
  var LeftUpVector = "↿";
  var LeftVectorBar = "⥒";
  var LeftVector = "↼";
  var lEg = "⪋";
  var leg = "⋚";
  var leq = "≤";
  var leqq = "≦";
  var leqslant = "⩽";
  var lescc = "⪨";
  var les = "⩽";
  var lesdot = "⩿";
  var lesdoto = "⪁";
  var lesdotor = "⪃";
  var lesg = "⋚︀";
  var lesges = "⪓";
  var lessapprox = "⪅";
  var lessdot = "⋖";
  var lesseqgtr = "⋚";
  var lesseqqgtr = "⪋";
  var LessEqualGreater = "⋚";
  var LessFullEqual = "≦";
  var LessGreater = "≶";
  var lessgtr = "≶";
  var LessLess = "⪡";
  var lesssim = "≲";
  var LessSlantEqual = "⩽";
  var LessTilde = "≲";
  var lfisht = "⥼";
  var lfloor = "⌊";
  var Lfr = "𝔏";
  var lfr = "𝔩";
  var lg = "≶";
  var lgE = "⪑";
  var lHar = "⥢";
  var lhard = "↽";
  var lharu = "↼";
  var lharul = "⥪";
  var lhblk = "▄";
  var LJcy = "Љ";
  var ljcy = "љ";
  var llarr = "⇇";
  var ll = "≪";
  var Ll = "⋘";
  var llcorner = "⌞";
  var Lleftarrow = "⇚";
  var llhard = "⥫";
  var lltri = "◺";
  var Lmidot = "Ŀ";
  var lmidot = "ŀ";
  var lmoustache = "⎰";
  var lmoust = "⎰";
  var lnap = "⪉";
  var lnapprox = "⪉";
  var lne = "⪇";
  var lnE = "≨";
  var lneq = "⪇";
  var lneqq = "≨";
  var lnsim = "⋦";
  var loang = "⟬";
  var loarr = "⇽";
  var lobrk = "⟦";
  var longleftarrow = "⟵";
  var LongLeftArrow = "⟵";
  var Longleftarrow = "⟸";
  var longleftrightarrow = "⟷";
  var LongLeftRightArrow = "⟷";
  var Longleftrightarrow = "⟺";
  var longmapsto = "⟼";
  var longrightarrow = "⟶";
  var LongRightArrow = "⟶";
  var Longrightarrow = "⟹";
  var looparrowleft = "↫";
  var looparrowright = "↬";
  var lopar = "⦅";
  var Lopf = "𝕃";
  var lopf = "𝕝";
  var loplus = "⨭";
  var lotimes = "⨴";
  var lowast = "∗";
  var lowbar = "_";
  var LowerLeftArrow = "↙";
  var LowerRightArrow = "↘";
  var loz = "◊";
  var lozenge = "◊";
  var lozf = "⧫";
  var lpar = "(";
  var lparlt = "⦓";
  var lrarr = "⇆";
  var lrcorner = "⌟";
  var lrhar = "⇋";
  var lrhard = "⥭";
  var lrm = "‎";
  var lrtri = "⊿";
  var lsaquo = "‹";
  var lscr = "𝓁";
  var Lscr = "ℒ";
  var lsh = "↰";
  var Lsh = "↰";
  var lsim = "≲";
  var lsime = "⪍";
  var lsimg = "⪏";
  var lsqb = "[";
  var lsquo = "‘";
  var lsquor = "‚";
  var Lstrok = "Ł";
  var lstrok = "ł";
  var ltcc = "⪦";
  var ltcir = "⩹";
  var lt = "<";
  var LT$1 = "<";
  var Lt = "≪";
  var ltdot = "⋖";
  var lthree = "⋋";
  var ltimes = "⋉";
  var ltlarr = "⥶";
  var ltquest = "⩻";
  var ltri = "◃";
  var ltrie = "⊴";
  var ltrif = "◂";
  var ltrPar = "⦖";
  var lurdshar = "⥊";
  var luruhar = "⥦";
  var lvertneqq = "≨︀";
  var lvnE = "≨︀";
  var macr = "¯";
  var male = "♂";
  var malt = "✠";
  var maltese = "✠";
  var map$1 = "↦";
  var mapsto = "↦";
  var mapstodown = "↧";
  var mapstoleft = "↤";
  var mapstoup = "↥";
  var marker = "▮";
  var mcomma = "⨩";
  var Mcy = "М";
  var mcy = "м";
  var mdash = "—";
  var mDDot = "∺";
  var measuredangle = "∡";
  var MediumSpace = " ";
  var Mellintrf = "ℳ";
  var Mfr = "𝔐";
  var mfr = "𝔪";
  var mho = "℧";
  var micro = "µ";
  var midast = "*";
  var midcir = "⫰";
  var mid = "∣";
  var middot = "·";
  var minusb = "⊟";
  var minus = "−";
  var minusd = "∸";
  var minusdu = "⨪";
  var MinusPlus = "∓";
  var mlcp = "⫛";
  var mldr = "…";
  var mnplus = "∓";
  var models = "⊧";
  var Mopf = "𝕄";
  var mopf = "𝕞";
  var mp = "∓";
  var mscr = "𝓂";
  var Mscr = "ℳ";
  var mstpos = "∾";
  var Mu = "Μ";
  var mu = "μ";
  var multimap = "⊸";
  var mumap = "⊸";
  var nabla = "∇";
  var Nacute = "Ń";
  var nacute = "ń";
  var nang = "∠⃒";
  var nap = "≉";
  var napE = "⩰̸";
  var napid = "≋̸";
  var napos = "ŉ";
  var napprox = "≉";
  var natural = "♮";
  var naturals = "ℕ";
  var natur = "♮";
  var nbsp = " ";
  var nbump = "≎̸";
  var nbumpe = "≏̸";
  var ncap = "⩃";
  var Ncaron = "Ň";
  var ncaron = "ň";
  var Ncedil = "Ņ";
  var ncedil = "ņ";
  var ncong = "≇";
  var ncongdot = "⩭̸";
  var ncup = "⩂";
  var Ncy = "Н";
  var ncy = "н";
  var ndash = "–";
  var nearhk = "⤤";
  var nearr = "↗";
  var neArr = "⇗";
  var nearrow = "↗";
  var ne = "≠";
  var nedot = "≐̸";
  var NegativeMediumSpace = "​";
  var NegativeThickSpace = "​";
  var NegativeThinSpace = "​";
  var NegativeVeryThinSpace = "​";
  var nequiv = "≢";
  var nesear = "⤨";
  var nesim = "≂̸";
  var NestedGreaterGreater = "≫";
  var NestedLessLess = "≪";
  var NewLine = "\n";
  var nexist = "∄";
  var nexists = "∄";
  var Nfr = "𝔑";
  var nfr = "𝔫";
  var ngE = "≧̸";
  var nge = "≱";
  var ngeq = "≱";
  var ngeqq = "≧̸";
  var ngeqslant = "⩾̸";
  var nges = "⩾̸";
  var nGg = "⋙̸";
  var ngsim = "≵";
  var nGt = "≫⃒";
  var ngt = "≯";
  var ngtr = "≯";
  var nGtv = "≫̸";
  var nharr = "↮";
  var nhArr = "⇎";
  var nhpar = "⫲";
  var ni = "∋";
  var nis = "⋼";
  var nisd = "⋺";
  var niv = "∋";
  var NJcy = "Њ";
  var njcy = "њ";
  var nlarr = "↚";
  var nlArr = "⇍";
  var nldr = "‥";
  var nlE = "≦̸";
  var nle = "≰";
  var nleftarrow = "↚";
  var nLeftarrow = "⇍";
  var nleftrightarrow = "↮";
  var nLeftrightarrow = "⇎";
  var nleq = "≰";
  var nleqq = "≦̸";
  var nleqslant = "⩽̸";
  var nles = "⩽̸";
  var nless = "≮";
  var nLl = "⋘̸";
  var nlsim = "≴";
  var nLt = "≪⃒";
  var nlt = "≮";
  var nltri = "⋪";
  var nltrie = "⋬";
  var nLtv = "≪̸";
  var nmid = "∤";
  var NoBreak = "⁠";
  var NonBreakingSpace = " ";
  var nopf = "𝕟";
  var Nopf = "ℕ";
  var Not = "⫬";
  var not = "¬";
  var NotCongruent = "≢";
  var NotCupCap = "≭";
  var NotDoubleVerticalBar = "∦";
  var NotElement = "∉";
  var NotEqual = "≠";
  var NotEqualTilde = "≂̸";
  var NotExists = "∄";
  var NotGreater = "≯";
  var NotGreaterEqual = "≱";
  var NotGreaterFullEqual = "≧̸";
  var NotGreaterGreater = "≫̸";
  var NotGreaterLess = "≹";
  var NotGreaterSlantEqual = "⩾̸";
  var NotGreaterTilde = "≵";
  var NotHumpDownHump = "≎̸";
  var NotHumpEqual = "≏̸";
  var notin = "∉";
  var notindot = "⋵̸";
  var notinE = "⋹̸";
  var notinva = "∉";
  var notinvb = "⋷";
  var notinvc = "⋶";
  var NotLeftTriangleBar = "⧏̸";
  var NotLeftTriangle = "⋪";
  var NotLeftTriangleEqual = "⋬";
  var NotLess = "≮";
  var NotLessEqual = "≰";
  var NotLessGreater = "≸";
  var NotLessLess = "≪̸";
  var NotLessSlantEqual = "⩽̸";
  var NotLessTilde = "≴";
  var NotNestedGreaterGreater = "⪢̸";
  var NotNestedLessLess = "⪡̸";
  var notni = "∌";
  var notniva = "∌";
  var notnivb = "⋾";
  var notnivc = "⋽";
  var NotPrecedes = "⊀";
  var NotPrecedesEqual = "⪯̸";
  var NotPrecedesSlantEqual = "⋠";
  var NotReverseElement = "∌";
  var NotRightTriangleBar = "⧐̸";
  var NotRightTriangle = "⋫";
  var NotRightTriangleEqual = "⋭";
  var NotSquareSubset = "⊏̸";
  var NotSquareSubsetEqual = "⋢";
  var NotSquareSuperset = "⊐̸";
  var NotSquareSupersetEqual = "⋣";
  var NotSubset = "⊂⃒";
  var NotSubsetEqual = "⊈";
  var NotSucceeds = "⊁";
  var NotSucceedsEqual = "⪰̸";
  var NotSucceedsSlantEqual = "⋡";
  var NotSucceedsTilde = "≿̸";
  var NotSuperset = "⊃⃒";
  var NotSupersetEqual = "⊉";
  var NotTilde = "≁";
  var NotTildeEqual = "≄";
  var NotTildeFullEqual = "≇";
  var NotTildeTilde = "≉";
  var NotVerticalBar = "∤";
  var nparallel = "∦";
  var npar = "∦";
  var nparsl = "⫽⃥";
  var npart = "∂̸";
  var npolint = "⨔";
  var npr = "⊀";
  var nprcue = "⋠";
  var nprec = "⊀";
  var npreceq = "⪯̸";
  var npre = "⪯̸";
  var nrarrc = "⤳̸";
  var nrarr = "↛";
  var nrArr = "⇏";
  var nrarrw = "↝̸";
  var nrightarrow = "↛";
  var nRightarrow = "⇏";
  var nrtri = "⋫";
  var nrtrie = "⋭";
  var nsc = "⊁";
  var nsccue = "⋡";
  var nsce = "⪰̸";
  var Nscr = "𝒩";
  var nscr = "𝓃";
  var nshortmid = "∤";
  var nshortparallel = "∦";
  var nsim = "≁";
  var nsime = "≄";
  var nsimeq = "≄";
  var nsmid = "∤";
  var nspar = "∦";
  var nsqsube = "⋢";
  var nsqsupe = "⋣";
  var nsub = "⊄";
  var nsubE = "⫅̸";
  var nsube = "⊈";
  var nsubset = "⊂⃒";
  var nsubseteq = "⊈";
  var nsubseteqq = "⫅̸";
  var nsucc = "⊁";
  var nsucceq = "⪰̸";
  var nsup = "⊅";
  var nsupE = "⫆̸";
  var nsupe = "⊉";
  var nsupset = "⊃⃒";
  var nsupseteq = "⊉";
  var nsupseteqq = "⫆̸";
  var ntgl = "≹";
  var Ntilde = "Ñ";
  var ntilde = "ñ";
  var ntlg = "≸";
  var ntriangleleft = "⋪";
  var ntrianglelefteq = "⋬";
  var ntriangleright = "⋫";
  var ntrianglerighteq = "⋭";
  var Nu = "Ν";
  var nu = "ν";
  var num = "#";
  var numero = "№";
  var numsp = " ";
  var nvap = "≍⃒";
  var nvdash = "⊬";
  var nvDash = "⊭";
  var nVdash = "⊮";
  var nVDash = "⊯";
  var nvge = "≥⃒";
  var nvgt = ">⃒";
  var nvHarr = "⤄";
  var nvinfin = "⧞";
  var nvlArr = "⤂";
  var nvle = "≤⃒";
  var nvlt = "<⃒";
  var nvltrie = "⊴⃒";
  var nvrArr = "⤃";
  var nvrtrie = "⊵⃒";
  var nvsim = "∼⃒";
  var nwarhk = "⤣";
  var nwarr = "↖";
  var nwArr = "⇖";
  var nwarrow = "↖";
  var nwnear = "⤧";
  var Oacute = "Ó";
  var oacute = "ó";
  var oast = "⊛";
  var Ocirc = "Ô";
  var ocirc = "ô";
  var ocir = "⊚";
  var Ocy = "О";
  var ocy = "о";
  var odash = "⊝";
  var Odblac = "Ő";
  var odblac = "ő";
  var odiv = "⨸";
  var odot = "⊙";
  var odsold = "⦼";
  var OElig = "Œ";
  var oelig = "œ";
  var ofcir = "⦿";
  var Ofr = "𝔒";
  var ofr = "𝔬";
  var ogon = "˛";
  var Ograve = "Ò";
  var ograve = "ò";
  var ogt = "⧁";
  var ohbar = "⦵";
  var ohm = "Ω";
  var oint = "∮";
  var olarr = "↺";
  var olcir = "⦾";
  var olcross = "⦻";
  var oline = "‾";
  var olt = "⧀";
  var Omacr = "Ō";
  var omacr = "ō";
  var Omega = "Ω";
  var omega = "ω";
  var Omicron = "Ο";
  var omicron = "ο";
  var omid = "⦶";
  var ominus = "⊖";
  var Oopf = "𝕆";
  var oopf = "𝕠";
  var opar = "⦷";
  var OpenCurlyDoubleQuote = "“";
  var OpenCurlyQuote = "‘";
  var operp = "⦹";
  var oplus = "⊕";
  var orarr = "↻";
  var Or = "⩔";
  var or = "∨";
  var ord = "⩝";
  var order = "ℴ";
  var orderof = "ℴ";
  var ordf = "ª";
  var ordm = "º";
  var origof = "⊶";
  var oror = "⩖";
  var orslope = "⩗";
  var orv = "⩛";
  var oS = "Ⓢ";
  var Oscr = "𝒪";
  var oscr = "ℴ";
  var Oslash = "Ø";
  var oslash = "ø";
  var osol = "⊘";
  var Otilde = "Õ";
  var otilde = "õ";
  var otimesas = "⨶";
  var Otimes = "⨷";
  var otimes = "⊗";
  var Ouml = "Ö";
  var ouml = "ö";
  var ovbar = "⌽";
  var OverBar = "‾";
  var OverBrace = "⏞";
  var OverBracket = "⎴";
  var OverParenthesis = "⏜";
  var para = "¶";
  var parallel = "∥";
  var par = "∥";
  var parsim = "⫳";
  var parsl = "⫽";
  var part = "∂";
  var PartialD = "∂";
  var Pcy = "П";
  var pcy = "п";
  var percnt = "%";
  var period = ".";
  var permil = "‰";
  var perp = "⊥";
  var pertenk = "‱";
  var Pfr = "𝔓";
  var pfr = "𝔭";
  var Phi = "Φ";
  var phi = "φ";
  var phiv = "ϕ";
  var phmmat = "ℳ";
  var phone = "☎";
  var Pi = "Π";
  var pi = "π";
  var pitchfork = "⋔";
  var piv = "ϖ";
  var planck = "ℏ";
  var planckh = "ℎ";
  var plankv = "ℏ";
  var plusacir = "⨣";
  var plusb = "⊞";
  var pluscir = "⨢";
  var plus = "+";
  var plusdo = "∔";
  var plusdu = "⨥";
  var pluse = "⩲";
  var PlusMinus = "±";
  var plusmn = "±";
  var plussim = "⨦";
  var plustwo = "⨧";
  var pm = "±";
  var Poincareplane = "ℌ";
  var pointint = "⨕";
  var popf = "𝕡";
  var Popf = "ℙ";
  var pound = "£";
  var prap = "⪷";
  var Pr = "⪻";
  var pr = "≺";
  var prcue = "≼";
  var precapprox = "⪷";
  var prec = "≺";
  var preccurlyeq = "≼";
  var Precedes = "≺";
  var PrecedesEqual = "⪯";
  var PrecedesSlantEqual = "≼";
  var PrecedesTilde = "≾";
  var preceq = "⪯";
  var precnapprox = "⪹";
  var precneqq = "⪵";
  var precnsim = "⋨";
  var pre = "⪯";
  var prE = "⪳";
  var precsim = "≾";
  var prime = "′";
  var Prime = "″";
  var primes = "ℙ";
  var prnap = "⪹";
  var prnE = "⪵";
  var prnsim = "⋨";
  var prod = "∏";
  var Product = "∏";
  var profalar = "⌮";
  var profline = "⌒";
  var profsurf = "⌓";
  var prop = "∝";
  var Proportional = "∝";
  var Proportion = "∷";
  var propto = "∝";
  var prsim = "≾";
  var prurel = "⊰";
  var Pscr = "𝒫";
  var pscr = "𝓅";
  var Psi = "Ψ";
  var psi = "ψ";
  var puncsp = " ";
  var Qfr = "𝔔";
  var qfr = "𝔮";
  var qint = "⨌";
  var qopf = "𝕢";
  var Qopf = "ℚ";
  var qprime = "⁗";
  var Qscr = "𝒬";
  var qscr = "𝓆";
  var quaternions = "ℍ";
  var quatint = "⨖";
  var quest = "?";
  var questeq = "≟";
  var quot = "\"";
  var QUOT = "\"";
  var rAarr = "⇛";
  var race = "∽̱";
  var Racute = "Ŕ";
  var racute = "ŕ";
  var radic = "√";
  var raemptyv = "⦳";
  var rang = "⟩";
  var Rang = "⟫";
  var rangd = "⦒";
  var range = "⦥";
  var rangle = "⟩";
  var raquo = "»";
  var rarrap = "⥵";
  var rarrb = "⇥";
  var rarrbfs = "⤠";
  var rarrc = "⤳";
  var rarr = "→";
  var Rarr = "↠";
  var rArr = "⇒";
  var rarrfs = "⤞";
  var rarrhk = "↪";
  var rarrlp = "↬";
  var rarrpl = "⥅";
  var rarrsim = "⥴";
  var Rarrtl = "⤖";
  var rarrtl = "↣";
  var rarrw = "↝";
  var ratail = "⤚";
  var rAtail = "⤜";
  var ratio = "∶";
  var rationals = "ℚ";
  var rbarr = "⤍";
  var rBarr = "⤏";
  var RBarr = "⤐";
  var rbbrk = "❳";
  var rbrace = "}";
  var rbrack = "]";
  var rbrke = "⦌";
  var rbrksld = "⦎";
  var rbrkslu = "⦐";
  var Rcaron = "Ř";
  var rcaron = "ř";
  var Rcedil = "Ŗ";
  var rcedil = "ŗ";
  var rceil = "⌉";
  var rcub = "}";
  var Rcy = "Р";
  var rcy = "р";
  var rdca = "⤷";
  var rdldhar = "⥩";
  var rdquo = "”";
  var rdquor = "”";
  var rdsh = "↳";
  var real = "ℜ";
  var realine = "ℛ";
  var realpart = "ℜ";
  var reals = "ℝ";
  var Re = "ℜ";
  var rect = "▭";
  var reg = "®";
  var REG = "®";
  var ReverseElement = "∋";
  var ReverseEquilibrium = "⇋";
  var ReverseUpEquilibrium = "⥯";
  var rfisht = "⥽";
  var rfloor = "⌋";
  var rfr = "𝔯";
  var Rfr = "ℜ";
  var rHar = "⥤";
  var rhard = "⇁";
  var rharu = "⇀";
  var rharul = "⥬";
  var Rho = "Ρ";
  var rho = "ρ";
  var rhov = "ϱ";
  var RightAngleBracket = "⟩";
  var RightArrowBar = "⇥";
  var rightarrow = "→";
  var RightArrow = "→";
  var Rightarrow = "⇒";
  var RightArrowLeftArrow = "⇄";
  var rightarrowtail = "↣";
  var RightCeiling = "⌉";
  var RightDoubleBracket = "⟧";
  var RightDownTeeVector = "⥝";
  var RightDownVectorBar = "⥕";
  var RightDownVector = "⇂";
  var RightFloor = "⌋";
  var rightharpoondown = "⇁";
  var rightharpoonup = "⇀";
  var rightleftarrows = "⇄";
  var rightleftharpoons = "⇌";
  var rightrightarrows = "⇉";
  var rightsquigarrow = "↝";
  var RightTeeArrow = "↦";
  var RightTee = "⊢";
  var RightTeeVector = "⥛";
  var rightthreetimes = "⋌";
  var RightTriangleBar = "⧐";
  var RightTriangle = "⊳";
  var RightTriangleEqual = "⊵";
  var RightUpDownVector = "⥏";
  var RightUpTeeVector = "⥜";
  var RightUpVectorBar = "⥔";
  var RightUpVector = "↾";
  var RightVectorBar = "⥓";
  var RightVector = "⇀";
  var ring = "˚";
  var risingdotseq = "≓";
  var rlarr = "⇄";
  var rlhar = "⇌";
  var rlm = "‏";
  var rmoustache = "⎱";
  var rmoust = "⎱";
  var rnmid = "⫮";
  var roang = "⟭";
  var roarr = "⇾";
  var robrk = "⟧";
  var ropar = "⦆";
  var ropf = "𝕣";
  var Ropf = "ℝ";
  var roplus = "⨮";
  var rotimes = "⨵";
  var RoundImplies = "⥰";
  var rpar = ")";
  var rpargt = "⦔";
  var rppolint = "⨒";
  var rrarr = "⇉";
  var Rrightarrow = "⇛";
  var rsaquo = "›";
  var rscr = "𝓇";
  var Rscr = "ℛ";
  var rsh = "↱";
  var Rsh = "↱";
  var rsqb = "]";
  var rsquo = "’";
  var rsquor = "’";
  var rthree = "⋌";
  var rtimes = "⋊";
  var rtri = "▹";
  var rtrie = "⊵";
  var rtrif = "▸";
  var rtriltri = "⧎";
  var RuleDelayed = "⧴";
  var ruluhar = "⥨";
  var rx = "℞";
  var Sacute = "Ś";
  var sacute = "ś";
  var sbquo = "‚";
  var scap = "⪸";
  var Scaron = "Š";
  var scaron = "š";
  var Sc = "⪼";
  var sc = "≻";
  var sccue = "≽";
  var sce = "⪰";
  var scE = "⪴";
  var Scedil = "Ş";
  var scedil = "ş";
  var Scirc = "Ŝ";
  var scirc = "ŝ";
  var scnap = "⪺";
  var scnE = "⪶";
  var scnsim = "⋩";
  var scpolint = "⨓";
  var scsim = "≿";
  var Scy = "С";
  var scy = "с";
  var sdotb = "⊡";
  var sdot = "⋅";
  var sdote = "⩦";
  var searhk = "⤥";
  var searr = "↘";
  var seArr = "⇘";
  var searrow = "↘";
  var sect = "§";
  var semi = ";";
  var seswar = "⤩";
  var setminus = "∖";
  var setmn = "∖";
  var sext = "✶";
  var Sfr = "𝔖";
  var sfr = "𝔰";
  var sfrown = "⌢";
  var sharp = "♯";
  var SHCHcy = "Щ";
  var shchcy = "щ";
  var SHcy = "Ш";
  var shcy = "ш";
  var ShortDownArrow = "↓";
  var ShortLeftArrow = "←";
  var shortmid = "∣";
  var shortparallel = "∥";
  var ShortRightArrow = "→";
  var ShortUpArrow = "↑";
  var shy = "­";
  var Sigma = "Σ";
  var sigma = "σ";
  var sigmaf = "ς";
  var sigmav = "ς";
  var sim = "∼";
  var simdot = "⩪";
  var sime = "≃";
  var simeq = "≃";
  var simg = "⪞";
  var simgE = "⪠";
  var siml = "⪝";
  var simlE = "⪟";
  var simne = "≆";
  var simplus = "⨤";
  var simrarr = "⥲";
  var slarr = "←";
  var SmallCircle = "∘";
  var smallsetminus = "∖";
  var smashp = "⨳";
  var smeparsl = "⧤";
  var smid = "∣";
  var smile = "⌣";
  var smt = "⪪";
  var smte = "⪬";
  var smtes = "⪬︀";
  var SOFTcy = "Ь";
  var softcy = "ь";
  var solbar = "⌿";
  var solb = "⧄";
  var sol = "/";
  var Sopf = "𝕊";
  var sopf = "𝕤";
  var spades = "♠";
  var spadesuit = "♠";
  var spar = "∥";
  var sqcap = "⊓";
  var sqcaps = "⊓︀";
  var sqcup = "⊔";
  var sqcups = "⊔︀";
  var Sqrt = "√";
  var sqsub = "⊏";
  var sqsube = "⊑";
  var sqsubset = "⊏";
  var sqsubseteq = "⊑";
  var sqsup = "⊐";
  var sqsupe = "⊒";
  var sqsupset = "⊐";
  var sqsupseteq = "⊒";
  var square = "□";
  var Square = "□";
  var SquareIntersection = "⊓";
  var SquareSubset = "⊏";
  var SquareSubsetEqual = "⊑";
  var SquareSuperset = "⊐";
  var SquareSupersetEqual = "⊒";
  var SquareUnion = "⊔";
  var squarf = "▪";
  var squ = "□";
  var squf = "▪";
  var srarr = "→";
  var Sscr = "𝒮";
  var sscr = "𝓈";
  var ssetmn = "∖";
  var ssmile = "⌣";
  var sstarf = "⋆";
  var Star = "⋆";
  var star = "☆";
  var starf = "★";
  var straightepsilon = "ϵ";
  var straightphi = "ϕ";
  var strns = "¯";
  var sub = "⊂";
  var Sub = "⋐";
  var subdot = "⪽";
  var subE = "⫅";
  var sube = "⊆";
  var subedot = "⫃";
  var submult = "⫁";
  var subnE = "⫋";
  var subne = "⊊";
  var subplus = "⪿";
  var subrarr = "⥹";
  var subset = "⊂";
  var Subset = "⋐";
  var subseteq = "⊆";
  var subseteqq = "⫅";
  var SubsetEqual = "⊆";
  var subsetneq = "⊊";
  var subsetneqq = "⫋";
  var subsim = "⫇";
  var subsub = "⫕";
  var subsup = "⫓";
  var succapprox = "⪸";
  var succ = "≻";
  var succcurlyeq = "≽";
  var Succeeds = "≻";
  var SucceedsEqual = "⪰";
  var SucceedsSlantEqual = "≽";
  var SucceedsTilde = "≿";
  var succeq = "⪰";
  var succnapprox = "⪺";
  var succneqq = "⪶";
  var succnsim = "⋩";
  var succsim = "≿";
  var SuchThat = "∋";
  var sum = "∑";
  var Sum = "∑";
  var sung = "♪";
  var sup1 = "¹";
  var sup2 = "²";
  var sup3 = "³";
  var sup = "⊃";
  var Sup = "⋑";
  var supdot = "⪾";
  var supdsub = "⫘";
  var supE = "⫆";
  var supe = "⊇";
  var supedot = "⫄";
  var Superset = "⊃";
  var SupersetEqual = "⊇";
  var suphsol = "⟉";
  var suphsub = "⫗";
  var suplarr = "⥻";
  var supmult = "⫂";
  var supnE = "⫌";
  var supne = "⊋";
  var supplus = "⫀";
  var supset = "⊃";
  var Supset = "⋑";
  var supseteq = "⊇";
  var supseteqq = "⫆";
  var supsetneq = "⊋";
  var supsetneqq = "⫌";
  var supsim = "⫈";
  var supsub = "⫔";
  var supsup = "⫖";
  var swarhk = "⤦";
  var swarr = "↙";
  var swArr = "⇙";
  var swarrow = "↙";
  var swnwar = "⤪";
  var szlig = "ß";
  var Tab = "\t";
  var target = "⌖";
  var Tau = "Τ";
  var tau = "τ";
  var tbrk = "⎴";
  var Tcaron = "Ť";
  var tcaron = "ť";
  var Tcedil = "Ţ";
  var tcedil = "ţ";
  var Tcy = "Т";
  var tcy = "т";
  var tdot = "⃛";
  var telrec = "⌕";
  var Tfr = "𝔗";
  var tfr = "𝔱";
  var there4 = "∴";
  var therefore = "∴";
  var Therefore = "∴";
  var Theta = "Θ";
  var theta = "θ";
  var thetasym = "ϑ";
  var thetav = "ϑ";
  var thickapprox = "≈";
  var thicksim = "∼";
  var ThickSpace = "  ";
  var ThinSpace = " ";
  var thinsp = " ";
  var thkap = "≈";
  var thksim = "∼";
  var THORN = "Þ";
  var thorn = "þ";
  var tilde = "˜";
  var Tilde = "∼";
  var TildeEqual = "≃";
  var TildeFullEqual = "≅";
  var TildeTilde = "≈";
  var timesbar = "⨱";
  var timesb = "⊠";
  var times = "×";
  var timesd = "⨰";
  var tint = "∭";
  var toea = "⤨";
  var topbot = "⌶";
  var topcir = "⫱";
  var top = "⊤";
  var Topf = "𝕋";
  var topf = "𝕥";
  var topfork = "⫚";
  var tosa = "⤩";
  var tprime = "‴";
  var trade = "™";
  var TRADE = "™";
  var triangle = "▵";
  var triangledown = "▿";
  var triangleleft = "◃";
  var trianglelefteq = "⊴";
  var triangleq = "≜";
  var triangleright = "▹";
  var trianglerighteq = "⊵";
  var tridot = "◬";
  var trie = "≜";
  var triminus = "⨺";
  var TripleDot = "⃛";
  var triplus = "⨹";
  var trisb = "⧍";
  var tritime = "⨻";
  var trpezium = "⏢";
  var Tscr = "𝒯";
  var tscr = "𝓉";
  var TScy = "Ц";
  var tscy = "ц";
  var TSHcy = "Ћ";
  var tshcy = "ћ";
  var Tstrok = "Ŧ";
  var tstrok = "ŧ";
  var twixt = "≬";
  var twoheadleftarrow = "↞";
  var twoheadrightarrow = "↠";
  var Uacute = "Ú";
  var uacute = "ú";
  var uarr = "↑";
  var Uarr = "↟";
  var uArr = "⇑";
  var Uarrocir = "⥉";
  var Ubrcy = "Ў";
  var ubrcy = "ў";
  var Ubreve = "Ŭ";
  var ubreve = "ŭ";
  var Ucirc = "Û";
  var ucirc = "û";
  var Ucy = "У";
  var ucy = "у";
  var udarr = "⇅";
  var Udblac = "Ű";
  var udblac = "ű";
  var udhar = "⥮";
  var ufisht = "⥾";
  var Ufr = "𝔘";
  var ufr = "𝔲";
  var Ugrave = "Ù";
  var ugrave = "ù";
  var uHar = "⥣";
  var uharl = "↿";
  var uharr = "↾";
  var uhblk = "▀";
  var ulcorn = "⌜";
  var ulcorner = "⌜";
  var ulcrop = "⌏";
  var ultri = "◸";
  var Umacr = "Ū";
  var umacr = "ū";
  var uml = "¨";
  var UnderBar = "_";
  var UnderBrace = "⏟";
  var UnderBracket = "⎵";
  var UnderParenthesis = "⏝";
  var Union = "⋃";
  var UnionPlus = "⊎";
  var Uogon = "Ų";
  var uogon = "ų";
  var Uopf = "𝕌";
  var uopf = "𝕦";
  var UpArrowBar = "⤒";
  var uparrow = "↑";
  var UpArrow = "↑";
  var Uparrow = "⇑";
  var UpArrowDownArrow = "⇅";
  var updownarrow = "↕";
  var UpDownArrow = "↕";
  var Updownarrow = "⇕";
  var UpEquilibrium = "⥮";
  var upharpoonleft = "↿";
  var upharpoonright = "↾";
  var uplus = "⊎";
  var UpperLeftArrow = "↖";
  var UpperRightArrow = "↗";
  var upsi = "υ";
  var Upsi = "ϒ";
  var upsih = "ϒ";
  var Upsilon = "Υ";
  var upsilon = "υ";
  var UpTeeArrow = "↥";
  var UpTee = "⊥";
  var upuparrows = "⇈";
  var urcorn = "⌝";
  var urcorner = "⌝";
  var urcrop = "⌎";
  var Uring = "Ů";
  var uring = "ů";
  var urtri = "◹";
  var Uscr = "𝒰";
  var uscr = "𝓊";
  var utdot = "⋰";
  var Utilde = "Ũ";
  var utilde = "ũ";
  var utri = "▵";
  var utrif = "▴";
  var uuarr = "⇈";
  var Uuml = "Ü";
  var uuml = "ü";
  var uwangle = "⦧";
  var vangrt = "⦜";
  var varepsilon = "ϵ";
  var varkappa = "ϰ";
  var varnothing = "∅";
  var varphi = "ϕ";
  var varpi = "ϖ";
  var varpropto = "∝";
  var varr = "↕";
  var vArr = "⇕";
  var varrho = "ϱ";
  var varsigma = "ς";
  var varsubsetneq = "⊊︀";
  var varsubsetneqq = "⫋︀";
  var varsupsetneq = "⊋︀";
  var varsupsetneqq = "⫌︀";
  var vartheta = "ϑ";
  var vartriangleleft = "⊲";
  var vartriangleright = "⊳";
  var vBar = "⫨";
  var Vbar = "⫫";
  var vBarv = "⫩";
  var Vcy = "В";
  var vcy = "в";
  var vdash = "⊢";
  var vDash = "⊨";
  var Vdash = "⊩";
  var VDash = "⊫";
  var Vdashl = "⫦";
  var veebar = "⊻";
  var vee = "∨";
  var Vee = "⋁";
  var veeeq = "≚";
  var vellip = "⋮";
  var verbar = "|";
  var Verbar = "‖";
  var vert = "|";
  var Vert = "‖";
  var VerticalBar = "∣";
  var VerticalLine = "|";
  var VerticalSeparator = "❘";
  var VerticalTilde = "≀";
  var VeryThinSpace = " ";
  var Vfr = "𝔙";
  var vfr = "𝔳";
  var vltri = "⊲";
  var vnsub = "⊂⃒";
  var vnsup = "⊃⃒";
  var Vopf = "𝕍";
  var vopf = "𝕧";
  var vprop = "∝";
  var vrtri = "⊳";
  var Vscr = "𝒱";
  var vscr = "𝓋";
  var vsubnE = "⫋︀";
  var vsubne = "⊊︀";
  var vsupnE = "⫌︀";
  var vsupne = "⊋︀";
  var Vvdash = "⊪";
  var vzigzag = "⦚";
  var Wcirc = "Ŵ";
  var wcirc = "ŵ";
  var wedbar = "⩟";
  var wedge = "∧";
  var Wedge = "⋀";
  var wedgeq = "≙";
  var weierp = "℘";
  var Wfr = "𝔚";
  var wfr = "𝔴";
  var Wopf = "𝕎";
  var wopf = "𝕨";
  var wp = "℘";
  var wr = "≀";
  var wreath = "≀";
  var Wscr = "𝒲";
  var wscr = "𝓌";
  var xcap = "⋂";
  var xcirc = "◯";
  var xcup = "⋃";
  var xdtri = "▽";
  var Xfr = "𝔛";
  var xfr = "𝔵";
  var xharr = "⟷";
  var xhArr = "⟺";
  var Xi = "Ξ";
  var xi = "ξ";
  var xlarr = "⟵";
  var xlArr = "⟸";
  var xmap = "⟼";
  var xnis = "⋻";
  var xodot = "⨀";
  var Xopf = "𝕏";
  var xopf = "𝕩";
  var xoplus = "⨁";
  var xotime = "⨂";
  var xrarr = "⟶";
  var xrArr = "⟹";
  var Xscr = "𝒳";
  var xscr = "𝓍";
  var xsqcup = "⨆";
  var xuplus = "⨄";
  var xutri = "△";
  var xvee = "⋁";
  var xwedge = "⋀";
  var Yacute = "Ý";
  var yacute = "ý";
  var YAcy = "Я";
  var yacy = "я";
  var Ycirc = "Ŷ";
  var ycirc = "ŷ";
  var Ycy = "Ы";
  var ycy = "ы";
  var yen = "¥";
  var Yfr = "𝔜";
  var yfr = "𝔶";
  var YIcy = "Ї";
  var yicy = "ї";
  var Yopf = "𝕐";
  var yopf = "𝕪";
  var Yscr = "𝒴";
  var yscr = "𝓎";
  var YUcy = "Ю";
  var yucy = "ю";
  var yuml = "ÿ";
  var Yuml = "Ÿ";
  var Zacute = "Ź";
  var zacute = "ź";
  var Zcaron = "Ž";
  var zcaron = "ž";
  var Zcy = "З";
  var zcy = "з";
  var Zdot = "Ż";
  var zdot = "ż";
  var zeetrf = "ℨ";
  var ZeroWidthSpace = "​";
  var Zeta = "Ζ";
  var zeta = "ζ";
  var zfr = "𝔷";
  var Zfr = "ℨ";
  var ZHcy = "Ж";
  var zhcy = "ж";
  var zigrarr = "⇝";
  var zopf = "𝕫";
  var Zopf = "ℤ";
  var Zscr = "𝒵";
  var zscr = "𝓏";
  var zwj = "‍";
  var zwnj = "‌";
  var require$$0$1 = {
  	Aacute: Aacute,
  	aacute: aacute,
  	Abreve: Abreve,
  	abreve: abreve,
  	ac: ac,
  	acd: acd,
  	acE: acE,
  	Acirc: Acirc,
  	acirc: acirc,
  	acute: acute,
  	Acy: Acy,
  	acy: acy,
  	AElig: AElig,
  	aelig: aelig,
  	af: af,
  	Afr: Afr,
  	afr: afr,
  	Agrave: Agrave,
  	agrave: agrave,
  	alefsym: alefsym,
  	aleph: aleph,
  	Alpha: Alpha,
  	alpha: alpha,
  	Amacr: Amacr,
  	amacr: amacr,
  	amalg: amalg,
  	amp: amp,
  	AMP: AMP,
  	andand: andand,
  	And: And,
  	and: and,
  	andd: andd,
  	andslope: andslope,
  	andv: andv,
  	ang: ang,
  	ange: ange,
  	angle: angle$1,
  	angmsdaa: angmsdaa,
  	angmsdab: angmsdab,
  	angmsdac: angmsdac,
  	angmsdad: angmsdad,
  	angmsdae: angmsdae,
  	angmsdaf: angmsdaf,
  	angmsdag: angmsdag,
  	angmsdah: angmsdah,
  	angmsd: angmsd,
  	angrt: angrt,
  	angrtvb: angrtvb,
  	angrtvbd: angrtvbd,
  	angsph: angsph,
  	angst: angst,
  	angzarr: angzarr,
  	Aogon: Aogon,
  	aogon: aogon,
  	Aopf: Aopf,
  	aopf: aopf,
  	apacir: apacir,
  	ap: ap,
  	apE: apE,
  	ape: ape,
  	apid: apid,
  	apos: apos,
  	ApplyFunction: ApplyFunction,
  	approx: approx,
  	approxeq: approxeq,
  	Aring: Aring,
  	aring: aring,
  	Ascr: Ascr,
  	ascr: ascr,
  	Assign: Assign,
  	ast: ast,
  	asymp: asymp,
  	asympeq: asympeq,
  	Atilde: Atilde,
  	atilde: atilde,
  	Auml: Auml,
  	auml: auml,
  	awconint: awconint,
  	awint: awint,
  	backcong: backcong,
  	backepsilon: backepsilon,
  	backprime: backprime,
  	backsim: backsim,
  	backsimeq: backsimeq,
  	Backslash: Backslash,
  	Barv: Barv,
  	barvee: barvee,
  	barwed: barwed,
  	Barwed: Barwed,
  	barwedge: barwedge,
  	bbrk: bbrk,
  	bbrktbrk: bbrktbrk,
  	bcong: bcong,
  	Bcy: Bcy,
  	bcy: bcy,
  	bdquo: bdquo,
  	becaus: becaus,
  	because: because,
  	Because: Because,
  	bemptyv: bemptyv,
  	bepsi: bepsi,
  	bernou: bernou,
  	Bernoullis: Bernoullis,
  	Beta: Beta,
  	beta: beta,
  	beth: beth,
  	between: between,
  	Bfr: Bfr,
  	bfr: bfr,
  	bigcap: bigcap,
  	bigcirc: bigcirc,
  	bigcup: bigcup,
  	bigodot: bigodot,
  	bigoplus: bigoplus,
  	bigotimes: bigotimes,
  	bigsqcup: bigsqcup,
  	bigstar: bigstar,
  	bigtriangledown: bigtriangledown,
  	bigtriangleup: bigtriangleup,
  	biguplus: biguplus,
  	bigvee: bigvee,
  	bigwedge: bigwedge,
  	bkarow: bkarow,
  	blacklozenge: blacklozenge,
  	blacksquare: blacksquare,
  	blacktriangle: blacktriangle,
  	blacktriangledown: blacktriangledown,
  	blacktriangleleft: blacktriangleleft,
  	blacktriangleright: blacktriangleright,
  	blank: blank,
  	blk12: blk12,
  	blk14: blk14,
  	blk34: blk34,
  	block: block$1,
  	bne: bne,
  	bnequiv: bnequiv,
  	bNot: bNot,
  	bnot: bnot,
  	Bopf: Bopf,
  	bopf: bopf,
  	bot: bot,
  	bottom: bottom,
  	bowtie: bowtie,
  	boxbox: boxbox,
  	boxdl: boxdl,
  	boxdL: boxdL,
  	boxDl: boxDl,
  	boxDL: boxDL,
  	boxdr: boxdr,
  	boxdR: boxdR,
  	boxDr: boxDr,
  	boxDR: boxDR,
  	boxh: boxh,
  	boxH: boxH,
  	boxhd: boxhd,
  	boxHd: boxHd,
  	boxhD: boxhD,
  	boxHD: boxHD,
  	boxhu: boxhu,
  	boxHu: boxHu,
  	boxhU: boxhU,
  	boxHU: boxHU,
  	boxminus: boxminus,
  	boxplus: boxplus,
  	boxtimes: boxtimes,
  	boxul: boxul,
  	boxuL: boxuL,
  	boxUl: boxUl,
  	boxUL: boxUL,
  	boxur: boxur,
  	boxuR: boxuR,
  	boxUr: boxUr,
  	boxUR: boxUR,
  	boxv: boxv,
  	boxV: boxV,
  	boxvh: boxvh,
  	boxvH: boxvH,
  	boxVh: boxVh,
  	boxVH: boxVH,
  	boxvl: boxvl,
  	boxvL: boxvL,
  	boxVl: boxVl,
  	boxVL: boxVL,
  	boxvr: boxvr,
  	boxvR: boxvR,
  	boxVr: boxVr,
  	boxVR: boxVR,
  	bprime: bprime,
  	breve: breve,
  	Breve: Breve,
  	brvbar: brvbar,
  	bscr: bscr,
  	Bscr: Bscr,
  	bsemi: bsemi,
  	bsim: bsim,
  	bsime: bsime,
  	bsolb: bsolb,
  	bsol: bsol,
  	bsolhsub: bsolhsub,
  	bull: bull,
  	bullet: bullet,
  	bump: bump,
  	bumpE: bumpE,
  	bumpe: bumpe,
  	Bumpeq: Bumpeq,
  	bumpeq: bumpeq,
  	Cacute: Cacute,
  	cacute: cacute,
  	capand: capand,
  	capbrcup: capbrcup,
  	capcap: capcap,
  	cap: cap,
  	Cap: Cap,
  	capcup: capcup,
  	capdot: capdot,
  	CapitalDifferentialD: CapitalDifferentialD,
  	caps: caps,
  	caret: caret,
  	caron: caron,
  	Cayleys: Cayleys,
  	ccaps: ccaps,
  	Ccaron: Ccaron,
  	ccaron: ccaron,
  	Ccedil: Ccedil,
  	ccedil: ccedil,
  	Ccirc: Ccirc,
  	ccirc: ccirc,
  	Cconint: Cconint,
  	ccups: ccups,
  	ccupssm: ccupssm,
  	Cdot: Cdot,
  	cdot: cdot,
  	cedil: cedil,
  	Cedilla: Cedilla,
  	cemptyv: cemptyv,
  	cent: cent,
  	centerdot: centerdot,
  	CenterDot: CenterDot,
  	cfr: cfr,
  	Cfr: Cfr,
  	CHcy: CHcy,
  	chcy: chcy,
  	check: check$1,
  	checkmark: checkmark,
  	Chi: Chi,
  	chi: chi,
  	circ: circ,
  	circeq: circeq,
  	circlearrowleft: circlearrowleft,
  	circlearrowright: circlearrowright,
  	circledast: circledast,
  	circledcirc: circledcirc,
  	circleddash: circleddash,
  	CircleDot: CircleDot,
  	circledR: circledR,
  	circledS: circledS,
  	CircleMinus: CircleMinus,
  	CirclePlus: CirclePlus,
  	CircleTimes: CircleTimes,
  	cir: cir,
  	cirE: cirE,
  	cire: cire,
  	cirfnint: cirfnint,
  	cirmid: cirmid,
  	cirscir: cirscir,
  	ClockwiseContourIntegral: ClockwiseContourIntegral,
  	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
  	CloseCurlyQuote: CloseCurlyQuote,
  	clubs: clubs,
  	clubsuit: clubsuit,
  	colon: colon,
  	Colon: Colon,
  	Colone: Colone,
  	colone: colone,
  	coloneq: coloneq,
  	comma: comma,
  	commat: commat,
  	comp: comp,
  	compfn: compfn,
  	complement: complement,
  	complexes: complexes,
  	cong: cong,
  	congdot: congdot,
  	Congruent: Congruent,
  	conint: conint,
  	Conint: Conint,
  	ContourIntegral: ContourIntegral,
  	copf: copf,
  	Copf: Copf,
  	coprod: coprod,
  	Coproduct: Coproduct,
  	copy: copy,
  	COPY: COPY,
  	copysr: copysr,
  	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
  	crarr: crarr,
  	cross: cross,
  	Cross: Cross,
  	Cscr: Cscr,
  	cscr: cscr,
  	csub: csub,
  	csube: csube,
  	csup: csup,
  	csupe: csupe,
  	ctdot: ctdot,
  	cudarrl: cudarrl,
  	cudarrr: cudarrr,
  	cuepr: cuepr,
  	cuesc: cuesc,
  	cularr: cularr,
  	cularrp: cularrp,
  	cupbrcap: cupbrcap,
  	cupcap: cupcap,
  	CupCap: CupCap,
  	cup: cup,
  	Cup: Cup,
  	cupcup: cupcup,
  	cupdot: cupdot,
  	cupor: cupor,
  	cups: cups,
  	curarr: curarr,
  	curarrm: curarrm,
  	curlyeqprec: curlyeqprec,
  	curlyeqsucc: curlyeqsucc,
  	curlyvee: curlyvee,
  	curlywedge: curlywedge,
  	curren: curren,
  	curvearrowleft: curvearrowleft,
  	curvearrowright: curvearrowright,
  	cuvee: cuvee,
  	cuwed: cuwed,
  	cwconint: cwconint,
  	cwint: cwint,
  	cylcty: cylcty,
  	dagger: dagger,
  	Dagger: Dagger,
  	daleth: daleth,
  	darr: darr,
  	Darr: Darr,
  	dArr: dArr,
  	dash: dash,
  	Dashv: Dashv,
  	dashv: dashv,
  	dbkarow: dbkarow,
  	dblac: dblac,
  	Dcaron: Dcaron,
  	dcaron: dcaron,
  	Dcy: Dcy,
  	dcy: dcy,
  	ddagger: ddagger,
  	ddarr: ddarr,
  	DD: DD,
  	dd: dd,
  	DDotrahd: DDotrahd,
  	ddotseq: ddotseq,
  	deg: deg$1,
  	Del: Del,
  	Delta: Delta,
  	delta: delta$1,
  	demptyv: demptyv,
  	dfisht: dfisht,
  	Dfr: Dfr,
  	dfr: dfr,
  	dHar: dHar,
  	dharl: dharl,
  	dharr: dharr,
  	DiacriticalAcute: DiacriticalAcute,
  	DiacriticalDot: DiacriticalDot,
  	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
  	DiacriticalGrave: DiacriticalGrave,
  	DiacriticalTilde: DiacriticalTilde,
  	diam: diam,
  	diamond: diamond,
  	Diamond: Diamond,
  	diamondsuit: diamondsuit,
  	diams: diams,
  	die: die,
  	DifferentialD: DifferentialD,
  	digamma: digamma,
  	disin: disin,
  	div: div,
  	divide: divide,
  	divideontimes: divideontimes,
  	divonx: divonx,
  	DJcy: DJcy,
  	djcy: djcy,
  	dlcorn: dlcorn,
  	dlcrop: dlcrop,
  	dollar: dollar,
  	Dopf: Dopf,
  	dopf: dopf,
  	Dot: Dot,
  	dot: dot,
  	DotDot: DotDot,
  	doteq: doteq,
  	doteqdot: doteqdot,
  	DotEqual: DotEqual,
  	dotminus: dotminus,
  	dotplus: dotplus,
  	dotsquare: dotsquare,
  	doublebarwedge: doublebarwedge,
  	DoubleContourIntegral: DoubleContourIntegral,
  	DoubleDot: DoubleDot,
  	DoubleDownArrow: DoubleDownArrow,
  	DoubleLeftArrow: DoubleLeftArrow,
  	DoubleLeftRightArrow: DoubleLeftRightArrow,
  	DoubleLeftTee: DoubleLeftTee,
  	DoubleLongLeftArrow: DoubleLongLeftArrow,
  	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
  	DoubleLongRightArrow: DoubleLongRightArrow,
  	DoubleRightArrow: DoubleRightArrow,
  	DoubleRightTee: DoubleRightTee,
  	DoubleUpArrow: DoubleUpArrow,
  	DoubleUpDownArrow: DoubleUpDownArrow,
  	DoubleVerticalBar: DoubleVerticalBar,
  	DownArrowBar: DownArrowBar,
  	downarrow: downarrow,
  	DownArrow: DownArrow,
  	Downarrow: Downarrow,
  	DownArrowUpArrow: DownArrowUpArrow,
  	DownBreve: DownBreve,
  	downdownarrows: downdownarrows,
  	downharpoonleft: downharpoonleft,
  	downharpoonright: downharpoonright,
  	DownLeftRightVector: DownLeftRightVector,
  	DownLeftTeeVector: DownLeftTeeVector,
  	DownLeftVectorBar: DownLeftVectorBar,
  	DownLeftVector: DownLeftVector,
  	DownRightTeeVector: DownRightTeeVector,
  	DownRightVectorBar: DownRightVectorBar,
  	DownRightVector: DownRightVector,
  	DownTeeArrow: DownTeeArrow,
  	DownTee: DownTee,
  	drbkarow: drbkarow,
  	drcorn: drcorn,
  	drcrop: drcrop,
  	Dscr: Dscr,
  	dscr: dscr,
  	DScy: DScy,
  	dscy: dscy,
  	dsol: dsol,
  	Dstrok: Dstrok,
  	dstrok: dstrok,
  	dtdot: dtdot,
  	dtri: dtri,
  	dtrif: dtrif,
  	duarr: duarr,
  	duhar: duhar,
  	dwangle: dwangle,
  	DZcy: DZcy,
  	dzcy: dzcy,
  	dzigrarr: dzigrarr,
  	Eacute: Eacute,
  	eacute: eacute,
  	easter: easter,
  	Ecaron: Ecaron,
  	ecaron: ecaron,
  	Ecirc: Ecirc,
  	ecirc: ecirc,
  	ecir: ecir,
  	ecolon: ecolon,
  	Ecy: Ecy,
  	ecy: ecy,
  	eDDot: eDDot,
  	Edot: Edot,
  	edot: edot,
  	eDot: eDot,
  	ee: ee,
  	efDot: efDot,
  	Efr: Efr,
  	efr: efr,
  	eg: eg,
  	Egrave: Egrave,
  	egrave: egrave,
  	egs: egs,
  	egsdot: egsdot,
  	el: el,
  	Element: Element$2,
  	elinters: elinters,
  	ell: ell,
  	els: els,
  	elsdot: elsdot,
  	Emacr: Emacr,
  	emacr: emacr,
  	empty: empty$1,
  	emptyset: emptyset,
  	EmptySmallSquare: EmptySmallSquare,
  	emptyv: emptyv,
  	EmptyVerySmallSquare: EmptyVerySmallSquare,
  	emsp13: emsp13,
  	emsp14: emsp14,
  	emsp: emsp,
  	ENG: ENG,
  	eng: eng,
  	ensp: ensp,
  	Eogon: Eogon,
  	eogon: eogon,
  	Eopf: Eopf,
  	eopf: eopf,
  	epar: epar,
  	eparsl: eparsl,
  	eplus: eplus,
  	epsi: epsi,
  	Epsilon: Epsilon,
  	epsilon: epsilon,
  	epsiv: epsiv,
  	eqcirc: eqcirc,
  	eqcolon: eqcolon,
  	eqsim: eqsim,
  	eqslantgtr: eqslantgtr,
  	eqslantless: eqslantless,
  	Equal: Equal,
  	equals: equals,
  	EqualTilde: EqualTilde,
  	equest: equest,
  	Equilibrium: Equilibrium,
  	equiv: equiv,
  	equivDD: equivDD,
  	eqvparsl: eqvparsl,
  	erarr: erarr,
  	erDot: erDot,
  	escr: escr,
  	Escr: Escr,
  	esdot: esdot,
  	Esim: Esim,
  	esim: esim,
  	Eta: Eta,
  	eta: eta,
  	ETH: ETH,
  	eth: eth,
  	Euml: Euml,
  	euml: euml,
  	euro: euro,
  	excl: excl,
  	exist: exist,
  	Exists: Exists,
  	expectation: expectation,
  	exponentiale: exponentiale,
  	ExponentialE: ExponentialE,
  	fallingdotseq: fallingdotseq,
  	Fcy: Fcy,
  	fcy: fcy,
  	female: female,
  	ffilig: ffilig,
  	fflig: fflig,
  	ffllig: ffllig,
  	Ffr: Ffr,
  	ffr: ffr,
  	filig: filig,
  	FilledSmallSquare: FilledSmallSquare,
  	FilledVerySmallSquare: FilledVerySmallSquare,
  	fjlig: fjlig,
  	flat: flat,
  	fllig: fllig,
  	fltns: fltns,
  	fnof: fnof,
  	Fopf: Fopf,
  	fopf: fopf,
  	forall: forall,
  	ForAll: ForAll,
  	fork: fork,
  	forkv: forkv,
  	Fouriertrf: Fouriertrf,
  	fpartint: fpartint,
  	frac12: frac12,
  	frac13: frac13,
  	frac14: frac14,
  	frac15: frac15,
  	frac16: frac16,
  	frac18: frac18,
  	frac23: frac23,
  	frac25: frac25,
  	frac34: frac34,
  	frac35: frac35,
  	frac38: frac38,
  	frac45: frac45,
  	frac56: frac56,
  	frac58: frac58,
  	frac78: frac78,
  	frasl: frasl,
  	frown: frown,
  	fscr: fscr,
  	Fscr: Fscr,
  	gacute: gacute,
  	Gamma: Gamma,
  	gamma: gamma,
  	Gammad: Gammad,
  	gammad: gammad,
  	gap: gap,
  	Gbreve: Gbreve,
  	gbreve: gbreve,
  	Gcedil: Gcedil,
  	Gcirc: Gcirc,
  	gcirc: gcirc,
  	Gcy: Gcy,
  	gcy: gcy,
  	Gdot: Gdot,
  	gdot: gdot,
  	ge: ge,
  	gE: gE,
  	gEl: gEl,
  	gel: gel,
  	geq: geq,
  	geqq: geqq,
  	geqslant: geqslant,
  	gescc: gescc,
  	ges: ges,
  	gesdot: gesdot,
  	gesdoto: gesdoto,
  	gesdotol: gesdotol,
  	gesl: gesl,
  	gesles: gesles,
  	Gfr: Gfr,
  	gfr: gfr,
  	gg: gg,
  	Gg: Gg,
  	ggg: ggg,
  	gimel: gimel,
  	GJcy: GJcy,
  	gjcy: gjcy,
  	gla: gla,
  	gl: gl,
  	glE: glE,
  	glj: glj,
  	gnap: gnap,
  	gnapprox: gnapprox,
  	gne: gne,
  	gnE: gnE,
  	gneq: gneq,
  	gneqq: gneqq,
  	gnsim: gnsim,
  	Gopf: Gopf,
  	gopf: gopf,
  	grave: grave,
  	GreaterEqual: GreaterEqual,
  	GreaterEqualLess: GreaterEqualLess,
  	GreaterFullEqual: GreaterFullEqual,
  	GreaterGreater: GreaterGreater,
  	GreaterLess: GreaterLess,
  	GreaterSlantEqual: GreaterSlantEqual,
  	GreaterTilde: GreaterTilde,
  	Gscr: Gscr,
  	gscr: gscr,
  	gsim: gsim,
  	gsime: gsime,
  	gsiml: gsiml,
  	gtcc: gtcc,
  	gtcir: gtcir,
  	gt: gt,
  	GT: GT$1,
  	Gt: Gt,
  	gtdot: gtdot,
  	gtlPar: gtlPar,
  	gtquest: gtquest,
  	gtrapprox: gtrapprox,
  	gtrarr: gtrarr,
  	gtrdot: gtrdot,
  	gtreqless: gtreqless,
  	gtreqqless: gtreqqless,
  	gtrless: gtrless,
  	gtrsim: gtrsim,
  	gvertneqq: gvertneqq,
  	gvnE: gvnE,
  	Hacek: Hacek,
  	hairsp: hairsp,
  	half: half,
  	hamilt: hamilt,
  	HARDcy: HARDcy,
  	hardcy: hardcy,
  	harrcir: harrcir,
  	harr: harr,
  	hArr: hArr,
  	harrw: harrw,
  	Hat: Hat,
  	hbar: hbar,
  	Hcirc: Hcirc,
  	hcirc: hcirc,
  	hearts: hearts,
  	heartsuit: heartsuit,
  	hellip: hellip,
  	hercon: hercon,
  	hfr: hfr,
  	Hfr: Hfr,
  	HilbertSpace: HilbertSpace,
  	hksearow: hksearow,
  	hkswarow: hkswarow,
  	hoarr: hoarr,
  	homtht: homtht,
  	hookleftarrow: hookleftarrow,
  	hookrightarrow: hookrightarrow,
  	hopf: hopf,
  	Hopf: Hopf,
  	horbar: horbar,
  	HorizontalLine: HorizontalLine,
  	hscr: hscr,
  	Hscr: Hscr,
  	hslash: hslash,
  	Hstrok: Hstrok,
  	hstrok: hstrok,
  	HumpDownHump: HumpDownHump,
  	HumpEqual: HumpEqual,
  	hybull: hybull,
  	hyphen: hyphen,
  	Iacute: Iacute,
  	iacute: iacute,
  	ic: ic,
  	Icirc: Icirc,
  	icirc: icirc,
  	Icy: Icy,
  	icy: icy,
  	Idot: Idot,
  	IEcy: IEcy,
  	iecy: iecy,
  	iexcl: iexcl,
  	iff: iff,
  	ifr: ifr,
  	Ifr: Ifr,
  	Igrave: Igrave,
  	igrave: igrave,
  	ii: ii,
  	iiiint: iiiint,
  	iiint: iiint,
  	iinfin: iinfin,
  	iiota: iiota,
  	IJlig: IJlig,
  	ijlig: ijlig,
  	Imacr: Imacr,
  	imacr: imacr,
  	image: image$2,
  	ImaginaryI: ImaginaryI,
  	imagline: imagline,
  	imagpart: imagpart,
  	imath: imath,
  	Im: Im,
  	imof: imof,
  	imped: imped,
  	Implies: Implies,
  	incare: incare,
  	"in": "∈",
  	infin: infin,
  	infintie: infintie,
  	inodot: inodot,
  	intcal: intcal,
  	int: int,
  	Int: Int,
  	integers: integers,
  	Integral: Integral,
  	intercal: intercal,
  	Intersection: Intersection,
  	intlarhk: intlarhk,
  	intprod: intprod,
  	InvisibleComma: InvisibleComma,
  	InvisibleTimes: InvisibleTimes,
  	IOcy: IOcy,
  	iocy: iocy,
  	Iogon: Iogon,
  	iogon: iogon,
  	Iopf: Iopf,
  	iopf: iopf,
  	Iota: Iota,
  	iota: iota,
  	iprod: iprod,
  	iquest: iquest,
  	iscr: iscr,
  	Iscr: Iscr,
  	isin: isin,
  	isindot: isindot,
  	isinE: isinE,
  	isins: isins,
  	isinsv: isinsv,
  	isinv: isinv,
  	it: it,
  	Itilde: Itilde,
  	itilde: itilde,
  	Iukcy: Iukcy,
  	iukcy: iukcy,
  	Iuml: Iuml,
  	iuml: iuml,
  	Jcirc: Jcirc,
  	jcirc: jcirc,
  	Jcy: Jcy,
  	jcy: jcy,
  	Jfr: Jfr,
  	jfr: jfr,
  	jmath: jmath,
  	Jopf: Jopf,
  	jopf: jopf,
  	Jscr: Jscr,
  	jscr: jscr,
  	Jsercy: Jsercy,
  	jsercy: jsercy,
  	Jukcy: Jukcy,
  	jukcy: jukcy,
  	Kappa: Kappa,
  	kappa: kappa,
  	kappav: kappav,
  	Kcedil: Kcedil,
  	kcedil: kcedil,
  	Kcy: Kcy,
  	kcy: kcy,
  	Kfr: Kfr,
  	kfr: kfr,
  	kgreen: kgreen,
  	KHcy: KHcy,
  	khcy: khcy,
  	KJcy: KJcy,
  	kjcy: kjcy,
  	Kopf: Kopf,
  	kopf: kopf,
  	Kscr: Kscr,
  	kscr: kscr,
  	lAarr: lAarr,
  	Lacute: Lacute,
  	lacute: lacute,
  	laemptyv: laemptyv,
  	lagran: lagran,
  	Lambda: Lambda,
  	lambda: lambda,
  	lang: lang,
  	Lang: Lang,
  	langd: langd,
  	langle: langle,
  	lap: lap,
  	Laplacetrf: Laplacetrf,
  	laquo: laquo,
  	larrb: larrb,
  	larrbfs: larrbfs,
  	larr: larr,
  	Larr: Larr,
  	lArr: lArr,
  	larrfs: larrfs,
  	larrhk: larrhk,
  	larrlp: larrlp,
  	larrpl: larrpl,
  	larrsim: larrsim,
  	larrtl: larrtl,
  	latail: latail,
  	lAtail: lAtail,
  	lat: lat,
  	late: late,
  	lates: lates,
  	lbarr: lbarr,
  	lBarr: lBarr,
  	lbbrk: lbbrk,
  	lbrace: lbrace,
  	lbrack: lbrack,
  	lbrke: lbrke,
  	lbrksld: lbrksld,
  	lbrkslu: lbrkslu,
  	Lcaron: Lcaron,
  	lcaron: lcaron,
  	Lcedil: Lcedil,
  	lcedil: lcedil,
  	lceil: lceil,
  	lcub: lcub,
  	Lcy: Lcy,
  	lcy: lcy,
  	ldca: ldca,
  	ldquo: ldquo,
  	ldquor: ldquor,
  	ldrdhar: ldrdhar,
  	ldrushar: ldrushar,
  	ldsh: ldsh,
  	le: le,
  	lE: lE,
  	LeftAngleBracket: LeftAngleBracket,
  	LeftArrowBar: LeftArrowBar,
  	leftarrow: leftarrow,
  	LeftArrow: LeftArrow,
  	Leftarrow: Leftarrow,
  	LeftArrowRightArrow: LeftArrowRightArrow,
  	leftarrowtail: leftarrowtail,
  	LeftCeiling: LeftCeiling,
  	LeftDoubleBracket: LeftDoubleBracket,
  	LeftDownTeeVector: LeftDownTeeVector,
  	LeftDownVectorBar: LeftDownVectorBar,
  	LeftDownVector: LeftDownVector,
  	LeftFloor: LeftFloor,
  	leftharpoondown: leftharpoondown,
  	leftharpoonup: leftharpoonup,
  	leftleftarrows: leftleftarrows,
  	leftrightarrow: leftrightarrow,
  	LeftRightArrow: LeftRightArrow,
  	Leftrightarrow: Leftrightarrow,
  	leftrightarrows: leftrightarrows,
  	leftrightharpoons: leftrightharpoons,
  	leftrightsquigarrow: leftrightsquigarrow,
  	LeftRightVector: LeftRightVector,
  	LeftTeeArrow: LeftTeeArrow,
  	LeftTee: LeftTee,
  	LeftTeeVector: LeftTeeVector,
  	leftthreetimes: leftthreetimes,
  	LeftTriangleBar: LeftTriangleBar,
  	LeftTriangle: LeftTriangle,
  	LeftTriangleEqual: LeftTriangleEqual,
  	LeftUpDownVector: LeftUpDownVector,
  	LeftUpTeeVector: LeftUpTeeVector,
  	LeftUpVectorBar: LeftUpVectorBar,
  	LeftUpVector: LeftUpVector,
  	LeftVectorBar: LeftVectorBar,
  	LeftVector: LeftVector,
  	lEg: lEg,
  	leg: leg,
  	leq: leq,
  	leqq: leqq,
  	leqslant: leqslant,
  	lescc: lescc,
  	les: les,
  	lesdot: lesdot,
  	lesdoto: lesdoto,
  	lesdotor: lesdotor,
  	lesg: lesg,
  	lesges: lesges,
  	lessapprox: lessapprox,
  	lessdot: lessdot,
  	lesseqgtr: lesseqgtr,
  	lesseqqgtr: lesseqqgtr,
  	LessEqualGreater: LessEqualGreater,
  	LessFullEqual: LessFullEqual,
  	LessGreater: LessGreater,
  	lessgtr: lessgtr,
  	LessLess: LessLess,
  	lesssim: lesssim,
  	LessSlantEqual: LessSlantEqual,
  	LessTilde: LessTilde,
  	lfisht: lfisht,
  	lfloor: lfloor,
  	Lfr: Lfr,
  	lfr: lfr,
  	lg: lg,
  	lgE: lgE,
  	lHar: lHar,
  	lhard: lhard,
  	lharu: lharu,
  	lharul: lharul,
  	lhblk: lhblk,
  	LJcy: LJcy,
  	ljcy: ljcy,
  	llarr: llarr,
  	ll: ll,
  	Ll: Ll,
  	llcorner: llcorner,
  	Lleftarrow: Lleftarrow,
  	llhard: llhard,
  	lltri: lltri,
  	Lmidot: Lmidot,
  	lmidot: lmidot,
  	lmoustache: lmoustache,
  	lmoust: lmoust,
  	lnap: lnap,
  	lnapprox: lnapprox,
  	lne: lne,
  	lnE: lnE,
  	lneq: lneq,
  	lneqq: lneqq,
  	lnsim: lnsim,
  	loang: loang,
  	loarr: loarr,
  	lobrk: lobrk,
  	longleftarrow: longleftarrow,
  	LongLeftArrow: LongLeftArrow,
  	Longleftarrow: Longleftarrow,
  	longleftrightarrow: longleftrightarrow,
  	LongLeftRightArrow: LongLeftRightArrow,
  	Longleftrightarrow: Longleftrightarrow,
  	longmapsto: longmapsto,
  	longrightarrow: longrightarrow,
  	LongRightArrow: LongRightArrow,
  	Longrightarrow: Longrightarrow,
  	looparrowleft: looparrowleft,
  	looparrowright: looparrowright,
  	lopar: lopar,
  	Lopf: Lopf,
  	lopf: lopf,
  	loplus: loplus,
  	lotimes: lotimes,
  	lowast: lowast,
  	lowbar: lowbar,
  	LowerLeftArrow: LowerLeftArrow,
  	LowerRightArrow: LowerRightArrow,
  	loz: loz,
  	lozenge: lozenge,
  	lozf: lozf,
  	lpar: lpar,
  	lparlt: lparlt,
  	lrarr: lrarr,
  	lrcorner: lrcorner,
  	lrhar: lrhar,
  	lrhard: lrhard,
  	lrm: lrm,
  	lrtri: lrtri,
  	lsaquo: lsaquo,
  	lscr: lscr,
  	Lscr: Lscr,
  	lsh: lsh,
  	Lsh: Lsh,
  	lsim: lsim,
  	lsime: lsime,
  	lsimg: lsimg,
  	lsqb: lsqb,
  	lsquo: lsquo,
  	lsquor: lsquor,
  	Lstrok: Lstrok,
  	lstrok: lstrok,
  	ltcc: ltcc,
  	ltcir: ltcir,
  	lt: lt,
  	LT: LT$1,
  	Lt: Lt,
  	ltdot: ltdot,
  	lthree: lthree,
  	ltimes: ltimes,
  	ltlarr: ltlarr,
  	ltquest: ltquest,
  	ltri: ltri,
  	ltrie: ltrie,
  	ltrif: ltrif,
  	ltrPar: ltrPar,
  	lurdshar: lurdshar,
  	luruhar: luruhar,
  	lvertneqq: lvertneqq,
  	lvnE: lvnE,
  	macr: macr,
  	male: male,
  	malt: malt,
  	maltese: maltese,
  	"Map": "⤅",
  	map: map$1,
  	mapsto: mapsto,
  	mapstodown: mapstodown,
  	mapstoleft: mapstoleft,
  	mapstoup: mapstoup,
  	marker: marker,
  	mcomma: mcomma,
  	Mcy: Mcy,
  	mcy: mcy,
  	mdash: mdash,
  	mDDot: mDDot,
  	measuredangle: measuredangle,
  	MediumSpace: MediumSpace,
  	Mellintrf: Mellintrf,
  	Mfr: Mfr,
  	mfr: mfr,
  	mho: mho,
  	micro: micro,
  	midast: midast,
  	midcir: midcir,
  	mid: mid,
  	middot: middot,
  	minusb: minusb,
  	minus: minus,
  	minusd: minusd,
  	minusdu: minusdu,
  	MinusPlus: MinusPlus,
  	mlcp: mlcp,
  	mldr: mldr,
  	mnplus: mnplus,
  	models: models,
  	Mopf: Mopf,
  	mopf: mopf,
  	mp: mp,
  	mscr: mscr,
  	Mscr: Mscr,
  	mstpos: mstpos,
  	Mu: Mu,
  	mu: mu,
  	multimap: multimap,
  	mumap: mumap,
  	nabla: nabla,
  	Nacute: Nacute,
  	nacute: nacute,
  	nang: nang,
  	nap: nap,
  	napE: napE,
  	napid: napid,
  	napos: napos,
  	napprox: napprox,
  	natural: natural,
  	naturals: naturals,
  	natur: natur,
  	nbsp: nbsp,
  	nbump: nbump,
  	nbumpe: nbumpe,
  	ncap: ncap,
  	Ncaron: Ncaron,
  	ncaron: ncaron,
  	Ncedil: Ncedil,
  	ncedil: ncedil,
  	ncong: ncong,
  	ncongdot: ncongdot,
  	ncup: ncup,
  	Ncy: Ncy,
  	ncy: ncy,
  	ndash: ndash,
  	nearhk: nearhk,
  	nearr: nearr,
  	neArr: neArr,
  	nearrow: nearrow,
  	ne: ne,
  	nedot: nedot,
  	NegativeMediumSpace: NegativeMediumSpace,
  	NegativeThickSpace: NegativeThickSpace,
  	NegativeThinSpace: NegativeThinSpace,
  	NegativeVeryThinSpace: NegativeVeryThinSpace,
  	nequiv: nequiv,
  	nesear: nesear,
  	nesim: nesim,
  	NestedGreaterGreater: NestedGreaterGreater,
  	NestedLessLess: NestedLessLess,
  	NewLine: NewLine,
  	nexist: nexist,
  	nexists: nexists,
  	Nfr: Nfr,
  	nfr: nfr,
  	ngE: ngE,
  	nge: nge,
  	ngeq: ngeq,
  	ngeqq: ngeqq,
  	ngeqslant: ngeqslant,
  	nges: nges,
  	nGg: nGg,
  	ngsim: ngsim,
  	nGt: nGt,
  	ngt: ngt,
  	ngtr: ngtr,
  	nGtv: nGtv,
  	nharr: nharr,
  	nhArr: nhArr,
  	nhpar: nhpar,
  	ni: ni,
  	nis: nis,
  	nisd: nisd,
  	niv: niv,
  	NJcy: NJcy,
  	njcy: njcy,
  	nlarr: nlarr,
  	nlArr: nlArr,
  	nldr: nldr,
  	nlE: nlE,
  	nle: nle,
  	nleftarrow: nleftarrow,
  	nLeftarrow: nLeftarrow,
  	nleftrightarrow: nleftrightarrow,
  	nLeftrightarrow: nLeftrightarrow,
  	nleq: nleq,
  	nleqq: nleqq,
  	nleqslant: nleqslant,
  	nles: nles,
  	nless: nless,
  	nLl: nLl,
  	nlsim: nlsim,
  	nLt: nLt,
  	nlt: nlt,
  	nltri: nltri,
  	nltrie: nltrie,
  	nLtv: nLtv,
  	nmid: nmid,
  	NoBreak: NoBreak,
  	NonBreakingSpace: NonBreakingSpace,
  	nopf: nopf,
  	Nopf: Nopf,
  	Not: Not,
  	not: not,
  	NotCongruent: NotCongruent,
  	NotCupCap: NotCupCap,
  	NotDoubleVerticalBar: NotDoubleVerticalBar,
  	NotElement: NotElement,
  	NotEqual: NotEqual,
  	NotEqualTilde: NotEqualTilde,
  	NotExists: NotExists,
  	NotGreater: NotGreater,
  	NotGreaterEqual: NotGreaterEqual,
  	NotGreaterFullEqual: NotGreaterFullEqual,
  	NotGreaterGreater: NotGreaterGreater,
  	NotGreaterLess: NotGreaterLess,
  	NotGreaterSlantEqual: NotGreaterSlantEqual,
  	NotGreaterTilde: NotGreaterTilde,
  	NotHumpDownHump: NotHumpDownHump,
  	NotHumpEqual: NotHumpEqual,
  	notin: notin,
  	notindot: notindot,
  	notinE: notinE,
  	notinva: notinva,
  	notinvb: notinvb,
  	notinvc: notinvc,
  	NotLeftTriangleBar: NotLeftTriangleBar,
  	NotLeftTriangle: NotLeftTriangle,
  	NotLeftTriangleEqual: NotLeftTriangleEqual,
  	NotLess: NotLess,
  	NotLessEqual: NotLessEqual,
  	NotLessGreater: NotLessGreater,
  	NotLessLess: NotLessLess,
  	NotLessSlantEqual: NotLessSlantEqual,
  	NotLessTilde: NotLessTilde,
  	NotNestedGreaterGreater: NotNestedGreaterGreater,
  	NotNestedLessLess: NotNestedLessLess,
  	notni: notni,
  	notniva: notniva,
  	notnivb: notnivb,
  	notnivc: notnivc,
  	NotPrecedes: NotPrecedes,
  	NotPrecedesEqual: NotPrecedesEqual,
  	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
  	NotReverseElement: NotReverseElement,
  	NotRightTriangleBar: NotRightTriangleBar,
  	NotRightTriangle: NotRightTriangle,
  	NotRightTriangleEqual: NotRightTriangleEqual,
  	NotSquareSubset: NotSquareSubset,
  	NotSquareSubsetEqual: NotSquareSubsetEqual,
  	NotSquareSuperset: NotSquareSuperset,
  	NotSquareSupersetEqual: NotSquareSupersetEqual,
  	NotSubset: NotSubset,
  	NotSubsetEqual: NotSubsetEqual,
  	NotSucceeds: NotSucceeds,
  	NotSucceedsEqual: NotSucceedsEqual,
  	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
  	NotSucceedsTilde: NotSucceedsTilde,
  	NotSuperset: NotSuperset,
  	NotSupersetEqual: NotSupersetEqual,
  	NotTilde: NotTilde,
  	NotTildeEqual: NotTildeEqual,
  	NotTildeFullEqual: NotTildeFullEqual,
  	NotTildeTilde: NotTildeTilde,
  	NotVerticalBar: NotVerticalBar,
  	nparallel: nparallel,
  	npar: npar,
  	nparsl: nparsl,
  	npart: npart,
  	npolint: npolint,
  	npr: npr,
  	nprcue: nprcue,
  	nprec: nprec,
  	npreceq: npreceq,
  	npre: npre,
  	nrarrc: nrarrc,
  	nrarr: nrarr,
  	nrArr: nrArr,
  	nrarrw: nrarrw,
  	nrightarrow: nrightarrow,
  	nRightarrow: nRightarrow,
  	nrtri: nrtri,
  	nrtrie: nrtrie,
  	nsc: nsc,
  	nsccue: nsccue,
  	nsce: nsce,
  	Nscr: Nscr,
  	nscr: nscr,
  	nshortmid: nshortmid,
  	nshortparallel: nshortparallel,
  	nsim: nsim,
  	nsime: nsime,
  	nsimeq: nsimeq,
  	nsmid: nsmid,
  	nspar: nspar,
  	nsqsube: nsqsube,
  	nsqsupe: nsqsupe,
  	nsub: nsub,
  	nsubE: nsubE,
  	nsube: nsube,
  	nsubset: nsubset,
  	nsubseteq: nsubseteq,
  	nsubseteqq: nsubseteqq,
  	nsucc: nsucc,
  	nsucceq: nsucceq,
  	nsup: nsup,
  	nsupE: nsupE,
  	nsupe: nsupe,
  	nsupset: nsupset,
  	nsupseteq: nsupseteq,
  	nsupseteqq: nsupseteqq,
  	ntgl: ntgl,
  	Ntilde: Ntilde,
  	ntilde: ntilde,
  	ntlg: ntlg,
  	ntriangleleft: ntriangleleft,
  	ntrianglelefteq: ntrianglelefteq,
  	ntriangleright: ntriangleright,
  	ntrianglerighteq: ntrianglerighteq,
  	Nu: Nu,
  	nu: nu,
  	num: num,
  	numero: numero,
  	numsp: numsp,
  	nvap: nvap,
  	nvdash: nvdash,
  	nvDash: nvDash,
  	nVdash: nVdash,
  	nVDash: nVDash,
  	nvge: nvge,
  	nvgt: nvgt,
  	nvHarr: nvHarr,
  	nvinfin: nvinfin,
  	nvlArr: nvlArr,
  	nvle: nvle,
  	nvlt: nvlt,
  	nvltrie: nvltrie,
  	nvrArr: nvrArr,
  	nvrtrie: nvrtrie,
  	nvsim: nvsim,
  	nwarhk: nwarhk,
  	nwarr: nwarr,
  	nwArr: nwArr,
  	nwarrow: nwarrow,
  	nwnear: nwnear,
  	Oacute: Oacute,
  	oacute: oacute,
  	oast: oast,
  	Ocirc: Ocirc,
  	ocirc: ocirc,
  	ocir: ocir,
  	Ocy: Ocy,
  	ocy: ocy,
  	odash: odash,
  	Odblac: Odblac,
  	odblac: odblac,
  	odiv: odiv,
  	odot: odot,
  	odsold: odsold,
  	OElig: OElig,
  	oelig: oelig,
  	ofcir: ofcir,
  	Ofr: Ofr,
  	ofr: ofr,
  	ogon: ogon,
  	Ograve: Ograve,
  	ograve: ograve,
  	ogt: ogt,
  	ohbar: ohbar,
  	ohm: ohm,
  	oint: oint,
  	olarr: olarr,
  	olcir: olcir,
  	olcross: olcross,
  	oline: oline,
  	olt: olt,
  	Omacr: Omacr,
  	omacr: omacr,
  	Omega: Omega,
  	omega: omega,
  	Omicron: Omicron,
  	omicron: omicron,
  	omid: omid,
  	ominus: ominus,
  	Oopf: Oopf,
  	oopf: oopf,
  	opar: opar,
  	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
  	OpenCurlyQuote: OpenCurlyQuote,
  	operp: operp,
  	oplus: oplus,
  	orarr: orarr,
  	Or: Or,
  	or: or,
  	ord: ord,
  	order: order,
  	orderof: orderof,
  	ordf: ordf,
  	ordm: ordm,
  	origof: origof,
  	oror: oror,
  	orslope: orslope,
  	orv: orv,
  	oS: oS,
  	Oscr: Oscr,
  	oscr: oscr,
  	Oslash: Oslash,
  	oslash: oslash,
  	osol: osol,
  	Otilde: Otilde,
  	otilde: otilde,
  	otimesas: otimesas,
  	Otimes: Otimes,
  	otimes: otimes,
  	Ouml: Ouml,
  	ouml: ouml,
  	ovbar: ovbar,
  	OverBar: OverBar,
  	OverBrace: OverBrace,
  	OverBracket: OverBracket,
  	OverParenthesis: OverParenthesis,
  	para: para,
  	parallel: parallel,
  	par: par,
  	parsim: parsim,
  	parsl: parsl,
  	part: part,
  	PartialD: PartialD,
  	Pcy: Pcy,
  	pcy: pcy,
  	percnt: percnt,
  	period: period,
  	permil: permil,
  	perp: perp,
  	pertenk: pertenk,
  	Pfr: Pfr,
  	pfr: pfr,
  	Phi: Phi,
  	phi: phi,
  	phiv: phiv,
  	phmmat: phmmat,
  	phone: phone,
  	Pi: Pi,
  	pi: pi,
  	pitchfork: pitchfork,
  	piv: piv,
  	planck: planck,
  	planckh: planckh,
  	plankv: plankv,
  	plusacir: plusacir,
  	plusb: plusb,
  	pluscir: pluscir,
  	plus: plus,
  	plusdo: plusdo,
  	plusdu: plusdu,
  	pluse: pluse,
  	PlusMinus: PlusMinus,
  	plusmn: plusmn,
  	plussim: plussim,
  	plustwo: plustwo,
  	pm: pm,
  	Poincareplane: Poincareplane,
  	pointint: pointint,
  	popf: popf,
  	Popf: Popf,
  	pound: pound,
  	prap: prap,
  	Pr: Pr,
  	pr: pr,
  	prcue: prcue,
  	precapprox: precapprox,
  	prec: prec,
  	preccurlyeq: preccurlyeq,
  	Precedes: Precedes,
  	PrecedesEqual: PrecedesEqual,
  	PrecedesSlantEqual: PrecedesSlantEqual,
  	PrecedesTilde: PrecedesTilde,
  	preceq: preceq,
  	precnapprox: precnapprox,
  	precneqq: precneqq,
  	precnsim: precnsim,
  	pre: pre,
  	prE: prE,
  	precsim: precsim,
  	prime: prime,
  	Prime: Prime,
  	primes: primes,
  	prnap: prnap,
  	prnE: prnE,
  	prnsim: prnsim,
  	prod: prod,
  	Product: Product,
  	profalar: profalar,
  	profline: profline,
  	profsurf: profsurf,
  	prop: prop,
  	Proportional: Proportional,
  	Proportion: Proportion,
  	propto: propto,
  	prsim: prsim,
  	prurel: prurel,
  	Pscr: Pscr,
  	pscr: pscr,
  	Psi: Psi,
  	psi: psi,
  	puncsp: puncsp,
  	Qfr: Qfr,
  	qfr: qfr,
  	qint: qint,
  	qopf: qopf,
  	Qopf: Qopf,
  	qprime: qprime,
  	Qscr: Qscr,
  	qscr: qscr,
  	quaternions: quaternions,
  	quatint: quatint,
  	quest: quest,
  	questeq: questeq,
  	quot: quot,
  	QUOT: QUOT,
  	rAarr: rAarr,
  	race: race,
  	Racute: Racute,
  	racute: racute,
  	radic: radic,
  	raemptyv: raemptyv,
  	rang: rang,
  	Rang: Rang,
  	rangd: rangd,
  	range: range,
  	rangle: rangle,
  	raquo: raquo,
  	rarrap: rarrap,
  	rarrb: rarrb,
  	rarrbfs: rarrbfs,
  	rarrc: rarrc,
  	rarr: rarr,
  	Rarr: Rarr,
  	rArr: rArr,
  	rarrfs: rarrfs,
  	rarrhk: rarrhk,
  	rarrlp: rarrlp,
  	rarrpl: rarrpl,
  	rarrsim: rarrsim,
  	Rarrtl: Rarrtl,
  	rarrtl: rarrtl,
  	rarrw: rarrw,
  	ratail: ratail,
  	rAtail: rAtail,
  	ratio: ratio,
  	rationals: rationals,
  	rbarr: rbarr,
  	rBarr: rBarr,
  	RBarr: RBarr,
  	rbbrk: rbbrk,
  	rbrace: rbrace,
  	rbrack: rbrack,
  	rbrke: rbrke,
  	rbrksld: rbrksld,
  	rbrkslu: rbrkslu,
  	Rcaron: Rcaron,
  	rcaron: rcaron,
  	Rcedil: Rcedil,
  	rcedil: rcedil,
  	rceil: rceil,
  	rcub: rcub,
  	Rcy: Rcy,
  	rcy: rcy,
  	rdca: rdca,
  	rdldhar: rdldhar,
  	rdquo: rdquo,
  	rdquor: rdquor,
  	rdsh: rdsh,
  	real: real,
  	realine: realine,
  	realpart: realpart,
  	reals: reals,
  	Re: Re,
  	rect: rect,
  	reg: reg,
  	REG: REG,
  	ReverseElement: ReverseElement,
  	ReverseEquilibrium: ReverseEquilibrium,
  	ReverseUpEquilibrium: ReverseUpEquilibrium,
  	rfisht: rfisht,
  	rfloor: rfloor,
  	rfr: rfr,
  	Rfr: Rfr,
  	rHar: rHar,
  	rhard: rhard,
  	rharu: rharu,
  	rharul: rharul,
  	Rho: Rho,
  	rho: rho,
  	rhov: rhov,
  	RightAngleBracket: RightAngleBracket,
  	RightArrowBar: RightArrowBar,
  	rightarrow: rightarrow,
  	RightArrow: RightArrow,
  	Rightarrow: Rightarrow,
  	RightArrowLeftArrow: RightArrowLeftArrow,
  	rightarrowtail: rightarrowtail,
  	RightCeiling: RightCeiling,
  	RightDoubleBracket: RightDoubleBracket,
  	RightDownTeeVector: RightDownTeeVector,
  	RightDownVectorBar: RightDownVectorBar,
  	RightDownVector: RightDownVector,
  	RightFloor: RightFloor,
  	rightharpoondown: rightharpoondown,
  	rightharpoonup: rightharpoonup,
  	rightleftarrows: rightleftarrows,
  	rightleftharpoons: rightleftharpoons,
  	rightrightarrows: rightrightarrows,
  	rightsquigarrow: rightsquigarrow,
  	RightTeeArrow: RightTeeArrow,
  	RightTee: RightTee,
  	RightTeeVector: RightTeeVector,
  	rightthreetimes: rightthreetimes,
  	RightTriangleBar: RightTriangleBar,
  	RightTriangle: RightTriangle,
  	RightTriangleEqual: RightTriangleEqual,
  	RightUpDownVector: RightUpDownVector,
  	RightUpTeeVector: RightUpTeeVector,
  	RightUpVectorBar: RightUpVectorBar,
  	RightUpVector: RightUpVector,
  	RightVectorBar: RightVectorBar,
  	RightVector: RightVector,
  	ring: ring,
  	risingdotseq: risingdotseq,
  	rlarr: rlarr,
  	rlhar: rlhar,
  	rlm: rlm,
  	rmoustache: rmoustache,
  	rmoust: rmoust,
  	rnmid: rnmid,
  	roang: roang,
  	roarr: roarr,
  	robrk: robrk,
  	ropar: ropar,
  	ropf: ropf,
  	Ropf: Ropf,
  	roplus: roplus,
  	rotimes: rotimes,
  	RoundImplies: RoundImplies,
  	rpar: rpar,
  	rpargt: rpargt,
  	rppolint: rppolint,
  	rrarr: rrarr,
  	Rrightarrow: Rrightarrow,
  	rsaquo: rsaquo,
  	rscr: rscr,
  	Rscr: Rscr,
  	rsh: rsh,
  	Rsh: Rsh,
  	rsqb: rsqb,
  	rsquo: rsquo,
  	rsquor: rsquor,
  	rthree: rthree,
  	rtimes: rtimes,
  	rtri: rtri,
  	rtrie: rtrie,
  	rtrif: rtrif,
  	rtriltri: rtriltri,
  	RuleDelayed: RuleDelayed,
  	ruluhar: ruluhar,
  	rx: rx,
  	Sacute: Sacute,
  	sacute: sacute,
  	sbquo: sbquo,
  	scap: scap,
  	Scaron: Scaron,
  	scaron: scaron,
  	Sc: Sc,
  	sc: sc,
  	sccue: sccue,
  	sce: sce,
  	scE: scE,
  	Scedil: Scedil,
  	scedil: scedil,
  	Scirc: Scirc,
  	scirc: scirc,
  	scnap: scnap,
  	scnE: scnE,
  	scnsim: scnsim,
  	scpolint: scpolint,
  	scsim: scsim,
  	Scy: Scy,
  	scy: scy,
  	sdotb: sdotb,
  	sdot: sdot,
  	sdote: sdote,
  	searhk: searhk,
  	searr: searr,
  	seArr: seArr,
  	searrow: searrow,
  	sect: sect,
  	semi: semi,
  	seswar: seswar,
  	setminus: setminus,
  	setmn: setmn,
  	sext: sext,
  	Sfr: Sfr,
  	sfr: sfr,
  	sfrown: sfrown,
  	sharp: sharp,
  	SHCHcy: SHCHcy,
  	shchcy: shchcy,
  	SHcy: SHcy,
  	shcy: shcy,
  	ShortDownArrow: ShortDownArrow,
  	ShortLeftArrow: ShortLeftArrow,
  	shortmid: shortmid,
  	shortparallel: shortparallel,
  	ShortRightArrow: ShortRightArrow,
  	ShortUpArrow: ShortUpArrow,
  	shy: shy,
  	Sigma: Sigma,
  	sigma: sigma,
  	sigmaf: sigmaf,
  	sigmav: sigmav,
  	sim: sim,
  	simdot: simdot,
  	sime: sime,
  	simeq: simeq,
  	simg: simg,
  	simgE: simgE,
  	siml: siml,
  	simlE: simlE,
  	simne: simne,
  	simplus: simplus,
  	simrarr: simrarr,
  	slarr: slarr,
  	SmallCircle: SmallCircle,
  	smallsetminus: smallsetminus,
  	smashp: smashp,
  	smeparsl: smeparsl,
  	smid: smid,
  	smile: smile,
  	smt: smt,
  	smte: smte,
  	smtes: smtes,
  	SOFTcy: SOFTcy,
  	softcy: softcy,
  	solbar: solbar,
  	solb: solb,
  	sol: sol,
  	Sopf: Sopf,
  	sopf: sopf,
  	spades: spades,
  	spadesuit: spadesuit,
  	spar: spar,
  	sqcap: sqcap,
  	sqcaps: sqcaps,
  	sqcup: sqcup,
  	sqcups: sqcups,
  	Sqrt: Sqrt,
  	sqsub: sqsub,
  	sqsube: sqsube,
  	sqsubset: sqsubset,
  	sqsubseteq: sqsubseteq,
  	sqsup: sqsup,
  	sqsupe: sqsupe,
  	sqsupset: sqsupset,
  	sqsupseteq: sqsupseteq,
  	square: square,
  	Square: Square,
  	SquareIntersection: SquareIntersection,
  	SquareSubset: SquareSubset,
  	SquareSubsetEqual: SquareSubsetEqual,
  	SquareSuperset: SquareSuperset,
  	SquareSupersetEqual: SquareSupersetEqual,
  	SquareUnion: SquareUnion,
  	squarf: squarf,
  	squ: squ,
  	squf: squf,
  	srarr: srarr,
  	Sscr: Sscr,
  	sscr: sscr,
  	ssetmn: ssetmn,
  	ssmile: ssmile,
  	sstarf: sstarf,
  	Star: Star,
  	star: star,
  	starf: starf,
  	straightepsilon: straightepsilon,
  	straightphi: straightphi,
  	strns: strns,
  	sub: sub,
  	Sub: Sub,
  	subdot: subdot,
  	subE: subE,
  	sube: sube,
  	subedot: subedot,
  	submult: submult,
  	subnE: subnE,
  	subne: subne,
  	subplus: subplus,
  	subrarr: subrarr,
  	subset: subset,
  	Subset: Subset,
  	subseteq: subseteq,
  	subseteqq: subseteqq,
  	SubsetEqual: SubsetEqual,
  	subsetneq: subsetneq,
  	subsetneqq: subsetneqq,
  	subsim: subsim,
  	subsub: subsub,
  	subsup: subsup,
  	succapprox: succapprox,
  	succ: succ,
  	succcurlyeq: succcurlyeq,
  	Succeeds: Succeeds,
  	SucceedsEqual: SucceedsEqual,
  	SucceedsSlantEqual: SucceedsSlantEqual,
  	SucceedsTilde: SucceedsTilde,
  	succeq: succeq,
  	succnapprox: succnapprox,
  	succneqq: succneqq,
  	succnsim: succnsim,
  	succsim: succsim,
  	SuchThat: SuchThat,
  	sum: sum,
  	Sum: Sum,
  	sung: sung,
  	sup1: sup1,
  	sup2: sup2,
  	sup3: sup3,
  	sup: sup,
  	Sup: Sup,
  	supdot: supdot,
  	supdsub: supdsub,
  	supE: supE,
  	supe: supe,
  	supedot: supedot,
  	Superset: Superset,
  	SupersetEqual: SupersetEqual,
  	suphsol: suphsol,
  	suphsub: suphsub,
  	suplarr: suplarr,
  	supmult: supmult,
  	supnE: supnE,
  	supne: supne,
  	supplus: supplus,
  	supset: supset,
  	Supset: Supset,
  	supseteq: supseteq,
  	supseteqq: supseteqq,
  	supsetneq: supsetneq,
  	supsetneqq: supsetneqq,
  	supsim: supsim,
  	supsub: supsub,
  	supsup: supsup,
  	swarhk: swarhk,
  	swarr: swarr,
  	swArr: swArr,
  	swarrow: swarrow,
  	swnwar: swnwar,
  	szlig: szlig,
  	Tab: Tab,
  	target: target,
  	Tau: Tau,
  	tau: tau,
  	tbrk: tbrk,
  	Tcaron: Tcaron,
  	tcaron: tcaron,
  	Tcedil: Tcedil,
  	tcedil: tcedil,
  	Tcy: Tcy,
  	tcy: tcy,
  	tdot: tdot,
  	telrec: telrec,
  	Tfr: Tfr,
  	tfr: tfr,
  	there4: there4,
  	therefore: therefore,
  	Therefore: Therefore,
  	Theta: Theta,
  	theta: theta,
  	thetasym: thetasym,
  	thetav: thetav,
  	thickapprox: thickapprox,
  	thicksim: thicksim,
  	ThickSpace: ThickSpace,
  	ThinSpace: ThinSpace,
  	thinsp: thinsp,
  	thkap: thkap,
  	thksim: thksim,
  	THORN: THORN,
  	thorn: thorn,
  	tilde: tilde,
  	Tilde: Tilde,
  	TildeEqual: TildeEqual,
  	TildeFullEqual: TildeFullEqual,
  	TildeTilde: TildeTilde,
  	timesbar: timesbar,
  	timesb: timesb,
  	times: times,
  	timesd: timesd,
  	tint: tint,
  	toea: toea,
  	topbot: topbot,
  	topcir: topcir,
  	top: top,
  	Topf: Topf,
  	topf: topf,
  	topfork: topfork,
  	tosa: tosa,
  	tprime: tprime,
  	trade: trade,
  	TRADE: TRADE,
  	triangle: triangle,
  	triangledown: triangledown,
  	triangleleft: triangleleft,
  	trianglelefteq: trianglelefteq,
  	triangleq: triangleq,
  	triangleright: triangleright,
  	trianglerighteq: trianglerighteq,
  	tridot: tridot,
  	trie: trie,
  	triminus: triminus,
  	TripleDot: TripleDot,
  	triplus: triplus,
  	trisb: trisb,
  	tritime: tritime,
  	trpezium: trpezium,
  	Tscr: Tscr,
  	tscr: tscr,
  	TScy: TScy,
  	tscy: tscy,
  	TSHcy: TSHcy,
  	tshcy: tshcy,
  	Tstrok: Tstrok,
  	tstrok: tstrok,
  	twixt: twixt,
  	twoheadleftarrow: twoheadleftarrow,
  	twoheadrightarrow: twoheadrightarrow,
  	Uacute: Uacute,
  	uacute: uacute,
  	uarr: uarr,
  	Uarr: Uarr,
  	uArr: uArr,
  	Uarrocir: Uarrocir,
  	Ubrcy: Ubrcy,
  	ubrcy: ubrcy,
  	Ubreve: Ubreve,
  	ubreve: ubreve,
  	Ucirc: Ucirc,
  	ucirc: ucirc,
  	Ucy: Ucy,
  	ucy: ucy,
  	udarr: udarr,
  	Udblac: Udblac,
  	udblac: udblac,
  	udhar: udhar,
  	ufisht: ufisht,
  	Ufr: Ufr,
  	ufr: ufr,
  	Ugrave: Ugrave,
  	ugrave: ugrave,
  	uHar: uHar,
  	uharl: uharl,
  	uharr: uharr,
  	uhblk: uhblk,
  	ulcorn: ulcorn,
  	ulcorner: ulcorner,
  	ulcrop: ulcrop,
  	ultri: ultri,
  	Umacr: Umacr,
  	umacr: umacr,
  	uml: uml,
  	UnderBar: UnderBar,
  	UnderBrace: UnderBrace,
  	UnderBracket: UnderBracket,
  	UnderParenthesis: UnderParenthesis,
  	Union: Union,
  	UnionPlus: UnionPlus,
  	Uogon: Uogon,
  	uogon: uogon,
  	Uopf: Uopf,
  	uopf: uopf,
  	UpArrowBar: UpArrowBar,
  	uparrow: uparrow,
  	UpArrow: UpArrow,
  	Uparrow: Uparrow,
  	UpArrowDownArrow: UpArrowDownArrow,
  	updownarrow: updownarrow,
  	UpDownArrow: UpDownArrow,
  	Updownarrow: Updownarrow,
  	UpEquilibrium: UpEquilibrium,
  	upharpoonleft: upharpoonleft,
  	upharpoonright: upharpoonright,
  	uplus: uplus,
  	UpperLeftArrow: UpperLeftArrow,
  	UpperRightArrow: UpperRightArrow,
  	upsi: upsi,
  	Upsi: Upsi,
  	upsih: upsih,
  	Upsilon: Upsilon,
  	upsilon: upsilon,
  	UpTeeArrow: UpTeeArrow,
  	UpTee: UpTee,
  	upuparrows: upuparrows,
  	urcorn: urcorn,
  	urcorner: urcorner,
  	urcrop: urcrop,
  	Uring: Uring,
  	uring: uring,
  	urtri: urtri,
  	Uscr: Uscr,
  	uscr: uscr,
  	utdot: utdot,
  	Utilde: Utilde,
  	utilde: utilde,
  	utri: utri,
  	utrif: utrif,
  	uuarr: uuarr,
  	Uuml: Uuml,
  	uuml: uuml,
  	uwangle: uwangle,
  	vangrt: vangrt,
  	varepsilon: varepsilon,
  	varkappa: varkappa,
  	varnothing: varnothing,
  	varphi: varphi,
  	varpi: varpi,
  	varpropto: varpropto,
  	varr: varr,
  	vArr: vArr,
  	varrho: varrho,
  	varsigma: varsigma,
  	varsubsetneq: varsubsetneq,
  	varsubsetneqq: varsubsetneqq,
  	varsupsetneq: varsupsetneq,
  	varsupsetneqq: varsupsetneqq,
  	vartheta: vartheta,
  	vartriangleleft: vartriangleleft,
  	vartriangleright: vartriangleright,
  	vBar: vBar,
  	Vbar: Vbar,
  	vBarv: vBarv,
  	Vcy: Vcy,
  	vcy: vcy,
  	vdash: vdash,
  	vDash: vDash,
  	Vdash: Vdash,
  	VDash: VDash,
  	Vdashl: Vdashl,
  	veebar: veebar,
  	vee: vee,
  	Vee: Vee,
  	veeeq: veeeq,
  	vellip: vellip,
  	verbar: verbar,
  	Verbar: Verbar,
  	vert: vert,
  	Vert: Vert,
  	VerticalBar: VerticalBar,
  	VerticalLine: VerticalLine,
  	VerticalSeparator: VerticalSeparator,
  	VerticalTilde: VerticalTilde,
  	VeryThinSpace: VeryThinSpace,
  	Vfr: Vfr,
  	vfr: vfr,
  	vltri: vltri,
  	vnsub: vnsub,
  	vnsup: vnsup,
  	Vopf: Vopf,
  	vopf: vopf,
  	vprop: vprop,
  	vrtri: vrtri,
  	Vscr: Vscr,
  	vscr: vscr,
  	vsubnE: vsubnE,
  	vsubne: vsubne,
  	vsupnE: vsupnE,
  	vsupne: vsupne,
  	Vvdash: Vvdash,
  	vzigzag: vzigzag,
  	Wcirc: Wcirc,
  	wcirc: wcirc,
  	wedbar: wedbar,
  	wedge: wedge,
  	Wedge: Wedge,
  	wedgeq: wedgeq,
  	weierp: weierp,
  	Wfr: Wfr,
  	wfr: wfr,
  	Wopf: Wopf,
  	wopf: wopf,
  	wp: wp,
  	wr: wr,
  	wreath: wreath,
  	Wscr: Wscr,
  	wscr: wscr,
  	xcap: xcap,
  	xcirc: xcirc,
  	xcup: xcup,
  	xdtri: xdtri,
  	Xfr: Xfr,
  	xfr: xfr,
  	xharr: xharr,
  	xhArr: xhArr,
  	Xi: Xi,
  	xi: xi,
  	xlarr: xlarr,
  	xlArr: xlArr,
  	xmap: xmap,
  	xnis: xnis,
  	xodot: xodot,
  	Xopf: Xopf,
  	xopf: xopf,
  	xoplus: xoplus,
  	xotime: xotime,
  	xrarr: xrarr,
  	xrArr: xrArr,
  	Xscr: Xscr,
  	xscr: xscr,
  	xsqcup: xsqcup,
  	xuplus: xuplus,
  	xutri: xutri,
  	xvee: xvee,
  	xwedge: xwedge,
  	Yacute: Yacute,
  	yacute: yacute,
  	YAcy: YAcy,
  	yacy: yacy,
  	Ycirc: Ycirc,
  	ycirc: ycirc,
  	Ycy: Ycy,
  	ycy: ycy,
  	yen: yen,
  	Yfr: Yfr,
  	yfr: yfr,
  	YIcy: YIcy,
  	yicy: yicy,
  	Yopf: Yopf,
  	yopf: yopf,
  	Yscr: Yscr,
  	yscr: yscr,
  	YUcy: YUcy,
  	yucy: yucy,
  	yuml: yuml,
  	Yuml: Yuml,
  	Zacute: Zacute,
  	zacute: zacute,
  	Zcaron: Zcaron,
  	zcaron: zcaron,
  	Zcy: Zcy,
  	zcy: zcy,
  	Zdot: Zdot,
  	zdot: zdot,
  	zeetrf: zeetrf,
  	ZeroWidthSpace: ZeroWidthSpace,
  	Zeta: Zeta,
  	zeta: zeta,
  	zfr: zfr,
  	Zfr: Zfr,
  	ZHcy: ZHcy,
  	zhcy: zhcy,
  	zigrarr: zigrarr,
  	zopf: zopf,
  	Zopf: Zopf,
  	Zscr: Zscr,
  	zscr: zscr,
  	zwj: zwj,
  	zwnj: zwnj
  };

  /*eslint quotes:0*/
  var entities$1 = require$$0$1;

  var regex$4=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

  var mdurl$1 = {};

  var encodeCache = {};


  // Create a lookup array where anything but characters in `chars` string
  // and alphanumeric chars is percent-encoded.
  //
  function getEncodeCache(exclude) {
    var i, ch, cache = encodeCache[exclude];
    if (cache) { return cache; }

    cache = encodeCache[exclude] = [];

    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);

      if (/^[0-9a-z]$/i.test(ch)) {
        // always allow unencoded alphanumeric characters
        cache.push(ch);
      } else {
        cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
      }
    }

    for (i = 0; i < exclude.length; i++) {
      cache[exclude.charCodeAt(i)] = exclude[i];
    }

    return cache;
  }


  // Encode unsafe characters with percent-encoding, skipping already
  // encoded sequences.
  //
  //  - string       - string to encode
  //  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
  //  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
  //
  function encode$1(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache,
        result = '';

    if (typeof exclude !== 'string') {
      // encode(string, keepEscaped)
      keepEscaped  = exclude;
      exclude = encode$1.defaultChars;
    }

    if (typeof keepEscaped === 'undefined') {
      keepEscaped = true;
    }

    cache = getEncodeCache(exclude);

    for (i = 0, l = string.length; i < l; i++) {
      code = string.charCodeAt(i);

      if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
        if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
          result += string.slice(i, i + 3);
          i += 2;
          continue;
        }
      }

      if (code < 128) {
        result += cache[code];
        continue;
      }

      if (code >= 0xD800 && code <= 0xDFFF) {
        if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
          nextCode = string.charCodeAt(i + 1);
          if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
            result += encodeURIComponent(string[i] + string[i + 1]);
            i++;
            continue;
          }
        }
        result += '%EF%BF%BD';
        continue;
      }

      result += encodeURIComponent(string[i]);
    }

    return result;
  }

  encode$1.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
  encode$1.componentChars = "-_.!~*'()";


  var encode_1 = encode$1;

  /* eslint-disable no-bitwise */

  var decodeCache = {};

  function getDecodeCache(exclude) {
    var i, ch, cache = decodeCache[exclude];
    if (cache) { return cache; }

    cache = decodeCache[exclude] = [];

    for (i = 0; i < 128; i++) {
      ch = String.fromCharCode(i);
      cache.push(ch);
    }

    for (i = 0; i < exclude.length; i++) {
      ch = exclude.charCodeAt(i);
      cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
    }

    return cache;
  }


  // Decode percent-encoded string.
  //
  function decode$3(string, exclude) {
    var cache;

    if (typeof exclude !== 'string') {
      exclude = decode$3.defaultChars;
    }

    cache = getDecodeCache(exclude);

    return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
      var i, l, b1, b2, b3, b4, chr,
          result = '';

      for (i = 0, l = seq.length; i < l; i += 3) {
        b1 = parseInt(seq.slice(i + 1, i + 3), 16);

        if (b1 < 0x80) {
          result += cache[b1];
          continue;
        }

        if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
          // 110xxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);

          if ((b2 & 0xC0) === 0x80) {
            chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

            if (chr < 0x80) {
              result += '\ufffd\ufffd';
            } else {
              result += String.fromCharCode(chr);
            }

            i += 3;
            continue;
          }
        }

        if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
          // 1110xxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);

          if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
            chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

            if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
              result += '\ufffd\ufffd\ufffd';
            } else {
              result += String.fromCharCode(chr);
            }

            i += 6;
            continue;
          }
        }

        if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
          // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
          b2 = parseInt(seq.slice(i + 4, i + 6), 16);
          b3 = parseInt(seq.slice(i + 7, i + 9), 16);
          b4 = parseInt(seq.slice(i + 10, i + 12), 16);

          if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
            chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

            if (chr < 0x10000 || chr > 0x10FFFF) {
              result += '\ufffd\ufffd\ufffd\ufffd';
            } else {
              chr -= 0x10000;
              result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
            }

            i += 9;
            continue;
          }
        }

        result += '\ufffd';
      }

      return result;
    });
  }


  decode$3.defaultChars   = ';/?:@&=+$,#';
  decode$3.componentChars = '';


  var decode_1 = decode$3;

  var format = function format(url) {
    var result = '';

    result += url.protocol || '';
    result += url.slashes ? '//' : '';
    result += url.auth ? url.auth + '@' : '';

    if (url.hostname && url.hostname.indexOf(':') !== -1) {
      // ipv6 address
      result += '[' + url.hostname + ']';
    } else {
      result += url.hostname || '';
    }

    result += url.port ? ':' + url.port : '';
    result += url.pathname || '';
    result += url.search || '';
    result += url.hash || '';

    return result;
  };

  //
  // Changes from joyent/node:
  //
  // 1. No leading slash in paths,
  //    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
  //
  // 2. Backslashes are not replaced with slashes,
  //    so `http:\\example.org\` is treated like a relative path
  //
  // 3. Trailing colon is treated like a part of the path,
  //    i.e. in `http://example.org:foo` pathname is `:foo`
  //
  // 4. Nothing is URL-encoded in the resulting object,
  //    (in joyent/node some chars in auth and paths are encoded)
  //
  // 5. `url.parse()` does not have `parseQueryString` argument
  //
  // 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
  //    which can be constructed using other parts of the url.
  //


  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

      // RFC 2396: characters not allowed for various reasons.
      unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = [ '\'' ].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
      hostEndingChars = [ '/', '?', '#' ],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      /* eslint-disable no-script-url */
      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      };
      /* eslint-enable no-script-url */

  function urlParse(url, slashesDenoteHost) {
    if (url && url instanceof Url) { return url; }

    var u = new Url();
    u.parse(url, slashesDenoteHost);
    return u;
  }

  Url.prototype.parse = function(url, slashesDenoteHost) {
    var i, l, lowerProto, hec, slashes,
        rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
        }
        return this;
      }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = proto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }

    if (!hostlessProtocol[proto] &&
        (slashes || (proto && !slashedProtocol[proto]))) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = auth;
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }

      if (rest[hostEnd - 1] === ':') { hostEnd--; }
      var host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      this.parseHost(host);

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      this.hostname = this.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = this.hostname[0] === '[' &&
          this.hostname[this.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) { continue; }
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = notHost.join('.') + rest;
              }
              this.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = '';
      }

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      }
    }

    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      this.search = rest.substr(qm);
      rest = rest.slice(0, qm);
    }
    if (rest) { this.pathname = rest; }
    if (slashedProtocol[lowerProto] &&
        this.hostname && !this.pathname) {
      this.pathname = '';
    }

    return this;
  };

  Url.prototype.parseHost = function(host) {
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) { this.hostname = host; }
  };

  var parse$1 = urlParse;

  mdurl$1.encode = encode_1;
  mdurl$1.decode = decode_1;
  mdurl$1.format = format;
  mdurl$1.parse  = parse$1;

  var uc_micro = {};

  var regex$3=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

  var regex$2=/[\0-\x1F\x7F-\x9F]/;

  var regex$1=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

  var regex=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

  uc_micro.Any = regex$3;
  uc_micro.Cc  = regex$2;
  uc_micro.Cf  = regex$1;
  uc_micro.P   = regex$4;
  uc_micro.Z   = regex;

  (function (exports) {


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function isString(obj) { return _class(obj) === '[object String]'; }

  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  function has(object, key) {
    return _hasOwnProperty.call(object, key);
  }

  // Merge objects
  //
  function assign(obj /*from1, from2, from3, ...*/) {
    var sources = Array.prototype.slice.call(arguments, 1);

    sources.forEach(function (source) {
      if (!source) { return; }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be object');
      }

      Object.keys(source).forEach(function (key) {
        obj[key] = source[key];
      });
    });

    return obj;
  }

  // Remove element from array and put another array at those position.
  // Useful for some operations with tokens
  function arrayReplaceAt(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }

  ////////////////////////////////////////////////////////////////////////////////

  function isValidEntityCode(c) {
    /*eslint no-bitwise:0*/
    // broken sequence
    if (c >= 0xD800 && c <= 0xDFFF) { return false; }
    // never used
    if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
    if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
    // control codes
    if (c >= 0x00 && c <= 0x08) { return false; }
    if (c === 0x0B) { return false; }
    if (c >= 0x0E && c <= 0x1F) { return false; }
    if (c >= 0x7F && c <= 0x9F) { return false; }
    // out of range
    if (c > 0x10FFFF) { return false; }
    return true;
  }

  function fromCodePoint(c) {
    /*eslint no-bitwise:0*/
    if (c > 0xffff) {
      c -= 0x10000;
      var surrogate1 = 0xd800 + (c >> 10),
          surrogate2 = 0xdc00 + (c & 0x3ff);

      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }


  var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

  var entities = entities$1;

  function replaceEntityPattern(match, name) {
    var code = 0;

    if (has(entities, name)) {
      return entities[name];
    }

    if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
      code = name[1].toLowerCase() === 'x' ?
        parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

      if (isValidEntityCode(code)) {
        return fromCodePoint(code);
      }
    }

    return match;
  }

  /*function replaceEntities(str) {
    if (str.indexOf('&') < 0) { return str; }

    return str.replace(ENTITY_RE, replaceEntityPattern);
  }*/

  function unescapeMd(str) {
    if (str.indexOf('\\') < 0) { return str; }
    return str.replace(UNESCAPE_MD_RE, '$1');
  }

  function unescapeAll(str) {
    if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

    return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
      if (escaped) { return escaped; }
      return replaceEntityPattern(match, entity);
    });
  }

  ////////////////////////////////////////////////////////////////////////////////

  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;'
  };

  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }

  function escapeHtml(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }

  ////////////////////////////////////////////////////////////////////////////////

  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

  function escapeRE(str) {
    return str.replace(REGEXP_ESCAPE_RE, '\\$&');
  }

  ////////////////////////////////////////////////////////////////////////////////

  function isSpace(code) {
    switch (code) {
      case 0x09:
      case 0x20:
        return true;
    }
    return false;
  }

  // Zs (unicode class) || [\t\f\v\r\n]
  function isWhiteSpace(code) {
    if (code >= 0x2000 && code <= 0x200A) { return true; }
    switch (code) {
      case 0x09: // \t
      case 0x0A: // \n
      case 0x0B: // \v
      case 0x0C: // \f
      case 0x0D: // \r
      case 0x20:
      case 0xA0:
      case 0x1680:
      case 0x202F:
      case 0x205F:
      case 0x3000:
        return true;
    }
    return false;
  }

  ////////////////////////////////////////////////////////////////////////////////

  /*eslint-disable max-len*/
  var UNICODE_PUNCT_RE = regex$4;

  // Currently without astral characters support.
  function isPunctChar(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }


  // Markdown ASCII punctuation characters.
  //
  // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
  // http://spec.commonmark.org/0.15/#ascii-punctuation-character
  //
  // Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
  //
  function isMdAsciiPunct(ch) {
    switch (ch) {
      case 0x21/* ! */:
      case 0x22/* " */:
      case 0x23/* # */:
      case 0x24/* $ */:
      case 0x25/* % */:
      case 0x26/* & */:
      case 0x27/* ' */:
      case 0x28/* ( */:
      case 0x29/* ) */:
      case 0x2A/* * */:
      case 0x2B/* + */:
      case 0x2C/* , */:
      case 0x2D/* - */:
      case 0x2E/* . */:
      case 0x2F/* / */:
      case 0x3A/* : */:
      case 0x3B/* ; */:
      case 0x3C/* < */:
      case 0x3D/* = */:
      case 0x3E/* > */:
      case 0x3F/* ? */:
      case 0x40/* @ */:
      case 0x5B/* [ */:
      case 0x5C/* \ */:
      case 0x5D/* ] */:
      case 0x5E/* ^ */:
      case 0x5F/* _ */:
      case 0x60/* ` */:
      case 0x7B/* { */:
      case 0x7C/* | */:
      case 0x7D/* } */:
      case 0x7E/* ~ */:
        return true;
      default:
        return false;
    }
  }

  // Hepler to unify [reference labels].
  //
  function normalizeReference(str) {
    // Trim and collapse whitespace
    //
    str = str.trim().replace(/\s+/g, ' ');

    // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
    // fixed in v12 (couldn't find any details).
    //
    // So treat this one as a special case
    // (remove this when node v10 is no longer supported).
    //
    if ('ẞ'.toLowerCase() === 'Ṿ') {
      str = str.replace(/ẞ/g, 'ß');
    }

    // .toLowerCase().toUpperCase() should get rid of all differences
    // between letter variants.
    //
    // Simple .toLowerCase() doesn't normalize 125 code points correctly,
    // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
    // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
    // uppercased versions).
    //
    // Here's an example showing how it happens. Lets take greek letter omega:
    // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
    //
    // Unicode entries:
    // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
    // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
    // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
    // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
    //
    // Case-insensitive comparison should treat all of them as equivalent.
    //
    // But .toLowerCase() doesn't change ϑ (it's already lowercase),
    // and .toUpperCase() doesn't change ϴ (already uppercase).
    //
    // Applying first lower then upper case normalizes any character:
    // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
    //
    // Note: this is equivalent to unicode case folding; unicode normalization
    // is a different step that is not required here.
    //
    // Final result should be uppercased, because it's later stored in an object
    // (this avoid a conflict with Object.prototype members,
    // most notably, `__proto__`)
    //
    return str.toLowerCase().toUpperCase();
  }

  ////////////////////////////////////////////////////////////////////////////////

  // Re-export libraries commonly used in both markdown-it and its plugins,
  // so plugins won't have to depend on them explicitly, which reduces their
  // bundled size (e.g. a browser build).
  //
  exports.lib                 = {};
  exports.lib.mdurl           = mdurl$1;
  exports.lib.ucmicro         = uc_micro;

  exports.assign              = assign;
  exports.isString            = isString;
  exports.has                 = has;
  exports.unescapeMd          = unescapeMd;
  exports.unescapeAll         = unescapeAll;
  exports.isValidEntityCode   = isValidEntityCode;
  exports.fromCodePoint       = fromCodePoint;
  // exports.replaceEntities     = replaceEntities;
  exports.escapeHtml          = escapeHtml;
  exports.arrayReplaceAt      = arrayReplaceAt;
  exports.isSpace             = isSpace;
  exports.isWhiteSpace        = isWhiteSpace;
  exports.isMdAsciiPunct      = isMdAsciiPunct;
  exports.isPunctChar         = isPunctChar;
  exports.escapeRE            = escapeRE;
  exports.normalizeReference  = normalizeReference;
  }(utils$1));

  var helpers$1 = {};

  var parse_link_label = function parseLinkLabel(state, start, disableNested) {
    var level, found, marker, prevPos,
        labelEnd = -1,
        max = state.posMax,
        oldPos = state.pos;

    state.pos = start + 1;
    level = 1;

    while (state.pos < max) {
      marker = state.src.charCodeAt(state.pos);
      if (marker === 0x5D /* ] */) {
        level--;
        if (level === 0) {
          found = true;
          break;
        }
      }

      prevPos = state.pos;
      state.md.inline.skipToken(state);
      if (marker === 0x5B /* [ */) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
    }

    if (found) {
      labelEnd = state.pos;
    }

    // restore old state
    state.pos = oldPos;

    return labelEnd;
  };

  var unescapeAll$2 = utils$1.unescapeAll;


  var parse_link_destination = function parseLinkDestination(str, pos, max) {
    var code, level,
        lines = 0,
        start = pos,
        result = {
          ok: false,
          pos: 0,
          lines: 0,
          str: ''
        };

    if (str.charCodeAt(pos) === 0x3C /* < */) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 0x0A /* \n */) { return result; }
        if (code === 0x3C /* < */) { return result; }
        if (code === 0x3E /* > */) {
          result.pos = pos + 1;
          result.str = unescapeAll$2(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code === 0x5C /* \ */ && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      }

      // no closing '>'
      return result;
    }

    // this should be ... } else { ... branch

    level = 0;
    while (pos < max) {
      code = str.charCodeAt(pos);

      if (code === 0x20) { break; }

      // ascii control characters
      if (code < 0x20 || code === 0x7F) { break; }

      if (code === 0x5C /* \ */ && pos + 1 < max) {
        if (str.charCodeAt(pos + 1) === 0x20) { break; }
        pos += 2;
        continue;
      }

      if (code === 0x28 /* ( */) {
        level++;
        if (level > 32) { return result; }
      }

      if (code === 0x29 /* ) */) {
        if (level === 0) { break; }
        level--;
      }

      pos++;
    }

    if (start === pos) { return result; }
    if (level !== 0) { return result; }

    result.str = unescapeAll$2(str.slice(start, pos));
    result.lines = lines;
    result.pos = pos;
    result.ok = true;
    return result;
  };

  var unescapeAll$1 = utils$1.unescapeAll;


  var parse_link_title = function parseLinkTitle(str, pos, max) {
    var code,
        marker,
        lines = 0,
        start = pos,
        result = {
          ok: false,
          pos: 0,
          lines: 0,
          str: ''
        };

    if (pos >= max) { return result; }

    marker = str.charCodeAt(pos);

    if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

    pos++;

    // if opening marker is "(", switch it to closing marker ")"
    if (marker === 0x28) { marker = 0x29; }

    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === marker) {
        result.pos = pos + 1;
        result.lines = lines;
        result.str = unescapeAll$1(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
        return result;
      } else if (code === 0x0A) {
        lines++;
      } else if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos++;
        if (str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }

      pos++;
    }

    return result;
  };

  helpers$1.parseLinkLabel       = parse_link_label;
  helpers$1.parseLinkDestination = parse_link_destination;
  helpers$1.parseLinkTitle       = parse_link_title;

  /**
   * class Renderer
   *
   * Generates HTML from parsed token stream. Each instance has independent
   * copy of rules. Those can be rewritten with ease. Also, you can add new
   * rules if you create plugin and adds new token types.
   **/


  var assign$1          = utils$1.assign;
  var unescapeAll     = utils$1.unescapeAll;
  var escapeHtml      = utils$1.escapeHtml;


  ////////////////////////////////////////////////////////////////////////////////

  var default_rules = {};


  default_rules.code_inline = function (tokens, idx, options, env, slf) {
    var token = tokens[idx];

    return  '<code' + slf.renderAttrs(token) + '>' +
            escapeHtml(tokens[idx].content) +
            '</code>';
  };


  default_rules.code_block = function (tokens, idx, options, env, slf) {
    var token = tokens[idx];

    return  '<pre' + slf.renderAttrs(token) + '><code>' +
            escapeHtml(tokens[idx].content) +
            '</code></pre>\n';
  };


  default_rules.fence = function (tokens, idx, options, env, slf) {
    var token = tokens[idx],
        info = token.info ? unescapeAll(token.info).trim() : '',
        langName = '',
        langAttrs = '',
        highlighted, i, arr, tmpAttrs, tmpToken;

    if (info) {
      arr = info.split(/(\s+)/g);
      langName = arr[0];
      langAttrs = arr.slice(2).join('');
    }

    if (options.highlight) {
      highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
    } else {
      highlighted = escapeHtml(token.content);
    }

    if (highlighted.indexOf('<pre') === 0) {
      return highlighted + '\n';
    }

    // If language exists, inject class gently, without modifying original token.
    // May be, one day we will add .deepClone() for token and simplify this part, but
    // now we prefer to keep things local.
    if (info) {
      i        = token.attrIndex('class');
      tmpAttrs = token.attrs ? token.attrs.slice() : [];

      if (i < 0) {
        tmpAttrs.push([ 'class', options.langPrefix + langName ]);
      } else {
        tmpAttrs[i] = tmpAttrs[i].slice();
        tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
      }

      // Fake token just to render attributes
      tmpToken = {
        attrs: tmpAttrs
      };

      return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
            + highlighted
            + '</code></pre>\n';
    }


    return  '<pre><code' + slf.renderAttrs(token) + '>'
          + highlighted
          + '</code></pre>\n';
  };


  default_rules.image = function (tokens, idx, options, env, slf) {
    var token = tokens[idx];

    // "alt" attr MUST be set, even if empty. Because it's mandatory and
    // should be placed on proper position for tests.
    //
    // Replace content with actual value

    token.attrs[token.attrIndex('alt')][1] =
      slf.renderInlineAsText(token.children, options, env);

    return slf.renderToken(tokens, idx, options);
  };


  default_rules.hardbreak = function (tokens, idx, options /*, env */) {
    return options.xhtmlOut ? '<br />\n' : '<br>\n';
  };
  default_rules.softbreak = function (tokens, idx, options /*, env */) {
    return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
  };


  default_rules.text = function (tokens, idx /*, options, env */) {
    return escapeHtml(tokens[idx].content);
  };


  default_rules.html_block = function (tokens, idx /*, options, env */) {
    return tokens[idx].content;
  };
  default_rules.html_inline = function (tokens, idx /*, options, env */) {
    return tokens[idx].content;
  };


  /**
   * new Renderer()
   *
   * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
   **/
  function Renderer$2() {

    /**
     * Renderer#rules -> Object
     *
     * Contains render rules for tokens. Can be updated and extended.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * md.renderer.rules.strong_open  = function () { return '<b>'; };
     * md.renderer.rules.strong_close = function () { return '</b>'; };
     *
     * var result = md.renderInline(...);
     * ```
     *
     * Each rule is called as independent static function with fixed signature:
     *
     * ```javascript
     * function my_token_render(tokens, idx, options, env, renderer) {
     *   // ...
     *   return renderedHTML;
     * }
     * ```
     *
     * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
     * for more details and examples.
     **/
    this.rules = assign$1({}, default_rules);
  }


  /**
   * Renderer.renderAttrs(token) -> String
   *
   * Render token attributes to string.
   **/
  Renderer$2.prototype.renderAttrs = function renderAttrs(token) {
    var i, l, result;

    if (!token.attrs) { return ''; }

    result = '';

    for (i = 0, l = token.attrs.length; i < l; i++) {
      result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
    }

    return result;
  };


  /**
   * Renderer.renderToken(tokens, idx, options) -> String
   * - tokens (Array): list of tokens
   * - idx (Numbed): token index to render
   * - options (Object): params of parser instance
   *
   * Default token renderer. Can be overriden by custom function
   * in [[Renderer#rules]].
   **/
  Renderer$2.prototype.renderToken = function renderToken(tokens, idx, options) {
    var nextToken,
        result = '',
        needLf = false,
        token = tokens[idx];

    // Tight list paragraphs
    if (token.hidden) {
      return '';
    }

    // Insert a newline between hidden paragraph and subsequent opening
    // block-level tag.
    //
    // For example, here we should insert a newline before blockquote:
    //  - a
    //    >
    //
    if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
      result += '\n';
    }

    // Add token name, e.g. `<img`
    result += (token.nesting === -1 ? '</' : '<') + token.tag;

    // Encode attributes, e.g. `<img src="foo"`
    result += this.renderAttrs(token);

    // Add a slash for self-closing tags, e.g. `<img src="foo" /`
    if (token.nesting === 0 && options.xhtmlOut) {
      result += ' /';
    }

    // Check if we need to add a newline after this tag
    if (token.block) {
      needLf = true;

      if (token.nesting === 1) {
        if (idx + 1 < tokens.length) {
          nextToken = tokens[idx + 1];

          if (nextToken.type === 'inline' || nextToken.hidden) {
            // Block-level tag containing an inline tag.
            //
            needLf = false;

          } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
            // Opening tag + closing tag of the same type. E.g. `<li></li>`.
            //
            needLf = false;
          }
        }
      }
    }

    result += needLf ? '>\n' : '>';

    return result;
  };


  /**
   * Renderer.renderInline(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to render
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * The same as [[Renderer.render]], but for single token of `inline` type.
   **/
  Renderer$2.prototype.renderInline = function (tokens, options, env) {
    var type,
        result = '',
        rules = this.rules;

    for (var i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;

      if (typeof rules[type] !== 'undefined') {
        result += rules[type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options);
      }
    }

    return result;
  };


  /** internal
   * Renderer.renderInlineAsText(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to render
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * Special kludge for image `alt` attributes to conform CommonMark spec.
   * Don't try to use it! Spec requires to show `alt` content with stripped markup,
   * instead of simple escaping.
   **/
  Renderer$2.prototype.renderInlineAsText = function (tokens, options, env) {
    var result = '';

    for (var i = 0, len = tokens.length; i < len; i++) {
      if (tokens[i].type === 'text') {
        result += tokens[i].content;
      } else if (tokens[i].type === 'image') {
        result += this.renderInlineAsText(tokens[i].children, options, env);
      } else if (tokens[i].type === 'softbreak') {
        result += '\n';
      }
    }

    return result;
  };


  /**
   * Renderer.render(tokens, options, env) -> String
   * - tokens (Array): list on block tokens to render
   * - options (Object): params of parser instance
   * - env (Object): additional data from parsed input (references, for example)
   *
   * Takes token stream and generates HTML. Probably, you will never need to call
   * this method directly.
   **/
  Renderer$2.prototype.render = function (tokens, options, env) {
    var i, len, type,
        result = '',
        rules = this.rules;

    for (i = 0, len = tokens.length; i < len; i++) {
      type = tokens[i].type;

      if (type === 'inline') {
        result += this.renderInline(tokens[i].children, options, env);
      } else if (typeof rules[type] !== 'undefined') {
        result += rules[tokens[i].type](tokens, i, options, env, this);
      } else {
        result += this.renderToken(tokens, i, options, env);
      }
    }

    return result;
  };

  var renderer = Renderer$2;

  /**
   * class Ruler
   *
   * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
   * [[MarkdownIt#inline]] to manage sequences of functions (rules):
   *
   * - keep rules in defined order
   * - assign the name to each rule
   * - enable/disable rules
   * - add/replace rules
   * - allow assign rules to additional named chains (in the same)
   * - cacheing lists of active rules
   *
   * You will not need use this class directly until write plugins. For simple
   * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
   * [[MarkdownIt.use]].
   **/


  /**
   * new Ruler()
   **/
  function Ruler$3() {
    // List of added rules. Each element is:
    //
    // {
    //   name: XXX,
    //   enabled: Boolean,
    //   fn: Function(),
    //   alt: [ name2, name3 ]
    // }
    //
    this.__rules__ = [];

    // Cached rule chains.
    //
    // First level - chain name, '' for default.
    // Second level - diginal anchor for fast filtering by charcodes.
    //
    this.__cache__ = null;
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Helper methods, should not be used directly


  // Find rule index by name
  //
  Ruler$3.prototype.__find__ = function (name) {
    for (var i = 0; i < this.__rules__.length; i++) {
      if (this.__rules__[i].name === name) {
        return i;
      }
    }
    return -1;
  };


  // Build rules lookup cache
  //
  Ruler$3.prototype.__compile__ = function () {
    var self = this;
    var chains = [ '' ];

    // collect unique names
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      rule.alt.forEach(function (altName) {
        if (chains.indexOf(altName) < 0) {
          chains.push(altName);
        }
      });
    });

    self.__cache__ = {};

    chains.forEach(function (chain) {
      self.__cache__[chain] = [];
      self.__rules__.forEach(function (rule) {
        if (!rule.enabled) { return; }

        if (chain && rule.alt.indexOf(chain) < 0) { return; }

        self.__cache__[chain].push(rule.fn);
      });
    });
  };


  /**
   * Ruler.at(name, fn [, options])
   * - name (String): rule name to replace.
   * - fn (Function): new rule function.
   * - options (Object): new rule options (not mandatory).
   *
   * Replace rule by name with new function & options. Throws error if name not
   * found.
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * Replace existing typographer replacement rule with new one:
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.core.ruler.at('replacements', function replace(state) {
   *   //...
   * });
   * ```
   **/
  Ruler$3.prototype.at = function (name, fn, options) {
    var index = this.__find__(name);
    var opt = options || {};

    if (index === -1) { throw new Error('Parser rule not found: ' + name); }

    this.__rules__[index].fn = fn;
    this.__rules__[index].alt = opt.alt || [];
    this.__cache__ = null;
  };


  /**
   * Ruler.before(beforeName, ruleName, fn [, options])
   * - beforeName (String): new rule will be added before this one.
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Add new rule to chain before one with given name. See also
   * [[Ruler.after]], [[Ruler.push]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/
  Ruler$3.prototype.before = function (beforeName, ruleName, fn, options) {
    var index = this.__find__(beforeName);
    var opt = options || {};

    if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

    this.__rules__.splice(index, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };


  /**
   * Ruler.after(afterName, ruleName, fn [, options])
   * - afterName (String): new rule will be added after this one.
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Add new rule to chain after one with given name. See also
   * [[Ruler.before]], [[Ruler.push]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.inline.ruler.after('text', 'my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/
  Ruler$3.prototype.after = function (afterName, ruleName, fn, options) {
    var index = this.__find__(afterName);
    var opt = options || {};

    if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

    this.__rules__.splice(index + 1, 0, {
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };

  /**
   * Ruler.push(ruleName, fn [, options])
   * - ruleName (String): name of added rule.
   * - fn (Function): rule function.
   * - options (Object): rule options (not mandatory).
   *
   * Push new rule to the end of chain. See also
   * [[Ruler.before]], [[Ruler.after]].
   *
   * ##### Options:
   *
   * - __alt__ - array with names of "alternate" chains.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.core.ruler.push('my_rule', function replace(state) {
   *   //...
   * });
   * ```
   **/
  Ruler$3.prototype.push = function (ruleName, fn, options) {
    var opt = options || {};

    this.__rules__.push({
      name: ruleName,
      enabled: true,
      fn: fn,
      alt: opt.alt || []
    });

    this.__cache__ = null;
  };


  /**
   * Ruler.enable(list [, ignoreInvalid]) -> Array
   * - list (String|Array): list of rule names to enable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable rules with given names. If any rule name not found - throw Error.
   * Errors can be disabled by second param.
   *
   * Returns list of found rule names (if no exception happened).
   *
   * See also [[Ruler.disable]], [[Ruler.enableOnly]].
   **/
  Ruler$3.prototype.enable = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) { list = [ list ]; }

    var result = [];

    // Search by name and enable
    list.forEach(function (name) {
      var idx = this.__find__(name);

      if (idx < 0) {
        if (ignoreInvalid) { return; }
        throw new Error('Rules manager: invalid rule name ' + name);
      }
      this.__rules__[idx].enabled = true;
      result.push(name);
    }, this);

    this.__cache__ = null;
    return result;
  };


  /**
   * Ruler.enableOnly(list [, ignoreInvalid])
   * - list (String|Array): list of rule names to enable (whitelist).
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable rules with given names, and disable everything else. If any rule name
   * not found - throw Error. Errors can be disabled by second param.
   *
   * See also [[Ruler.disable]], [[Ruler.enable]].
   **/
  Ruler$3.prototype.enableOnly = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) { list = [ list ]; }

    this.__rules__.forEach(function (rule) { rule.enabled = false; });

    this.enable(list, ignoreInvalid);
  };


  /**
   * Ruler.disable(list [, ignoreInvalid]) -> Array
   * - list (String|Array): list of rule names to disable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Disable rules with given names. If any rule name not found - throw Error.
   * Errors can be disabled by second param.
   *
   * Returns list of found rule names (if no exception happened).
   *
   * See also [[Ruler.enable]], [[Ruler.enableOnly]].
   **/
  Ruler$3.prototype.disable = function (list, ignoreInvalid) {
    if (!Array.isArray(list)) { list = [ list ]; }

    var result = [];

    // Search by name and disable
    list.forEach(function (name) {
      var idx = this.__find__(name);

      if (idx < 0) {
        if (ignoreInvalid) { return; }
        throw new Error('Rules manager: invalid rule name ' + name);
      }
      this.__rules__[idx].enabled = false;
      result.push(name);
    }, this);

    this.__cache__ = null;
    return result;
  };


  /**
   * Ruler.getRules(chainName) -> Array
   *
   * Return array of active functions (rules) for given chain name. It analyzes
   * rules configuration, compiles caches if not exists and returns result.
   *
   * Default chain name is `''` (empty string). It can't be skipped. That's
   * done intentionally, to keep signature monomorphic for high speed.
   **/
  Ruler$3.prototype.getRules = function (chainName) {
    if (this.__cache__ === null) {
      this.__compile__();
    }

    // Chain can be empty, if rules disabled. But we still have to return Array.
    return this.__cache__[chainName] || [];
  };

  var ruler = Ruler$3;

  // https://spec.commonmark.org/0.29/#line-ending
  var NEWLINES_RE  = /\r\n?|\n/g;
  var NULL_RE      = /\0/g;


  var normalize$1 = function normalize(state) {
    var str;

    // Normalize newlines
    str = state.src.replace(NEWLINES_RE, '\n');

    // Replace NULL characters
    str = str.replace(NULL_RE, '\uFFFD');

    state.src = str;
  };

  var block = function block(state) {
    var token;

    if (state.inlineMode) {
      token          = new state.Token('inline', '', 0);
      token.content  = state.src;
      token.map      = [ 0, 1 ];
      token.children = [];
      state.tokens.push(token);
    } else {
      state.md.block.parse(state.src, state.md, state.env, state.tokens);
    }
  };

  var inline = function inline(state) {
    var tokens = state.tokens, tok, i, l;

    // Parse inlines
    for (i = 0, l = tokens.length; i < l; i++) {
      tok = tokens[i];
      if (tok.type === 'inline') {
        state.md.inline.parse(tok.content, state.md, state.env, tok.children);
      }
    }
  };

  var arrayReplaceAt = utils$1.arrayReplaceAt;


  function isLinkOpen(str) {
    return /^<a[>\s]/i.test(str);
  }
  function isLinkClose(str) {
    return /^<\/a\s*>/i.test(str);
  }


  var linkify = function linkify(state) {
    var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
        level, htmlLinkLevel, url, fullUrl, urlText,
        blockTokens = state.tokens,
        links;

    if (!state.md.options.linkify) { return; }

    for (j = 0, l = blockTokens.length; j < l; j++) {
      if (blockTokens[j].type !== 'inline' ||
          !state.md.linkify.pretest(blockTokens[j].content)) {
        continue;
      }

      tokens = blockTokens[j].children;

      htmlLinkLevel = 0;

      // We scan from the end, to keep position when new tags added.
      // Use reversed logic in links start/end match
      for (i = tokens.length - 1; i >= 0; i--) {
        currentToken = tokens[i];

        // Skip content of markdown links
        if (currentToken.type === 'link_close') {
          i--;
          while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
            i--;
          }
          continue;
        }

        // Skip content of html tag links
        if (currentToken.type === 'html_inline') {
          if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
            htmlLinkLevel--;
          }
          if (isLinkClose(currentToken.content)) {
            htmlLinkLevel++;
          }
        }
        if (htmlLinkLevel > 0) { continue; }

        if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

          text = currentToken.content;
          links = state.md.linkify.match(text);

          // Now split string to nodes
          nodes = [];
          level = currentToken.level;
          lastPos = 0;

          for (ln = 0; ln < links.length; ln++) {

            url = links[ln].url;
            fullUrl = state.md.normalizeLink(url);
            if (!state.md.validateLink(fullUrl)) { continue; }

            urlText = links[ln].text;

            // Linkifier might send raw hostnames like "example.com", where url
            // starts with domain name. So we prepend http:// in those cases,
            // and remove it afterwards.
            //
            if (!links[ln].schema) {
              urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
            } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
              urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
            } else {
              urlText = state.md.normalizeLinkText(urlText);
            }

            pos = links[ln].index;

            if (pos > lastPos) {
              token         = new state.Token('text', '', 0);
              token.content = text.slice(lastPos, pos);
              token.level   = level;
              nodes.push(token);
            }

            token         = new state.Token('link_open', 'a', 1);
            token.attrs   = [ [ 'href', fullUrl ] ];
            token.level   = level++;
            token.markup  = 'linkify';
            token.info    = 'auto';
            nodes.push(token);

            token         = new state.Token('text', '', 0);
            token.content = urlText;
            token.level   = level;
            nodes.push(token);

            token         = new state.Token('link_close', 'a', -1);
            token.level   = --level;
            token.markup  = 'linkify';
            token.info    = 'auto';
            nodes.push(token);

            lastPos = links[ln].lastIndex;
          }
          if (lastPos < text.length) {
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos);
            token.level   = level;
            nodes.push(token);
          }

          // replace current node
          blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
        }
      }
    }
  };

  // TODO:
  // - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
  // - miltiplication 2 x 4 -> 2 × 4

  var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

  // Workaround for phantomjs - need regex without /g flag,
  // or root check will fail every second time
  var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

  var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
  var SCOPED_ABBR = {
    c: '©',
    r: '®',
    p: '§',
    tm: '™'
  };

  function replaceFn(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  }

  function replace_scoped(inlineTokens) {
    var i, token, inside_autolink = 0;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];

      if (token.type === 'text' && !inside_autolink) {
        token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
      }

      if (token.type === 'link_open' && token.info === 'auto') {
        inside_autolink--;
      }

      if (token.type === 'link_close' && token.info === 'auto') {
        inside_autolink++;
      }
    }
  }

  function replace_rare(inlineTokens) {
    var i, token, inside_autolink = 0;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];

      if (token.type === 'text' && !inside_autolink) {
        if (RARE_RE.test(token.content)) {
          token.content = token.content
            .replace(/\+-/g, '±')
            // .., ..., ....... -> …
            // but ?..... & !..... -> ?.. & !..
            .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
            // em-dash
            .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
            // en-dash
            .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
            .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
        }
      }

      if (token.type === 'link_open' && token.info === 'auto') {
        inside_autolink--;
      }

      if (token.type === 'link_close' && token.info === 'auto') {
        inside_autolink++;
      }
    }
  }


  var replacements = function replace(state) {
    var blkIdx;

    if (!state.md.options.typographer) { return; }

    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

      if (state.tokens[blkIdx].type !== 'inline') { continue; }

      if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
        replace_scoped(state.tokens[blkIdx].children);
      }

      if (RARE_RE.test(state.tokens[blkIdx].content)) {
        replace_rare(state.tokens[blkIdx].children);
      }

    }
  };

  var isWhiteSpace$2   = utils$1.isWhiteSpace;
  var isPunctChar$1    = utils$1.isPunctChar;
  var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;

  var QUOTE_TEST_RE = /['"]/;
  var QUOTE_RE = /['"]/g;
  var APOSTROPHE$1 = '\u2019'; /* ’ */


  function replaceAt(str, index, ch) {
    return str.substr(0, index) + ch + str.substr(index + 1);
  }

  function process_inlines(tokens, state) {
    var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
        isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
        canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

    stack = [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) { break; }
      }
      stack.length = j + 1;

      if (token.type !== 'text') { continue; }

      text = token.content;
      pos = 0;
      max = text.length;

      /*eslint no-labels:0,block-scoped-var:0*/
      OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) { break; }

        canOpen = canClose = true;
        pos = t.index + 1;
        isSingle = (t[0] === "'");

        // Find previous character,
        // default to space if it's the beginning of the line
        //
        lastChar = 0x20;

        if (t.index - 1 >= 0) {
          lastChar = text.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
            if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }

        // Find next character,
        // default to space if it's the end of the line
        //
        nextChar = 0x20;

        if (pos < max) {
          nextChar = text.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
            if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }

        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));

        isLastWhiteSpace = isWhiteSpace$2(lastChar);
        isNextWhiteSpace = isWhiteSpace$2(nextChar);

        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }

        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }

        if (nextChar === 0x22 /* " */ && t[0] === '"') {
          if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
        }

        if (canOpen && canClose) {
          // Replace quotes in the middle of punctuation sequence, but not
          // in the middle of the words, i.e.:
          //
          // 1. foo " bar " baz - not replaced
          // 2. foo-"-bar-"-baz - replaced
          // 3. foo"bar"baz     - not replaced
          //
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }

        if (!canOpen && !canClose) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE$1);
          }
          continue;
        }

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) { break; }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];

              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }

              // replace token.content *before* tokens[item.token].content,
              // because, if they are pointing at the same token, replaceAt
              // could mess up indices when quote length != 1
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content, item.pos, openQuote);

              pos += closeQuote.length - 1;
              if (item.token === i) { pos += openQuote.length - 1; }

              text = token.content;
              max = text.length;

              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE$1);
        }
      }
    }
  }


  var smartquotes = function smartquotes(state) {
    /*eslint max-depth:0*/
    var blkIdx;

    if (!state.md.options.typographer) { return; }

    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

      if (state.tokens[blkIdx].type !== 'inline' ||
          !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
        continue;
      }

      process_inlines(state.tokens[blkIdx].children, state);
    }
  };

  /**
   * class Token
   **/

  /**
   * new Token(type, tag, nesting)
   *
   * Create new token and fill passed properties.
   **/
  function Token$3(type, tag, nesting) {
    /**
     * Token#type -> String
     *
     * Type of the token (string, e.g. "paragraph_open")
     **/
    this.type     = type;

    /**
     * Token#tag -> String
     *
     * html tag name, e.g. "p"
     **/
    this.tag      = tag;

    /**
     * Token#attrs -> Array
     *
     * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
     **/
    this.attrs    = null;

    /**
     * Token#map -> Array
     *
     * Source map info. Format: `[ line_begin, line_end ]`
     **/
    this.map      = null;

    /**
     * Token#nesting -> Number
     *
     * Level change (number in {-1, 0, 1} set), where:
     *
     * -  `1` means the tag is opening
     * -  `0` means the tag is self-closing
     * - `-1` means the tag is closing
     **/
    this.nesting  = nesting;

    /**
     * Token#level -> Number
     *
     * nesting level, the same as `state.level`
     **/
    this.level    = 0;

    /**
     * Token#children -> Array
     *
     * An array of child nodes (inline and img tokens)
     **/
    this.children = null;

    /**
     * Token#content -> String
     *
     * In a case of self-closing tag (code, html, fence, etc.),
     * it has contents of this tag.
     **/
    this.content  = '';

    /**
     * Token#markup -> String
     *
     * '*' or '_' for emphasis, fence string for fence, etc.
     **/
    this.markup   = '';

    /**
     * Token#info -> String
     *
     * Additional information:
     *
     * - Info string for "fence" tokens
     * - The value "auto" for autolink "link_open" and "link_close" tokens
     * - The string value of the item marker for ordered-list "list_item_open" tokens
     **/
    this.info     = '';

    /**
     * Token#meta -> Object
     *
     * A place for plugins to store an arbitrary data
     **/
    this.meta     = null;

    /**
     * Token#block -> Boolean
     *
     * True for block-level tokens, false for inline tokens.
     * Used in renderer to calculate line breaks
     **/
    this.block    = false;

    /**
     * Token#hidden -> Boolean
     *
     * If it's true, ignore this element when rendering. Used for tight lists
     * to hide paragraphs.
     **/
    this.hidden   = false;
  }


  /**
   * Token.attrIndex(name) -> Number
   *
   * Search attribute index by name.
   **/
  Token$3.prototype.attrIndex = function attrIndex(name) {
    var attrs, i, len;

    if (!this.attrs) { return -1; }

    attrs = this.attrs;

    for (i = 0, len = attrs.length; i < len; i++) {
      if (attrs[i][0] === name) { return i; }
    }
    return -1;
  };


  /**
   * Token.attrPush(attrData)
   *
   * Add `[ name, value ]` attribute to list. Init attrs if necessary
   **/
  Token$3.prototype.attrPush = function attrPush(attrData) {
    if (this.attrs) {
      this.attrs.push(attrData);
    } else {
      this.attrs = [ attrData ];
    }
  };


  /**
   * Token.attrSet(name, value)
   *
   * Set `name` attribute to `value`. Override old value if exists.
   **/
  Token$3.prototype.attrSet = function attrSet(name, value) {
    var idx = this.attrIndex(name),
        attrData = [ name, value ];

    if (idx < 0) {
      this.attrPush(attrData);
    } else {
      this.attrs[idx] = attrData;
    }
  };


  /**
   * Token.attrGet(name)
   *
   * Get the value of attribute `name`, or null if it does not exist.
   **/
  Token$3.prototype.attrGet = function attrGet(name) {
    var idx = this.attrIndex(name), value = null;
    if (idx >= 0) {
      value = this.attrs[idx][1];
    }
    return value;
  };


  /**
   * Token.attrJoin(name, value)
   *
   * Join value to existing attribute via space. Or create new attribute if not
   * exists. Useful to operate with token classes.
   **/
  Token$3.prototype.attrJoin = function attrJoin(name, value) {
    var idx = this.attrIndex(name);

    if (idx < 0) {
      this.attrPush([ name, value ]);
    } else {
      this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
    }
  };


  var token = Token$3;

  var Token$2 = token;


  function StateCore(src, md, env) {
    this.src = src;
    this.env = env;
    this.tokens = [];
    this.inlineMode = false;
    this.md = md; // link to parser instance
  }

  // re-export Token class to use in core rules
  StateCore.prototype.Token = Token$2;


  var state_core = StateCore;

  /** internal
   * class Core
   *
   * Top-level rules executor. Glues block/inline parsers and does intermediate
   * transformations.
   **/


  var Ruler$2  = ruler;


  var _rules$2 = [
    [ 'normalize',      normalize$1      ],
    [ 'block',          block          ],
    [ 'inline',         inline         ],
    [ 'linkify',        linkify        ],
    [ 'replacements',   replacements   ],
    [ 'smartquotes',    smartquotes    ]
  ];


  /**
   * new Core()
   **/
  function Core() {
    /**
     * Core#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of core rules.
     **/
    this.ruler = new Ruler$2();

    for (var i = 0; i < _rules$2.length; i++) {
      this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
    }
  }


  /**
   * Core.process(state)
   *
   * Executes core chain rules.
   **/
  Core.prototype.process = function (state) {
    var i, l, rules;

    rules = this.ruler.getRules('');

    for (i = 0, l = rules.length; i < l; i++) {
      rules[i](state);
    }
  };

  Core.prototype.State = state_core;


  var parser_core = Core;

  var isSpace$a = utils$1.isSpace;


  function getLine(state, line) {
    var pos = state.bMarks[line] + state.tShift[line],
        max = state.eMarks[line];

    return state.src.substr(pos, max - pos);
  }

  function escapedSplit(str) {
    var result = [],
        pos = 0,
        max = str.length,
        ch,
        isEscaped = false,
        lastPos = 0,
        current = '';

    ch  = str.charCodeAt(pos);

    while (pos < max) {
      if (ch === 0x7c/* | */) {
        if (!isEscaped) {
          // pipe separating cells, '|'
          result.push(current + str.substring(lastPos, pos));
          current = '';
          lastPos = pos + 1;
        } else {
          // escaped pipe, '\|'
          current += str.substring(lastPos, pos - 1);
          lastPos = pos;
        }
      }

      isEscaped = (ch === 0x5c/* \ */);
      pos++;

      ch = str.charCodeAt(pos);
    }

    result.push(current + str.substring(lastPos));

    return result;
  }


  var table = function table(state, startLine, endLine, silent) {
    var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
        aligns, t, tableLines, tbodyLines, oldParentType, terminate,
        terminatorRules, firstCh, secondCh;

    // should have at least two lines
    if (startLine + 2 > endLine) { return false; }

    nextLine = startLine + 1;

    if (state.sCount[nextLine] < state.blkIndent) { return false; }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

    // first character of the second line should be '|', '-', ':',
    // and no other characters are allowed but spaces;
    // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    if (pos >= state.eMarks[nextLine]) { return false; }

    firstCh = state.src.charCodeAt(pos++);
    if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false; }

    if (pos >= state.eMarks[nextLine]) { return false; }

    secondCh = state.src.charCodeAt(pos++);
    if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace$a(secondCh)) {
      return false;
    }

    // if first character is '-', then second character must not be a space
    // (due to parsing ambiguity with list)
    if (firstCh === 0x2D/* - */ && isSpace$a(secondCh)) { return false; }

    while (pos < state.eMarks[nextLine]) {
      ch = state.src.charCodeAt(pos);

      if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace$a(ch)) { return false; }

      pos++;
    }

    lineText = getLine(state, startLine + 1);

    columns = lineText.split('|');
    aligns = [];
    for (i = 0; i < columns.length; i++) {
      t = columns[i].trim();
      if (!t) {
        // allow empty columns before and after table, but not in between columns;
        // e.g. allow ` |---| `, disallow ` ---||--- `
        if (i === 0 || i === columns.length - 1) {
          continue;
        } else {
          return false;
        }
      }

      if (!/^:?-+:?$/.test(t)) { return false; }
      if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
        aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A/* : */) {
        aligns.push('left');
      } else {
        aligns.push('');
      }
    }

    lineText = getLine(state, startLine).trim();
    if (lineText.indexOf('|') === -1) { return false; }
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();

    // header row will define an amount of columns in the entire table,
    // and align row should be exactly the same (the rest of the rows can differ)
    columnCount = columns.length;
    if (columnCount === 0 || columnCount !== aligns.length) { return false; }

    if (silent) { return true; }

    oldParentType = state.parentType;
    state.parentType = 'table';

    // use 'blockquote' lists for termination because it's
    // the most similar to tables
    terminatorRules = state.md.block.ruler.getRules('blockquote');

    token     = state.push('table_open', 'table', 1);
    token.map = tableLines = [ startLine, 0 ];

    token     = state.push('thead_open', 'thead', 1);
    token.map = [ startLine, startLine + 1 ];

    token     = state.push('tr_open', 'tr', 1);
    token.map = [ startLine, startLine + 1 ];

    for (i = 0; i < columns.length; i++) {
      token          = state.push('th_open', 'th', 1);
      if (aligns[i]) {
        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
      }

      token          = state.push('inline', '', 0);
      token.content  = columns[i].trim();
      token.children = [];

      token          = state.push('th_close', 'th', -1);
    }

    token     = state.push('tr_close', 'tr', -1);
    token     = state.push('thead_close', 'thead', -1);

    for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) { break; }
      lineText = getLine(state, nextLine).trim();
      if (!lineText) { break; }
      if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === '') columns.shift();
      if (columns.length && columns[columns.length - 1] === '') columns.pop();

      if (nextLine === startLine + 2) {
        token     = state.push('tbody_open', 'tbody', 1);
        token.map = tbodyLines = [ startLine + 2, 0 ];
      }

      token     = state.push('tr_open', 'tr', 1);
      token.map = [ nextLine, nextLine + 1 ];

      for (i = 0; i < columnCount; i++) {
        token          = state.push('td_open', 'td', 1);
        if (aligns[i]) {
          token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
        }

        token          = state.push('inline', '', 0);
        token.content  = columns[i] ? columns[i].trim() : '';
        token.children = [];

        token          = state.push('td_close', 'td', -1);
      }
      token = state.push('tr_close', 'tr', -1);
    }

    if (tbodyLines) {
      token = state.push('tbody_close', 'tbody', -1);
      tbodyLines[1] = nextLine;
    }

    token = state.push('table_close', 'table', -1);
    tableLines[1] = nextLine;

    state.parentType = oldParentType;
    state.line = nextLine;
    return true;
  };

  var code = function code(state, startLine, endLine/*, silent*/) {
    var nextLine, last, token;

    if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

    last = nextLine = startLine + 1;

    while (nextLine < endLine) {
      if (state.isEmpty(nextLine)) {
        nextLine++;
        continue;
      }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        nextLine++;
        last = nextLine;
        continue;
      }
      break;
    }

    state.line = last;

    token         = state.push('code_block', 'code', 0);
    token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n';
    token.map     = [ startLine, state.line ];

    return true;
  };

  var fence = function fence(state, startLine, endLine, silent) {
    var marker, len, params, nextLine, mem, token, markup,
        haveEndMarker = false,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    if (pos + 3 > max) { return false; }

    marker = state.src.charCodeAt(pos);

    if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
      return false;
    }

    // scan marker length
    mem = pos;
    pos = state.skipChars(pos, marker);

    len = pos - mem;

    if (len < 3) { return false; }

    markup = state.src.slice(mem, pos);
    params = state.src.slice(pos, max);

    if (marker === 0x60 /* ` */) {
      if (params.indexOf(String.fromCharCode(marker)) >= 0) {
        return false;
      }
    }

    // Since start is found, we can report success here in validation mode
    if (silent) { return true; }

    // search end of block
    nextLine = startLine;

    for (;;) {
      nextLine++;
      if (nextLine >= endLine) {
        // unclosed block should be autoclosed by end of document.
        // also block seems to be autoclosed by end of parent
        break;
      }

      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max && state.sCount[nextLine] < state.blkIndent) {
        // non-empty line with negative indent should stop the list:
        // - ```
        //  test
        break;
      }

      if (state.src.charCodeAt(pos) !== marker) { continue; }

      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        // closing fence should be indented less than 4 spaces
        continue;
      }

      pos = state.skipChars(pos, marker);

      // closing code fence must be at least as long as the opening one
      if (pos - mem < len) { continue; }

      // make sure tail has spaces only
      pos = state.skipSpaces(pos);

      if (pos < max) { continue; }

      haveEndMarker = true;
      // found!
      break;
    }

    // If a fence has heading spaces, they should be removed from its inner block
    len = state.sCount[startLine];

    state.line = nextLine + (haveEndMarker ? 1 : 0);

    token         = state.push('fence', 'code', 0);
    token.info    = params;
    token.content = state.getLines(startLine + 1, nextLine, len, true);
    token.markup  = markup;
    token.map     = [ startLine, state.line ];

    return true;
  };

  var isSpace$9 = utils$1.isSpace;


  var blockquote = function blockquote(state, startLine, endLine, silent) {
    var adjustTab,
        ch,
        i,
        initial,
        l,
        lastLineEmpty,
        lines,
        nextLine,
        offset,
        oldBMarks,
        oldBSCount,
        oldIndent,
        oldParentType,
        oldSCount,
        oldTShift,
        spaceAfterMarker,
        terminate,
        terminatorRules,
        token,
        isOutdented,
        oldLineMax = state.lineMax,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    // check the block quote marker
    if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

    // we know that it's going to be a valid blockquote,
    // so no point trying to find the end of it in silent mode
    if (silent) { return true; }

    // set offset past spaces and ">"
    initial = offset = state.sCount[startLine] + 1;

    // skip one optional space after '>'
    if (state.src.charCodeAt(pos) === 0x20 /* space */) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
      spaceAfterMarker = false;
    }

    oldBMarks = [ state.bMarks[startLine] ];
    state.bMarks[startLine] = pos;

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (isSpace$9(ch)) {
        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
        } else {
          offset++;
        }
      } else {
        break;
      }

      pos++;
    }

    oldBSCount = [ state.bsCount[startLine] ];
    state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

    lastLineEmpty = pos >= max;

    oldSCount = [ state.sCount[startLine] ];
    state.sCount[startLine] = offset - initial;

    oldTShift = [ state.tShift[startLine] ];
    state.tShift[startLine] = pos - state.bMarks[startLine];

    terminatorRules = state.md.block.ruler.getRules('blockquote');

    oldParentType = state.parentType;
    state.parentType = 'blockquote';

    // Search the end of the block
    //
    // Block ends with either:
    //  1. an empty line outside:
    //     ```
    //     > test
    //
    //     ```
    //  2. an empty line inside:
    //     ```
    //     >
    //     test
    //     ```
    //  3. another tag:
    //     ```
    //     > test
    //      - - -
    //     ```
    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
      // check if it's outdented, i.e. it's inside list item and indented
      // less than said list item:
      //
      // ```
      // 1. anything
      //    > current blockquote
      // 2. checking this line
      // ```
      isOutdented = state.sCount[nextLine] < state.blkIndent;

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos >= max) {
        // Case 1: line is not inside the blockquote, and this line is empty.
        break;
      }

      if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
        // This line is inside the blockquote.

        // set offset past spaces and ">"
        initial = offset = state.sCount[nextLine] + 1;

        // skip one optional space after '>'
        if (state.src.charCodeAt(pos) === 0x20 /* space */) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
          spaceAfterMarker = false;
        }

        oldBMarks.push(state.bMarks[nextLine]);
        state.bMarks[nextLine] = pos;

        while (pos < max) {
          ch = state.src.charCodeAt(pos);

          if (isSpace$9(ch)) {
            if (ch === 0x09) {
              offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
            } else {
              offset++;
            }
          } else {
            break;
          }

          pos++;
        }

        lastLineEmpty = pos >= max;

        oldBSCount.push(state.bsCount[nextLine]);
        state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = offset - initial;

        oldTShift.push(state.tShift[nextLine]);
        state.tShift[nextLine] = pos - state.bMarks[nextLine];
        continue;
      }

      // Case 2: line is not inside the blockquote, and the last line was empty.
      if (lastLineEmpty) { break; }

      // Case 3: another tag found.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }

      if (terminate) {
        // Quirk to enforce "hard termination mode" for paragraphs;
        // normally if you call `tokenize(state, startLine, nextLine)`,
        // paragraphs will look below nextLine for paragraph continuation,
        // but if blockquote is terminated by another tag, they shouldn't
        state.lineMax = nextLine;

        if (state.blkIndent !== 0) {
          // state.blkIndent was non-zero, we now set it to zero,
          // so we need to re-calculate all offsets to appear as
          // if indent wasn't changed
          oldBMarks.push(state.bMarks[nextLine]);
          oldBSCount.push(state.bsCount[nextLine]);
          oldTShift.push(state.tShift[nextLine]);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] -= state.blkIndent;
        }

        break;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      oldBSCount.push(state.bsCount[nextLine]);
      oldTShift.push(state.tShift[nextLine]);
      oldSCount.push(state.sCount[nextLine]);

      // A negative indentation means that this is a paragraph continuation
      //
      state.sCount[nextLine] = -1;
    }

    oldIndent = state.blkIndent;
    state.blkIndent = 0;

    token        = state.push('blockquote_open', 'blockquote', 1);
    token.markup = '>';
    token.map    = lines = [ startLine, 0 ];

    state.md.block.tokenize(state, startLine, nextLine);

    token        = state.push('blockquote_close', 'blockquote', -1);
    token.markup = '>';

    state.lineMax = oldLineMax;
    state.parentType = oldParentType;
    lines[1] = state.line;

    // Restore original tShift; this might not be necessary since the parser
    // has already been here, but just to make sure we can do that.
    for (i = 0; i < oldTShift.length; i++) {
      state.bMarks[i + startLine] = oldBMarks[i];
      state.tShift[i + startLine] = oldTShift[i];
      state.sCount[i + startLine] = oldSCount[i];
      state.bsCount[i + startLine] = oldBSCount[i];
    }
    state.blkIndent = oldIndent;

    return true;
  };

  var isSpace$8 = utils$1.isSpace;


  var hr = function hr(state, startLine, endLine, silent) {
    var marker, cnt, ch, token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    marker = state.src.charCodeAt(pos++);

    // Check hr marker
    if (marker !== 0x2A/* * */ &&
        marker !== 0x2D/* - */ &&
        marker !== 0x5F/* _ */) {
      return false;
    }

    // markers can be mixed with spaces, but there should be at least 3 of them

    cnt = 1;
    while (pos < max) {
      ch = state.src.charCodeAt(pos++);
      if (ch !== marker && !isSpace$8(ch)) { return false; }
      if (ch === marker) { cnt++; }
    }

    if (cnt < 3) { return false; }

    if (silent) { return true; }

    state.line = startLine + 1;

    token        = state.push('hr', 'hr', 0);
    token.map    = [ startLine, state.line ];
    token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

    return true;
  };

  var isSpace$7 = utils$1.isSpace;


  // Search `[-+*][\n ]`, returns next pos after marker on success
  // or -1 on fail.
  function skipBulletListMarker(state, startLine) {
    var marker, pos, max, ch;

    pos = state.bMarks[startLine] + state.tShift[startLine];
    max = state.eMarks[startLine];

    marker = state.src.charCodeAt(pos++);
    // Check bullet
    if (marker !== 0x2A/* * */ &&
        marker !== 0x2D/* - */ &&
        marker !== 0x2B/* + */) {
      return -1;
    }

    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (!isSpace$7(ch)) {
        // " -test " - is not a list item
        return -1;
      }
    }

    return pos;
  }

  // Search `\d+[.)][\n ]`, returns next pos after marker on success
  // or -1 on fail.
  function skipOrderedListMarker(state, startLine) {
    var ch,
        start = state.bMarks[startLine] + state.tShift[startLine],
        pos = start,
        max = state.eMarks[startLine];

    // List marker should have at least 2 chars (digit + dot)
    if (pos + 1 >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

    for (;;) {
      // EOL -> fail
      if (pos >= max) { return -1; }

      ch = state.src.charCodeAt(pos++);

      if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) { return -1; }

        continue;
      }

      // found valid marker
      if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
        break;
      }

      return -1;
    }


    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (!isSpace$7(ch)) {
        // " 1.test " - is not a list item
        return -1;
      }
    }
    return pos;
  }

  function markTightParagraphs(state, idx) {
    var i, l,
        level = state.level + 2;

    for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
      if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
        state.tokens[i + 2].hidden = true;
        state.tokens[i].hidden = true;
        i += 2;
      }
    }
  }


  var list = function list(state, startLine, endLine, silent) {
    var ch,
        contentStart,
        i,
        indent,
        indentAfterMarker,
        initial,
        isOrdered,
        itemLines,
        l,
        listLines,
        listTokIdx,
        markerCharCode,
        markerValue,
        max,
        nextLine,
        offset,
        oldListIndent,
        oldParentType,
        oldSCount,
        oldTShift,
        oldTight,
        pos,
        posAfterMarker,
        prevEmptyEnd,
        start,
        terminate,
        terminatorRules,
        token,
        isTerminatingParagraph = false,
        tight = true;

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    // Special case:
    //  - item 1
    //   - item 2
    //    - item 3
    //     - item 4
    //      - this one is a paragraph continuation
    if (state.listIndent >= 0 &&
        state.sCount[startLine] - state.listIndent >= 4 &&
        state.sCount[startLine] < state.blkIndent) {
      return false;
    }

    // limit conditions when list can interrupt
    // a paragraph (validation mode only)
    if (silent && state.parentType === 'paragraph') {
      // Next list item should still terminate previous list item;
      //
      // This code can fail if plugins use blkIndent as well as lists,
      // but I hope the spec gets fixed long before that happens.
      //
      if (state.sCount[startLine] >= state.blkIndent) {
        isTerminatingParagraph = true;
      }
    }

    // Detect list type and position after marker
    if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
      isOrdered = true;
      start = state.bMarks[startLine] + state.tShift[startLine];
      markerValue = Number(state.src.slice(start, posAfterMarker - 1));

      // If we're starting a new ordered list right after
      // a paragraph, it should start with 1.
      if (isTerminatingParagraph && markerValue !== 1) return false;

    } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
      isOrdered = false;

    } else {
      return false;
    }

    // If we're starting a new unordered list right after
    // a paragraph, first line should not be empty.
    if (isTerminatingParagraph) {
      if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
    }

    // We should terminate list on style change. Remember first one to compare.
    markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

    // For validation mode we can terminate immediately
    if (silent) { return true; }

    // Start list
    listTokIdx = state.tokens.length;

    if (isOrdered) {
      token       = state.push('ordered_list_open', 'ol', 1);
      if (markerValue !== 1) {
        token.attrs = [ [ 'start', markerValue ] ];
      }

    } else {
      token       = state.push('bullet_list_open', 'ul', 1);
    }

    token.map    = listLines = [ startLine, 0 ];
    token.markup = String.fromCharCode(markerCharCode);

    //
    // Iterate list items
    //

    nextLine = startLine;
    prevEmptyEnd = false;
    terminatorRules = state.md.block.ruler.getRules('list');

    oldParentType = state.parentType;
    state.parentType = 'list';

    while (nextLine < endLine) {
      pos = posAfterMarker;
      max = state.eMarks[nextLine];

      initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (ch === 0x09) {
          offset += 4 - (offset + state.bsCount[nextLine]) % 4;
        } else if (ch === 0x20) {
          offset++;
        } else {
          break;
        }

        pos++;
      }

      contentStart = pos;

      if (contentStart >= max) {
        // trimming space in "-    \n  3" case, indent is 1 here
        indentAfterMarker = 1;
      } else {
        indentAfterMarker = offset - initial;
      }

      // If we have more than 4 spaces, the indent is 1
      // (the rest is just indented code block)
      if (indentAfterMarker > 4) { indentAfterMarker = 1; }

      // "  -  test"
      //  ^^^^^ - calculating total length of this thing
      indent = initial + indentAfterMarker;

      // Run subparser & write tokens
      token        = state.push('list_item_open', 'li', 1);
      token.markup = String.fromCharCode(markerCharCode);
      token.map    = itemLines = [ startLine, 0 ];
      if (isOrdered) {
        token.info = state.src.slice(start, posAfterMarker - 1);
      }

      // change current state, then restore it after parser subcall
      oldTight = state.tight;
      oldTShift = state.tShift[startLine];
      oldSCount = state.sCount[startLine];

      //  - example list
      // ^ listIndent position will be here
      //   ^ blkIndent position will be here
      //
      oldListIndent = state.listIndent;
      state.listIndent = state.blkIndent;
      state.blkIndent = indent;

      state.tight = true;
      state.tShift[startLine] = contentStart - state.bMarks[startLine];
      state.sCount[startLine] = offset;

      if (contentStart >= max && state.isEmpty(startLine + 1)) {
        // workaround for this case
        // (list item is empty, list terminates before "foo"):
        // ~~~~~~~~
        //   -
        //
        //     foo
        // ~~~~~~~~
        state.line = Math.min(state.line + 2, endLine);
      } else {
        state.md.block.tokenize(state, startLine, endLine, true);
      }

      // If any of list item is tight, mark list as tight
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
      prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

      state.blkIndent = state.listIndent;
      state.listIndent = oldListIndent;
      state.tShift[startLine] = oldTShift;
      state.sCount[startLine] = oldSCount;
      state.tight = oldTight;

      token        = state.push('list_item_close', 'li', -1);
      token.markup = String.fromCharCode(markerCharCode);

      nextLine = startLine = state.line;
      itemLines[1] = nextLine;
      contentStart = state.bMarks[startLine];

      if (nextLine >= endLine) { break; }

      //
      // Try to check if list is terminated or continued.
      //
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      // if it's indented more than 3 spaces, it should be a code block
      if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

      // fail if terminating block found
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }

      // fail if list has another type
      if (isOrdered) {
        posAfterMarker = skipOrderedListMarker(state, nextLine);
        if (posAfterMarker < 0) { break; }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
      } else {
        posAfterMarker = skipBulletListMarker(state, nextLine);
        if (posAfterMarker < 0) { break; }
      }

      if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
    }

    // Finalize list
    if (isOrdered) {
      token = state.push('ordered_list_close', 'ol', -1);
    } else {
      token = state.push('bullet_list_close', 'ul', -1);
    }
    token.markup = String.fromCharCode(markerCharCode);

    listLines[1] = nextLine;
    state.line = nextLine;

    state.parentType = oldParentType;

    // mark paragraphs tight if needed
    if (tight) {
      markTightParagraphs(state, listTokIdx);
    }

    return true;
  };

  var normalizeReference$2   = utils$1.normalizeReference;
  var isSpace$6              = utils$1.isSpace;


  var reference = function reference(state, startLine, _endLine, silent) {
    var ch,
        destEndPos,
        destEndLineNo,
        endLine,
        href,
        i,
        l,
        label,
        labelEnd,
        oldParentType,
        res,
        start,
        str,
        terminate,
        terminatorRules,
        title,
        lines = 0,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine],
        nextLine = startLine + 1;

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

    // Simple check to quickly interrupt scan on [link](url) at the start of line.
    // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
    while (++pos < max) {
      if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
          state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
        if (pos + 1 === max) { return false; }
        if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
        break;
      }
    }

    endLine = state.lineMax;

    // jump line-by-line until empty one or EOF
    terminatorRules = state.md.block.ruler.getRules('reference');

    oldParentType = state.parentType;
    state.parentType = 'reference';

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

      // quirk for blockquotes, this line should already be checked by that rule
      if (state.sCount[nextLine] < 0) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }

    str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
    max = str.length;

    for (pos = 1; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 0x5B /* [ */) {
        return false;
      } else if (ch === 0x5D /* ] */) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A /* \n */) {
        lines++;
      } else if (ch === 0x5C /* \ */) {
        pos++;
        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
    }

    if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

    // [label]:   destination   'title'
    //         ^^^ skip optional whitespace here
    for (pos = labelEnd + 2; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 0x0A) {
        lines++;
      } else if (isSpace$6(ch)) ; else {
        break;
      }
    }

    // [label]:   destination   'title'
    //            ^^^^^^^^^^^ parse this
    res = state.md.helpers.parseLinkDestination(str, pos, max);
    if (!res.ok) { return false; }

    href = state.md.normalizeLink(res.str);
    if (!state.md.validateLink(href)) { return false; }

    pos = res.pos;
    lines += res.lines;

    // save cursor state, we could require to rollback later
    destEndPos = pos;
    destEndLineNo = lines;

    // [label]:   destination   'title'
    //                       ^^^ skipping those spaces
    start = pos;
    for (; pos < max; pos++) {
      ch = str.charCodeAt(pos);
      if (ch === 0x0A) {
        lines++;
      } else if (isSpace$6(ch)) ; else {
        break;
      }
    }

    // [label]:   destination   'title'
    //                          ^^^^^^^ parse this
    res = state.md.helpers.parseLinkTitle(str, pos, max);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      lines += res.lines;
    } else {
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
    }

    // skip trailing spaces until the rest of the line
    while (pos < max) {
      ch = str.charCodeAt(pos);
      if (!isSpace$6(ch)) { break; }
      pos++;
    }

    if (pos < max && str.charCodeAt(pos) !== 0x0A) {
      if (title) {
        // garbage at the end of the line after title,
        // but it could still be a valid reference if we roll back
        title = '';
        pos = destEndPos;
        lines = destEndLineNo;
        while (pos < max) {
          ch = str.charCodeAt(pos);
          if (!isSpace$6(ch)) { break; }
          pos++;
        }
      }
    }

    if (pos < max && str.charCodeAt(pos) !== 0x0A) {
      // garbage at the end of the line
      return false;
    }

    label = normalizeReference$2(str.slice(1, labelEnd));
    if (!label) {
      // CommonMark 0.20 disallows empty labels
      return false;
    }

    // Reference can not terminate anything. This check is for safety only.
    /*istanbul ignore if*/
    if (silent) { return true; }

    if (typeof state.env.references === 'undefined') {
      state.env.references = {};
    }
    if (typeof state.env.references[label] === 'undefined') {
      state.env.references[label] = { title: title, href: href };
    }

    state.parentType = oldParentType;

    state.line = startLine + lines + 1;
    return true;
  };

  var html_blocks = [
    'address',
    'article',
    'aside',
    'base',
    'basefont',
    'blockquote',
    'body',
    'caption',
    'center',
    'col',
    'colgroup',
    'dd',
    'details',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'frame',
    'frameset',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hr',
    'html',
    'iframe',
    'legend',
    'li',
    'link',
    'main',
    'menu',
    'menuitem',
    'nav',
    'noframes',
    'ol',
    'optgroup',
    'option',
    'p',
    'param',
    'section',
    'source',
    'summary',
    'table',
    'tbody',
    'td',
    'tfoot',
    'th',
    'thead',
    'title',
    'tr',
    'track',
    'ul'
  ];

  var html_re = {};

  var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

  var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
  var single_quoted = "'[^']*'";
  var double_quoted = '"[^"]*"';

  var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

  var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

  var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

  var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
  var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
  var processing  = '<[?][\\s\\S]*?[?]>';
  var declaration = '<![A-Z]+\\s+[^>]*>';
  var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

  var HTML_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                          '|' + processing + '|' + declaration + '|' + cdata + ')');
  var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

  html_re.HTML_TAG_RE = HTML_TAG_RE$1;
  html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;

  var block_names = html_blocks;
  var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;

  // An array of opening and corresponding closing sequences for html tags,
  // last argument defines whether it can terminate a paragraph or not
  //
  var HTML_SEQUENCES = [
    [ /^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true ],
    [ /^<!--/,        /-->/,   true ],
    [ /^<\?/,         /\?>/,   true ],
    [ /^<![A-Z]/,     />/,     true ],
    [ /^<!\[CDATA\[/, /\]\]>/, true ],
    [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
    [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
  ];


  var html_block = function html_block(state, startLine, endLine, silent) {
    var i, nextLine, token, lineText,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    if (!state.md.options.html) { return false; }

    if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

    lineText = state.src.slice(pos, max);

    for (i = 0; i < HTML_SEQUENCES.length; i++) {
      if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
    }

    if (i === HTML_SEQUENCES.length) { return false; }

    if (silent) {
      // true if this sequence can be a terminator, false otherwise
      return HTML_SEQUENCES[i][2];
    }

    nextLine = startLine + 1;

    // If we are here - we detected HTML block.
    // Let's roll down till block end.
    if (!HTML_SEQUENCES[i][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) { break; }

        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);

        if (HTML_SEQUENCES[i][1].test(lineText)) {
          if (lineText.length !== 0) { nextLine++; }
          break;
        }
      }
    }

    state.line = nextLine;

    token         = state.push('html_block', '', 0);
    token.map     = [ startLine, nextLine ];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

    return true;
  };

  var isSpace$5 = utils$1.isSpace;


  var heading = function heading(state, startLine, endLine, silent) {
    var ch, level, tmp, token,
        pos = state.bMarks[startLine] + state.tShift[startLine],
        max = state.eMarks[startLine];

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    ch  = state.src.charCodeAt(pos);

    if (ch !== 0x23/* # */ || pos >= max) { return false; }

    // count heading level
    level = 1;
    ch = state.src.charCodeAt(++pos);
    while (ch === 0x23/* # */ && pos < max && level <= 6) {
      level++;
      ch = state.src.charCodeAt(++pos);
    }

    if (level > 6 || (pos < max && !isSpace$5(ch))) { return false; }

    if (silent) { return true; }

    // Let's cut tails like '    ###  ' from the end of string

    max = state.skipSpacesBack(max, pos);
    tmp = state.skipCharsBack(max, 0x23, pos); // #
    if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
      max = tmp;
    }

    state.line = startLine + 1;

    token        = state.push('heading_open', 'h' + String(level), 1);
    token.markup = '########'.slice(0, level);
    token.map    = [ startLine, state.line ];

    token          = state.push('inline', '', 0);
    token.content  = state.src.slice(pos, max).trim();
    token.map      = [ startLine, state.line ];
    token.children = [];

    token        = state.push('heading_close', 'h' + String(level), -1);
    token.markup = '########'.slice(0, level);

    return true;
  };

  var lheading = function lheading(state, startLine, endLine/*, silent*/) {
    var content, terminate, i, l, token, pos, max, level, marker,
        nextLine = startLine + 1, oldParentType,
        terminatorRules = state.md.block.ruler.getRules('paragraph');

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

    oldParentType = state.parentType;
    state.parentType = 'paragraph'; // use paragraph to match terminatorRules

    // jump line-by-line until empty one or EOF
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

      //
      // Check for underline in setext header
      //
      if (state.sCount[nextLine] >= state.blkIndent) {
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];

        if (pos < max) {
          marker = state.src.charCodeAt(pos);

          if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = (marker === 0x3D/* = */ ? 1 : 2);
              break;
            }
          }
        }
      }

      // quirk for blockquotes, this line should already be checked by that rule
      if (state.sCount[nextLine] < 0) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }

    if (!level) {
      // Didn't find valid underline
      return false;
    }

    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

    state.line = nextLine + 1;

    token          = state.push('heading_open', 'h' + String(level), 1);
    token.markup   = String.fromCharCode(marker);
    token.map      = [ startLine, state.line ];

    token          = state.push('inline', '', 0);
    token.content  = content;
    token.map      = [ startLine, state.line - 1 ];
    token.children = [];

    token          = state.push('heading_close', 'h' + String(level), -1);
    token.markup   = String.fromCharCode(marker);

    state.parentType = oldParentType;

    return true;
  };

  var paragraph = function paragraph(state, startLine/*, endLine*/) {
    var content, terminate, i, l, token, oldParentType,
        nextLine = startLine + 1,
        terminatorRules = state.md.block.ruler.getRules('paragraph'),
        endLine = state.lineMax;

    oldParentType = state.parentType;
    state.parentType = 'paragraph';

    // jump line-by-line until empty one or EOF
    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

      // quirk for blockquotes, this line should already be checked by that rule
      if (state.sCount[nextLine] < 0) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }

    content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

    state.line = nextLine;

    token          = state.push('paragraph_open', 'p', 1);
    token.map      = [ startLine, state.line ];

    token          = state.push('inline', '', 0);
    token.content  = content;
    token.map      = [ startLine, state.line ];
    token.children = [];

    token          = state.push('paragraph_close', 'p', -1);

    state.parentType = oldParentType;

    return true;
  };

  var Token$1 = token;
  var isSpace$4 = utils$1.isSpace;


  function StateBlock(src, md, env, tokens) {
    var ch, s, start, pos, len, indent, offset, indent_found;

    this.src = src;

    // link to parser instance
    this.md     = md;

    this.env = env;

    //
    // Internal state vartiables
    //

    this.tokens = tokens;

    this.bMarks = [];  // line begin offsets for fast jumps
    this.eMarks = [];  // line end offsets for fast jumps
    this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
    this.sCount = [];  // indents for each line (tabs expanded)

    // An amount of virtual spaces (tabs expanded) between beginning
    // of each line (bMarks) and real beginning of that line.
    //
    // It exists only as a hack because blockquotes override bMarks
    // losing information in the process.
    //
    // It's used only when expanding tabs, you can think about it as
    // an initial tab length, e.g. bsCount=21 applied to string `\t123`
    // means first tab should be expanded to 4-21%4 === 3 spaces.
    //
    this.bsCount = [];

    // block parser variables
    this.blkIndent  = 0; // required block content indent (for example, if we are
                         // inside a list, it would be positioned after list marker)
    this.line       = 0; // line index in src
    this.lineMax    = 0; // lines count
    this.tight      = false;  // loose/tight mode for lists
    this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
    this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

    // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
    // used in lists to determine if they interrupt a paragraph
    this.parentType = 'root';

    this.level = 0;

    // renderer
    this.result = '';

    // Create caches
    // Generate markers.
    s = this.src;
    indent_found = false;

    for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
      ch = s.charCodeAt(pos);

      if (!indent_found) {
        if (isSpace$4(ch)) {
          indent++;

          if (ch === 0x09) {
            offset += 4 - offset % 4;
          } else {
            offset++;
          }
          continue;
        } else {
          indent_found = true;
        }
      }

      if (ch === 0x0A || pos === len - 1) {
        if (ch !== 0x0A) { pos++; }
        this.bMarks.push(start);
        this.eMarks.push(pos);
        this.tShift.push(indent);
        this.sCount.push(offset);
        this.bsCount.push(0);

        indent_found = false;
        indent = 0;
        offset = 0;
        start = pos + 1;
      }
    }

    // Push fake entry to simplify cache bounds checks
    this.bMarks.push(s.length);
    this.eMarks.push(s.length);
    this.tShift.push(0);
    this.sCount.push(0);
    this.bsCount.push(0);

    this.lineMax = this.bMarks.length - 1; // don't count last fake line
  }

  // Push new token to "stream".
  //
  StateBlock.prototype.push = function (type, tag, nesting) {
    var token = new Token$1(type, tag, nesting);
    token.block = true;

    if (nesting < 0) this.level--; // closing tag
    token.level = this.level;
    if (nesting > 0) this.level++; // opening tag

    this.tokens.push(token);
    return token;
  };

  StateBlock.prototype.isEmpty = function isEmpty(line) {
    return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
  };

  StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
    for (var max = this.lineMax; from < max; from++) {
      if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
        break;
      }
    }
    return from;
  };

  // Skip spaces from given position.
  StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
    var ch;

    for (var max = this.src.length; pos < max; pos++) {
      ch = this.src.charCodeAt(pos);
      if (!isSpace$4(ch)) { break; }
    }
    return pos;
  };

  // Skip spaces from given position in reverse.
  StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
    if (pos <= min) { return pos; }

    while (pos > min) {
      if (!isSpace$4(this.src.charCodeAt(--pos))) { return pos + 1; }
    }
    return pos;
  };

  // Skip char codes from given position
  StateBlock.prototype.skipChars = function skipChars(pos, code) {
    for (var max = this.src.length; pos < max; pos++) {
      if (this.src.charCodeAt(pos) !== code) { break; }
    }
    return pos;
  };

  // Skip char codes reverse from given position - 1
  StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
    if (pos <= min) { return pos; }

    while (pos > min) {
      if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
    }
    return pos;
  };

  // cut lines range from source.
  StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
    var i, lineIndent, ch, first, last, queue, lineStart,
        line = begin;

    if (begin >= end) {
      return '';
    }

    queue = new Array(end - begin);

    for (i = 0; line < end; line++, i++) {
      lineIndent = 0;
      lineStart = first = this.bMarks[line];

      if (line + 1 < end || keepLastLF) {
        // No need for bounds check because we have fake entry on tail.
        last = this.eMarks[line] + 1;
      } else {
        last = this.eMarks[line];
      }

      while (first < last && lineIndent < indent) {
        ch = this.src.charCodeAt(first);

        if (isSpace$4(ch)) {
          if (ch === 0x09) {
            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
          } else {
            lineIndent++;
          }
        } else if (first - lineStart < this.tShift[line]) {
          // patched tShift masked characters to look like spaces (blockquotes, list markers)
          lineIndent++;
        } else {
          break;
        }

        first++;
      }

      if (lineIndent > indent) {
        // partially expanding tabs in code blocks, e.g '\t\tfoobar'
        // with indent=2 becomes '  \tfoobar'
        queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
      } else {
        queue[i] = this.src.slice(first, last);
      }
    }

    return queue.join('');
  };

  // re-export Token class to use in block rules
  StateBlock.prototype.Token = Token$1;


  var state_block = StateBlock;

  /** internal
   * class ParserBlock
   *
   * Block-level tokenizer.
   **/


  var Ruler$1           = ruler;


  var _rules$1 = [
    // First 2 params - rule name & source. Secondary array - list of rules,
    // which can be terminated by this one.
    [ 'table',      table,      [ 'paragraph', 'reference' ] ],
    [ 'code',       code ],
    [ 'fence',      fence,      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
    [ 'blockquote', blockquote, [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
    [ 'hr',         hr,         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
    [ 'list',       list,       [ 'paragraph', 'reference', 'blockquote' ] ],
    [ 'reference',  reference ],
    [ 'html_block', html_block, [ 'paragraph', 'reference', 'blockquote' ] ],
    [ 'heading',    heading,    [ 'paragraph', 'reference', 'blockquote' ] ],
    [ 'lheading',   lheading ],
    [ 'paragraph',  paragraph ]
  ];


  /**
   * new ParserBlock()
   **/
  function ParserBlock$1() {
    /**
     * ParserBlock#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of block rules.
     **/
    this.ruler = new Ruler$1();

    for (var i = 0; i < _rules$1.length; i++) {
      this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
    }
  }


  // Generate tokens for input range
  //
  ParserBlock$1.prototype.tokenize = function (state, startLine, endLine) {
    var ok, i,
        rules = this.ruler.getRules(''),
        len = rules.length,
        line = startLine,
        hasEmptyLines = false,
        maxNesting = state.md.options.maxNesting;

    while (line < endLine) {
      state.line = line = state.skipEmptyLines(line);
      if (line >= endLine) { break; }

      // Termination condition for nested calls.
      // Nested calls currently used for blockquotes & lists
      if (state.sCount[line] < state.blkIndent) { break; }

      // If nesting level exceeded - skip tail to the end. That's not ordinary
      // situation and we should not care about content.
      if (state.level >= maxNesting) {
        state.line = endLine;
        break;
      }

      // Try all possible rules.
      // On success, rule should:
      //
      // - update `state.line`
      // - update `state.tokens`
      // - return true

      for (i = 0; i < len; i++) {
        ok = rules[i](state, line, endLine, false);
        if (ok) { break; }
      }

      // set state.tight if we had an empty line before current tag
      // i.e. latest empty line should not count
      state.tight = !hasEmptyLines;

      // paragraph might "eat" one newline after it in nested lists
      if (state.isEmpty(state.line - 1)) {
        hasEmptyLines = true;
      }

      line = state.line;

      if (line < endLine && state.isEmpty(line)) {
        hasEmptyLines = true;
        line++;
        state.line = line;
      }
    }
  };


  /**
   * ParserBlock.parse(str, md, env, outTokens)
   *
   * Process input string and push block tokens into `outTokens`
   **/
  ParserBlock$1.prototype.parse = function (src, md, env, outTokens) {
    var state;

    if (!src) { return; }

    state = new this.State(src, md, env, outTokens);

    this.tokenize(state, state.line, state.lineMax);
  };


  ParserBlock$1.prototype.State = state_block;


  var parser_block = ParserBlock$1;

  // Rule to skip pure text
  // '{}$%@~+=:' reserved for extentions

  // !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

  // !!!! Don't confuse with "Markdown ASCII Punctuation" chars
  // http://spec.commonmark.org/0.15/#ascii-punctuation-character
  function isTerminatorChar(ch) {
    switch (ch) {
      case 0x0A/* \n */:
      case 0x21/* ! */:
      case 0x23/* # */:
      case 0x24/* $ */:
      case 0x25/* % */:
      case 0x26/* & */:
      case 0x2A/* * */:
      case 0x2B/* + */:
      case 0x2D/* - */:
      case 0x3A/* : */:
      case 0x3C/* < */:
      case 0x3D/* = */:
      case 0x3E/* > */:
      case 0x40/* @ */:
      case 0x5B/* [ */:
      case 0x5C/* \ */:
      case 0x5D/* ] */:
      case 0x5E/* ^ */:
      case 0x5F/* _ */:
      case 0x60/* ` */:
      case 0x7B/* { */:
      case 0x7D/* } */:
      case 0x7E/* ~ */:
        return true;
      default:
        return false;
    }
  }

  var text$1 = function text(state, silent) {
    var pos = state.pos;

    while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
      pos++;
    }

    if (pos === state.pos) { return false; }

    if (!silent) { state.pending += state.src.slice(state.pos, pos); }

    state.pos = pos;

    return true;
  };

  var isSpace$3 = utils$1.isSpace;


  var newline = function newline(state, silent) {
    var pmax, max, ws, pos = state.pos;

    if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

    pmax = state.pending.length - 1;
    max = state.posMax;

    // '  \n' -> hardbreak
    // Lookup in pending chars is bad practice! Don't copy to other rules!
    // Pending string is stored in concat mode, indexed lookups will cause
    // convertion to flat mode.
    if (!silent) {
      if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
        if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
          // Find whitespaces tail of pending chars.
          ws = pmax - 1;
          while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;

          state.pending = state.pending.slice(0, ws);
          state.push('hardbreak', 'br', 0);
        } else {
          state.pending = state.pending.slice(0, -1);
          state.push('softbreak', 'br', 0);
        }

      } else {
        state.push('softbreak', 'br', 0);
      }
    }

    pos++;

    // skip heading spaces for next line
    while (pos < max && isSpace$3(state.src.charCodeAt(pos))) { pos++; }

    state.pos = pos;
    return true;
  };

  var isSpace$2 = utils$1.isSpace;

  var ESCAPED = [];

  for (var i$5 = 0; i$5 < 256; i$5++) { ESCAPED.push(0); }

  '\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
    .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


  var _escape = function escape(state, silent) {
    var ch, pos = state.pos, max = state.posMax;

    if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

    pos++;

    if (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch < 256 && ESCAPED[ch] !== 0) {
        if (!silent) { state.pending += state.src[pos]; }
        state.pos += 2;
        return true;
      }

      if (ch === 0x0A) {
        if (!silent) {
          state.push('hardbreak', 'br', 0);
        }

        pos++;
        // skip leading whitespaces from next line
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (!isSpace$2(ch)) { break; }
          pos++;
        }

        state.pos = pos;
        return true;
      }
    }

    if (!silent) { state.pending += '\\'; }
    state.pos++;
    return true;
  };

  var backticks = function backtick(state, silent) {
    var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,
        pos = state.pos,
        ch = state.src.charCodeAt(pos);

    if (ch !== 0x60/* ` */) { return false; }

    start = pos;
    pos++;
    max = state.posMax;

    // scan marker length
    while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

    marker = state.src.slice(start, pos);
    openerLength = marker.length;

    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent) state.pending += marker;
      state.pos += openerLength;
      return true;
    }

    matchStart = matchEnd = pos;

    // Nothing found in the cache, scan until the end of the line (or until marker is found)
    while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
      matchEnd = matchStart + 1;

      // scan marker length
      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

      closerLength = matchEnd - matchStart;

      if (closerLength === openerLength) {
        // Found matching closer length.
        if (!silent) {
          token     = state.push('code_inline', 'code', 0);
          token.markup  = marker;
          token.content = state.src.slice(pos, matchStart)
            .replace(/\n/g, ' ')
            .replace(/^ (.+) $/, '$1');
        }
        state.pos = matchEnd;
        return true;
      }

      // Some different length found, put it in cache as upper limit of where closer can be found
      state.backticks[closerLength] = matchStart;
    }

    // Scanned through the end, didn't find anything
    state.backticksScanned = true;

    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  };

  var strikethrough = {};

  // Insert each marker as a separate text token, and add it to delimiter list
  //
  strikethrough.tokenize = function strikethrough(state, silent) {
    var i, scanned, token, len, ch,
        start = state.pos,
        marker = state.src.charCodeAt(start);

    if (silent) { return false; }

    if (marker !== 0x7E/* ~ */) { return false; }

    scanned = state.scanDelims(state.pos, true);
    len = scanned.length;
    ch = String.fromCharCode(marker);

    if (len < 2) { return false; }

    if (len % 2) {
      token         = state.push('text', '', 0);
      token.content = ch;
      len--;
    }

    for (i = 0; i < len; i += 2) {
      token         = state.push('text', '', 0);
      token.content = ch + ch;

      state.delimiters.push({
        marker: marker,
        length: 0,     // disable "rule of 3" length checks meant for emphasis
        token:  state.tokens.length - 1,
        end:    -1,
        open:   scanned.can_open,
        close:  scanned.can_close
      });
    }

    state.pos += scanned.length;

    return true;
  };


  function postProcess$1(state, delimiters) {
    var i, j,
        startDelim,
        endDelim,
        token,
        loneMarkers = [],
        max = delimiters.length;

    for (i = 0; i < max; i++) {
      startDelim = delimiters[i];

      if (startDelim.marker !== 0x7E/* ~ */) {
        continue;
      }

      if (startDelim.end === -1) {
        continue;
      }

      endDelim = delimiters[startDelim.end];

      token         = state.tokens[startDelim.token];
      token.type    = 's_open';
      token.tag     = 's';
      token.nesting = 1;
      token.markup  = '~~';
      token.content = '';

      token         = state.tokens[endDelim.token];
      token.type    = 's_close';
      token.tag     = 's';
      token.nesting = -1;
      token.markup  = '~~';
      token.content = '';

      if (state.tokens[endDelim.token - 1].type === 'text' &&
          state.tokens[endDelim.token - 1].content === '~') {

        loneMarkers.push(endDelim.token - 1);
      }
    }

    // If a marker sequence has an odd number of characters, it's splitted
    // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
    // start of the sequence.
    //
    // So, we have to move all those markers after subsequent s_close tags.
    //
    while (loneMarkers.length) {
      i = loneMarkers.pop();
      j = i + 1;

      while (j < state.tokens.length && state.tokens[j].type === 's_close') {
        j++;
      }

      j--;

      if (i !== j) {
        token = state.tokens[j];
        state.tokens[j] = state.tokens[i];
        state.tokens[i] = token;
      }
    }
  }


  // Walk through delimiter list and replace text tokens with tags
  //
  strikethrough.postProcess = function strikethrough(state) {
    var curr,
        tokens_meta = state.tokens_meta,
        max = state.tokens_meta.length;

    postProcess$1(state, state.delimiters);

    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess$1(state, tokens_meta[curr].delimiters);
      }
    }
  };

  var emphasis = {};

  // Insert each marker as a separate text token, and add it to delimiter list
  //
  emphasis.tokenize = function emphasis(state, silent) {
    var i, scanned, token,
        start = state.pos,
        marker = state.src.charCodeAt(start);

    if (silent) { return false; }

    if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

    scanned = state.scanDelims(state.pos, marker === 0x2A);

    for (i = 0; i < scanned.length; i++) {
      token         = state.push('text', '', 0);
      token.content = String.fromCharCode(marker);

      state.delimiters.push({
        // Char code of the starting marker (number).
        //
        marker: marker,

        // Total length of these series of delimiters.
        //
        length: scanned.length,

        // A position of the token this delimiter corresponds to.
        //
        token:  state.tokens.length - 1,

        // If this delimiter is matched as a valid opener, `end` will be
        // equal to its position, otherwise it's `-1`.
        //
        end:    -1,

        // Boolean flags that determine if this delimiter could open or close
        // an emphasis.
        //
        open:   scanned.can_open,
        close:  scanned.can_close
      });
    }

    state.pos += scanned.length;

    return true;
  };


  function postProcess(state, delimiters) {
    var i,
        startDelim,
        endDelim,
        token,
        ch,
        isStrong,
        max = delimiters.length;

    for (i = max - 1; i >= 0; i--) {
      startDelim = delimiters[i];

      if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
        continue;
      }

      // Process only opening markers
      if (startDelim.end === -1) {
        continue;
      }

      endDelim = delimiters[startDelim.end];

      // If the previous delimiter has the same marker and is adjacent to this one,
      // merge those into one strong delimiter.
      //
      // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
      //
      isStrong = i > 0 &&
                 delimiters[i - 1].end === startDelim.end + 1 &&
                 // check that first two markers match and adjacent
                 delimiters[i - 1].marker === startDelim.marker &&
                 delimiters[i - 1].token === startDelim.token - 1 &&
                 // check that last two markers are adjacent (we can safely assume they match)
                 delimiters[startDelim.end + 1].token === endDelim.token + 1;

      ch = String.fromCharCode(startDelim.marker);

      token         = state.tokens[startDelim.token];
      token.type    = isStrong ? 'strong_open' : 'em_open';
      token.tag     = isStrong ? 'strong' : 'em';
      token.nesting = 1;
      token.markup  = isStrong ? ch + ch : ch;
      token.content = '';

      token         = state.tokens[endDelim.token];
      token.type    = isStrong ? 'strong_close' : 'em_close';
      token.tag     = isStrong ? 'strong' : 'em';
      token.nesting = -1;
      token.markup  = isStrong ? ch + ch : ch;
      token.content = '';

      if (isStrong) {
        state.tokens[delimiters[i - 1].token].content = '';
        state.tokens[delimiters[startDelim.end + 1].token].content = '';
        i--;
      }
    }
  }


  // Walk through delimiter list and replace text tokens with tags
  //
  emphasis.postProcess = function emphasis(state) {
    var curr,
        tokens_meta = state.tokens_meta,
        max = state.tokens_meta.length;

    postProcess(state, state.delimiters);

    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        postProcess(state, tokens_meta[curr].delimiters);
      }
    }
  };

  var normalizeReference$1   = utils$1.normalizeReference;
  var isSpace$1              = utils$1.isSpace;


  var link = function link(state, silent) {
    var attrs,
        code,
        label,
        labelEnd,
        labelStart,
        pos,
        res,
        ref,
        token,
        href = '',
        title = '',
        oldPos = state.pos,
        max = state.posMax,
        start = state.pos,
        parseReference = true;

    if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

    labelStart = state.pos + 1;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

    // parser failed to find ']', so it's not a valid link
    if (labelEnd < 0) { return false; }

    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
      //
      // Inline link
      //

      // might have found a valid shortcut link, disable reference parsing
      parseReference = false;

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace$1(code) && code !== 0x0A) { break; }
      }
      if (pos >= max) { return false; }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }

        // [link](  <href>  "title"  )
        //                ^^ skipping these spaces
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$1(code) && code !== 0x0A) { break; }
        }

        // [link](  <href>  "title"  )
        //                  ^^^^^^^ parsing link title
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;

          // [link](  <href>  "title"  )
          //                         ^^ skipping these spaces
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace$1(code) && code !== 0x0A) { break; }
          }
        }
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
        // parsing a valid shortcut link failed, fallback to reference
        parseReference = true;
      }
      pos++;
    }

    if (parseReference) {
      //
      // Link reference
      //
      if (typeof state.env.references === 'undefined') { return false; }

      if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }

      // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)
      if (!label) { label = state.src.slice(labelStart, labelEnd); }

      ref = state.env.references[normalizeReference$1(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }

    //
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    //
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;

      token        = state.push('link_open', 'a', 1);
      token.attrs  = attrs = [ [ 'href', href ] ];
      if (title) {
        attrs.push([ 'title', title ]);
      }

      state.md.inline.tokenize(state);

      token        = state.push('link_close', 'a', -1);
    }

    state.pos = pos;
    state.posMax = max;
    return true;
  };

  var normalizeReference   = utils$1.normalizeReference;
  var isSpace              = utils$1.isSpace;


  var image$1 = function image(state, silent) {
    var attrs,
        code,
        content,
        label,
        labelEnd,
        labelStart,
        pos,
        ref,
        res,
        title,
        token,
        tokens,
        start,
        href = '',
        oldPos = state.pos,
        max = state.posMax;

    if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
    if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

    labelStart = state.pos + 2;
    labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

    // parser failed to find ']', so it's not a valid link
    if (labelEnd < 0) { return false; }

    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
      //
      // Inline link
      //

      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }
      if (pos >= max) { return false; }

      // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination
      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        href = state.md.normalizeLink(res.str);
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) { break; }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      //
      // Link reference
      //
      if (typeof state.env.references === 'undefined') { return false; }

      if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }

      // covers label === '' and label === undefined
      // (collapsed reference link and shortcut reference link respectively)
      if (!label) { label = state.src.slice(labelStart, labelEnd); }

      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }

    //
    // We found the end of the link, and know for a fact it's a valid link;
    // so all that's left to do is to call tokenizer.
    //
    if (!silent) {
      content = state.src.slice(labelStart, labelEnd);

      state.md.inline.parse(
        content,
        state.md,
        state.env,
        tokens = []
      );

      token          = state.push('image', 'img', 0);
      token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
      token.children = tokens;
      token.content  = content;

      if (title) {
        attrs.push([ 'title', title ]);
      }
    }

    state.pos = pos;
    state.posMax = max;
    return true;
  };

  /*eslint max-len:0*/
  var EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
  var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;


  var autolink = function autolink(state, silent) {
    var url, fullUrl, token, ch, start, max,
        pos = state.pos;

    if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

    start = state.pos;
    max = state.posMax;

    for (;;) {
      if (++pos >= max) return false;

      ch = state.src.charCodeAt(pos);

      if (ch === 0x3C /* < */) return false;
      if (ch === 0x3E /* > */) break;
    }

    url = state.src.slice(start + 1, pos);

    if (AUTOLINK_RE.test(url)) {
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl)) { return false; }

      if (!silent) {
        token         = state.push('link_open', 'a', 1);
        token.attrs   = [ [ 'href', fullUrl ] ];
        token.markup  = 'autolink';
        token.info    = 'auto';

        token         = state.push('text', '', 0);
        token.content = state.md.normalizeLinkText(url);

        token         = state.push('link_close', 'a', -1);
        token.markup  = 'autolink';
        token.info    = 'auto';
      }

      state.pos += url.length + 2;
      return true;
    }

    if (EMAIL_RE.test(url)) {
      fullUrl = state.md.normalizeLink('mailto:' + url);
      if (!state.md.validateLink(fullUrl)) { return false; }

      if (!silent) {
        token         = state.push('link_open', 'a', 1);
        token.attrs   = [ [ 'href', fullUrl ] ];
        token.markup  = 'autolink';
        token.info    = 'auto';

        token         = state.push('text', '', 0);
        token.content = state.md.normalizeLinkText(url);

        token         = state.push('link_close', 'a', -1);
        token.markup  = 'autolink';
        token.info    = 'auto';
      }

      state.pos += url.length + 2;
      return true;
    }

    return false;
  };

  var HTML_TAG_RE = html_re.HTML_TAG_RE;


  function isLetter$1(ch) {
    /*eslint no-bitwise:0*/
    var lc = ch | 0x20; // to lower case
    return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
  }


  var html_inline = function html_inline(state, silent) {
    var ch, match, max, token,
        pos = state.pos;

    if (!state.md.options.html) { return false; }

    // Check start
    max = state.posMax;
    if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
        pos + 2 >= max) {
      return false;
    }

    // Quick fail on second char
    ch = state.src.charCodeAt(pos + 1);
    if (ch !== 0x21/* ! */ &&
        ch !== 0x3F/* ? */ &&
        ch !== 0x2F/* / */ &&
        !isLetter$1(ch)) {
      return false;
    }

    match = state.src.slice(pos).match(HTML_TAG_RE);
    if (!match) { return false; }

    if (!silent) {
      token         = state.push('html_inline', '', 0);
      token.content = state.src.slice(pos, pos + match[0].length);
    }
    state.pos += match[0].length;
    return true;
  };

  var entities          = entities$1;
  var has$1               = utils$1.has;
  var isValidEntityCode = utils$1.isValidEntityCode;
  var fromCodePoint$2     = utils$1.fromCodePoint;


  var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
  var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


  var entity = function entity(state, silent) {
    var ch, code, match, pos = state.pos, max = state.posMax;

    if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

    if (pos + 1 < max) {
      ch = state.src.charCodeAt(pos + 1);

      if (ch === 0x23 /* # */) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint$2(code) : fromCodePoint$2(0xFFFD);
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has$1(entities, match[1])) {
            if (!silent) { state.pending += entities[match[1]]; }
            state.pos += match[0].length;
            return true;
          }
        }
      }
    }

    if (!silent) { state.pending += '&'; }
    state.pos++;
    return true;
  };

  function processDelimiters(state, delimiters) {
    var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
        isOddMatch, lastJump,
        openersBottom = {},
        max = delimiters.length;

    if (!max) return;

    // headerIdx is the first delimiter of the current (where closer is) delimiter run
    var headerIdx = 0;
    var lastTokenIdx = -2; // needs any value lower than -1
    var jumps = [];

    for (closerIdx = 0; closerIdx < max; closerIdx++) {
      closer = delimiters[closerIdx];

      jumps.push(0);

      // markers belong to same delimiter run if:
      //  - they have adjacent tokens
      //  - AND markers are the same
      //
      if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
        headerIdx = closerIdx;
      }

      lastTokenIdx = closer.token;

      // Length is only used for emphasis-specific "rule of 3",
      // if it's not defined (in strikethrough or 3rd party plugins),
      // we can default it to 0 to disable those checks.
      //
      closer.length = closer.length || 0;

      if (!closer.close) continue;

      // Previously calculated lower bounds (previous fails)
      // for each marker, each delimiter length modulo 3,
      // and for whether this closer can be an opener;
      // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
      if (!openersBottom.hasOwnProperty(closer.marker)) {
        openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];
      }

      minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];

      openerIdx = headerIdx - jumps[headerIdx] - 1;

      newMinOpenerIdx = openerIdx;

      for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
        opener = delimiters[openerIdx];

        if (opener.marker !== closer.marker) continue;

        if (opener.open && opener.end < 0) {

          isOddMatch = false;

          // from spec:
          //
          // If one of the delimiters can both open and close emphasis, then the
          // sum of the lengths of the delimiter runs containing the opening and
          // closing delimiters must not be a multiple of 3 unless both lengths
          // are multiples of 3.
          //
          if (opener.close || closer.open) {
            if ((opener.length + closer.length) % 3 === 0) {
              if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                isOddMatch = true;
              }
            }
          }

          if (!isOddMatch) {
            // If previous delimiter cannot be an opener, we can safely skip
            // the entire sequence in future checks. This is required to make
            // sure algorithm has linear complexity (see *_*_*_*_*_... case).
            //
            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
              jumps[openerIdx - 1] + 1 :
              0;

            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
            jumps[openerIdx] = lastJump;

            closer.open  = false;
            opener.end   = closerIdx;
            opener.close = false;
            newMinOpenerIdx = -1;
            // treat next token as start of run,
            // it optimizes skips in **<...>**a**<...>** pathological case
            lastTokenIdx = -2;
            break;
          }
        }
      }

      if (newMinOpenerIdx !== -1) {
        // If match for this delimiter run failed, we want to set lower bound for
        // future lookups. This is required to make sure algorithm has linear
        // complexity.
        //
        // See details here:
        // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
        //
        openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;
      }
    }
  }


  var balance_pairs = function link_pairs(state) {
    var curr,
        tokens_meta = state.tokens_meta,
        max = state.tokens_meta.length;

    processDelimiters(state, state.delimiters);

    for (curr = 0; curr < max; curr++) {
      if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
        processDelimiters(state, tokens_meta[curr].delimiters);
      }
    }
  };

  var text_collapse = function text_collapse(state) {
    var curr, last,
        level = 0,
        tokens = state.tokens,
        max = state.tokens.length;

    for (curr = last = 0; curr < max; curr++) {
      // re-calculate levels after emphasis/strikethrough turns some text nodes
      // into opening/closing tags
      if (tokens[curr].nesting < 0) level--; // closing tag
      tokens[curr].level = level;
      if (tokens[curr].nesting > 0) level++; // opening tag

      if (tokens[curr].type === 'text' &&
          curr + 1 < max &&
          tokens[curr + 1].type === 'text') {

        // collapse two adjacent text nodes
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) { tokens[last] = tokens[curr]; }

        last++;
      }
    }

    if (curr !== last) {
      tokens.length = last;
    }
  };

  var Token          = token;
  var isWhiteSpace$1   = utils$1.isWhiteSpace;
  var isPunctChar    = utils$1.isPunctChar;
  var isMdAsciiPunct = utils$1.isMdAsciiPunct;


  function StateInline(src, md, env, outTokens) {
    this.src = src;
    this.env = env;
    this.md = md;
    this.tokens = outTokens;
    this.tokens_meta = Array(outTokens.length);

    this.pos = 0;
    this.posMax = this.src.length;
    this.level = 0;
    this.pending = '';
    this.pendingLevel = 0;

    // Stores { start: end } pairs. Useful for backtrack
    // optimization of pairs parse (emphasis, strikes).
    this.cache = {};

    // List of emphasis-like delimiters for current tag
    this.delimiters = [];

    // Stack of delimiter lists for upper level tags
    this._prev_delimiters = [];

    // backtick length => last seen position
    this.backticks = {};
    this.backticksScanned = false;
  }


  // Flush pending text
  //
  StateInline.prototype.pushPending = function () {
    var token = new Token('text', '', 0);
    token.content = this.pending;
    token.level = this.pendingLevel;
    this.tokens.push(token);
    this.pending = '';
    return token;
  };


  // Push new token to "stream".
  // If pending text exists - flush it as text token
  //
  StateInline.prototype.push = function (type, tag, nesting) {
    if (this.pending) {
      this.pushPending();
    }

    var token = new Token(type, tag, nesting);
    var token_meta = null;

    if (nesting < 0) {
      // closing tag
      this.level--;
      this.delimiters = this._prev_delimiters.pop();
    }

    token.level = this.level;

    if (nesting > 0) {
      // opening tag
      this.level++;
      this._prev_delimiters.push(this.delimiters);
      this.delimiters = [];
      token_meta = { delimiters: this.delimiters };
    }

    this.pendingLevel = this.level;
    this.tokens.push(token);
    this.tokens_meta.push(token_meta);
    return token;
  };


  // Scan a sequence of emphasis-like markers, and determine whether
  // it can start an emphasis sequence or end an emphasis sequence.
  //
  //  - start - position to scan from (it should point at a valid marker);
  //  - canSplitWord - determine if these markers can be found inside a word
  //
  StateInline.prototype.scanDelims = function (start, canSplitWord) {
    var pos = start, lastChar, nextChar, count, can_open, can_close,
        isLastWhiteSpace, isLastPunctChar,
        isNextWhiteSpace, isNextPunctChar,
        left_flanking = true,
        right_flanking = true,
        max = this.posMax,
        marker = this.src.charCodeAt(start);

    // treat beginning of the line as a whitespace
    lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

    while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

    count = pos - start;

    // treat end of the line as a whitespace
    nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

    isLastWhiteSpace = isWhiteSpace$1(lastChar);
    isNextWhiteSpace = isWhiteSpace$1(nextChar);

    if (isNextWhiteSpace) {
      left_flanking = false;
    } else if (isNextPunctChar) {
      if (!(isLastWhiteSpace || isLastPunctChar)) {
        left_flanking = false;
      }
    }

    if (isLastWhiteSpace) {
      right_flanking = false;
    } else if (isLastPunctChar) {
      if (!(isNextWhiteSpace || isNextPunctChar)) {
        right_flanking = false;
      }
    }

    if (!canSplitWord) {
      can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
      can_close = right_flanking && (!left_flanking  || isNextPunctChar);
    } else {
      can_open  = left_flanking;
      can_close = right_flanking;
    }

    return {
      can_open:  can_open,
      can_close: can_close,
      length:    count
    };
  };


  // re-export Token class to use in block rules
  StateInline.prototype.Token = Token;


  var state_inline = StateInline;

  /** internal
   * class ParserInline
   *
   * Tokenizes paragraph content.
   **/


  var Ruler           = ruler;


  ////////////////////////////////////////////////////////////////////////////////
  // Parser rules

  var _rules = [
    [ 'text',            text$1 ],
    [ 'newline',         newline ],
    [ 'escape',          _escape ],
    [ 'backticks',       backticks ],
    [ 'strikethrough',   strikethrough.tokenize ],
    [ 'emphasis',        emphasis.tokenize ],
    [ 'link',            link ],
    [ 'image',           image$1 ],
    [ 'autolink',        autolink ],
    [ 'html_inline',     html_inline ],
    [ 'entity',          entity ]
  ];

  var _rules2 = [
    [ 'balance_pairs',   balance_pairs ],
    [ 'strikethrough',   strikethrough.postProcess ],
    [ 'emphasis',        emphasis.postProcess ],
    [ 'text_collapse',   text_collapse ]
  ];


  /**
   * new ParserInline()
   **/
  function ParserInline$1() {
    var i;

    /**
     * ParserInline#ruler -> Ruler
     *
     * [[Ruler]] instance. Keep configuration of inline rules.
     **/
    this.ruler = new Ruler();

    for (i = 0; i < _rules.length; i++) {
      this.ruler.push(_rules[i][0], _rules[i][1]);
    }

    /**
     * ParserInline#ruler2 -> Ruler
     *
     * [[Ruler]] instance. Second ruler used for post-processing
     * (e.g. in emphasis-like rules).
     **/
    this.ruler2 = new Ruler();

    for (i = 0; i < _rules2.length; i++) {
      this.ruler2.push(_rules2[i][0], _rules2[i][1]);
    }
  }


  // Skip single token by running all rules in validation mode;
  // returns `true` if any rule reported success
  //
  ParserInline$1.prototype.skipToken = function (state) {
    var ok, i, pos = state.pos,
        rules = this.ruler.getRules(''),
        len = rules.length,
        maxNesting = state.md.options.maxNesting,
        cache = state.cache;


    if (typeof cache[pos] !== 'undefined') {
      state.pos = cache[pos];
      return;
    }

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        // Increment state.level and decrement it later to limit recursion.
        // It's harmless to do here, because no tokens are created. But ideally,
        // we'd need a separate private state variable for this purpose.
        //
        state.level++;
        ok = rules[i](state, true);
        state.level--;

        if (ok) { break; }
      }
    } else {
      // Too much nesting, just skip until the end of the paragraph.
      //
      // NOTE: this will cause links to behave incorrectly in the following case,
      //       when an amount of `[` is exactly equal to `maxNesting + 1`:
      //
      //       [[[[[[[[[[[[[[[[[[[[[foo]()
      //
      // TODO: remove this workaround when CM standard will allow nested links
      //       (we can replace it by preventing links from being parsed in
      //       validation mode)
      //
      state.pos = state.posMax;
    }

    if (!ok) { state.pos++; }
    cache[pos] = state.pos;
  };


  // Generate tokens for input range
  //
  ParserInline$1.prototype.tokenize = function (state) {
    var ok, i,
        rules = this.ruler.getRules(''),
        len = rules.length,
        end = state.posMax,
        maxNesting = state.md.options.maxNesting;

    while (state.pos < end) {
      // Try all possible rules.
      // On success, rule should:
      //
      // - update `state.pos`
      // - update `state.tokens`
      // - return true

      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          ok = rules[i](state, false);
          if (ok) { break; }
        }
      }

      if (ok) {
        if (state.pos >= end) { break; }
        continue;
      }

      state.pending += state.src[state.pos++];
    }

    if (state.pending) {
      state.pushPending();
    }
  };


  /**
   * ParserInline.parse(str, md, env, outTokens)
   *
   * Process input string and push inline tokens into `outTokens`
   **/
  ParserInline$1.prototype.parse = function (str, md, env, outTokens) {
    var i, rules, len;
    var state = new this.State(str, md, env, outTokens);

    this.tokenize(state);

    rules = this.ruler2.getRules('');
    len = rules.length;

    for (i = 0; i < len; i++) {
      rules[i](state);
    }
  };


  ParserInline$1.prototype.State = state_inline;


  var parser_inline = ParserInline$1;

  var re = function (opts) {
    var re = {};

    // Use direct extract instead of `regenerate` to reduse browserified size
    re.src_Any = regex$3.source;
    re.src_Cc  = regex$2.source;
    re.src_Z   = regex.source;
    re.src_P   = regex$4.source;

    // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
    re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

    // \p{\Z\Cc} (white spaces + control)
    re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

    // Experimental. List of chars, completely prohibited in links
    // because can separate it from other part of text
    var text_separators = '[><\uff5c]';

    // All possible word characters (everything without punctuation, spaces & controls)
    // Defined via punctuation & spaces to save space
    // Should be something like \p{\L\N\S\M} (\w but without `_`)
    re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
    // The same as abothe but without [0-9]
    // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

    ////////////////////////////////////////////////////////////////////////////////

    re.src_ip4 =

      '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

    // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
    re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

    re.src_port =

      '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

    re.src_host_terminator =

      '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

    re.src_path =

      '(?:' +
        '[/?#]' +
          '(?:' +
            '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-;]).|' +
            '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
            '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
            '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
            '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
            "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
            "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
            '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                       // github has ... in commit range links,
                                       // Restrict to
                                       // - english
                                       // - percent-encoded
                                       // - parts of file path
                                       // - params separator
                                       // until more examples found.
            '\\.(?!' + re.src_ZCc + '|[.]).|' +
            (opts && opts['---'] ?
              '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
              :
              '\\-+|'
            ) +
            ',(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
            ';(?!' + re.src_ZCc + ').|' +       // allow `;` if not followed by space-like char
            '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
            '\\?(?!' + re.src_ZCc + '|[?]).' +
          ')+' +
        '|\\/' +
      ')?';

    // Allow anything in markdown spec, forbid quote (") at the first position
    // because emails enclosed in quotes are far more common
    re.src_email_name =

      '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

    re.src_xn =

      'xn--[a-z0-9\\-]{1,59}';

    // More to read about domain names
    // http://serverfault.com/questions/638260/

    re.src_domain_root =

      // Allow letters & digits (http://test1)
      '(?:' +
        re.src_xn +
        '|' +
        re.src_pseudo_letter + '{1,63}' +
      ')';

    re.src_domain =

      '(?:' +
        re.src_xn +
        '|' +
        '(?:' + re.src_pseudo_letter + ')' +
        '|' +
        '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
      ')';

    re.src_host =

      '(?:' +
      // Don't need IP check, because digits are already allowed in normal domain names
      //   src_ip4 +
      // '|' +
        '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
      ')';

    re.tpl_host_fuzzy =

      '(?:' +
        re.src_ip4 +
      '|' +
        '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
      ')';

    re.tpl_host_no_ip_fuzzy =

      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

    re.src_host_strict =

      re.src_host + re.src_host_terminator;

    re.tpl_host_fuzzy_strict =

      re.tpl_host_fuzzy + re.src_host_terminator;

    re.src_host_port_strict =

      re.src_host + re.src_port + re.src_host_terminator;

    re.tpl_host_port_fuzzy_strict =

      re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

    re.tpl_host_port_no_ip_fuzzy_strict =

      re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


    ////////////////////////////////////////////////////////////////////////////////
    // Main rules

    // Rude test fuzzy links by host, for quick deny
    re.tpl_host_fuzzy_test =

      'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

    re.tpl_email_fuzzy =

        '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
        '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

    re.tpl_link_fuzzy =
        // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
        '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

    re.tpl_link_no_ip_fuzzy =
        // Fuzzy link can't be prepended with .:/\- and non punctuation.
        // but can start with > (markdown blockquote)
        '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
        '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

    return re;
  };

  ////////////////////////////////////////////////////////////////////////////////
  // Helpers

  // Merge objects
  //
  function assign(obj /*from1, from2, from3, ...*/) {
    var sources = Array.prototype.slice.call(arguments, 1);

    sources.forEach(function (source) {
      if (!source) { return; }

      Object.keys(source).forEach(function (key) {
        obj[key] = source[key];
      });
    });

    return obj;
  }

  function _class(obj) { return Object.prototype.toString.call(obj); }
  function isString(obj) { return _class(obj) === '[object String]'; }
  function isObject$9(obj) { return _class(obj) === '[object Object]'; }
  function isRegExp$2(obj) { return _class(obj) === '[object RegExp]'; }
  function isFunction(obj) { return _class(obj) === '[object Function]'; }


  function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

  ////////////////////////////////////////////////////////////////////////////////


  var defaultOptions = {
    fuzzyLink: true,
    fuzzyEmail: true,
    fuzzyIP: false
  };


  function isOptionsObj(obj) {
    return Object.keys(obj || {}).reduce(function (acc, k) {
      return acc || defaultOptions.hasOwnProperty(k);
    }, false);
  }


  var defaultSchemas = {
    'http:': {
      validate: function (text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.http) {
          // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.http =  new RegExp(
            '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
          );
        }
        if (self.re.http.test(tail)) {
          return tail.match(self.re.http)[0].length;
        }
        return 0;
      }
    },
    'https:':  'http:',
    'ftp:':    'http:',
    '//':      {
      validate: function (text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
          self.re.no_http =  new RegExp(
            '^' +
            self.re.src_auth +
            // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
            self.re.src_port +
            self.re.src_host_terminator +
            self.re.src_path,

            'i'
          );
        }

        if (self.re.no_http.test(tail)) {
          // should not be `://` & `///`, that protects from errors in protocol name
          if (pos >= 3 && text[pos - 3] === ':') { return 0; }
          if (pos >= 3 && text[pos - 3] === '/') { return 0; }
          return tail.match(self.re.no_http)[0].length;
        }
        return 0;
      }
    },
    'mailto:': {
      validate: function (text, pos, self) {
        var tail = text.slice(pos);

        if (!self.re.mailto) {
          self.re.mailto =  new RegExp(
            '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
          );
        }
        if (self.re.mailto.test(tail)) {
          return tail.match(self.re.mailto)[0].length;
        }
        return 0;
      }
    }
  };

  /*eslint-disable max-len*/

  // RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
  var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

  // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
  var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

  /*eslint-enable max-len*/

  ////////////////////////////////////////////////////////////////////////////////

  function resetScanCache(self) {
    self.__index__ = -1;
    self.__text_cache__   = '';
  }

  function createValidator(re) {
    return function (text, pos) {
      var tail = text.slice(pos);

      if (re.test(tail)) {
        return tail.match(re)[0].length;
      }
      return 0;
    };
  }

  function createNormalizer() {
    return function (match, self) {
      self.normalize(match);
    };
  }

  // Schemas compiler. Build regexps.
  //
  function compile(self) {

    // Load & clone RE patterns.
    var re$1 = self.re = re(self.__opts__);

    // Define dynamic patterns
    var tlds = self.__tlds__.slice();

    self.onCompile();

    if (!self.__tlds_replaced__) {
      tlds.push(tlds_2ch_src_re);
    }
    tlds.push(re$1.src_xn);

    re$1.src_tlds = tlds.join('|');

    function untpl(tpl) { return tpl.replace('%TLDS%', re$1.src_tlds); }

    re$1.email_fuzzy      = RegExp(untpl(re$1.tpl_email_fuzzy), 'i');
    re$1.link_fuzzy       = RegExp(untpl(re$1.tpl_link_fuzzy), 'i');
    re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), 'i');
    re$1.host_fuzzy_test  = RegExp(untpl(re$1.tpl_host_fuzzy_test), 'i');

    //
    // Compile each schema
    //

    var aliases = [];

    self.__compiled__ = {}; // Reset compiled data

    function schemaError(name, val) {
      throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
    }

    Object.keys(self.__schemas__).forEach(function (name) {
      var val = self.__schemas__[name];

      // skip disabled methods
      if (val === null) { return; }

      var compiled = { validate: null, link: null };

      self.__compiled__[name] = compiled;

      if (isObject$9(val)) {
        if (isRegExp$2(val.validate)) {
          compiled.validate = createValidator(val.validate);
        } else if (isFunction(val.validate)) {
          compiled.validate = val.validate;
        } else {
          schemaError(name, val);
        }

        if (isFunction(val.normalize)) {
          compiled.normalize = val.normalize;
        } else if (!val.normalize) {
          compiled.normalize = createNormalizer();
        } else {
          schemaError(name, val);
        }

        return;
      }

      if (isString(val)) {
        aliases.push(name);
        return;
      }

      schemaError(name, val);
    });

    //
    // Compile postponed aliases
    //

    aliases.forEach(function (alias) {
      if (!self.__compiled__[self.__schemas__[alias]]) {
        // Silently fail on missed schemas to avoid errons on disable.
        // schemaError(alias, self.__schemas__[alias]);
        return;
      }

      self.__compiled__[alias].validate =
        self.__compiled__[self.__schemas__[alias]].validate;
      self.__compiled__[alias].normalize =
        self.__compiled__[self.__schemas__[alias]].normalize;
    });

    //
    // Fake record for guessed links
    //
    self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

    //
    // Build schema condition
    //
    var slist = Object.keys(self.__compiled__)
                        .filter(function (name) {
                          // Filter disabled & fake schemas
                          return name.length > 0 && self.__compiled__[name];
                        })
                        .map(escapeRE)
                        .join('|');
    // (?!_) cause 1.5x slowdown
    self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'i');
    self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'ig');

    self.re.pretest = RegExp(
      '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
      'i'
    );

    //
    // Cleanup
    //

    resetScanCache(self);
  }

  /**
   * class Match
   *
   * Match result. Single element of array, returned by [[LinkifyIt#match]]
   **/
  function Match(self, shift) {
    var start = self.__index__,
        end   = self.__last_index__,
        text  = self.__text_cache__.slice(start, end);

    /**
     * Match#schema -> String
     *
     * Prefix (protocol) for matched string.
     **/
    this.schema    = self.__schema__.toLowerCase();
    /**
     * Match#index -> Number
     *
     * First position of matched string.
     **/
    this.index     = start + shift;
    /**
     * Match#lastIndex -> Number
     *
     * Next position after matched string.
     **/
    this.lastIndex = end + shift;
    /**
     * Match#raw -> String
     *
     * Matched string.
     **/
    this.raw       = text;
    /**
     * Match#text -> String
     *
     * Notmalized text of matched string.
     **/
    this.text      = text;
    /**
     * Match#url -> String
     *
     * Normalized url of matched string.
     **/
    this.url       = text;
  }

  function createMatch(self, shift) {
    var match = new Match(self, shift);

    self.__compiled__[match.schema].normalize(match, self);

    return match;
  }


  /**
   * class LinkifyIt
   **/

  /**
   * new LinkifyIt(schemas, options)
   * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
   * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
   *
   * Creates new linkifier instance with optional additional schemas.
   * Can be called without `new` keyword for convenience.
   *
   * By default understands:
   *
   * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
   * - "fuzzy" links and emails (example.com, foo@bar.com).
   *
   * `schemas` is an object, where each key/value describes protocol/rule:
   *
   * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
   *   for example). `linkify-it` makes shure that prefix is not preceeded with
   *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
   * - __value__ - rule to check tail after link prefix
   *   - _String_ - just alias to existing rule
   *   - _Object_
   *     - _validate_ - validator function (should return matched length on success),
   *       or `RegExp`.
   *     - _normalize_ - optional function to normalize text & url of matched result
   *       (for example, for @twitter mentions).
   *
   * `options`:
   *
   * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
   * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
   *   like version numbers. Default `false`.
   * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
   *
   **/
  function LinkifyIt$1(schemas, options) {
    if (!(this instanceof LinkifyIt$1)) {
      return new LinkifyIt$1(schemas, options);
    }

    if (!options) {
      if (isOptionsObj(schemas)) {
        options = schemas;
        schemas = {};
      }
    }

    this.__opts__           = assign({}, defaultOptions, options);

    // Cache last tested result. Used to skip repeating steps on next `match` call.
    this.__index__          = -1;
    this.__last_index__     = -1; // Next scan position
    this.__schema__         = '';
    this.__text_cache__     = '';

    this.__schemas__        = assign({}, defaultSchemas, schemas);
    this.__compiled__       = {};

    this.__tlds__           = tlds_default;
    this.__tlds_replaced__  = false;

    this.re = {};

    compile(this);
  }


  /** chainable
   * LinkifyIt#add(schema, definition)
   * - schema (String): rule name (fixed pattern prefix)
   * - definition (String|RegExp|Object): schema definition
   *
   * Add new rule definition. See constructor description for details.
   **/
  LinkifyIt$1.prototype.add = function add(schema, definition) {
    this.__schemas__[schema] = definition;
    compile(this);
    return this;
  };


  /** chainable
   * LinkifyIt#set(options)
   * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
   *
   * Set recognition options for links without schema.
   **/
  LinkifyIt$1.prototype.set = function set(options) {
    this.__opts__ = assign(this.__opts__, options);
    return this;
  };


  /**
   * LinkifyIt#test(text) -> Boolean
   *
   * Searches linkifiable pattern and returns `true` on success or `false` on fail.
   **/
  LinkifyIt$1.prototype.test = function test(text) {
    // Reset scan cache
    this.__text_cache__ = text;
    this.__index__      = -1;

    if (!text.length) { return false; }

    var m, ml, me, len, shift, next, re, tld_pos, at_pos;

    // try to scan for link with schema - that's the most simple rule
    if (this.re.schema_test.test(text)) {
      re = this.re.schema_search;
      re.lastIndex = 0;
      while ((m = re.exec(text)) !== null) {
        len = this.testSchemaAt(text, m[2], re.lastIndex);
        if (len) {
          this.__schema__     = m[2];
          this.__index__      = m.index + m[1].length;
          this.__last_index__ = m.index + m[0].length + len;
          break;
        }
      }
    }

    if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
      // guess schemaless links
      tld_pos = text.search(this.re.host_fuzzy_test);
      if (tld_pos >= 0) {
        // if tld is located after found link - no need to check fuzzy pattern
        if (this.__index__ < 0 || tld_pos < this.__index__) {
          if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

            shift = ml.index + ml[1].length;

            if (this.__index__ < 0 || shift < this.__index__) {
              this.__schema__     = '';
              this.__index__      = shift;
              this.__last_index__ = ml.index + ml[0].length;
            }
          }
        }
      }
    }

    if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
      // guess schemaless emails
      at_pos = text.indexOf('@');
      if (at_pos >= 0) {
        // We can't skip this check, because this cases are possible:
        // 192.168.1.1@gmail.com, my.in@example.com
        if ((me = text.match(this.re.email_fuzzy)) !== null) {

          shift = me.index + me[1].length;
          next  = me.index + me[0].length;

          if (this.__index__ < 0 || shift < this.__index__ ||
              (shift === this.__index__ && next > this.__last_index__)) {
            this.__schema__     = 'mailto:';
            this.__index__      = shift;
            this.__last_index__ = next;
          }
        }
      }
    }

    return this.__index__ >= 0;
  };


  /**
   * LinkifyIt#pretest(text) -> Boolean
   *
   * Very quick check, that can give false positives. Returns true if link MAY BE
   * can exists. Can be used for speed optimization, when you need to check that
   * link NOT exists.
   **/
  LinkifyIt$1.prototype.pretest = function pretest(text) {
    return this.re.pretest.test(text);
  };


  /**
   * LinkifyIt#testSchemaAt(text, name, position) -> Number
   * - text (String): text to scan
   * - name (String): rule (schema) name
   * - position (Number): text offset to check from
   *
   * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
   * at given position. Returns length of found pattern (0 on fail).
   **/
  LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
    // If not supported schema check requested - terminate
    if (!this.__compiled__[schema.toLowerCase()]) {
      return 0;
    }
    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
  };


  /**
   * LinkifyIt#match(text) -> Array|null
   *
   * Returns array of found link descriptions or `null` on fail. We strongly
   * recommend to use [[LinkifyIt#test]] first, for best speed.
   *
   * ##### Result match description
   *
   * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
   *   protocol-neutral  links.
   * - __index__ - offset of matched text
   * - __lastIndex__ - index of next char after mathch end
   * - __raw__ - matched text
   * - __text__ - normalized text
   * - __url__ - link, generated from matched text
   **/
  LinkifyIt$1.prototype.match = function match(text) {
    var shift = 0, result = [];

    // Try to take previous element from cache, if .test() called before
    if (this.__index__ >= 0 && this.__text_cache__ === text) {
      result.push(createMatch(this, shift));
      shift = this.__last_index__;
    }

    // Cut head if cache was used
    var tail = shift ? text.slice(shift) : text;

    // Scan string until end reached
    while (this.test(tail)) {
      result.push(createMatch(this, shift));

      tail = tail.slice(this.__last_index__);
      shift += this.__last_index__;
    }

    if (result.length) {
      return result;
    }

    return null;
  };


  /** chainable
   * LinkifyIt#tlds(list [, keepOld]) -> this
   * - list (Array): list of tlds
   * - keepOld (Boolean): merge with current list if `true` (`false` by default)
   *
   * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
   * to avoid false positives. By default this algorythm used:
   *
   * - hostname with any 2-letter root zones are ok.
   * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
   *   are ok.
   * - encoded (`xn--...`) root zones are ok.
   *
   * If list is replaced, then exact match for 2-chars root zones will be checked.
   **/
  LinkifyIt$1.prototype.tlds = function tlds(list, keepOld) {
    list = Array.isArray(list) ? list : [ list ];

    if (!keepOld) {
      this.__tlds__ = list.slice();
      this.__tlds_replaced__ = true;
      compile(this);
      return this;
    }

    this.__tlds__ = this.__tlds__.concat(list)
                                    .sort()
                                    .filter(function (el, idx, arr) {
                                      return el !== arr[idx - 1];
                                    })
                                    .reverse();

    compile(this);
    return this;
  };

  /**
   * LinkifyIt#normalize(match)
   *
   * Default normalizer (if schema does not define it's own).
   **/
  LinkifyIt$1.prototype.normalize = function normalize(match) {

    // Do minimal possible changes by default. Need to collect feedback prior
    // to move forward https://github.com/markdown-it/linkify-it/issues/1

    if (!match.schema) { match.url = 'http://' + match.url; }

    if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
      match.url = 'mailto:' + match.url;
    }
  };


  /**
   * LinkifyIt#onCompile()
   *
   * Override to modify basic RegExp-s.
   **/
  LinkifyIt$1.prototype.onCompile = function onCompile() {
  };


  var linkifyIt = LinkifyIt$1;

  /** Highest positive signed 32-bit float value */
  const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128; // 0x80
  const delimiter = '-'; // '\x2D'

  /** Regular expressions */
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */
  const errors = {
  	'overflow': 'Overflow: input needs wider integers to process',
  	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  	'invalid-input': 'Invalid input'
  };

  /** Convenience shortcuts */
  const baseMinusTMin = base - tMin;
  const floor$2 = Math.floor;
  const stringFromCharCode = String.fromCharCode;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error(type) {
  	throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map(array, fn) {
  	const result = [];
  	let length = array.length;
  	while (length--) {
  		result[length] = fn(array[length]);
  	}
  	return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
  	const parts = string.split('@');
  	let result = '';
  	if (parts.length > 1) {
  		// In email addresses, only the domain name should be punycoded. Leave
  		// the local part (i.e. everything up to `@`) intact.
  		result = parts[0] + '@';
  		string = parts[1];
  	}
  	// Avoid `split(regex)` for IE8 compatibility. See #17.
  	string = string.replace(regexSeparators, '\x2E');
  	const labels = string.split('.');
  	const encoded = map(labels, fn).join('.');
  	return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
  	const output = [];
  	let counter = 0;
  	const length = string.length;
  	while (counter < length) {
  		const value = string.charCodeAt(counter++);
  		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
  			// It's a high surrogate, and there is a next character.
  			const extra = string.charCodeAt(counter++);
  			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
  				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
  			} else {
  				// It's an unmatched surrogate; only append this code unit, in case the
  				// next code unit is the high surrogate of a surrogate pair.
  				output.push(value);
  				counter--;
  			}
  		} else {
  			output.push(value);
  		}
  	}
  	return output;
  }

  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */
  const ucs2encode = array => String.fromCodePoint(...array);

  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */
  const basicToDigit = function(codePoint) {
  	if (codePoint - 0x30 < 0x0A) {
  		return codePoint - 0x16;
  	}
  	if (codePoint - 0x41 < 0x1A) {
  		return codePoint - 0x41;
  	}
  	if (codePoint - 0x61 < 0x1A) {
  		return codePoint - 0x61;
  	}
  	return base;
  };

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  const digitToBasic = function(digit, flag) {
  	//  0..25 map to ASCII a..z or A..Z
  	// 26..35 map to ASCII 0..9
  	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  const adapt = function(delta, numPoints, firstTime) {
  	let k = 0;
  	delta = firstTime ? floor$2(delta / damp) : delta >> 1;
  	delta += floor$2(delta / numPoints);
  	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
  		delta = floor$2(delta / baseMinusTMin);
  	}
  	return floor$2(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };

  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */
  const decode$2 = function(input) {
  	// Don't use UCS-2.
  	const output = [];
  	const inputLength = input.length;
  	let i = 0;
  	let n = initialN;
  	let bias = initialBias;

  	// Handle the basic code points: let `basic` be the number of input code
  	// points before the last delimiter, or `0` if there is none, then copy
  	// the first basic code points to the output.

  	let basic = input.lastIndexOf(delimiter);
  	if (basic < 0) {
  		basic = 0;
  	}

  	for (let j = 0; j < basic; ++j) {
  		// if it's not a basic code point
  		if (input.charCodeAt(j) >= 0x80) {
  			error('not-basic');
  		}
  		output.push(input.charCodeAt(j));
  	}

  	// Main decoding loop: start just after the last delimiter if any basic code
  	// points were copied; start at the beginning otherwise.

  	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

  		// `index` is the index of the next character to be consumed.
  		// Decode a generalized variable-length integer into `delta`,
  		// which gets added to `i`. The overflow checking is easier
  		// if we increase `i` as we go, then subtract off its starting
  		// value at the end to obtain `delta`.
  		let oldi = i;
  		for (let w = 1, k = base; /* no condition */; k += base) {

  			if (index >= inputLength) {
  				error('invalid-input');
  			}

  			const digit = basicToDigit(input.charCodeAt(index++));

  			if (digit >= base || digit > floor$2((maxInt - i) / w)) {
  				error('overflow');
  			}

  			i += digit * w;
  			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

  			if (digit < t) {
  				break;
  			}

  			const baseMinusT = base - t;
  			if (w > floor$2(maxInt / baseMinusT)) {
  				error('overflow');
  			}

  			w *= baseMinusT;

  		}

  		const out = output.length + 1;
  		bias = adapt(i - oldi, out, oldi == 0);

  		// `i` was supposed to wrap around from `out` to `0`,
  		// incrementing `n` each time, so we'll fix that now:
  		if (floor$2(i / out) > maxInt - n) {
  			error('overflow');
  		}

  		n += floor$2(i / out);
  		i %= out;

  		// Insert `n` at position `i` of the output.
  		output.splice(i++, 0, n);

  	}

  	return String.fromCodePoint(...output);
  };

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  const encode = function(input) {
  	const output = [];

  	// Convert the input in UCS-2 to an array of Unicode code points.
  	input = ucs2decode(input);

  	// Cache the length.
  	let inputLength = input.length;

  	// Initialize the state.
  	let n = initialN;
  	let delta = 0;
  	let bias = initialBias;

  	// Handle the basic code points.
  	for (const currentValue of input) {
  		if (currentValue < 0x80) {
  			output.push(stringFromCharCode(currentValue));
  		}
  	}

  	let basicLength = output.length;
  	let handledCPCount = basicLength;

  	// `handledCPCount` is the number of code points that have been handled;
  	// `basicLength` is the number of basic code points.

  	// Finish the basic string with a delimiter unless it's empty.
  	if (basicLength) {
  		output.push(delimiter);
  	}

  	// Main encoding loop:
  	while (handledCPCount < inputLength) {

  		// All non-basic code points < n have been handled already. Find the next
  		// larger one:
  		let m = maxInt;
  		for (const currentValue of input) {
  			if (currentValue >= n && currentValue < m) {
  				m = currentValue;
  			}
  		}

  		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
  		// but guard against overflow.
  		const handledCPCountPlusOne = handledCPCount + 1;
  		if (m - n > floor$2((maxInt - delta) / handledCPCountPlusOne)) {
  			error('overflow');
  		}

  		delta += (m - n) * handledCPCountPlusOne;
  		n = m;

  		for (const currentValue of input) {
  			if (currentValue < n && ++delta > maxInt) {
  				error('overflow');
  			}
  			if (currentValue == n) {
  				// Represent delta as a generalized variable-length integer.
  				let q = delta;
  				for (let k = base; /* no condition */; k += base) {
  					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
  					if (q < t) {
  						break;
  					}
  					const qMinusT = q - t;
  					const baseMinusT = base - t;
  					output.push(
  						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
  					);
  					q = floor$2(qMinusT / baseMinusT);
  				}

  				output.push(stringFromCharCode(digitToBasic(q, 0)));
  				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
  				delta = 0;
  				++handledCPCount;
  			}
  		}

  		++delta;
  		++n;

  	}
  	return output.join('');
  };

  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */
  const toUnicode = function(input) {
  	return mapDomain(input, function(string) {
  		return regexPunycode.test(string)
  			? decode$2(string.slice(4).toLowerCase())
  			: string;
  	});
  };

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  const toASCII = function(input) {
  	return mapDomain(input, function(string) {
  		return regexNonASCII.test(string)
  			? 'xn--' + encode(string)
  			: string;
  	});
  };

  /*--------------------------------------------------------------------------*/

  /** Define the public API */
  const punycode$1 = {
  	/**
  	 * A string representing the current Punycode.js version number.
  	 * @memberOf punycode
  	 * @type String
  	 */
  	'version': '2.1.0',
  	/**
  	 * An object of methods to convert from JavaScript's internal character
  	 * representation (UCS-2) to Unicode code points, and back.
  	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
  	 * @memberOf punycode
  	 * @type Object
  	 */
  	'ucs2': {
  		'decode': ucs2decode,
  		'encode': ucs2encode
  	},
  	'decode': decode$2,
  	'encode': encode,
  	'toASCII': toASCII,
  	'toUnicode': toUnicode
  };

  var punycode_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ucs2decode: ucs2decode,
    ucs2encode: ucs2encode,
    decode: decode$2,
    encode: encode,
    toASCII: toASCII,
    toUnicode: toUnicode,
    'default': punycode$1
  });

  var require$$8 = /*@__PURE__*/getAugmentedNamespace(punycode_es6);

  var _default = {
    options: {
      html:         false,        // Enable HTML tags in source
      xhtmlOut:     false,        // Use '/' to close single tags (<br />)
      breaks:       false,        // Convert '\n' in paragraphs into <br>
      langPrefix:   'language-',  // CSS language prefix for fenced blocks
      linkify:      false,        // autoconvert URL-like texts to links

      // Enable some language-neutral replacements + quotes beautification
      typographer:  false,

      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,

      maxNesting:   100            // Internal protection, recursion limit
    },

    components: {

      core: {},
      block: {},
      inline: {}
    }
  };

  var zero = {
    options: {
      html:         false,        // Enable HTML tags in source
      xhtmlOut:     false,        // Use '/' to close single tags (<br />)
      breaks:       false,        // Convert '\n' in paragraphs into <br>
      langPrefix:   'language-',  // CSS language prefix for fenced blocks
      linkify:      false,        // autoconvert URL-like texts to links

      // Enable some language-neutral replacements + quotes beautification
      typographer:  false,

      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,

      maxNesting:   20            // Internal protection, recursion limit
    },

    components: {

      core: {
        rules: [
          'normalize',
          'block',
          'inline'
        ]
      },

      block: {
        rules: [
          'paragraph'
        ]
      },

      inline: {
        rules: [
          'text'
        ],
        rules2: [
          'balance_pairs',
          'text_collapse'
        ]
      }
    }
  };

  var commonmark = {
    options: {
      html:         true,         // Enable HTML tags in source
      xhtmlOut:     true,         // Use '/' to close single tags (<br />)
      breaks:       false,        // Convert '\n' in paragraphs into <br>
      langPrefix:   'language-',  // CSS language prefix for fenced blocks
      linkify:      false,        // autoconvert URL-like texts to links

      // Enable some language-neutral replacements + quotes beautification
      typographer:  false,

      // Double + single quotes replacement pairs, when typographer enabled,
      // and smartquotes on. Could be either a String or an Array.
      //
      // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
      // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
      quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

      // Highlighter function. Should return escaped HTML,
      // or '' if the source string is not changed and should be escaped externaly.
      // If result starts with <pre... internal wrapper is skipped.
      //
      // function (/*str, lang*/) { return ''; }
      //
      highlight: null,

      maxNesting:   20            // Internal protection, recursion limit
    },

    components: {

      core: {
        rules: [
          'normalize',
          'block',
          'inline'
        ]
      },

      block: {
        rules: [
          'blockquote',
          'code',
          'fence',
          'heading',
          'hr',
          'html_block',
          'lheading',
          'list',
          'reference',
          'paragraph'
        ]
      },

      inline: {
        rules: [
          'autolink',
          'backticks',
          'emphasis',
          'entity',
          'escape',
          'html_inline',
          'image',
          'link',
          'newline',
          'text'
        ],
        rules2: [
          'balance_pairs',
          'emphasis',
          'text_collapse'
        ]
      }
    }
  };

  var utils        = utils$1;
  var helpers      = helpers$1;
  var Renderer$1     = renderer;
  var ParserCore   = parser_core;
  var ParserBlock  = parser_block;
  var ParserInline = parser_inline;
  var LinkifyIt    = linkifyIt;
  var mdurl        = mdurl$1;
  var punycode     = require$$8;


  var config = {
    default: _default,
    zero: zero,
    commonmark: commonmark
  };

  ////////////////////////////////////////////////////////////////////////////////
  //
  // This validator can prohibit more than really needed to prevent XSS. It's a
  // tradeoff to keep code simple and to be secure by default.
  //
  // If you need different setup - override validator method as you wish. Or
  // replace it with dummy function and use external sanitizer.
  //

  var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
  var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

  function validateLink(url) {
    // url should be normalized at this point, and existing entities are decoded
    var str = url.trim().toLowerCase();

    return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
  }

  ////////////////////////////////////////////////////////////////////////////////


  var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

  function normalizeLink(url) {
    var parsed = mdurl.parse(url, true);

    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      //
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      //
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toASCII(parsed.hostname);
        } catch (er) { /**/ }
      }
    }

    return mdurl.encode(mdurl.format(parsed));
  }

  function normalizeLinkText(url) {
    var parsed = mdurl.parse(url, true);

    if (parsed.hostname) {
      // Encode hostnames in urls like:
      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
      //
      // We don't encode unknown schemas, because it's likely that we encode
      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
      //
      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
        try {
          parsed.hostname = punycode.toUnicode(parsed.hostname);
        } catch (er) { /**/ }
      }
    }

    // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
    return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
  }


  /**
   * class MarkdownIt
   *
   * Main parser/renderer class.
   *
   * ##### Usage
   *
   * ```javascript
   * // node.js, "classic" way:
   * var MarkdownIt = require('markdown-it'),
   *     md = new MarkdownIt();
   * var result = md.render('# markdown-it rulezz!');
   *
   * // node.js, the same, but with sugar:
   * var md = require('markdown-it')();
   * var result = md.render('# markdown-it rulezz!');
   *
   * // browser without AMD, added to "window" on script load
   * // Note, there are no dash.
   * var md = window.markdownit();
   * var result = md.render('# markdown-it rulezz!');
   * ```
   *
   * Single line rendering, without paragraph wrap:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * var result = md.renderInline('__markdown-it__ rulezz!');
   * ```
   **/

  /**
   * new MarkdownIt([presetName, options])
   * - presetName (String): optional, `commonmark` / `zero`
   * - options (Object)
   *
   * Creates parser instanse with given config. Can be called without `new`.
   *
   * ##### presetName
   *
   * MarkdownIt provides named presets as a convenience to quickly
   * enable/disable active syntax rules and options for common use cases.
   *
   * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
   *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
   * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
   *   similar to GFM, used when no preset name given. Enables all available rules,
   *   but still without html, typographer & autolinker.
   * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
   *   all rules disabled. Useful to quickly setup your config via `.enable()`.
   *   For example, when you need only `bold` and `italic` markup and nothing else.
   *
   * ##### options:
   *
   * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
   *   That's not safe! You may need external sanitizer to protect output from XSS.
   *   It's better to extend features via plugins, instead of enabling HTML.
   * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
   *   (`<br />`). This is needed only for full CommonMark compatibility. In real
   *   world you will need HTML output.
   * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
   * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
   *   Can be useful for external highlighters.
   * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
   * - __typographer__  - `false`. Set `true` to enable [some language-neutral
   *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
   *   quotes beautification (smartquotes).
   * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
   *   pairs, when typographer enabled and smartquotes on. For example, you can
   *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
   *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
   * - __highlight__ - `null`. Highlighter function for fenced code blocks.
   *   Highlighter `function (str, lang)` should return escaped HTML. It can also
   *   return empty string if the source was not changed and should be escaped
   *   externaly. If result starts with <pre... internal wrapper is skipped.
   *
   * ##### Example
   *
   * ```javascript
   * // commonmark mode
   * var md = require('markdown-it')('commonmark');
   *
   * // default mode
   * var md = require('markdown-it')();
   *
   * // enable everything
   * var md = require('markdown-it')({
   *   html: true,
   *   linkify: true,
   *   typographer: true
   * });
   * ```
   *
   * ##### Syntax highlighting
   *
   * ```js
   * var hljs = require('highlight.js') // https://highlightjs.org/
   *
   * var md = require('markdown-it')({
   *   highlight: function (str, lang) {
   *     if (lang && hljs.getLanguage(lang)) {
   *       try {
   *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
   *       } catch (__) {}
   *     }
   *
   *     return ''; // use external default escaping
   *   }
   * });
   * ```
   *
   * Or with full wrapper override (if you need assign class to `<pre>`):
   *
   * ```javascript
   * var hljs = require('highlight.js') // https://highlightjs.org/
   *
   * // Actual default values
   * var md = require('markdown-it')({
   *   highlight: function (str, lang) {
   *     if (lang && hljs.getLanguage(lang)) {
   *       try {
   *         return '<pre class="hljs"><code>' +
   *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
   *                '</code></pre>';
   *       } catch (__) {}
   *     }
   *
   *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
   *   }
   * });
   * ```
   *
   **/
  function MarkdownIt(presetName, options) {
    if (!(this instanceof MarkdownIt)) {
      return new MarkdownIt(presetName, options);
    }

    if (!options) {
      if (!utils.isString(presetName)) {
        options = presetName || {};
        presetName = 'default';
      }
    }

    /**
     * MarkdownIt#inline -> ParserInline
     *
     * Instance of [[ParserInline]]. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/
    this.inline = new ParserInline();

    /**
     * MarkdownIt#block -> ParserBlock
     *
     * Instance of [[ParserBlock]]. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/
    this.block = new ParserBlock();

    /**
     * MarkdownIt#core -> Core
     *
     * Instance of [[Core]] chain executor. You may need it to add new rules when
     * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
     * [[MarkdownIt.enable]].
     **/
    this.core = new ParserCore();

    /**
     * MarkdownIt#renderer -> Renderer
     *
     * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
     * rules for new token types, generated by plugins.
     *
     * ##### Example
     *
     * ```javascript
     * var md = require('markdown-it')();
     *
     * function myToken(tokens, idx, options, env, self) {
     *   //...
     *   return result;
     * };
     *
     * md.renderer.rules['my_token'] = myToken
     * ```
     *
     * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
     **/
    this.renderer = new Renderer$1();

    /**
     * MarkdownIt#linkify -> LinkifyIt
     *
     * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
     * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
     * rule.
     **/
    this.linkify = new LinkifyIt();

    /**
     * MarkdownIt#validateLink(url) -> Boolean
     *
     * Link validation function. CommonMark allows too much in links. By default
     * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
     * except some embedded image types.
     *
     * You can change this behaviour:
     *
     * ```javascript
     * var md = require('markdown-it')();
     * // enable everything
     * md.validateLink = function () { return true; }
     * ```
     **/
    this.validateLink = validateLink;

    /**
     * MarkdownIt#normalizeLink(url) -> String
     *
     * Function used to encode link url to a machine-readable format,
     * which includes url-encoding, punycode, etc.
     **/
    this.normalizeLink = normalizeLink;

    /**
     * MarkdownIt#normalizeLinkText(url) -> String
     *
     * Function used to decode link url to a human-readable format`
     **/
    this.normalizeLinkText = normalizeLinkText;


    // Expose utils & helpers for easy acces from plugins

    /**
     * MarkdownIt#utils -> utils
     *
     * Assorted utility functions, useful to write plugins. See details
     * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
     **/
    this.utils = utils;

    /**
     * MarkdownIt#helpers -> helpers
     *
     * Link components parser functions, useful to write plugins. See details
     * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
     **/
    this.helpers = utils.assign({}, helpers);


    this.options = {};
    this.configure(presetName);

    if (options) { this.set(options); }
  }


  /** chainable
   * MarkdownIt.set(options)
   *
   * Set parser options (in the same format as in constructor). Probably, you
   * will never need it, but you can change options after constructor call.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')()
   *             .set({ html: true, breaks: true })
   *             .set({ typographer, true });
   * ```
   *
   * __Note:__ To achieve the best possible performance, don't modify a
   * `markdown-it` instance options on the fly. If you need multiple configurations
   * it's best to create multiple instances and initialize each with separate
   * config.
   **/
  MarkdownIt.prototype.set = function (options) {
    utils.assign(this.options, options);
    return this;
  };


  /** chainable, internal
   * MarkdownIt.configure(presets)
   *
   * Batch load of all options and compenent settings. This is internal method,
   * and you probably will not need it. But if you will - see available presets
   * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
   *
   * We strongly recommend to use presets instead of direct config loads. That
   * will give better compatibility with next versions.
   **/
  MarkdownIt.prototype.configure = function (presets) {
    var self = this, presetName;

    if (utils.isString(presets)) {
      presetName = presets;
      presets = config[presetName];
      if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
    }

    if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

    if (presets.options) { self.set(presets.options); }

    if (presets.components) {
      Object.keys(presets.components).forEach(function (name) {
        if (presets.components[name].rules) {
          self[name].ruler.enableOnly(presets.components[name].rules);
        }
        if (presets.components[name].rules2) {
          self[name].ruler2.enableOnly(presets.components[name].rules2);
        }
      });
    }
    return this;
  };


  /** chainable
   * MarkdownIt.enable(list, ignoreInvalid)
   * - list (String|Array): rule name or list of rule names to enable
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * Enable list or rules. It will automatically find appropriate components,
   * containing rules with given names. If rule not found, and `ignoreInvalid`
   * not set - throws exception.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')()
   *             .enable(['sub', 'sup'])
   *             .disable('smartquotes');
   * ```
   **/
  MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
    var result = [];

    if (!Array.isArray(list)) { list = [ list ]; }

    [ 'core', 'block', 'inline' ].forEach(function (chain) {
      result = result.concat(this[chain].ruler.enable(list, true));
    }, this);

    result = result.concat(this.inline.ruler2.enable(list, true));

    var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

    if (missed.length && !ignoreInvalid) {
      throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
    }

    return this;
  };


  /** chainable
   * MarkdownIt.disable(list, ignoreInvalid)
   * - list (String|Array): rule name or list of rule names to disable.
   * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
   *
   * The same as [[MarkdownIt.enable]], but turn specified rules off.
   **/
  MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
    var result = [];

    if (!Array.isArray(list)) { list = [ list ]; }

    [ 'core', 'block', 'inline' ].forEach(function (chain) {
      result = result.concat(this[chain].ruler.disable(list, true));
    }, this);

    result = result.concat(this.inline.ruler2.disable(list, true));

    var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

    if (missed.length && !ignoreInvalid) {
      throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
    }
    return this;
  };


  /** chainable
   * MarkdownIt.use(plugin, params)
   *
   * Load specified plugin with given params into current parser instance.
   * It's just a sugar to call `plugin(md, params)` with curring.
   *
   * ##### Example
   *
   * ```javascript
   * var iterator = require('markdown-it-for-inline');
   * var md = require('markdown-it')()
   *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
   *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
   *             });
   * ```
   **/
  MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
    var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
    plugin.apply(plugin, args);
    return this;
  };


  /** internal
   * MarkdownIt.parse(src, env) -> Array
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Parse input string and return list of block tokens (special token type
   * "inline" will contain list of inline tokens). You should not call this
   * method directly, until you write custom renderer (for example, to produce
   * AST).
   *
   * `env` is used to pass data between "distributed" rules and return additional
   * metadata like reference info, needed for the renderer. It also can be used to
   * inject data in specific cases. Usually, you will be ok to pass `{}`,
   * and then pass updated object to renderer.
   **/
  MarkdownIt.prototype.parse = function (src, env) {
    if (typeof src !== 'string') {
      throw new Error('Input data should be a String');
    }

    var state = new this.core.State(src, this, env);

    this.core.process(state);

    return state.tokens;
  };


  /**
   * MarkdownIt.render(src [, env]) -> String
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Render markdown string into html. It does all magic for you :).
   *
   * `env` can be used to inject additional metadata (`{}` by default).
   * But you will not need it with high probability. See also comment
   * in [[MarkdownIt.parse]].
   **/
  MarkdownIt.prototype.render = function (src, env) {
    env = env || {};

    return this.renderer.render(this.parse(src, env), this.options, env);
  };


  /** internal
   * MarkdownIt.parseInline(src, env) -> Array
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
   * block tokens list with the single `inline` element, containing parsed inline
   * tokens in `children` property. Also updates `env` object.
   **/
  MarkdownIt.prototype.parseInline = function (src, env) {
    var state = new this.core.State(src, this, env);

    state.inlineMode = true;
    this.core.process(state);

    return state.tokens;
  };


  /**
   * MarkdownIt.renderInline(src [, env]) -> String
   * - src (String): source string
   * - env (Object): environment sandbox
   *
   * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
   * will NOT be wrapped into `<p>` tags.
   **/
  MarkdownIt.prototype.renderInline = function (src, env) {
    env = env || {};

    return this.renderer.render(this.parseInline(src, env), this.options, env);
  };


  var lib = MarkdownIt;

  var markdownIt = lib;

  /* eslint-disable no-unused-vars */
  var htmlTagRegex$1 = /<html(.|\s)*>(.|\s)*<\/html>/im;
  var md$1 = new markdownIt({
      html: true,
      linkify: true
  });
  md$1.use(markdownItSanitizer, {
      imageClass: "",
      removeUnbalanced: false,
      removeUnknown: false
  });
  var KnockoutMarkdownBinding$1 = {
      register: function (Knockout) {
          Knockout.bindingHandlers.markdown = {
              init: function () {
                  // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
                  return { controlsDescendantBindings: true };
              },
              update: function (element, valueAccessor) {
                  // Remove existing children of this element.
                  while (element.firstChild) {
                      Knockout.removeNode(element.firstChild);
                  }
                  var rawText = Knockout.unwrap(valueAccessor());
                  // If the text contains an <html> tag, don't try to interpret it as Markdown because
                  // we'll probably break it in the process.
                  var html;
                  if (htmlTagRegex$1.test(rawText)) {
                      html = rawText;
                  }
                  else {
                      html = md$1.render(rawText);
                  }
                  var nodes = Knockout.utils.parseHtmlFragment(html, element);
                  element.className = element.className + " markdown";
                  for (var i = 0; i < nodes.length; ++i) {
                      var node = nodes[i];
                      setAnchorTargets$1(node);
                      element.appendChild(node);
                  }
              }
          };
      }
  };
  function setAnchorTargets$1(element) {
      if (element instanceof HTMLAnchorElement) {
          element.target = "_blank";
      }
      if (element.childNodes && element.childNodes.length > 0) {
          for (var i = 0; i < element.childNodes.length; ++i) {
              setAnchorTargets$1(element.childNodes[i]);
          }
      }
  }

  var hammer = {exports: {}};

  /*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */

  (function (module) {
  (function(window, document, exportName, undefined$1) {

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');

  var TYPE_FUNCTION = 'function';

  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;

  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */
  function setTimeoutContext(fn, timeout, context) {
      return setTimeout(bindFn(fn, context), timeout);
  }

  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */
  function invokeArrayArg(arg, fn, context) {
      if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
      }
      return false;
  }

  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */
  function each(obj, iterator, context) {
      var i;

      if (!obj) {
          return;
      }

      if (obj.forEach) {
          obj.forEach(iterator, context);
      } else if (obj.length !== undefined$1) {
          i = 0;
          while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
          }
      } else {
          for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
      }
  }

  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */
  function deprecate(method, name, message) {
      var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
      return function() {
          var e = new Error('get-stack-trace');
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
              .replace(/^\s+at\s+/gm, '')
              .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

          var log = window.console && (window.console.warn || window.console.log);
          if (log) {
              log.call(window.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
      };
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */
  var assign;
  if (typeof Object.assign !== 'function') {
      assign = function assign(target) {
          if (target === undefined$1 || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }

          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined$1 && source !== null) {
                  for (var nextKey in source) {
                      if (source.hasOwnProperty(nextKey)) {
                          output[nextKey] = source[nextKey];
                      }
                  }
              }
          }
          return output;
      };
  } else {
      assign = Object.assign;
  }

  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */
  var extend = deprecate(function extend(dest, src, merge) {
      var keys = Object.keys(src);
      var i = 0;
      while (i < keys.length) {
          if (!merge || (merge && dest[keys[i]] === undefined$1)) {
              dest[keys[i]] = src[keys[i]];
          }
          i++;
      }
      return dest;
  }, 'extend', 'Use `assign`.');

  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */
  var merge = deprecate(function merge(dest, src) {
      return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');

  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */
  function inherit(child, base, properties) {
      var baseP = base.prototype,
          childP;

      childP = child.prototype = Object.create(baseP);
      childP.constructor = child;
      childP._super = baseP;

      if (properties) {
          assign(childP, properties);
      }
  }

  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */
  function bindFn(fn, context) {
      return function boundFn() {
          return fn.apply(context, arguments);
      };
  }

  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */
  function boolOrFn(val, args) {
      if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
      }
      return val;
  }

  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */
  function ifUndefined(val1, val2) {
      return (val1 === undefined$1) ? val2 : val1;
  }

  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function addEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
      });
  }

  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */
  function removeEventListeners(target, types, handler) {
      each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
      });
  }

  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  function hasParent(node, parent) {
      while (node) {
          if (node == parent) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }

  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */
  function inStr(str, find) {
      return str.indexOf(find) > -1;
  }

  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */
  function splitStr(str) {
      return str.trim().split(/\s+/g);
  }

  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */
  function inArray(src, find, findByKey) {
      if (src.indexOf && !findByKey) {
          return src.indexOf(find);
      } else {
          var i = 0;
          while (i < src.length) {
              if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                  return i;
              }
              i++;
          }
          return -1;
      }
  }

  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */
  function toArray(obj) {
      return Array.prototype.slice.call(obj, 0);
  }

  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */
  function uniqueArray(src, key, sort) {
      var results = [];
      var values = [];
      var i = 0;

      while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
              results.push(src[i]);
          }
          values[i] = val;
          i++;
      }

      if (sort) {
          if (!key) {
              results = results.sort();
          } else {
              results = results.sort(function sortUniqueArray(a, b) {
                  return a[key] > b[key];
              });
          }
      }

      return results;
  }

  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */
  function prefixed(obj, property) {
      var prefix, prop;
      var camelProp = property[0].toUpperCase() + property.slice(1);

      var i = 0;
      while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = (prefix) ? prefix + camelProp : property;

          if (prop in obj) {
              return prop;
          }
          i++;
      }
      return undefined$1;
  }

  /**
   * get a unique id
   * @returns {number} uniqueId
   */
  var _uniqueId = 1;
  function uniqueId() {
      return _uniqueId++;
  }

  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */
  function getWindowForElement(element) {
      var doc = element.ownerDocument || element;
      return (doc.defaultView || doc.parentWindow || window);
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';

  var COMPUTE_INTERVAL = 25;

  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;

  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;

  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];

  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */
  function Input(manager, callback) {
      var self = this;
      this.manager = manager;
      this.callback = callback;
      this.element = manager.element;
      this.target = manager.options.inputTarget;

      // smaller wrapper around the handler, for the scope and the enabled state of the manager,
      // so when disabled the input events are completely bypassed.
      this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
          }
      };

      this.init();

  }

  Input.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() { },

      /**
       * bind the events
       */
      init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      },

      /**
       * unbind the events
       */
      destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
      }
  };

  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */
  function createInputInstance(manager) {
      var Type;
      var inputClass = manager.options.inputClass;

      if (inputClass) {
          Type = inputClass;
      } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
      } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
      } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
      } else {
          Type = TouchMouseInput;
      }
      return new (Type)(manager, inputHandler);
  }

  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */
  function inputHandler(manager, eventType, input) {
      var pointersLen = input.pointers.length;
      var changedPointersLen = input.changedPointers.length;
      var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
      var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

      input.isFirst = !!isFirst;
      input.isFinal = !!isFinal;

      if (isFirst) {
          manager.session = {};
      }

      // source event is the normalized value of the domEvents
      // like 'touchstart, mouseup, pointerdown'
      input.eventType = eventType;

      // compute scale, rotation etc
      computeInputData(manager, input);

      // emit secret event
      manager.emit('hammer.input', input);

      manager.recognize(input);
      manager.session.prevInput = input;
  }

  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */
  function computeInputData(manager, input) {
      var session = manager.session;
      var pointers = input.pointers;
      var pointersLength = pointers.length;

      // store the first input to calculate the distance and direction
      if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
      }

      // to compute scale and rotation we need to store the multiple touches
      if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
      } else if (pointersLength === 1) {
          session.firstMultiple = false;
      }

      var firstInput = session.firstInput;
      var firstMultiple = session.firstMultiple;
      var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

      var center = input.center = getCenter(pointers);
      input.timeStamp = now();
      input.deltaTime = input.timeStamp - firstInput.timeStamp;

      input.angle = getAngle(offsetCenter, center);
      input.distance = getDistance(offsetCenter, center);

      computeDeltaXY(session, input);
      input.offsetDirection = getDirection(input.deltaX, input.deltaY);

      var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
      input.overallVelocityX = overallVelocity.x;
      input.overallVelocityY = overallVelocity.y;
      input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

      input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
      input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

      input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
          session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

      computeIntervalInputData(session, input);

      // find the correct target
      var target = manager.element;
      if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
      }
      input.target = target;
  }

  function computeDeltaXY(session, input) {
      var center = input.center;
      var offset = session.offsetDelta || {};
      var prevDelta = session.prevDelta || {};
      var prevInput = session.prevInput || {};

      if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
          };

          offset = session.offsetDelta = {
              x: center.x,
              y: center.y
          };
      }

      input.deltaX = prevDelta.x + (center.x - offset.x);
      input.deltaY = prevDelta.y + (center.y - offset.y);
  }

  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */
  function computeIntervalInputData(session, input) {
      var last = session.lastInterval || input,
          deltaTime = input.timeStamp - last.timeStamp,
          velocity, velocityX, velocityY, direction;

      if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;

          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);

          session.lastInterval = input;
      } else {
          // use latest velocity info if it doesn't overtake a minimum period
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
      }

      input.velocity = velocity;
      input.velocityX = velocityX;
      input.velocityY = velocityY;
      input.direction = direction;
  }

  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */
  function simpleCloneInputData(input) {
      // make a simple copy of the pointers because we will get a reference if we don't
      // we only need clientXY for the calculations
      var pointers = [];
      var i = 0;
      while (i < input.pointers.length) {
          pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
          };
          i++;
      }

      return {
          timeStamp: now(),
          pointers: pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
      };
  }

  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */
  function getCenter(pointers) {
      var pointersLength = pointers.length;

      // no need to loop when only one touch
      if (pointersLength === 1) {
          return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
          };
      }

      var x = 0, y = 0, i = 0;
      while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
      }

      return {
          x: round(x / pointersLength),
          y: round(y / pointersLength)
      };
  }

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */
  function getVelocity(deltaTime, x, y) {
      return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
      };
  }

  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */
  function getDirection(x, y) {
      if (x === y) {
          return DIRECTION_NONE;
      }

      if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }

  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */
  function getDistance(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];

      return Math.sqrt((x * x) + (y * y));
  }

  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */
  function getAngle(p1, p2, props) {
      if (!props) {
          props = PROPS_XY;
      }
      var x = p2[props[0]] - p1[props[0]],
          y = p2[props[1]] - p1[props[1]];
      return Math.atan2(y, x) * 180 / Math.PI;
  }

  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */
  function getRotation(start, end) {
      return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }

  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */
  function getScale(start, end) {
      return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
  };

  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */
  function MouseInput() {
      this.evEl = MOUSE_ELEMENT_EVENTS;
      this.evWin = MOUSE_WINDOW_EVENTS;

      this.pressed = false; // mousedown state

      Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];

          // on start we want to have the left mouse button down
          if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
          }

          if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
          }

          // mouse must be down
          if (!this.pressed) {
              return;
          }

          if (eventType & INPUT_END) {
              this.pressed = false;
          }

          this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
          });
      }
  });

  var POINTER_INPUT_MAP = {
      pointerdown: INPUT_START,
      pointermove: INPUT_MOVE,
      pointerup: INPUT_END,
      pointercancel: INPUT_CANCEL,
      pointerout: INPUT_CANCEL
  };

  // in IE10 the pointer types is defined as an enum
  var IE10_POINTER_TYPE_ENUM = {
      2: INPUT_TYPE_TOUCH,
      3: INPUT_TYPE_PEN,
      4: INPUT_TYPE_MOUSE,
      5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
  };

  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

  // IE10 has prefixed support, and case-sensitive
  if (window.MSPointerEvent && !window.PointerEvent) {
      POINTER_ELEMENT_EVENTS = 'MSPointerDown';
      POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }

  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */
  function PointerEventInput() {
      this.evEl = POINTER_ELEMENT_EVENTS;
      this.evWin = POINTER_WINDOW_EVENTS;

      Input.apply(this, arguments);

      this.store = (this.manager.session.pointerEvents = []);
  }

  inherit(PointerEventInput, Input, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;

          var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

          var isTouch = (pointerType == INPUT_TYPE_TOUCH);

          // get index of the event in the store
          var storeIndex = inArray(store, ev.pointerId, 'pointerId');

          // start and mouse must be down
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                  store.push(ev);
                  storeIndex = store.length - 1;
              }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
          }

          // it not found, so the pointer hasn't been down (so it's probably a hover)
          if (storeIndex < 0) {
              return;
          }

          // update the event in the store
          store[storeIndex] = ev;

          this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
          });

          if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
          }
      }
  });

  var SINGLE_TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Touch events input
   * @constructor
   * @extends Input
   */
  function SingleTouchInput() {
      this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
      this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
      this.started = false;

      Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
      handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

          // should we handle the touch events?
          if (type === INPUT_START) {
              this.started = true;
          }

          if (!this.started) {
              return;
          }

          var touches = normalizeSingleTouches.call(this, ev, type);

          // when done, reset the started state
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function normalizeSingleTouches(ev, type) {
      var all = toArray(ev.touches);
      var changed = toArray(ev.changedTouches);

      if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), 'identifier', true);
      }

      return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
      touchstart: INPUT_START,
      touchmove: INPUT_MOVE,
      touchend: INPUT_END,
      touchcancel: INPUT_CANCEL
  };

  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */
  function TouchInput() {
      this.evTarget = TOUCH_TARGET_EVENTS;
      this.targetIds = {};

      Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
      handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
              return;
          }

          this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
          });
      }
  });

  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */
  function getTouches(ev, type) {
      var allTouches = toArray(ev.touches);
      var targetIds = this.targetIds;

      // when there is only one touch, the process can be simplified
      if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
      }

      var i,
          targetTouches,
          changedTouches = toArray(ev.changedTouches),
          changedTargetTouches = [],
          target = this.target;

      // get target touches from touches
      targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
      });

      // collect touches
      if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
          }
      }

      // filter changed touches to only contain touches that exist in the collected target ids
      i = 0;
      while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
          }

          // cleanup removed touches
          if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
          }
          i++;
      }

      if (!changedTargetTouches.length) {
          return;
      }

      return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
          changedTargetTouches
      ];
  }

  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */

  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
      Input.apply(this, arguments);

      var handler = bindFn(this.handler, this);
      this.touch = new TouchInput(this.manager, handler);
      this.mouse = new MouseInput(this.manager, handler);

      this.primaryTouch = null;
      this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
              isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
          }

          // when we're in a touch event, record touches to  de-dupe synthetic mouse event
          if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
          }

          this.callback(manager, inputEvent, inputData);
      },

      /**
       * remove the event listeners
       */
      destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
      }
  });

  function recordTouches(eventType, eventData) {
      if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
      }
  }

  function setLastTouch(eventData) {
      var touch = eventData.changedPointers[0];

      if (touch.identifier === this.primaryTouch) {
          var lastTouch = {x: touch.clientX, y: touch.clientY};
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                  lts.splice(i, 1);
              }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
      }
  }

  function isSyntheticEvent(eventData) {
      var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
      for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
          }
      }
      return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

  // magical touchAction value
  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();

  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */
  function TouchAction(manager, value) {
      this.manager = manager;
      this.set(value);
  }

  TouchAction.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(value) {
          // find out the touch-action by the event handlers
          if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
          }

          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
      },

      /**
       * just re-set the touchAction value
       */
      update: function() {
          this.set(this.manager.options.touchAction);
      },

      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                  actions = actions.concat(recognizer.getTouchAction());
              }
          });
          return cleanTouchActions(actions.join(' '));
      },

      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;

          // if the touch action did prevented once this session
          if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
          }

          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

          if (hasNone) {
              //do not prevent defaults if this is a tap gesture

              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                  return;
              }
          }

          if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
          }

          if (hasNone ||
              (hasPanY && direction & DIRECTION_HORIZONTAL) ||
              (hasPanX && direction & DIRECTION_VERTICAL)) {
              return this.preventSrc(srcEvent);
          }
      },

      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
      }
  };

  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */
  function cleanTouchActions(actions) {
      // none
      if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
      }

      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

      // if both pan-x and pan-y are set (different recognizers
      // for different directions, e.g. horizontal pan but vertical swipe?)
      // we need none (as otherwise with pan-x pan-y combined none of these
      // recognizers will work, since the browser would handle all panning
      if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
      }

      // pan-x OR pan-y
      if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
      }

      // manipulation
      if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
      }

      return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
      if (!NATIVE_TOUCH_ACTION) {
          return false;
      }
      var touchMap = {};
      var cssSupports = window.CSS && window.CSS.supports;
      ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

          // If css.supports is not supported but there is native touch-action assume it supports
          // all values. This is the case for IE 10 and 11.
          touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
      });
      return touchMap;
  }

  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */
  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;

  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */
  function Recognizer(options) {
      this.options = assign({}, this.defaults, options || {});

      this.id = uniqueId();

      this.manager = null;

      // default is enable true
      this.options.enable = ifUndefined(this.options.enable, true);

      this.state = STATE_POSSIBLE;

      this.simultaneous = {};
      this.requireFail = [];
  }

  Recognizer.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},

      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(options) {
          assign(this.options, options);

          // also update the touchAction, in case something changed about the directions/enabled state
          this.manager && this.manager.touchAction.update();
          return this;
      },

      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
          }

          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
          }
          return this;
      },

      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
      },

      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
          }

          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
          }
          return this;
      },

      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
          }

          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
              this.requireFail.splice(index, 1);
          }
          return this;
      },

      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
          return this.requireFail.length > 0;
      },

      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
      },

      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(input) {
          var self = this;
          var state = this.state;

          function emit(event) {
              self.manager.emit(event, input);
          }

          // 'panstart' and 'panmove'
          if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }

          emit(self.options.event); // simple 'eventName' events

          if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
          }

          // panend and pancancel
          if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
          }
      },

      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(input) {
          if (this.canEmit()) {
              return this.emit(input);
          }
          // it's failing anyway
          this.state = STATE_FAILED;
      },

      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                  return false;
              }
              i++;
          }
          return true;
      },

      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          // make a new copy of the inputData
          // so we can change the inputData without messing up the other recognizers
          var inputDataClone = assign({}, inputData);

          // is is enabled and allow recognizing?
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
          }

          // reset when we've reached the end
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
          }

          this.state = this.process(inputDataClone);

          // the recognizer has recognized a gesture
          // so trigger an event
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
          }
      },

      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(inputData) { }, // jshint ignore:line

      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() { },

      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() { }
  };

  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */
  function stateStr(state) {
      if (state & STATE_CANCELLED) {
          return 'cancel';
      } else if (state & STATE_ENDED) {
          return 'end';
      } else if (state & STATE_CHANGED) {
          return 'move';
      } else if (state & STATE_BEGAN) {
          return 'start';
      }
      return '';
  }

  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */
  function directionStr(direction) {
      if (direction == DIRECTION_DOWN) {
          return 'down';
      } else if (direction == DIRECTION_UP) {
          return 'up';
      } else if (direction == DIRECTION_LEFT) {
          return 'left';
      } else if (direction == DIRECTION_RIGHT) {
          return 'right';
      }
      return '';
  }

  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */
  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
      var manager = recognizer.manager;
      if (manager) {
          return manager.get(otherRecognizer);
      }
      return otherRecognizer;
  }

  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */
  function AttrRecognizer() {
      Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
      },

      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
      },

      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(input) {
          var state = this.state;
          var eventType = input.eventType;

          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);

          // on cancel input and we've recognized before, return STATE_CANCELLED
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                  return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                  return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
          }
          return STATE_FAILED;
      }
  });

  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function PanRecognizer() {
      AttrRecognizer.apply(this, arguments);

      this.pX = null;
      this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
      },

      getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
      },

      directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;

          // lock to axis?
          if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                  direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                  hasMoved = x != this.pX;
                  distance = Math.abs(input.deltaX);
              } else {
                  direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                  hasMoved = y != this.pY;
                  distance = Math.abs(input.deltaY);
              }
          }
          input.direction = direction;
          return hasMoved && distance > options.threshold && direction & options.direction;
      },

      attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) &&
              (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
      },

      emit: function(input) {

          this.pX = input.deltaX;
          this.pY = input.deltaY;

          var direction = directionStr(input.direction);

          if (direction) {
              input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */
  function PinchRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'pinch',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
      },

      emit: function(input) {
          if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
      }
  });

  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */
  function PressRecognizer() {
      Recognizer.apply(this, arguments);

      this._timer = null;
      this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
          event: 'press',
          pointers: 1,
          time: 251, // minimal time of the pointer to be pressed
          threshold: 9 // a minimal movement is ok, but keep it low
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
      },

      process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;

          this._input = input;

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
              this.reset();
          } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
              }, options.time, this);
          } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
              return;
          }

          if (input && (input.eventType & INPUT_END)) {
              this.manager.emit(this.options.event + 'up', input);
          } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */
  function RotateRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
          event: 'rotate',
          threshold: 0,
          pointers: 2
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
      },

      attrTest: function(input) {
          return this._super.attrTest.call(this, input) &&
              (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
      }
  });

  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */
  function SwipeRecognizer() {
      AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
      },

      getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
      },

      attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;

          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
          }

          return this._super.attrTest.call(this, input) &&
              direction & input.offsetDirection &&
              input.distance > this.options.threshold &&
              input.maxPointers == this.options.pointers &&
              abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
      },

      emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
              this.manager.emit(this.options.event + direction, input);
          }

          this.manager.emit(this.options.event, input);
      }
  });

  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */
  function TapRecognizer() {
      Recognizer.apply(this, arguments);

      // previous time and center,
      // used for tap counting
      this.pTime = false;
      this.pCenter = false;

      this._timer = null;
      this._input = null;
      this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300, // max time between the multi-tap taps
          time: 250, // max time of the pointer to be down (like finger on the screen)
          threshold: 9, // a minimal movement is ok, but keep it low
          posThreshold: 10 // a multi-tap can be a bit off the initial position
      },

      getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
      },

      process: function(input) {
          var options = this.options;

          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;

          this.reset();

          if ((input.eventType & INPUT_START) && (this.count === 0)) {
              return this.failTimeout();
          }

          // we only allow little movement
          // and we've reached an end event, so a tap is possible
          if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                  return this.failTimeout();
              }

              var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                  this.count = 1;
              } else {
                  this.count += 1;
              }

              this._input = input;

              // if tap count matches we have recognized it,
              // else it has began recognizing...
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                  // no failing requirements, immediately trigger the tap event
                  // or wait as long as the multitap interval to trigger
                  if (!this.hasRequireFailures()) {
                      return STATE_RECOGNIZED;
                  } else {
                      this._timer = setTimeoutContext(function() {
                          this.state = STATE_RECOGNIZED;
                          this.tryEmit();
                      }, options.interval, this);
                      return STATE_BEGAN;
                  }
              }
          }
          return STATE_FAILED;
      },

      failTimeout: function() {
          this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
      },

      reset: function() {
          clearTimeout(this._timer);
      },

      emit: function() {
          if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
          }
      }
  });

  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Hammer(element, options) {
      options = options || {};
      options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
      return new Manager(element, options);
  }

  /**
   * @const {string}
   */
  Hammer.VERSION = '2.0.7';

  /**
   * default settings
   * @namespace
   */
  Hammer.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: false,

      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: TOUCH_ACTION_COMPUTE,

      /**
       * @type {Boolean}
       * @default true
       */
      enable: true,

      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,

      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,

      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {enable: false}],
          [PinchRecognizer, {enable: false}, ['rotate']],
          [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
          [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
          [TapRecognizer],
          [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
          [PressRecognizer]
      ],

      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: 'none',

          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: 'none',

          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: 'none',

          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: 'none',

          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: 'none',

          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: 'rgba(0,0,0,0)'
      }
  };

  var STOP = 1;
  var FORCED_STOP = 2;

  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */
  function Manager(element, options) {
      this.options = assign({}, Hammer.defaults, options || {});

      this.options.inputTarget = this.options.inputTarget || element;

      this.handlers = {};
      this.session = {};
      this.recognizers = [];
      this.oldCssProps = {};

      this.element = element;
      this.input = createInputInstance(this);
      this.touchAction = new TouchAction(this, this.options.touchAction);

      toggleCssProps(this, true);

      each(this.options.recognizers, function(item) {
          var recognizer = this.add(new (item[0])(item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
      }, this);
  }

  Manager.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(options) {
          assign(this.options, options);

          // Options that need a little more setup
          if (options.touchAction) {
              this.touchAction.update();
          }
          if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
          }
          return this;
      },

      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
      },

      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
              return;
          }

          // run the touch-action polyfill
          this.touchAction.preventDefaults(inputData);

          var recognizer;
          var recognizers = this.recognizers;

          // this holds the recognizer that is being recognized.
          // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
          // if no recognizer is detecting a thing, it is set to `null`
          var curRecognizer = session.curRecognizer;

          // reset when the last recognizer is recognized
          // or when we're in a new session
          if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
              curRecognizer = session.curRecognizer = null;
          }

          var i = 0;
          while (i < recognizers.length) {
              recognizer = recognizers[i];

              // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.
              if (session.stopped !== FORCED_STOP && ( // 1
                      !curRecognizer || recognizer == curRecognizer || // 2
                      recognizer.canRecognizeWith(curRecognizer))) { // 3
                  recognizer.recognize(inputData);
              } else {
                  recognizer.reset();
              }

              // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                  curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
          }
      },

      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
              return recognizer;
          }

          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                  return recognizers[i];
              }
          }
          return null;
      },

      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(recognizer) {
          if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
          }

          // remove existing
          var existing = this.get(recognizer.options.event);
          if (existing) {
              this.remove(existing);
          }

          this.recognizers.push(recognizer);
          recognizer.manager = this;

          this.touchAction.update();
          return recognizer;
      },

      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(recognizer) {
          if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
          }

          recognizer = this.get(recognizer);

          // let's make sure this recognizer exists
          if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                  recognizers.splice(index, 1);
                  this.touchAction.update();
              }
          }

          return this;
      },

      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(events, handler) {
          if (events === undefined$1) {
              return;
          }
          if (handler === undefined$1) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
          });
          return this;
      },

      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(events, handler) {
          if (events === undefined$1) {
              return;
          }

          var handlers = this.handlers;
          each(splitStr(events), function(event) {
              if (!handler) {
                  delete handlers[event];
              } else {
                  handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
          });
          return this;
      },

      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(event, data) {
          // we also want to trigger dom events
          if (this.options.domEvents) {
              triggerDomEvent(event, data);
          }

          // no handlers, so skip it all
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
              return;
          }

          data.type = event;
          data.preventDefault = function() {
              data.srcEvent.preventDefault();
          };

          var i = 0;
          while (i < handlers.length) {
              handlers[i](data);
              i++;
          }
      },

      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
          this.element && toggleCssProps(this, false);

          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
      }
  };

  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */
  function toggleCssProps(manager, add) {
      var element = manager.element;
      if (!element.style) {
          return;
      }
      var prop;
      each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
          } else {
              element.style[prop] = manager.oldCssProps[prop] || '';
          }
      });
      if (!add) {
          manager.oldCssProps = {};
      }
  }

  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */
  function triggerDomEvent(event, data) {
      var gestureEvent = document.createEvent('Event');
      gestureEvent.initEvent(event, true, true);
      gestureEvent.gesture = data;
      data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
      INPUT_START: INPUT_START,
      INPUT_MOVE: INPUT_MOVE,
      INPUT_END: INPUT_END,
      INPUT_CANCEL: INPUT_CANCEL,

      STATE_POSSIBLE: STATE_POSSIBLE,
      STATE_BEGAN: STATE_BEGAN,
      STATE_CHANGED: STATE_CHANGED,
      STATE_ENDED: STATE_ENDED,
      STATE_RECOGNIZED: STATE_RECOGNIZED,
      STATE_CANCELLED: STATE_CANCELLED,
      STATE_FAILED: STATE_FAILED,

      DIRECTION_NONE: DIRECTION_NONE,
      DIRECTION_LEFT: DIRECTION_LEFT,
      DIRECTION_RIGHT: DIRECTION_RIGHT,
      DIRECTION_UP: DIRECTION_UP,
      DIRECTION_DOWN: DIRECTION_DOWN,
      DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
      DIRECTION_VERTICAL: DIRECTION_VERTICAL,
      DIRECTION_ALL: DIRECTION_ALL,

      Manager: Manager,
      Input: Input,
      TouchAction: TouchAction,

      TouchInput: TouchInput,
      MouseInput: MouseInput,
      PointerEventInput: PointerEventInput,
      TouchMouseInput: TouchMouseInput,
      SingleTouchInput: SingleTouchInput,

      Recognizer: Recognizer,
      AttrRecognizer: AttrRecognizer,
      Tap: TapRecognizer,
      Pan: PanRecognizer,
      Swipe: SwipeRecognizer,
      Pinch: PinchRecognizer,
      Rotate: RotateRecognizer,
      Press: PressRecognizer,

      on: addEventListeners,
      off: removeEventListeners,
      each: each,
      merge: merge,
      extend: extend,
      assign: assign,
      inherit: inherit,
      bindFn: bindFn,
      prefixed: prefixed
  });

  // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.
  var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
  freeGlobal.Hammer = Hammer;

  if (typeof undefined$1 === 'function' && undefined$1.amd) {
      undefined$1(function() {
          return Hammer;
      });
  } else if (module.exports) {
      module.exports = Hammer;
  } else {
      window[exportName] = Hammer;
  }

  })(window, document, 'Hammer');
  }(hammer));

  var Hammer = hammer.exports;

  var KnockoutHammerBinding$1 = {
      register: function (Knockout) {
          Knockout.bindingHandlers.swipeLeft = {
              init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                  var f = Knockout.unwrap(valueAccessor());
                  new Hammer(element).on("swipeleft", function (e) {
                      var viewModel = bindingContext.$data;
                      f.apply(viewModel, arguments);
                  });
              }
          };
          Knockout.bindingHandlers.swipeRight = {
              init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                  var f = Knockout.unwrap(valueAccessor());
                  new Hammer(element).on("swiperight", function (e) {
                      var viewModel = bindingContext.$data;
                      f.apply(viewModel, arguments);
                  });
              }
          };
      }
  };

  // @ts-ignore
  var Knockout$9 = Cesium__namespace.knockout;
  var registerKnockoutBindings$1 = function () {
      // @ts-ignore
      Cesium__namespace.SvgPathBindingHandler.register(Knockout$9);
      KnockoutMarkdownBinding$1.register(Knockout$9);
      KnockoutHammerBinding$1.register(Knockout$9);
      Knockout$9.bindingHandlers.embeddedComponent = {
          init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
              var component = Knockout$9.unwrap(valueAccessor());
              component.show(element);
              return { controlsDescendantBindings: true };
          },
          update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
              return;
          }
      };
  };

  var createFragmentFromTemplate$1 = function (htmlString) {
      var holder = document.createElement("div");
      holder.innerHTML = htmlString;
      var fragment = document.createDocumentFragment();
      while (holder.firstChild) {
          fragment.appendChild(holder.firstChild);
      }
      return fragment;
  };

  // @ts-ignore
  var Knockout$8 = Cesium__namespace.knockout;
  var loadView$1 = function (htmlString, container, viewModel) {
      // @ts-ignore
      container = Cesium__namespace.getElement(container);
      var fragment = createFragmentFromTemplate$1(htmlString);
      // Sadly, fragment.childNodes doesn't have a slice function.
      // This code could be replaced with Array.prototype.slice.call(fragment.childNodes)
      // but that seems slightly error prone.
      var nodes = [];
      var i;
      for (i = 0; i < fragment.childNodes.length; ++i) {
          nodes.push(fragment.childNodes[i]);
      }
      container.appendChild(fragment);
      for (i = 0; i < nodes.length; ++i) {
          var node = nodes[i];
          if (node.nodeType === 1 || node.nodeType === 8) {
              Knockout$8.applyBindings(viewModel, node);
          }
      }
      return nodes;
  };

  /* eslint-disable quotes */
  // @ts-ignore
  var Knockout$7 = Cesium__namespace.knockout;
  var DistanceLegendViewModel$1 = function (options) {
      if (!Cesium__namespace.defined(options) || !Cesium__namespace.defined(options.terria)) {
          throw new Cesium__namespace.DeveloperError("options.terria is required.");
      }
      this.terria = options.terria;
      this._removeSubscription = undefined;
      this._lastLegendUpdate = undefined;
      this.eventHelper = new Cesium__namespace.EventHelper();
      this.distanceLabel = undefined;
      this.barWidth = undefined;
      this.enableDistanceLegend = Cesium__namespace.defined(options.enableDistanceLegend) ? options.enableDistanceLegend : true;
      Knockout$7.track(this, ["distanceLabel", "barWidth"]);
      this.eventHelper.add(this.terria.afterWidgetChanged, function () {
          if (Cesium__namespace.defined(this._removeSubscription)) {
              this._removeSubscription();
              this._removeSubscription = undefined;
          }
      }, this);
      //        this.terria.beforeWidgetChanged.addEventListener(function () {
      //            if ( Cesium.defined(this._removeSubscription)) {
      //                this._removeSubscription();
      //                this._removeSubscription = undefined;
      //            }
      //        }, this);
      var that = this;
      function addUpdateSubscription() {
          if (Cesium__namespace.defined(that.terria)) {
              var scene_1 = that.terria.scene;
              that._removeSubscription = scene_1.postRender.addEventListener(function () {
                  updateDistanceLegendCesium$1(this, scene_1);
              }, that);
          }
      }
      addUpdateSubscription();
      this.eventHelper.add(this.terria.afterWidgetChanged, function () {
          addUpdateSubscription();
      }, this);
      // this.terria.afterWidgetChanged.addEventListener(function() {
      //    addUpdateSubscription();
      // }, this);
  };
  DistanceLegendViewModel$1.prototype.destroy = function () {
      this.eventHelper.removeAll();
  };
  DistanceLegendViewModel$1.prototype.show = function (container) {
      var testing;
      if (this.enableDistanceLegend) {
          testing =
              '<div class="distance-legend" data-bind="visible: distanceLabel && barWidth">' +
                  '<div class="distance-legend-label" data-bind="text: distanceLabel"></div>' +
                  "<div class=\"distance-legend-scale-bar\" data-bind=\"style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }\"></div>" +
                  "</div>";
      }
      else {
          testing =
              '<div class="distance-legend"  style="display: none;" data-bind="visible: distanceLabel && barWidth">' +
                  '<div class="distance-legend-label"  data-bind="text: distanceLabel"></div>' +
                  "<div class=\"distance-legend-scale-bar\"  data-bind=\"style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }\"></div>" +
                  "</div>";
      }
      loadView$1(testing, container, this);
      // loadView(distanceLegendTemplate, container, this);
      // loadView(require('fs').readFileSync(__dirname + '/../Views/DistanceLegend.html', 'utf8'), container, this);
  };
  DistanceLegendViewModel$1.create = function (options) {
      var result = new DistanceLegendViewModel$1(options);
      result.show(options.container);
      return result;
  };
  var geodesic$1 = new Cesium__namespace.EllipsoidGeodesic();
  var distances$1 = [
      1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 20000, 30000, 50000, 100000, 200000,
      300000, 500000, 1000000, 2000000, 3000000, 5000000, 10000000, 20000000, 30000000, 50000000
  ];
  function updateDistanceLegendCesium$1(viewModel, scene) {
      if (!viewModel.enableDistanceLegend) {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
          return;
      }
      // @ts-ignore
      var now = Cesium__namespace.getTimestamp();
      if (now < viewModel._lastLegendUpdate + 250) {
          return;
      }
      viewModel._lastLegendUpdate = now;
      // Find the distance between two pixels at the bottom center of the screen.
      var width = scene.canvas.clientWidth;
      var height = scene.canvas.clientHeight;
      var left = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((width / 2) | 0, height - 1));
      var right = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((1 + width / 2) | 0, height - 1));
      var globe = scene.globe;
      var leftPosition = globe.pick(left, scene);
      var rightPosition = globe.pick(right, scene);
      if (!Cesium__namespace.defined(leftPosition) || !Cesium__namespace.defined(rightPosition)) {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
          return;
      }
      var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
      var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);
      geodesic$1.setEndPoints(leftCartographic, rightCartographic);
      var pixelDistance = geodesic$1.surfaceDistance;
      // Find the first distance that makes the scale bar less than 100 pixels.
      var maxBarWidth = 100;
      var distance;
      for (var i = distances$1.length - 1; !Cesium__namespace.defined(distance) && i >= 0; --i) {
          if (distances$1[i] / pixelDistance < maxBarWidth) {
              distance = distances$1[i];
          }
      }
      if (Cesium__namespace.defined(distance)) {
          var label = void 0;
          if (distance >= 1000) {
              label = (distance / 1000).toString() + " km";
          }
          else {
              label = distance.toString() + " m";
          }
          viewModel.barWidth = (distance / pixelDistance) | 0;
          viewModel.distanceLabel = label;
      }
      else {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
      }
  }

  var svgReset$1 = "M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z";

  // @ts-ignore
  var Knockout$6 = Cesium__namespace.knockout;
  /**
   * The view-model for a control in the user interface
   *
   * @alias UserInterfaceControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var UserInterfaceControl$1 = function (terria) {
      if (!Cesium__namespace.defined(terria)) {
          throw new Cesium__namespace.DeveloperError("terria is required");
      }
      this._terria = terria;
      /**
       * Gets or sets the name of the control which is set as the controls title.
       * This property is observable.
       * @type {String}
       */
      this.name = "Unnamed Control";
      /**
       * Gets or sets the text to be displayed in the UI control.
       * This property is observable.
       * @type {String}
       */
      this.text = undefined;
      /**
       * Gets or sets the svg icon of the control.  This property is observable.
       * @type {Object}
       */
      this.svgIcon = undefined;
      /**
       * Gets or sets the height of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgHeight = undefined;
      /**
       * Gets or sets the width of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgWidth = undefined;
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = undefined;
      /**
       * Gets or sets the property describing whether or not the control is in the active state.
       * This property is observable.
       * @type {Boolean}
       */
      this.isActive = false;
      Knockout$6.track(this, ["name", "svgIcon", "svgHeight", "svgWidth", "cssClass", "isActive"]);
  };
  // @ts-ignore
  Object.defineProperties(UserInterfaceControl$1.prototype, {
      /**
       * Gets the Terria instance.
       * @memberOf UserInterfaceControl.prototype
       * @type {Terria}
       */
      terria: {
          get: function () {
              return this._terria;
          }
      },
      /**
       * Gets a value indicating whether this button has text associated with it.
       * @type {Object}
       * @ignore
       */
      hasText: {
          get: function () {
              return Cesium__namespace.defined(this.text) && typeof this.text === "string";
          }
      }
  });
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control.
   * @abstract
   * @protected
   * @ignore
   */
  UserInterfaceControl$1.prototype.activate = function () {
      throw new Cesium__namespace.DeveloperError("activate must be implemented in the derived class.");
  };

  /**
   * The view-model for a control in the navigation control tool bar
   *
   * @alias NavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var NavigationControl$1 = function (terria) {
      UserInterfaceControl$1.apply(this, arguments);
  };
  NavigationControl$1.prototype = Object.create(UserInterfaceControl$1.prototype);

  /**
   * The model for a zoom in control in the navigation control tool bar
   *
   * @alias ResetViewNavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var ResetViewNavigationControl$1 = function (terria) {
      NavigationControl$1.apply(this, arguments);
      /**
       * Gets or sets the name of the control which is set as the control's title.
       * This property is observable.
       * @type {String}
       */
      this.name = "重置视图";
      this.navigationLocked = false;
      /**
       * Gets or sets the svg icon of the control.  This property is observable.
       * @type {Object}
       */
      this.svgIcon = svgReset$1;
      /**
       * Gets or sets the height of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgHeight = 15;
      /**
       * Gets or sets the width of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgWidth = 15;
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = "navigation-control-icon-reset";
  };
  ResetViewNavigationControl$1.prototype = Object.create(NavigationControl$1.prototype);
  ResetViewNavigationControl$1.prototype.setNavigationLocked = function (locked) {
      this.navigationLocked = locked;
  };
  ResetViewNavigationControl$1.prototype.resetView = function () {
      // this.terria.analytics.logEvent('navigation', 'click', 'reset');
      if (this.navigationLocked) {
          return;
      }
      var scene = this.terria.scene;
      var sscc = scene.screenSpaceCameraController;
      if (!sscc.enableInputs) {
          return;
      }
      this.isActive = true;
      scene.camera;
      if (Cesium__namespace.defined(this.terria.trackedEntity)) {
          // when tracking do not reset to default view but to default view of tracked entity
          var trackedEntity = this.terria.trackedEntity;
          this.terria.trackedEntity = undefined;
          this.terria.trackedEntity = trackedEntity;
      }
      else {
          // 定位到默认位置
          var _a = this.terria.options, position = _a.position, map = _a.map;
          if (position) {
              map.flyTo({
                  center: position.center,
                  zoom: position.zoom,
                  orientation: position.orientation,
                  duration: position.duration || 1
              });
          }
          else {
              map.flyTo({
                  center: map.options.center,
                  zoom: map.options.zoom,
                  orientation: map.options.orientation,
                  duration: 1
              });
          }
      }
      this.isActive = false;
  };
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control
   * @abstract
   * @protected
   * @ignore
   */
  ResetViewNavigationControl$1.prototype.activate = function () {
      this.resetView();
  };

  /* eslint-disable no-unused-vars */
  var Utils$1 = {};
  var unprojectedScratch$1 = new Cesium__namespace.Cartographic();
  var rayScratch$1 = new Cesium__namespace.Ray();
  /**
   * gets the focus point of the camera
   * @param {Viewer|Widget} terria The terria
   * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
   * @param { Cesium.Cartesian3} [result] The object in which the result will be stored.
   * @return { Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
   * @ignore
   */
  // @ts-ignore
  Utils$1.getCameraFocus = function (terria, inWorldCoordinates, result) {
      var scene = terria.scene;
      var camera = scene.camera;
      if (scene.mode === 0 /* MORPHING */) {
          return undefined;
      }
      if (!Cesium__namespace.defined(result)) {
          result = new Cesium__namespace.Cartesian3();
      }
      // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
      // TODO bug when tracking: reset should reset to default view of tracked entity
      if (Cesium__namespace.defined(terria.trackedEntity)) {
          result = terria.trackedEntity.position.getValue(terria.clock.currentTime, result);
      }
      else {
          rayScratch$1.origin = camera.positionWC;
          rayScratch$1.direction = camera.directionWC;
          result = scene.globe.pick(rayScratch$1, scene, result);
      }
      if (!Cesium__namespace.defined(result)) {
          return undefined;
      }
      if (scene.mode === 2 /* SCENE2D */ || scene.mode === 1 /* COLUMBUS_VIEW */) {
          result = camera.worldToCameraCoordinatesPoint(result, result);
          if (inWorldCoordinates) {
              result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch$1), result);
          }
      }
      else {
          if (!inWorldCoordinates) {
              result = camera.worldToCameraCoordinatesPoint(result, result);
          }
      }
      return result;
  };

  /**
   * The model for a zoom in control in the navigation control tool bar
   *
   * @alias ZoomOutNavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   * @param {boolean} zoomIn is used for zooming in (true) or out (false)
   */
  var ZoomNavigationControl$1 = function (terria, zoomIn) {
      NavigationControl$1.apply(this, arguments);
      /**
       * Gets or sets the name of the control which is set as the control's title.
       * This property is observable.
       * @type {String}
       */
      this.name = "Zoom " + (zoomIn ? "In" : "Out");
      /**
       * Gets or sets the text to be displayed in the nav control. Controls that
       * have text do not display the svgIcon.
       * This property is observable.
       * @type {String}
       */
      this.text = zoomIn ? "+" : "-";
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = "navigation-control-icon-zoom-" + (zoomIn ? "in" : "out");
      this.relativeAmount = 2;
      if (zoomIn) {
          // this ensures that zooming in is the inverse of zooming out and vice versa
          // e.g. the camera position remains when zooming in and out
          this.relativeAmount = 1 / this.relativeAmount;
      }
  };
  ZoomNavigationControl$1.prototype.relativeAmount = 1;
  ZoomNavigationControl$1.prototype = Object.create(NavigationControl$1.prototype);
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control
   * @abstract
   * @protected
   * @ignore
   */
  ZoomNavigationControl$1.prototype.activate = function () {
      this.zoom(this.relativeAmount);
  };
  var cartesian3Scratch$1 = new Cesium__namespace.Cartesian3();
  ZoomNavigationControl$1.prototype.zoom = function (relativeAmount) {
      // this.terria.analytics.logEvent('navigation', 'click', 'zoomIn');
      this.isActive = true;
      if (Cesium__namespace.defined(this.terria)) {
          var scene = this.terria.scene;
          var sscc = scene.screenSpaceCameraController;
          // do not zoom if it is disabled
          if (!sscc.enableInputs || !sscc.enableZoom) {
              return;
          }
          // TODO
          //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
          //                return;
          //            }
          var camera = scene.camera;
          var orientation_1;
          if (scene.mode === 0 /* MORPHING */) ;
          else if (scene.mode === 2 /* SCENE2D */) {
              camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
          }
          else {
              var focus_1;
              if (Cesium__namespace.defined(this.terria.trackedEntity)) {
                  focus_1 = new Cesium__namespace.Cartesian3();
              }
              else {
                  // @ts-ignore
                  focus_1 = Utils$1.getCameraFocus(this.terria, false);
              }
              if (!Cesium__namespace.defined(focus_1)) {
                  // Cesium.Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                  // the focal point.
                  var ray = new Cesium__namespace.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                  focus_1 = Cesium__namespace.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);
                  orientation_1 = {
                      heading: camera.heading,
                      pitch: camera.pitch,
                      roll: camera.roll
                  };
              }
              else {
                  orientation_1 = {
                      direction: camera.direction,
                      up: camera.up
                  };
              }
              var direction = Cesium__namespace.Cartesian3.subtract(camera.position, focus_1, cartesian3Scratch$1);
              var movementVector = Cesium__namespace.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
              var endPosition = Cesium__namespace.Cartesian3.add(focus_1, movementVector, focus_1);
              if (Cesium__namespace.defined(this.terria.trackedEntity) || scene.mode === 1 /* COLUMBUS_VIEW */) {
                  // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                  // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                  camera.position = endPosition;
              }
              else {
                  camera.flyTo({
                      destination: endPosition,
                      orientation: orientation_1,
                      duration: 0.5,
                      convert: false
                  });
              }
          }
      }
      // this.terria.notifyRepaintRequired();
      this.isActive = false;
  };

  var svgCompassOuterRing$1 = "M73.5,20.7c-28.9,0-52.3,23.5-52.3,52.6s23.4,52.6,52.3,52.6s52.3-23.5,52.3-52.6S102.4,20.7,73.5,20.7z M73.5,22.5c13.8,0,26.4,5.6,35.5,14.7L98,48.2l0.6,0.6l11-11.1c8.9,9.1,14.4,21.7,14.4,35.5s-5.5,26.3-14.4,35.5l-11-11.1L98,98.3l11,11.1c-9.1,9-21.7,14.7-35.5,14.7s-26.3-5.5-35.4-14.6l11.1-11.2c6.3,6.1,14.9,9.9,24.3,9.9c19.2,0,34.9-15.7,34.9-35.1s-15.6-35-34.9-35c-9.5,0-18,3.8-24.3,9.9L38.1,37C47.2,28,59.7,22.5,73.5,22.5z M72.6,23.3v14h1.8v-14H72.6z M37.5,37.7l11.1,11.2c-6.1,6.3-9.9,15-9.9,24.4s3.8,18.2,9.9,24.4l-11.1,11.2C28.5,99.7,23,87.1,23,73.2S28.5,46.8,37.5,37.7z M73.5,40c18.3,0,33.1,14.9,33.1,33.3s-14.8,33.3-33.1,33.3S40.4,91.6,40.4,73.2S55.2,40,73.5,40z M23.8,72.3v1.8h14v-1.8H23.8z M109.4,72.3v1.8h14v-1.8H109.4z M72.8,109.2v14h1.7v-14H72.8z M66.2,12.3l-0.4-1.9c0.5-0.1,1.1-0.3,2-0.5c0.9-0.2,1.6-0.3,2-0.4V5.9h-3.7V4.2h3.7V1h2.3v12.6h-2.3v-2.1 C68.6,11.7,67.4,12,66.2,12.3z M79.5,2.7l1.6,1.5c-1.5,0.9-3.2,1.9-4.9,2.8v3.9c0,0.5,0.3,0.8,0.9,0.8h0.5c0.6,0,0.9-0.3,1-1 c0-0.1,0-0.2,0.1-0.4c0.1-0.7,0.1-1.3,0.1-1.8c0.1,0,0.3,0.1,0.5,0.1C79.9,8.7,80.4,8.9,81,9c0,0.4-0.1,1-0.3,1.9 c0,0.3-0.1,0.4-0.1,0.6c-0.3,1.2-1.2,1.8-2.7,1.8h-1.4c-1.8,0-2.7-0.7-2.7-2V1h2.3v3.8C77.5,4.1,78.6,3.4,79.5,2.7z";

  var svgCompassGyro$1 = "m 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z";

  var svgCompassRotationMarker$1 = "M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z";

  /* eslint-disable quotes */
  var CesiumMath$1 = Cesium__namespace.Math;
  // @ts-ignore
  var Knockout$5 = Cesium__namespace.knockout;
  var NavigationViewModel$1 = function (options) {
      this.terria = options.terria;
      this.eventHelper = new Cesium__namespace.EventHelper();
      this.enableZoomControls = Cesium__namespace.defined(options.enableZoomControls) ? options.enableZoomControls : true;
      this.enableCompass = Cesium__namespace.defined(options.enableCompass) ? options.enableCompass : true;
      this.navigationLocked = false;
      // if (this.showZoomControls)
      //   {
      this.controls = options.controls;
      if (!Cesium__namespace.defined(this.controls)) {
          this.controls = [
              new ZoomNavigationControl$1(this.terria, true),
              new ResetViewNavigationControl$1(this.terria),
              new ZoomNavigationControl$1(this.terria, false)
          ];
      }
      // }
      this.svgCompassOuterRing = svgCompassOuterRing$1;
      this.svgCompassGyro = svgCompassGyro$1;
      this.svgCompassRotationMarker = svgCompassRotationMarker$1;
      this.showCompass = Cesium__namespace.defined(this.terria) && this.enableCompass;
      this.heading = this.showCompass ? this.terria.scene.camera.heading : 0.0;
      this.isOrbiting = false;
      this.orbitCursorAngle = 0;
      this.orbitCursorOpacity = 0.0;
      this.orbitLastTimestamp = 0;
      this.orbitFrame = undefined;
      this.orbitIsLook = false;
      this.orbitMouseMoveFunction = undefined;
      this.orbitMouseUpFunction = undefined;
      this.isRotating = false;
      this.rotateInitialCursorAngle = undefined;
      this.rotateFrame = undefined;
      this.rotateIsLook = false;
      this.rotateMouseMoveFunction = undefined;
      this.rotateMouseUpFunction = undefined;
      this._unsubcribeFromPostRender = undefined;
      Knockout$5.track(this, ["controls", "showCompass", "heading", "isOrbiting", "orbitCursorAngle", "isRotating"]);
      var that = this;
      NavigationViewModel$1.prototype.setNavigationLocked = function (locked) {
          this.navigationLocked = locked;
          if (this.controls && this.controls.length > 1) {
              this.controls[1].setNavigationLocked(this.navigationLocked);
          }
      };
      function widgetChange() {
          if (Cesium__namespace.defined(that.terria)) {
              if (that._unsubcribeFromPostRender) {
                  that._unsubcribeFromPostRender();
                  that._unsubcribeFromPostRender = undefined;
              }
              that.showCompass = that.enableCompass;
              that._unsubcribeFromPostRender = that.terria.scene.postRender.addEventListener(function () {
                  that.heading = that.terria.scene.camera.heading;
              });
          }
          else {
              if (that._unsubcribeFromPostRender) {
                  that._unsubcribeFromPostRender();
                  that._unsubcribeFromPostRender = undefined;
              }
              that.showCompass = false;
          }
      }
      this.eventHelper.add(this.terria.afterWidgetChanged, widgetChange, this);
      // this.terria.afterWidgetChanged.addEventListener(widgetChange);
      widgetChange();
  };
  NavigationViewModel$1.prototype.destroy = function () {
      this.eventHelper.removeAll();
      // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);
  };
  NavigationViewModel$1.prototype.show = function (container) {
      var testing;
      if (this.enableZoomControls && this.enableCompass) {
          testing =
              '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls">' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (!this.enableZoomControls && this.enableCompass) {
          testing =
              '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"  style="display: none;" >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (this.enableZoomControls && !this.enableCompass) {
          testing =
              '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"    >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (!this.enableZoomControls && !this.enableCompass) {
          testing =
              '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"   style="display: none;" >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      loadView$1(testing, container, this);
      // loadView(navigatorTemplate, container, this);
      // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);
  };
  /**
   * Adds a control to this toolbar.
   * @param {NavControl} control The control to add.
   * @ignore
   */
  NavigationViewModel$1.prototype.add = function (control) {
      this.controls.push(control);
  };
  /**
   * Removes a control from this toolbar.
   * @param {NavControl} control The control to remove.
   * @ignore
   */
  NavigationViewModel$1.prototype.remove = function (control) {
      this.controls.remove(control);
  };
  /**
   * Checks if the control given is the last control in the control array.
   * @param {NavControl} control The control to remove.
   * @ignore
   */
  NavigationViewModel$1.prototype.isLastControl = function (control) {
      return control === this.controls[this.controls.length - 1];
  };
  var vectorScratch$1 = new Cesium__namespace.Cartesian2();
  NavigationViewModel$1.prototype.handleMouseDown = function (viewModel, e) {
      var scene = this.terria.scene;
      if (scene.mode === 0 /* MORPHING */) {
          return true;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      var compassElement = e.currentTarget;
      var compassRectangle = e.currentTarget.getBoundingClientRect();
      var maxDistance = compassRectangle.width / 2.0;
      var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
      var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
      var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch$1);
      var distanceFromCenter = Cesium__namespace.Cartesian2.magnitude(vector);
      var distanceFraction = distanceFromCenter / maxDistance;
      var nominalTotalRadius = 145;
      var norminalGyroRadius = 50;
      if (distanceFraction < norminalGyroRadius / nominalTotalRadius) {
          orbit$1(this, compassElement, vector);
          //            return false;
      }
      else if (distanceFraction < 1.0) {
          rotate$1(this, compassElement, vector);
          //            return false;
      }
      else {
          return true;
      }
  };
  var oldTransformScratch$1 = new Cesium__namespace.Matrix4();
  var newTransformScratch$1 = new Cesium__namespace.Matrix4();
  var centerScratch$1 = new Cesium__namespace.Cartesian3();
  NavigationViewModel$1.prototype.handleDoubleClick = function (viewModel, e) {
      var scene = viewModel.terria.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;
      if (scene.mode === 0 /* MORPHING */ || !sscc.enableInputs) {
          return true;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      if (scene.mode === 1 /* COLUMBUS_VIEW */ && !sscc.enableTranslate) {
          return;
      }
      if (scene.mode === 3 /* SCENE3D */ || scene.mode === 1 /* COLUMBUS_VIEW */) {
          if (!sscc.enableLook) {
              return;
          }
          if (scene.mode === 3 /* SCENE3D */) {
              if (!sscc.enableRotate) {
                  return;
              }
          }
      }
      // @ts-ignore
      var center = Utils$1.getCameraFocus(viewModel.terria, true, centerScratch$1);
      if (!Cesium__namespace.defined(center)) {
          // Globe is barely visible, so reset to home view.
          this.controls[1].resetView();
          return;
      }
      var cameraPosition = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic, new Cesium__namespace.Cartesian3());
      var surfaceNormal = scene.globe.ellipsoid.geodeticSurfaceNormal(center);
      var focusBoundingSphere = new Cesium__namespace.BoundingSphere(center, 0);
      camera.flyToBoundingSphere(focusBoundingSphere, {
          offset: new Cesium__namespace.HeadingPitchRange(0, 
          // do not use camera.pitch since the pitch at the center/target is required
          CesiumMath$1.PI_OVER_TWO - Cesium__namespace.Cartesian3.angleBetween(surfaceNormal, camera.directionWC), 
          // distanceToBoundingSphere returns wrong values when in 2D or Columbus view so do not use
          // camera.distanceToBoundingSphere(focusBoundingSphere)
          // instead calculate distance manually
          Cesium__namespace.Cartesian3.distance(cameraPosition, center)),
          duration: 1.5
      });
  };
  NavigationViewModel$1.create = function (options) {
      // options.enableZoomControls = this.enableZoomControls;
      // options.enableCompass = this.enableCompass;
      var result = new NavigationViewModel$1(options);
      result.show(options.container);
      return result;
  };
  function orbit$1(viewModel, compassElement, cursorVector) {
      var scene = viewModel.terria.scene;
      var sscc = scene.screenSpaceCameraController;
      // do not orbit if it is disabled
      if (scene.mode === 0 /* MORPHING */ || !sscc.enableInputs) {
          return;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      switch (scene.mode) {
          case 1 /* COLUMBUS_VIEW */:
              if (sscc.enableLook) {
                  break;
              }
              if (!sscc.enableTranslate || !sscc.enableTilt) {
                  return;
              }
              break;
          case 3 /* SCENE3D */:
              if (sscc.enableLook) {
                  break;
              }
              if (!sscc.enableTilt || !sscc.enableRotate) {
                  return;
              }
              break;
          case 2 /* SCENE2D */:
              if (!sscc.enableTranslate) {
                  return;
              }
              break;
      }
      // Remove existing event handlers, if any.
      document.removeEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
      document.removeEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
      if (Cesium__namespace.defined(viewModel.orbitTickFunction)) {
          viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
      }
      viewModel.orbitMouseMoveFunction = undefined;
      viewModel.orbitMouseUpFunction = undefined;
      viewModel.orbitTickFunction = undefined;
      viewModel.isOrbiting = true;
      // @ts-ignore
      viewModel.orbitLastTimestamp = Cesium__namespace.getTimestamp();
      var camera = scene.camera;
      if (Cesium__namespace.defined(viewModel.terria.trackedEntity)) {
          // when tracking an entity simply use that reference frame
          viewModel.orbitFrame = undefined;
          viewModel.orbitIsLook = false;
      }
      else {
          // @ts-ignore
          var center = Utils$1.getCameraFocus(viewModel.terria, true, centerScratch$1);
          if (!Cesium__namespace.defined(center)) {
              viewModel.orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch$1);
              viewModel.orbitIsLook = true;
          }
          else {
              viewModel.orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid, newTransformScratch$1);
              viewModel.orbitIsLook = false;
          }
      }
      viewModel.orbitTickFunction = function (e) {
          // @ts-ignore
          var timestamp = Cesium__namespace.getTimestamp();
          var deltaT = timestamp - viewModel.orbitLastTimestamp;
          var rate = ((viewModel.orbitCursorOpacity - 0.5) * 2.5) / 1000;
          var distance = deltaT * rate;
          var angle = viewModel.orbitCursorAngle + CesiumMath$1.PI_OVER_TWO;
          var x = Math.cos(angle) * distance;
          var y = Math.sin(angle) * distance;
          var oldTransform;
          if (viewModel.navigationLocked) {
              return true;
          }
          if (Cesium__namespace.defined(viewModel.orbitFrame)) {
              oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch$1);
              camera.lookAtTransform(viewModel.orbitFrame);
          }
          // do not look up/down or rotate in 2D mode
          if (scene.mode === 2 /* SCENE2D */) {
              camera.move(new Cesium__namespace.Cartesian3(x, y, 0), (Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100) *
                  camera.positionCartographic.height *
                  distance);
          }
          else {
              if (viewModel.orbitIsLook) {
                  camera.look(Cesium__namespace.Cartesian3.UNIT_Z, -x);
                  camera.look(camera.right, -y);
              }
              else {
                  camera.rotateLeft(x);
                  camera.rotateUp(y);
              }
          }
          if (Cesium__namespace.defined(viewModel.orbitFrame)) {
              camera.lookAtTransform(oldTransform);
          }
          // viewModel.terria.cesium.notifyRepaintRequired();
          viewModel.orbitLastTimestamp = timestamp;
      };
      function updateAngleAndOpacity(vector, compassWidth) {
          var angle = Math.atan2(-vector.y, vector.x);
          viewModel.orbitCursorAngle = CesiumMath$1.zeroToTwoPi(angle - CesiumMath$1.PI_OVER_TWO);
          var distance = Cesium__namespace.Cartesian2.magnitude(vector);
          var maxDistance = compassWidth / 2.0;
          var distanceFraction = Math.min(distance / maxDistance, 1.0);
          var easedOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
          viewModel.orbitCursorOpacity = easedOpacity;
          // viewModel.terria.cesium.notifyRepaintRequired();
      }
      viewModel.orbitMouseMoveFunction = function (e) {
          var compassRectangle = compassElement.getBoundingClientRect();
          var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
          var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
          var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch$1);
          updateAngleAndOpacity(vector, compassRectangle.width);
      };
      viewModel.orbitMouseUpFunction = function (e) {
          // TODO: if mouse didn't move, reset view to looking down, north is up?
          viewModel.isOrbiting = false;
          document.removeEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
          document.removeEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
          if (Cesium__namespace.defined(viewModel.orbitTickFunction)) {
              viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
          }
          viewModel.orbitMouseMoveFunction = undefined;
          viewModel.orbitMouseUpFunction = undefined;
          viewModel.orbitTickFunction = undefined;
      };
      document.addEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
      document.addEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
      viewModel.terria.clock.onTick.addEventListener(viewModel.orbitTickFunction);
      updateAngleAndOpacity(cursorVector, compassElement.getBoundingClientRect().width);
  }
  function rotate$1(viewModel, compassElement, cursorVector) {
      var scene = viewModel.terria.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;
      // do not rotate in 2D mode or if rotating is disabled
      if (scene.mode === 0 /* MORPHING */ || scene.mode === 2 /* SCENE2D */ || !sscc.enableInputs) {
          return;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      if (!sscc.enableLook &&
          (scene.mode === 1 /* COLUMBUS_VIEW */ || (scene.mode === 3 /* SCENE3D */ && !sscc.enableRotate))) {
          return;
      }
      // Remove existing event handlers, if any.
      document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
      document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
      viewModel.rotateMouseMoveFunction = undefined;
      viewModel.rotateMouseUpFunction = undefined;
      viewModel.isRotating = true;
      viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);
      if (Cesium__namespace.defined(viewModel.terria.trackedEntity)) {
          // when tracking an entity simply use that reference frame
          viewModel.rotateFrame = undefined;
          viewModel.rotateIsLook = false;
      }
      else {
          // @ts-ignore
          var viewCenter = Utils$1.getCameraFocus(viewModel.terria, true, centerScratch$1);
          if (!Cesium__namespace.defined(viewCenter) ||
              (scene.mode === 1 /* COLUMBUS_VIEW */ && !sscc.enableLook && !sscc.enableTranslate)) {
              viewModel.rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch$1);
              viewModel.rotateIsLook = true;
          }
          else {
              viewModel.rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(viewCenter, scene.globe.ellipsoid, newTransformScratch$1);
              viewModel.rotateIsLook = false;
          }
      }
      var oldTransform;
      if (Cesium__namespace.defined(viewModel.rotateFrame)) {
          oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch$1);
          camera.lookAtTransform(viewModel.rotateFrame);
      }
      viewModel.rotateInitialCameraAngle = -camera.heading;
      if (Cesium__namespace.defined(viewModel.rotateFrame)) {
          camera.lookAtTransform(oldTransform);
      }
      viewModel.rotateMouseMoveFunction = function (e) {
          var compassRectangle = compassElement.getBoundingClientRect();
          var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
          var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
          var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch$1);
          var angle = Math.atan2(-vector.y, vector.x);
          var angleDifference = angle - viewModel.rotateInitialCursorAngle;
          var newCameraAngle = CesiumMath$1.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);
          var camera = viewModel.terria.scene.camera;
          var oldTransform;
          if (Cesium__namespace.defined(viewModel.rotateFrame)) {
              oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch$1);
              camera.lookAtTransform(viewModel.rotateFrame);
          }
          var currentCameraAngle = -camera.heading;
          camera.rotateRight(newCameraAngle - currentCameraAngle);
          if (Cesium__namespace.defined(viewModel.rotateFrame)) {
              camera.lookAtTransform(oldTransform);
          }
          // viewModel.terria.cesium.notifyRepaintRequired();
      };
      viewModel.rotateMouseUpFunction = function (e) {
          viewModel.isRotating = false;
          document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
          document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
          viewModel.rotateMouseMoveFunction = undefined;
          viewModel.rotateMouseUpFunction = undefined;
      };
      document.addEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
      document.addEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
  }

  // @ts-ignore
  var CesiumEvent$1 = Cesium__namespace.Event;
  /**
   * @alias CesiumNavigationClass
   * @constructor
   * @ignore
   *
   * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
   */
  var CesiumNavigationClass$1 = function (viewerCesiumWidget) {
      initialize$1.apply(this, arguments);
      this._onDestroyListeners = [];
  };
  CesiumNavigationClass$1.prototype.distanceLegendViewModel = undefined;
  CesiumNavigationClass$1.prototype.navigationViewModel = undefined;
  CesiumNavigationClass$1.prototype.navigationDiv = undefined;
  CesiumNavigationClass$1.prototype.distanceLegendDiv = undefined;
  CesiumNavigationClass$1.prototype.terria = undefined;
  CesiumNavigationClass$1.prototype.container = undefined;
  CesiumNavigationClass$1.prototype._onDestroyListeners = undefined;
  CesiumNavigationClass$1.prototype._navigationLocked = false;
  CesiumNavigationClass$1.prototype.setNavigationLocked = function (locked) {
      this._navigationLocked = locked;
      this.navigationViewModel.setNavigationLocked(this._navigationLocked);
  };
  CesiumNavigationClass$1.prototype.getNavigationLocked = function () {
      return this._navigationLocked;
  };
  CesiumNavigationClass$1.prototype.destroy = function () {
      if (Cesium__namespace.defined(this.navigationViewModel)) {
          this.navigationViewModel.destroy();
      }
      if (Cesium__namespace.defined(this.distanceLegendViewModel)) {
          this.distanceLegendViewModel.destroy();
      }
      if (Cesium__namespace.defined(this.navigationDiv)) {
          this.navigationDiv.parentNode.removeChild(this.navigationDiv);
      }
      delete this.navigationDiv;
      if (Cesium__namespace.defined(this.distanceLegendDiv)) {
          this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv);
      }
      delete this.distanceLegendDiv;
      if (Cesium__namespace.defined(this.container)) {
          this.container.parentNode.removeChild(this.container);
      }
      delete this.container;
      for (var i = 0; i < this._onDestroyListeners.length; i++) {
          this._onDestroyListeners[i]();
      }
  };
  CesiumNavigationClass$1.prototype.addOnDestroyListener = function (callback) {
      if (typeof callback === "function") {
          this._onDestroyListeners.push(callback);
      }
  };
  /**
   * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
   * @param options
   * @ignore
   */
  function initialize$1(viewerCesiumWidget, options) {
      if (!Cesium__namespace.defined(viewerCesiumWidget)) {
          throw new Cesium__namespace.DeveloperError("CesiumWidget or Viewer is required.");
      }
      //        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
      var cesiumWidget = Cesium__namespace.defined(viewerCesiumWidget.cesiumWidget)
          ? viewerCesiumWidget.cesiumWidget
          : viewerCesiumWidget;
      var container = document.createElement("div");
      container.className = "cesium-widget-cesiumNavigationContainer";
      cesiumWidget.container.appendChild(container);
      this.terria = viewerCesiumWidget;
      this.terria.options = Cesium__namespace.defined(options) ? options : {};
      this.terria.afterWidgetChanged = new CesiumEvent$1();
      this.terria.beforeWidgetChanged = new CesiumEvent$1();
      this.container = container;
      // this.navigationDiv.setAttribute("id", "navigationDiv");
      // Register custom Knockout.js bindings.  If you're not using the TerriaJS user interface, you can remove this.
      registerKnockoutBindings$1();
      if (!Cesium__namespace.defined(this.terria.options.enableDistanceLegend) || this.terria.options.enableDistanceLegend) {
          this.distanceLegendDiv = document.createElement("div");
          container.appendChild(this.distanceLegendDiv);
          this.distanceLegendDiv.setAttribute("id", "distanceLegendDiv");
          this.distanceLegendViewModel = DistanceLegendViewModel$1.create({
              container: this.distanceLegendDiv,
              terria: this.terria,
              mapElement: container,
              enableDistanceLegend: true
          });
      }
      if ((!Cesium__namespace.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) &&
          (!Cesium__namespace.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel$1.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: true,
              enableCompass: true
          });
      }
      else if (Cesium__namespace.defined(this.terria.options.enableZoomControls) &&
          !this.terria.options.enableZoomControls &&
          (!Cesium__namespace.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel$1.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: false,
              enableCompass: true
          });
      }
      else if ((!Cesium__namespace.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) &&
          Cesium__namespace.defined(this.terria.options.enableCompass) &&
          !this.terria.options.enableCompass) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel$1.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: true,
              enableCompass: false
          });
      }
      else if (Cesium__namespace.defined(this.terria.options.enableZoomControls) &&
          !this.terria.options.enableZoomControls &&
          Cesium__namespace.defined(this.terria.options.enableCompass) &&
          !this.terria.options.enableCompass) ;
  }

  /**
   * 罗盘组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Compass, _super);
      function Compass(options, map) {
          return _super.call(this, __assign$1({ compass: true, scaleLine: true, zoom: true }, options), map) || this;
      }
      /**
       * 初始化
       * @ignore
       */
      Compass.prototype.init = function () {
          this.initialized = true;
          var _a = this.options, compass = _a.compass, scaleLine = _a.scaleLine, zoom = _a.zoom;
          var viewer = this.map.map;
          var defaultOptions = {
              defaultResetView: viewer.scene.camera.position,
              enableCompass: compass,
              enableZoomControls: zoom,
              enableDistanceLegend: scaleLine,
              enableCompassOuterRing: true
          };
          // @ts-ignore
          this._component = new CesiumNavigationClass$1(viewer, __assign$1(__assign$1(__assign$1({}, defaultOptions), this._options), { map: this.map }));
      };
      /**
       * 从地球移除
       * @ignore
       */
      Compass.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._component.destroy();
          this._component = void 0;
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Compass.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Compass;
  })(Component));

  /**
   * 坐标信息组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Coordinate, _super);
      function Coordinate(options, map) {
          return _super.call(this, options, map) || this;
      }
      /**
       * @ignore
       */
      Coordinate.prototype.init = function () {
          var _a = this._options, className = _a.className, text = _a.text, style = _a.style;
          var globe = this.map;
          var template = text || "经度:{longitude}° 纬度:{latitude}°";
          var coordsDom = document.createElement("span");
          var tem = document.createElement("div");
          this._component = tem;
          tem.append(coordsDom);
          tem.classList.add("gis-widget-coordinate");
          className && tem.classList.add(className);
          Object.assign(tem.style, style);
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(globe.map.canvas);
          this._eventHandler.setInputAction(function (mousement) {
              var position = mousement.endPosition || mousement.position;
              var cartesian3 = pickPositionAndObj(globe.map.scene, position, undefined, PickModelEnum.MULTI).cartesian3;
              var cartographic, cartographicPosition;
              if (cartesian3) {
                  cartographic = globe.map.scene.globe.ellipsoid.cartesianToCartographic(cartesian3);
                  cartographicPosition = {
                      height: cartographic.height,
                      latitude: Cesium__namespace.Math.toDegrees(cartographic.latitude),
                      longitude: Cesium__namespace.Math.toDegrees(cartographic.longitude)
                  };
              }
              if (cartographicPosition) {
                  var longitude = cartographicPosition.longitude, latitude = cartographicPosition.latitude, height = cartographicPosition.height;
                  coordsDom.innerText = template
                      .replace(new RegExp("{longitude}", "g"), longitude.toFixed(4))
                      .replace(new RegExp("{latitude}", "g"), latitude.toFixed(4))
                      .replace(new RegExp("{height}", "g"), height.toFixed(2));
              }
          }, 15 /* MOUSE_MOVE */);
          this.initialized = true;
      };
      /**
       * 添加到地球
       * @ignore
       */
      Coordinate.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          globe.map.cesiumWidget.container.append(this._component);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Coordinate.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.cesiumWidget.container.removeChild(this._component);
          // @ts-ignore
          Object.keys(this._eventHandler._inputEvents).forEach(function (key) {
              _this._eventHandler.removeInputAction(Number(key));
          });
          this._eventHandler.destroy();
          this._eventHandler = void 0;
          this.initialized = false;
          this._component = void 0;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Coordinate.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Coordinate;
  })(Component));

  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  // Computes the bounding box of the specified hash of GeoJSON objects.
  function bounds(objects) {
    var x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    function boundGeometry(geometry) {
      if (geometry != null && hasOwnProperty$2.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
    }

    var boundGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },
      Point: function(o) { boundPoint(o.coordinates); },
      MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },
      LineString: function(o) { boundLine(o.arcs); },
      MultiLineString: function(o) { o.arcs.forEach(boundLine); },
      Polygon: function(o) { o.arcs.forEach(boundLine); },
      MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }
    };

    function boundPoint(coordinates) {
      var x = coordinates[0],
          y = coordinates[1];
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    function boundLine(coordinates) {
      coordinates.forEach(boundPoint);
    }

    function boundMultiLine(coordinates) {
      coordinates.forEach(boundLine);
    }

    for (var key in objects) {
      boundGeometry(objects[key]);
    }

    return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;
  }

  function hashset(size, hash, equal, type, empty) {
    if (arguments.length === 3) {
      type = Array;
      empty = null;
    }

    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
        mask = size - 1;

    for (var i = 0; i < size; ++i) {
      store[i] = empty;
    }

    function add(value) {
      var index = hash(value) & mask,
          match = store[index],
          collisions = 0;
      while (match != empty) {
        if (equal(match, value)) return true;
        if (++collisions >= size) throw new Error("full hashset");
        match = store[index = (index + 1) & mask];
      }
      store[index] = value;
      return true;
    }

    function has(value) {
      var index = hash(value) & mask,
          match = store[index],
          collisions = 0;
      while (match != empty) {
        if (equal(match, value)) return true;
        if (++collisions >= size) break;
        match = store[index = (index + 1) & mask];
      }
      return false;
    }

    function values() {
      var values = [];
      for (var i = 0, n = store.length; i < n; ++i) {
        var match = store[i];
        if (match != empty) values.push(match);
      }
      return values;
    }

    return {
      add: add,
      has: has,
      values: values
    };
  }

  function hashmap(size, hash, equal, keyType, keyEmpty, valueType) {
    if (arguments.length === 3) {
      keyType = valueType = Array;
      keyEmpty = null;
    }

    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
        valstore = new valueType(size),
        mask = size - 1;

    for (var i = 0; i < size; ++i) {
      keystore[i] = keyEmpty;
    }

    function set(key, value) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index] = value;
        if (++collisions >= size) throw new Error("full hashmap");
        matchKey = keystore[index = (index + 1) & mask];
      }
      keystore[index] = key;
      valstore[index] = value;
      return value;
    }

    function maybeSet(key, value) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index];
        if (++collisions >= size) throw new Error("full hashmap");
        matchKey = keystore[index = (index + 1) & mask];
      }
      keystore[index] = key;
      valstore[index] = value;
      return value;
    }

    function get(key, missingValue) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index];
        if (++collisions >= size) break;
        matchKey = keystore[index = (index + 1) & mask];
      }
      return missingValue;
    }

    function keys() {
      var keys = [];
      for (var i = 0, n = keystore.length; i < n; ++i) {
        var matchKey = keystore[i];
        if (matchKey != keyEmpty) keys.push(matchKey);
      }
      return keys;
    }

    return {
      set: set,
      maybeSet: maybeSet, // set if unset
      get: get,
      keys: keys
    };
  }

  function equalPoint(pointA, pointB) {
    return pointA[0] === pointB[0] && pointA[1] === pointB[1];
  }

  // TODO if quantized, use simpler Int32 hashing?

  var buffer = new ArrayBuffer(16),
      floats = new Float64Array(buffer),
      uints = new Uint32Array(buffer);

  function hashPoint(point) {
    floats[0] = point[0];
    floats[1] = point[1];
    var hash = uints[0] ^ uints[1];
    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
    return hash & 0x7fffffff;
  }

  // Given an extracted (pre-)topology, identifies all of the junctions. These are
  // the points at which arcs (lines or rings) will need to be cut so that each
  // arc is represented uniquely.
  //
  // A junction is a point where at least one arc deviates from another arc going
  // through the same point. For example, consider the point B. If there is a arc
  // through ABC and another arc through CBA, then B is not a junction because in
  // both cases the adjacent point pairs are {A,C}. However, if there is an
  // additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.
  //
  // For a closed ring ABCA, the first point A’s adjacent points are the second
  // and last point {B,C}. For a line, the first and last point are always
  // considered junctions, even if the line is closed; this ensures that a closed
  // line is never rotated.
  function join(topology) {
    var coordinates = topology.coordinates,
        lines = topology.lines,
        rings = topology.rings,
        indexes = index(),
        visitedByIndex = new Int32Array(coordinates.length),
        leftByIndex = new Int32Array(coordinates.length),
        rightByIndex = new Int32Array(coordinates.length),
        junctionByIndex = new Int8Array(coordinates.length),
        junctionCount = 0, // upper bound on number of junctions
        i, n,
        previousIndex,
        currentIndex,
        nextIndex;

    for (i = 0, n = coordinates.length; i < n; ++i) {
      visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
    }

    for (i = 0, n = lines.length; i < n; ++i) {
      var line = lines[i],
          lineStart = line[0],
          lineEnd = line[1];
      currentIndex = indexes[lineStart];
      nextIndex = indexes[++lineStart];
      ++junctionCount, junctionByIndex[currentIndex] = 1; // start
      while (++lineStart <= lineEnd) {
        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
      }
      ++junctionCount, junctionByIndex[nextIndex] = 1; // end
    }

    for (i = 0, n = coordinates.length; i < n; ++i) {
      visitedByIndex[i] = -1;
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      var ring = rings[i],
          ringStart = ring[0] + 1,
          ringEnd = ring[1];
      previousIndex = indexes[ringEnd - 1];
      currentIndex = indexes[ringStart - 1];
      nextIndex = indexes[ringStart];
      sequence(i, previousIndex, currentIndex, nextIndex);
      while (++ringStart <= ringEnd) {
        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
      }
    }

    function sequence(i, previousIndex, currentIndex, nextIndex) {
      if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
      visitedByIndex[currentIndex] = i;
      var leftIndex = leftByIndex[currentIndex];
      if (leftIndex >= 0) {
        var rightIndex = rightByIndex[currentIndex];
        if ((leftIndex !== previousIndex || rightIndex !== nextIndex)
          && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
          ++junctionCount, junctionByIndex[currentIndex] = 1;
        }
      } else {
        leftByIndex[currentIndex] = previousIndex;
        rightByIndex[currentIndex] = nextIndex;
      }
    }

    function index() {
      var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),
          indexes = new Int32Array(coordinates.length);

      for (var i = 0, n = coordinates.length; i < n; ++i) {
        indexes[i] = indexByPoint.maybeSet(i, i);
      }

      return indexes;
    }

    function hashIndex(i) {
      return hashPoint(coordinates[i]);
    }

    function equalIndex(i, j) {
      return equalPoint(coordinates[i], coordinates[j]);
    }

    visitedByIndex = leftByIndex = rightByIndex = null;

    var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;

    // Convert back to a standard hashset by point for caller convenience.
    for (i = 0, n = coordinates.length; i < n; ++i) {
      if (junctionByIndex[j = indexes[i]]) {
        junctionByPoint.add(coordinates[j]);
      }
    }

    return junctionByPoint;
  }

  // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared
  // point sequences are identified. The topology can then be subsequently deduped
  // to remove exact duplicate arcs.
  function cut(topology) {
    var junctions = join(topology),
        coordinates = topology.coordinates,
        lines = topology.lines,
        rings = topology.rings,
        next,
        i, n;

    for (i = 0, n = lines.length; i < n; ++i) {
      var line = lines[i],
          lineMid = line[0],
          lineEnd = line[1];
      while (++lineMid < lineEnd) {
        if (junctions.has(coordinates[lineMid])) {
          next = {0: lineMid, 1: line[1]};
          line[1] = lineMid;
          line = line.next = next;
        }
      }
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      var ring = rings[i],
          ringStart = ring[0],
          ringMid = ringStart,
          ringEnd = ring[1],
          ringFixed = junctions.has(coordinates[ringStart]);
      while (++ringMid < ringEnd) {
        if (junctions.has(coordinates[ringMid])) {
          if (ringFixed) {
            next = {0: ringMid, 1: ring[1]};
            ring[1] = ringMid;
            ring = ring.next = next;
          } else { // For the first junction, we can rotate rather than cut.
            rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
            coordinates[ringEnd] = coordinates[ringStart];
            ringFixed = true;
            ringMid = ringStart; // restart; we may have skipped junctions
          }
        }
      }
    }

    return topology;
  }

  function rotateArray(array, start, end, offset) {
    reverse$1(array, start, end);
    reverse$1(array, start, start + offset);
    reverse$1(array, start + offset, end);
  }

  function reverse$1(array, start, end) {
    for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {
      t = array[start], array[start] = array[end], array[end] = t;
    }
  }

  // Given a cut topology, combines duplicate arcs.
  function dedup(topology) {
    var coordinates = topology.coordinates,
        lines = topology.lines, line,
        rings = topology.rings, ring,
        arcCount = lines.length + rings.length,
        i, n;

    delete topology.lines;
    delete topology.rings;

    // Count the number of (non-unique) arcs to initialize the hashmap safely.
    for (i = 0, n = lines.length; i < n; ++i) {
      line = lines[i]; while (line = line.next) ++arcCount;
    }
    for (i = 0, n = rings.length; i < n; ++i) {
      ring = rings[i]; while (ring = ring.next) ++arcCount;
    }

    var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),
        arcs = topology.arcs = [];

    for (i = 0, n = lines.length; i < n; ++i) {
      line = lines[i];
      do {
        dedupLine(line);
      } while (line = line.next);
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      ring = rings[i];
      if (ring.next) { // arc is no longer closed
        do {
          dedupLine(ring);
        } while (ring = ring.next);
      } else {
        dedupRing(ring);
      }
    }

    function dedupLine(arc) {
      var startPoint,
          endPoint,
          startArcs, startArc,
          endArcs, endArc,
          i, n;

      // Does this arc match an existing arc in order?
      if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
        for (i = 0, n = startArcs.length; i < n; ++i) {
          startArc = startArcs[i];
          if (equalLine(startArc, arc)) {
            arc[0] = startArc[0];
            arc[1] = startArc[1];
            return;
          }
        }
      }

      // Does this arc match an existing arc in reverse order?
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (reverseEqualLine(endArc, arc)) {
            arc[1] = endArc[0];
            arc[0] = endArc[1];
            return;
          }
        }
      }

      if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);
      if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
      arcs.push(arc);
    }

    function dedupRing(arc) {
      var endPoint,
          endArcs,
          endArc,
          i, n;

      // Does this arc match an existing line in order, or reverse order?
      // Rings are closed, so their start point and end point is the same.
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (equalRing(endArc, arc)) {
            arc[0] = endArc[0];
            arc[1] = endArc[1];
            return;
          }
          if (reverseEqualRing(endArc, arc)) {
            arc[0] = endArc[1];
            arc[1] = endArc[0];
            return;
          }
        }
      }

      // Otherwise, does this arc match an existing ring in order, or reverse order?
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (equalRing(endArc, arc)) {
            arc[0] = endArc[0];
            arc[1] = endArc[1];
            return;
          }
          if (reverseEqualRing(endArc, arc)) {
            arc[0] = endArc[1];
            arc[1] = endArc[0];
            return;
          }
        }
      }

      if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
      arcs.push(arc);
    }

    function equalLine(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1];
      if (ia - ja !== ib - jb) return false;
      for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;
      return true;
    }

    function reverseEqualLine(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1];
      if (ia - ja !== ib - jb) return false;
      for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;
      return true;
    }

    function equalRing(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1],
          n = ja - ia;
      if (n !== jb - ib) return false;
      var ka = findMinimumOffset(arcA),
          kb = findMinimumOffset(arcB);
      for (var i = 0; i < n; ++i) {
        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
      }
      return true;
    }

    function reverseEqualRing(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1],
          n = ja - ia;
      if (n !== jb - ib) return false;
      var ka = findMinimumOffset(arcA),
          kb = n - findMinimumOffset(arcB);
      for (var i = 0; i < n; ++i) {
        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
      }
      return true;
    }

    // Rings are rotated to a consistent, but arbitrary, start point.
    // This is necessary to detect when a ring and a rotated copy are dupes.
    function findMinimumOffset(arc) {
      var start = arc[0],
          end = arc[1],
          mid = start,
          minimum = mid,
          minimumPoint = coordinates[mid];
      while (++mid < end) {
        var point = coordinates[mid];
        if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
          minimum = mid;
          minimumPoint = point;
        }
      }
      return minimum - start;
    }

    return topology;
  }

  // Given an array of arcs in absolute (but already quantized!) coordinates,
  // converts to fixed-point delta encoding.
  // This is a destructive operation that modifies the given arcs!
  function delta(arcs) {
    var i = -1,
        n = arcs.length;

    while (++i < n) {
      var arc = arcs[i],
          j = 0,
          k = 1,
          m = arc.length,
          point = arc[0],
          x0 = point[0],
          y0 = point[1],
          x1,
          y1;

      while (++j < m) {
        point = arc[j], x1 = point[0], y1 = point[1];
        if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
      }

      if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.

      arc.length = k;
    }

    return arcs;
  }

  // Extracts the lines and rings from the specified hash of geometry objects.
  //
  // Returns an object with three properties:
  //
  // * coordinates - shared buffer of [x, y] coordinates
  // * lines - lines extracted from the hash, of the form [start, end]
  // * rings - rings extracted from the hash, of the form [start, end]
  //
  // For each ring or line, start and end represent inclusive indexes into the
  // coordinates buffer. For rings (and closed lines), coordinates[start] equals
  // coordinates[end].
  //
  // For each line or polygon geometry in the input hash, including nested
  // geometries as in geometry collections, the `coordinates` array is replaced
  // with an equivalent `arcs` array that, for each line (for line string
  // geometries) or ring (for polygon geometries), points to one of the above
  // lines or rings.
  function extract(objects) {
    var index = -1,
        lines = [],
        rings = [],
        coordinates = [];

    function extractGeometry(geometry) {
      if (geometry && hasOwnProperty$2.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
    }

    var extractGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },
      LineString: function(o) { o.arcs = extractLine(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },
      Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }
    };

    function extractLine(line) {
      for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
      var arc = {0: index - n + 1, 1: index};
      lines.push(arc);
      return arc;
    }

    function extractRing(ring) {
      for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
      var arc = {0: index - n + 1, 1: index};
      rings.push(arc);
      return arc;
    }

    function extractMultiRing(rings) {
      return rings.map(extractRing);
    }

    for (var key in objects) {
      extractGeometry(objects[key]);
    }

    return {
      type: "Topology",
      coordinates: coordinates,
      lines: lines,
      rings: rings,
      objects: objects
    };
  }

  // Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
  // Any null input geometry objects are represented as {type: null} in the output.
  // Any feature.{id,properties,bbox} are transferred to the output geometry object.
  // Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
  function geometry(inputs) {
    var outputs = {}, key;
    for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
    return outputs;
  }

  function geomifyObject(input) {
    return input == null ? {type: null}
        : (input.type === "FeatureCollection" ? geomifyFeatureCollection
        : input.type === "Feature" ? geomifyFeature
        : geomifyGeometry)(input);
  }

  function geomifyFeatureCollection(input) {
    var output = {type: "GeometryCollection", geometries: input.features.map(geomifyFeature)};
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  function geomifyFeature(input) {
    var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    for (key in input.properties) { output.properties = input.properties; break; }
    return output;
  }

  function geomifyGeometry(input) {
    if (input == null) return {type: null};
    var output = input.type === "GeometryCollection" ? {type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry)}
        : input.type === "Point" || input.type === "MultiPoint" ? {type: input.type, coordinates: input.coordinates}
        : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  function prequantize(objects, bbox, n) {
    var x0 = bbox[0],
        y0 = bbox[1],
        x1 = bbox[2],
        y1 = bbox[3],
        kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,
        ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;

    function quantizePoint(input) {
      return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
    }

    function quantizePoints(input, m) {
      var i = -1,
          j = 0,
          n = input.length,
          output = new Array(n), // pessimistic
          pi,
          px,
          py,
          x,
          y;

      while (++i < n) {
        pi = input[i];
        x = Math.round((pi[0] - x0) * kx);
        y = Math.round((pi[1] - y0) * ky);
        if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points
      }

      output.length = j;
      while (j < m) j = output.push([output[0][0], output[0][1]]);
      return output;
    }

    function quantizeLine(input) {
      return quantizePoints(input, 2);
    }

    function quantizeRing(input) {
      return quantizePoints(input, 4);
    }

    function quantizePolygon(input) {
      return input.map(quantizeRing);
    }

    function quantizeGeometry(o) {
      if (o != null && hasOwnProperty$2.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
    }

    var quantizeGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },
      Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },
      MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },
      LineString: function(o) { o.arcs = quantizeLine(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },
      Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }
    };

    for (var key in objects) {
      quantizeGeometry(objects[key]);
    }

    return {
      scale: [1 / kx, 1 / ky],
      translate: [x0, y0]
    };
  }

  // Constructs the TopoJSON Topology for the specified hash of features.
  // Each object in the specified hash must be a GeoJSON object,
  // meaning FeatureCollection, a Feature or a geometry object.
  function topology(objects, quantization) {
    var bbox = bounds(objects = geometry(objects)),
        transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),
        topology = dedup(cut(extract(objects))),
        coordinates = topology.coordinates,
        indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);

    objects = topology.objects; // for garbage collection
    topology.bbox = bbox;
    topology.arcs = topology.arcs.map(function(arc, i) {
      indexByArc.set(arc, i);
      return coordinates.slice(arc[0], arc[1] + 1);
    });

    delete topology.coordinates;
    coordinates = null;

    function indexGeometry(geometry) {
      if (geometry && hasOwnProperty$2.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
    }

    var indexGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },
      LineString: function(o) { o.arcs = indexArcs(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },
      Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }
    };

    function indexArcs(arc) {
      var indexes = [];
      do {
        var index = indexByArc.get(arc);
        indexes.push(arc[0] < arc[1] ? index : ~index);
      } while (arc = arc.next);
      return indexes;
    }

    function indexMultiArcs(arcs) {
      return arcs.map(indexArcs);
    }

    for (var key in objects) {
      indexGeometry(objects[key]);
    }

    if (transform) {
      topology.transform = transform;
      topology.arcs = delta(topology.arcs);
    }

    return topology;
  }

  function hashArc(arc) {
    var i = arc[0], j = arc[1], t;
    if (j < i) t = i, i = j, j = t;
    return i + 31 * j;
  }

  function equalArc(arcA, arcB) {
    var ia = arcA[0], ja = arcA[1],
        ib = arcB[0], jb = arcB[1], t;
    if (ja < ia) t = ia, ia = ja, ja = t;
    if (jb < ib) t = ib, ib = jb, jb = t;
    return ia === ib && ja === jb;
  }

  var src$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    topology: topology
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(src$1);

  function identity(x) {
    return x;
  }

  function transform$2(transform) {
    if (transform == null) return identity;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2, n = input.length, output = new Array(n);
      output[0] = (x0 += input[0]) * kx + dx;
      output[1] = (y0 += input[1]) * ky + dy;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function bbox(topology) {
    var t = transform$2(topology.transform), key,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    function bboxPoint(p) {
      p = t(p);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }

    function bboxGeometry(o) {
      switch (o.type) {
        case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
        case "Point": bboxPoint(o.coordinates); break;
        case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
      }
    }

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length, p;
      while (++i < n) {
        p = t(arc[i], i);
        if (p[0] < x0) x0 = p[0];
        if (p[0] > x1) x1 = p[0];
        if (p[1] < y0) y0 = p[1];
        if (p[1] > y1) y1 = p[1];
      }
    });

    for (key in topology.objects) {
      bboxGeometry(topology.objects[key]);
    }

    return [x0, y0, x1, y1];
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n;
    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function feature(topology, o) {
    if (typeof o === "string") o = topology.objects[o];
    return o.type === "GeometryCollection"
        ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
        : feature$1(topology, o);
  }

  function feature$1(topology, o) {
    var id = o.id,
        bbox = o.bbox,
        properties = o.properties == null ? {} : o.properties,
        geometry = object(topology, o);
    return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
        : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
        : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
  }

  function object(topology, o) {
    var transformPoint = transform$2(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
        points.push(transformPoint(a[k], k));
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      return transformPoint(p);
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var type = o.type, coordinates;
      switch (type) {
        case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
        case "Point": coordinates = point(o.coordinates); break;
        case "MultiPoint": coordinates = o.coordinates.map(point); break;
        case "LineString": coordinates = line(o.arcs); break;
        case "MultiLineString": coordinates = o.arcs.map(line); break;
        case "Polygon": coordinates = polygon(o.arcs); break;
        case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
        default: return null;
      }
      return {type: type, coordinates: coordinates};
    }

    return geometry(o);
  }

  function stitch(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function mesh(topology) {
    return object(topology, meshArcs.apply(this, arguments));
  }

  function meshArcs(topology, object, filter) {
    var arcs, i, n;
    if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
    else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
    return {type: "MultiLineString", arcs: stitch(topology, arcs)};
  }

  function extractArcs(topology, object, filter) {
    var arcs = [],
        geomsByArc = [],
        geom;

    function extract0(i) {
      var j = i < 0 ? ~i : i;
      (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
    }

    function extract1(arcs) {
      arcs.forEach(extract0);
    }

    function extract2(arcs) {
      arcs.forEach(extract1);
    }

    function extract3(arcs) {
      arcs.forEach(extract2);
    }

    function geometry(o) {
      switch (geom = o, o.type) {
        case "GeometryCollection": o.geometries.forEach(geometry); break;
        case "LineString": extract1(o.arcs); break;
        case "MultiLineString": case "Polygon": extract2(o.arcs); break;
        case "MultiPolygon": extract3(o.arcs); break;
      }
    }

    geometry(object);

    geomsByArc.forEach(filter == null
        ? function(geoms) { arcs.push(geoms[0].i); }
        : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

    return arcs;
  }

  function planarRingArea(ring) {
    var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
    while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
    return Math.abs(area); // Note: doubled area!
  }

  function merge(topology) {
    return object(topology, mergeArcs.apply(this, arguments));
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        groups = [];

    objects.forEach(geometry);

    function geometry(o) {
      switch (o.type) {
        case "GeometryCollection": o.geometries.forEach(geometry); break;
        case "Polygon": extract(o.arcs); break;
        case "MultiPolygon": o.arcs.forEach(extract); break;
      }
    }

    function extract(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function area(ring) {
      return planarRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var group = [],
            neighbors = [polygon];
        polygon._ = 1;
        groups.push(group);
        while (polygon = neighbors.pop()) {
          group.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: groups.map(function(polygons) {
        var arcs = [], n;

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitch(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // choose the one with the greatest absolute area.
        if ((n = arcs.length) > 1) {
          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
            if ((ki = area(arcs[i])) > k) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
            }
          }
        }

        return arcs;
      }).filter(function(arcs) {
        return arcs.length > 0;
      })
    };
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function untransform(transform) {
    if (transform == null) return identity;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2,
          n = input.length,
          output = new Array(n),
          x1 = Math.round((input[0] - dx) / kx),
          y1 = Math.round((input[1] - dy) / ky);
      output[0] = x1 - x0, x0 = x1;
      output[1] = y1 - y0, y0 = y1;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function quantize(topology, transform) {
    if (topology.transform) throw new Error("already quantized");

    if (!transform || !transform.scale) {
      if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
      box = topology.bbox || bbox(topology);
      var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
      transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
    } else {
      box = topology.bbox;
    }

    var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};

    function quantizePoint(point) {
      return t(point);
    }

    function quantizeGeometry(input) {
      var output;
      switch (input.type) {
        case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
        case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
        case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
        default: return input;
      }
      if (input.id != null) output.id = input.id;
      if (input.bbox != null) output.bbox = input.bbox;
      if (input.properties != null) output.properties = input.properties;
      return output;
    }

    function quantizeArc(input) {
      var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
      output[0] = t(input[0], 0);
      while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
      if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
      output.length = j;
      return output;
    }

    for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

    return {
      type: "Topology",
      bbox: box,
      transform: transform,
      objects: outputs,
      arcs: topology.arcs.map(quantizeArc)
    };
  }

  var src = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bbox: bbox,
    feature: feature,
    mesh: mesh,
    meshArcs: meshArcs,
    merge: merge,
    mergeArcs: mergeArcs,
    neighbors: neighbors,
    quantize: quantize,
    transform: transform$2,
    untransform: untransform
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(src);

  var geojsonLinestringDissolve = mergeViableLineStrings;

  // [Number, Number] -> String
  function coordId (coord) {
    return coord[0].toString() + ',' + coord[1].toString()
  }

  // LineString, LineString -> LineString
  function mergeLineStrings (a, b) {
    var s1 = coordId(a.coordinates[0]);
    var e1 = coordId(a.coordinates[a.coordinates.length - 1]);
    var s2 = coordId(b.coordinates[0]);
    var e2 = coordId(b.coordinates[b.coordinates.length - 1]);

    // TODO: handle case where more than one of these is true!

    var coords;
    if (s1 === e2) {
      coords = b.coordinates.concat(a.coordinates.slice(1));
    } else if (s2 === e1) {
      coords = a.coordinates.concat(b.coordinates.slice(1));
    } else if (s1 === s2) {
      coords = a.coordinates.slice(1).reverse().concat(b.coordinates);
    } else if (e1 === e2) {
      coords = a.coordinates.concat(b.coordinates.reverse().slice(1));
    } else {
      return null
    }

    return {
      type: 'LineString',
      coordinates: coords
    }
  }

  // Merges all connected (non-forking, non-junctioning) line strings into single
  // line strings.
  // [LineString] -> LineString|MultiLineString
  function mergeViableLineStrings (geoms) {
    // TODO: assert all are linestrings

    var lineStrings = geoms.slice();
    var result = [];
    while (lineStrings.length > 0) {
      var ls = lineStrings.shift();

      // Attempt to merge this LineString with the other LineStrings, updating
      // the reference as it is merged with others and grows.
      lineStrings = lineStrings.reduce(function (accum, cur) {
        var merged = mergeLineStrings(ls, cur);
        if (merged) {
          // Accumulate the merged LineString
          ls = merged;
        } else {
          // Put the unmerged LineString back into the list
          accum.push(cur);
        }
        return accum
      }, []);

      result.push(ls);
    }

    if (result.length === 1) {
      result = result[0];
    } else {
      result = {
        type: 'MultiLineString',
        coordinates: result.map(function (ls) { return ls.coordinates })
      };
    }
    return result
  }

  var meta = {};

  /**
   * Callback for coordEach
   *
   * @private
   * @callback coordEachCallback
   * @param {[number, number]} currentCoords The current coordinates being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
   *
   * @name coordEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentCoords, currentIndex)
   * @param {boolean} [excludeWrapCoord=false] whether or not to include
   * the final coordinate of LinearRings that wraps the ring in its iteration.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.coordEach(features, function (currentCoords, currentIndex) {
   *   //=currentCoords
   *   //=currentIndex
   * });
   */
  function coordEach(layer, callback, excludeWrapCoord) {
      var i, j, k, g, l, geometry, stopG, coords,
          geometryMaybeCollection,
          wrapShrink = 0,
          currentIndex = 0,
          isGeometryCollection,
          isFeatureCollection = layer.type === 'FeatureCollection',
          isFeature = layer.type === 'Feature',
          stop = isFeatureCollection ? layer.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
      for (i = 0; i < stop; i++) {

          geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
          (isFeature ? layer.geometry : layer));
          isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (g = 0; g < stopG; g++) {
              geometry = isGeometryCollection ?
              geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
              coords = geometry.coordinates;

              wrapShrink = (excludeWrapCoord &&
                  (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                  1 : 0;

              if (geometry.type === 'Point') {
                  callback(coords, currentIndex);
                  currentIndex++;
              } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                  for (j = 0; j < coords.length; j++) {
                      callback(coords[j], currentIndex);
                      currentIndex++;
                  }
              } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                  for (j = 0; j < coords.length; j++)
                      for (k = 0; k < coords[j].length - wrapShrink; k++) {
                          callback(coords[j][k], currentIndex);
                          currentIndex++;
                      }
              } else if (geometry.type === 'MultiPolygon') {
                  for (j = 0; j < coords.length; j++)
                      for (k = 0; k < coords[j].length; k++)
                          for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                              callback(coords[j][k][l], currentIndex);
                              currentIndex++;
                          }
              } else if (geometry.type === 'GeometryCollection') {
                  for (j = 0; j < geometry.geometries.length; j++)
                      coordEach(geometry.geometries[j], callback, excludeWrapCoord);
              } else {
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }
  meta.coordEach = coordEach;

  /**
   * Callback for coordReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback coordReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {[number, number]} currentCoords The current coordinate being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
   *
   * @name coordReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @param {boolean} [excludeWrapCoord=false] whether or not to include
   * the final coordinate of LinearRings that wraps the ring in its iteration.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {
   *   //=previousValue
   *   //=currentCoords
   *   //=currentIndex
   *   return currentCoords;
   * });
   */
  function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(layer, function (currentCoords, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentCoords;
          } else {
              previousValue = callback(previousValue, currentCoords, currentIndex);
          }
      }, excludeWrapCoord);
      return previousValue;
  }
  meta.coordReduce = coordReduce;

  /**
   * Callback for propEach
   *
   * @private
   * @callback propEachCallback
   * @param {*} currentProperties The current properties being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over properties in any GeoJSON object, similar to Array.forEach()
   *
   * @name propEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentProperties, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.propEach(features, function (currentProperties, currentIndex) {
   *   //=currentProperties
   *   //=currentIndex
   * });
   */
  function propEach(layer, callback) {
      var i;
      switch (layer.type) {
      case 'FeatureCollection':
          for (i = 0; i < layer.features.length; i++) {
              callback(layer.features[i].properties, i);
          }
          break;
      case 'Feature':
          callback(layer.properties, 0);
          break;
      }
  }
  meta.propEach = propEach;


  /**
   * Callback for propReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback propReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {*} currentProperties The current properties being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce properties in any GeoJSON object into a single value,
   * similar to how Array.reduce works. However, in this case we lazily run
   * the reduction, so an array of all properties is unnecessary.
   *
   * @name propReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {
   *   //=previousValue
   *   //=currentProperties
   *   //=currentIndex
   *   return currentProperties
   * });
   */
  function propReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      propEach(layer, function (currentProperties, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentProperties;
          } else {
              previousValue = callback(previousValue, currentProperties, currentIndex);
          }
      });
      return previousValue;
  }
  meta.propReduce = propReduce;

  /**
   * Callback for featureEach
   *
   * @private
   * @callback featureEachCallback
   * @param {Feature<any>} currentFeature The current feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over features in any GeoJSON object, similar to
   * Array.forEach.
   *
   * @name featureEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentFeature, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.featureEach(features, function (currentFeature, currentIndex) {
   *   //=currentFeature
   *   //=currentIndex
   * });
   */
  function featureEach(layer, callback) {
      if (layer.type === 'Feature') {
          callback(layer, 0);
      } else if (layer.type === 'FeatureCollection') {
          for (var i = 0; i < layer.features.length; i++) {
              callback(layer.features[i], i);
          }
      }
  }
  meta.featureEach = featureEach;

  /**
   * Callback for featureReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback featureReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {Feature<any>} currentFeature The current Feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce features in any GeoJSON object, similar to Array.reduce().
   *
   * @name featureReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {
   *   //=previousValue
   *   //=currentFeature
   *   //=currentIndex
   *   return currentFeature
   * });
   */
  function featureReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      featureEach(layer, function (currentFeature, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentFeature;
          } else {
              previousValue = callback(previousValue, currentFeature, currentIndex);
          }
      });
      return previousValue;
  }
  meta.featureReduce = featureReduce;

  /**
   * Get all coordinates from any GeoJSON object.
   *
   * @name coordAll
   * @param {Object} layer any GeoJSON object
   * @returns {Array<Array<number>>} coordinate position array
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * var coords = turf.coordAll(features);
   * //=coords
   */
  function coordAll(layer) {
      var coords = [];
      coordEach(layer, function (coord) {
          coords.push(coord);
      });
      return coords;
  }
  meta.coordAll = coordAll;

  /**
   * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
   *
   * @name geomEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentGeometry, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.geomEach(features, function (currentGeometry, currentIndex) {
   *   //=currentGeometry
   *   //=currentIndex
   * });
   */
  function geomEach$1(layer, callback) {
      var i, j, g, geometry, stopG,
          geometryMaybeCollection,
          isGeometryCollection,
          currentIndex = 0,
          isFeatureCollection = layer.type === 'FeatureCollection',
          isFeature = layer.type === 'Feature',
          stop = isFeatureCollection ? layer.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
      for (i = 0; i < stop; i++) {

          geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
          (isFeature ? layer.geometry : layer));
          isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (g = 0; g < stopG; g++) {
              geometry = isGeometryCollection ?
              geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

              if (geometry.type === 'Point' ||
                  geometry.type === 'LineString' ||
                  geometry.type === 'MultiPoint' ||
                  geometry.type === 'Polygon' ||
                  geometry.type === 'MultiLineString' ||
                  geometry.type === 'MultiPolygon') {
                  callback(geometry, currentIndex);
                  currentIndex++;
              } else if (geometry.type === 'GeometryCollection') {
                  for (j = 0; j < geometry.geometries.length; j++) {
                      callback(geometry.geometries[j], currentIndex);
                      currentIndex++;
                  }
              } else {
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }
  meta.geomEach = geomEach$1;

  /**
   * Callback for geomReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback geomReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {*} currentGeometry The current Feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce geometry in any GeoJSON object, similar to Array.reduce().
   *
   * @name geomReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {
   *   //=previousValue
   *   //=currentGeometry
   *   //=currentIndex
   *   return currentGeometry
   * });
   */
  function geomReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      geomEach$1(layer, function (currentGeometry, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentGeometry;
          } else {
              previousValue = callback(previousValue, currentGeometry, currentIndex);
          }
      });
      return previousValue;
  }
  meta.geomReduce = geomReduce;

  var dist=function e(t){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.reduce(function(t,r){return t.concat(e(r))},[]),t;case"Feature":return t.geometry?e(t.geometry).map(function(e){var r={type:"Feature",properties:JSON.parse(JSON.stringify(t.properties)),geometry:e};return void 0!==t.id&&(r.id=t.id),r}):t;case"MultiPoint":return t.coordinates.map(function(e){return {type:"Point",coordinates:e}});case"MultiPolygon":return t.coordinates.map(function(e){return {type:"Polygon",coordinates:e}});case"MultiLineString":return t.coordinates.map(function(e){return {type:"LineString",coordinates:e}});case"GeometryCollection":return t.geometries.map(e).reduce(function(e,t){return e.concat(t)},[]);case"Point":case"Polygon":case"LineString":return [t]}};

  var createTopology = require$$0.topology;
  var mergeTopology = require$$1.merge;
  var dissolveLineStrings = geojsonLinestringDissolve;
  var geomEach = meta.geomEach;
  var flatten = dist;

  var geojsonDissolve = dissolve;

  function toArray (args) {
    if (!args.length) return []
    return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)
  }

  function dissolvePolygons (geoms) {
    // Topojson modifies in place, so we need to deep clone first
    var objects = {
      geoms: {
        type: 'GeometryCollection',
        geometries: JSON.parse(JSON.stringify(geoms))
      }
    };
    var topo = createTopology(objects);
    return mergeTopology(topo, topo.objects.geoms.geometries)
  }

  // [GeoJSON] -> String|Null
  function getHomogenousType (geoms) {
    var type = null;
    for (var i = 0; i < geoms.length; i++) {
      if (!type) {
        type = geoms[i].type;
      } else if (type !== geoms[i].type) {
        return null
      }
    }
    return type
  }

  // Transform function: attempts to dissolve geojson objects where possible
  // [GeoJSON] -> GeoJSON geometry
  function dissolve () {
    // accept an array of geojson objects, or an argument list
    var objects = toArray(arguments);
    var geoms = objects.reduce(function (acc, o) {
      // flatten any Multi-geom into features of simple types
      var flat = flatten(o);
      if (!Array.isArray(flat)) flat = [flat];
      for (var i = 0; i < flat.length; i++) {
        // get an array of all flatten geometry objects
        geomEach(flat[i], function (geom) {
          acc.push(geom);
        });
      }
      return acc
    }, []);
    // Assert homogenity
    var type = getHomogenousType(geoms);
    if (!type) {
      throw new Error('List does not contain only homoegenous GeoJSON')
    }

    switch (type) {
      case 'LineString':
        return dissolveLineStrings(geoms)
      case 'Polygon':
        return dissolvePolygons(geoms)
      default:
        return geoms
    }
  }

  /**
   * 区域面组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Area, _super);
      function Area(options, map) {
          return _super.call(this, __assign$1({ contentStyle: AREA_STYLE.contentStyle, outlineStyle: AREA_STYLE.outlineStyle, contentOutlineStyle: AREA_STYLE.contentOutlineStyle, contentLabelStyle: AREA_STYLE.contentLabelStyle, topOutline: true, bottomOutline: false, contentOutline: true, contentLabel: true, visible: true }, options), map) || this;
      }
      Object.defineProperty(Area.prototype, "visible", {
          /**
           * 组件显隐状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Area.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化
       * @ignore
       */
      Area.prototype.init = function () {
          var _this = this;
          var _a;
          this.initialized = true;
          var _b = this.options, contentStyle = _b.contentStyle, outlineStyle = _b.outlineStyle, contentOutlineStyle = _b.contentOutlineStyle, contentLabelStyle = _b.contentLabelStyle, topOutline = _b.topOutline, bottomOutline = _b.bottomOutline, contentOutline = _b.contentOutline, contentLabel = _b.contentLabel, visible = _b.visible;
          if (!defined$1(this._visible)) {
              this._visible = visible;
          }
          var data = this.options.data;
          if ((data === null || data === void 0 ? void 0 : data.type) !== "FeatureCollection" || ((_a = data.features) === null || _a === void 0 ? void 0 : _a.length) === 0) {
              throw new Error("GeoJSON格式错误或内容为空");
          }
          data = JSON.parse(JSON.stringify(data));
          var contentFeatureList = read$1(data);
          var mergePolygon;
          this._contentVectorLayer = new VectorLayer({
              id: this.id + "-content-vector-layer",
              data: contentFeatureList,
              style: contentStyle,
              visible: this._visible
          });
          this._contentFeatureList = this._contentVectorLayer.features;
          this._outlineVectorLayer = new VectorLayer({
              id: this.id + "-outline-vector-layer",
              style: outlineStyle,
              visible: this._visible
          });
          this._contentOutlineVectorLayer = new VectorLayer({
              id: this.id + "-content-outline-vector-layer",
              style: contentOutlineStyle,
              visible: this._visible
          });
          this._labelContentVectorLayer = new VectorLayer({
              id: this.id + "-label-content-vector-layer",
              style: contentLabelStyle,
              visible: this._visible
          });
          this._contentVectorLayer.on([
              BaseEventType.MOUSE_DOWN,
              BaseEventType.MOUSE_UP,
              BaseEventType.CLICK,
              BaseEventType.RIGHT_CLICK,
              BaseEventType.DOUBLE_CLICK,
              BaseEventType.MOUSE_MOVE
          ], function (e) {
              var coordinate = e.coordinate, pixel = e.pixel, map = e.map;
              var feature;
              if (e.features.length === 1 && _this._contentFeatureList.includes(e.features[0])) {
                  feature = e.features[0];
              }
              else if (e.features[0] instanceof Point$1) {
                  //@ts-ignore
                  feature = e.features[0].contentFeature;
              }
              _this.dispatchEvent({
                  type: e.type,
                  feature: feature,
                  coordinate: coordinate,
                  pixel: pixel,
                  map: map
              });
          });
          this._contentLabelFeatureList = [];
          var topExtrudedHeight = void 0;
          this._contentOutlineFeatureList = contentFeatureList.map(function (feature) {
              var _a;
              var extrudedHeight = ((_a = ((feature.style || feature._layerStyle))) === null || _a === void 0 ? void 0 : _a.reduce(function (previousVal, currentVal) {
                  return previousVal > (currentVal.extrudedHeight || 0) ? previousVal : currentVal.extrudedHeight || 0;
              }, 0)) || 0;
              topExtrudedHeight === void 0 && (topExtrudedHeight = extrudedHeight);
              topExtrudedHeight < extrudedHeight && (topExtrudedHeight = extrudedHeight);
              var temFeature = new Polyline$1({
                  coordinates: polygonToPolyline$1(feature.geoJson.geometry, extrudedHeight)
                      .coordinates,
                  properties: __assign$1({}, feature.properties)
              });
              contentOutline && _this._contentOutlineVectorLayer.addFeature(temFeature);
              var labelPoint = feature.properties.center
                  ? feature.properties.center
                  : Turf__namespace.centerOfMass(feature.geoJson.geometry, {
                      properties: __assign$1({}, feature.properties)
                  }).geometry.coordinates;
              var labelFeature = new Point$1({
                  coordinates: labelPoint.length > 2 ? labelPoint : [labelPoint[0], labelPoint[1], extrudedHeight],
                  properties: __assign$1({}, feature.properties)
              });
              //@ts-ignore
              labelFeature.contentFeature = feature;
              contentLabel && _this._labelContentVectorLayer.addFeature(labelFeature);
              _this._contentLabelFeatureList.push(labelFeature);
              return temFeature;
          });
          if (bottomOutline) {
              mergePolygon || (mergePolygon = geojsonDissolve(data));
              var outlineBottomGeoJSON = polygonToPolyline$1(mergePolygon, 0);
              var outlineBottomFeature = new Polyline$1({
                  coordinates: outlineBottomGeoJSON.coordinates
              });
              this._outlineBottomFeature = outlineBottomFeature;
              this._outlineVectorLayer.addFeature(outlineBottomFeature);
          }
          if (topOutline) {
              mergePolygon || (mergePolygon = geojsonDissolve(data));
              var outlineTopGeoJSON = polygonToPolyline$1(mergePolygon, topExtrudedHeight);
              var outlineTopFeature = new Polyline$1({
                  coordinates: outlineTopGeoJSON.coordinates
              });
              this._outlineTopFeature = outlineTopFeature;
              this._outlineVectorLayer.addFeature(outlineTopFeature);
          }
      };
      /**
       * @ignore
       */
      Area.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this._contentVectorLayer.addTo(globe);
          this._outlineVectorLayer.addTo(globe);
          this._contentOutlineVectorLayer.addTo(globe);
          this._labelContentVectorLayer.addTo(globe);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Area.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._contentVectorLayer.remove();
          this._contentOutlineVectorLayer.remove();
          this._outlineVectorLayer.remove();
          this._labelContentVectorLayer.remove();
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Area.prototype._destroy = function () {
          this.remove();
          this._contentVectorLayer.destroy();
          this._contentOutlineVectorLayer.destroy();
          this._outlineVectorLayer.destroy();
          this._labelContentVectorLayer.destroy();
          this._contentVectorLayer =
              this._contentOutlineVectorLayer =
                  this._outlineVectorLayer =
                      this._labelContentVectorLayer =
                          this._outlineTopFeature =
                              this._outlineBottomFeature =
                                  this._contentFeatureList =
                                      this._contentLabelFeatureList =
                                          this._contentOutlineFeatureList =
                                              void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示行政区划
       */
      Area.prototype.show = function () {
          var _a, _b, _c, _d;
          if (this.visible) {
              return;
          }
          this._visible = true;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.show();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.show();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.show();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.show();
          return this;
      };
      /**
       * 隐藏行政区划
       */
      Area.prototype.hide = function () {
          var _a, _b, _c, _d;
          if (this.visible === false) {
              return;
          }
          this._visible = false;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.hide();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.hide();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.hide();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.hide();
          return this;
      };
      return Area;
  })(Component));
  function polygonToPolyline$1(geojson, height) {
      if (height === void 0) { height = 0; }
      if (geojson.type === GeoJsonType.FEATURE) {
          return feature$3(polygonToPolyline$1(geojson.geometry, height), __assign$1({}, geojson.properties));
      }
      else if (geojson.type === GeoJsonGeometryType.MULTI_POLYGON) {
          var list_1 = [];
          geojson.coordinates.forEach(function (item) {
              list_1 = list_1.concat(polygonToPolyline$1(polygon$1(item).geometry, height).coordinates);
          });
          return multiLineString(list_1).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.POLYGON) {
          return multiLineString(geojson.coordinates.map(function (item) {
              return polygonToPolyline$1(lineString(item).geometry, height).coordinates;
          })).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.LINE_STRING) {
          return lineString(geojson.coordinates.map(function (item) {
              return item.length > 2 ? __spreadArray$1([], __read(item), false) : __spreadArray$1(__spreadArray$1([], __read(item), false), [height], false);
          })).geometry;
      }
  }

  var CastType;
  (function (CastType) {
      CastType["CUBE"] = "cube";
      CastType["ELLIPSE"] = "ellipse";
      CastType["ELLIPSOID"] = "ellipsoid";
      CastType["CYLINDER"] = "cylinder";
      CastType["PLANE"] = "plane";
  })(CastType || (CastType = {}));

  /** @class */ ((function (_super) {
      __extends$3(VideoShed, _super);
      function VideoShed(options, map) {
          return _super.call(this, __assign$1({ castType: CastType.PLANE, videoType: "video/mp4", ground: true }, (options || {})), map) || this;
      }
      Object.defineProperty(VideoShed.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      VideoShed.prototype.init = function () {
          var _a, _b, _c, _d, _e, _f, _g;
          this.initialized = true;
          var type = this.options.castType;
          var position = this.options.position;
          var video = this.options.video;
          var size = this.options.size;
          var videoType = this.options.videoType;
          var ground = this.options.ground;
          var _material;
          if (typeof video === "string") {
              var div = document.createElement("div");
              div.innerHTML =
                  "<video  muted=' autoplay='autoplay' loop='' crossorigin='' controls='' width='200px' height='200px'>" +
                      "<source src='" +
                      video +
                      "' type='" +
                      videoType +
                      "' />" +
                      "</video>";
              _material = div.children[0];
          }
          else {
              _material = video;
          }
          new Cesium__namespace.VideoSynchronizer({
              clock: this.map.map.clock,
              element: _material
          });
          this.map.map.clock.shouldAnimate = true;
          if (type === CastType.CUBE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(position), false)),
                  box: {
                      dimensions: new ((_b = Cesium__namespace.Cartesian3).bind.apply(_b, __spreadArray$1([void 0], __read(size), false)))(),
                      material: _material
                  }
              });
          }
          if (type === CastType.ELLIPSOID) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_c = Cesium__namespace.Cartesian3).fromDegrees.apply(_c, __spreadArray$1([], __read(position), false)),
                  ellipsoid: {
                      radii: new ((_d = Cesium__namespace.Cartesian3).bind.apply(_d, __spreadArray$1([void 0], __read(size), false)))(),
                      material: _material
                  }
              });
          }
          if (type === CastType.ELLIPSE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_e = Cesium__namespace.Cartesian3).fromDegrees.apply(_e, __spreadArray$1([], __read(position), false)),
                  ellipse: {
                      semiMajorAxis: size[0],
                      semiMinorAxis: size[1],
                      material: _material
                  }
              });
          }
          if (type === CastType.CYLINDER) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_f = Cesium__namespace.Cartesian3).fromDegrees.apply(_f, __spreadArray$1([], __read(position), false)),
                  cylinder: {
                      length: size[0],
                      topRadius: size[1],
                      bottomRadius: size[2],
                      material: _material
                  }
              });
          }
          if (type === CastType.PLANE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_g = Cesium__namespace.Cartesian3).fromDegrees.apply(_g, __spreadArray$1([], __read(position), false)),
                  plane: {
                      plane: new Cesium__namespace.Plane(ground ? Cesium__namespace.Cartesian3.UNIT_Z : Cesium__namespace.Cartesian3.UNIT_Y, 0.0),
                      dimensions: new Cesium__namespace.Cartesian2(size[1], size[2]),
                      material: _material
                  }
              });
          }
      };
      VideoShed.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.map.entities.add(this._castEntity);
          this.map.map.zoomTo(this._castEntity);
      };
      VideoShed.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
          }
          this.map.map.entities.remove(this._castEntity);
          this.map = undefined;
          this._castEntity = undefined;
          this.initialized = false;
      };
      VideoShed.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return VideoShed;
  })(Component));

  var RegisterCoordinateSystem$1 = /** @class */ (function () {
      function RegisterCoordinateSystem(glMap) {
          this.dimensions = ["lng", "lat"];
          this.radians = Cesium__namespace.Math.toRadians(80);
          this._GLMap = glMap;
          this._mapOffset = [0, 0];
          this.dimensions = ["lng", "lat"];
          //this._api = api;
      }
      RegisterCoordinateSystem.prototype.setMapOffset = function (mapOffset) {
          this._mapOffset = mapOffset;
      };
      RegisterCoordinateSystem.prototype.getMap = function () {
          return this._GLMap;
      };
      RegisterCoordinateSystem.prototype.fixLat = function (lat) {
          return lat >= 90 ? 89.99999999999999 : lat <= -90 ? -89.99999999999999 : lat;
      };
      RegisterCoordinateSystem.prototype.dataToPoint = function (coords) {
          var lonlat = [99999, 99999];
          coords[1] = this.fixLat(coords[1]);
          var position = Cesium__namespace.Cartesian3.fromDegrees(coords[0], coords[1]);
          if (!position)
              return lonlat;
          var coordinates = this._GLMap.cartesianToCanvasCoordinates(position);
          if (!coordinates)
              return lonlat;
          if (this._GLMap.mode === 3 /* SCENE3D */) {
              if (Cesium__namespace.Cartesian3.angleBetween(this._GLMap.camera.position, position) > this.radians)
                  return [NaN, NaN];
          }
          return [coordinates.x - this._mapOffset[0], coordinates.y - this._mapOffset[1]];
      };
      RegisterCoordinateSystem.prototype.pointToData = function (pixel) {
          this._mapOffset; 
          var // @ts-ignore
          coords = this._bmap.project([pixel[0] + pixel[0], pixel[1] + pixel[1]]);
          return [coords.lng, coords.lat];
      };
      RegisterCoordinateSystem.prototype.getViewRect = function () {
          // @ts-ignore
          var api = this._api;
          return new echarts__namespace.graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
      };
      RegisterCoordinateSystem.prototype.getRoamTransform = function () {
          return echarts__namespace.matrix.create();
      };
      RegisterCoordinateSystem.prototype.create = function (echartModel, api) {
          // @ts-ignore
          this._api = api;
          var glMap = this._GLMap;
          var registerCoordinateSystem;
          echartModel.eachComponent("GLMap", function (seriesModel) {
              var painter = api.getZr().painter;
              if (painter) {
                  //let glMap = (api.getViewportRoot(), echarts.glMap);
                  // @ts-ignore
                  // @ts-ignore
                  registerCoordinateSystem = new RegisterCoordinateSystem(glMap, api);
                  registerCoordinateSystem.setMapOffset(seriesModel.__mapOffset || [0, 0]);
                  seriesModel.coordinateSystem = registerCoordinateSystem;
              }
          });
          echartModel.eachSeries(function (series) {
              "GLMap" === series.get("coordinateSystem") && (series.coordinateSystem = registerCoordinateSystem);
          });
      };
      return RegisterCoordinateSystem;
  }());

  var convertTypes$1 = ["pie", "line", "bar"];
  /**
   * Echarts组件
   */
  /** @class */ ((function (_super) {
      __extends$3(Echarts, _super);
      function Echarts(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Echarts.prototype, "echarts", {
          /**
           * `echarts.init`初始化结果对象
           */
          get: function () {
              return this._echarts;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Echarts.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Echarts.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var viewer = this.map.map;
          var scene = viewer.scene;
          var container = document.createElement("div");
          container.style.position = "absolute";
          container.style.top = "0px";
          container.style.left = "0px";
          container.style.right = "0px";
          container.style.bottom = "0px";
          container.style.width = scene.canvas.width + "px";
          container.style.height = scene.canvas.height + "px";
          container.style.pointerEvents = "none";
          //@ts-ignore
          viewer._element.appendChild(container);
          this._echartsContainer = container;
          // @ts-ignore
          // echarts.glMap = scene;
          this._registerCoordinateSystem = new RegisterCoordinateSystem$1(this.map.map.scene);
          this._register();
          this._echarts = echarts__namespace.init(container);
          this._echarts.setOption(this._convertData(this.options), false);
          this.map.on([BaseEventType.CENTER_CHANGED, BaseEventType.ZOOM_CHANGED], function () {
              if (_this._chartRender) {
                  _this.echarts.resize();
                  _this._echarts.setOption(_this._convertData(_this.options), false);
              }
          });
      };
      /**
       * @ignore
       */
      Echarts.prototype._register = function () {
          if (this._isRegistered)
              return;
          var scene = this.map.map.scene;
          // @ts-ignore
          echarts__namespace.registerCoordinateSystem("GLMap", this._registerCoordinateSystem);
          echarts__namespace.registerAction({
              type: "GLMapRoam",
              event: "GLMapRoam",
              update: "updateLayout"
          }, function (e, t) { });
          echarts__namespace.extendComponentModel({
              type: "GLMap",
              // @ts-ignore
              getBMap: function () {
                  return this.__GLMap;
              },
              defaultOption: {
                  roam: !1
              }
          });
          echarts__namespace.extendComponentView({
              type: "GLMap",
              init: function (echartModel, api) {
                  //@ts-ignore
                  (this.api = api), scene.postRender.addEventListener(this.moveHandler, this);
              },
              moveHandler: function (e, t) {
                  this.api.dispatchAction({
                      type: "GLMapRoam"
                  });
              },
              render: function (e, t, i) { },
              dispose: function () {
                  // @ts-ignore
                  scene.postRender.removeEventListener(this.moveHandler, this);
              }
          });
          this._isRegistered = true;
      };
      /**
       * @ignore
       */
      Echarts.prototype._convertData = function (options) {
          var series = options.series;
          if (series && series.length > 0) {
              if (series && typeof series === "object") {
                  if (convertTypes$1) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (convertTypes$1.indexOf(series[i].type) > -1) {
                              if (series[i] && series[i].hasOwnProperty("coordinates")) {
                                  this._chartRender = true;
                                  // @ts-ignore
                                  series[i] = CHARTS_TRANSFORMER$1[series[i].type].call(this, options, series[i]);
                              }
                          }
                      }
                  }
              }
          }
          return options;
      };
      /**
       * @ignore
       */
      Echarts.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
      };
      /**
       * @ignore
       */
      Echarts.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.initialized = false;
          this._echartsContainer &&
              //@ts-ignore
              (this.map.map._element.removeChild(this._echartsContainer), (this._echartsContainer = void 0));
          this._echarts && (this._echarts.dispose(), (this._echarts = void 0));
          this._isRegistered = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Echarts.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置图表`option`
       *
       * 参考内容:[https://echarts.apache.org/zh/api.html#echartsInstance.setOption](https://echarts.apache.org/zh/api.html#echartsInstance.setOption)
       */
      Echarts.prototype.setOption = function (option) {
          this._options = __assign$1(__assign$1({}, option), { id: this.options.id, initOptions: this.options.initOptions });
          this._chartRender = false;
          this.echarts.setOption(this._convertData(this.options), false);
          return this;
      };
      return Echarts;
  })(Component));
  function barCoordinateTransform$1(options, series) {
      var _this = this;
      if (isObject$a(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coordinatePixel = _this._registerCoordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coordinatePixel[0] - parseFloat(gri.width) / 2;
              gri.top = coordinatePixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  }
  function lineCoordinateTransform$1(options, series) {
      var _this = this;
      if (isObject$a(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coordinatePixel = _this._registerCoordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coordinatePixel[0] - parseFloat(gri.width) / 2;
              gri.top = coordinatePixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  }
  function pieCoordinateTransform$1(options, series) {
      series.center = this._registerCoordinateSystem.dataToPoint(series.coordinates);
      return series;
  }
  var CHARTS_TRANSFORMER$1 = {
      pie: pieCoordinateTransform$1,
      bar: barCoordinateTransform$1,
      line: lineCoordinateTransform$1
  };

  /**
   * 遮罩组件
   *
   * [cesium]
   */
  /** @class */ ((function (_super) {
      __extends$3(Mask, _super);
      function Mask(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, globe: false }, options)) || this;
          _this._visible = _this.options.visible;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Mask.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Mask.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          this._entities = [];
          var styleItem = this.options.style && cesiumStyleItemListInit(this.options.style)[0];
          var material_ = new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.GREEN.withAlpha(0.3));
          var material1_ = new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.GREEN.withAlpha(0.3));
          if (defined$1(styleItem)) {
              material_ =
                  styleItem.type === StyleItemType.COLOR
                      ? styleItemFillColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem);
              material1_ =
                  styleItem.type === StyleItemType.COLOR
                      ? styleItemBorderColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem);
          }
          var data;
          if (this.options.data.geometry.type === GeoJsonGeometryType.POLYGON) {
              data = [this.options.data.geometry.coordinates];
          }
          if (this.options.data.geometry.type === GeoJsonGeometryType.MULTI_POLYGON) {
              data = this.options.data.geometry.coordinates;
          }
          var cartesians = data.map(function (_data) {
              return _data.map(function (_coords) {
                  return _coords.map(function (_coord) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_coord), false));
                  });
              });
          });
          var globe = this.options.globe;
          if (globe) {
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy([
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: -3.915323898915733,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: -3.915323898915733,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: 5500477.1339386385
                          }
                      ].map(function (coord) {
                          return Cesium__namespace.Cartesian3.fromArray([coord.x, coord.y, coord.z]);
                      })), 
                      // 填充的颜色，withAlpha透明度
                      material: material_ }, styleItem)
              }));
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy([
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: 3.915323898915733,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: 3.915323898915733,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: 5500477.1339386385
                          }
                      ].map(function (coord) {
                          return Cesium__namespace.Cartesian3.fromArray([coord.x, coord.y, coord.z]);
                      }), cartesians.map(function (_cartesians) {
                          return new Cesium__namespace.PolygonHierarchy(_cartesians[0]);
                      })), material: material_ }, styleItem)
              }));
          }
          else {
              // const coordinates = [
              //   [120.58593749999999, 27.254629577800063],
              //   [121.28906250000001, 28.188243641850313],
              //   [121.9482421875, 29.075375179558346],
              //   [122.08007812499999, 29.954934549656144],
              //   [121.5087890625, 30.221101852485987],
              //   [120.76171875, 30.41078179084589],
              //   [121.28906250000001, 30.90222470517144],
              //   [120.58593749999999, 30.86451022625836],
              //   [119.794921875, 31.090574094954192],
              //   [119.53125, 30.751277776257812],
              //   [118.828125, 29.878755346037977],
              //   [118.2568359375, 29.267232865200878],
              //   [118.43261718749999, 28.22697003891834],
              //   [118.91601562499999, 27.605670826465445],
              //   [119.794921875, 27.488781168937997],
              //   [120.58593749999999, 27.254629577800063]
              // ];
              var coordinates = Turf__namespace.bboxPolygon(this.options.extent || [73.66, 3.86, 135.05, 53.55]).geometry.coordinates.flat();
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy(coordinates.map(function (coord) {
                          var _a;
                          return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coord), false));
                      }), cartesians
                          .map(function (_cartesians) {
                          return _cartesians.map(function (_cartesian) {
                              return new Cesium__namespace.PolygonHierarchy(_cartesian);
                          });
                      })
                          .flat()), material: material_ }, styleItem)
              }));
          }
          cartesians.forEach(function (elem) {
              elem.forEach(function (coords) {
                  _this._entities.push(new Cesium__namespace.Entity({
                      polyline: __assign$1({ positions: coords, width: 10, material: material1_ }, styleItem)
                  }));
              });
          });
      };
      /**
       * @ignore
       * @param map
       */
      Mask.prototype.addTo = function (map) {
          var e_1, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = this._visible;
                  this.map.map.entities.add(entity);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Mask.prototype.remove = function (destroy) {
          var e_2, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.remove(entity);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this._entities = [];
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Mask.prototype._destroy = function () {
          var e_3, _a;
          this.remove();
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  Cesium__namespace.destroyObject(entity);
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_3) throw e_3.error; }
          }
          this._entities = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 显示墙组件
       */
      Mask.prototype.show = function () {
          var e_4, _a;
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = true;
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_4) throw e_4.error; }
          }
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Mask.prototype.hide = function () {
          var e_5, _a;
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = false;
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_5) throw e_5.error; }
          }
          return this;
      };
      return Mask;
  })(Component));

  /**
   *  绘制组件
   */
  var Draw$1 = /** @class */ (function (_super) {
      __extends$3(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, edit: true }, (options || {})), map) || this;
          /**
           * @ignore
           *
           * @type {PointCoordinate[]}
           */
          _this._points = [];
          return _this;
      }
      Object.defineProperty(Draw.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "drawing", {
          get: function () {
              return defined$1(this._handler.getInputAction(2 /* LEFT_CLICK */));
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Draw.prototype.init = function () {
          this.initialized = true;
          this._style = {
              point: this.options.pointStyle || DRAW_STYLE.point,
              polygon: this.options.polygonStyle || DRAW_STYLE.polygon,
              polyline: this.options.polylineStyle || DRAW_STYLE.polyline
          };
          this._initTip();
          this._initEvent();
      };
      /**
       * @ignore
       */
      Draw.prototype._initEvent = function () {
          // 事件处理器是否销毁，如果未销毁，则销毁
          this._handler && !this._handler.isDestroyed && this._handler.destroy();
          this._handler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
      };
      /**
       * @ignore
       */
      Draw.prototype._firstClickEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.position);
          if (!obj.cartesian3) {
              return;
          }
          this._tip.element.innerHTML = "单击继续绘制要素，双击完成要素绘制!";
          this._points.push(cartesian3ToDegrees(obj.cartesian3, this.map));
          this._plot = createDraw(this.type, this._points.slice());
          if (this.type === DrawType.CIRCLE) {
              // @ts-ignore
              this._plot.minRadius = this.options.minRadius / 1000 || 50 / 1000;
              // @ts-ignore
              this._plot.maxRadius = this.options.maxRadius / 1000 || Number.MAX_VALUE;
          }
          this._feature = this._createFeauture();
          this.map.map.entities.add(this._feature);
          this._handler.removeInputAction(2 /* LEFT_CLICK */);
          this._handler.removeInputAction(15 /* MOUSE_MOVE */);
          this.dispatchEvent({
              type: BaseEventType.DRAW_START
          });
          // 特殊类型几何体需要几个点来插值生成特殊几何体
          if (this._plot.fixPointCount === this._plot.getPointCount()) {
              this._doubleClickEventHandler();
              return;
          }
          this._handler.setInputAction(this._nextClickEventHandler.bind(this), 2 /* LEFT_CLICK */);
          this._handler.setInputAction(this._mouseMoveEventHandler.bind(this), 15 /* MOUSE_MOVE */);
          this._handler.setInputAction(this._doubleClickEventHandler.bind(this), 3 /* LEFT_DOUBLE_CLICK */);
      };
      /**
       * @ignore
       */
      Draw.prototype._nextClickEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.position);
          if (!obj.cartesian3) {
              return;
          }
          var _coord = cartesian3ToDegrees(obj.cartesian3, this.map);
          var distance = distance$1(_coord, this._points[this._points.length - 1]);
          if (distance > Constants.ZERO_TOLERANCE) {
              this._points.push(_coord);
              this._plot.setPoints(this._points.slice());
              // 添加节点触发节点增加事件---
              this.dispatchEvent({
                  type: "nodeadd",
                  target: this,
                  positions: this._points.slice()
              });
              if (this._plot.fixPointCount === this._plot.getPointCount()) {
                  // 结束绘制----销毁资源
                  this._doubleClickEventHandler();
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._doubleClickEventHandler = function () {
          var feature_;
          if (this._feature.point) {
              feature_ = new Point$1({ coordinates: this._plot.coordinates.slice() });
          }
          if (this._feature.polyline) {
              feature_ = new Polyline$1({
                  coordinates: this._plot.coordinates.slice().map(function (i) {
                      return [i[0], i[1]];
                  })
              });
          }
          if (this._feature.polygon) {
              // TODO:坐标格式化
              var cd = this._plot.coordinates.slice();
              cd.forEach(function (i) {
                  i.forEach(function (c) {
                      c.length = 2;
                  });
                  i.push(i[0]);
              });
              if (this.type === DrawType.CIRCLE) {
                  feature_ = new Circle({
                      radius: this._plot.ellipsoidRaduis * 1000,
                      center: this._plot.center
                  });
              }
              else {
                  feature_ = new Polygon$1({ coordinates: cd });
              }
          }
          feature_.set("plot", this._plot.getPoints());
          feature_.set("plotType", this.type);
          feature_.setProperties({ plot: this._plot.getPoints(), plotType: this.type });
          this.options.target && this.options.target.addFeature(feature_);
          this.dispatchEvent({
              type: BaseEventType.DRAW_END,
              feature: feature_
          });
          this.deactive();
      };
      /**
       * @ignore
       */
      Draw.prototype._mouseMoveEventHandler = function (evt) {
          var obj = pickPositionAndObj(this.map.map.scene, evt.endPosition);
          if (!obj.cartesian3) {
              return;
          }
          var _coord = cartesian3ToDegrees(obj.cartesian3, this.map);
          this._tip.setPosition(cartesian3ToDegrees(obj.cartesian3, this.map));
          if (distance$1(_coord, this._points[this._points.length - 1]) > Constants.ZERO_TOLERANCE) {
              this._plot.setPoints(this._points.concat([_coord]).slice(0));
              if (this._points.concat([_coord]).length > 1) {
                  this.dispatchEvent({
                      type: "nodemove",
                      target: this,
                      positions: this._points.concat([_coord]).slice(0)
                  });
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._destroyEvent = function () {
          this._handler.isDestroyed && this._handler.destroy();
          this._handler = undefined;
      };
      // 交互失效
      Draw.prototype.deactive = function () {
          this._feature && this.map.map.entities.remove(this._feature);
          this._points = [];
          this._tip.hide();
          this._tip.element.innerHTML = "单击地图绘制要素";
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this._plot = undefined;
          this._feature = undefined;
          if (this._handler && !this._handler.isDestroyed()) {
              this._handler.getInputAction(2 /* LEFT_CLICK */) &&
                  this._handler.removeInputAction(2 /* LEFT_CLICK */);
              this._handler.getInputAction(15 /* MOUSE_MOVE */) &&
                  this._handler.removeInputAction(15 /* MOUSE_MOVE */);
              this._handler.getInputAction(3 /* LEFT_DOUBLE_CLICK */) &&
                  this._handler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
          }
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.initialized = false;
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this.map = undefined;
      };
      /**
       * 激活绘制组件
       *
       *
       */
      Draw.prototype.active = function (type) {
          var _this = this;
          this.deactive();
          this._defaultCursor = this.map.map.container.style.cursor;
          // @ts-ignore
          this.map.map.container.style.cursor = "crosshair";
          this._type = type;
          this._handler.setInputAction(this._firstClickEventHandler.bind(this), 2 /* LEFT_CLICK */);
          this._handler.setInputAction(function (evt) {
              var obj = pickPositionAndObj(_this.map.map.scene, evt.endPosition);
              if (!obj.cartesian3) {
                  return;
              }
              _this._tip.setPosition(cartesian3ToDegrees(obj.cartesian3, _this.map));
          }, 15 /* MOUSE_MOVE */);
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype._destroy = function () {
          this.remove();
          this._style = undefined;
          this._destroyEvent();
          _super.prototype._destroy.call(this);
      };
      /**
       * 清除全部标绘
       */
      Draw.prototype.clearAll = function () {
          this.options.target && this.options.target.clearFeatures();
          return this;
      };
      /**
       * @ignore
       */
      Draw.prototype._initTip = function () {
          var _element = document.createElement("span");
          _element.className = "mti-measure-tool mti-measure-tool-length";
          _element.innerHTML = "单击地图绘制要素";
          this._tip = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: _element,
              offset: [0, 18]
          }, this.map);
          this._tip.setPositioning(Positioning.TOP_LEFT);
      };
      /**
       * @ignore
       */
      Draw.prototype._createFeauture = function () {
          var _a;
          var _this = this;
          var _entity;
          if (this.type === DrawType.POINT) {
              var _coordinates = this._plot.coordinates;
              var _style = transformParams(this._style.point[0]);
              _entity = new Cesium__namespace.Entity(__assign$1({ position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_coordinates), false)), point: __assign$1({}, _style) }, _style));
          }
          else if (this.type === DrawType.POLYLINE ||
              this.type === DrawType.ARC ||
              this.type === DrawType.CURVE ||
              this.type === DrawType.STRAIGHT_ARROW) {
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates || [];
                  var _pos = _coordinates.slice().map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return _pos;
              }, false);
              var _style = transformParams(this._style.polyline[0]);
              _entity = new Cesium__namespace.Entity({
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_style) }, _style))
              });
          }
          else {
              // 线的回调坐标---
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates.concat() || [];
                  var _coords = [];
                  if (_coordinates[0] && _coordinates[0].length > 2) {
                      //  _coords = Turf.cleanCoords(Turf.lineString(_coordinates[0])).geometry.coordinates;
                      _coords = _coordinates[0];
                      _coords.push(_coords[0]);
                  }
                  var _pos = _coords.map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return _pos;
              }, false);
              var _style = transformParams(this._style.polygon[0]);
              // 面的回调坐标-----开始
              var hierarchy = new Cesium__namespace.CallbackProperty(function () {
                  var _coordinates = _this._plot.coordinates[0] || [];
                  var _pos = _coordinates.slice().map(function (cood) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(cood), false));
                  });
                  return new Cesium__namespace.PolygonHierarchy(_pos);
              }, false);
              // 面的回调坐标-----结束---
              _entity = new Cesium__namespace.Entity({
                  polygon: new Cesium__namespace.PolygonGraphics(__assign$1({ hierarchy: hierarchy, material: _style.type === StyleItemType.COLOR
                          ? styleItemFillColorToColorMaterialProperty(__assign$1({}, _style))
                          : styleItemToImageMaterialProperty(__assign$1({}, _style)) }, __assign$1({}, _style))),
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(__assign$1({}, _style)) }, __assign$1({}, _style)))
              });
          }
          return _entity;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成   | (feature: [[Feature]])-要素对象
       *  `nodeadd`    |   绘制要素新增点时         | (positions: [[PointCoordinate]][])-坐标串
       *  `nodemove`   |   移动顶点时              | (positions: [[PointCoordinate]][])-坐标串
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       *  `nodeadd`    |   绘制要素新增点时         | (positions: [[PointCoordinate]][])-坐标串
       *  `nodemove`   |   移动顶点时              | (positions: [[PointCoordinate]][])-坐标串
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Draw;
  }(Component));

  /**
   * 周边搜索组件
   */
  var CircleSearch = /** @class */ (function (_super) {
      __extends$3(CircleSearch, _super);
      function CircleSearch(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(CircleSearch.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "minRadius", {
          /**
           * 可拖拽的最小半径  单位: 米
           */
          get: function () {
              return this._minRadius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "maxRadius", {
          /**
           * 可拖拽的最大半径  单位: 米
           */
          get: function () {
              return this._maxRadius;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      CircleSearch.prototype.init = function () {
          var _a = this.options, infoPopup = _a.infoPopup, step = _a.step, _b = _a.minRadius, minRadius = _b === void 0 ? 5 : _b, maxRadius = _a.maxRadius;
          defined$1(this.minRadius) || this.setMinRadius(minRadius);
          defined$1(this.maxRadius) || this.setMaxRadius(maxRadius);
          this._step = step || 1;
          this._dragging = false;
          this._hovering = false;
          this.initialized = true;
          this._layer = new VectorLayer({});
          this._infoPopup = infoPopup;
          this._eventKeys = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          defined$1(this._infoPopup) && this.map.addOverlay(this._infoPopup);
      };
      /**
       * 激活
       * @param feature
       * @returns
       */
      CircleSearch.prototype.active = function (feature) {
          var _this = this;
          this.deactive();
          if (feature instanceof Circle) {
              this._active(feature);
          }
          else if (this.map) {
              this._draw = new Draw$1({}, this.map).active(DrawType.CIRCLE);
              this._draw.once(BaseEventType.DRAW_END, function (_a) {
                  var feature = _a.feature; _a.target;
                  _this._active(feature);
                  _this.dispatchEvent({
                      type: BaseEventType.EDIT_END,
                      radius: feature.radius,
                      center: feature.center,
                      dragPointCoordinate: _this._dragCoordinate
                  });
                  window.setTimeout(function () {
                      _this._removeDraw();
                  });
              });
          }
          return this;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._initEvent = function () {
          this._eventKeys.setInputAction(pointerDownHandler.bind(this), 0 /* LEFT_DOWN */);
          this._eventKeys.setInputAction(pointerUpHandler.bind(this), 1 /* LEFT_UP */);
          this._eventKeys.setInputAction(pointerMoveHandler.bind(this), 15 /* MOUSE_MOVE */);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._clearEvent = function () {
          this._eventKeys.removeInputAction(0 /* LEFT_DOWN */);
          this._eventKeys.removeInputAction(1 /* LEFT_UP */);
          this._eventKeys.removeInputAction(15 /* MOUSE_MOVE */);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._initFeatures = function (feature) {
          var _this = this;
          var _a;
          var centerCoordinates = feature.center;
          centerCoordinates[2] = 0;
          var radius = feature.radius;
          var _b = this.options, linkedLineStyle = _b.linkedLineStyle, centerPointStyle = _b.centerPointStyle, dragPointStyle = _b.dragPointStyle, circleStyle = _b.circleStyle;
          this._inverseMatrix4 = Cesium__namespace.Matrix4.inverse(Cesium__namespace.Transforms.eastNorthUpToFixedFrame(degreesToCartesian3(centerCoordinates, this.map)), new Cesium__namespace.Matrix4());
          this._distance = radius;
          var circleRadiusCallBack = function () {
              return _this._distance;
          };
          var circleRadiusPolylineCallBack = function (styleItem) {
              return function () {
                  return calculateCircleOutlineCartesian3Points(_this._distance, degreesToCartesian3(centerCoordinates, _this.map), centerCoordinates, styleItem, _this.map);
              };
          };
          this._circle = new Circle({ center: centerCoordinates, radius: radius });
          this._circle.setStyle((circleStyle === null || circleStyle === void 0 ? void 0 : circleStyle.map(function (i) { return (__assign$1(__assign$1(__assign$1({}, i), { entity: true, semiMajorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false), semiMinorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false) }), (i.type === StyleItemType.COLOR || i.type === StyleItemType.RADIAL_GRADIENT
              ? { positions: new Cesium__namespace.CallbackProperty(circleRadiusPolylineCallBack(i), false) }
              : {}))); })) ||
              CIRCLE_SEARCH_STYLE.circle.map(function (i) { return (__assign$1(__assign$1(__assign$1({}, i), { semiMajorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false), semiMinorAxis: new Cesium__namespace.CallbackProperty(circleRadiusCallBack, false) }), (i.type === StyleItemType.COLOR || i.type === StyleItemType.RADIAL_GRADIENT
                  ? { positions: new Cesium__namespace.CallbackProperty(circleRadiusPolylineCallBack(i), false) }
                  : {}))); }));
          this._layer.addFeature(this._circle);
          this._dragCoordinate = computeDragPoint.call(this);
          var centerCartesian3 = coordinatesToCartesian3Array([centerCoordinates])[0];
          var linkedLineCoordinatesCallBack = function () {
              return [centerCartesian3, coordinatesToCartesian3Array([_this._dragCoordinate])[0]];
          };
          this._linkedLine = new Polyline$1({ coordinates: [centerCoordinates, centerCoordinates] });
          this._linkedLine.setStyle((linkedLineStyle === null || linkedLineStyle === void 0 ? void 0 : linkedLineStyle.map(function (i) { return (__assign$1(__assign$1({}, i), { entity: true, positions: new Cesium__namespace.CallbackProperty(linkedLineCoordinatesCallBack, false) })); })) ||
              CIRCLE_SEARCH_STYLE.linkedLine.map(function (i) { return (__assign$1(__assign$1({}, i), { positions: new Cesium__namespace.CallbackProperty(linkedLineCoordinatesCallBack, false) })); }));
          this._layer.addFeature(this._linkedLine);
          this._centerPoint = new Point$1({ coordinates: centerCoordinates });
          this._centerPoint.setStyle(centerPointStyle || CIRCLE_SEARCH_STYLE.centerPoint);
          this._layer.addFeature(this._centerPoint);
          this._dragPoint = new Point$1({ coordinates: this._dragCoordinate });
          this._dragPoint.setStyle(dragPointStyle || CIRCLE_SEARCH_STYLE.dragPoint);
          this._layer.addFeature(this._dragPoint);
          (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(this._dragCoordinate);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._active = function (feature) {
          this._initEvent();
          this._initFeatures(feature);
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._clearFeatures = function () {
          this._layer.clearFeatures();
          this._centerPoint = this._linkedLine = this._dragPoint = this._circle = void 0;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._removeDraw = function () {
          if (this._draw) {
              this.map.removeComponent(this._draw, true);
              this._draw = void 0;
          }
      };
      /**
       * 清除
       * @returns
       */
      CircleSearch.prototype.deactive = function () {
          if (this._infoPopup) {
              this._infoPopup.setPosition();
          }
          this._removeDraw();
          this._clearFeatures();
          this._clearEvent();
          return this;
      };
      /**
       * 禁用地图平移交互组件
       * @ignore
       */
      CircleSearch.prototype._disableMapDragPan = function () {
          this.map.map.scene.screenSpaceCameraController.enableInputs = false;
      };
      /**
       * 启用地图平移拖拽交互组件
       * @ignore
       */
      CircleSearch.prototype._enableMapDragPan = function () {
          this.map.map.scene.screenSpaceCameraController.enableInputs = true;
      };
      /**
       * 设置周边搜索圆半径
       *
       * @param radius
       * @returns
       */
      CircleSearch.prototype.setCircleRadius = function (radius) {
          if (typeof radius === "number" &&
              radius >= this.minRadius &&
              (!defined$1(this.maxRadius) || radius <= this.maxRadius)) {
              changeCircleRadius.call(this, radius);
          }
          return this;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._infoPopup);
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      CircleSearch.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          this._infoPopup = void 0;
          this._eventKeys.destroy();
          this._eventKeys = void 0;
          this._inverseMatrix4 = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `radiuschange`    |   半径变更  | (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *  `editend` |  拖拽修改或绘制结束  |  (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      CircleSearch.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `radiuschange`    |   半径变更  | (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *  `editend` |  拖拽修改或绘制结束  |  (radius:number)-圆半径, (center: [[PointCoordinate]])-圆心坐标, (dragPointCoordinate:[[PointCoordinate]])-拖拽点坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      CircleSearch.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 设置可拖拽的最小半径  单位: 米
       */
      CircleSearch.prototype.setMinRadius = function (radius) {
          this._minRadius = radius;
          return this;
      };
      /**
       * 设置可拖拽的最大半径  单位: 米
       */
      CircleSearch.prototype.setMaxRadius = function (radius) {
          this._maxRadius = radius;
          return this;
      };
      return CircleSearch;
  }(Component$1));
  function pointerDownHandler(e) {
      if (this._hovering) {
          this._disableMapDragPan();
          this._dragging = true;
      }
  }
  function pointerUpHandler() {
      this.map.map.scene.canvas.style.cursor = "";
      if (this._dragging) {
          this._hovering = false;
          this._dragging = false;
          this._enableMapDragPan();
          this.dispatchEvent({
              type: BaseEventType.EDIT_END,
              radius: this._distance,
              center: this._circle.center,
              dragPointCoordinate: this._dragCoordinate
          });
      }
  }
  function pointerMoveHandler(movement) {
      var _a;
      if (this._dragging) {
          var startCartesian3 = this.map.map.scene.camera.pickEllipsoid(movement.startPosition, this.map.map.scene.globe.ellipsoid);
          var endCartesian3 = this.map.map.scene.camera.pickEllipsoid(movement.endPosition, this.map.map.scene.globe.ellipsoid);
          if (!(startCartesian3 && endCartesian3)) {
              return;
          }
          var move = computeDistance.call(this, startCartesian3, endCartesian3);
          move = move - (move % this._step);
          var newR = this._distance + move;
          if (!(newR >= this.minRadius && (!defined$1(this.maxRadius) || newR <= this.maxRadius))) {
              return;
          }
          changeCircleRadius.call(this, newR);
      }
      else {
          var pickObj = this.map.map.scene.pick(movement.endPosition);
          if ((pickObj === null || pickObj === void 0 ? void 0 : pickObj.id) === this._dragPoint || ((_a = pickObj === null || pickObj === void 0 ? void 0 : pickObj.id) === null || _a === void 0 ? void 0 : _a[FEATURE_LINK]) === this._dragPoint) {
              this._hovering = true;
              this.map.map.scene.canvas.style.cursor = "move";
          }
          else if (!this._dragging) {
              this._hovering = false;
              this.map.map.scene.canvas.style.cursor = "";
          }
      }
  }
  function changeCircleRadius(radius) {
      var _a;
      if (this._distance === radius) {
          return;
      }
      this._distance = radius;
      this._dragCoordinate = computeDragPoint.call(this);
      this._dragPoint.setCoordinates(this._dragCoordinate);
      (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(this._dragCoordinate);
      this.dispatchEvent({
          type: BaseEventType.RADIUS_CHANGE,
          radius: radius,
          center: this._circle.center,
          dragPointCoordinate: this._dragCoordinate
      });
  }
  function computeDistance(startCartesian3, endCartesian3) {
      var cameraPosition = Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, this.map.map.camera.position, new Cesium__namespace.Cartesian3());
      // 由平面法线、和平面经过点获取平面方程表示的三维平面
      var temPlane = Cesium__namespace.Plane.fromPointNormal(Cesium__namespace.Cartesian3.UNIT_X, Cesium__namespace.Cartesian3.UNIT_Z);
      return (Cesium__namespace.IntersectionTests.rayPlane(new Cesium__namespace.Ray(cameraPosition, Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, endCartesian3, new Cesium__namespace.Cartesian3()), cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3())), temPlane).x -
          Cesium__namespace.IntersectionTests.rayPlane(new Cesium__namespace.Ray(cameraPosition, Cesium__namespace.Cartesian3.normalize(Cesium__namespace.Cartesian3.subtract(Cesium__namespace.Matrix4.multiplyByPoint(this._inverseMatrix4, startCartesian3, new Cesium__namespace.Cartesian3()), cameraPosition, new Cesium__namespace.Cartesian3()), new Cesium__namespace.Cartesian3())), temPlane).x);
  }
  function computeDragPoint() {
      var _a;
      // @ts-ignore
      var points = Cesium__namespace.EllipseGeometryLibrary.computeEllipsePositions({
          semiMinorAxis: this._distance,
          semiMajorAxis: this._distance,
          rotation: 0,
          granularity: Cesium__namespace.Math.RADIANS_PER_DEGREE,
          center: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(this._circle.coordinates), false))
      }, true, false).positions;
      var degrees = cartesian3ToDegrees(new Cesium__namespace.Cartesian3(points[0], points[1], points[2]));
      degrees.length = 2;
      return degrees;
  }

  /**
   * 历史轨迹组件
   */
  var HistoryTrack = /** @class */ (function (_super) {
      __extends$3(HistoryTrack, _super);
      function HistoryTrack(options, map) {
          var _this = _super.call(this, options) || this;
          _this.setLoop(options.loop || false);
          _this.setVelocity(options.velocity || 1);
          _this.setTrack(options.track || false);
          _this._duration = options.duration;
          _this._paused = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(HistoryTrack.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "loop", {
          /**
           * 是否循环
           */
          get: function () {
              return this._loop;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "velocity", {
          /**
           * 速度值 单位: m/s
           *
           * 当duration未定义时,按照设定的真实速度移动
           */
          get: function () {
              return this._velocity;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "track", {
          /**
           * 是否跟踪移动
           */
          get: function () {
              return this._track;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      HistoryTrack.prototype.init = function () {
          this.initialized = true;
          this._eventHelper = new Cesium__namespace.EventHelper();
          this._time = this._distance = 0;
          this._layer = new VectorLayer({});
          var _a = this.options, pathCoordinates = _a.path, targetStyle = _a.targetStyle, pathStyle = _a.pathStyle, originStyle = _a.originStyle, destinationStyle = _a.destinationStyle;
          this._pathGeoJsonFeature = Array.isArray(pathCoordinates) ? lineString(pathCoordinates) : pathCoordinates;
          this._pathCoordinates = this._pathGeoJsonFeature.geometry.coordinates;
          this._pathDistance = Turf__namespace.length(this._pathGeoJsonFeature) * 1000;
          if (pathStyle) {
              this._path = new Polyline$1({ coordinates: this._pathCoordinates });
              this._path.setStyle(pathStyle);
              this._layer.addFeature(this._path);
          }
          if (originStyle) {
              this._origin = new Point$1({ coordinates: this._pathCoordinates[0] });
              this._origin.setStyle(originStyle);
              this._layer.addFeature(this._origin);
          }
          if (destinationStyle) {
              this._destination = new Point$1({ coordinates: this._pathCoordinates[this._pathCoordinates.length - 1] });
              this._destination.setStyle(destinationStyle);
              this._layer.addFeature(this._destination);
          }
          this._target = new Point$1({ coordinates: this._pathCoordinates[0] });
          this._target.setStyle(targetStyle);
          this._layer.addFeature(this._target);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._clearEvent();
          this._reset();
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._pathCoordinates =
              this._target =
                  this._origin =
                      this._path =
                          this._destination =
                              this._layer =
                                  this._pathGeoJsonFeature =
                                      this._eventHelper =
                                          void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._initEvent = function () {
          var e_1, _a;
          var _this = this;
          var previousTime = performance.now();
          var startPosition = degreesToCartesian3(this._target.coordinates, this.map);
          var _b = getPointFeatureModelParams(this._target, this.map), clamped = _b.clamped, hasModel = _b.hasModel;
          if (hasModel && this.track) {
              try {
                  for (var _c = __values(this._target.sourceFeature.entities), _d = _c.next(); !_d.done; _d = _c.next()) {
                      var entity = _d.value;
                      if (defined$1(entity.model)) {
                          entity.viewFrom = new Cesium__namespace.ConstantProperty(new Cesium__namespace.Cartesian3(180, 100, 10000));
                          this.map.map.trackedEntity = entity;
                          break;
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          if (clamped) {
              coordinatesClampToTerrain([this._target.coordinates], this.map).then(function (res) {
                  startPosition = degreesToCartesian3(res[0], _this.map);
              });
          }
          var hasHeight = this._target.coordinates.length > 2;
          this._eventHelper.add(this.map.map.scene.postRender, function () {
              if (!_this._paused) {
                  var rate = void 0;
                  if (defined$1(_this._duration)) {
                      _this._time += (performance.now() - previousTime) / 1000;
                      rate = _this._time / _this._duration;
                  }
                  else {
                      _this._distance += ((performance.now() - previousTime) / 1000) * _this.velocity;
                      rate = _this._distance / _this._pathDistance;
                  }
                  rate = rate >= 1 ? 1 : rate;
                  var slicedLineFeature = Turf__namespace.lineSliceAlong(_this._pathGeoJsonFeature, 0, (_this._pathDistance * rate) / 1000);
                  var slicedCoordinates = slicedLineFeature.geometry.coordinates;
                  var newPointCoordinate = slicedCoordinates[slicedCoordinates.length - 1];
                  if (hasHeight) {
                      var _a = __read(_this._pathGeoJsonFeature.geometry.coordinates[slicedCoordinates.length - 1], 3), lng1 = _a[0], lat1 = _a[1], height1 = _a[2];
                      var _b = __read(_this._pathGeoJsonFeature.geometry.coordinates[slicedCoordinates.length - 2], 3), lng2 = _b[0], lat2 = _b[1], height2 = _b[2];
                      var _c = __read(slicedCoordinates[slicedCoordinates.length - 1], 2), lng3 = _c[0], lat3 = _c[1];
                      var newHeight = void 0;
                      if (lng1 === lng3 && lat1 === lat3) {
                          newHeight = height1;
                      }
                      else {
                          newHeight =
                              height2 -
                                  (Turf__namespace.distance([lng2, lat2], [lng3, lat3]) / Turf__namespace.distance([lng2, lat2], [lng1, lat1])) *
                                      (height2 - height1);
                      }
                      newPointCoordinate[2] = newHeight;
                  }
                  if (_this.track && !hasModel) {
                      _this.map.setCenter(newPointCoordinate);
                  }
                  _this._target.setCoordinates(newPointCoordinate);
                  if (hasModel) {
                      var position1_1 = startPosition;
                      if (clamped) {
                          coordinatesClampToTerrain([newPointCoordinate], _this.map).then(function (res) {
                              var position2 = degreesToCartesian3(res[0]);
                              updateFeatureOrientation(_this._target, position1_1, position2, _this.map.map.scene.globe.ellipsoid);
                              startPosition = position2;
                          });
                      }
                      else {
                          var position2 = degreesToCartesian3(newPointCoordinate);
                          updateFeatureOrientation(_this._target, position1_1, position2, _this.map.map.scene.globe.ellipsoid);
                          startPosition = position2;
                      }
                  }
                  _this.dispatchEvent({
                      type: BaseEventType.MOVE,
                      progress: rate,
                      position: newPointCoordinate
                  });
                  if (rate >= 1) {
                      if (!_this.loop) {
                          _this._clearEvent();
                          _this.dispatchEvent({
                              type: BaseEventType.MOVE_END,
                              progress: rate,
                              position: newPointCoordinate
                          });
                      }
                      else {
                          _this._reset();
                      }
                      return;
                  }
              }
              previousTime = performance.now();
          });
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._clearEvent = function () {
          this._eventHelper.removeAll();
      };
      /**
       * @ignore
       */
      HistoryTrack.prototype._reset = function () {
          this._time = this._distance = 0;
          this._target.setCoordinates(this._pathCoordinates[0]);
          this.resume();
      };
      /**
       * 开始
       *
       * @returns
       */
      HistoryTrack.prototype.start = function () {
          if (this._time !== 0 || this._distance !== 0) {
              return this;
          }
          this._reset();
          this._clearEvent();
          this._initEvent();
          return this;
      };
      /**
       * 暂停
       * @returns
       */
      HistoryTrack.prototype.pause = function () {
          this._paused = true;
          return this;
      };
      /**
       * 恢复
       * @returns
       */
      HistoryTrack.prototype.resume = function () {
          this._paused = false;
          return this;
      };
      /**
       * 停止
       * @returns
       */
      HistoryTrack.prototype.stop = function () {
          this._reset();
          this._clearEvent();
          return this;
      };
      /**
       * 设置是否循环
       * @param loop
       * @returns
       */
      HistoryTrack.prototype.setLoop = function (loop) {
          this._loop = loop;
          return this;
      };
      /**
       * 设置速度值 单位: m/s
       *
       * @param velocity
       * @returns
       */
      HistoryTrack.prototype.setVelocity = function (velocity) {
          this._velocity = velocity;
          return this;
      };
      /**
       * 设置是否跟踪
       * @param track
       * @returns
       */
      HistoryTrack.prototype.setTrack = function (track) {
          this._track = track;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `move`    |   移动中  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *  `moveend` |  非循环状态下,移动结束  |  (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      HistoryTrack.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `move`    |   移动中  | (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *  `moveend` |  非循环状态下,移动结束  |  (progress:number)-进度, (position: [[PointCoordinate]])-当前位置点
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      HistoryTrack.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return HistoryTrack;
  }(Component$1));

  var PointEntity = /** @class */ (function () {
      function PointEntity(viewer, pixel, style) {
          this.graphic = null;
          this.wp = null;
          this.viewer = viewer;
          this.style = style || PointEntity.defaultStyle();
          this.create(pixel);
      }
      /**
       * 类的静态方法，点实体的默认样式
       */
      PointEntity.defaultStyle = function () {
          return {
              type: StyleItemType.CIRCLE,
              entity: true,
              fillColor: "red",
              outlineColor: "red",
              outlineWidth: 1,
              color: "red",
              pixelSize: 8,
              heightReference: 1 /* CLAMP_TO_GROUND */
          };
      };
      /**
       * 类的静态方法，点实体的编辑样式
       *
       */
      PointEntity.editStyle = function () {
          return {
              type: StyleItemType.ICON,
              image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAANklEQVQ4jWNkCJP/z0BFwMLAwMAQnqR+lhqGrZx305iJGgYhg1EDRw0cNXDUwFEDIYCR2lUAAHrqBxH0XVqDAAAAAElFTkSuQmCC",
              entity: true,
              scale: 0.8,
              heightReference: 0 /* NONE */
          };
      };
      /**
       * 类的静态方法，点实体的选中样式
       *
       */
      PointEntity.selectedStyle = function () {
          return {
              type: StyleItemType.CIRCLE,
              entity: true,
              color: "rgba(0,255,255,1)",
              pixelSize: 5,
              outlineColor: "rgba(0,255,255,1)",
              outlineWidth: 3
          };
      };
      // 将世界坐标系转化为经纬度、高度---
      PointEntity.cartesian3ToLonLat = function (world) {
          return cartesian3ToCartographic(world);
      };
      /**
       * 根据屏幕像素坐标创建实体，并添加到地图上
       *
       * @param {Cesium.Cartesian2} pixel  2d笛卡尔坐标点
       * @return {Cesium.Entity}  实体类对象
       */
      PointEntity.prototype.create = function (pos) {
          var _wp = null;
          if (pos instanceof Cesium__namespace.Cartesian3) {
              _wp = pos;
          }
          else {
              var cartesian3 = pickPositionAndObj(this.viewer.scene, pos).cartesian3;
              if (cartesian3) {
                  _wp = cartesian3;
              }
          }
          var entity = new Cesium__namespace.Entity({
              position: _wp
          });
          if (this.style.type === StyleItemType.ICON && this.style.entity) {
              entity.billboard = new Cesium__namespace.BillboardGraphics(transformParams(this.style));
          }
          if (this.style.type === StyleItemType.CIRCLE && this.style.entity) {
              entity.point = new Cesium__namespace.PointGraphics(transformParams(this.style));
          }
          this.graphic = entity;
          this.wp = _wp;
          return entity;
      };
      /**
       * 实体的清除
       *
       */
      PointEntity.prototype.remove = function () {
          this.viewer.entities.remove(this.graphic);
      };
      return PointEntity;
  }());

  /**
   *编辑组件
   */
  var Edit = /** @class */ (function (_super) {
      __extends$3(Edit, _super);
      function Edit(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, minRadius: 50, maxRadius: Number.MAX_VALUE }, (options || {})), map) || this;
          /**
           * @ignore
           */
          _this._editMode = false;
          /**
           * @ignore
           */
          _this._vertices = [];
          /**
           * @ignore
           */
          _this._positions = [];
          return _this;
      }
      Object.defineProperty(Edit.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Edit.prototype.init = function () {
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.scene.canvas);
          this.initialized = true;
      };
      /**
       * 激活编辑组件
       * 二维可选，三维必传，二维如果编辑军事要素要素必传，
       * @param {Feature} feature 要编辑的要素
       */
      Edit.prototype.active = function (feature) {
          var _this = this;
          if (!defined$1(this.map)) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          if (!defined$1(Feature)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          this.deactive();
          this._editFeature = feature;
          if (Array.isArray(feature.get("plot")) && defined$1(feature.get("plotType"))) {
              feature.set("plot", createDraw(feature.get("plotType"), feature.get("plot")));
          }
          if (this._editFeature.type !== GeoJsonGeometryType.POINT) {
              // 添加编辑节点
              this.addVertices();
          }
          this._eventHandler.setInputAction(function (e) {
              _this._down(e);
          }, 0 /* LEFT_DOWN */);
          // 鼠标弹起事件-----
          this._eventHandler.setInputAction(this._up.bind(this), 1 /* LEFT_UP */);
          // 拖动点改变实体位置---
          this._eventHandler.setInputAction(function (e) {
              _this._move(e);
          }, 15 /* MOUSE_MOVE */);
          return this;
      };
      /**
       *
       * @ignore
       * @param e
       * 鼠标左键按下事件监听程序
       */
      Edit.prototype._down = function (e) {
          if (this._editFeature.type === GeoJsonGeometryType.POINT) {
              var obj = this.map.map.scene.pick(e.position);
              if (Cesium__namespace.defined(obj) && obj.id && this._editFeature.sourceFeature.entities.includes(obj.id)) {
                  // 获取到编辑要拖拽的节点---
                  this._selectedPosition = obj.id.position.getValue(Cesium__namespace.JulianDate.fromDate(new Date()));
                  // @ts-ignore
                  // this.map.map.container.style.cursor =
                  //   "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4jZXTO0sDQRTF8Z8xWIigIEF8dCKIIgQiptZGCFj4KGIU7Kz8FH4AeyvBSkRjYeEDtLGysRBsbCwsxEctEhQtZgNLTDbJhWnOzPnfO7NnO3K5nDZqBmW8oID3VBvmNI4xjGmcortVwCC6sIVKpOWx3ApgBDfC6Oco4RufuE03MQ/hGqPRKmMRq/jAYxJgAFcYi2kF7KNYFRpdIRN1Hq/Rv7AXF+oBMlHniRq9giVcJAH6cYmpOuYVnNV2iwP6InO2jrkofPd/FQf0oLdm/wdrOKlnjgPW8YZZPMXMJRw1MlcBKexEB18xF0E2cJhkJuQ7L7z8Ag6E+07iN5qoM8H/kBaSVa0s5oUH28VmkwGe00LStoU/7T5OFzKflNa7P7UfNc+pDPV+AAAAAElFTkSuQmCC),auto";
                  //  this.map.map.scene.screenSpaceCameraController.enableRotate = false;
                  this.map.dragPan(false);
                  this._selectedVertice = obj.id;
                  this.dispatchEvent({
                      type: BaseEventType.EDIT_START,
                      feature: this._editFeature
                  });
              }
          }
          else {
              var obj = this.map.map.scene.pick(e.position);
              var vertices = this._vertices;
              if (Cesium__namespace.defined(obj) && obj.id && vertices.includes(obj.id)) {
                  console.warn("down", vertices.includes(obj.id));
                  // 获取到编辑要拖拽的节点---
                  this._selectedPosition = obj.id.position.getValue(Cesium__namespace.JulianDate.fromDate(new Date()));
                  // @ts-ignore
                  // this.map.map.container.style.cursor =
                  //   "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABI0lEQVQ4jZXTO0sDQRTF8Z8xWIigIEF8dCKIIgQiptZGCFj4KGIU7Kz8FH4AeyvBSkRjYeEDtLGysRBsbCwsxEctEhQtZgNLTDbJhWnOzPnfO7NnO3K5nDZqBmW8oID3VBvmNI4xjGmcortVwCC6sIVKpOWx3ApgBDfC6Oco4RufuE03MQ/hGqPRKmMRq/jAYxJgAFcYi2kF7KNYFRpdIRN1Hq/Rv7AXF+oBMlHniRq9giVcJAH6cYmpOuYVnNV2iwP6InO2jrkofPd/FQf0oLdm/wdrOKlnjgPW8YZZPMXMJRw1MlcBKexEB18xF0E2cJhkJuQ7L7z8Ag6E+07iN5qoM8H/kBaSVa0s5oUH28VmkwGe00LStoU/7T5OFzKflNa7P7UfNc+pDPV+AAAAAElFTkSuQmCC),auto";
                  // this.map.map.scene.screenSpaceCameraController.enableRotate = false;
                  this.map.dragPan(false);
                  this._selectedVertice = obj.id;
                  this.dispatchEvent({
                      type: BaseEventType.EDIT_START,
                      feature: this._editFeature
                  });
              }
          }
      };
      /**
       *
       *@ignore
       * 鼠标左键弹出事件监听程序
       */
      Edit.prototype._up = function () {
          if (this._selectedPosition && this._selectedVertice) {
              this._selectedPosition = null;
              this._selectedVertice = null;
              this.map.dragPan(true);
              // @ts-ignore
              this.map.map.container.style.cursor = "default";
              this.dispatchEvent({
                  type: BaseEventType.EDIT_END,
                  feature: this._editFeature
              });
          }
      };
      /**
       *@ignore
       * @param event
       * 鼠标移动事件处理程序
       */
      Edit.prototype._move = function (event) {
          if (this._selectedPosition) {
              // 像素坐标转化为世界三维笛卡尔坐标
              var wp = pickPositionAndObj(this.map.map.scene, event.endPosition).cartesian3;
              if (!wp) {
                  return;
              }
              this._selectedPosition = wp;
              // 选中顶点的位置变更
              this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
              // 点要素时
              if (this._editFeature.type === GeoJsonGeometryType.POINT) {
                  this._editFeature.setCoordinates(cartesian3ToDegrees(wp));
                  return;
              }
              var index = this._vertices.indexOf(this._selectedVertice);
              this._positions.splice(index, 1, this._selectedPosition);
              if (this._editFeature.type === GeoJsonGeometryType.LINE_STRING) {
                  if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                      this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                      this._editFeature.setCoordinates(this._editFeature.get("plot").coordinates);
                  }
                  else {
                      this._editFeature.setCoordinates(cartesian3sToDegreesArray(this._positions));
                  }
              }
              if (this._editFeature.type === GeoJsonGeometryType.POLYGON) {
                  if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                      this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                      this._editFeature.setCoordinates(this._editFeature.get("plot").coordinates);
                  }
                  else {
                      this._editFeature.setCoordinates([cartesian3sToDegreesArray(this._positions)]);
                  }
              }
              if (this._editFeature.type === FeatureType.CIRCLE) {
                  if (index === 0) {
                      var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this._editFeature.get("plot").ellipsoidRaduis, 90).geometry.coordinates;
                      this._positions[1] = degreesToCartesian3(dragPointCoordinates);
                      this._vertices[0].position = new Cesium__namespace.ConstantPositionProperty(this._positions[0]);
                      this._vertices[1].position = new Cesium__namespace.ConstantPositionProperty(this._positions[1]);
                      // 判断半径是否超范围
                  }
                  else {
                      var _postions = cartesian3sToDegreesArray(this._positions);
                      var _radius = calculatesRadius(_postions[0], _postions[1]);
                      if (_radius <= this.options.minRadius / 1000) {
                          var _dragCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this.options.minRadius / 1000, 90).geometry.coordinates;
                          this._selectedPosition = degreesToCartesian3(_dragCoordinates);
                          this._positions.splice(index, 1, this._selectedPosition);
                          this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
                      }
                      if (_radius >= this.options.maxRadius / 1000) {
                          var _dragCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(cartesian3ToDegrees(this._positions[0])), this.options.maxRadius / 1000, 90).geometry.coordinates;
                          this._selectedPosition = degreesToCartesian3(_dragCoordinates);
                          this._positions.splice(index, 1, this._selectedPosition);
                          this._selectedVertice.position = new Cesium__namespace.ConstantPositionProperty(this._selectedPosition);
                      }
                  }
                  this._editFeature.get("plot").setPoints(cartesian3sToDegreesArray(this._positions));
                  this._editFeature.setRadius(this._editFeature.get("plot").ellipsoidRaduis * 1000);
                  this._editFeature.setCenter(this._editFeature.get("plot").center);
              }
              // 非编辑模式--
          }
          else {
              var obj = this.map.map.scene.pick(event.endPosition);
              if (Cesium__namespace.defined(obj) && obj.id) {
                  // @ts-ignore
                  this.map.map.container.style.cursor = "cursor:pointer;cursor: hand;";
              }
              else {
                  // @ts-ignore
                  this.map.map.container.style.cursor = "default";
              }
          }
      };
      /**
       * 设置顶点
       */
      Edit.prototype.addVertices = function () {
          var e_1, _a;
          // 该实体为点实体---
          // 该实体为多线实体
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === GeoJsonGeometryType.LINE_STRING) {
              // 军事标绘要素
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  this._positions = this._editFeature.coordinates.slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          // 该实体为多边形实体
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === GeoJsonGeometryType.POLYGON) {
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  this._positions = this._editFeature.coordinates[0].slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          // 该实体为圆
          if (Cesium__namespace.defined(this._editFeature) && this._editFeature.type === FeatureType.CIRCLE) {
              if (Cesium__namespace.defined(this._editFeature.get("plot"))) {
                  this._positions = this._editFeature.get("plot").getPoints().slice().map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
              else {
                  var center = this._editFeature.center;
                  var radius = this._editFeature.radius / 1000;
                  var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(center), radius, 90).geometry
                      .coordinates;
                  this._editFeature.set("plot", createDraw(DrawType.CIRCLE, [center, dragPointCoordinates]));
                  //在这做处理---圆可以反算
                  this._positions = [center, dragPointCoordinates].map(function (coordinate) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinate), false));
                  });
              }
          }
          try {
              // 添加顶点----
              for (var _b = __values(this._positions), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var _cartesian = _c.value;
                  var pt = new PointEntity(this.map.map, _cartesian, PointEntity.defaultStyle());
                  this._vertices.push(pt.graphic);
                  this.map.map.entities.add(pt.graphic);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * 删除编辑顶点
       * @private
       * @ignore
       */
      Edit.prototype._removeVertice = function () {
          var e_2, _a;
          try {
              for (var _b = __values(this._vertices), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var _entity = _c.value;
                  this.map.map.entities.remove(_entity);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this._vertices = [];
      };
      Edit.prototype.deactive = function () {
          this._removeVertice();
          this._eventHandler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
          this._eventHandler.removeInputAction(2 /* LEFT_CLICK */);
          this._eventHandler.removeInputAction(1 /* LEFT_UP */);
          this._eventHandler.removeInputAction(0 /* LEFT_DOWN */);
          this._eventHandler.removeInputAction(15 /* MOUSE_MOVE */);
          this._editFeature = undefined;
          return this;
      };
      /**
       * 注销该对象的绘图事件监听句柄
       * @ignore
       */
      Edit.prototype._destroy = function () {
          this._eventHandler = void 0;
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Edit.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          // @ts-ignore
          this.map.map.container.style.cursor = this._defaultCursor;
          this.map = undefined;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Edit;
  }(Component$1));

  /**
   * 绘制类别
   *
   * @enum {number}
   */
  var DrawTypeEnum;
  (function (DrawTypeEnum) {
      /**
       * 点
       */
      DrawTypeEnum["POINT"] = "point";
      /**
       * 面
       */
      DrawTypeEnum["POLYGON"] = "polygon";
      /**
       * 线
       */
      DrawTypeEnum["POLYLINE"] = "polyline";
  })(DrawTypeEnum || (DrawTypeEnum = {}));
  /**
   * 绘制组件
   */
  var Draw = /** @class */ (function (_super) {
      __extends$3(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, options || {}, map) || this;
          /**
           * @ignore
           * 草图
           */
          _this._tempGraphic = null;
          /**
           * @ignore
           */
          _this._positions = [];
          /**
           * @ignore
           */
          _this._vertices = [];
          /**
           * @ignore
           */
          _this._type = DrawTypeEnum.POINT;
          /**
           * @ignore
           */
          _this._tempPositions = [];
          /**
           * @ignore
           */
          _this._isShowTooltip = true;
          return _this;
      }
      Object.defineProperty(Draw.prototype, "isShowTooltip", {
          /**
           * @ignore
           */
          set: function (flag) {
              this._isShowTooltip = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Draw.prototype.init = function () {
          this._layer = this._options.layer;
          this._element = document.createElement("span");
          this._element.className = "mti-measure-tool mti-measure-tool-length";
          this._element.innerHTML = "单击地图绘制要素";
          this._overlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: this._element,
              offset: [5, -15]
          }, this.map);
          var _styleConfig = Cesium__namespace.defaultValue(this._options.style, {});
          if (!Cesium__namespace.defined(_styleConfig.point[0].heightReference)) {
              _styleConfig.point[0].heightReference = 1 /* CLAMP_TO_GROUND */;
          }
          if (!Cesium__namespace.defined(_styleConfig.polyline[0].clampToGround)) {
              _styleConfig.polyline[0].clampToGround = true;
          }
          if (!Cesium__namespace.defined(_styleConfig.polygon[0].clampToGround)) {
              _styleConfig.polygon[0].clampToGround = true;
          }
          this._style = _styleConfig;
          // 已经初始化
          this.initialized = true;
      };
      /**
       * 激活绘制组件
       * @param {string} type 绘制类型
       * @memberof Draw
       */
      Draw.prototype.active = function (type) {
          var _this = this;
          if (Cesium__namespace.defined(this._handler)) {
              this.deactive();
          }
          this._positions = [];
          this._type = type;
          // 激活绘制控件后修改鼠标样式
          this.map.map.scene.canvas.style.cursor = "crosshair";
          // 屏幕事件处理器
          this._handler = new Cesium__namespace.ScreenSpaceEventHandler(this.map.map.canvas);
          this._handler.setInputAction(function (e) {
              // 绘制点时
              if (_this._type === DrawTypeEnum.POINT) {
                  var pt = new PointEntity(_this.map.map, e.position, _this._style.point[0]);
                  _this._positions.push(pt.wp);
                  _this._tempGraphic = _this.map.map.entities.add(pt.graphic);
                  var _feature = new Point$1({ coordinates: cartesian3ToDegrees(pt.wp, _this.map) });
                  _this._layer && _this._layer.addFeature(_feature);
                  _this.dispatchEvent({
                      type: BaseEventType.DRAW_END,
                      target: _this,
                      feature: _feature
                  });
                  // 销毁事件监听----
                  _this.deactive();
              }
              else {
                  _this._element.innerHTML = "单击继续绘制,双击结束绘制";
                  _this.onClick(e);
              }
          }, 2 /* LEFT_CLICK */);
          this._handler.setInputAction(function (e) {
              _this.onMove(e);
          }, 15 /* MOUSE_MOVE */);
          if ([DrawTypeEnum.POLYLINE, DrawTypeEnum.POLYGON].includes(this._type)) {
              this._handler.setInputAction(function (e) {
                  var _feature = _this._createFeature();
                  if (!Cesium__namespace.defined(_feature)) {
                      return;
                  }
                  _this.deactive();
                  _this._layer && _this._layer.addFeature(_feature);
                  var wp = pickPositionAndObj(_this.map.map.scene, e.position).cartesian3;
                  _this.dispatchEvent({
                      type: BaseEventType.DRAW_END,
                      target: _this,
                      feature: _feature,
                      position: cartesian3ToDegrees(wp, _this.map)
                  });
              }, 3 /* LEFT_DOUBLE_CLICK */);
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._createFeature = function () {
          var _this = this;
          var _feature = null;
          var _coods = [];
          if (this._type === DrawTypeEnum.POLYGON) {
              if (this._positions.length > 2) {
                  _coods = this._positions.map(function (pos) {
                      var s = cartesian3ToDegrees(pos, _this.map);
                      return [s[0], s[1]];
                  });
                  _coods.push(_coods[0]);
                  _feature = new Polygon$1({ coordinates: [_coods] });
              }
          }
          if (this._type === DrawTypeEnum.POLYLINE) {
              if (this._positions.length > 1) {
                  _coods = this._positions.map(function (pos) {
                      var s = cartesian3ToDegrees(pos, _this.map);
                      return [s[0], s[1]];
                  });
                  _feature = new Polyline$1({ coordinates: _coods });
              }
          }
          return _feature;
      };
      /**
       *  鼠标单击事件回调
       * @param e
       * @ignore
       */
      Draw.prototype.onClick = function (e) {
          // 创建临时实体
          if (this._positions.length === 0) {
              this._createTemp();
          }
          var wp = pickPositionAndObj(this.map.map.scene, e.position).cartesian3;
          if (Cesium__namespace.defined(wp)) {
              this._positions.push(wp);
              // 是否保存顶点信息
              var pt = new PointEntity(this.map.map, wp, this._style.point[0]);
              this.map.map.entities.add(pt.graphic);
              this._vertices.push(pt.graphic);
          }
          // 添加节点触发节点增加事件---
          this.dispatchEvent({
              type: "nodeAdd",
              target: this,
              positions: this._positions
          });
      };
      /**
       * @ignore
       */
      Draw.prototype.onMove = function (e) {
          var wp = pickPositionAndObj(this.map.map.scene, e.endPosition).cartesian3;
          if (Cesium__namespace.defined(wp)) {
              var _position = cartesian3ToDegrees(wp, this.map);
              if (this._isShowTooltip) {
                  this._overlay.setPosition(_position);
              }
              if (this._type === DrawTypeEnum.POINT) {
                  return;
              }
              else {
                  this._tempPositions = this._positions.concat([wp]);
              }
              if (this._positions.length >= 1) {
                  // 点类型直接返回-----
                  // 添加节点移动触发事件
                  this.dispatchEvent({
                      type: "nodeMove",
                      target: this,
                      positions: this._tempPositions
                  });
              }
          }
      };
      /**
       * @ignore
       */
      Draw.prototype._createTemp = function () {
          var _this = this;
          if (this._type === DrawTypeEnum.POLYGON) {
              var hierarchy = new Cesium__namespace.CallbackProperty(function () {
                  return new Cesium__namespace.PolygonHierarchy(_this._tempPositions);
              }, false);
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  return __spreadArray$1(__spreadArray$1([], __read(_this._tempPositions), false), [_this._tempPositions[0]], false);
              }, false);
              var _style = transformParams(this._style.polygon[0]);
              var _lstyle = transformParams(this._style.polyline[0]);
              this._tempGraphic = this.map.map.entities.add(new Cesium__namespace.Entity({
                  polygon: new Cesium__namespace.PolygonGraphics(__assign$1({ hierarchy: hierarchy, material: _style.type === StyleItemType.COLOR
                          ? styleItemFillColorToColorMaterialProperty(_style)
                          : styleItemToImageMaterialProperty(_style) }, _style)),
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_lstyle) }, _lstyle))
              }));
          }
          if (this._type === DrawTypeEnum.POLYLINE) {
              var pos = new Cesium__namespace.CallbackProperty(function () {
                  return _this._tempPositions;
              }, false);
              var _style = transformParams(this._style.polyline[0]);
              this._tempGraphic = this.map.map.entities.add(new Cesium__namespace.Entity({
                  polyline: new Cesium__namespace.PolylineGraphics(__assign$1({ positions: pos, material: styleItemBorderColorToColorMaterialProperty(_style) }, _style))
              }));
          }
      };
      /**
       * 移除绘制的对象
       * @private
       * @ignore
       */
      Draw.prototype._removeGraphic = function () {
          if (this._tempGraphic) {
              this.map.map.entities.remove(this._tempGraphic);
              this._tempGraphic = undefined;
          }
          this._removeVertices();
          this._positions = [];
          this._tempPositions = [];
      };
      /**
       * 移除顶点
       * @private
       * @ignore
       */
      Draw.prototype._removeVertices = function () {
          var e_1, _a;
          if (this._vertices) {
              try {
                  for (var _b = __values(this._vertices), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var _entity = _c.value;
                      this.map.map.entities.remove(_entity);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          this._vertices = [];
      };
      // 交互失效
      Draw.prototype.deactive = function () {
          if (this._handler && !this._handler.isDestroyed()) {
              this._handler.getInputAction(2 /* LEFT_CLICK */) &&
                  this._handler.removeInputAction(2 /* LEFT_CLICK */);
              this._handler.getInputAction(3 /* LEFT_DOUBLE_CLICK */) &&
                  this._handler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
              this._handler.getInputAction(15 /* MOUSE_MOVE */) &&
                  this._handler.removeInputAction(15 /* MOUSE_MOVE */);
              this._handler.destroy();
          }
          this._overlay.hide();
          this.map.map.scene.canvas.style.cursor = "default";
          this._handler = undefined;
          this._removeGraphic();
          this._element.innerHTML = "单击地图绘制要素";
      };
      /**
       * @ignore
       */
      Draw.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Draw.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._overlay, false);
          this._element = undefined;
          this.map = undefined;
      };
      return Draw;
  }(Component$1));

  /**
   * 测量组件
   *
   * @class Measure
   */
  var Measure = /** @class */ (function (_super) {
      __extends$3(Measure, _super);
      // 构造函数---
      function Measure(options, map) {
          var _this = _super.call(this, __assign$1({ measureStyle: __spreadArray$1(__spreadArray$1([], __read(Measure_STYLE.draw), false), __read(Measure_STYLE.finsh), false) }, options), map) || this;
          /**
           * @ignore
           */
          _this._isActive = false;
          /**
           * @ignore
           */
          _this._uuids = [];
          /**
           * @ignore
           */
          _this._components = [];
          /**
           * @ignore
           */
          _this.isFirst = true;
          return _this;
      }
      Object.defineProperty(Measure.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Measure.prototype.init = function () {
          this.initialized = true;
          this._measureType = "";
          this._element = document.createElement("span");
          this._element.className = "mti-measure-tool mti-measure-tool-length";
          this._overlay = new Overlay({
              id: "popup",
              element: this._element,
              offset: [5, -60]
          }, this.map);
          this._tipElement = document.createElement("span");
          this._tipElement.className = "mti-measure-tool mti-measure-tool-length";
          this._tipOverlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: this._tipElement,
              offset: [5, -30]
          }, this.map);
          this._layer = new VectorLayer({
              style: this.options.measureStyle.slice(3).map(function (style) {
                  style.heightReference = 1 /* CLAMP_TO_GROUND */;
                  return style;
              })
          }, this.map);
      };
      /**
       * 添加到地球
       * 重写父类方法---
       * @ignore
       */
      Measure.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
      };
      /**
       * 添加绘制交互组件
       * @param type
       * @ignore
       */
      Measure.prototype._addDrawInteractions = function (type) {
          this._draw = new Draw({
              style: {
                  point: [__assign$1({ heightReference: 1 }, this.options.measureStyle[0])],
                  polyline: [__assign$1({ heightReference: 1 }, this.options.measureStyle[1])],
                  polygon: [__assign$1({ heightReference: 1 }, this.options.measureStyle[2])]
              }
          }, this.map);
          var uniqueKey = Cesium__namespace.createGuid();
          this._draw.set("uuid", uniqueKey);
          this._uuids.push(uniqueKey);
          this._draw.on(BaseEventType.DRAW_END, this._drawEndHandle.bind(this));
          this._draw.on("nodeAdd", this._nodeAdded.bind(this));
          this._draw.on("nodeMove", this._nodeMove.bind(this));
          var _type;
          if (type === MeasureType.DISTANCE) {
              _type = DrawTypeEnum.POLYLINE;
          }
          if (type === MeasureType.AREA) {
              _type = DrawTypeEnum.POLYGON;
          }
          this._draw.active(_type);
          this._draw.set("type", type);
      };
      /**
       * 增加节点时触发的回调
       * @param event
       * @ignore
       */
      Measure.prototype._nodeAdded = function (event) {
          this._tipElement.innerHTML = "单击继续测量，双击结束测量";
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _text = "起点";
              var _position = cartesian3ToDegrees(event.positions[0]);
              if (event.positions.length >= 2) {
                  this._distance = parseFloat(getSpaceDisfromCartesian3Array(event.positions));
                  this._overlay.hide();
                  _text = getSpaceDisfromCartesian3Array(event.positions);
                  _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              }
              var measureResult = document.createElement("span");
              measureResult.className = "mti-measure-tool-overlay-label";
              measureResult.innerHTML = _text;
              var _overlay = new Overlay({
                  id: Cesium__namespace.createGuid(),
                  element: measureResult,
                  offset: [0, -25],
                  positioning: Positioning.TOP_LEFT
              }, this.map);
              _overlay.setPosition(_position);
              _overlay.set("uuid", this._draw.get("uuid"));
              _overlay.set("distance", _text);
          }
      };
      /**
       * 节点移动时的回调
       * @param event
       * @ignore
       */
      Measure.prototype._nodeMove = function (event) {
          // 测量面积
          if (this._draw.get("type") === MeasureType.AREA && event.positions.length > 2) {
              var _positions = cartesian3sToDegreesArray(event.positions);
              var _text = getArea(_positions);
              this._element.innerHTML = _text;
              var _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              this._overlay.setPosition(_position);
          }
          // 测面长度
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _position = cartesian3ToDegrees(event.positions[event.positions.length - 1]);
              var _text = getSpaceDisfromCartesian3Array(event.positions);
              this._element.innerHTML = _text;
              this._overlay.setPosition(_position);
          }
      };
      /**
       * 绘制完成时的回调
       * @param event
       * @ignore
       */
      Measure.prototype._drawEndHandle = function (event) {
          var _this = this;
          var _overlays = this.map.getOverlays().filter(function (a) {
              return a.get("uuid") === _this._draw.get("uuid");
          });
          var feature = event.feature;
          feature.set("uuid", this._draw.get("uuid"));
          this._layer.addFeature(feature);
          this.map.removeOverlay(_overlays[_overlays.length - 1]);
          this.map.removeOverlay(_overlays[_overlays.length - 2]);
          var _tip = "";
          if (this._draw.get("type") === MeasureType.AREA) {
              var _positions = event.feature.coordinates[0];
              _positions[_positions.length - 1];
              var _text = getArea(_positions);
              _tip = "总面积：<span class='measure-end-label'>" + _text + "</span>";
          }
          if (this._draw.get("type") === MeasureType.DISTANCE) {
              var _positions = event.feature.coordinates;
              _positions[_positions.length - 1];
              var _text = getSpaceDisfromCartesian3Array(_positions.map(function (_position) {
                  var _a;
                  return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_position), false));
              }));
              _tip = "总长：<span class='measure-end-label'>" + _text + "</span>";
          }
          var measureResult = document.createElement("span");
          measureResult.className = "mti-measure-tool-end-overlay-label";
          measureResult.innerHTML = _tip;
          var _resultOverlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: measureResult,
              offset: [-1, 0],
              positioning: Positioning.TOP_LEFT
          }, this.map);
          _resultOverlay.set("uuid", this._draw.get("uuid"));
          this._overlay.hide();
          _resultOverlay.setPosition(event.position);
          this._tipOverlay.hide();
          this.isFirst = true;
          this.addMeasureRemoveButton(event.position);
          this.removeLastInteraction_();
          this.dispatchEvent(BaseEventType.MEASURE_END);
          this.map.unByKey(this._moveListener);
          this._moveListener = null;
      };
      /**
       * 添加单例清除按钮
       * @param coordinate
       * @ignore
       */
      Measure.prototype.addMeasureRemoveButton = function (_position) {
          var imageButton = document.createElement("img");
          imageButton.src =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEYzMzc1RDY3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEYzMzc1RDc3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0RjMzNzVENDdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0RjMzNzVENTdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsDx84AAAAC3SURBVHjavJIxDoMwDEV/ok5wDCbu0DvAdUBIwMLFSs/AxDXY6tZ2SCGVUikd+ifn20+2k5hHVd0AXJGmGQw+UyWMxY8KQGpbUNcB23aYHIsnuSgIy8dlAQ2DgwWSmD0YE5ReAq5pQOMIrKsDRByjKGC/dsxz2L7XQgU8JB7n4qDoY6SYF4J+p72T7/zeOXqr03SMx8XnsTUX7UgElKVCyDK3s8Tsae6sv/8ceceZ6jr1k99fAgwAsZy0Sa2HgDcAAAAASUVORK5CYII=";
          imageButton.style.cursor = "pointer";
          imageButton.title = "清除测量结果";
          imageButton.onclick = (function (id) {
              return function () {
                  this._removeMeasure(id);
                  this.dispatchEvent(BaseEventType.CLEAR);
              };
          })(this._draw.get("uuid")).bind(this);
          var _overlay = new Overlay({
              id: Cesium__namespace.createGuid(),
              element: imageButton,
              offset: [-20, 0],
              positioning: Positioning.CENTER_LEFT
          }, this.map);
          _overlay.setPosition(_position);
          _overlay.set("uuid", this._draw.get("uuid"));
      };
      /**
       * 移除测量结果
       * @param uuid
       * @ignore
       */
      Measure.prototype._removeMeasure = function (uuid) {
          var overlays = this.map.getOverlays();
          if (overlays && Array.isArray(overlays)) {
              var length_1 = overlays.length;
              // @ts-ignore
              for (var j = 0, i = 0; j < length_1; j++) {
                  i++;
                  if (overlays[length_1 - i] &&
                      overlays[length_1 - i] instanceof Overlay &&
                      overlays[length_1 - i].get("uuid") === uuid) {
                      this.map.removeOverlay(overlays[length_1 - i]);
                  }
              }
          }
          if (this._layer) {
              var features = this._layer.getFeatures();
              features.forEach(function (feat) {
                  if (feat.get("uuid") === uuid) {
                      this._layer.removeFeature(feat);
                  }
              }, this);
          }
      };
      /**
       * 移除所有测量结果
       */
      Measure.prototype.clear = function () {
          var _this = this;
          if (this._isActive) {
              console.warn("绘制完成，在清除");
              return;
          }
          this._uuids.forEach(function (id) {
              _this._removeMeasure(id);
          });
          return this;
      };
      /**
       * 激活测量组件
       *
       * @param {string} type 量算类型
       */
      Measure.prototype.active = function (type) {
          var _this = this;
          this.removeLastInteraction_();
          this._isActive = true;
          this._type = type;
          this._addDrawInteractions(type);
          this._draw.isShowTooltip = false;
          this._moveListener = this.map.on(BaseEventType.MOUSE_MOVE, function (event) {
              if (_this._isActive) {
                  if (_this.isFirst) {
                      _this._tipElement.innerHTML = "单击地图测量";
                      _this.isFirst = false;
                  }
                  _this._tipOverlay.setPosition(event.coordinate);
              }
          });
          return this;
      };
      /**
       * 失效控件
       */
      Measure.prototype.deactive = function () {
          if (this._isActive) {
              this._removeMeasure(this._draw.get("uuid"));
              this.removeLastInteraction_();
              this._isActive = false;
              this._overlay.hide();
              this._tipOverlay.hide();
          }
          return this;
      };
      /**
       * 移除上一次激活的工具
       * @ignore
       */
      Measure.prototype.removeLastInteraction_ = function () {
          if (this._draw && this.map) {
              this.map.removeComponent(this._draw);
              this._isActive = false;
          }
      };
      /**
       * @ignore
       */
      Measure.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * @ignore
       */
      Measure.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.removeLastInteraction_();
          this.clear();
          this._draw = null;
          this.initialized = false;
          this._measureType = "";
          this.map.removeOverlay(this._overlay);
          this.map.removeOverlay(this._tipOverlay);
          this._element = undefined;
          this._tipElement = undefined;
          this.map = undefined;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Measure;
  }(Component$1));

  var WALL_STYLE_TYPE = [
      StyleItemType.COLOR,
      StyleItemType.IMAGE,
      StyleItemType.LINEAR_GRADIENT,
      StyleItemType.LINEAR_FOW
  ];
  /**
   * 墙组件
   *
   * [cesium]
   */
  var Wall = /** @class */ (function (_super) {
      __extends$3(Wall, _super);
      function Wall(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true }, options)) || this;
          _this._visible = _this.options.visible;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Wall.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Wall.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Wall.prototype.init = function () {
          var e_1, _a, _b, e_2, _c, _d, e_3, _e, e_4, _f, _g;
          this._entities = [];
          this.initialized = true;
          var _h = this.options, height = _h.height, data = _h.data;
          var style = this.options.style;
          style = cesiumStyleItemListInit(style);
          try {
              for (var _j = __values(data.features), _k = _j.next(); !_k.done; _k = _j.next()) {
                  var feature = _k.value;
                  switch (feature.geometry.type) {
                      case GeoJsonGeometryType.LINE_STRING:
                          (_b = this._entities).push.apply(_b, __spreadArray$1([], __read(buildEntities.call(this, feature.geometry.coordinates, style, height)), false));
                          break;
                      case GeoJsonGeometryType.MULTI_LINE_STRING:
                      case GeoJsonGeometryType.POLYGON:
                          try {
                              for (var _l = (e_2 = void 0, __values(feature.geometry.coordinates)), _m = _l.next(); !_m.done; _m = _l.next()) {
                                  var lineString = _m.value;
                                  (_d = this._entities).push.apply(_d, __spreadArray$1([], __read(buildEntities.call(this, lineString, style, height)), false));
                              }
                          }
                          catch (e_2_1) { e_2 = { error: e_2_1 }; }
                          finally {
                              try {
                                  if (_m && !_m.done && (_c = _l.return)) _c.call(_l);
                              }
                              finally { if (e_2) throw e_2.error; }
                          }
                          break;
                      case GeoJsonGeometryType.MULTI_POLYGON:
                          try {
                              for (var _o = (e_3 = void 0, __values(feature.geometry.coordinates)), _p = _o.next(); !_p.done; _p = _o.next()) {
                                  var polygon = _p.value;
                                  try {
                                      for (var _q = (e_4 = void 0, __values(polygon)), _r = _q.next(); !_r.done; _r = _q.next()) {
                                          var iterator = _r.value;
                                          (_g = this._entities).push.apply(_g, __spreadArray$1([], __read(buildEntities.call(this, iterator, style, height)), false));
                                      }
                                  }
                                  catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                  finally {
                                      try {
                                          if (_r && !_r.done && (_f = _q.return)) _f.call(_q);
                                      }
                                      finally { if (e_4) throw e_4.error; }
                                  }
                              }
                          }
                          catch (e_3_1) { e_3 = { error: e_3_1 }; }
                          finally {
                              try {
                                  if (_p && !_p.done && (_e = _o.return)) _e.call(_o);
                              }
                              finally { if (e_3) throw e_3.error; }
                          }
                          break;
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_k && !_k.done && (_a = _j.return)) _a.call(_j);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       * @param map
       */
      Wall.prototype.addTo = function (map) {
          var e_5, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.add(entity);
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_5) throw e_5.error; }
          }
      };
      /**
       * @ignore
       */
      Wall.prototype.remove = function (destroy) {
          var e_6, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.remove(entity);
              }
          }
          catch (e_6_1) { e_6 = { error: e_6_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_6) throw e_6.error; }
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Wall.prototype._destroy = function () {
          var e_7, _a;
          this.remove();
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  Cesium__namespace.destroyObject(entity);
              }
          }
          catch (e_7_1) { e_7 = { error: e_7_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_7) throw e_7.error; }
          }
          this._entities = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Wall.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `doubleclick` |  左键双击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousedown` |  左键按下  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mouseup` |  左键抬起  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `rightclick` |  右键单击  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `mousemove` |  鼠标移动  |  (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Wall.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示墙组件
       */
      Wall.prototype.show = function () {
          var e_8, _a;
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = true;
              }
          }
          catch (e_8_1) { e_8 = { error: e_8_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_8) throw e_8.error; }
          }
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Wall.prototype.hide = function () {
          var e_9, _a;
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = false;
              }
          }
          catch (e_9_1) { e_9 = { error: e_9_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_9) throw e_9.error; }
          }
          return this;
      };
      return Wall;
  }(Component$1));
  function buildWallPositions(coordinates, height) {
      if (coordinates[0].length > 2) {
          return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(coordinates.flat());
      }
      else if (coordinates[0].length === 2 && Cesium__namespace.defined(height)) {
          return Cesium__namespace.Cartesian3.fromDegreesArrayHeights(coordinates.reduce(function (acc, val) { return acc.concat(val, height); }, []));
      }
      throw new Error(ErrorNotification.WALL_COORDINATES_NEED_HEIGHT);
  }
  /** 构建实体 */
  function buildEntities(coordinates, style, height) {
      var _this = this;
      var positions = buildWallPositions(coordinates, height);
      return style
          .filter(function (i) { return WALL_STYLE_TYPE.includes(i.type); })
          .map(function (styleItem) {
          var entity = new Cesium__namespace.Entity({
              show: _this.visible,
              wall: __assign$1({ positions: positions, material: styleItem.type === StyleItemType.COLOR
                      ? styleItemBorderColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem) }, styleItem)
          });
          entity[COMPONENT_LINK] = _this;
          return entity;
      });
  }

  /**
   * 鼠标交互三角测量工具组件
   *
   * @class Triangulation
   */
  var Triangulation = /** @class */ (function (_super) {
      __extends$3(Triangulation, _super);
      function Triangulation(options, map) {
          var _this = _super.call(this, __assign$1({ color: [255, 255, 0, 1], width: 2, label: {} }, (options || {})), map) || this;
          /**
           * @ignore
           */
          _this._entities = [];
          /**
           * @ignore
           */
          _this._active = false; // 是否处于激活状态
          /**
           * @ignore
           */
          _this.interactivePoint = []; // 鼠标点击两次的点
          /**
           * @ignore
           */
          _this._positions = [];
          /**
           * @ignore
           */
          _this._overlayerIds = [];
          /**
           * @ignore
           */
          _this._labelPoint = [
              { type: "a", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "b", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "c", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 }
          ];
          return _this;
      }
      /**
       * @ignore
       */
      Triangulation.prototype.init = function () {
          var e_1, _a, _b, _c;
          this.times = 0;
          var label = __assign$1({ font: "14px sans-serif", outlineWidth: 3, horizontalOrigin: -1 /* RIGHT */, verticalOrigin: 1 /* BOTTOM */, style: 2 /* FILL_AND_OUTLINE */ }, this.options.label);
          try {
              for (var _d = __values(Object.keys(label)), _e = _d.next(); !_e.done; _e = _d.next()) {
                  var key = _e.value;
                  var val = label[key];
                  if (Array.isArray(val)) {
                      if (val.length === 2) {
                          label[key] = new ((_b = Cesium__namespace.Cartesian2).bind.apply(_b, __spreadArray$1([void 0], __read(val), false)))();
                      }
                      else {
                          label[key] = Cesium__namespace.Color.fromAlpha((_c = Cesium__namespace.Color).fromBytes.apply(_c, __spreadArray$1([], __read(val), false)), val.slice(3, 4)[0]);
                      }
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
              }
              finally { if (e_1) throw e_1.error; }
          }
          this._options.label = label;
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Triangulation.prototype._initEvent = function () {
          this._canvas = this.map.map.scene.canvas;
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(this._canvas);
          this._eventHandler.setInputAction(this._mouseClick.bind(this), 2 /* LEFT_CLICK */);
          this._eventHandler.setInputAction(this._mouseMove.bind(this), 15 /* MOUSE_MOVE */);
          this._eventHandler.setInputAction(this._mouseDoubleClick.bind(this), 3 /* LEFT_DOUBLE_CLICK */);
      };
      /**
       * @ignore
       */
      Triangulation.prototype._removeEvent = function () {
          if (this._eventHandler) {
              this._eventHandler.removeInputAction(0 /* LEFT_DOWN */);
              this._eventHandler.removeInputAction(1 /* LEFT_UP */);
              this._eventHandler.removeInputAction(15 /* MOUSE_MOVE */);
              this._eventHandler.removeInputAction(3 /* LEFT_DOUBLE_CLICK */);
              this._eventHandler.removeInputAction(2 /* LEFT_CLICK */);
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseClick = function (mousement) {
          var position = pickPositionAndObj(this.map.map.scene, mousement.position).cartesian3;
          if (position) {
              if (this._positions.length === 0) {
                  this._positions.push(position, position);
                  this._buildTriangle();
                  this._buildLabel();
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseDoubleClick = function (mousement) {
          var position = pickPositionAndObj(this.map.map.scene, mousement.position).cartesian3;
          if (position) {
              if (this._positions.length > 0) {
                  this._active = false;
                  this.fireEvent();
                  this.closeEdit();
                  this.addCloseBtn(position);
                  this._canvas.style.cursor = this._cursor;
                  this._positions = [];
                  this._removeEvent();
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype.addCloseBtn = function (position) {
          var _this = this;
          this.times += 1;
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          var self = this;
          var map = this.map.map;
          var endPnt = position;
          var closeBtn = document.createElement("div");
          closeBtn.id = "mti3d-closeBtnId" + this.times;
          this._overlayerIds.push("mti3d-closeBtnId" + this.times);
          this.map.stopEventOverlayContainer.appendChild(closeBtn);
          closeBtn.innerHTML = "x";
          closeBtn.style.cssText = "\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    z-index: 9999;\n    border: 1px solid rgb(255, 0, 0);\n    width: 16px;\n    height: 16px;\n    line-height: 11px;\n    text-align: center;\n    cursor: pointer;\n    color: rgb(255, 0, 0);\n    background-color: #f1f1f1;\n    box-shadow: 0.1px 0.1px 5px 1px rgba(0,0,0,0.3);\n    box-sizing: border-box;";
          closeBtn.onclick = (function (_entitys) {
              return function () {
                  _entitys.forEach(function (_entity) {
                      _this.map.map.entities.remove(_entity);
                  });
                  closeBtn.remove();
                  var index_ = _this._overlayerIds.indexOf(closeBtn.id);
                  _this._overlayerIds.splice(index_, 1);
              };
          })(this._entities.slice(this._entities.length - 4, this._entities.length));
          this.showCloseBtn(map, endPnt, closeBtn);
          map.scene.postRender.addEventListener(function () {
              self.showCloseBtn(map, endPnt, closeBtn);
          });
      };
      /**
       * @ignore
       */
      Triangulation.prototype.showCloseBtn = function (viewer, endPnt, closeBtn) {
          if (endPnt) {
              var wp = Cesium__namespace.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, endPnt);
              if (Cesium__namespace.defined(wp)) {
                  closeBtn.style.transform = "translate3d(".concat(wp.x + 10, "px, ").concat(wp.y - 10, "px, 0)");
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._mouseMove = function (movement) {
          if (this._positions.length > 0) {
              var endCartesian3 = pickPositionAndObj(this.map.map.scene, movement.endPosition).cartesian3;
              if (endCartesian3) {
                  this._positions.splice(1, 1, endCartesian3);
              }
          }
      };
      /**
       * @ignore
       */
      Triangulation.prototype._buildTriangle = function () {
          var _a;
          this._editingEntity = new Cesium__namespace.Entity({
              polyline: new Cesium__namespace.PolylineGraphics({
                  width: this._options.width,
                  positions: new Cesium__namespace.CallbackProperty(this._trianglePositions.bind(this)(), false),
                  material: new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.fromAlpha((_a = Cesium__namespace.Color).fromBytes.apply(_a, __spreadArray$1([], __read(this._options.color), false)), this._options.color.slice(3, 4)[0]))
              })
          });
          this.map.map.entities.add(this._editingEntity);
      };
      /**
       * @ignore
       */
      Triangulation.prototype._buildLabel = function () {
          var _a;
          var _this = this;
          var labelPoint = this._labelPoint;
          (_a = this._entities).push.apply(_a, __spreadArray$1([], __read(labelPoint.map(function (point) {
              return _this.map.map.entities.add(new Cesium__namespace.Entity({
                  // @ts-ignore
                  position: new Cesium__namespace.CallbackProperty(function () {
                      return point.position;
                  }, false),
                  label: new Cesium__namespace.LabelGraphics(__assign$1({ text: new Cesium__namespace.CallbackProperty(function () {
                          return point.text;
                      }, false) }, _this._options.label))
              }));
          })), false));
      };
      /**
       * @ignore
       */
      Triangulation.prototype.fireEvent = function () {
          var e_2, _a;
          var _b = __read(this._positions, 2), startCartesian3 = _b[0], endCartesian3 = _b[1];
          var start = Cesium__namespace.Cartographic.fromCartesian(startCartesian3);
          var end = Cesium__namespace.Cartographic.fromCartesian(endCartesian3);
          var event = {
              type: BaseEventType.MEASURE_END,
              startPoint: [Cesium__namespace.Math.toDegrees(start.longitude), Cesium__namespace.Math.toDegrees(start.latitude), start.height],
              endPoint: [Cesium__namespace.Math.toDegrees(end.longitude), Cesium__namespace.Math.toDegrees(end.latitude), end.height]
          };
          try {
              for (var _c = __values(this._labelPoint), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var point = _d.value;
                  if (point.type === "a") {
                      // @ts-ignore
                      event.height = point.distance;
                  }
                  else if (point.type === "b") {
                      // @ts-ignore
                      event.short = point.distance;
                  }
                  else {
                      // @ts-ignore
                      event.long = point.distance;
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this.dispatchEvent(event);
      };
      /**
       * @ignore
       */
      Triangulation.prototype.closeEdit = function () {
          this._entities.push(this._editingEntity);
          this._positions = [];
          this._labelPoint = [
              { type: "a", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "b", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 },
              { type: "c", position: new Cesium__namespace.Cartesian3(), text: "", distance: 0 }
          ];
      };
      /**
       * @ignore
       */
      Triangulation.prototype._trianglePositions = function () {
          var positions = this._positions;
          var labelPoint = this._labelPoint;
          return function () {
              var e_3, _a;
              var _b = __read(positions, 2), startCartesian3 = _b[0], endCartesian3 = _b[1];
              // 起始点转化为经纬度高度位置
              var startCartographic = Cesium__namespace.Cartographic.fromCartesian(startCartesian3);
              // 终点转化为经纬度高度位置
              var endCartographic = Cesium__namespace.Cartographic.fromCartesian(endCartesian3);
              var centerCartographic;
              var bc;
              if (startCartographic.height > endCartographic.height) {
                  centerCartographic = endCartographic.clone();
                  centerCartographic.height = startCartographic.height;
                  bc = startCartographic.clone();
              }
              else {
                  centerCartographic = startCartographic.clone();
                  centerCartographic.height = endCartographic.height;
                  bc = endCartographic.clone();
              }
              var height = Math.abs(endCartographic.height - startCartographic.height);
              try {
                  for (var labelPoint_1 = __values(labelPoint), labelPoint_1_1 = labelPoint_1.next(); !labelPoint_1_1.done; labelPoint_1_1 = labelPoint_1.next()) {
                      var label = labelPoint_1_1.value;
                      if (label.type === "a") {
                          label.position = centerCartographic.clone();
                          // @ts-ignore
                          label.position.height -= height / 2;
                          // @ts-ignore
                          label.position = Cesium__namespace.Cartographic.toCartesian(label.position);
                          label.text = numberToString(height);
                          label.distance = height;
                      }
                      else if (label.type === "b") {
                          label.distance = getSpaceDistance(centerCartographic, bc);
                          label.text = numberToString(label.distance);
                          label.position = Cesium__namespace.Cartographic.toCartesian(new Cesium__namespace.Cartographic((centerCartographic.longitude + bc.longitude) / 2, (centerCartographic.latitude + bc.latitude) / 2, centerCartographic.height));
                      }
                      else {
                          label.distance = getSpaceDistance(endCartographic, startCartographic);
                          label.text = numberToString(label.distance);
                          label.position = centerCartographic.clone();
                          // @ts-ignore
                          label.position.height -= height / 2;
                          // @ts-ignore
                          label.position.longitude = (startCartographic.longitude + endCartographic.longitude) / 2;
                          // @ts-ignore
                          label.position.latitude = (startCartographic.latitude + endCartographic.latitude) / 2;
                          // @ts-ignore
                          label.position = Cesium__namespace.Cartographic.toCartesian(label.position);
                      }
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (labelPoint_1_1 && !labelPoint_1_1.done && (_a = labelPoint_1.return)) _a.call(labelPoint_1);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
              return [startCartesian3, endCartesian3, Cesium__namespace.Cartographic.toCartesian(centerCartographic), startCartesian3];
          };
      };
      /**
       * 激活三角测量工具
       *
       * @memberof Triangulation
       */
      Triangulation.prototype.active = function () {
          if (this._active) {
              return;
          }
          this._active = true;
          this._initEvent();
          this._cursor = this._canvas.style.cursor;
          this._canvas.style.cursor = "crosshair";
          return this;
      };
      Triangulation.prototype.deactive = function () {
          var _this = this;
          if (this._active === false) {
              return this;
          }
          this._active = false;
          this._removeEvent();
          (function (_entitys) {
              _entitys.forEach(function (_entity) {
                  _this.map.map.entities.remove(_entity);
              });
          })(this._entities.slice(this._entities.length - 3, this._entities.length));
          this._editingEntity && this.map.map.entities.remove(this._editingEntity);
          this._canvas.style.cursor = this._cursor;
          this._positions = [];
          return this;
      };
      /**
       * 清除当前测量结果
       *
       * @memberof Triangulation
       */
      Triangulation.prototype.clear = function () {
          do {
              // 从数组中删除最后一个元素并返回该元素
              var entity = this._entities.pop();
              if (entity) {
                  this.map.map.entities.remove(entity);
              }
              else {
                  break;
              }
          } while (true);
          this._editingEntity &&
              this.map.map.entities.contains(this._editingEntity) &&
              this.map.map.entities.remove(this._editingEntity);
          this._positions = [];
          this._overlayerIds.forEach(function (id) {
              document.getElementById(id) && document.getElementById(id).remove();
          });
          this._overlayerIds = [];
          return this;
      };
      /**
       * 资源销毁
       *
       * @memberof Triangulation
       * @ignore
       */
      Triangulation.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      Triangulation.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.clear();
          this._removeEvent();
          this._canvas && (this._canvas.style.cursor = this._cursor);
          this.map = void 0;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Triangulation.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Triangulation.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Triangulation;
  }(Component$1));
  function numberToString(num) {
      if (num < 1000) {
          return num.toFixed(2) + "米";
      }
      else {
          return (num / 1000).toFixed(2) + "千米";
      }
  }

  var Snap = /** @class */ (function (_super) {
      __extends$3(Snap, _super);
      function Snap(options, map) {
          var _this = _super.call(this, __assign$1({ pixelTolerance: 10 }, (options || {})), map) || this;
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _this;
      }
      Snap.prototype.active = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.deactive = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.addFeatures = function (features) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.removeFeatures = function (features) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      Snap.prototype.init = function () {
          this.initialized = true;
      };
      Snap.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
          }
          this.map = undefined;
      };
      Snap.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snap;
  }(Component$1));

  /**
   * 扩散圆组件
   */
  var RippleCircle = /** @class */ (function (_super) {
      __extends$3(RippleCircle, _super);
      function RippleCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, color: "rgba(255,0,0,1)", height: 0, duration: 3, image: CIRCLE_WHITE_IMAGE }, options), map) || this;
      }
      Object.defineProperty(RippleCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RippleCircle.prototype.init = function () {
          this.initialized = true;
          var op = __assign$1({}, this.options);
          delete op.center;
          delete op.radius;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.RIPPLE }, op)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * 从地球移除
       * @ignore
       */
      RippleCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RippleCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RippleCircle;
  }(Component$1));

  /**
   * 旋转圆组件
   */
  var RotateCircle = /** @class */ (function (_super) {
      __extends$3(RotateCircle, _super);
      function RotateCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, duration: 3, color: "rgba(255,255,255,1)", reverse: false }, options), map) || this;
      }
      Object.defineProperty(RotateCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RotateCircle.prototype.init = function () {
          this.initialized = true;
          var op = __assign$1({}, this.options);
          delete op.center;
          delete op.radius;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.ROTATE }, op)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * 从地球移除
       * @ignore
       */
      RotateCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RotateCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RotateCircle;
  }(Component$1));

  /**
   * 右键菜单组件
   */
  var ContextMenu = /** @class */ (function (_super) {
      __extends$3(ContextMenu, _super);
      function ContextMenu(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(ContextMenu.prototype, "autoClose", {
          get: function () {
              return this._autoClose;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "theme", {
          get: function () {
              return this._theme;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "target", {
          /**
           * 绑定对象
           *
           * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
           */
          get: function () {
              return this._target;
          },
          enumerable: false,
          configurable: true
      });
      ContextMenu.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var _a = this.options, theme = _a.theme, autoClose = _a.autoClose, list = _a.list, target = _a.target;
          if (!defined$1(this._autoClose)) {
              this._autoClose = defined$1(autoClose) ? autoClose : true;
          }
          if (!defined$1(this._theme)) {
              this._theme = theme || "dark";
          }
          if (!defined$1(this.target)) {
              this._target = target;
          }
          var pickLayers, temPickObjects;
          this._overlay = new Overlay({
              element: createContextMenuElement({ list: list || [], theme: this._theme }, function (e) {
                  _this.dispatchEvent({
                      type: BaseEventType.CLICK,
                      item: list.find(function (val) { return String(val.id) === String(e.target.getAttribute("data-id")); }),
                      layers: pickLayers,
                      pickObjects: temPickObjects
                  });
                  if (_this._autoClose) {
                      _this.hide();
                  }
              }),
              useEvent: true
          });
          this._eventKey = this.map.on([BaseEventType.RIGHT_CLICK, BaseEventType.CLICK], function (_a) {
              var coordinate = _a.coordinate, type = _a.type, pixel = _a.pixel, layers = _a.layers, pickObjects = _a.pickObjects;
              if (!defined$1(_this.map)) {
                  return;
              }
              type !== BaseEventType.CLICK && (pickLayers = temPickObjects = void 0);
              if (type !== BaseEventType.CLICK && _this.target) {
                  if (_this.target instanceof VectorLayer && !layers.find(function (i) { return i.layer === _this.target; })) {
                      return;
                  }
                  else if (_this.target instanceof Feature &&
                      !layers.find(function (_a) {
                          var features = _a.features;
                          return features.find(function (feature) { return feature === _this.target; }) !== void 0;
                      })) {
                      return;
                  }
                  else if (typeof _this.target === "function" && !_this.target({ pixel: pixel, coordinate: coordinate, layers: layers, pickObjects: pickObjects })) {
                      return;
                  }
                  else if (Array.isArray(_this.target) &&
                      _this.target[0] instanceof VectorLayer &&
                      !layers.find(function (_a) {
                          var layer = _a.layer;
                          return _this.target.find(function (i) { return i === layer; }) !== void 0;
                      })) {
                      return;
                  }
                  else if (Array.isArray(_this.target) &&
                      _this.target[0] instanceof Feature &&
                      !layers.find(function (_a) {
                          var features = _a.features;
                          return (_this.target.find(function (i) {
                              return features.find(function (f) { return f === i; }) !== void 0;
                          }) !== void 0);
                      })) {
                      return;
                  }
              }
              setTimeout(function () {
                  if (type === BaseEventType.CLICK) {
                      _this.hide();
                      if (_this._overlay.visible) {
                          _this.dispatchEvent({ type: BaseEventType.HIDE });
                      }
                  }
                  else {
                      pickLayers = layers;
                      temPickObjects = pickObjects;
                      _this._overlay.setPosition(coordinate);
                      _this.dispatchEvent({ type: BaseEventType.SHOW, coordinate: coordinate, pixel: pixel, layers: layers, pickObjects: pickObjects });
                  }
              }, 0);
          });
      };
      ContextMenu.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addOverlay(this._overlay);
      };
      /**
       * @ignore
       */
      ContextMenu.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeOverlay(this._overlay);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      ContextMenu.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          clearContextMenuElementEvent(this._overlay.element);
          this._overlay.destroy();
          this._overlay = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 关闭菜单
       */
      ContextMenu.prototype.hide = function () {
          this._overlay.setPosition();
          return this;
      };
      /**
       * 设置右键菜单主题
       */
      ContextMenu.prototype.setTheme = function (
      /**
       * 提示框样式主题
       *
       * 可选值:'dark','light'
       */
      theme) {
          this._overlay.element.classList.replace(this._theme, theme);
          this._theme = theme;
          return this;
      };
      /**
       * 设置绑定对象
       *
       * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
       */
      ContextMenu.prototype.setTarget = function (target) {
          this._target = target;
          this.options.target = target;
          return this;
      };
      /**
       * 设置弹窗是否自动关闭
       */
      ContextMenu.prototype.setAutoClose = function (autoClose) {
          this._autoClose = autoClose;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标 , (layers: {layer:[[VectorLayer]][];features:[[Feature]][]}[])-矢量图层对象数组 , (pickObjects)-`cesium`原生对象数组[cesium]
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return ContextMenu;
  }(Component$1));

  /**
   * 大气对象
   */
  var Atmosphere = /** @class */ (function (_super) {
      __extends$3(Atmosphere, _super);
      function Atmosphere(options, map) {
          return _super.call(this, options, map) || this;
      }
      // 重写父类方法
      Atmosphere.prototype.init = function () {
          this.initialized = true;
          var global = this.map.map.scene.globe;
          this._defaultConfig.atmosphereHueShift = global.atmosphereHueShift;
          this._defaultConfig.lightingFadeOutDistance = global.lightingFadeOutDistance;
          this._defaultConfig.lightingFadeInDistance = global.lightingFadeInDistance;
          this.map.map.scene.globe.atmosphereHueShift = this.options.atmosphereHueShift;
          this.map.map.scene.globe.lightingFadeOutDistance = this.options.lightingFadeOutDistance;
          this.map.map.scene.globe.lightingFadeInDistance = this.options.lightingFadeInDistance;
      };
      /**
       * 清除修改、恢复修改之前的设置
       * @memberof Atmosphere
       * @instance
       */
      Atmosphere.prototype.remove = function () {
          this.map.map.scene.globe.atmosphereHueShift = this._defaultConfig.atmosphereHueShift;
          this.map.map.scene.globe.lightingFadeOutDistance = this._defaultConfig.lightingFadeOutDistance;
          this.map.map.scene.globe.lightingFadeInDistance = this._defaultConfig.lightingFadeInDistance;
          this.initialized = false;
      };
      return Atmosphere;
  }(Component$1));

  var textureRain = "data:image/png;base64,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";
  var textureSnow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAABTVBMVEVHcEz19fX19fX4+Pj29vb19fX39/f09PT19fX5+fn29vb29vb39/f19fX39/f29vb29vb29vb29vb29vb19fX19fX19fX19fX29vb29vbz8/P29vb39/f29vb29vb4+Pj39/f19fX39/f29vb09PT19fX09PT39/f29vb39/f19fX4+Pj29vb09PT29vb39/fz8/P19fX4+Pj4+Pj29vb29vb4+Pj29vb19fXx8fH19fX39/f29vb4+Pj19fX19fX19fX09PT29vb19fX29vb09PT19fX19fX19fX39/f09PT39/fz8/P39/f29vb39/f39/f29vb29vb29vb19fX19fX09PT29vb29vb4+Pj09PT09PTz8/P39/f29vb29vb09PT4+Pj4+Pj39/f09PT39/f29vb39/f19fX29vb5+fn09PTz8/Py8vL5+fmamtp/AAAAZ3RSTlMAhD/ncQR9AQL/ZROzB8kNnEOImCf+HqWTH/ocwRhh+7wq11nkM/37Fd3e8Vzre/b0++7EMSTSNucJTuo73w+7ObMh8AvDzGmPry6s989tR25RVnaB9cag+vPQ1tuoU4y45eH0dP1KNDOHtAAABh5JREFUWMPdV1dDKjsQDkqTprJcaYJUEZQiKhYUFVAs2OuxHRsnG3b3/7/emQQR9QD6eG8eYMhmZqd882Ug5P+3Flc/7xiCznhLtNv76uvT0x4hhY3HVS5YGnTNz6XRkG20j77hVqbNI5SsjuvJQ77nlpvNYxQCT5SFDL0NmDbBwJwZpBkqayN8L6PQ5joKHkrZTR8DZGCSUvoArjioor3yrflJRn95ITsJShV93ySAC9RhIBbK1NyCCGsbtiyEPFIq31b7GljVwIWoPQkRSK0to0LpLjmBANTTb9TRjS44wduWA4RsgIFn/wE48NhbNVDCT9cFxcVU3dv+8h2jCQiA1fd6VtC4lNw3royRc4YG5Ji1/UiShU0PMZnMVn83CPr4sfy4lMVv5ez90QrEQIco256bm3OsRY7/Xsp5n6bwd4t1V+JB/dFDJkox4ZQsnhdcfzVgPktrmgJnGD93D0FlxkNL9GCKkDPcYTJfipJ2dQmi/OBcj6mqglZoJUyOEtcqhDVDyB9QVxRF1XCljs09UmkdyDzGchizm7gp02T0xTxHqXqre60FZ05PNqb6IsFa1oOF69NnqCWkpWg4hfi1gZ+QghnRm29Q+RKFGmBIc/+MVkYneb7loB4MTEMGlrx2fy/fq/FAuxl2bcbRwC6vmM8b/kdYSu0Wnua6s8nw77VC6+mUA1UHk1xvC4JpQQA+rvfbCNqTdGMfWGAJdMTOWEqR23gCIspwfMqMyYqafktkqUCzI53FdFUEdDAY26SmqbJAkxHAccEdUDWfps3aSuL8ThNw/QENmKuJDd5SyezSfkoDPMFW0UsWoTNk382VxfYPbaS9ojcmOptVrEs4HjIR4k8laHamulqT1nPgg0Q2oa9u9uxkFGqhPPIklJ9AvCt9qpsKx0+A+S8BQ9P8HjgE6eU8ARhaAVIBfbmyJ9KMPn3B1SYcjwxDVyOOk9jzhi2RTG3dRLxrqLTC9ecQl5kOCLgWxgKl5Y0cBOGE39E6CONInh5RgFycGEKApVzwTR9iKVkDXtf83jJcQKFfv/JPycj2C7xvYv9KktL4YtvZ2XlFQGBJ59xHoXh1v7trKzSbIKcia0/F6Wx+xEok+rc1xCmMtjH09aFYxSiRFAaLMka7rM4H76eY4JbJKHGtpyv1SVVVZznrKKoqiI29ERhIqip+gCDw0ajU67l07O7mHHJl9nvDi6sDAzY4Im/pM+fnRTy76ZFuOYYpu3TqftdBaLgtNcthGqrU+O3ac41NDXeya/QF3hXD8hkTqA9APYNvdMcBmyc+kJJlhCGyd/4LDE5Bi15gR57he2+g9+0HCMILRpv3x38WnGghgk1vQZ7Lxz8BEe8C3wM+5pcKvqoGUm7MAx5D4bKpOlK2hTcOWih8gPI8hq0A/ZKFPCQyFTYs6m0Y0w7xx1plRFqWo/z4OVhIdLrgTeJzfvUfXSuq795TaAilHTgtcxd4OSKta03SlEKgw4AT2r/Vnn6HVq90AMVKdtCDoUEgCMZGWmk3vF59yKJOUdrDwMJDLY/+tBwPkgOEwJBu8XDkccfb7UraSnveB7hyGvgnJ8iU7pevOZ6eh3uyeKnc+Su67o56sKpQmmdn61KVfjhvRkBPB2zUQCK6BbaZWPyRvh4cSFsPeSKYNrANYBi3/0C/BATEdCTs4/18R1YQOg7Piv972qPGcdBbsuLMd91gCtCXWxFVDUkZS3TD1ONWDQfd4lKiiKv5VCWUCdpbnPu2nma6z6nj2fYxzoCuqJhG9AIX4rpJuLvNu1VHB+3sdj6xic1ZjQ8wzm4xWAtIP9osNzDY0W6lQUFtIzNO9/rWTqBrCJlZ3+3VYVHE0IH2AaQWCCK53KcApni8SoKtMJzv+0Zku9g38VjF3r6ECeW5HYMJyqpGg4jHb0xKFuTGcIq16sDbK0uZb8GwrVJ60C8IZEIm6zgLON7Au4jkaCYbPoWPDL0XjnQVLwnXKR8xRRFCslbDuQIQXSz3+dcF4SoS/9vQeE9Z2TiD80jpTpvNnvQ2MP8C1ziOAa60kn39/PQop8bivQ3EkwlFzJSrV/qvLHTkOTH3yaF+fMv73/qv/S8xKzSNcc760gAAAABJRU5ErkJggg==";
  var textureFire = "data:image/png;base64,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";
  var textureWater2 = "data:image/png;base64,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";
  var textureAir = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAADoCAMAAACtpkq7AAAAz1BMVEVHcEz///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8Z+KahAAAARHRSTlMAFxIiCgUHAQIbHiAMDgRCED0tphRhGO9IftF5wLG4i081Vm8lZySbaoaDKfsVMkyPyvXfxejaOaB1k11TWnKs5JfWfYFa5EcAACAASURBVHjarFhrc5vKEgwPIcGCeFygUOmDACEsiwL8jSh6VPn//6nbPYtsJzfnHvvkbKyH42XZnu7pmeXbt8+O5dtYrVbr9WLhOLYdREFkmmYgw7cdZ4GxXi3/+mpcu1rJGnyt5P9+M3c1j+U85X9n/enQu3m710IA+X7U92aep6YZRUEQ+bZNUNzyb+GsHtfK+0rArWTV39yLYfuAa/XvYlp+DJsw5DiO7wNElPYuh9GDKtMPfP+BafnT5T9fbC/W5HK9lqm/EvUAhEkA9Y5Lg1r+a4CWH7YEhmxKLjVMw/Wapm0b5Xlur/UHTI99vi3wDohgbBmOHtz0PBdv7/eS2zgi5LWMv1Lpn1Aky84pBIpSsuO1yZBgNJ6b9z0EaEaST+sPmHT+yNC7RDjAMNbwZ2Cr5U9DZnOezkxepDP0PbP+HBIBSbxkR8ADSzCU8lSTxHFVDUNnuZ7R94alItGes3jPatki6NB6JaLIDMwIi2hMC07WSfXOpfMY9vxytKDflv0jRLMKFjMcAorMvu/zRnXDEBdhPA1d17k5eDLTiMpb2M68TzE3oUfolSUQkKCHSClUe1bfavEBkNzNdojXBmr+aEIfifUnmB6ZupDoYunggSfP3SSppiouyiKekqZxPdfIqTx/juuslZUmyZbdcYkenhLlhmn20Zx7nLgW+3tI23nM1h/+w0wls37nkl8V3SN/NCAz7XM3d92mG6opDsOwDKdpUFaH1AIibNJ2PozFevG+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";
  var textureAir2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI8AAADoCAMAAADhTEdDAAAA8FBMVEX///////////////////////////9HcEz///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9Cw+iKAAAAT3RSTlMBGgkgBhAUAAIEFxIiCwMcQQ40Hj1LLWAIKEemOm8xwLgqi4NOk+9orLGGfnmfdVQM/GXpRI+XmyTS21pXxV3X3/Zya8s3Ufp8z+S9o7XIl/40EQAAIABJREFUeNqsWG2TmswWFEaIwsAAM6BwkSp2TZnaeJWyyPNQpeWH3cLy//+i22cG3WziZk1y2WhW15emT5/ucxh9+uEYjUafbjxnjslkOpnQfxO6TfRzN147Mcfou+PTncfoIzyvUOiYTqf6fqKRAdXNl9/AM/oLPN+/+fXTDZq5jbvpmG7j6c8UXdCE+CEO3yIa/T6eH8/nOzgEZGrrY2yOKZ4bXou773gMw5BejP9+IOrP8Yxe6ZkOB0Gw7biJY7tpmiDQmN5WZXTBArBh+Nd4Rj8d+PwLmjl+AtvxY99pYucV0MQIaWBRwxkP76EHbxH9Jj9voVArGeZxvnNiB0D82PXj2MfN1s9NSdoXNIaUqanmFdY0nPw9nuv50ucSOdBN48S+63iej/s4JkRGRZOh4fDNA5WDwC7iD+8l6AM84aBMfPbcDgKg8TzXws0FQQBoamaafxDaGD1ocI7HV1hh+P/BcwFEtQoCVMv1LAt4PNfjvhZ1oL+bLOlKBqCPqQvfAtLa/hDQr/WjAZGih85yauIGcABKUMmaGJjsZm6abzynYzo3ZGpO7fmFreldgN7v98HUrvzMbQjHAhiiRwiZcctxHN9zdPPj7w2BCQLc2Xjc2PpRcPWr6Wvz/xEeg8gIGnjw0bFrccARlmd1XZYktWX5PprfaXx8J3FBBdSqxx1+CYA0bi6A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";

  /**
   * 火焰组件
   */
  var Fire = /** @class */ (function (_super) {
      __extends$3(Fire, _super);
      function Fire(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, type: "explosion" }, options), map) || this;
      }
      Fire.prototype.init = function () {
          this.initialized = true;
          this.map.map.clock.shouldAnimate = true;
          switch (this.options.type) {
              case "burning":
                  this._addBurning(this.options);
                  break;
              case "explosion":
                  this._addExplosion(this.options);
                  break;
          }
      };
      Fire.prototype._addExplosion = function (options) {
          var coordinates = options.coordinates, particleSize = options.particleSize;
          var _explosionOptions = {
              emitterModelMatrix: this._computeEmitterModelMatrix(),
              speed: 2.0,
              lifetime: 2,
              emitter: new Cesium__namespace.SphereEmitter(2),
              startScale: 5,
              endScale: 0,
              image: textureFire,
              emissionRate: 30,
              bursts: [new Cesium__namespace.ParticleBurst({ time: 10.0, minimum: 60, maximum: 80 })]
          };
          merge$2(_explosionOptions, options);
          merge$2(_explosionOptions, {
              modelMatrix: this._computeModelMatrix(coordinates),
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize)
          });
          this._particleSystem = new Cesium__namespace.ParticleSystem(_explosionOptions);
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      Fire.prototype._addBurning = function (options) {
          var coordinates = options.coordinates, particleSize = options.particleSize;
          var _burningOptions = {
              emitterModelMatrix: this._computeEmitterModelMatrix(),
              speed: 1.0,
              lifetime: 16,
              emitter: new Cesium__namespace.ConeEmitter(Cesium__namespace.Math.toRadians(30.0)),
              startScale: 3.5,
              endScale: 5.0,
              emissionRate: 30.0,
              image: textureFire,
              sizeInMeters: true
          };
          merge$2(_burningOptions, options);
          merge$2(_burningOptions, {
              modelMatrix: this._computeModelMatrix(coordinates),
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize)
          });
          this._particleSystem = new Cesium__namespace.ParticleSystem(_burningOptions);
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      Fire.prototype._computeModelMatrix = function (coordinates) {
          var _a;
          var position = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          return Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position);
      };
      Fire.prototype._computeEmitterModelMatrix = function () {
          var hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(0, 0, 0);
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(2.5, 4, 1);
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr);
          var result = Cesium__namespace.Matrix4.fromTranslationRotationScale(trs);
          if (result) {
              return result;
          }
      };
      /**
       * 删除火焰
       */
      Fire.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Fire;
  }(Component$1));

  /**
   * @class Fountain
   */
  var Fountain = /** @class */ (function (_super) {
      __extends$3(Fountain, _super);
      function Fountain(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, type: "fountain", hpr: {} }, options), map) || this;
      }
      Fountain.prototype.init = function () {
          this.initialized = true;
          this.map.map.clock.shouldAnimate = true;
          switch (this.options.type) {
              case "watergun":
                  this.fountain1(this.options);
                  break;
              case "fountain":
                  this.fountain2(this.options);
                  break;
          }
      };
      Fountain.prototype.updateCallbackGravity = function () {
          var updateCallbackFun = function (particle, dt) {
              var gravityVector = Cesium__namespace.Cartesian3.normalize(particle.position, new Cesium__namespace.Cartesian3()) || new Cesium__namespace.Cartesian3();
              var heading = -3;
              Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, heading * dt, gravityVector);
              particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
          };
          return updateCallbackFun;
      };
      Fountain.prototype.fountain1 = function (options) {
          var _a;
          var _b = options; _b.id; var type = _b.type, originCoordinates = _b.originCoordinates, hpr = _b.hpr;
          var particleSize = 6;
          var radius = 0.15;
          var speed = 9.5;
          var entity = this.map.map.entities.add({
              id: this.id,
              position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(originCoordinates), false)),
              point: {
                  show: false,
                  pixelSize: 10,
                  color: Cesium__namespace.Color.RED
              }
          });
          this.particle1 = new Cesium__namespace.ParticleSystem({
              startScale: 0.05,
              endScale: 5.0,
              lifetime: 1.5,
              emissionRate: 100,
              speed: speed,
              image: textureAir,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              emitter: new Cesium__namespace.CircleEmitter(radius * 1.5),
              modelMatrix: this.computeModelMatrix1(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix1(hpr),
              updateCallback: this.updateCallbackGravity()
          });
          this.particle2 = new Cesium__namespace.ParticleSystem({
              startScale: 0.6,
              endScale: 3.0,
              lifetime: 1.5,
              emissionRate: 100,
              speed: speed,
              image: textureWater2,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              emitter: new Cesium__namespace.CircleEmitter(radius),
              modelMatrix: this.computeModelMatrix1(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix1(hpr),
              updateCallback: this.updateCallbackGravity()
          });
          this.particle1["type"] = type;
          this.particle2["type"] = type;
          this.map.map.scene.primitives.add(this.particle1);
          this.map.map.scene.primitives.add(this.particle2);
      };
      Fountain.prototype.computeEmitterModelMatrix1 = function (headingPitchRoll) {
          var hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(0, 0, 0, new Cesium__namespace.HeadingPitchRoll());
          if (Cesium__namespace.defined(headingPitchRoll)) {
              var heading = headingPitchRoll.heading, pitch = headingPitchRoll.pitch, roll = headingPitchRoll.roll;
              hpr = Cesium__namespace.HeadingPitchRoll.fromDegrees(Cesium__namespace.defaultValue(heading, 130), Cesium__namespace.defaultValue(pitch, 30), Cesium__namespace.defaultValue(roll, 0), new Cesium__namespace.HeadingPitchRoll());
          }
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(0, 0, 0, new Cesium__namespace.Cartesian3());
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr, new Cesium__namespace.Quaternion());
          return Cesium__namespace.Matrix4.fromTranslationRotationScale(trs, new Cesium__namespace.Matrix4());
      };
      Fountain.prototype.computeModelMatrix1 = function (entity, time) {
          var modelMatrix = null;
          var position = entity.position.getValue(time);
          if (!Cesium__namespace.defined(position)) {
              return undefined;
          }
          var orientation = entity.orientation.getValue(time);
          if (!Cesium__namespace.defined(orientation)) {
              modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position, undefined, new Cesium__namespace.Matrix4());
          }
          else {
              var matrix3 = Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3());
              // 由旋转和转换生成四阶矩阵
              modelMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(matrix3, position, new Cesium__namespace.Matrix4());
          }
          return modelMatrix;
      };
      Fountain.prototype.computeEmitterModelMatrix = function (targetCoordinates) {
          var _a;
          var hpr = (_a = Cesium__namespace.HeadingPitchRoll).fromDegrees.apply(_a, __spreadArray$1([], __read(targetCoordinates), false));
          var trs = new Cesium__namespace.TranslationRotationScale();
          trs.translation = Cesium__namespace.Cartesian3.fromElements(0, 0, 1, new Cesium__namespace.Cartesian3());
          trs.rotation = Cesium__namespace.Quaternion.fromHeadingPitchRoll(hpr, new Cesium__namespace.Quaternion());
          return Cesium__namespace.Matrix4.fromTranslationRotationScale(trs, new Cesium__namespace.Matrix4());
      };
      Fountain.prototype.computeModelMatrix = function (entity, time) {
          var modelMatrix = null;
          var position = entity.position.getValue(time);
          if (!Cesium__namespace.defined(position)) {
              return undefined;
          }
          var orientation = entity.orientation.getValue(time);
          if (!Cesium__namespace.defined(orientation)) {
              modelMatrix = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(position, undefined, new Cesium__namespace.Matrix4());
          }
          else {
              var matrix3 = Cesium__namespace.Matrix3.fromQuaternion(orientation, new Cesium__namespace.Matrix3());
              // 由旋转和转换生成四阶矩阵
              modelMatrix = Cesium__namespace.Matrix4.fromRotationTranslation(matrix3, position, new Cesium__namespace.Matrix4());
          }
          return modelMatrix;
      };
      Fountain.prototype.fountain2 = function (options) {
          var _a;
          var _b = options; _b.id; var type = _b.type, targetCoordinates = _b.targetCoordinates, particleSize = _b.particleSize;
          var originCoordinates = [targetCoordinates[0], targetCoordinates[1], 0];
          var entity = this.map.map.entities.add({
              id: this.id,
              position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(targetCoordinates), false)),
              point: {
                  pixelSize: 10,
                  color: Cesium__namespace.Color.TRANSPARENT,
                  show: false
              }
          });
          this.particle1 = new Cesium__namespace.ParticleSystem({
              startScale: 20.0,
              endScale: 5.0,
              startColor: Cesium__namespace.Color.fromCssColorString("rgba(85, 193, 255, 0.5)"),
              endColor: Cesium__namespace.Color.fromCssColorString("#fff"),
              image: textureAir2,
              imageSize: new Cesium__namespace.Cartesian2(particleSize / 2, particleSize),
              lifetime: 16,
              emissionRate: 60.0,
              speed: 60,
              emitter: new Cesium__namespace.SphereEmitter(1),
              modelMatrix: this.computeModelMatrix(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix(originCoordinates),
              updateCallback: function (particle, dt) {
                  var position = particle.position;
                  var gravityVector = Cesium__namespace.Cartesian3.normalize(position, new Cesium__namespace.Cartesian3());
                  Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, -90 * dt, gravityVector);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
              }
          });
          this.particle2 = new Cesium__namespace.ParticleSystem({
              startScale: 0.01,
              endScale: 2.0,
              image: textureRain,
              imageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              minimumImageSize: new Cesium__namespace.Cartesian2(1.0, 1.0),
              maximumImageSize: new Cesium__namespace.Cartesian2(5.0, 5.0),
              minimumMass: 1,
              maximumMass: 3,
              sizeInMeters: true,
              lifetime: 16,
              emissionRate: 60.2,
              speed: 60.2,
              emitter: new Cesium__namespace.SphereEmitter(1),
              modelMatrix: this.computeModelMatrix(entity, Cesium__namespace.JulianDate.now()),
              emitterModelMatrix: this.computeEmitterModelMatrix(targetCoordinates),
              updateCallback: function (particle, dt) {
                  var gravity = -90; // 重力参数（值为负表示向外弯曲，值为正数的时候表示向内弯曲）
                  var position = particle.position;
                  var gravityVector = Cesium__namespace.Cartesian3.normalize(position, new Cesium__namespace.Cartesian3());
                  Cesium__namespace.Cartesian3.multiplyByScalar(gravityVector, gravity * dt, gravityVector);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
              }
          });
          this.particle1["type"] = type;
          this.particle2["type"] = type;
          this.map.map.scene.primitives.add(this.particle1);
          this.map.map.scene.primitives.add(this.particle2);
      };
      Fountain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this.map = undefined;
          this.initialized = false;
          this.map.map.scene.primitives.remove(this.particle1);
          this.map.map.scene.primitives.remove(this.particle2);
          this.map.map.entities.removeById(this.id);
          if (destroy) {
              if (!this.particle1.isDestroyed()) {
                  this.particle1.destroy();
              }
              if (!this.particle2.isDestroyed()) {
                  this.particle2.destroy();
              }
          }
      };
      return Fountain;
  }(Component$1));

  /**
   * 光照对象
   */
  var Light = /** @class */ (function (_super) {
      __extends$3(Light, _super);
      function Light(options, map) {
          return _super.call(this, __assign$1({ speed: 1000 }, options), map) || this;
      }
      /**
       * @ignore
       */
      Light.prototype.init = function () {
          this.initialized = true;
          var speed = this.options.speed;
          this.map.map.scene.globe.enableLighting = true;
          this._defaultMultiplier = this.map.map.clock.multiplier;
          this.map.map.clock.multiplier = speed;
      };
      /**
       * 关闭
       */
      Light.prototype.remove = function () {
          this.map.map.scene.globe.enableLighting = false;
          this.map.map.clock.multiplier = this._defaultMultiplier;
          this.initialized = false;
      };
      return Light;
  }(Component$1));

  /**
   * 雨
   */
  var Rain = /** @class */ (function (_super) {
      __extends$3(Rain, _super);
      function Rain(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, areaRadius: 200 }, options), map) || this;
      }
      Rain.prototype.init = function () {
          var _a;
          var _this = this;
          this.initialized = true;
          var _b = this.options, coordinates = _b.coordinates, particleSize = _b.particleSize, areaRadius = _b.areaRadius, color = _b.color;
          this.map.map.scene.globe.depthTestAgainstTerrain = true;
          var center = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          var disLength = 100000;
          var dimensions = new Cesium__namespace.Cartesian3(areaRadius * 2, areaRadius * 2, areaRadius * 2);
          this._particleSystem = new Cesium__namespace.ParticleSystem({
              modelMatrix: Cesium__namespace.Matrix4.fromTranslation(center),
              minimumSpeed: 0,
              maximumSpeed: 1,
              lifetime: 15.0,
              emitter: new Cesium__namespace.BoxEmitter(dimensions),
              startScale: 0.5,
              endScale: 1.0,
              image: textureRain,
              emissionRate: 100.0,
              startColor: Cesium__namespace.Color.WHITE.withAlpha(0.1),
              endColor: Cesium__namespace.Color.WHITE.withAlpha(1.0),
              color: (color && Cesium__namespace.Color.fromCssColorString(color)) || Cesium__namespace.Color.WHITE,
              minimumImageSize: new Cesium__namespace.Cartesian2(particleSize * 0.5, particleSize * 0.5),
              maximumImageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              updateCallback: function (particle, dt) {
                  _this._snowGravityScratch = new Cesium__namespace.Cartesian3();
                  _this._snowGravityScratch = Cesium__namespace.Cartesian3.normalize(particle.position, _this._snowGravityScratch);
                  Cesium__namespace.Cartesian3.multiplyByScalar(_this._snowGravityScratch, Cesium__namespace.Math.randomBetween(-30.0, -300.0), _this._snowGravityScratch);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, _this._snowGravityScratch, particle.velocity);
                  var distance = Cesium__namespace.Cartesian3.distance(center, particle.position);
                  if (distance > disLength) {
                      particle.endColor.alpha = 0.0;
                  }
                  else {
                      particle.endColor.alpha = _this._particleSystem.endColor.alpha / (distance / disLength + 0.1);
                  }
              }
          });
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      /**
       * 删除
       */
      Rain.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
                  this._snowGravityScratch = null;
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Rain;
  }(Component$1));

  /**
   * 雪花
   */
  var Snow = /** @class */ (function (_super) {
      __extends$3(Snow, _super);
      function Snow(options, map) {
          return _super.call(this, __assign$1({ particleSize: 10, areaRadius: 200 }, options), map) || this;
      }
      /**
       * @ignore
       */
      Snow.prototype.init = function () {
          var _a;
          var _this = this;
          this.initialized = true;
          var _b = this.options, coordinates = _b.coordinates, particleSize = _b.particleSize, areaRadius = _b.areaRadius;
          this.map.map.scene.globe.depthTestAgainstTerrain = true;
          var center = (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coordinates), false));
          var disLength = 100000;
          this._particleSystem = new Cesium__namespace.ParticleSystem({
              modelMatrix: Cesium__namespace.Matrix4.fromTranslation(center),
              minimumSpeed: 0,
              maximumSpeed: 1,
              lifetime: 15.0,
              emitter: new Cesium__namespace.SphereEmitter(areaRadius),
              startScale: 0.5,
              endScale: 1.0,
              image: textureSnow,
              emissionRate: 300.0,
              startColor: Cesium__namespace.Color.WHITE.withAlpha(0.0),
              endColor: Cesium__namespace.Color.WHITE.withAlpha(1.0),
              minimumImageSize: new Cesium__namespace.Cartesian2(particleSize * 0.5, particleSize * 0.5),
              maximumImageSize: new Cesium__namespace.Cartesian2(particleSize, particleSize),
              updateCallback: function (particle, dt) {
                  _this._snowGravityScratch = new Cesium__namespace.Cartesian3();
                  _this._snowGravityScratch = Cesium__namespace.Cartesian3.normalize(particle.position, _this._snowGravityScratch);
                  Cesium__namespace.Cartesian3.multiplyByScalar(_this._snowGravityScratch, Cesium__namespace.Math.randomBetween(-30.0, -300.0), _this._snowGravityScratch);
                  particle.velocity = Cesium__namespace.Cartesian3.add(particle.velocity, _this._snowGravityScratch, particle.velocity);
                  var distance = Cesium__namespace.Cartesian3.distance(center, particle.position);
                  if (distance > disLength) {
                      particle.endColor.alpha = 0.0;
                  }
                  else {
                      particle.endColor.alpha = _this._particleSystem.endColor.alpha / (distance / disLength + 0.1);
                  }
              }
          });
          this.map.map.scene.primitives.add(this._particleSystem);
      };
      /**
       * 删除
       */
      Snow.prototype.remove = function () {
          this.initialized = false;
          if (Cesium__namespace.defined(this._particleSystem)) {
              this.map.map.scene.primitives.remove(this._particleSystem);
              if (!this._particleSystem.isDestroyed()) {
                  this._particleSystem.destroy();
              }
              this.map = undefined;
              this._particleSystem = undefined;
          }
      };
      return Snow;
  }(Component$1));

  /* eslint-disable no-unused-vars */
  var htmlTagRegex = /<html(.|\s)*>(.|\s)*<\/html>/im;
  var md = new markdownIt({
      html: true,
      linkify: true
  });
  md.use(markdownItSanitizer, {
      imageClass: "",
      removeUnbalanced: false,
      removeUnknown: false
  });
  var KnockoutMarkdownBinding = {
      register: function (Knockout) {
          Knockout.bindingHandlers.markdown = {
              init: function () {
                  // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
                  return { controlsDescendantBindings: true };
              },
              update: function (element, valueAccessor) {
                  // Remove existing children of this element.
                  while (element.firstChild) {
                      Knockout.removeNode(element.firstChild);
                  }
                  var rawText = Knockout.unwrap(valueAccessor());
                  // If the text contains an <html> tag, don't try to interpret it as Markdown because
                  // we'll probably break it in the process.
                  var html;
                  if (htmlTagRegex.test(rawText)) {
                      html = rawText;
                  }
                  else {
                      html = md.render(rawText);
                  }
                  var nodes = Knockout.utils.parseHtmlFragment(html, element);
                  element.className = element.className + " markdown";
                  for (var i = 0; i < nodes.length; ++i) {
                      var node = nodes[i];
                      setAnchorTargets(node);
                      element.appendChild(node);
                  }
              }
          };
      }
  };
  function setAnchorTargets(element) {
      if (element instanceof HTMLAnchorElement) {
          element.target = "_blank";
      }
      if (element.childNodes && element.childNodes.length > 0) {
          for (var i = 0; i < element.childNodes.length; ++i) {
              setAnchorTargets(element.childNodes[i]);
          }
      }
  }

  var KnockoutHammerBinding = {
      register: function (Knockout) {
          Knockout.bindingHandlers.swipeLeft = {
              init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                  var f = Knockout.unwrap(valueAccessor());
                  new Hammer(element).on("swipeleft", function (e) {
                      var viewModel = bindingContext.$data;
                      f.apply(viewModel, arguments);
                  });
              }
          };
          Knockout.bindingHandlers.swipeRight = {
              init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
                  var f = Knockout.unwrap(valueAccessor());
                  new Hammer(element).on("swiperight", function (e) {
                      var viewModel = bindingContext.$data;
                      f.apply(viewModel, arguments);
                  });
              }
          };
      }
  };

  // @ts-ignore
  var Knockout$4 = Cesium__namespace.knockout;
  var registerKnockoutBindings = function () {
      // @ts-ignore
      Cesium__namespace.SvgPathBindingHandler.register(Knockout$4);
      KnockoutMarkdownBinding.register(Knockout$4);
      KnockoutHammerBinding.register(Knockout$4);
      Knockout$4.bindingHandlers.embeddedComponent = {
          init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
              var component = Knockout$4.unwrap(valueAccessor());
              component.show(element);
              return { controlsDescendantBindings: true };
          },
          update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
              return;
          }
      };
  };

  var createFragmentFromTemplate = function (htmlString) {
      var holder = document.createElement("div");
      holder.innerHTML = htmlString;
      var fragment = document.createDocumentFragment();
      while (holder.firstChild) {
          fragment.appendChild(holder.firstChild);
      }
      return fragment;
  };

  // @ts-ignore
  var Knockout$3 = Cesium__namespace.knockout;
  var loadView = function (htmlString, container, viewModel) {
      // @ts-ignore
      container = Cesium__namespace.getElement(container);
      var fragment = createFragmentFromTemplate(htmlString);
      // Sadly, fragment.childNodes doesn't have a slice function.
      // This code could be replaced with Array.prototype.slice.call(fragment.childNodes)
      // but that seems slightly error prone.
      var nodes = [];
      var i;
      for (i = 0; i < fragment.childNodes.length; ++i) {
          nodes.push(fragment.childNodes[i]);
      }
      container.appendChild(fragment);
      for (i = 0; i < nodes.length; ++i) {
          var node = nodes[i];
          if (node.nodeType === 1 || node.nodeType === 8) {
              Knockout$3.applyBindings(viewModel, node);
          }
      }
      return nodes;
  };

  /* eslint-disable quotes */
  // @ts-ignore
  var Knockout$2 = Cesium__namespace.knockout;
  var DistanceLegendViewModel = function (options) {
      if (!Cesium__namespace.defined(options) || !Cesium__namespace.defined(options.terria)) {
          throw new Cesium__namespace.DeveloperError("options.terria is required.");
      }
      this.terria = options.terria;
      this._removeSubscription = undefined;
      this._lastLegendUpdate = undefined;
      this.eventHelper = new Cesium__namespace.EventHelper();
      this.distanceLabel = undefined;
      this.barWidth = undefined;
      this.enableDistanceLegend = Cesium__namespace.defined(options.enableDistanceLegend) ? options.enableDistanceLegend : true;
      Knockout$2.track(this, ["distanceLabel", "barWidth"]);
      this.eventHelper.add(this.terria.afterWidgetChanged, function () {
          if (Cesium__namespace.defined(this._removeSubscription)) {
              this._removeSubscription();
              this._removeSubscription = undefined;
          }
      }, this);
      //        this.terria.beforeWidgetChanged.addEventListener(function () {
      //            if ( Cesium.defined(this._removeSubscription)) {
      //                this._removeSubscription();
      //                this._removeSubscription = undefined;
      //            }
      //        }, this);
      var that = this;
      function addUpdateSubscription() {
          if (Cesium__namespace.defined(that.terria)) {
              var scene_1 = that.terria.scene;
              that._removeSubscription = scene_1.postRender.addEventListener(function () {
                  updateDistanceLegendCesium(this, scene_1);
              }, that);
          }
      }
      addUpdateSubscription();
      this.eventHelper.add(this.terria.afterWidgetChanged, function () {
          addUpdateSubscription();
      }, this);
      // this.terria.afterWidgetChanged.addEventListener(function() {
      //    addUpdateSubscription();
      // }, this);
  };
  DistanceLegendViewModel.prototype.destroy = function () {
      this.eventHelper.removeAll();
  };
  DistanceLegendViewModel.prototype.show = function (container) {
      var testing;
      if (this.enableDistanceLegend) {
          testing =
              '<div class="distance-legend" data-bind="visible: distanceLabel && barWidth">' +
                  '<div class="distance-legend-label" data-bind="text: distanceLabel"></div>' +
                  "<div class=\"distance-legend-scale-bar\" data-bind=\"style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }\"></div>" +
                  "</div>";
      }
      else {
          testing =
              '<div class="distance-legend"  style="display: none;" data-bind="visible: distanceLabel && barWidth">' +
                  '<div class="distance-legend-label"  data-bind="text: distanceLabel"></div>' +
                  "<div class=\"distance-legend-scale-bar\"  data-bind=\"style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }\"></div>" +
                  "</div>";
      }
      loadView(testing, container, this);
      // loadView(distanceLegendTemplate, container, this);
      // loadView(require('fs').readFileSync(__dirname + '/../Views/DistanceLegend.html', 'utf8'), container, this);
  };
  DistanceLegendViewModel.create = function (options) {
      var result = new DistanceLegendViewModel(options);
      result.show(options.container);
      return result;
  };
  var geodesic = new Cesium__namespace.EllipsoidGeodesic();
  var distances = [
      1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 20000, 30000, 50000, 100000, 200000,
      300000, 500000, 1000000, 2000000, 3000000, 5000000, 10000000, 20000000, 30000000, 50000000
  ];
  function updateDistanceLegendCesium(viewModel, scene) {
      if (!viewModel.enableDistanceLegend) {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
          return;
      }
      // @ts-ignore
      var now = Cesium__namespace.getTimestamp();
      if (now < viewModel._lastLegendUpdate + 250) {
          return;
      }
      viewModel._lastLegendUpdate = now;
      // Find the distance between two pixels at the bottom center of the screen.
      var width = scene.canvas.clientWidth;
      var height = scene.canvas.clientHeight;
      var left = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((width / 2) | 0, height - 1));
      var right = scene.camera.getPickRay(new Cesium__namespace.Cartesian2((1 + width / 2) | 0, height - 1));
      var globe = scene.globe;
      var leftPosition = globe.pick(left, scene);
      var rightPosition = globe.pick(right, scene);
      if (!Cesium__namespace.defined(leftPosition) || !Cesium__namespace.defined(rightPosition)) {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
          return;
      }
      var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
      var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);
      geodesic.setEndPoints(leftCartographic, rightCartographic);
      var pixelDistance = geodesic.surfaceDistance;
      // Find the first distance that makes the scale bar less than 100 pixels.
      var maxBarWidth = 100;
      var distance;
      for (var i = distances.length - 1; !Cesium__namespace.defined(distance) && i >= 0; --i) {
          if (distances[i] / pixelDistance < maxBarWidth) {
              distance = distances[i];
          }
      }
      if (Cesium__namespace.defined(distance)) {
          var label = void 0;
          if (distance >= 1000) {
              label = (distance / 1000).toString() + " km";
          }
          else {
              label = distance.toString() + " m";
          }
          viewModel.barWidth = (distance / pixelDistance) | 0;
          viewModel.distanceLabel = label;
      }
      else {
          viewModel.barWidth = undefined;
          viewModel.distanceLabel = undefined;
      }
  }

  var svgReset = "M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z";

  // @ts-ignore
  var Knockout$1 = Cesium__namespace.knockout;
  /**
   * The view-model for a control in the user interface
   *
   * @alias UserInterfaceControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var UserInterfaceControl = function (terria) {
      if (!Cesium__namespace.defined(terria)) {
          throw new Cesium__namespace.DeveloperError("terria is required");
      }
      this._terria = terria;
      /**
       * Gets or sets the name of the control which is set as the controls title.
       * This property is observable.
       * @type {String}
       */
      this.name = "Unnamed Control";
      /**
       * Gets or sets the text to be displayed in the UI control.
       * This property is observable.
       * @type {String}
       */
      this.text = undefined;
      /**
       * Gets or sets the svg icon of the control.  This property is observable.
       * @type {Object}
       */
      this.svgIcon = undefined;
      /**
       * Gets or sets the height of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgHeight = undefined;
      /**
       * Gets or sets the width of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgWidth = undefined;
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = undefined;
      /**
       * Gets or sets the property describing whether or not the control is in the active state.
       * This property is observable.
       * @type {Boolean}
       */
      this.isActive = false;
      Knockout$1.track(this, ["name", "svgIcon", "svgHeight", "svgWidth", "cssClass", "isActive"]);
  };
  // @ts-ignore
  Object.defineProperties(UserInterfaceControl.prototype, {
      /**
       * Gets the Terria instance.
       * @memberOf UserInterfaceControl.prototype
       * @type {Terria}
       */
      terria: {
          get: function () {
              return this._terria;
          }
      },
      /**
       * Gets a value indicating whether this button has text associated with it.
       * @type {Object}
       * @ignore
       */
      hasText: {
          get: function () {
              return Cesium__namespace.defined(this.text) && typeof this.text === "string";
          }
      }
  });
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control.
   * @abstract
   * @protected
   * @ignore
   */
  UserInterfaceControl.prototype.activate = function () {
      throw new Cesium__namespace.DeveloperError("activate must be implemented in the derived class.");
  };

  /**
   * The view-model for a control in the navigation control tool bar
   *
   * @alias NavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var NavigationControl = function (terria) {
      UserInterfaceControl.apply(this, arguments);
  };
  NavigationControl.prototype = Object.create(UserInterfaceControl.prototype);

  /**
   * The model for a zoom in control in the navigation control tool bar
   *
   * @alias ResetViewNavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   */
  var ResetViewNavigationControl = function (terria) {
      NavigationControl.apply(this, arguments);
      /**
       * Gets or sets the name of the control which is set as the control's title.
       * This property is observable.
       * @type {String}
       */
      this.name = "重置视图";
      this.navigationLocked = false;
      /**
       * Gets or sets the svg icon of the control.  This property is observable.
       * @type {Object}
       */
      this.svgIcon = svgReset;
      /**
       * Gets or sets the height of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgHeight = 15;
      /**
       * Gets or sets the width of the svg icon.  This property is observable.
       * @type {Integer}
       */
      this.svgWidth = 15;
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = "navigation-control-icon-reset";
  };
  ResetViewNavigationControl.prototype = Object.create(NavigationControl.prototype);
  ResetViewNavigationControl.prototype.setNavigationLocked = function (locked) {
      this.navigationLocked = locked;
  };
  ResetViewNavigationControl.prototype.resetView = function () {
      // this.terria.analytics.logEvent('navigation', 'click', 'reset');
      if (this.navigationLocked) {
          return;
      }
      var scene = this.terria.scene;
      var sscc = scene.screenSpaceCameraController;
      if (!sscc.enableInputs) {
          return;
      }
      this.isActive = true;
      scene.camera;
      if (Cesium__namespace.defined(this.terria.trackedEntity)) {
          // when tracking do not reset to default view but to default view of tracked entity
          var trackedEntity = this.terria.trackedEntity;
          this.terria.trackedEntity = undefined;
          this.terria.trackedEntity = trackedEntity;
      }
      else {
          // 定位到默认位置
          var _a = this.terria.options, position = _a.position, map = _a.map;
          if (position) {
              map.flyTo({
                  center: position.center,
                  zoom: position.zoom,
                  orientation: position.orientation,
                  duration: position.duration || 1
              });
          }
          else {
              map.flyTo({
                  center: map.options.center,
                  zoom: map.options.zoom,
                  orientation: map.options.orientation,
                  duration: 1
              });
          }
      }
      this.isActive = false;
  };
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control
   * @abstract
   * @protected
   * @ignore
   */
  ResetViewNavigationControl.prototype.activate = function () {
      this.resetView();
  };

  /* eslint-disable no-unused-vars */
  var Utils = {};
  var unprojectedScratch = new Cesium__namespace.Cartographic();
  var rayScratch = new Cesium__namespace.Ray();
  /**
   * gets the focus point of the camera
   * @param {Viewer|Widget} terria The terria
   * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
   * @param { Cesium.Cartesian3} [result] The object in which the result will be stored.
   * @return { Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
   * @ignore
   */
  // @ts-ignore
  Utils.getCameraFocus = function (terria, inWorldCoordinates, result) {
      var scene = terria.scene;
      var camera = scene.camera;
      if (scene.mode === 0 /* MORPHING */) {
          return undefined;
      }
      if (!Cesium__namespace.defined(result)) {
          result = new Cesium__namespace.Cartesian3();
      }
      // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
      // TODO bug when tracking: reset should reset to default view of tracked entity
      if (Cesium__namespace.defined(terria.trackedEntity)) {
          result = terria.trackedEntity.position.getValue(terria.clock.currentTime, result);
      }
      else {
          rayScratch.origin = camera.positionWC;
          rayScratch.direction = camera.directionWC;
          result = scene.globe.pick(rayScratch, scene, result);
      }
      if (!Cesium__namespace.defined(result)) {
          return undefined;
      }
      if (scene.mode === 2 /* SCENE2D */ || scene.mode === 1 /* COLUMBUS_VIEW */) {
          result = camera.worldToCameraCoordinatesPoint(result, result);
          if (inWorldCoordinates) {
              result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);
          }
      }
      else {
          if (!inWorldCoordinates) {
              result = camera.worldToCameraCoordinatesPoint(result, result);
          }
      }
      return result;
  };

  /**
   * The model for a zoom in control in the navigation control tool bar
   *
   * @alias ZoomOutNavigationControl
   * @constructor
   * @abstract
   * @ignore
   *
   * @param {Terria} terria The Terria instance.
   * @param {boolean} zoomIn is used for zooming in (true) or out (false)
   */
  var ZoomNavigationControl = function (terria, zoomIn) {
      NavigationControl.apply(this, arguments);
      /**
       * Gets or sets the name of the control which is set as the control's title.
       * This property is observable.
       * @type {String}
       */
      this.name = "Zoom " + (zoomIn ? "In" : "Out");
      /**
       * Gets or sets the text to be displayed in the nav control. Controls that
       * have text do not display the svgIcon.
       * This property is observable.
       * @type {String}
       */
      this.text = zoomIn ? "+" : "-";
      /**
       * Gets or sets the CSS class of the control. This property is observable.
       * @type {String}
       */
      this.cssClass = "navigation-control-icon-zoom-" + (zoomIn ? "in" : "out");
      this.relativeAmount = 2;
      if (zoomIn) {
          // this ensures that zooming in is the inverse of zooming out and vice versa
          // e.g. the camera position remains when zooming in and out
          this.relativeAmount = 1 / this.relativeAmount;
      }
  };
  ZoomNavigationControl.prototype.relativeAmount = 1;
  ZoomNavigationControl.prototype = Object.create(NavigationControl.prototype);
  /**
   * When implemented in a derived class, performs an action when the user clicks
   * on this control
   * @abstract
   * @protected
   * @ignore
   */
  ZoomNavigationControl.prototype.activate = function () {
      this.zoom(this.relativeAmount);
  };
  var cartesian3Scratch = new Cesium__namespace.Cartesian3();
  ZoomNavigationControl.prototype.zoom = function (relativeAmount) {
      // this.terria.analytics.logEvent('navigation', 'click', 'zoomIn');
      this.isActive = true;
      if (Cesium__namespace.defined(this.terria)) {
          var scene = this.terria.scene;
          var sscc = scene.screenSpaceCameraController;
          // do not zoom if it is disabled
          if (!sscc.enableInputs || !sscc.enableZoom) {
              return;
          }
          // TODO
          //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
          //                return;
          //            }
          var camera = scene.camera;
          var orientation_1;
          if (scene.mode === 0 /* MORPHING */) ;
          else if (scene.mode === 2 /* SCENE2D */) {
              camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
          }
          else {
              var focus_1;
              if (Cesium__namespace.defined(this.terria.trackedEntity)) {
                  focus_1 = new Cesium__namespace.Cartesian3();
              }
              else {
                  // @ts-ignore
                  focus_1 = Utils.getCameraFocus(this.terria, false);
              }
              if (!Cesium__namespace.defined(focus_1)) {
                  // Cesium.Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                  // the focal point.
                  var ray = new Cesium__namespace.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                  focus_1 = Cesium__namespace.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);
                  orientation_1 = {
                      heading: camera.heading,
                      pitch: camera.pitch,
                      roll: camera.roll
                  };
              }
              else {
                  orientation_1 = {
                      direction: camera.direction,
                      up: camera.up
                  };
              }
              var direction = Cesium__namespace.Cartesian3.subtract(camera.position, focus_1, cartesian3Scratch);
              var movementVector = Cesium__namespace.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
              var endPosition = Cesium__namespace.Cartesian3.add(focus_1, movementVector, focus_1);
              if (Cesium__namespace.defined(this.terria.trackedEntity) || scene.mode === 1 /* COLUMBUS_VIEW */) {
                  // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                  // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                  camera.position = endPosition;
              }
              else {
                  camera.flyTo({
                      destination: endPosition,
                      orientation: orientation_1,
                      duration: 0.5,
                      convert: false
                  });
              }
          }
      }
      // this.terria.notifyRepaintRequired();
      this.isActive = false;
  };

  var svgCompassOuterRing = "M73.5,20.7c-28.9,0-52.3,23.5-52.3,52.6s23.4,52.6,52.3,52.6s52.3-23.5,52.3-52.6S102.4,20.7,73.5,20.7z M73.5,22.5c13.8,0,26.4,5.6,35.5,14.7L98,48.2l0.6,0.6l11-11.1c8.9,9.1,14.4,21.7,14.4,35.5s-5.5,26.3-14.4,35.5l-11-11.1L98,98.3l11,11.1c-9.1,9-21.7,14.7-35.5,14.7s-26.3-5.5-35.4-14.6l11.1-11.2c6.3,6.1,14.9,9.9,24.3,9.9c19.2,0,34.9-15.7,34.9-35.1s-15.6-35-34.9-35c-9.5,0-18,3.8-24.3,9.9L38.1,37C47.2,28,59.7,22.5,73.5,22.5z M72.6,23.3v14h1.8v-14H72.6z M37.5,37.7l11.1,11.2c-6.1,6.3-9.9,15-9.9,24.4s3.8,18.2,9.9,24.4l-11.1,11.2C28.5,99.7,23,87.1,23,73.2S28.5,46.8,37.5,37.7z M73.5,40c18.3,0,33.1,14.9,33.1,33.3s-14.8,33.3-33.1,33.3S40.4,91.6,40.4,73.2S55.2,40,73.5,40z M23.8,72.3v1.8h14v-1.8H23.8z M109.4,72.3v1.8h14v-1.8H109.4z M72.8,109.2v14h1.7v-14H72.8z M66.2,12.3l-0.4-1.9c0.5-0.1,1.1-0.3,2-0.5c0.9-0.2,1.6-0.3,2-0.4V5.9h-3.7V4.2h3.7V1h2.3v12.6h-2.3v-2.1 C68.6,11.7,67.4,12,66.2,12.3z M79.5,2.7l1.6,1.5c-1.5,0.9-3.2,1.9-4.9,2.8v3.9c0,0.5,0.3,0.8,0.9,0.8h0.5c0.6,0,0.9-0.3,1-1 c0-0.1,0-0.2,0.1-0.4c0.1-0.7,0.1-1.3,0.1-1.8c0.1,0,0.3,0.1,0.5,0.1C79.9,8.7,80.4,8.9,81,9c0,0.4-0.1,1-0.3,1.9 c0,0.3-0.1,0.4-0.1,0.6c-0.3,1.2-1.2,1.8-2.7,1.8h-1.4c-1.8,0-2.7-0.7-2.7-2V1h2.3v3.8C77.5,4.1,78.6,3.4,79.5,2.7z";

  var svgCompassGyro = "m 72.71875,54.375 c -0.476702,0 -0.908208,0.245402 -1.21875,0.5625 -0.310542,0.317098 -0.551189,0.701933 -0.78125,1.1875 -0.172018,0.363062 -0.319101,0.791709 -0.46875,1.25 -6.91615,1.075544 -12.313231,6.656514 -13,13.625 -0.327516,0.117495 -0.661877,0.244642 -0.9375,0.375 -0.485434,0.22959 -0.901634,0.471239 -1.21875,0.78125 -0.317116,0.310011 -0.5625,0.742111 -0.5625,1.21875 l 0.03125,0 c 0,0.476639 0.245384,0.877489 0.5625,1.1875 0.317116,0.310011 0.702066,0.58291 1.1875,0.8125 0.35554,0.168155 0.771616,0.32165 1.21875,0.46875 1.370803,6.10004 6.420817,10.834127 12.71875,11.8125 0.146999,0.447079 0.30025,0.863113 0.46875,1.21875 0.230061,0.485567 0.470708,0.870402 0.78125,1.1875 0.310542,0.317098 0.742048,0.5625 1.21875,0.5625 0.476702,0 0.876958,-0.245402 1.1875,-0.5625 0.310542,-0.317098 0.582439,-0.701933 0.8125,-1.1875 0.172018,-0.363062 0.319101,-0.791709 0.46875,-1.25 6.249045,-1.017063 11.256351,-5.7184 12.625,-11.78125 0.447134,-0.1471 0.86321,-0.300595 1.21875,-0.46875 0.485434,-0.22959 0.901633,-0.502489 1.21875,-0.8125 0.317117,-0.310011 0.5625,-0.710861 0.5625,-1.1875 l -0.03125,0 c 0,-0.476639 -0.245383,-0.908739 -0.5625,-1.21875 C 89.901633,71.846239 89.516684,71.60459 89.03125,71.375 88.755626,71.244642 88.456123,71.117495 88.125,71 87.439949,64.078341 82.072807,58.503735 75.21875,57.375 c -0.15044,-0.461669 -0.326927,-0.884711 -0.5,-1.25 -0.230061,-0.485567 -0.501958,-0.870402 -0.8125,-1.1875 -0.310542,-0.317098 -0.710798,-0.5625 -1.1875,-0.5625 z m -0.0625,1.40625 c 0.03595,-0.01283 0.05968,0 0.0625,0 0.0056,0 0.04321,-0.02233 0.1875,0.125 0.144288,0.147334 0.34336,0.447188 0.53125,0.84375 0.06385,0.134761 0.123901,0.309578 0.1875,0.46875 -0.320353,-0.01957 -0.643524,-0.0625 -0.96875,-0.0625 -0.289073,0 -0.558569,0.04702 -0.84375,0.0625 C 71.8761,57.059578 71.936151,56.884761 72,56.75 c 0.18789,-0.396562 0.355712,-0.696416 0.5,-0.84375 0.07214,-0.07367 0.120304,-0.112167 0.15625,-0.125 z m 0,2.40625 c 0.448007,0 0.906196,0.05436 1.34375,0.09375 0.177011,0.592256 0.347655,1.271044 0.5,2.03125 0.475097,2.370753 0.807525,5.463852 0.9375,8.9375 -0.906869,-0.02852 -1.834463,-0.0625 -2.78125,-0.0625 -0.92298,0 -1.802327,0.03537 -2.6875,0.0625 0.138529,-3.473648 0.493653,-6.566747 0.96875,-8.9375 0.154684,-0.771878 0.320019,-1.463985 0.5,-2.0625 0.405568,-0.03377 0.804291,-0.0625 1.21875,-0.0625 z m -2.71875,0.28125 c -0.129732,0.498888 -0.259782,0.987558 -0.375,1.5625 -0.498513,2.487595 -0.838088,5.693299 -0.96875,9.25 -3.21363,0.15162 -6.119596,0.480068 -8.40625,0.9375 -0.682394,0.136509 -1.275579,0.279657 -1.84375,0.4375 0.799068,-6.135482 5.504716,-11.036454 11.59375,-12.1875 z M 75.5,58.5 c 6.043169,1.18408 10.705093,6.052712 11.5,12.15625 -0.569435,-0.155806 -1.200273,-0.302525 -1.875,-0.4375 -2.262525,-0.452605 -5.108535,-0.783809 -8.28125,-0.9375 -0.130662,-3.556701 -0.470237,-6.762405 -0.96875,-9.25 C 75.761959,59.467174 75.626981,58.990925 75.5,58.5 z m -2.84375,12.09375 c 0.959338,0 1.895843,0.03282 2.8125,0.0625 C 75.48165,71.267751 75.5,71.871028 75.5,72.5 c 0,1.228616 -0.01449,2.438313 -0.0625,3.59375 -0.897358,0.0284 -1.811972,0.0625 -2.75,0.0625 -0.927373,0 -1.831062,-0.03473 -2.71875,-0.0625 -0.05109,-1.155437 -0.0625,-2.365134 -0.0625,-3.59375 0,-0.628972 0.01741,-1.232249 0.03125,-1.84375 0.895269,-0.02827 1.783025,-0.0625 2.71875,-0.0625 z M 68.5625,70.6875 c -0.01243,0.60601 -0.03125,1.189946 -0.03125,1.8125 0,1.22431 0.01541,2.407837 0.0625,3.5625 -3.125243,-0.150329 -5.92077,-0.471558 -8.09375,-0.90625 -0.784983,-0.157031 -1.511491,-0.316471 -2.125,-0.5 -0.107878,-0.704096 -0.1875,-1.422089 -0.1875,-2.15625 0,-0.115714 0.02849,-0.228688 0.03125,-0.34375 0.643106,-0.20284 1.389577,-0.390377 2.25,-0.5625 2.166953,-0.433487 4.97905,-0.75541 8.09375,-0.90625 z m 8.3125,0.03125 c 3.075121,0.15271 5.824455,0.446046 7.96875,0.875 0.857478,0.171534 1.630962,0.360416 2.28125,0.5625 0.0027,0.114659 0,0.228443 0,0.34375 0,0.735827 -0.07914,1.450633 -0.1875,2.15625 -0.598568,0.180148 -1.29077,0.34562 -2.0625,0.5 -2.158064,0.431708 -4.932088,0.754666 -8.03125,0.90625 0.04709,-1.154663 0.0625,-2.33819 0.0625,-3.5625 0,-0.611824 -0.01924,-1.185379 -0.03125,-1.78125 z M 57.15625,72.5625 c 0.0023,0.572772 0.06082,1.131112 0.125,1.6875 -0.125327,-0.05123 -0.266577,-0.10497 -0.375,-0.15625 -0.396499,-0.187528 -0.665288,-0.387337 -0.8125,-0.53125 -0.147212,-0.143913 -0.15625,-0.182756 -0.15625,-0.1875 0,-0.0047 -0.02221,-0.07484 0.125,-0.21875 0.147212,-0.143913 0.447251,-0.312472 0.84375,-0.5 0.07123,-0.03369 0.171867,-0.06006 0.25,-0.09375 z m 31.03125,0 c 0.08201,0.03503 0.175941,0.05872 0.25,0.09375 0.396499,0.187528 0.665288,0.356087 0.8125,0.5 0.14725,0.14391 0.15625,0.21405 0.15625,0.21875 0,0.0047 -0.009,0.04359 -0.15625,0.1875 -0.147212,0.143913 -0.416001,0.343722 -0.8125,0.53125 -0.09755,0.04613 -0.233314,0.07889 -0.34375,0.125 0.06214,-0.546289 0.09144,-1.094215 0.09375,-1.65625 z m -29.5,3.625 c 0.479308,0.123125 0.983064,0.234089 1.53125,0.34375 2.301781,0.460458 5.229421,0.787224 8.46875,0.9375 0.167006,2.84339 0.46081,5.433176 0.875,7.5 0.115218,0.574942 0.245268,1.063612 0.375,1.5625 -5.463677,-1.028179 -9.833074,-5.091831 -11.25,-10.34375 z m 27.96875,0 C 85.247546,81.408945 80.919274,85.442932 75.5,86.5 c 0.126981,-0.490925 0.261959,-0.967174 0.375,-1.53125 0.41419,-2.066824 0.707994,-4.65661 0.875,-7.5 3.204493,-0.15162 6.088346,-0.480068 8.375,-0.9375 0.548186,-0.109661 1.051942,-0.220625 1.53125,-0.34375 z M 70.0625,77.53125 c 0.865391,0.02589 1.723666,0.03125 2.625,0.03125 0.912062,0 1.782843,-0.0048 2.65625,-0.03125 -0.165173,2.736408 -0.453252,5.207651 -0.84375,7.15625 -0.152345,0.760206 -0.322989,1.438994 -0.5,2.03125 -0.437447,0.03919 -0.895856,0.0625 -1.34375,0.0625 -0.414943,0 -0.812719,-0.02881 -1.21875,-0.0625 -0.177011,-0.592256 -0.347655,-1.271044 -0.5,-2.03125 -0.390498,-1.948599 -0.700644,-4.419842 -0.875,-7.15625 z m 1.75,10.28125 c 0.284911,0.01545 0.554954,0.03125 0.84375,0.03125 0.325029,0 0.648588,-0.01171 0.96875,-0.03125 -0.05999,0.148763 -0.127309,0.31046 -0.1875,0.4375 -0.18789,0.396562 -0.386962,0.696416 -0.53125,0.84375 -0.144288,0.147334 -0.181857,0.125 -0.1875,0.125 -0.0056,0 -0.07446,0.02233 -0.21875,-0.125 C 72.355712,88.946416 72.18789,88.646562 72,88.25 71.939809,88.12296 71.872486,87.961263 71.8125,87.8125 z";

  var svgCompassRotationMarker = "M 72.46875,22.03125 C 59.505873,22.050338 46.521615,27.004287 36.6875,36.875 L 47.84375,47.96875 C 61.521556,34.240041 83.442603,34.227389 97.125,47.90625 l 11.125,-11.125 C 98.401629,26.935424 85.431627,22.012162 72.46875,22.03125 z";

  /* eslint-disable quotes */
  var CesiumMath = Cesium__namespace.Math;
  // @ts-ignore
  var Knockout = Cesium__namespace.knockout;
  var NavigationViewModel = function (options) {
      this.terria = options.terria;
      this.eventHelper = new Cesium__namespace.EventHelper();
      this.enableZoomControls = Cesium__namespace.defined(options.enableZoomControls) ? options.enableZoomControls : true;
      this.enableCompass = Cesium__namespace.defined(options.enableCompass) ? options.enableCompass : true;
      this.navigationLocked = false;
      // if (this.showZoomControls)
      //   {
      this.controls = options.controls;
      if (!Cesium__namespace.defined(this.controls)) {
          this.controls = [
              new ZoomNavigationControl(this.terria, true),
              new ResetViewNavigationControl(this.terria),
              new ZoomNavigationControl(this.terria, false)
          ];
      }
      // }
      this.svgCompassOuterRing = svgCompassOuterRing;
      this.svgCompassGyro = svgCompassGyro;
      this.svgCompassRotationMarker = svgCompassRotationMarker;
      this.showCompass = Cesium__namespace.defined(this.terria) && this.enableCompass;
      this.heading = this.showCompass ? this.terria.scene.camera.heading : 0.0;
      this.isOrbiting = false;
      this.orbitCursorAngle = 0;
      this.orbitCursorOpacity = 0.0;
      this.orbitLastTimestamp = 0;
      this.orbitFrame = undefined;
      this.orbitIsLook = false;
      this.orbitMouseMoveFunction = undefined;
      this.orbitMouseUpFunction = undefined;
      this.isRotating = false;
      this.rotateInitialCursorAngle = undefined;
      this.rotateFrame = undefined;
      this.rotateIsLook = false;
      this.rotateMouseMoveFunction = undefined;
      this.rotateMouseUpFunction = undefined;
      this._unsubcribeFromPostRender = undefined;
      Knockout.track(this, ["controls", "showCompass", "heading", "isOrbiting", "orbitCursorAngle", "isRotating"]);
      var that = this;
      NavigationViewModel.prototype.setNavigationLocked = function (locked) {
          this.navigationLocked = locked;
          if (this.controls && this.controls.length > 1) {
              this.controls[1].setNavigationLocked(this.navigationLocked);
          }
      };
      function widgetChange() {
          if (Cesium__namespace.defined(that.terria)) {
              if (that._unsubcribeFromPostRender) {
                  that._unsubcribeFromPostRender();
                  that._unsubcribeFromPostRender = undefined;
              }
              that.showCompass = that.enableCompass;
              that._unsubcribeFromPostRender = that.terria.scene.postRender.addEventListener(function () {
                  that.heading = that.terria.scene.camera.heading;
              });
          }
          else {
              if (that._unsubcribeFromPostRender) {
                  that._unsubcribeFromPostRender();
                  that._unsubcribeFromPostRender = undefined;
              }
              that.showCompass = false;
          }
      }
      this.eventHelper.add(this.terria.afterWidgetChanged, widgetChange, this);
      // this.terria.afterWidgetChanged.addEventListener(widgetChange);
      widgetChange();
  };
  NavigationViewModel.prototype.destroy = function () {
      this.eventHelper.removeAll();
      // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);
  };
  NavigationViewModel.prototype.show = function (container) {
      var testing;
      if (this.enableZoomControls && this.enableCompass) {
          testing =
              '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls">' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (!this.enableZoomControls && this.enableCompass) {
          testing =
              '<div class="compass" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"  style="display: none;" >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (this.enableZoomControls && !this.enableCompass) {
          testing =
              '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"    >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      else if (!this.enableZoomControls && !this.enableCompass) {
          testing =
              '<div class="compass"  style="display: none;" title="" data-bind="visible: showCompass, event: { mousedown: handleMouseDown, dblclick: handleDoubleClick }">' +
                  '<div class="compass-outer-ring-background"></div>' +
                  " <div class=\"compass-rotation-marker\" data-bind=\"visible: isOrbiting, style: { transform: 'rotate(-' + orbitCursorAngle + 'rad)', '-webkit-transform': 'rotate(-' + orbitCursorAngle + 'rad)', opacity: orbitCursorOpacity }, cesiumSvgPath: { path: svgCompassRotationMarker, width: 145, height: 145 }\"></div>" +
                  " <div class=\"compass-outer-ring\" title=\"\" data-bind=\"style: { transform: 'rotate(-' + heading + 'rad)', '-webkit-transform': 'rotate(-' + heading + 'rad)' }, cesiumSvgPath: { path: svgCompassOuterRing, width: 145, height: 145 }\"></div>" +
                  ' <div class="compass-gyro-background"></div>' +
                  ' <div class="compass-gyro" data-bind="cesiumSvgPath: { path: svgCompassGyro, width: 145, height: 145 }, css: { \'compass-gyro-active\': isOrbiting }"></div>' +
                  "</div>" +
                  '<div class="navigation-controls"   style="display: none;" >' +
                  "<!-- ko foreach: controls -->" +
                  "<div data-bind=\"click: activate, attr: { title: $data.name }, css: $root.isLastControl($data) ? 'navigation-control-last' : 'navigation-control' \">" +
                  "   <!-- ko if: $data.hasText -->" +
                  "   <div data-bind=\"text: $data.text, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "   <!-- /ko -->" +
                  "  <!-- ko ifnot: $data.hasText -->" +
                  "  <div data-bind=\"cesiumSvgPath: { path: $data.svgIcon, width: $data.svgWidth, height: $data.svgHeight }, css: $data.isActive ?  'navigation-control-icon-active ' + $data.cssClass : $data.cssClass\"></div>" +
                  "  <!-- /ko -->" +
                  " </div>" +
                  " <!-- /ko -->" +
                  "</div>";
      }
      loadView(testing, container, this);
      // loadView(navigatorTemplate, container, this);
      // loadView(require('fs').readFileSync(baseURLEmpCesium + 'js-lib/terrajs/lib/Views/Navigation.html', 'utf8'), container, this);
  };
  /**
   * Adds a control to this toolbar.
   * @param {NavControl} control The control to add.
   * @ignore
   */
  NavigationViewModel.prototype.add = function (control) {
      this.controls.push(control);
  };
  /**
   * Removes a control from this toolbar.
   * @param {NavControl} control The control to remove.
   * @ignore
   */
  NavigationViewModel.prototype.remove = function (control) {
      this.controls.remove(control);
  };
  /**
   * Checks if the control given is the last control in the control array.
   * @param {NavControl} control The control to remove.
   * @ignore
   */
  NavigationViewModel.prototype.isLastControl = function (control) {
      return control === this.controls[this.controls.length - 1];
  };
  var vectorScratch = new Cesium__namespace.Cartesian2();
  NavigationViewModel.prototype.handleMouseDown = function (viewModel, e) {
      var scene = this.terria.scene;
      if (scene.mode === 0 /* MORPHING */) {
          return true;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      var compassElement = e.currentTarget;
      var compassRectangle = e.currentTarget.getBoundingClientRect();
      var maxDistance = compassRectangle.width / 2.0;
      var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
      var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
      var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch);
      var distanceFromCenter = Cesium__namespace.Cartesian2.magnitude(vector);
      var distanceFraction = distanceFromCenter / maxDistance;
      var nominalTotalRadius = 145;
      var norminalGyroRadius = 50;
      if (distanceFraction < norminalGyroRadius / nominalTotalRadius) {
          orbit(this, compassElement, vector);
          //            return false;
      }
      else if (distanceFraction < 1.0) {
          rotate(this, compassElement, vector);
          //            return false;
      }
      else {
          return true;
      }
  };
  var oldTransformScratch = new Cesium__namespace.Matrix4();
  var newTransformScratch = new Cesium__namespace.Matrix4();
  var centerScratch = new Cesium__namespace.Cartesian3();
  NavigationViewModel.prototype.handleDoubleClick = function (viewModel, e) {
      var scene = viewModel.terria.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;
      if (scene.mode === 0 /* MORPHING */ || !sscc.enableInputs) {
          return true;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      if (scene.mode === 1 /* COLUMBUS_VIEW */ && !sscc.enableTranslate) {
          return;
      }
      if (scene.mode === 3 /* SCENE3D */ || scene.mode === 1 /* COLUMBUS_VIEW */) {
          if (!sscc.enableLook) {
              return;
          }
          if (scene.mode === 3 /* SCENE3D */) {
              if (!sscc.enableRotate) {
                  return;
              }
          }
      }
      // @ts-ignore
      var center = Utils.getCameraFocus(viewModel.terria, true, centerScratch);
      if (!Cesium__namespace.defined(center)) {
          // Globe is barely visible, so reset to home view.
          this.controls[1].resetView();
          return;
      }
      var cameraPosition = scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic, new Cesium__namespace.Cartesian3());
      var surfaceNormal = scene.globe.ellipsoid.geodeticSurfaceNormal(center);
      var focusBoundingSphere = new Cesium__namespace.BoundingSphere(center, 0);
      camera.flyToBoundingSphere(focusBoundingSphere, {
          offset: new Cesium__namespace.HeadingPitchRange(0, 
          // do not use camera.pitch since the pitch at the center/target is required
          CesiumMath.PI_OVER_TWO - Cesium__namespace.Cartesian3.angleBetween(surfaceNormal, camera.directionWC), 
          // distanceToBoundingSphere returns wrong values when in 2D or Columbus view so do not use
          // camera.distanceToBoundingSphere(focusBoundingSphere)
          // instead calculate distance manually
          Cesium__namespace.Cartesian3.distance(cameraPosition, center)),
          duration: 1.5
      });
  };
  NavigationViewModel.create = function (options) {
      // options.enableZoomControls = this.enableZoomControls;
      // options.enableCompass = this.enableCompass;
      var result = new NavigationViewModel(options);
      result.show(options.container);
      return result;
  };
  function orbit(viewModel, compassElement, cursorVector) {
      var scene = viewModel.terria.scene;
      var sscc = scene.screenSpaceCameraController;
      // do not orbit if it is disabled
      if (scene.mode === 0 /* MORPHING */ || !sscc.enableInputs) {
          return;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      switch (scene.mode) {
          case 1 /* COLUMBUS_VIEW */:
              if (sscc.enableLook) {
                  break;
              }
              if (!sscc.enableTranslate || !sscc.enableTilt) {
                  return;
              }
              break;
          case 3 /* SCENE3D */:
              if (sscc.enableLook) {
                  break;
              }
              if (!sscc.enableTilt || !sscc.enableRotate) {
                  return;
              }
              break;
          case 2 /* SCENE2D */:
              if (!sscc.enableTranslate) {
                  return;
              }
              break;
      }
      // Remove existing event handlers, if any.
      document.removeEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
      document.removeEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
      if (Cesium__namespace.defined(viewModel.orbitTickFunction)) {
          viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
      }
      viewModel.orbitMouseMoveFunction = undefined;
      viewModel.orbitMouseUpFunction = undefined;
      viewModel.orbitTickFunction = undefined;
      viewModel.isOrbiting = true;
      // @ts-ignore
      viewModel.orbitLastTimestamp = Cesium__namespace.getTimestamp();
      var camera = scene.camera;
      if (Cesium__namespace.defined(viewModel.terria.trackedEntity)) {
          // when tracking an entity simply use that reference frame
          viewModel.orbitFrame = undefined;
          viewModel.orbitIsLook = false;
      }
      else {
          // @ts-ignore
          var center = Utils.getCameraFocus(viewModel.terria, true, centerScratch);
          if (!Cesium__namespace.defined(center)) {
              viewModel.orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
              viewModel.orbitIsLook = true;
          }
          else {
              viewModel.orbitFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(center, scene.globe.ellipsoid, newTransformScratch);
              viewModel.orbitIsLook = false;
          }
      }
      viewModel.orbitTickFunction = function (e) {
          // @ts-ignore
          var timestamp = Cesium__namespace.getTimestamp();
          var deltaT = timestamp - viewModel.orbitLastTimestamp;
          var rate = ((viewModel.orbitCursorOpacity - 0.5) * 2.5) / 1000;
          var distance = deltaT * rate;
          var angle = viewModel.orbitCursorAngle + CesiumMath.PI_OVER_TWO;
          var x = Math.cos(angle) * distance;
          var y = Math.sin(angle) * distance;
          var oldTransform;
          if (viewModel.navigationLocked) {
              return true;
          }
          if (Cesium__namespace.defined(viewModel.orbitFrame)) {
              oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch);
              camera.lookAtTransform(viewModel.orbitFrame);
          }
          // do not look up/down or rotate in 2D mode
          if (scene.mode === 2 /* SCENE2D */) {
              camera.move(new Cesium__namespace.Cartesian3(x, y, 0), (Math.max(scene.canvas.clientWidth, scene.canvas.clientHeight) / 100) *
                  camera.positionCartographic.height *
                  distance);
          }
          else {
              if (viewModel.orbitIsLook) {
                  camera.look(Cesium__namespace.Cartesian3.UNIT_Z, -x);
                  camera.look(camera.right, -y);
              }
              else {
                  camera.rotateLeft(x);
                  camera.rotateUp(y);
              }
          }
          if (Cesium__namespace.defined(viewModel.orbitFrame)) {
              camera.lookAtTransform(oldTransform);
          }
          // viewModel.terria.cesium.notifyRepaintRequired();
          viewModel.orbitLastTimestamp = timestamp;
      };
      function updateAngleAndOpacity(vector, compassWidth) {
          var angle = Math.atan2(-vector.y, vector.x);
          viewModel.orbitCursorAngle = CesiumMath.zeroToTwoPi(angle - CesiumMath.PI_OVER_TWO);
          var distance = Cesium__namespace.Cartesian2.magnitude(vector);
          var maxDistance = compassWidth / 2.0;
          var distanceFraction = Math.min(distance / maxDistance, 1.0);
          var easedOpacity = 0.5 * distanceFraction * distanceFraction + 0.5;
          viewModel.orbitCursorOpacity = easedOpacity;
          // viewModel.terria.cesium.notifyRepaintRequired();
      }
      viewModel.orbitMouseMoveFunction = function (e) {
          var compassRectangle = compassElement.getBoundingClientRect();
          var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
          var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
          var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch);
          updateAngleAndOpacity(vector, compassRectangle.width);
      };
      viewModel.orbitMouseUpFunction = function (e) {
          // TODO: if mouse didn't move, reset view to looking down, north is up?
          viewModel.isOrbiting = false;
          document.removeEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
          document.removeEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
          if (Cesium__namespace.defined(viewModel.orbitTickFunction)) {
              viewModel.terria.clock.onTick.removeEventListener(viewModel.orbitTickFunction);
          }
          viewModel.orbitMouseMoveFunction = undefined;
          viewModel.orbitMouseUpFunction = undefined;
          viewModel.orbitTickFunction = undefined;
      };
      document.addEventListener("mousemove", viewModel.orbitMouseMoveFunction, false);
      document.addEventListener("mouseup", viewModel.orbitMouseUpFunction, false);
      viewModel.terria.clock.onTick.addEventListener(viewModel.orbitTickFunction);
      updateAngleAndOpacity(cursorVector, compassElement.getBoundingClientRect().width);
  }
  function rotate(viewModel, compassElement, cursorVector) {
      var scene = viewModel.terria.scene;
      var camera = scene.camera;
      var sscc = scene.screenSpaceCameraController;
      // do not rotate in 2D mode or if rotating is disabled
      if (scene.mode === 0 /* MORPHING */ || scene.mode === 2 /* SCENE2D */ || !sscc.enableInputs) {
          return;
      }
      if (viewModel.navigationLocked) {
          return true;
      }
      if (!sscc.enableLook &&
          (scene.mode === 1 /* COLUMBUS_VIEW */ || (scene.mode === 3 /* SCENE3D */ && !sscc.enableRotate))) {
          return;
      }
      // Remove existing event handlers, if any.
      document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
      document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
      viewModel.rotateMouseMoveFunction = undefined;
      viewModel.rotateMouseUpFunction = undefined;
      viewModel.isRotating = true;
      viewModel.rotateInitialCursorAngle = Math.atan2(-cursorVector.y, cursorVector.x);
      if (Cesium__namespace.defined(viewModel.terria.trackedEntity)) {
          // when tracking an entity simply use that reference frame
          viewModel.rotateFrame = undefined;
          viewModel.rotateIsLook = false;
      }
      else {
          // @ts-ignore
          var viewCenter = Utils.getCameraFocus(viewModel.terria, true, centerScratch);
          if (!Cesium__namespace.defined(viewCenter) ||
              (scene.mode === 1 /* COLUMBUS_VIEW */ && !sscc.enableLook && !sscc.enableTranslate)) {
              viewModel.rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(camera.positionWC, scene.globe.ellipsoid, newTransformScratch);
              viewModel.rotateIsLook = true;
          }
          else {
              viewModel.rotateFrame = Cesium__namespace.Transforms.eastNorthUpToFixedFrame(viewCenter, scene.globe.ellipsoid, newTransformScratch);
              viewModel.rotateIsLook = false;
          }
      }
      var oldTransform;
      if (Cesium__namespace.defined(viewModel.rotateFrame)) {
          oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch);
          camera.lookAtTransform(viewModel.rotateFrame);
      }
      viewModel.rotateInitialCameraAngle = -camera.heading;
      if (Cesium__namespace.defined(viewModel.rotateFrame)) {
          camera.lookAtTransform(oldTransform);
      }
      viewModel.rotateMouseMoveFunction = function (e) {
          var compassRectangle = compassElement.getBoundingClientRect();
          var center = new Cesium__namespace.Cartesian2((compassRectangle.right - compassRectangle.left) / 2.0, (compassRectangle.bottom - compassRectangle.top) / 2.0);
          var clickLocation = new Cesium__namespace.Cartesian2(e.clientX - compassRectangle.left, e.clientY - compassRectangle.top);
          var vector = Cesium__namespace.Cartesian2.subtract(clickLocation, center, vectorScratch);
          var angle = Math.atan2(-vector.y, vector.x);
          var angleDifference = angle - viewModel.rotateInitialCursorAngle;
          var newCameraAngle = CesiumMath.zeroToTwoPi(viewModel.rotateInitialCameraAngle - angleDifference);
          var camera = viewModel.terria.scene.camera;
          var oldTransform;
          if (Cesium__namespace.defined(viewModel.rotateFrame)) {
              oldTransform = Cesium__namespace.Matrix4.clone(camera.transform, oldTransformScratch);
              camera.lookAtTransform(viewModel.rotateFrame);
          }
          var currentCameraAngle = -camera.heading;
          camera.rotateRight(newCameraAngle - currentCameraAngle);
          if (Cesium__namespace.defined(viewModel.rotateFrame)) {
              camera.lookAtTransform(oldTransform);
          }
          // viewModel.terria.cesium.notifyRepaintRequired();
      };
      viewModel.rotateMouseUpFunction = function (e) {
          viewModel.isRotating = false;
          document.removeEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
          document.removeEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
          viewModel.rotateMouseMoveFunction = undefined;
          viewModel.rotateMouseUpFunction = undefined;
      };
      document.addEventListener("mousemove", viewModel.rotateMouseMoveFunction, false);
      document.addEventListener("mouseup", viewModel.rotateMouseUpFunction, false);
  }

  // @ts-ignore
  var CesiumEvent = Cesium__namespace.Event;
  /**
   * @alias CesiumNavigationClass
   * @constructor
   * @ignore
   *
   * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
   */
  var CesiumNavigationClass = function (viewerCesiumWidget) {
      initialize.apply(this, arguments);
      this._onDestroyListeners = [];
  };
  CesiumNavigationClass.prototype.distanceLegendViewModel = undefined;
  CesiumNavigationClass.prototype.navigationViewModel = undefined;
  CesiumNavigationClass.prototype.navigationDiv = undefined;
  CesiumNavigationClass.prototype.distanceLegendDiv = undefined;
  CesiumNavigationClass.prototype.terria = undefined;
  CesiumNavigationClass.prototype.container = undefined;
  CesiumNavigationClass.prototype._onDestroyListeners = undefined;
  CesiumNavigationClass.prototype._navigationLocked = false;
  CesiumNavigationClass.prototype.setNavigationLocked = function (locked) {
      this._navigationLocked = locked;
      this.navigationViewModel.setNavigationLocked(this._navigationLocked);
  };
  CesiumNavigationClass.prototype.getNavigationLocked = function () {
      return this._navigationLocked;
  };
  CesiumNavigationClass.prototype.destroy = function () {
      if (Cesium__namespace.defined(this.navigationViewModel)) {
          this.navigationViewModel.destroy();
      }
      if (Cesium__namespace.defined(this.distanceLegendViewModel)) {
          this.distanceLegendViewModel.destroy();
      }
      if (Cesium__namespace.defined(this.navigationDiv)) {
          this.navigationDiv.parentNode.removeChild(this.navigationDiv);
      }
      delete this.navigationDiv;
      if (Cesium__namespace.defined(this.distanceLegendDiv)) {
          this.distanceLegendDiv.parentNode.removeChild(this.distanceLegendDiv);
      }
      delete this.distanceLegendDiv;
      if (Cesium__namespace.defined(this.container)) {
          this.container.parentNode.removeChild(this.container);
      }
      delete this.container;
      for (var i = 0; i < this._onDestroyListeners.length; i++) {
          this._onDestroyListeners[i]();
      }
  };
  CesiumNavigationClass.prototype.addOnDestroyListener = function (callback) {
      if (typeof callback === "function") {
          this._onDestroyListeners.push(callback);
      }
  };
  /**
   * @param {Viewer|CesiumWidget} viewerCesiumWidget The Viewer or CesiumWidget instance
   * @param options
   * @ignore
   */
  function initialize(viewerCesiumWidget, options) {
      if (!Cesium__namespace.defined(viewerCesiumWidget)) {
          throw new Cesium__namespace.DeveloperError("CesiumWidget or Viewer is required.");
      }
      //        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
      var cesiumWidget = Cesium__namespace.defined(viewerCesiumWidget.cesiumWidget)
          ? viewerCesiumWidget.cesiumWidget
          : viewerCesiumWidget;
      var container = document.createElement("div");
      container.className = "cesium-widget-cesiumNavigationContainer";
      cesiumWidget.container.appendChild(container);
      this.terria = viewerCesiumWidget;
      this.terria.options = Cesium__namespace.defined(options) ? options : {};
      this.terria.afterWidgetChanged = new CesiumEvent();
      this.terria.beforeWidgetChanged = new CesiumEvent();
      this.container = container;
      // this.navigationDiv.setAttribute("id", "navigationDiv");
      // Register custom Knockout.js bindings.  If you're not using the TerriaJS user interface, you can remove this.
      registerKnockoutBindings();
      if (!Cesium__namespace.defined(this.terria.options.enableDistanceLegend) || this.terria.options.enableDistanceLegend) {
          this.distanceLegendDiv = document.createElement("div");
          container.appendChild(this.distanceLegendDiv);
          this.distanceLegendDiv.setAttribute("id", "distanceLegendDiv");
          this.distanceLegendViewModel = DistanceLegendViewModel.create({
              container: this.distanceLegendDiv,
              terria: this.terria,
              mapElement: container,
              enableDistanceLegend: true
          });
      }
      if ((!Cesium__namespace.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) &&
          (!Cesium__namespace.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: true,
              enableCompass: true
          });
      }
      else if (Cesium__namespace.defined(this.terria.options.enableZoomControls) &&
          !this.terria.options.enableZoomControls &&
          (!Cesium__namespace.defined(this.terria.options.enableCompass) || this.terria.options.enableCompass)) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: false,
              enableCompass: true
          });
      }
      else if ((!Cesium__namespace.defined(this.terria.options.enableZoomControls) || this.terria.options.enableZoomControls) &&
          Cesium__namespace.defined(this.terria.options.enableCompass) &&
          !this.terria.options.enableCompass) {
          this.navigationDiv = document.createElement("div");
          this.navigationDiv.setAttribute("id", "navigationDiv");
          container.appendChild(this.navigationDiv);
          // Create the navigation controls.
          this.navigationViewModel = NavigationViewModel.create({
              container: this.navigationDiv,
              terria: this.terria,
              enableZoomControls: true,
              enableCompass: false
          });
      }
      else if (Cesium__namespace.defined(this.terria.options.enableZoomControls) &&
          !this.terria.options.enableZoomControls &&
          Cesium__namespace.defined(this.terria.options.enableCompass) &&
          !this.terria.options.enableCompass) ;
  }

  /**
   * 罗盘组件
   */
  var Compass = /** @class */ (function (_super) {
      __extends$3(Compass, _super);
      function Compass(options, map) {
          return _super.call(this, __assign$1({ compass: true, scaleLine: true, zoom: true }, options), map) || this;
      }
      /**
       * 初始化
       * @ignore
       */
      Compass.prototype.init = function () {
          this.initialized = true;
          var _a = this.options, compass = _a.compass, scaleLine = _a.scaleLine, zoom = _a.zoom;
          var viewer = this.map.map;
          var defaultOptions = {
              defaultResetView: viewer.scene.camera.position,
              enableCompass: compass,
              enableZoomControls: zoom,
              enableDistanceLegend: scaleLine,
              enableCompassOuterRing: true
          };
          // @ts-ignore
          this._component = new CesiumNavigationClass(viewer, __assign$1(__assign$1(__assign$1({}, defaultOptions), this._options), { map: this.map }));
      };
      /**
       * 从地球移除
       * @ignore
       */
      Compass.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._component.destroy();
          this._component = void 0;
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Compass.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Compass;
  }(Component$1));

  /**
   * 坐标信息组件
   */
  var Coordinate = /** @class */ (function (_super) {
      __extends$3(Coordinate, _super);
      function Coordinate(options, map) {
          return _super.call(this, options, map) || this;
      }
      /**
       * @ignore
       */
      Coordinate.prototype.init = function () {
          var _a = this._options, className = _a.className, text = _a.text, style = _a.style;
          var globe = this.map;
          var template = text || "经度:{longitude}° 纬度:{latitude}°";
          var coordsDom = document.createElement("span");
          var tem = document.createElement("div");
          this._component = tem;
          tem.append(coordsDom);
          tem.classList.add("gis-widget-coordinate");
          className && tem.classList.add(className);
          Object.assign(tem.style, style);
          this._eventHandler = new Cesium__namespace.ScreenSpaceEventHandler(globe.map.canvas);
          this._eventHandler.setInputAction(function (mousement) {
              var position = mousement.endPosition || mousement.position;
              var cartesian3 = pickPositionAndObj(globe.map.scene, position, undefined, PickModelEnum.MULTI).cartesian3;
              var cartographic, cartographicPosition;
              if (cartesian3) {
                  cartographic = globe.map.scene.globe.ellipsoid.cartesianToCartographic(cartesian3);
                  cartographicPosition = {
                      height: cartographic.height,
                      latitude: Cesium__namespace.Math.toDegrees(cartographic.latitude),
                      longitude: Cesium__namespace.Math.toDegrees(cartographic.longitude)
                  };
              }
              if (cartographicPosition) {
                  var longitude = cartographicPosition.longitude, latitude = cartographicPosition.latitude, height = cartographicPosition.height;
                  coordsDom.innerText = template
                      .replace(new RegExp("{longitude}", "g"), longitude.toFixed(4))
                      .replace(new RegExp("{latitude}", "g"), latitude.toFixed(4))
                      .replace(new RegExp("{height}", "g"), height.toFixed(2));
              }
          }, 15 /* MOUSE_MOVE */);
          this.initialized = true;
      };
      /**
       * 添加到地球
       * @ignore
       */
      Coordinate.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          globe.map.cesiumWidget.container.append(this._component);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Coordinate.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.cesiumWidget.container.removeChild(this._component);
          // @ts-ignore
          Object.keys(this._eventHandler._inputEvents).forEach(function (key) {
              _this._eventHandler.removeInputAction(Number(key));
          });
          this._eventHandler.destroy();
          this._eventHandler = void 0;
          this.initialized = false;
          this._component = void 0;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Coordinate.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Coordinate;
  }(Component$1));

  /**
   * 区域面组件
   */
  var Area = /** @class */ (function (_super) {
      __extends$3(Area, _super);
      function Area(options, map) {
          return _super.call(this, __assign$1({ contentStyle: AREA_STYLE.contentStyle, outlineStyle: AREA_STYLE.outlineStyle, contentOutlineStyle: AREA_STYLE.contentOutlineStyle, contentLabelStyle: AREA_STYLE.contentLabelStyle, topOutline: true, bottomOutline: false, contentOutline: true, contentLabel: true, visible: true }, options), map) || this;
      }
      Object.defineProperty(Area.prototype, "visible", {
          /**
           * 组件显隐状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Area.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化
       * @ignore
       */
      Area.prototype.init = function () {
          var _this = this;
          var _a;
          this.initialized = true;
          var _b = this.options, contentStyle = _b.contentStyle, outlineStyle = _b.outlineStyle, contentOutlineStyle = _b.contentOutlineStyle, contentLabelStyle = _b.contentLabelStyle, topOutline = _b.topOutline, bottomOutline = _b.bottomOutline, contentOutline = _b.contentOutline, contentLabel = _b.contentLabel, visible = _b.visible;
          if (!defined$1(this._visible)) {
              this._visible = visible;
          }
          var data = this.options.data;
          if ((data === null || data === void 0 ? void 0 : data.type) !== "FeatureCollection" || ((_a = data.features) === null || _a === void 0 ? void 0 : _a.length) === 0) {
              throw new Error("GeoJSON格式错误或内容为空");
          }
          data = JSON.parse(JSON.stringify(data));
          var contentFeatureList = read$1(data);
          var mergePolygon;
          this._contentVectorLayer = new VectorLayer({
              id: this.id + "-content-vector-layer",
              data: contentFeatureList,
              style: contentStyle,
              visible: this._visible
          });
          this._contentFeatureList = this._contentVectorLayer.features;
          this._outlineVectorLayer = new VectorLayer({
              id: this.id + "-outline-vector-layer",
              style: outlineStyle,
              visible: this._visible
          });
          this._contentOutlineVectorLayer = new VectorLayer({
              id: this.id + "-content-outline-vector-layer",
              style: contentOutlineStyle,
              visible: this._visible
          });
          this._labelContentVectorLayer = new VectorLayer({
              id: this.id + "-label-content-vector-layer",
              style: contentLabelStyle,
              visible: this._visible
          });
          this._contentVectorLayer.on([
              BaseEventType.MOUSE_DOWN,
              BaseEventType.MOUSE_UP,
              BaseEventType.CLICK,
              BaseEventType.RIGHT_CLICK,
              BaseEventType.DOUBLE_CLICK,
              BaseEventType.MOUSE_MOVE
          ], function (e) {
              var coordinate = e.coordinate, pixel = e.pixel, map = e.map;
              var feature;
              if (e.features.length === 1 && _this._contentFeatureList.includes(e.features[0])) {
                  feature = e.features[0];
              }
              else if (e.features[0] instanceof Point$1) {
                  //@ts-ignore
                  feature = e.features[0].contentFeature;
              }
              _this.dispatchEvent({
                  type: e.type,
                  feature: feature,
                  coordinate: coordinate,
                  pixel: pixel,
                  map: map
              });
          });
          this._contentLabelFeatureList = [];
          var topExtrudedHeight = void 0;
          this._contentOutlineFeatureList = contentFeatureList.map(function (feature) {
              var _a;
              var extrudedHeight = ((_a = ((feature.style || feature._layerStyle))) === null || _a === void 0 ? void 0 : _a.reduce(function (previousVal, currentVal) {
                  return previousVal > (currentVal.extrudedHeight || 0) ? previousVal : currentVal.extrudedHeight || 0;
              }, 0)) || 0;
              topExtrudedHeight === void 0 && (topExtrudedHeight = extrudedHeight);
              topExtrudedHeight < extrudedHeight && (topExtrudedHeight = extrudedHeight);
              var temFeature = new Polyline$1({
                  coordinates: polygonToPolyline(feature.geoJson.geometry, extrudedHeight)
                      .coordinates,
                  properties: __assign$1({}, feature.properties)
              });
              contentOutline && _this._contentOutlineVectorLayer.addFeature(temFeature);
              var labelPoint = feature.properties.center
                  ? feature.properties.center
                  : Turf__namespace.centerOfMass(feature.geoJson.geometry, {
                      properties: __assign$1({}, feature.properties)
                  }).geometry.coordinates;
              var labelFeature = new Point$1({
                  coordinates: labelPoint.length > 2 ? labelPoint : [labelPoint[0], labelPoint[1], extrudedHeight],
                  properties: __assign$1({}, feature.properties)
              });
              //@ts-ignore
              labelFeature.contentFeature = feature;
              contentLabel && _this._labelContentVectorLayer.addFeature(labelFeature);
              _this._contentLabelFeatureList.push(labelFeature);
              return temFeature;
          });
          if (bottomOutline) {
              mergePolygon || (mergePolygon = geojsonDissolve(data));
              var outlineBottomGeoJSON = polygonToPolyline(mergePolygon, 0);
              var outlineBottomFeature = new Polyline$1({
                  coordinates: outlineBottomGeoJSON.coordinates
              });
              this._outlineBottomFeature = outlineBottomFeature;
              this._outlineVectorLayer.addFeature(outlineBottomFeature);
          }
          if (topOutline) {
              mergePolygon || (mergePolygon = geojsonDissolve(data));
              var outlineTopGeoJSON = polygonToPolyline(mergePolygon, topExtrudedHeight);
              var outlineTopFeature = new Polyline$1({
                  coordinates: outlineTopGeoJSON.coordinates
              });
              this._outlineTopFeature = outlineTopFeature;
              this._outlineVectorLayer.addFeature(outlineTopFeature);
          }
      };
      /**
       * @ignore
       */
      Area.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this._contentVectorLayer.addTo(globe);
          this._outlineVectorLayer.addTo(globe);
          this._contentOutlineVectorLayer.addTo(globe);
          this._labelContentVectorLayer.addTo(globe);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Area.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._contentVectorLayer.remove();
          this._contentOutlineVectorLayer.remove();
          this._outlineVectorLayer.remove();
          this._labelContentVectorLayer.remove();
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Area.prototype._destroy = function () {
          this.remove();
          this._contentVectorLayer.destroy();
          this._contentOutlineVectorLayer.destroy();
          this._outlineVectorLayer.destroy();
          this._labelContentVectorLayer.destroy();
          this._contentVectorLayer =
              this._contentOutlineVectorLayer =
                  this._outlineVectorLayer =
                      this._labelContentVectorLayer =
                          this._outlineTopFeature =
                              this._outlineBottomFeature =
                                  this._contentFeatureList =
                                      this._contentLabelFeatureList =
                                          this._contentOutlineFeatureList =
                                              void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示行政区划
       */
      Area.prototype.show = function () {
          var _a, _b, _c, _d;
          if (this.visible) {
              return;
          }
          this._visible = true;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.show();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.show();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.show();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.show();
          return this;
      };
      /**
       * 隐藏行政区划
       */
      Area.prototype.hide = function () {
          var _a, _b, _c, _d;
          if (this.visible === false) {
              return;
          }
          this._visible = false;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.hide();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.hide();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.hide();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.hide();
          return this;
      };
      return Area;
  }(Component$1));
  function polygonToPolyline(geojson, height) {
      if (height === void 0) { height = 0; }
      if (geojson.type === GeoJsonType.FEATURE) {
          return feature$3(polygonToPolyline(geojson.geometry, height), __assign$1({}, geojson.properties));
      }
      else if (geojson.type === GeoJsonGeometryType.MULTI_POLYGON) {
          var list_1 = [];
          geojson.coordinates.forEach(function (item) {
              list_1 = list_1.concat(polygonToPolyline(polygon$1(item).geometry, height).coordinates);
          });
          return multiLineString(list_1).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.POLYGON) {
          return multiLineString(geojson.coordinates.map(function (item) {
              return polygonToPolyline(lineString(item).geometry, height).coordinates;
          })).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.LINE_STRING) {
          return lineString(geojson.coordinates.map(function (item) {
              return item.length > 2 ? __spreadArray$1([], __read(item), false) : __spreadArray$1(__spreadArray$1([], __read(item), false), [height], false);
          })).geometry;
      }
  }

  var VideoShed = /** @class */ (function (_super) {
      __extends$3(VideoShed, _super);
      function VideoShed(options, map) {
          return _super.call(this, __assign$1({ castType: CastType.PLANE, videoType: "video/mp4", ground: true }, (options || {})), map) || this;
      }
      Object.defineProperty(VideoShed.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      VideoShed.prototype.init = function () {
          var _a, _b, _c, _d, _e, _f, _g;
          this.initialized = true;
          var type = this.options.castType;
          var position = this.options.position;
          var video = this.options.video;
          var size = this.options.size;
          var videoType = this.options.videoType;
          var ground = this.options.ground;
          var _material;
          if (typeof video === "string") {
              var div = document.createElement("div");
              div.innerHTML =
                  "<video  muted=' autoplay='autoplay' loop='' crossorigin='' controls='' width='200px' height='200px'>" +
                      "<source src='" +
                      video +
                      "' type='" +
                      videoType +
                      "' />" +
                      "</video>";
              _material = div.children[0];
          }
          else {
              _material = video;
          }
          new Cesium__namespace.VideoSynchronizer({
              clock: this.map.map.clock,
              element: _material
          });
          this.map.map.clock.shouldAnimate = true;
          if (type === CastType.CUBE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(position), false)),
                  box: {
                      dimensions: new ((_b = Cesium__namespace.Cartesian3).bind.apply(_b, __spreadArray$1([void 0], __read(size), false)))(),
                      material: _material
                  }
              });
          }
          if (type === CastType.ELLIPSOID) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_c = Cesium__namespace.Cartesian3).fromDegrees.apply(_c, __spreadArray$1([], __read(position), false)),
                  ellipsoid: {
                      radii: new ((_d = Cesium__namespace.Cartesian3).bind.apply(_d, __spreadArray$1([void 0], __read(size), false)))(),
                      material: _material
                  }
              });
          }
          if (type === CastType.ELLIPSE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_e = Cesium__namespace.Cartesian3).fromDegrees.apply(_e, __spreadArray$1([], __read(position), false)),
                  ellipse: {
                      semiMajorAxis: size[0],
                      semiMinorAxis: size[1],
                      material: _material
                  }
              });
          }
          if (type === CastType.CYLINDER) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_f = Cesium__namespace.Cartesian3).fromDegrees.apply(_f, __spreadArray$1([], __read(position), false)),
                  cylinder: {
                      length: size[0],
                      topRadius: size[1],
                      bottomRadius: size[2],
                      material: _material
                  }
              });
          }
          if (type === CastType.PLANE) {
              this._castEntity = new Cesium__namespace.Entity({
                  position: (_g = Cesium__namespace.Cartesian3).fromDegrees.apply(_g, __spreadArray$1([], __read(position), false)),
                  plane: {
                      plane: new Cesium__namespace.Plane(ground ? Cesium__namespace.Cartesian3.UNIT_Z : Cesium__namespace.Cartesian3.UNIT_Y, 0.0),
                      dimensions: new Cesium__namespace.Cartesian2(size[1], size[2]),
                      material: _material
                  }
              });
          }
      };
      VideoShed.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.map.entities.add(this._castEntity);
          this.map.map.zoomTo(this._castEntity);
      };
      VideoShed.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
          }
          this.map.map.entities.remove(this._castEntity);
          this.map = undefined;
          this._castEntity = undefined;
          this.initialized = false;
      };
      VideoShed.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return VideoShed;
  }(Component$1));

  var RegisterCoordinateSystem = /** @class */ (function () {
      function RegisterCoordinateSystem(glMap) {
          this.dimensions = ["lng", "lat"];
          this.radians = Cesium__namespace.Math.toRadians(80);
          this._GLMap = glMap;
          this._mapOffset = [0, 0];
          this.dimensions = ["lng", "lat"];
          //this._api = api;
      }
      RegisterCoordinateSystem.prototype.setMapOffset = function (mapOffset) {
          this._mapOffset = mapOffset;
      };
      RegisterCoordinateSystem.prototype.getMap = function () {
          return this._GLMap;
      };
      RegisterCoordinateSystem.prototype.fixLat = function (lat) {
          return lat >= 90 ? 89.99999999999999 : lat <= -90 ? -89.99999999999999 : lat;
      };
      RegisterCoordinateSystem.prototype.dataToPoint = function (coords) {
          var lonlat = [99999, 99999];
          coords[1] = this.fixLat(coords[1]);
          var position = Cesium__namespace.Cartesian3.fromDegrees(coords[0], coords[1]);
          if (!position)
              return lonlat;
          var coordinates = this._GLMap.cartesianToCanvasCoordinates(position);
          if (!coordinates)
              return lonlat;
          if (this._GLMap.mode === 3 /* SCENE3D */) {
              if (Cesium__namespace.Cartesian3.angleBetween(this._GLMap.camera.position, position) > this.radians)
                  return [NaN, NaN];
          }
          return [coordinates.x - this._mapOffset[0], coordinates.y - this._mapOffset[1]];
      };
      RegisterCoordinateSystem.prototype.pointToData = function (pixel) {
          this._mapOffset; 
          var // @ts-ignore
          coords = this._bmap.project([pixel[0] + pixel[0], pixel[1] + pixel[1]]);
          return [coords.lng, coords.lat];
      };
      RegisterCoordinateSystem.prototype.getViewRect = function () {
          // @ts-ignore
          var api = this._api;
          return new echarts__namespace.graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
      };
      RegisterCoordinateSystem.prototype.getRoamTransform = function () {
          return echarts__namespace.matrix.create();
      };
      RegisterCoordinateSystem.prototype.create = function (echartModel, api) {
          // @ts-ignore
          this._api = api;
          var glMap = this._GLMap;
          var registerCoordinateSystem;
          echartModel.eachComponent("GLMap", function (seriesModel) {
              var painter = api.getZr().painter;
              if (painter) {
                  //let glMap = (api.getViewportRoot(), echarts.glMap);
                  // @ts-ignore
                  // @ts-ignore
                  registerCoordinateSystem = new RegisterCoordinateSystem(glMap, api);
                  registerCoordinateSystem.setMapOffset(seriesModel.__mapOffset || [0, 0]);
                  seriesModel.coordinateSystem = registerCoordinateSystem;
              }
          });
          echartModel.eachSeries(function (series) {
              "GLMap" === series.get("coordinateSystem") && (series.coordinateSystem = registerCoordinateSystem);
          });
      };
      return RegisterCoordinateSystem;
  }());

  var convertTypes = ["pie", "line", "bar"];
  /**
   * Echarts组件
   */
  var Echarts = /** @class */ (function (_super) {
      __extends$3(Echarts, _super);
      function Echarts(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Echarts.prototype, "echarts", {
          /**
           * `echarts.init`初始化结果对象
           */
          get: function () {
              return this._echarts;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Echarts.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Echarts.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var viewer = this.map.map;
          var scene = viewer.scene;
          var container = document.createElement("div");
          container.style.position = "absolute";
          container.style.top = "0px";
          container.style.left = "0px";
          container.style.right = "0px";
          container.style.bottom = "0px";
          container.style.width = scene.canvas.width + "px";
          container.style.height = scene.canvas.height + "px";
          container.style.pointerEvents = "none";
          //@ts-ignore
          viewer._element.appendChild(container);
          this._echartsContainer = container;
          // @ts-ignore
          // echarts.glMap = scene;
          this._registerCoordinateSystem = new RegisterCoordinateSystem(this.map.map.scene);
          this._register();
          this._echarts = echarts__namespace.init(container);
          this._echarts.setOption(this._convertData(this.options), false);
          this.map.on([BaseEventType.CENTER_CHANGED, BaseEventType.ZOOM_CHANGED], function () {
              if (_this._chartRender) {
                  _this.echarts.resize();
                  _this._echarts.setOption(_this._convertData(_this.options), false);
              }
          });
      };
      /**
       * @ignore
       */
      Echarts.prototype._register = function () {
          if (this._isRegistered)
              return;
          var scene = this.map.map.scene;
          // @ts-ignore
          echarts__namespace.registerCoordinateSystem("GLMap", this._registerCoordinateSystem);
          echarts__namespace.registerAction({
              type: "GLMapRoam",
              event: "GLMapRoam",
              update: "updateLayout"
          }, function (e, t) { });
          echarts__namespace.extendComponentModel({
              type: "GLMap",
              // @ts-ignore
              getBMap: function () {
                  return this.__GLMap;
              },
              defaultOption: {
                  roam: !1
              }
          });
          echarts__namespace.extendComponentView({
              type: "GLMap",
              init: function (echartModel, api) {
                  //@ts-ignore
                  (this.api = api), scene.postRender.addEventListener(this.moveHandler, this);
              },
              moveHandler: function (e, t) {
                  this.api.dispatchAction({
                      type: "GLMapRoam"
                  });
              },
              render: function (e, t, i) { },
              dispose: function () {
                  // @ts-ignore
                  scene.postRender.removeEventListener(this.moveHandler, this);
              }
          });
          this._isRegistered = true;
      };
      /**
       * @ignore
       */
      Echarts.prototype._convertData = function (options) {
          var series = options.series;
          if (series && series.length > 0) {
              if (series && typeof series === "object") {
                  if (convertTypes) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (convertTypes.indexOf(series[i].type) > -1) {
                              if (series[i] && series[i].hasOwnProperty("coordinates")) {
                                  this._chartRender = true;
                                  // @ts-ignore
                                  series[i] = CHARTS_TRANSFORMER[series[i].type].call(this, options, series[i]);
                              }
                          }
                      }
                  }
              }
          }
          return options;
      };
      /**
       * @ignore
       */
      Echarts.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
      };
      /**
       * @ignore
       */
      Echarts.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.initialized = false;
          this._echartsContainer &&
              //@ts-ignore
              (this.map.map._element.removeChild(this._echartsContainer), (this._echartsContainer = void 0));
          this._echarts && (this._echarts.dispose(), (this._echarts = void 0));
          this._isRegistered = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Echarts.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置图表`option`
       *
       * 参考内容:[https://echarts.apache.org/zh/api.html#echartsInstance.setOption](https://echarts.apache.org/zh/api.html#echartsInstance.setOption)
       */
      Echarts.prototype.setOption = function (option) {
          this._options = __assign$1(__assign$1({}, option), { id: this.options.id, initOptions: this.options.initOptions });
          this._chartRender = false;
          this.echarts.setOption(this._convertData(this.options), false);
          return this;
      };
      return Echarts;
  }(Component$1));
  function barCoordinateTransform(options, series) {
      var _this = this;
      if (isObject$a(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coordinatePixel = _this._registerCoordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coordinatePixel[0] - parseFloat(gri.width) / 2;
              gri.top = coordinatePixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  }
  function lineCoordinateTransform(options, series) {
      var _this = this;
      if (isObject$a(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coordinatePixel = _this._registerCoordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coordinatePixel[0] - parseFloat(gri.width) / 2;
              gri.top = coordinatePixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  }
  function pieCoordinateTransform(options, series) {
      series.center = this._registerCoordinateSystem.dataToPoint(series.coordinates);
      return series;
  }
  var CHARTS_TRANSFORMER = {
      pie: pieCoordinateTransform,
      bar: barCoordinateTransform,
      line: lineCoordinateTransform
  };

  /**
   * 遮罩组件
   *
   * [cesium]
   */
  var Mask = /** @class */ (function (_super) {
      __extends$3(Mask, _super);
      function Mask(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, globe: false }, options)) || this;
          _this._visible = _this.options.visible;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Mask.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Mask.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          this._entities = [];
          var styleItem = this.options.style && cesiumStyleItemListInit(this.options.style)[0];
          var material_ = new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.GREEN.withAlpha(0.3));
          var material1_ = new Cesium__namespace.ColorMaterialProperty(Cesium__namespace.Color.GREEN.withAlpha(0.3));
          if (defined$1(styleItem)) {
              material_ =
                  styleItem.type === StyleItemType.COLOR
                      ? styleItemFillColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem);
              material1_ =
                  styleItem.type === StyleItemType.COLOR
                      ? styleItemBorderColorToColorMaterialProperty(styleItem)
                      : styleItem.type === StyleItemType.IMAGE
                          ? styleItemToImageMaterialProperty(styleItem)
                          : styleItem.type === StyleItemType.LINEAR_GRADIENT
                              ? styleItemToLinearGradientMaterialProperty(styleItem)
                              : styleItemToLinearFlowMaterialProperty(styleItem);
          }
          var data;
          if (this.options.data.geometry.type === GeoJsonGeometryType.POLYGON) {
              data = [this.options.data.geometry.coordinates];
          }
          if (this.options.data.geometry.type === GeoJsonGeometryType.MULTI_POLYGON) {
              data = this.options.data.geometry.coordinates;
          }
          var cartesians = data.map(function (_data) {
              return _data.map(function (_coords) {
                  return _coords.map(function (_coord) {
                      var _a;
                      return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(_coord), false));
                  });
              });
          });
          var globe = this.options.globe;
          if (globe) {
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy([
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: -3.915323898915733,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: -3.915323898915733,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: -0.5580000157243585,
                              z: 5500477.1339386385
                          }
                      ].map(function (coord) {
                          return Cesium__namespace.Cartesian3.fromArray([coord.x, coord.y, coord.z]);
                      })), 
                      // 填充的颜色，withAlpha透明度
                      material: material_ }, styleItem)
              }));
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy([
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: 3.915323898915733,
                              z: -5500477.1339386385
                          },
                          {
                              x: -3197104.5869239476,
                              y: 3.915323898915733,
                              z: 5500477.1339386385
                          },
                          {
                              x: 3197104.586923899,
                              y: 0.5580000157243585,
                              z: 5500477.1339386385
                          }
                      ].map(function (coord) {
                          return Cesium__namespace.Cartesian3.fromArray([coord.x, coord.y, coord.z]);
                      }), cartesians.map(function (_cartesians) {
                          return new Cesium__namespace.PolygonHierarchy(_cartesians[0]);
                      })), material: material_ }, styleItem)
              }));
          }
          else {
              // const coordinates = [
              //   [120.58593749999999, 27.254629577800063],
              //   [121.28906250000001, 28.188243641850313],
              //   [121.9482421875, 29.075375179558346],
              //   [122.08007812499999, 29.954934549656144],
              //   [121.5087890625, 30.221101852485987],
              //   [120.76171875, 30.41078179084589],
              //   [121.28906250000001, 30.90222470517144],
              //   [120.58593749999999, 30.86451022625836],
              //   [119.794921875, 31.090574094954192],
              //   [119.53125, 30.751277776257812],
              //   [118.828125, 29.878755346037977],
              //   [118.2568359375, 29.267232865200878],
              //   [118.43261718749999, 28.22697003891834],
              //   [118.91601562499999, 27.605670826465445],
              //   [119.794921875, 27.488781168937997],
              //   [120.58593749999999, 27.254629577800063]
              // ];
              var coordinates = Turf__namespace.bboxPolygon(this.options.extent || [73.66, 3.86, 135.05, 53.55]).geometry.coordinates.flat();
              this._entities.push(new Cesium__namespace.Entity({
                  polygon: __assign$1({ hierarchy: new Cesium__namespace.PolygonHierarchy(coordinates.map(function (coord) {
                          var _a;
                          return (_a = Cesium__namespace.Cartesian3).fromDegrees.apply(_a, __spreadArray$1([], __read(coord), false));
                      }), cartesians
                          .map(function (_cartesians) {
                          return _cartesians.map(function (_cartesian) {
                              return new Cesium__namespace.PolygonHierarchy(_cartesian);
                          });
                      })
                          .flat()), material: material_ }, styleItem)
              }));
          }
          cartesians.forEach(function (elem) {
              elem.forEach(function (coords) {
                  _this._entities.push(new Cesium__namespace.Entity({
                      polyline: __assign$1({ positions: coords, width: 10, material: material1_ }, styleItem)
                  }));
              });
          });
      };
      /**
       * @ignore
       * @param map
       */
      Mask.prototype.addTo = function (map) {
          var e_1, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = this._visible;
                  this.map.map.entities.add(entity);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Mask.prototype.remove = function (destroy) {
          var e_2, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  this.map.map.entities.remove(entity);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this._entities = [];
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Mask.prototype._destroy = function () {
          var e_3, _a;
          this.remove();
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  Cesium__namespace.destroyObject(entity);
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_3) throw e_3.error; }
          }
          this._entities = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 显示墙组件
       */
      Mask.prototype.show = function () {
          var e_4, _a;
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = true;
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_4) throw e_4.error; }
          }
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Mask.prototype.hide = function () {
          var e_5, _a;
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          try {
              for (var _b = __values(this._entities), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var entity = _c.value;
                  entity.show = false;
              }
          }
          catch (e_5_1) { e_5 = { error: e_5_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_5) throw e_5.error; }
          }
          return this;
      };
      return Mask;
  }(Component$1));

  /**
   * Code
   */

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Component: Component$1,
    CircleSearch: CircleSearch,
    HistoryTrack: HistoryTrack,
    Draw: Draw$1,
    get DrawType () { return DrawType; },
    Edit: Edit,
    Measure: Measure,
    get MeasureType () { return MeasureType; },
    Wall: Wall,
    Triangulation: Triangulation,
    Snap: Snap,
    RippleCircle: RippleCircle,
    RotateCircle: RotateCircle,
    ContextMenu: ContextMenu,
    Atmosphere: Atmosphere,
    Fire: Fire,
    Fountain: Fountain,
    Light: Light,
    Rain: Rain,
    Snow: Snow,
    TranslationQueue: TranslationQueue,
    Compass: Compass,
    Coordinate: Coordinate,
    Area: Area,
    VideoShed: VideoShed,
    get CastType () { return CastType; },
    Echarts: Echarts,
    Mask: Mask
  });

  /**
   * Code
   */

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Model: Model,
    get ModelType () { return ModelType; },
    get DirectionType () { return DirectionType; },
    GLTF: GLTF,
    Cesium3DTile: Cesium3DTile
  });

  /**
   * 将WKT字符串数组转为Feature对象数组
   *
   * **WKT格式**
   *
   * - 点
   * ```
   * 'POINT(35.12 19.12)'
   * ```
   * - 线
   * ```
   * 'LINESTRING (30 10, 10 30, 40 40)'
   * ```
   * - 面 (首尾坐标必须相同)
   * ```
   * // 简单面
   * 'POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))'
   * // 中心有孔的面
   * `POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))`
   * ```
   *
   * - 多点
   * ```
   * 'MULTIPOINT (10 40, 40 30, 20 20, 30 10)'
   * ```
   * - 多线
   * ```
   * 'MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))'
   * ```
   * - 多面 (首尾坐标必须相同)
   * ```
   * // 简单面
   * 'MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))'
   * // 中心有孔的面
   * `MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)),((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))`
   * ```
   *
   * @param wkts WKT字符串数组
   * @returns
   *
   */
  function read(wkts, options) {
      return wktsToFeatures(wkts, { Point: Point$1, Polyline: Polyline$1, Polygon: Polygon$1 }, options);
  }
  /**
   * 将Feature对象数组转为wkt字符串数组
   *
   * @param features 要素数组
   * @returns
   */
  function write(features, options) {
      return featuresToWkts(features, options);
  }

  var WKT = /*#__PURE__*/Object.freeze({
    __proto__: null,
    read: read,
    write: write
  });

  /**
   * core
   */
  var version$1 = "".concat(gitVersion, "(").concat(gitDate, ")");
  /**
   * @ignore
   */
  var name = "mti-gis-cesium";

  /*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || from);
  }

  var Bounds = /** @class */ (function () {
      function Bounds(left, top, width, height) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
      }
      Bounds.prototype.add = function (x, y, w, h) {
          return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
      };
      Bounds.fromClientRect = function (context, clientRect) {
          return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
      };
      Bounds.fromDOMRectList = function (context, domRectList) {
          var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
          return domRect
              ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
              : Bounds.EMPTY;
      };
      Bounds.EMPTY = new Bounds(0, 0, 0, 0);
      return Bounds;
  }());
  var parseBounds = function (context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
  };
  var parseDocumentSize = function (document) {
      var body = document.body;
      var documentElement = document.documentElement;
      if (!body || !documentElement) {
          throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
  };

  /*
   * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var toCodePoints$1 = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint$1 = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
  }

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
  }
  var decode$1 = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1$1[base64.charCodeAt(i)];
          encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2$1 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1$1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT$1 = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
  var slice16$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64$1 = function (base64, _byteLength) {
      var buffer = decode$1(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16$1(view16, (headerLength + view32[4]) / 2)
          : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie$1 = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
  }

  var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

  var LETTER_NUMBER_MODIFIER = 50;
  // Non-tailorable Line Breaking Classes
  var BK = 1; //  Cause a line break (after)
  var CR$1 = 2; //  Cause a line break (after), except between CR and LF
  var LF$1 = 3; //  Cause a line break (after)
  var CM = 4; //  Prohibit a line break between the character and the preceding character
  var NL = 5; //  Cause a line break (after)
  var WJ = 7; //  Prohibit line breaks before and after
  var ZW = 8; //  Provide a break opportunity
  var GL = 9; //  Prohibit line breaks before and after
  var SP = 10; // Enable indirect line breaks
  var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
  // Break Opportunities
  var B2 = 12; //  Provide a line break opportunity before and after the character
  var BA = 13; //  Generally provide a line break opportunity after the character
  var BB = 14; //  Generally provide a line break opportunity before the character
  var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
  var CB = 16; //   Provide a line break opportunity contingent on additional information
  // Characters Prohibiting Certain Breaks
  var CL = 17; //  Prohibit line breaks before
  var CP = 18; //  Prohibit line breaks before
  var EX = 19; //  Prohibit line breaks before
  var IN = 20; //  Allow only indirect line breaks between pairs
  var NS = 21; //  Allow only indirect line breaks before
  var OP = 22; //  Prohibit line breaks after
  var QU = 23; //  Act like they are both opening and closing
  // Numeric Context
  var IS = 24; //  Prevent breaks after any and before numeric
  var NU = 25; //  Form numeric expressions for line breaking purposes
  var PO = 26; //  Do not break following a numeric expression
  var PR = 27; //  Do not break in front of a numeric expression
  var SY = 28; //  Prevent a break before; and allow a break after
  // Other Characters
  var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
  var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
  var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
  var EB = 32; //  Do not break from following Emoji Modifier
  var EM = 33; //  Do not break from preceding Emoji Base
  var H2 = 34; //  Form Korean syllable blocks
  var H3 = 35; //  Form Korean syllable blocks
  var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
  var ID = 37; //  Break before or after; except in some numeric context
  var JL = 38; //  Form Korean syllable blocks
  var JV = 39; //  Form Korean syllable blocks
  var JT = 40; //  Form Korean syllable blocks
  var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
  var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
  var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
  var ea_OP = [0x2329, 0xff08];
  var BREAK_MANDATORY = '!';
  var BREAK_NOT_ALLOWED$1 = '×';
  var BREAK_ALLOWED$1 = '÷';
  var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
  var ALPHABETICS = [AL, HL];
  var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
  var SPACE$1 = [SP, ZW];
  var PREFIX_POSTFIX = [PR, PO];
  var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  var HYPHEN = [HY, BA];
  var codePointsToCharacterClasses = function (codePoints, lineBreak) {
      if (lineBreak === void 0) { lineBreak = 'strict'; }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function (codePoint, index) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
          }
          else {
              categories.push(false);
          }
          if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
              // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
              if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                  indices.push(index);
                  return types.push(CB);
              }
          }
          if (classType === CM || classType === ZWJ$1) {
              // LB10 Treat any remaining combining mark or ZWJ as AL.
              if (index === 0) {
                  indices.push(index);
                  return types.push(AL);
              }
              // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
              // the base character in all of the following rules. Treat ZWJ as if it were CM.
              var prev = types[index - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                  indices.push(indices[index - 1]);
                  return types.push(prev);
              }
              indices.push(index);
              return types.push(AL);
          }
          indices.push(index);
          if (classType === CJ) {
              return types.push(lineBreak === 'strict' ? NS : ID);
          }
          if (classType === SA) {
              return types.push(AL);
          }
          if (classType === AI) {
              return types.push(AL);
          }
          // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
          // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
          // to take into account the actual line breaking properties for these characters.
          if (classType === XX) {
              if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
                  return types.push(ID);
              }
              else {
                  return types.push(AL);
              }
          }
          types.push(classType);
      });
      return [indices, types, categories];
  };
  var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
          var i = currentIndex;
          while (i <= classTypes.length) {
              i++;
              var next = classTypes[i];
              if (next === b) {
                  return true;
              }
              if (next !== SP) {
                  break;
              }
          }
      }
      if (current === SP) {
          var i = currentIndex;
          while (i > 0) {
              i--;
              var prev = classTypes[i];
              if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                  var n = currentIndex;
                  while (n <= classTypes.length) {
                      n++;
                      var next = classTypes[n];
                      if (next === b) {
                          return true;
                      }
                      if (next !== SP) {
                          break;
                      }
                  }
              }
              if (prev !== SP) {
                  break;
              }
          }
      }
      return false;
  };
  var previousNonSpaceClassType = function (currentIndex, classTypes) {
      var i = currentIndex;
      while (i >= 0) {
          var type = classTypes[i];
          if (type === SP) {
              i--;
          }
          else {
              return type;
          }
      }
      return 0;
  };
  var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
      if (indicies[index] === 0) {
          return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      // LB4 Always break after hard line breaks.
      // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
      }
      // LB6 Do not break before hard line breaks.
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB7 Do not break before spaces or zero width space.
      if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
      }
      // LB8a Do not break after a zero width joiner.
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // zwj emojis
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB11 Do not break before or after Word joiner and related characters.
      if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12 Do not break after NBSP and related characters.
      if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB14 Do not break after ‘[’, even after spaces.
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB15 Do not break within ‘”[’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB17 Do not break within ‘——’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB18 Break after spaces.
      if (current === SP) {
          return BREAK_ALLOWED$1;
      }
      // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
      if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB20 Break before and after unresolved CB.
      if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
      }
      // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21a Don't break after Hebrew + Hyphen.
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21b Don’t break between Solidus and Hebrew letters.
      if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB22 Do not break before ellipsis.
      if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23 Do not break between digits and letters.
      if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
      if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
          ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
      if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
          (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB25 Do not break between the following pairs of classes relevant to numbers:
      if (
      // (PR | PO) × ( OP | HY )? NU
      ([PR, PO].indexOf(current) !== -1 &&
          (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
          // ( OP | HY ) × NU
          ([OP, HY].indexOf(current) !== -1 && next === NU) ||
          // NU ×	(NU | SY | IS)
          (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
      if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // LB26 Do not break a Korean syllable.
      if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
          ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
          ([JT, H3].indexOf(current) !== -1 && next === JT)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB27 Treat a Korean Syllable Block the same as ID.
      if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
          (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB28 Do not break between alphabetics (“at”).
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
      if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
          next === OP &&
          ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
          (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
      // indicators preceding the position of the break.
      if (current === RI$1 && next === RI$1) {
          var i = indicies[currentIndex];
          var count = 1;
          while (i > 0) {
              i--;
              if (classTypes[i] === RI$1) {
                  count++;
              }
              else {
                  break;
              }
          }
          if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
          }
      }
      // LB30b Do not break between an emoji base and an emoji modifier.
      if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
  };
  var cssFormattedClasses = function (codePoints, options) {
      if (!options) {
          options = { lineBreak: 'normal', wordBreak: 'normal' };
      }
      var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
      if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
          classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
      }
      var forbiddenBreakpoints = options.wordBreak === 'keep-all'
          ? isLetterNumber.map(function (letterNumber, i) {
              return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
          })
          : undefined;
      return [indicies, classTypes, forbiddenBreakpoints];
  };
  var Break = /** @class */ (function () {
      function Break(codePoints, lineBreak, start, end) {
          this.codePoints = codePoints;
          this.required = lineBreak === BREAK_MANDATORY;
          this.start = start;
          this.end = end;
      }
      Break.prototype.slice = function () {
          return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
      };
      return Break;
  }());
  var LineBreaker = function (str, options) {
      var codePoints = toCodePoints$1(str);
      var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
          next: function () {
              if (nextIndex >= length) {
                  return { done: true, value: null };
              }
              var lineBreak = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length &&
                  (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
                      BREAK_NOT_ALLOWED$1) { }
              if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                  var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                  lastEnd = nextIndex;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };

  // https://www.w3.org/TR/css-syntax-3
  var FLAG_UNRESTRICTED = 1 << 0;
  var FLAG_ID = 1 << 1;
  var FLAG_INTEGER = 1 << 2;
  var FLAG_NUMBER = 1 << 3;
  var LINE_FEED = 0x000a;
  var SOLIDUS = 0x002f;
  var REVERSE_SOLIDUS = 0x005c;
  var CHARACTER_TABULATION = 0x0009;
  var SPACE = 0x0020;
  var QUOTATION_MARK = 0x0022;
  var EQUALS_SIGN = 0x003d;
  var NUMBER_SIGN = 0x0023;
  var DOLLAR_SIGN = 0x0024;
  var PERCENTAGE_SIGN = 0x0025;
  var APOSTROPHE = 0x0027;
  var LEFT_PARENTHESIS = 0x0028;
  var RIGHT_PARENTHESIS = 0x0029;
  var LOW_LINE = 0x005f;
  var HYPHEN_MINUS = 0x002d;
  var EXCLAMATION_MARK = 0x0021;
  var LESS_THAN_SIGN = 0x003c;
  var GREATER_THAN_SIGN = 0x003e;
  var COMMERCIAL_AT = 0x0040;
  var LEFT_SQUARE_BRACKET = 0x005b;
  var RIGHT_SQUARE_BRACKET = 0x005d;
  var CIRCUMFLEX_ACCENT = 0x003d;
  var LEFT_CURLY_BRACKET = 0x007b;
  var QUESTION_MARK = 0x003f;
  var RIGHT_CURLY_BRACKET = 0x007d;
  var VERTICAL_LINE = 0x007c;
  var TILDE = 0x007e;
  var CONTROL = 0x0080;
  var REPLACEMENT_CHARACTER = 0xfffd;
  var ASTERISK = 0x002a;
  var PLUS_SIGN = 0x002b;
  var COMMA = 0x002c;
  var COLON = 0x003a;
  var SEMICOLON = 0x003b;
  var FULL_STOP = 0x002e;
  var NULL = 0x0000;
  var BACKSPACE = 0x0008;
  var LINE_TABULATION = 0x000b;
  var SHIFT_OUT = 0x000e;
  var INFORMATION_SEPARATOR_ONE = 0x001f;
  var DELETE = 0x007f;
  var EOF = -1;
  var ZERO = 0x0030;
  var a$1 = 0x0061;
  var e$1 = 0x0065;
  var f$1 = 0x0066;
  var u$1 = 0x0075;
  var z = 0x007a;
  var A = 0x0041;
  var E = 0x0045;
  var F = 0x0046;
  var U = 0x0055;
  var Z = 0x005a;
  var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
  var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
  var isHex = function (codePoint) {
      return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a$1 && codePoint <= f$1);
  };
  var isLowerCaseLetter = function (codePoint) { return codePoint >= a$1 && codePoint <= z; };
  var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
  var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
  var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
  var isWhiteSpace = function (codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  };
  var isNameStartCodePoint = function (codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  };
  var isNameCodePoint = function (codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  };
  var isNonPrintableCodePoint = function (codePoint) {
      return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
          codePoint === LINE_TABULATION ||
          (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
          codePoint === DELETE);
  };
  var isValidEscape = function (c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
          return false;
      }
      return c2 !== LINE_FEED;
  };
  var isIdentifierStart = function (c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      }
      else if (isNameStartCodePoint(c1)) {
          return true;
      }
      else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
          return true;
      }
      return false;
  };
  var isNumberStart = function (c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c2)) {
              return true;
          }
          return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
          return isDigit(c2);
      }
      return isDigit(c1);
  };
  var stringToNumber = function (codePoints) {
      var c = 0;
      var sign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              sign = -1;
          }
          c++;
      }
      var integers = [];
      while (isDigit(codePoints[c])) {
          integers.push(codePoints[c++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
      if (codePoints[c] === FULL_STOP) {
          c++;
      }
      var fraction = [];
      while (isDigit(codePoints[c])) {
          fraction.push(codePoints[c++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
      if (codePoints[c] === E || codePoints[c] === e$1) {
          c++;
      }
      var expsign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              expsign = -1;
          }
          c++;
      }
      var exponent = [];
      while (isDigit(codePoints[c])) {
          exponent.push(codePoints[c++]);
      }
      var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  };
  var LEFT_PARENTHESIS_TOKEN = {
      type: 2 /* LEFT_PARENTHESIS_TOKEN */
  };
  var RIGHT_PARENTHESIS_TOKEN = {
      type: 3 /* RIGHT_PARENTHESIS_TOKEN */
  };
  var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
  var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
  var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
  var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
  var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
  var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
  var LEFT_CURLY_BRACKET_TOKEN = {
      type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
  };
  var RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
  };
  var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
  var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
  var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
  var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
  var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
  var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
  var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
  var LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
  };
  var RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
  };
  var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
  var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
  var Tokenizer = /** @class */ (function () {
      function Tokenizer() {
          this._value = [];
      }
      Tokenizer.prototype.write = function (chunk) {
          this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer.prototype.read = function () {
          var tokens = [];
          var token = this.consumeToken();
          while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
          }
          return tokens;
      };
      Tokenizer.prototype.consumeToken = function () {
          var codePoint = this.consumeCodePoint();
          switch (codePoint) {
              case QUOTATION_MARK:
                  return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                  var c1 = this.peekCodePoint(0);
                  var c2 = this.peekCodePoint(1);
                  var c3 = this.peekCodePoint(2);
                  if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                      var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                      var value = this.consumeName();
                      return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
                  }
                  break;
              case DOLLAR_SIGN:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUFFIX_MATCH_TOKEN;
                  }
                  break;
              case APOSTROPHE:
                  return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                  return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                  return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUBSTRING_MATCH_TOKEN;
                  }
                  break;
              case PLUS_SIGN:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case COMMA:
                  return COMMA_TOKEN;
              case HYPHEN_MINUS:
                  var e1 = codePoint;
                  var e2 = this.peekCodePoint(0);
                  var e3 = this.peekCodePoint(1);
                  if (isNumberStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  if (isIdentifierStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDC_TOKEN;
                  }
                  break;
              case FULL_STOP:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case SOLIDUS:
                  if (this.peekCodePoint(0) === ASTERISK) {
                      this.consumeCodePoint();
                      while (true) {
                          var c = this.consumeCodePoint();
                          if (c === ASTERISK) {
                              c = this.consumeCodePoint();
                              if (c === SOLIDUS) {
                                  return this.consumeToken();
                              }
                          }
                          if (c === EOF) {
                              return this.consumeToken();
                          }
                      }
                  }
                  break;
              case COLON:
                  return COLON_TOKEN;
              case SEMICOLON:
                  return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                  if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
                      this.peekCodePoint(1) === HYPHEN_MINUS &&
                      this.peekCodePoint(2) === HYPHEN_MINUS) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDO_TOKEN;
                  }
                  break;
              case COMMERCIAL_AT:
                  var a1 = this.peekCodePoint(0);
                  var a2 = this.peekCodePoint(1);
                  var a3 = this.peekCodePoint(2);
                  if (isIdentifierStart(a1, a2, a3)) {
                      var value = this.consumeName();
                      return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
                  }
                  break;
              case LEFT_SQUARE_BRACKET:
                  return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  break;
              case RIGHT_SQUARE_BRACKET:
                  return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return PREFIX_MATCH_TOKEN;
                  }
                  break;
              case LEFT_CURLY_BRACKET:
                  return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                  return RIGHT_CURLY_BRACKET_TOKEN;
              case u$1:
              case U:
                  var u1 = this.peekCodePoint(0);
                  var u2 = this.peekCodePoint(1);
                  if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                      this.consumeCodePoint();
                      this.consumeUnicodeRangeToken();
                  }
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return DASH_MATCH_TOKEN;
                  }
                  if (this.peekCodePoint(0) === VERTICAL_LINE) {
                      this.consumeCodePoint();
                      return COLUMN_TOKEN;
                  }
                  break;
              case TILDE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return INCLUDE_MATCH_TOKEN;
                  }
                  break;
              case EOF:
                  return EOF_TOKEN;
          }
          if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
          }
          if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
          }
          if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
          }
          return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer.prototype.consumeCodePoint = function () {
          var value = this._value.shift();
          return typeof value === 'undefined' ? -1 : value;
      };
      Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
          this._value.unshift(codePoint);
      };
      Tokenizer.prototype.peekCodePoint = function (delta) {
          if (delta >= this._value.length) {
              return -1;
          }
          return this._value[delta];
      };
      Tokenizer.prototype.consumeUnicodeRangeToken = function () {
          var digits = [];
          var codePoint = this.consumeCodePoint();
          while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
          }
          var questionMarks = false;
          while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
          }
          if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
          }
          var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
          if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                  endDigits.push(codePoint);
                  codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
          }
          else {
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
          }
      };
      Tokenizer.prototype.consumeIdentLikeToken = function () {
          var value = this.consumeName();
          if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
          }
          else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19 /* FUNCTION_TOKEN */, value: value };
          }
          return { type: 20 /* IDENT_TOKEN */, value: value };
      };
      Tokenizer.prototype.consumeUrlToken = function () {
          var value = [];
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF) {
              return { type: 22 /* URL_TOKEN */, value: '' };
          }
          var next = this.peekCodePoint(0);
          if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0 /* STRING_TOKEN */) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: stringToken.value };
                  }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
          }
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                  return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
              }
              else if (isWhiteSpace(codePoint)) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
                  }
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === QUOTATION_MARK ||
                  codePoint === APOSTROPHE ||
                  codePoint === LEFT_PARENTHESIS ||
                  isNonPrintableCodePoint(codePoint)) {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === REVERSE_SOLIDUS) {
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      value.push(this.consumeEscapedCodePoint());
                  }
                  else {
                      this.consumeBadUrlRemnants();
                      return BAD_URL_TOKEN;
                  }
              }
              else {
                  value.push(codePoint);
              }
          }
      };
      Tokenizer.prototype.consumeWhiteSpace = function () {
          while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
          }
      };
      Tokenizer.prototype.consumeBadUrlRemnants = function () {
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                  return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.consumeEscapedCodePoint();
              }
          }
      };
      Tokenizer.prototype.consumeStringSlice = function (count) {
          var SLICE_STACK_SIZE = 50000;
          var value = '';
          while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
          }
          this._value.shift();
          return value;
      };
      Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
          var value = '';
          var i = 0;
          do {
              var codePoint = this._value[i];
              if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
                  value += this.consumeStringSlice(i);
                  return { type: 0 /* STRING_TOKEN */, value: value };
              }
              if (codePoint === LINE_FEED) {
                  this._value.splice(0, i);
                  return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                  var next = this._value[i + 1];
                  if (next !== EOF && next !== undefined) {
                      if (next === LINE_FEED) {
                          value += this.consumeStringSlice(i);
                          i = -1;
                          this._value.shift();
                      }
                      else if (isValidEscape(codePoint, next)) {
                          value += this.consumeStringSlice(i);
                          value += fromCodePoint$1(this.consumeEscapedCodePoint());
                          i = -1;
                      }
                  }
              }
              i++;
          } while (true);
      };
      Tokenizer.prototype.consumeNumber = function () {
          var repr = [];
          var type = FLAG_INTEGER;
          var c1 = this.peekCodePoint(0);
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
          }
          while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
          }
          c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          c1 = this.peekCodePoint(0);
          c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if ((c1 === E || c1 === e$1) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          return [stringToNumber(repr), type];
      };
      Tokenizer.prototype.consumeNumericToken = function () {
          var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
          }
          if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
          }
          return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
      };
      Tokenizer.prototype.consumeEscapedCodePoint = function () {
          var codePoint = this.consumeCodePoint();
          if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                  hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                  this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
                  return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
          }
          if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
          }
          return codePoint;
      };
      Tokenizer.prototype.consumeName = function () {
          var result = '';
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                  result += fromCodePoint$1(codePoint);
              }
              else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  result += fromCodePoint$1(this.consumeEscapedCodePoint());
              }
              else {
                  this.reconsumeCodePoint(codePoint);
                  return result;
              }
          }
      };
      return Tokenizer;
  }());

  var Parser$1 = /** @class */ (function () {
      function Parser(tokens) {
          this._tokens = tokens;
      }
      Parser.create = function (value) {
          var tokenizer = new Tokenizer();
          tokenizer.write(value);
          return new Parser(tokenizer.read());
      };
      Parser.parseValue = function (value) {
          return Parser.create(value).parseComponentValue();
      };
      Parser.parseValues = function (value) {
          return Parser.create(value).parseComponentValues();
      };
      Parser.prototype.parseComponentValue = function () {
          var token = this.consumeToken();
          while (token.type === 31 /* WHITESPACE_TOKEN */) {
              token = this.consumeToken();
          }
          if (token.type === 32 /* EOF_TOKEN */) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
          }
          this.reconsumeToken(token);
          var value = this.consumeComponentValue();
          do {
              token = this.consumeToken();
          } while (token.type === 31 /* WHITESPACE_TOKEN */);
          if (token.type === 32 /* EOF_TOKEN */) {
              return value;
          }
          throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser.prototype.parseComponentValues = function () {
          var values = [];
          while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32 /* EOF_TOKEN */) {
                  return values;
              }
              values.push(value);
              values.push();
          }
      };
      Parser.prototype.consumeComponentValue = function () {
          var token = this.consumeToken();
          switch (token.type) {
              case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
              case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
              case 2 /* LEFT_PARENTHESIS_TOKEN */:
                  return this.consumeSimpleBlock(token.type);
              case 19 /* FUNCTION_TOKEN */:
                  return this.consumeFunction(token);
          }
          return token;
      };
      Parser.prototype.consumeSimpleBlock = function (type) {
          var block = { type: type, values: [] };
          var token = this.consumeToken();
          while (true) {
              if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
                  return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
          }
      };
      Parser.prototype.consumeFunction = function (functionToken) {
          var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18 /* FUNCTION */
          };
          while (true) {
              var token = this.consumeToken();
              if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
                  return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
          }
      };
      Parser.prototype.consumeToken = function () {
          var token = this._tokens.shift();
          return typeof token === 'undefined' ? EOF_TOKEN : token;
      };
      Parser.prototype.reconsumeToken = function (token) {
          this._tokens.unshift(token);
      };
      return Parser;
  }());
  var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
  var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
  var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
  var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
  var isIdentWithValue = function (token, value) {
      return isIdentToken(token) && token.value === value;
  };
  var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
  var nonFunctionArgSeparator = function (token) {
      return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
  };
  var parseFunctionArgs = function (tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function (token) {
          if (token.type === 4 /* COMMA_TOKEN */) {
              if (arg.length === 0) {
                  throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
          }
          if (token.type !== 31 /* WHITESPACE_TOKEN */) {
              arg.push(token);
          }
      });
      if (arg.length) {
          args.push(arg);
      }
      return args;
  };
  var isEndingTokenFor = function (token, type) {
      if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
          return true;
      }
      if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
          return true;
      }
      return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
  };

  var isLength = function (token) {
      return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
  };

  var isLengthPercentage = function (token) {
      return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
  };
  var parseLengthPercentageTuple = function (tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  };
  var ZERO_LENGTH = {
      type: 17 /* NUMBER_TOKEN */,
      number: 0,
      flags: FLAG_INTEGER
  };
  var FIFTY_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var HUNDRED_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 100,
      flags: FLAG_INTEGER
  };
  var getAbsoluteValueForTuple = function (tuple, width, height) {
      var x = tuple[0], y = tuple[1];
      return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
  };
  var getAbsoluteValue = function (token, parent) {
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          return (token.number / 100) * parent;
      }
      if (isDimensionToken(token)) {
          switch (token.unit) {
              case 'rem':
              case 'em':
                  return 16 * token.number; // TODO use correct font-size
              case 'px':
              default:
                  return token.number;
          }
      }
      return token.number;
  };

  var DEG = 'deg';
  var GRAD = 'grad';
  var RAD = 'rad';
  var TURN = 'turn';
  var angle = {
      name: 'angle',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit) {
                  case DEG:
                      return (Math.PI * value.number) / 180;
                  case GRAD:
                      return (Math.PI / 200) * value.number;
                  case RAD:
                      return value.number;
                  case TURN:
                      return Math.PI * 2 * value.number;
              }
          }
          throw new Error("Unsupported angle type");
      }
  };
  var isAngle = function (value) {
      if (value.type === 15 /* DIMENSION_TOKEN */) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
          }
      }
      return false;
  };
  var parseNamedSide = function (tokens) {
      var sideOrCorner = tokens
          .filter(isIdentToken)
          .map(function (ident) { return ident.value; })
          .join(' ');
      switch (sideOrCorner) {
          case 'to bottom right':
          case 'to right bottom':
          case 'left top':
          case 'top left':
              return [ZERO_LENGTH, ZERO_LENGTH];
          case 'to top':
          case 'bottom':
              return deg(0);
          case 'to bottom left':
          case 'to left bottom':
          case 'right top':
          case 'top right':
              return [ZERO_LENGTH, HUNDRED_PERCENT];
          case 'to right':
          case 'left':
              return deg(90);
          case 'to top left':
          case 'to left top':
          case 'right bottom':
          case 'bottom right':
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case 'to bottom':
          case 'top':
              return deg(180);
          case 'to top right':
          case 'to right top':
          case 'left bottom':
          case 'bottom left':
              return [HUNDRED_PERCENT, ZERO_LENGTH];
          case 'to left':
          case 'right':
              return deg(270);
      }
      return 0;
  };
  var deg = function (deg) { return (Math.PI * deg) / 180; };

  var color$1 = {
      name: 'color',
      parse: function (context, value) {
          if (value.type === 18 /* FUNCTION */) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
              }
              return colorFunction(context, value.values);
          }
          if (value.type === 5 /* HASH_TOKEN */) {
              if (value.value.length === 3) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
              }
              if (value.value.length === 4) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  var a = value.value.substring(3, 4);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
              }
              if (value.value.length === 6) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
              }
              if (value.value.length === 8) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  var a = value.value.substring(6, 8);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
              }
          }
          if (value.type === 20 /* IDENT_TOKEN */) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== 'undefined') {
                  return namedColor;
              }
          }
          return COLORS.TRANSPARENT;
      }
  };
  var isTransparent = function (color) { return (0xff & color) === 0; };
  var asString = function (color) {
      var alpha = 0xff & color;
      var blue = 0xff & (color >> 8);
      var green = 0xff & (color >> 16);
      var red = 0xff & (color >> 24);
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  };
  var pack = function (r, g, b, a) {
      return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
  };
  var getTokenColorValue = function (token, i) {
      if (token.type === 17 /* NUMBER_TOKEN */) {
          return token.number;
      }
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          var max = i === 3 ? 1 : 255;
          return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
      }
      return 0;
  };
  var rgb = function (_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
          var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
          return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
          var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
          return pack(r, g, b, a);
      }
      return 0;
  };
  function hue2rgb(t1, t2, hue) {
      if (hue < 0) {
          hue += 1;
      }
      if (hue >= 1) {
          hue -= 1;
      }
      if (hue < 1 / 6) {
          return (t2 - t1) * hue * 6 + t1;
      }
      else if (hue < 1 / 2) {
          return t2;
      }
      else if (hue < 2 / 3) {
          return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
      }
      else {
          return t1;
      }
  }
  var hsl = function (context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
          return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h + 1 / 3);
      var g = hue2rgb(t1, t2, h);
      var b = hue2rgb(t1, t2, h - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a);
  };
  var SUPPORTED_COLOR_FUNCTIONS = {
      hsl: hsl,
      hsla: hsl,
      rgb: rgb,
      rgba: rgb
  };
  var parseColor = function (context, value) {
      return color$1.parse(context, Parser$1.create(value).parseComponentValue());
  };
  var COLORS = {
      ALICEBLUE: 0xf0f8ffff,
      ANTIQUEWHITE: 0xfaebd7ff,
      AQUA: 0x00ffffff,
      AQUAMARINE: 0x7fffd4ff,
      AZURE: 0xf0ffffff,
      BEIGE: 0xf5f5dcff,
      BISQUE: 0xffe4c4ff,
      BLACK: 0x000000ff,
      BLANCHEDALMOND: 0xffebcdff,
      BLUE: 0x0000ffff,
      BLUEVIOLET: 0x8a2be2ff,
      BROWN: 0xa52a2aff,
      BURLYWOOD: 0xdeb887ff,
      CADETBLUE: 0x5f9ea0ff,
      CHARTREUSE: 0x7fff00ff,
      CHOCOLATE: 0xd2691eff,
      CORAL: 0xff7f50ff,
      CORNFLOWERBLUE: 0x6495edff,
      CORNSILK: 0xfff8dcff,
      CRIMSON: 0xdc143cff,
      CYAN: 0x00ffffff,
      DARKBLUE: 0x00008bff,
      DARKCYAN: 0x008b8bff,
      DARKGOLDENROD: 0xb886bbff,
      DARKGRAY: 0xa9a9a9ff,
      DARKGREEN: 0x006400ff,
      DARKGREY: 0xa9a9a9ff,
      DARKKHAKI: 0xbdb76bff,
      DARKMAGENTA: 0x8b008bff,
      DARKOLIVEGREEN: 0x556b2fff,
      DARKORANGE: 0xff8c00ff,
      DARKORCHID: 0x9932ccff,
      DARKRED: 0x8b0000ff,
      DARKSALMON: 0xe9967aff,
      DARKSEAGREEN: 0x8fbc8fff,
      DARKSLATEBLUE: 0x483d8bff,
      DARKSLATEGRAY: 0x2f4f4fff,
      DARKSLATEGREY: 0x2f4f4fff,
      DARKTURQUOISE: 0x00ced1ff,
      DARKVIOLET: 0x9400d3ff,
      DEEPPINK: 0xff1493ff,
      DEEPSKYBLUE: 0x00bfffff,
      DIMGRAY: 0x696969ff,
      DIMGREY: 0x696969ff,
      DODGERBLUE: 0x1e90ffff,
      FIREBRICK: 0xb22222ff,
      FLORALWHITE: 0xfffaf0ff,
      FORESTGREEN: 0x228b22ff,
      FUCHSIA: 0xff00ffff,
      GAINSBORO: 0xdcdcdcff,
      GHOSTWHITE: 0xf8f8ffff,
      GOLD: 0xffd700ff,
      GOLDENROD: 0xdaa520ff,
      GRAY: 0x808080ff,
      GREEN: 0x008000ff,
      GREENYELLOW: 0xadff2fff,
      GREY: 0x808080ff,
      HONEYDEW: 0xf0fff0ff,
      HOTPINK: 0xff69b4ff,
      INDIANRED: 0xcd5c5cff,
      INDIGO: 0x4b0082ff,
      IVORY: 0xfffff0ff,
      KHAKI: 0xf0e68cff,
      LAVENDER: 0xe6e6faff,
      LAVENDERBLUSH: 0xfff0f5ff,
      LAWNGREEN: 0x7cfc00ff,
      LEMONCHIFFON: 0xfffacdff,
      LIGHTBLUE: 0xadd8e6ff,
      LIGHTCORAL: 0xf08080ff,
      LIGHTCYAN: 0xe0ffffff,
      LIGHTGOLDENRODYELLOW: 0xfafad2ff,
      LIGHTGRAY: 0xd3d3d3ff,
      LIGHTGREEN: 0x90ee90ff,
      LIGHTGREY: 0xd3d3d3ff,
      LIGHTPINK: 0xffb6c1ff,
      LIGHTSALMON: 0xffa07aff,
      LIGHTSEAGREEN: 0x20b2aaff,
      LIGHTSKYBLUE: 0x87cefaff,
      LIGHTSLATEGRAY: 0x778899ff,
      LIGHTSLATEGREY: 0x778899ff,
      LIGHTSTEELBLUE: 0xb0c4deff,
      LIGHTYELLOW: 0xffffe0ff,
      LIME: 0x00ff00ff,
      LIMEGREEN: 0x32cd32ff,
      LINEN: 0xfaf0e6ff,
      MAGENTA: 0xff00ffff,
      MAROON: 0x800000ff,
      MEDIUMAQUAMARINE: 0x66cdaaff,
      MEDIUMBLUE: 0x0000cdff,
      MEDIUMORCHID: 0xba55d3ff,
      MEDIUMPURPLE: 0x9370dbff,
      MEDIUMSEAGREEN: 0x3cb371ff,
      MEDIUMSLATEBLUE: 0x7b68eeff,
      MEDIUMSPRINGGREEN: 0x00fa9aff,
      MEDIUMTURQUOISE: 0x48d1ccff,
      MEDIUMVIOLETRED: 0xc71585ff,
      MIDNIGHTBLUE: 0x191970ff,
      MINTCREAM: 0xf5fffaff,
      MISTYROSE: 0xffe4e1ff,
      MOCCASIN: 0xffe4b5ff,
      NAVAJOWHITE: 0xffdeadff,
      NAVY: 0x000080ff,
      OLDLACE: 0xfdf5e6ff,
      OLIVE: 0x808000ff,
      OLIVEDRAB: 0x6b8e23ff,
      ORANGE: 0xffa500ff,
      ORANGERED: 0xff4500ff,
      ORCHID: 0xda70d6ff,
      PALEGOLDENROD: 0xeee8aaff,
      PALEGREEN: 0x98fb98ff,
      PALETURQUOISE: 0xafeeeeff,
      PALEVIOLETRED: 0xdb7093ff,
      PAPAYAWHIP: 0xffefd5ff,
      PEACHPUFF: 0xffdab9ff,
      PERU: 0xcd853fff,
      PINK: 0xffc0cbff,
      PLUM: 0xdda0ddff,
      POWDERBLUE: 0xb0e0e6ff,
      PURPLE: 0x800080ff,
      REBECCAPURPLE: 0x663399ff,
      RED: 0xff0000ff,
      ROSYBROWN: 0xbc8f8fff,
      ROYALBLUE: 0x4169e1ff,
      SADDLEBROWN: 0x8b4513ff,
      SALMON: 0xfa8072ff,
      SANDYBROWN: 0xf4a460ff,
      SEAGREEN: 0x2e8b57ff,
      SEASHELL: 0xfff5eeff,
      SIENNA: 0xa0522dff,
      SILVER: 0xc0c0c0ff,
      SKYBLUE: 0x87ceebff,
      SLATEBLUE: 0x6a5acdff,
      SLATEGRAY: 0x708090ff,
      SLATEGREY: 0x708090ff,
      SNOW: 0xfffafaff,
      SPRINGGREEN: 0x00ff7fff,
      STEELBLUE: 0x4682b4ff,
      TAN: 0xd2b48cff,
      TEAL: 0x008080ff,
      THISTLE: 0xd8bfd8ff,
      TOMATO: 0xff6347ff,
      TRANSPARENT: 0x00000000,
      TURQUOISE: 0x40e0d0ff,
      VIOLET: 0xee82eeff,
      WHEAT: 0xf5deb3ff,
      WHITE: 0xffffffff,
      WHITESMOKE: 0xf5f5f5ff,
      YELLOW: 0xffff00ff,
      YELLOWGREEN: 0x9acd32ff
  };

  var backgroundClip = {
      name: 'background-clip',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundColor = {
      name: "background-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var parseColorStop = function (context, args) {
      var color = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
  };
  var processColorStops = function (stops, lineLength) {
      var first = stops[0];
      var last = stops[stops.length - 1];
      if (first.stop === null) {
          first.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i = 0; i < stops.length; i++) {
          var stop_1 = stops[i].stop;
          if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                  processStops.push(absoluteValue);
              }
              else {
                  processStops.push(previous);
              }
              previous = absoluteValue;
          }
          else {
              processStops.push(null);
          }
      }
      var gapBegin = null;
      for (var i = 0; i < processStops.length; i++) {
          var stop_2 = processStops[i];
          if (stop_2 === null) {
              if (gapBegin === null) {
                  gapBegin = i;
              }
          }
          else if (gapBegin !== null) {
              var gapLength = i - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g = 1; g <= gapLength; g++) {
                  processStops[gapBegin + g - 1] = gapValue * g;
              }
              gapBegin = null;
          }
      }
      return stops.map(function (_a, i) {
          var color = _a.color;
          return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
      });
  };
  var getAngleFromCorner = function (corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x = getAbsoluteValue(corner[0], width) - centerX;
      var y = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
  };
  var calculateGradientDirection = function (angle, width, height) {
      var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  };
  var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
  var findCorner = function (width, height, x, y, closest) {
      var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
      ];
      return corners.reduce(function (stat, corner) {
          var cx = corner[0], cy = corner[1];
          var d = distance(x - cx, y - cy);
          if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
              return {
                  optimumCorner: corner,
                  optimumDistance: d
              };
          }
          return stat;
      }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
      }).optimumCorner;
  };
  var calculateRadius = function (gradient, x, y, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
          case 0 /* CLOSEST_SIDE */:
              // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, it exactly meets the closest side in each dimension.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.min(Math.abs(x), Math.abs(x - width));
                  ry = Math.min(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 2 /* CLOSEST_CORNER */:
              // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                  var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                  var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
          case 1 /* FARTHEST_SIDE */:
              // Same as closest-side, except the ending shape is sized based on the farthest side(s)
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.max(Math.abs(x), Math.abs(x - width));
                  ry = Math.max(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 3 /* FARTHEST_CORNER */:
              // Same as closest-corner, except the ending shape is sized based on the farthest corner.
              // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                  var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                  var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
      }
      if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
  };

  var linearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = angle.parse(context, firstToken);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
  };

  var prefixLinearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ &&
                  ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return {
          angle: angle$1,
          stops: stops,
          type: 1 /* LINEAR_GRADIENT */
      };
  };

  var webkitGradient = function (context, tokens) {
      var angle = deg(180);
      var stops = [];
      var type = 1 /* LINEAR_GRADIENT */;
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var firstToken = arg[0];
          if (i === 0) {
              if (isIdentToken(firstToken) && firstToken.value === 'linear') {
                  type = 1 /* LINEAR_GRADIENT */;
                  return;
              }
              else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
                  type = 2 /* RADIAL_GRADIENT */;
                  return;
              }
          }
          if (firstToken.type === 18 /* FUNCTION */) {
              if (firstToken.name === 'from') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: ZERO_LENGTH, color: color });
              }
              else if (firstToken.name === 'to') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: HUNDRED_PERCENT, color: color });
              }
              else if (firstToken.name === 'color-stop') {
                  var values = firstToken.values.filter(nonFunctionArgSeparator);
                  if (values.length === 2) {
                      var color = color$1.parse(context, values[1]);
                      var stop_1 = values[0];
                      if (isNumberToken(stop_1)) {
                          stops.push({
                              stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
                              color: color
                          });
                      }
                  }
              }
          }
      });
      return type === 1 /* LINEAR_GRADIENT */
          ? {
              angle: (angle + deg(180)) % deg(360),
              stops: stops,
              type: type
          }
          : { size: size, shape: shape, stops: stops, position: position, type: type };
  };

  var CLOSEST_SIDE = 'closest-side';
  var FARTHEST_SIDE = 'farthest-side';
  var CLOSEST_CORNER = 'closest-corner';
  var FARTHEST_CORNER = 'farthest-corner';
  var CIRCLE = 'circle';
  var ELLIPSE = 'ellipse';
  var COVER = 'cover';
  var CONTAIN = 'contain';
  var radialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function (acc, token) {
                  if (isAtPosition_1) {
                      if (isIdentToken(token)) {
                          switch (token.value) {
                              case 'center':
                                  position.push(FIFTY_PERCENT);
                                  return acc;
                              case 'top':
                              case 'left':
                                  position.push(ZERO_LENGTH);
                                  return acc;
                              case 'right':
                              case 'bottom':
                                  position.push(HUNDRED_PERCENT);
                                  return acc;
                          }
                      }
                      else if (isLengthPercentage(token) || isLength(token)) {
                          position.push(token);
                      }
                  }
                  else if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case 'at':
                              isAtPosition_1 = true;
                              return false;
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case COVER:
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var prefixRadialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case 'center':
                              position.push(FIFTY_PERCENT);
                              return false;
                          case 'top':
                          case 'left':
                              position.push(ZERO_LENGTH);
                              return false;
                          case 'right':
                          case 'bottom':
                              position.push(HUNDRED_PERCENT);
                              return false;
                      }
                  }
                  else if (isLengthPercentage(token) || isLength(token)) {
                      position.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          else if (i === 1) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case COVER:
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var isLinearGradient = function (background) {
      return background.type === 1 /* LINEAR_GRADIENT */;
  };
  var isRadialGradient = function (background) {
      return background.type === 2 /* RADIAL_GRADIENT */;
  };
  var image = {
      name: 'image',
      parse: function (context, value) {
          if (value.type === 22 /* URL_TOKEN */) {
              var image_1 = { url: value.value, type: 0 /* URL */ };
              context.cache.addImage(value.value);
              return image_1;
          }
          if (value.type === 18 /* FUNCTION */) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
              }
              return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
      }
  };
  function isSupportedImage(value) {
      return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
          (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
  }
  var SUPPORTED_IMAGE_FUNCTIONS = {
      'linear-gradient': linearGradient,
      '-moz-linear-gradient': prefixLinearGradient,
      '-ms-linear-gradient': prefixLinearGradient,
      '-o-linear-gradient': prefixLinearGradient,
      '-webkit-linear-gradient': prefixLinearGradient,
      'radial-gradient': radialGradient,
      '-moz-radial-gradient': prefixRadialGradient,
      '-ms-radial-gradient': prefixRadialGradient,
      '-o-radial-gradient': prefixRadialGradient,
      '-webkit-radial-gradient': prefixRadialGradient,
      '-webkit-gradient': webkitGradient
  };

  var backgroundImage = {
      name: 'background-image',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens
              .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
              .map(function (value) { return image.parse(context, value); });
      }
  };

  var backgroundOrigin = {
      name: 'background-origin',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundPosition = {
      name: 'background-position',
      initialValue: '0% 0%',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) { return values.filter(isLengthPercentage); })
              .map(parseLengthPercentageTuple);
      }
  };

  var backgroundRepeat = {
      name: 'background-repeat',
      initialValue: 'repeat',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) {
              return values
                  .filter(isIdentToken)
                  .map(function (token) { return token.value; })
                  .join(' ');
          })
              .map(parseBackgroundRepeat);
      }
  };
  var parseBackgroundRepeat = function (value) {
      switch (value) {
          case 'no-repeat':
              return 1 /* NO_REPEAT */;
          case 'repeat-x':
          case 'repeat no-repeat':
              return 2 /* REPEAT_X */;
          case 'repeat-y':
          case 'no-repeat repeat':
              return 3 /* REPEAT_Y */;
          case 'repeat':
          default:
              return 0 /* REPEAT */;
      }
  };

  var BACKGROUND_SIZE;
  (function (BACKGROUND_SIZE) {
      BACKGROUND_SIZE["AUTO"] = "auto";
      BACKGROUND_SIZE["CONTAIN"] = "contain";
      BACKGROUND_SIZE["COVER"] = "cover";
  })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  var backgroundSize = {
      name: 'background-size',
      initialValue: '0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
      }
  };
  var isBackgroundSizeInfoToken = function (value) {
      return isIdentToken(value) || isLengthPercentage(value);
  };

  var borderColorForSide = function (side) { return ({
      name: "border-" + side + "-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  }); };
  var borderTopColor = borderColorForSide('top');
  var borderRightColor = borderColorForSide('right');
  var borderBottomColor = borderColorForSide('bottom');
  var borderLeftColor = borderColorForSide('left');

  var borderRadiusForSide = function (side) { return ({
      name: "border-radius-" + side,
      initialValue: '0 0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
      }
  }); };
  var borderTopLeftRadius = borderRadiusForSide('top-left');
  var borderTopRightRadius = borderRadiusForSide('top-right');
  var borderBottomRightRadius = borderRadiusForSide('bottom-right');
  var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

  var borderStyleForSide = function (side) { return ({
      name: "border-" + side + "-style",
      initialValue: 'solid',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, style) {
          switch (style) {
              case 'none':
                  return 0 /* NONE */;
              case 'dashed':
                  return 2 /* DASHED */;
              case 'dotted':
                  return 3 /* DOTTED */;
              case 'double':
                  return 4 /* DOUBLE */;
          }
          return 1 /* SOLID */;
      }
  }); };
  var borderTopStyle = borderStyleForSide('top');
  var borderRightStyle = borderStyleForSide('right');
  var borderBottomStyle = borderStyleForSide('bottom');
  var borderLeftStyle = borderStyleForSide('left');

  var borderWidthForSide = function (side) { return ({
      name: "border-" + side + "-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  }); };
  var borderTopWidth = borderWidthForSide('top');
  var borderRightWidth = borderWidthForSide('right');
  var borderBottomWidth = borderWidthForSide('bottom');
  var borderLeftWidth = borderWidthForSide('left');

  var color = {
      name: "color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var direction = {
      name: 'direction',
      initialValue: 'ltr',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, direction) {
          switch (direction) {
              case 'rtl':
                  return 1 /* RTL */;
              case 'ltr':
              default:
                  return 0 /* LTR */;
          }
      }
  };

  var display = {
      name: 'display',
      initialValue: 'inline-block',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).reduce(function (bit, token) {
              return bit | parseDisplayValue(token.value);
          }, 0 /* NONE */);
      }
  };
  var parseDisplayValue = function (display) {
      switch (display) {
          case 'block':
          case '-webkit-box':
              return 2 /* BLOCK */;
          case 'inline':
              return 4 /* INLINE */;
          case 'run-in':
              return 8 /* RUN_IN */;
          case 'flow':
              return 16 /* FLOW */;
          case 'flow-root':
              return 32 /* FLOW_ROOT */;
          case 'table':
              return 64 /* TABLE */;
          case 'flex':
          case '-webkit-flex':
              return 128 /* FLEX */;
          case 'grid':
          case '-ms-grid':
              return 256 /* GRID */;
          case 'ruby':
              return 512 /* RUBY */;
          case 'subgrid':
              return 1024 /* SUBGRID */;
          case 'list-item':
              return 2048 /* LIST_ITEM */;
          case 'table-row-group':
              return 4096 /* TABLE_ROW_GROUP */;
          case 'table-header-group':
              return 8192 /* TABLE_HEADER_GROUP */;
          case 'table-footer-group':
              return 16384 /* TABLE_FOOTER_GROUP */;
          case 'table-row':
              return 32768 /* TABLE_ROW */;
          case 'table-cell':
              return 65536 /* TABLE_CELL */;
          case 'table-column-group':
              return 131072 /* TABLE_COLUMN_GROUP */;
          case 'table-column':
              return 262144 /* TABLE_COLUMN */;
          case 'table-caption':
              return 524288 /* TABLE_CAPTION */;
          case 'ruby-base':
              return 1048576 /* RUBY_BASE */;
          case 'ruby-text':
              return 2097152 /* RUBY_TEXT */;
          case 'ruby-base-container':
              return 4194304 /* RUBY_BASE_CONTAINER */;
          case 'ruby-text-container':
              return 8388608 /* RUBY_TEXT_CONTAINER */;
          case 'contents':
              return 16777216 /* CONTENTS */;
          case 'inline-block':
              return 33554432 /* INLINE_BLOCK */;
          case 'inline-list-item':
              return 67108864 /* INLINE_LIST_ITEM */;
          case 'inline-table':
              return 134217728 /* INLINE_TABLE */;
          case 'inline-flex':
              return 268435456 /* INLINE_FLEX */;
          case 'inline-grid':
              return 536870912 /* INLINE_GRID */;
      }
      return 0 /* NONE */;
  };

  var float = {
      name: 'float',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, float) {
          switch (float) {
              case 'left':
                  return 1 /* LEFT */;
              case 'right':
                  return 2 /* RIGHT */;
              case 'inline-start':
                  return 3 /* INLINE_START */;
              case 'inline-end':
                  return 4 /* INLINE_END */;
          }
          return 0 /* NONE */;
      }
  };

  var letterSpacing = {
      name: 'letter-spacing',
      initialValue: '0',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
              return 0;
          }
          if (token.type === 17 /* NUMBER_TOKEN */) {
              return token.number;
          }
          if (token.type === 15 /* DIMENSION_TOKEN */) {
              return token.number;
          }
          return 0;
      }
  };

  var LINE_BREAK;
  (function (LINE_BREAK) {
      LINE_BREAK["NORMAL"] = "normal";
      LINE_BREAK["STRICT"] = "strict";
  })(LINE_BREAK || (LINE_BREAK = {}));
  var lineBreak = {
      name: 'line-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, lineBreak) {
          switch (lineBreak) {
              case 'strict':
                  return LINE_BREAK.STRICT;
              case 'normal':
              default:
                  return LINE_BREAK.NORMAL;
          }
      }
  };

  var lineHeight = {
      name: 'line-height',
      initialValue: 'normal',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  };
  var computeLineHeight = function (token, fontSize) {
      if (isIdentToken(token) && token.value === 'normal') {
          return 1.2 * fontSize;
      }
      else if (token.type === 17 /* NUMBER_TOKEN */) {
          return fontSize * token.number;
      }
      else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize);
      }
      return fontSize;
  };

  var listStyleImage = {
      name: 'list-style-image',
      initialValue: 'none',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          return image.parse(context, token);
      }
  };

  var listStylePosition = {
      name: 'list-style-position',
      initialValue: 'outside',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'inside':
                  return 0 /* INSIDE */;
              case 'outside':
              default:
                  return 1 /* OUTSIDE */;
          }
      }
  };

  var listStyleType = {
      name: 'list-style-type',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, type) {
          switch (type) {
              case 'disc':
                  return 0 /* DISC */;
              case 'circle':
                  return 1 /* CIRCLE */;
              case 'square':
                  return 2 /* SQUARE */;
              case 'decimal':
                  return 3 /* DECIMAL */;
              case 'cjk-decimal':
                  return 4 /* CJK_DECIMAL */;
              case 'decimal-leading-zero':
                  return 5 /* DECIMAL_LEADING_ZERO */;
              case 'lower-roman':
                  return 6 /* LOWER_ROMAN */;
              case 'upper-roman':
                  return 7 /* UPPER_ROMAN */;
              case 'lower-greek':
                  return 8 /* LOWER_GREEK */;
              case 'lower-alpha':
                  return 9 /* LOWER_ALPHA */;
              case 'upper-alpha':
                  return 10 /* UPPER_ALPHA */;
              case 'arabic-indic':
                  return 11 /* ARABIC_INDIC */;
              case 'armenian':
                  return 12 /* ARMENIAN */;
              case 'bengali':
                  return 13 /* BENGALI */;
              case 'cambodian':
                  return 14 /* CAMBODIAN */;
              case 'cjk-earthly-branch':
                  return 15 /* CJK_EARTHLY_BRANCH */;
              case 'cjk-heavenly-stem':
                  return 16 /* CJK_HEAVENLY_STEM */;
              case 'cjk-ideographic':
                  return 17 /* CJK_IDEOGRAPHIC */;
              case 'devanagari':
                  return 18 /* DEVANAGARI */;
              case 'ethiopic-numeric':
                  return 19 /* ETHIOPIC_NUMERIC */;
              case 'georgian':
                  return 20 /* GEORGIAN */;
              case 'gujarati':
                  return 21 /* GUJARATI */;
              case 'gurmukhi':
                  return 22 /* GURMUKHI */;
              case 'hebrew':
                  return 22 /* HEBREW */;
              case 'hiragana':
                  return 23 /* HIRAGANA */;
              case 'hiragana-iroha':
                  return 24 /* HIRAGANA_IROHA */;
              case 'japanese-formal':
                  return 25 /* JAPANESE_FORMAL */;
              case 'japanese-informal':
                  return 26 /* JAPANESE_INFORMAL */;
              case 'kannada':
                  return 27 /* KANNADA */;
              case 'katakana':
                  return 28 /* KATAKANA */;
              case 'katakana-iroha':
                  return 29 /* KATAKANA_IROHA */;
              case 'khmer':
                  return 30 /* KHMER */;
              case 'korean-hangul-formal':
                  return 31 /* KOREAN_HANGUL_FORMAL */;
              case 'korean-hanja-formal':
                  return 32 /* KOREAN_HANJA_FORMAL */;
              case 'korean-hanja-informal':
                  return 33 /* KOREAN_HANJA_INFORMAL */;
              case 'lao':
                  return 34 /* LAO */;
              case 'lower-armenian':
                  return 35 /* LOWER_ARMENIAN */;
              case 'malayalam':
                  return 36 /* MALAYALAM */;
              case 'mongolian':
                  return 37 /* MONGOLIAN */;
              case 'myanmar':
                  return 38 /* MYANMAR */;
              case 'oriya':
                  return 39 /* ORIYA */;
              case 'persian':
                  return 40 /* PERSIAN */;
              case 'simp-chinese-formal':
                  return 41 /* SIMP_CHINESE_FORMAL */;
              case 'simp-chinese-informal':
                  return 42 /* SIMP_CHINESE_INFORMAL */;
              case 'tamil':
                  return 43 /* TAMIL */;
              case 'telugu':
                  return 44 /* TELUGU */;
              case 'thai':
                  return 45 /* THAI */;
              case 'tibetan':
                  return 46 /* TIBETAN */;
              case 'trad-chinese-formal':
                  return 47 /* TRAD_CHINESE_FORMAL */;
              case 'trad-chinese-informal':
                  return 48 /* TRAD_CHINESE_INFORMAL */;
              case 'upper-armenian':
                  return 49 /* UPPER_ARMENIAN */;
              case 'disclosure-open':
                  return 50 /* DISCLOSURE_OPEN */;
              case 'disclosure-closed':
                  return 51 /* DISCLOSURE_CLOSED */;
              case 'none':
              default:
                  return -1 /* NONE */;
          }
      }
  };

  var marginForSide = function (side) { return ({
      name: "margin-" + side,
      initialValue: '0',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  }); };
  var marginTop = marginForSide('top');
  var marginRight = marginForSide('right');
  var marginBottom = marginForSide('bottom');
  var marginLeft = marginForSide('left');

  var overflow = {
      name: 'overflow',
      initialValue: 'visible',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (overflow) {
              switch (overflow.value) {
                  case 'hidden':
                      return 1 /* HIDDEN */;
                  case 'scroll':
                      return 2 /* SCROLL */;
                  case 'clip':
                      return 3 /* CLIP */;
                  case 'auto':
                      return 4 /* AUTO */;
                  case 'visible':
                  default:
                      return 0 /* VISIBLE */;
              }
          });
      }
  };

  var overflowWrap = {
      name: 'overflow-wrap',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'break-word':
                  return "break-word" /* BREAK_WORD */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var paddingForSide = function (side) { return ({
      name: "padding-" + side,
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length-percentage'
  }); };
  var paddingTop = paddingForSide('top');
  var paddingRight = paddingForSide('right');
  var paddingBottom = paddingForSide('bottom');
  var paddingLeft = paddingForSide('left');

  var textAlign = {
      name: 'text-align',
      initialValue: 'left',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textAlign) {
          switch (textAlign) {
              case 'right':
                  return 2 /* RIGHT */;
              case 'center':
              case 'justify':
                  return 1 /* CENTER */;
              case 'left':
              default:
                  return 0 /* LEFT */;
          }
      }
  };

  var position = {
      name: 'position',
      initialValue: 'static',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'relative':
                  return 1 /* RELATIVE */;
              case 'absolute':
                  return 2 /* ABSOLUTE */;
              case 'fixed':
                  return 3 /* FIXED */;
              case 'sticky':
                  return 4 /* STICKY */;
          }
          return 0 /* STATIC */;
      }
  };

  var textShadow = {
      name: 'text-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: COLORS.TRANSPARENT,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else {
                          shadow.blur = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var textTransform = {
      name: 'text-transform',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textTransform) {
          switch (textTransform) {
              case 'uppercase':
                  return 2 /* UPPERCASE */;
              case 'lowercase':
                  return 1 /* LOWERCASE */;
              case 'capitalize':
                  return 3 /* CAPITALIZE */;
          }
          return 0 /* NONE */;
      }
  };

  var transform$1 = {
      name: 'transform',
      initialValue: 'none',
      prefix: true,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          if (token.type === 18 /* FUNCTION */) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
              }
              return transformFunction(token.values);
          }
          return null;
      }
  };
  var matrix = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      return values.length === 6 ? values : null;
  };
  // doesn't support 3D transforms at the moment
  var matrix3d = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  };
  var SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix: matrix,
      matrix3d: matrix3d
  };

  var DEFAULT_VALUE = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  var transformOrigin = {
      name: 'transform-origin',
      initialValue: '50% 50%',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
              return DEFAULT;
          }
          return [origins[0], origins[1]];
      }
  };

  var visibility = {
      name: 'visible',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, visibility) {
          switch (visibility) {
              case 'hidden':
                  return 1 /* HIDDEN */;
              case 'collapse':
                  return 2 /* COLLAPSE */;
              case 'visible':
              default:
                  return 0 /* VISIBLE */;
          }
      }
  };

  var WORD_BREAK;
  (function (WORD_BREAK) {
      WORD_BREAK["NORMAL"] = "normal";
      WORD_BREAK["BREAK_ALL"] = "break-all";
      WORD_BREAK["KEEP_ALL"] = "keep-all";
  })(WORD_BREAK || (WORD_BREAK = {}));
  var wordBreak = {
      name: 'word-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, wordBreak) {
          switch (wordBreak) {
              case 'break-all':
                  return WORD_BREAK.BREAK_ALL;
              case 'keep-all':
                  return WORD_BREAK.KEEP_ALL;
              case 'normal':
              default:
                  return WORD_BREAK.NORMAL;
          }
      }
  };

  var zIndex = {
      name: 'z-index',
      initialValue: 'auto',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */) {
              return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
              return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
      }
  };

  var time = {
      name: 'time',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit.toLowerCase()) {
                  case 's':
                      return 1000 * value.number;
                  case 'ms':
                      return value.number;
              }
          }
          throw new Error("Unsupported time type");
      }
  };

  var opacity = {
      name: 'opacity',
      initialValue: '1',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          return 1;
      }
  };

  var textDecorationColor = {
      name: "text-decoration-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var textDecorationLine = {
      name: 'text-decoration-line',
      initialValue: 'none',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens
              .filter(isIdentToken)
              .map(function (token) {
              switch (token.value) {
                  case 'underline':
                      return 1 /* UNDERLINE */;
                  case 'overline':
                      return 2 /* OVERLINE */;
                  case 'line-through':
                      return 3 /* LINE_THROUGH */;
                  case 'none':
                      return 4 /* BLINK */;
              }
              return 0 /* NONE */;
          })
              .filter(function (line) { return line !== 0 /* NONE */; });
      }
  };

  var fontFamily = {
      name: "font-family",
      initialValue: '',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function (token) {
              switch (token.type) {
                  case 20 /* IDENT_TOKEN */:
                  case 0 /* STRING_TOKEN */:
                      accumulator.push(token.value);
                      break;
                  case 17 /* NUMBER_TOKEN */:
                      accumulator.push(token.number.toString());
                      break;
                  case 4 /* COMMA_TOKEN */:
                      results.push(accumulator.join(' '));
                      accumulator.length = 0;
                      break;
              }
          });
          if (accumulator.length) {
              results.push(accumulator.join(' '));
          }
          return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
      }
  };

  var fontSize = {
      name: "font-size",
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length'
  };

  var fontWeight = {
      name: 'font-weight',
      initialValue: 'normal',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          if (isIdentToken(token)) {
              switch (token.value) {
                  case 'bold':
                      return 700;
                  case 'normal':
                  default:
                      return 400;
              }
          }
          return 400;
      }
  };

  var fontVariant = {
      name: 'font-variant',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (token) { return token.value; });
      }
  };

  var fontStyle = {
      name: 'font-style',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'oblique':
                  return "oblique" /* OBLIQUE */;
              case 'italic':
                  return "italic" /* ITALIC */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var contains = function (bit, value) { return (bit & value) !== 0; };

  var content = {
      name: 'content',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens;
      }
  };

  var counterIncrement = {
      name: 'counter-increment',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (counter.type === 20 /* IDENT_TOKEN */) {
                  var increment = next && isNumberToken(next) ? next.number : 1;
                  increments.push({ counter: counter.value, increment: increment });
              }
          }
          return increments;
      }
  };

  var counterReset = {
      name: 'counter-reset',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (isIdentToken(counter) && counter.value !== 'none') {
                  var reset = next && isNumberToken(next) ? next.number : 0;
                  resets.push({ counter: counter.value, reset: reset });
              }
          }
          return resets;
      }
  };

  var duration = {
      name: 'duration',
      initialValue: '0s',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (context, tokens) {
          return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
      }
  };

  var quotes = {
      name: 'quotes',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var quotes = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
              return null;
          }
          for (var i = 0; i < filtered.length; i += 2) {
              var open_1 = filtered[i].value;
              var close_1 = filtered[i + 1].value;
              quotes.push({ open: open_1, close: close_1 });
          }
          return quotes;
      }
  };
  var getQuote = function (quotes, depth, open) {
      if (!quotes) {
          return '';
      }
      var quote = quotes[Math.min(depth, quotes.length - 1)];
      if (!quote) {
          return '';
      }
      return open ? quote.open : quote.close;
  };

  var boxShadow = {
      name: 'box-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: 0x000000ff,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH,
                  spread: ZERO_LENGTH,
                  inset: false
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isIdentWithValue(token, 'inset')) {
                      shadow.inset = true;
                  }
                  else if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else if (c === 2) {
                          shadow.blur = token;
                      }
                      else {
                          shadow.spread = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var paintOrder = {
      name: 'paint-order',
      initialValue: 'normal',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function (token) {
              switch (token.value) {
                  case 'stroke':
                      layers.push(1 /* STROKE */);
                      break;
                  case 'fill':
                      layers.push(0 /* FILL */);
                      break;
                  case 'markers':
                      layers.push(2 /* MARKERS */);
                      break;
              }
          });
          DEFAULT_VALUE.forEach(function (value) {
              if (layers.indexOf(value) === -1) {
                  layers.push(value);
              }
          });
          return layers;
      }
  };

  var webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: 'currentcolor',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  };

  var CSSParsedDeclaration = /** @class */ (function () {
      function CSSParsedDeclaration(context, declaration) {
          var _a, _b;
          this.animationDuration = parse(context, duration, declaration.animationDuration);
          this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
          this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
          this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
          this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
          this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
          this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
          this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
          this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
          this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
          this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
          this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
          this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
          this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
          this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
          this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
          this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
          this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
          this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
          this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
          this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
          this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
          this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
          this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
          this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
          this.color = parse(context, color, declaration.color);
          this.direction = parse(context, direction, declaration.direction);
          this.display = parse(context, display, declaration.display);
          this.float = parse(context, float, declaration.cssFloat);
          this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
          this.fontSize = parse(context, fontSize, declaration.fontSize);
          this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
          this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
          this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
          this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
          this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
          this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
          this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
          this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
          this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
          this.marginTop = parse(context, marginTop, declaration.marginTop);
          this.marginRight = parse(context, marginRight, declaration.marginRight);
          this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
          this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
          this.opacity = parse(context, opacity, declaration.opacity);
          var overflowTuple = parse(context, overflow, declaration.overflow);
          this.overflowX = overflowTuple[0];
          this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
          this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
          this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
          this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
          this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
          this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
          this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
          this.position = parse(context, position, declaration.position);
          this.textAlign = parse(context, textAlign, declaration.textAlign);
          this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
          this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
          this.textShadow = parse(context, textShadow, declaration.textShadow);
          this.textTransform = parse(context, textTransform, declaration.textTransform);
          this.transform = parse(context, transform$1, declaration.transform);
          this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
          this.visibility = parse(context, visibility, declaration.visibility);
          this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
          this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
          this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
          this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration.prototype.isVisible = function () {
          return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
      };
      CSSParsedDeclaration.prototype.isTransparent = function () {
          return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration.prototype.isTransformed = function () {
          return this.transform !== null;
      };
      CSSParsedDeclaration.prototype.isPositioned = function () {
          return this.position !== 0 /* STATIC */;
      };
      CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
          return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration.prototype.isFloating = function () {
          return this.float !== 0 /* NONE */;
      };
      CSSParsedDeclaration.prototype.isInlineLevel = function () {
          return (contains(this.display, 4 /* INLINE */) ||
              contains(this.display, 33554432 /* INLINE_BLOCK */) ||
              contains(this.display, 268435456 /* INLINE_FLEX */) ||
              contains(this.display, 536870912 /* INLINE_GRID */) ||
              contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
              contains(this.display, 134217728 /* INLINE_TABLE */));
      };
      return CSSParsedDeclaration;
  }());
  var CSSParsedPseudoDeclaration = /** @class */ (function () {
      function CSSParsedPseudoDeclaration(context, declaration) {
          this.content = parse(context, content, declaration.content);
          this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration;
  }());
  var CSSParsedCounterDeclaration = /** @class */ (function () {
      function CSSParsedCounterDeclaration(context, declaration) {
          this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
          this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration;
  }());
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parse = function (context, descriptor, style) {
      var tokenizer = new Tokenizer();
      var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser$1(tokenizer.read());
      switch (descriptor.type) {
          case 2 /* IDENT_VALUE */:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0 /* VALUE */:
              return descriptor.parse(context, parser.parseComponentValue());
          case 1 /* LIST */:
              return descriptor.parse(context, parser.parseComponentValues());
          case 4 /* TOKEN_VALUE */:
              return parser.parseComponentValue();
          case 3 /* TYPE_VALUE */:
              switch (descriptor.format) {
                  case 'angle':
                      return angle.parse(context, parser.parseComponentValue());
                  case 'color':
                      return color$1.parse(context, parser.parseComponentValue());
                  case 'image':
                      return image.parse(context, parser.parseComponentValue());
                  case 'length':
                      var length_1 = parser.parseComponentValue();
                      return isLength(length_1) ? length_1 : ZERO_LENGTH;
                  case 'length-percentage':
                      var value_1 = parser.parseComponentValue();
                      return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                  case 'time':
                      return time.parse(context, parser.parseComponentValue());
              }
              break;
      }
  };

  var elementDebuggerAttribute = 'data-html2canvas-debug';
  var getElementDebugType = function (element) {
      var attribute = element.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
          case 'all':
              return 1 /* ALL */;
          case 'clone':
              return 2 /* CLONE */;
          case 'parse':
              return 3 /* PARSE */;
          case 'render':
              return 4 /* RENDER */;
          default:
              return 0 /* NONE */;
      }
  };
  var isDebugging = function (element, type) {
      var elementType = getElementDebugType(element);
      return elementType === 1 /* ALL */ || type === elementType;
  };

  var ElementContainer = /** @class */ (function () {
      function ElementContainer(context, element) {
          this.context = context;
          this.textNodes = [];
          this.elements = [];
          this.flags = 0;
          if (isDebugging(element, 3 /* PARSE */)) {
              debugger;
          }
          this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
          if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
                  element.style.animationDuration = '0s';
              }
              if (this.styles.transform !== null) {
                  // getBoundingClientRect takes transforms into account
                  element.style.transform = 'none';
              }
          }
          this.bounds = parseBounds(this.context, element);
          if (isDebugging(element, 4 /* RENDER */)) {
              this.flags |= 16 /* DEBUG_RENDER */;
          }
      }
      return ElementContainer;
  }());

  /*
   * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {
      lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
  }
  var decode = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1[base64.charCodeAt(i)];
          encoded2 = lookup$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  var slice16 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64 = function (base64, _byteLength) {
      var buffer = decode(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16(view16, (headerLength + view32[4]) / 2)
          : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$4 = 0; i$4 < chars.length; i$4++) {
      lookup[chars.charCodeAt(i$4)] = i$4;
  }

  var Prepend = 1;
  var CR = 2;
  var LF = 3;
  var Control = 4;
  var Extend = 5;
  var SpacingMark = 7;
  var L = 8;
  var V = 9;
  var T$1 = 10;
  var LV = 11;
  var LVT = 12;
  var ZWJ = 13;
  var Extended_Pictographic = 14;
  var RI = 15;
  var toCodePoints = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var UnicodeTrie = createTrieFromBase64(base64);
  var BREAK_NOT_ALLOWED = '×';
  var BREAK_ALLOWED = '÷';
  var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
  var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
      var prevIndex = index - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index - 1];
      var next = classTypes[index];
      // GB3 Do not break between a CR and LF
      if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
      }
      // GB4 Otherwise, break before and after controls.
      if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
      }
      // GB5
      if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
      }
      // Do not break Hangul syllable sequences.
      // GB6
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
      }
      // GB7
      if ((current === LV || current === V) && (next === V || next === T$1)) {
          return BREAK_NOT_ALLOWED;
      }
      // GB8
      if ((current === LVT || current === T$1) && next === T$1) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9 Do not break before extending characters or ZWJ.
      if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
      }
      // Do not break before SpacingMarks, or after Prepend characters.
      // GB9a
      if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9a
      if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
      }
      // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
      if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
              prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
          }
      }
      // GB12 Do not break within emoji flag sequences.
      // That is, do not break between regional indicator (RI) symbols
      // if there is an odd number of RI characters before the break point.
      if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
          }
      }
      return BREAK_ALLOWED;
  };
  var GraphemeBreaker = function (str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
          next: function () {
              if (index >= length) {
                  return { done: true, value: null };
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index < length &&
                  (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
                  var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
                  lastEnd = index;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };
  var splitGraphemes = function (str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
          if (bk.value) {
              graphemes.push(bk.value.slice());
          }
      }
      return graphemes;
  };

  var testRangeBounds = function (document) {
      var TEST_HEIGHT = 123;
      if (document.createRange) {
          var range = document.createRange();
          if (range.getBoundingClientRect) {
              var testElement = document.createElement('boundtest');
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = 'block';
              document.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                  return true;
              }
          }
      }
      return false;
  };
  var testIOSLineBreak = function (document) {
      var testElement = document.createElement('boundtest');
      testElement.style.width = '50px';
      testElement.style.display = 'block';
      testElement.style.fontSize = '12px';
      testElement.style.letterSpacing = '0px';
      testElement.style.wordSpacing = '0px';
      document.body.appendChild(testElement);
      var range = document.createRange();
      testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
      var offset = 0;
      var prev = {};
      // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
      var supports = textList.every(function (text, i) {
          range.setStart(node, offset);
          range.setEnd(node, offset + text.length);
          var rect = range.getBoundingClientRect();
          offset += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i === 0) {
              return true;
          }
          return boundAhead;
      });
      document.body.removeChild(testElement);
      return supports;
  };
  var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
  var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
  var testSVG = function (document) {
      var img = new Image();
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
      }
      catch (e) {
          return false;
      }
      return true;
  };
  var isGreenPixel = function (data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  };
  var testForeignObject = function (document) {
      var canvas = document.createElement('canvas');
      var size = 100;
      canvas.width = size;
      canvas.height = size;
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return Promise.reject(false);
      }
      ctx.fillStyle = 'rgb(0, 255, 0)';
      ctx.fillRect(0, 0, size, size);
      var img = new Image();
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size, size, 0, 0, img);
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, size, size);
      return loadSerializedSVG$1(svg)
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, size, size);
          var node = document.createElement('div');
          node.style.backgroundImage = "url(" + greenImageSrc + ")";
          node.style.height = size + "px";
          // Firefox 55 does not render inline <img /> tags
          return isGreenPixel(data)
              ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
              : Promise.reject(false);
      })
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          // Edge does not render background-images
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
      })
          .catch(function () { return false; });
  };
  var createForeignObjectSVG = function (width, height, x, y, node) {
      var xmlns = 'http://www.w3.org/2000/svg';
      var svg = document.createElementNS(xmlns, 'svg');
      var foreignObject = document.createElementNS(xmlns, 'foreignObject');
      svg.setAttributeNS(null, 'width', width.toString());
      svg.setAttributeNS(null, 'height', height.toString());
      foreignObject.setAttributeNS(null, 'width', '100%');
      foreignObject.setAttributeNS(null, 'height', '100%');
      foreignObject.setAttributeNS(null, 'x', x.toString());
      foreignObject.setAttributeNS(null, 'y', y.toString());
      foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
  };
  var loadSerializedSVG$1 = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () { return resolve(img); };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };
  var FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
          return value;
      },
      get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
          return value;
      },
      get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
              ? testForeignObject(document)
              : Promise.resolve(false);
          Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
          return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
          return value;
      },
      get SUPPORT_CORS_XHR() {
          var value = 'withCredentials' in new XMLHttpRequest();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
          return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
          Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
          return value;
      }
  };

  var TextBounds = /** @class */ (function () {
      function TextBounds(text, bounds) {
          this.text = text;
          this.bounds = bounds;
      }
      return TextBounds;
  }());
  var parseTextBounds = function (context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function (text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                  var clientRects = createRange(node, offset, text.length).getClientRects();
                  if (clientRects.length > 1) {
                      var subSegments = segmentGraphemes(text);
                      var subOffset_1 = 0;
                      subSegments.forEach(function (subSegment) {
                          textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                          subOffset_1 += subSegment.length;
                      });
                  }
                  else {
                      textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
                  }
              }
              else {
                  var replacementNode = node.splitText(text.length);
                  textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
                  node = replacementNode;
              }
          }
          else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node = node.splitText(text.length);
          }
          offset += text.length;
      });
      return textBounds;
  };
  var getWrapperBounds = function (context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
          var wrapper = ownerDocument.createElement('html2canvaswrapper');
          wrapper.appendChild(node.cloneNode(true));
          var parentNode = node.parentNode;
          if (parentNode) {
              parentNode.replaceChild(wrapper, node);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                  parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
          }
      }
      return Bounds.EMPTY;
  };
  var createRange = function (node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
          throw new Error('Node has no owner document');
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
  };
  var segmentGraphemes = function (value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return splitGraphemes(value);
  };
  var segmentWords = function (value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, {
              granularity: 'word'
          });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return breakWords(value, styles);
  };
  var breakText = function (value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
  };
  // https://drafts.csswg.org/css-text/#word-separator
  var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
  var breakWords = function (str, styles) {
      var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function () {
          if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = '';
              codePoints.forEach(function (codePoint) {
                  if (wordSeparators.indexOf(codePoint) === -1) {
                      word_1 += fromCodePoint$1(codePoint);
                  }
                  else {
                      if (word_1.length) {
                          words.push(word_1);
                      }
                      words.push(fromCodePoint$1(codePoint));
                      word_1 = '';
                  }
              });
              if (word_1.length) {
                  words.push(word_1);
              }
          }
      };
      while (!(bk = breaker.next()).done) {
          _loop_1();
      }
      return words;
  };

  var TextContainer = /** @class */ (function () {
      function TextContainer(context, node, styles) {
          this.text = transform(node.data, styles.textTransform);
          this.textBounds = parseTextBounds(context, this.text, styles, node);
      }
      return TextContainer;
  }());
  var transform = function (text, transform) {
      switch (transform) {
          case 1 /* LOWERCASE */:
              return text.toLowerCase();
          case 3 /* CAPITALIZE */:
              return text.replace(CAPITALIZE, capitalize);
          case 2 /* UPPERCASE */:
              return text.toUpperCase();
          default:
              return text;
      }
  };
  var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  var capitalize = function (m, p1, p2) {
      if (m.length > 0) {
          return p1 + p2.toUpperCase();
      }
      return m;
  };

  var ImageElementContainer = /** @class */ (function (_super) {
      __extends(ImageElementContainer, _super);
      function ImageElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          _this.src = img.currentSrc || img.src;
          _this.intrinsicWidth = img.naturalWidth;
          _this.intrinsicHeight = img.naturalHeight;
          _this.context.cache.addImage(_this.src);
          return _this;
      }
      return ImageElementContainer;
  }(ElementContainer));

  var CanvasElementContainer = /** @class */ (function (_super) {
      __extends(CanvasElementContainer, _super);
      function CanvasElementContainer(context, canvas) {
          var _this = _super.call(this, context, canvas) || this;
          _this.canvas = canvas;
          _this.intrinsicWidth = canvas.width;
          _this.intrinsicHeight = canvas.height;
          return _this;
      }
      return CanvasElementContainer;
  }(ElementContainer));

  var SVGElementContainer = /** @class */ (function (_super) {
      __extends(SVGElementContainer, _super);
      function SVGElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          var s = new XMLSerializer();
          var bounds = parseBounds(context, img);
          img.setAttribute('width', bounds.width + "px");
          img.setAttribute('height', bounds.height + "px");
          _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
          _this.intrinsicWidth = img.width.baseVal.value;
          _this.intrinsicHeight = img.height.baseVal.value;
          _this.context.cache.addImage(_this.svg);
          return _this;
      }
      return SVGElementContainer;
  }(ElementContainer));

  var LIElementContainer = /** @class */ (function (_super) {
      __extends(LIElementContainer, _super);
      function LIElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return LIElementContainer;
  }(ElementContainer));

  var OLElementContainer = /** @class */ (function (_super) {
      __extends(OLElementContainer, _super);
      function OLElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.start = element.start;
          _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
          return _this;
      }
      return OLElementContainer;
  }(ElementContainer));

  var CHECKBOX_BORDER_RADIUS = [
      {
          type: 15 /* DIMENSION_TOKEN */,
          flags: 0,
          unit: 'px',
          number: 3
      }
  ];
  var RADIO_BORDER_RADIUS = [
      {
          type: 16 /* PERCENTAGE_TOKEN */,
          flags: 0,
          number: 50
      }
  ];
  var reformatInputBounds = function (bounds) {
      if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      }
      else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
  };
  var getInputValue = function (node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
      return value.length === 0 ? node.placeholder || '' : value;
  };
  var CHECKBOX = 'checkbox';
  var RADIO = 'radio';
  var PASSWORD = 'password';
  var INPUT_COLOR = 0x2a2a2aff;
  var InputElementContainer = /** @class */ (function (_super) {
      __extends(InputElementContainer, _super);
      function InputElementContainer(context, input) {
          var _this = _super.call(this, context, input) || this;
          _this.type = input.type.toLowerCase();
          _this.checked = input.checked;
          _this.value = getInputValue(input);
          if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 0xdededeff;
              _this.styles.borderTopColor =
                  _this.styles.borderRightColor =
                      _this.styles.borderBottomColor =
                          _this.styles.borderLeftColor =
                              0xa5a5a5ff;
              _this.styles.borderTopWidth =
                  _this.styles.borderRightWidth =
                      _this.styles.borderBottomWidth =
                          _this.styles.borderLeftWidth =
                              1;
              _this.styles.borderTopStyle =
                  _this.styles.borderRightStyle =
                      _this.styles.borderBottomStyle =
                          _this.styles.borderLeftStyle =
                              1 /* SOLID */;
              _this.styles.backgroundClip = [0 /* BORDER_BOX */];
              _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
              _this.bounds = reformatInputBounds(_this.bounds);
          }
          switch (_this.type) {
              case CHECKBOX:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  CHECKBOX_BORDER_RADIUS;
                  break;
              case RADIO:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  RADIO_BORDER_RADIUS;
                  break;
          }
          return _this;
      }
      return InputElementContainer;
  }(ElementContainer));

  var SelectElementContainer = /** @class */ (function (_super) {
      __extends(SelectElementContainer, _super);
      function SelectElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          var option = element.options[element.selectedIndex || 0];
          _this.value = option ? option.text || '' : '';
          return _this;
      }
      return SelectElementContainer;
  }(ElementContainer));

  var TextareaElementContainer = /** @class */ (function (_super) {
      __extends(TextareaElementContainer, _super);
      function TextareaElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return TextareaElementContainer;
  }(ElementContainer));

  var IFrameElementContainer = /** @class */ (function (_super) {
      __extends(IFrameElementContainer, _super);
      function IFrameElementContainer(context, iframe) {
          var _this = _super.call(this, context, iframe) || this;
          _this.src = iframe.src;
          _this.width = parseInt(iframe.width, 10) || 0;
          _this.height = parseInt(iframe.height, 10) || 0;
          _this.backgroundColor = _this.styles.backgroundColor;
          try {
              if (iframe.contentWindow &&
                  iframe.contentWindow.document &&
                  iframe.contentWindow.document.documentElement) {
                  _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                  // http://www.w3.org/TR/css3-background/#special-backgrounds
                  var documentBackgroundColor = iframe.contentWindow.document.documentElement
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
                      : COLORS.TRANSPARENT;
                  var bodyBackgroundColor = iframe.contentWindow.document.body
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
                      : COLORS.TRANSPARENT;
                  _this.backgroundColor = isTransparent(documentBackgroundColor)
                      ? isTransparent(bodyBackgroundColor)
                          ? _this.styles.backgroundColor
                          : bodyBackgroundColor
                      : documentBackgroundColor;
              }
          }
          catch (e) { }
          return _this;
      }
      return IFrameElementContainer;
  }(ElementContainer));

  var LIST_OWNERS = ['OL', 'UL', 'MENU'];
  var parseNodeTree = function (context, node, parent, root) {
      for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          }
          else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                  childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
              }
              else {
                  var container = createContainer(context, childNode);
                  if (container.styles.isVisible()) {
                      if (createsRealStackingContext(childNode, container, root)) {
                          container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
                      }
                      else if (createsStackingContext(container.styles)) {
                          container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
                      }
                      if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                          container.flags |= 8 /* IS_LIST_OWNER */;
                      }
                      parent.elements.push(container);
                      childNode.slot;
                      if (childNode.shadowRoot) {
                          parseNodeTree(context, childNode.shadowRoot, container, root);
                      }
                      else if (!isTextareaElement(childNode) &&
                          !isSVGElement(childNode) &&
                          !isSelectElement(childNode)) {
                          parseNodeTree(context, childNode, container, root);
                      }
                  }
              }
          }
      }
  };
  var createContainer = function (context, element) {
      if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
      }
      if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
      }
      if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
      }
      if (isLIElement(element)) {
          return new LIElementContainer(context, element);
      }
      if (isOLElement(element)) {
          return new OLElementContainer(context, element);
      }
      if (isInputElement(element)) {
          return new InputElementContainer(context, element);
      }
      if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
      }
      if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
      }
      if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
      }
      return new ElementContainer(context, element);
  };
  var parseTree = function (context, element) {
      var container = createContainer(context, element);
      container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
      parseNodeTree(context, element, container, container);
      return container;
  };
  var createsRealStackingContext = function (node, container, root) {
      return (container.styles.isPositionedWithZIndex() ||
          container.styles.opacity < 1 ||
          container.styles.isTransformed() ||
          (isBodyElement(node) && root.styles.isTransparent()));
  };
  var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
  var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
  var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
  var isHTMLElementNode = function (node) {
      return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
  };
  var isSVGElementNode = function (element) {
      return typeof element.className === 'object';
  };
  var isLIElement = function (node) { return node.tagName === 'LI'; };
  var isOLElement = function (node) { return node.tagName === 'OL'; };
  var isInputElement = function (node) { return node.tagName === 'INPUT'; };
  var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
  var isSVGElement = function (node) { return node.tagName === 'svg'; };
  var isBodyElement = function (node) { return node.tagName === 'BODY'; };
  var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
  var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
  var isImageElement = function (node) { return node.tagName === 'IMG'; };
  var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
  var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
  var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
  var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
  var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
  var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

  var CounterState = /** @class */ (function () {
      function CounterState() {
          this.counters = {};
      }
      CounterState.prototype.getCounterValue = function (name) {
          var counter = this.counters[name];
          if (counter && counter.length) {
              return counter[counter.length - 1];
          }
          return 1;
      };
      CounterState.prototype.getCounterValues = function (name) {
          var counter = this.counters[name];
          return counter ? counter : [];
      };
      CounterState.prototype.pop = function (counters) {
          var _this = this;
          counters.forEach(function (counter) { return _this.counters[counter].pop(); });
      };
      CounterState.prototype.parse = function (style) {
          var _this = this;
          var counterIncrement = style.counterIncrement;
          var counterReset = style.counterReset;
          var canReset = true;
          if (counterIncrement !== null) {
              counterIncrement.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  if (counter && entry.increment !== 0) {
                      canReset = false;
                      if (!counter.length) {
                          counter.push(1);
                      }
                      counter[Math.max(0, counter.length - 1)] += entry.increment;
                  }
              });
          }
          var counterNames = [];
          if (canReset) {
              counterReset.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  counterNames.push(entry.counter);
                  if (!counter) {
                      counter = _this.counters[entry.counter] = [];
                  }
                  counter.push(entry.reset);
              });
          }
          return counterNames;
      };
      return CounterState;
  }());
  var ROMAN_UPPER = {
      integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
  };
  var ARMENIAN = {
      integers: [
          9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
          60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'Ք',
          'Փ',
          'Ւ',
          'Ց',
          'Ր',
          'Տ',
          'Վ',
          'Ս',
          'Ռ',
          'Ջ',
          'Պ',
          'Չ',
          'Ո',
          'Շ',
          'Ն',
          'Յ',
          'Մ',
          'Ճ',
          'Ղ',
          'Ձ',
          'Հ',
          'Կ',
          'Ծ',
          'Խ',
          'Լ',
          'Ի',
          'Ժ',
          'Թ',
          'Ը',
          'Է',
          'Զ',
          'Ե',
          'Դ',
          'Գ',
          'Բ',
          'Ա'
      ]
  };
  var HEBREW = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
          19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'י׳',
          'ט׳',
          'ח׳',
          'ז׳',
          'ו׳',
          'ה׳',
          'ד׳',
          'ג׳',
          'ב׳',
          'א׳',
          'ת',
          'ש',
          'ר',
          'ק',
          'צ',
          'פ',
          'ע',
          'ס',
          'נ',
          'מ',
          'ל',
          'כ',
          'יט',
          'יח',
          'יז',
          'טז',
          'טו',
          'י',
          'ט',
          'ח',
          'ז',
          'ו',
          'ה',
          'ד',
          'ג',
          'ב',
          'א'
      ]
  };
  var GEORGIAN = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
          80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'ჵ',
          'ჰ',
          'ჯ',
          'ჴ',
          'ხ',
          'ჭ',
          'წ',
          'ძ',
          'ც',
          'ჩ',
          'შ',
          'ყ',
          'ღ',
          'ქ',
          'ფ',
          'ჳ',
          'ტ',
          'ს',
          'რ',
          'ჟ',
          'პ',
          'ო',
          'ჲ',
          'ნ',
          'მ',
          'ლ',
          'კ',
          'ი',
          'თ',
          'ჱ',
          'ზ',
          'ვ',
          'ე',
          'დ',
          'გ',
          'ბ',
          'ა'
      ]
  };
  var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
      if (value < min || value > max) {
          return createCounterText(value, fallback, suffix.length > 0);
      }
      return (symbols.integers.reduce(function (string, integer, index) {
          while (value >= integer) {
              value -= integer;
              string += symbols.values[index];
          }
          return string;
      }, '') + suffix);
  };
  var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
      var string = '';
      do {
          if (!isNumeric) {
              value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
  };
  var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return ((value < 0 ? '-' : '') +
          (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
              return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) +
              suffix));
  };
  var createCounterStyleFromSymbols = function (value, symbols, suffix) {
      if (suffix === void 0) { suffix = '. '; }
      var codePointRangeLength = symbols.length;
      return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
  };
  var CJK_ZEROS = 1 << 0;
  var CJK_TEN_COEFFICIENTS = 1 << 1;
  var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
          return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
          return numbers[0] + string;
      }
      for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
              string = numbers[coefficient] + string;
          }
          else if (coefficient > 1 ||
              (coefficient === 1 && digit === 0) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
              (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
              string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
          }
          else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : '') + string;
  };
  var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
  var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
  var JAPANESE_NEGATIVE = 'マイナス';
  var KOREAN_NEGATIVE = '마이너스';
  var createCounterText = function (value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? '. ' : '';
      var cjkSuffix = appendSuffix ? '、' : '';
      var koreanSuffix = appendSuffix ? ', ' : '';
      var spaceSuffix = appendSuffix ? ' ' : '';
      switch (type) {
          case 0 /* DISC */:
              return '•' + spaceSuffix;
          case 1 /* CIRCLE */:
              return '◦' + spaceSuffix;
          case 2 /* SQUARE */:
              return '◾' + spaceSuffix;
          case 5 /* DECIMAL_LEADING_ZERO */:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
          case 4 /* CJK_DECIMAL */:
              return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
          case 6 /* LOWER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 7 /* UPPER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
          case 8 /* LOWER_GREEK */:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9 /* LOWER_ALPHA */:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10 /* UPPER_ALPHA */:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11 /* ARABIC_INDIC */:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12 /* ARMENIAN */:
          case 49 /* UPPER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
          case 35 /* LOWER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 13 /* BENGALI */:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14 /* CAMBODIAN */:
          case 30 /* KHMER */:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15 /* CJK_EARTHLY_BRANCH */:
              return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
          case 16 /* CJK_HEAVENLY_STEM */:
              return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
          case 17 /* CJK_IDEOGRAPHIC */:
          case 48 /* TRAD_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47 /* TRAD_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42 /* SIMP_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41 /* SIMP_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26 /* JAPANESE_INFORMAL */:
              return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25 /* JAPANESE_FORMAL */:
              return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31 /* KOREAN_HANGUL_FORMAL */:
              return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33 /* KOREAN_HANJA_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32 /* KOREAN_HANJA_FORMAL */:
              return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18 /* DEVANAGARI */:
              return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
          case 20 /* GEORGIAN */:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
          case 21 /* GUJARATI */:
              return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
          case 22 /* GURMUKHI */:
              return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
          case 22 /* HEBREW */:
              return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
          case 23 /* HIRAGANA */:
              return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
          case 24 /* HIRAGANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
          case 27 /* KANNADA */:
              return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
          case 28 /* KATAKANA */:
              return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
          case 29 /* KATAKANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
          case 34 /* LAO */:
              return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
          case 37 /* MONGOLIAN */:
              return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
          case 38 /* MYANMAR */:
              return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
          case 39 /* ORIYA */:
              return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
          case 40 /* PERSIAN */:
              return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
          case 43 /* TAMIL */:
              return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
          case 44 /* TELUGU */:
              return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
          case 45 /* THAI */:
              return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
          case 46 /* TIBETAN */:
              return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
          case 3 /* DECIMAL */:
          default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
  };

  var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
  var DocumentCloner = /** @class */ (function () {
      function DocumentCloner(context, element, options) {
          this.context = context;
          this.options = options;
          this.scrolledElements = [];
          this.referenceElement = element;
          this.counters = new CounterState();
          this.quoteDepth = 0;
          if (!element.ownerDocument) {
              throw new Error('Cloned element does not have an owner document');
          }
          this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
          var _this = this;
          var iframe = createIFrameContainer(ownerDocument, windowSize);
          if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
          }
          var scrollX = ownerDocument.defaultView.pageXOffset;
          var scrollY = ownerDocument.defaultView.pageYOffset;
          var cloneWindow = iframe.contentWindow;
          var documentClone = cloneWindow.document;
          /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
           if window url is about:blank, we can assign the url to current by writing onto the document
           */
          var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
              var onclone, referenceElement;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.scrolledElements.forEach(restoreNodeScroll);
                          if (cloneWindow) {
                              cloneWindow.scrollTo(windowSize.left, windowSize.top);
                              if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
                                  (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                                  this.context.logger.warn('Unable to restore scroll position for cloned document');
                                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                              }
                          }
                          onclone = this.options.onclone;
                          referenceElement = this.clonedReferenceElement;
                          if (typeof referenceElement === 'undefined') {
                              return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                          }
                          if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
                          return [4 /*yield*/, documentClone.fonts.ready];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
                          return [4 /*yield*/, imagesReady(documentClone)];
                      case 3:
                          _a.sent();
                          _a.label = 4;
                      case 4:
                          if (typeof onclone === 'function') {
                              return [2 /*return*/, Promise.resolve()
                                      .then(function () { return onclone(documentClone, referenceElement); })
                                      .then(function () { return iframe; })];
                          }
                          return [2 /*return*/, iframe];
                  }
              });
          }); });
          documentClone.open();
          documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
          // Chrome scrolls the parent document for some reason after the write to the cloned window???
          restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
          documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
          documentClone.close();
          return iframeLoad;
      };
      DocumentCloner.prototype.createElementClone = function (node) {
          if (isDebugging(node, 2 /* CLONE */)) {
              debugger;
          }
          if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
          }
          if (isVideoElement(node)) {
              return this.createVideoClone(node);
          }
          if (isStyleElement(node)) {
              return this.createStyleClone(node);
          }
          var clone = node.cloneNode(false);
          if (isImageElement(clone)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                  clone.src = node.currentSrc;
                  clone.srcset = '';
              }
              if (clone.loading === 'lazy') {
                  clone.loading = 'eager';
              }
          }
          if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
          }
          return clone;
      };
      DocumentCloner.prototype.createCustomElementClone = function (node) {
          var clone = document.createElement('html2canvascustomelement');
          copyCSSStyles(node.style, clone);
          return clone;
      };
      DocumentCloner.prototype.createStyleClone = function (node) {
          try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                  var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
                      if (rule && typeof rule.cssText === 'string') {
                          return css + rule.cssText;
                      }
                      return css;
                  }, '');
                  var style = node.cloneNode(false);
                  style.textContent = css;
                  return style;
              }
          }
          catch (e) {
              // accessing node.sheet.cssRules throws a DOMException
              this.context.logger.error('Unable to access cssRules property', e);
              if (e.name !== 'SecurityError') {
                  throw e;
              }
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.createCanvasClone = function (canvas) {
          var _a;
          if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement('img');
              try {
                  img.src = canvas.toDataURL();
                  return img;
              }
              catch (e) {
                  this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
          }
          var clonedCanvas = canvas.cloneNode(false);
          try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext('2d');
              var clonedCtx = clonedCanvas.getContext('2d');
              if (clonedCtx) {
                  if (!this.options.allowTaint && ctx) {
                      clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                  }
                  else {
                      var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
                      if (gl) {
                          var attribs = gl.getContextAttributes();
                          if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                              this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
                          }
                      }
                      clonedCtx.drawImage(canvas, 0, 0);
                  }
              }
              return clonedCanvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
          }
          return clonedCanvas;
      };
      DocumentCloner.prototype.createVideoClone = function (video) {
          var canvas = video.ownerDocument.createElement('canvas');
          canvas.width = video.offsetWidth;
          canvas.height = video.offsetHeight;
          var ctx = canvas.getContext('2d');
          try {
              if (ctx) {
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  if (!this.options.allowTaint) {
                      ctx.getImageData(0, 0, canvas.width, canvas.height);
                  }
              }
              return canvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
          }
          var blankCanvas = video.ownerDocument.createElement('canvas');
          blankCanvas.width = video.offsetWidth;
          blankCanvas.height = video.offsetHeight;
          return blankCanvas;
      };
      DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
          if (!isElementNode(child) ||
              (!isScriptElement(child) &&
                  !child.hasAttribute(IGNORE_ATTRIBUTE) &&
                  (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                  clone.appendChild(this.cloneNode(child, copyStyles));
              }
          }
      };
      DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
          var _this = this;
          for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
                  var assignedNodes = child.assignedNodes();
                  if (assignedNodes.length) {
                      assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
                  }
              }
              else {
                  this.appendChildNode(clone, child, copyStyles);
              }
          }
      };
      DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
          if (isTextNode(node)) {
              return document.createTextNode(node.data);
          }
          if (!node.ownerDocument) {
              return node.cloneNode(false);
          }
          var window = node.ownerDocument.defaultView;
          if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone = this.createElementClone(node);
              clone.style.transitionProperty = 'none';
              var style = window.getComputedStyle(node);
              var styleBefore = window.getComputedStyle(node, ':before');
              var styleAfter = window.getComputedStyle(node, ':after');
              if (this.referenceElement === node && isHTMLElementNode(clone)) {
                  this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                  createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node)) {
                  copyStyles = true;
              }
              if (!isVideoElement(node)) {
                  this.cloneChildNodes(node, clone, copyStyles);
              }
              if (before) {
                  clone.insertBefore(before, clone.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
              if (after) {
                  clone.appendChild(after);
              }
              this.counters.pop(counters);
              if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
                  copyStyles) {
                  copyCSSStyles(style, clone);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                  this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) &&
                  (isTextareaElement(clone) || isSelectElement(clone))) {
                  clone.value = node.value;
              }
              return clone;
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
          var _this = this;
          if (!style) {
              return;
          }
          var value = style.content;
          var document = clone.ownerDocument;
          if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
              return;
          }
          this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var declaration = new CSSParsedPseudoDeclaration(this.context, style);
          var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
          copyCSSStyles(style, anonymousReplacedElement);
          declaration.content.forEach(function (token) {
              if (token.type === 0 /* STRING_TOKEN */) {
                  anonymousReplacedElement.appendChild(document.createTextNode(token.value));
              }
              else if (token.type === 22 /* URL_TOKEN */) {
                  var img = document.createElement('img');
                  img.src = token.value;
                  img.style.opacity = '1';
                  anonymousReplacedElement.appendChild(img);
              }
              else if (token.type === 18 /* FUNCTION */) {
                  if (token.name === 'attr') {
                      var attr = token.values.filter(isIdentToken);
                      if (attr.length) {
                          anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
                      }
                  }
                  else if (token.name === 'counter') {
                      var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
                      if (counter && isIdentToken(counter)) {
                          var counterState = _this.counters.getCounterValue(counter.value);
                          var counterType = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
                      }
                  }
                  else if (token.name === 'counters') {
                      var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                      if (counter && isIdentToken(counter)) {
                          var counterStates = _this.counters.getCounterValues(counter.value);
                          var counterType_1 = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
                          var text = counterStates
                              .map(function (value) { return createCounterText(value, counterType_1, false); })
                              .join(separator);
                          anonymousReplacedElement.appendChild(document.createTextNode(text));
                      }
                  }
                  else ;
              }
              else if (token.type === 20 /* IDENT_TOKEN */) {
                  switch (token.value) {
                      case 'open-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                          break;
                      case 'close-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                          break;
                      default:
                          // safari doesn't parse string tokens correctly because of lack of quotes
                          anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                  }
              }
          });
          anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          var newClassName = pseudoElt === PseudoElementType.BEFORE
              ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
              : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
          }
          else {
              clone.className += newClassName;
          }
          return anonymousReplacedElement;
      };
      DocumentCloner.destroy = function (container) {
          if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
          }
          return false;
      };
      return DocumentCloner;
  }());
  var PseudoElementType;
  (function (PseudoElementType) {
      PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
      PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
  })(PseudoElementType || (PseudoElementType = {}));
  var createIFrameContainer = function (ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement('iframe');
      cloneIframeContainer.className = 'html2canvas-container';
      cloneIframeContainer.style.visibility = 'hidden';
      cloneIframeContainer.style.position = 'fixed';
      cloneIframeContainer.style.left = '-10000px';
      cloneIframeContainer.style.top = '0px';
      cloneIframeContainer.style.border = '0';
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
  };
  var imageReady = function (img) {
      return new Promise(function (resolve) {
          if (img.complete) {
              resolve();
              return;
          }
          if (!img.src) {
              resolve();
              return;
          }
          img.onload = resolve;
          img.onerror = resolve;
      });
  };
  var imagesReady = function (document) {
      return Promise.all([].slice.call(document.images, 0).map(imageReady));
  };
  var iframeLoader = function (iframe) {
      return new Promise(function (resolve, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
              return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function () {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function () {
                  if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                      clearInterval(interval);
                      resolve(iframe);
                  }
              }, 50);
          };
      });
  };
  var ignoredStyleProperties = [
      'all',
      'd',
      'content' // Safari shows pseudoelements if content is set
  ];
  var copyCSSStyles = function (style, target) {
      // Edge does not provide value for cssText
      for (var i = style.length - 1; i >= 0; i--) {
          var property = style.item(i);
          if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
          }
      }
      return target;
  };
  var serializeDoctype = function (doctype) {
      var str = '';
      if (doctype) {
          str += '<!DOCTYPE ';
          if (doctype.name) {
              str += doctype.name;
          }
          if (doctype.internalSubset) {
              str += doctype.internalSubset;
          }
          if (doctype.publicId) {
              str += "\"" + doctype.publicId + "\"";
          }
          if (doctype.systemId) {
              str += "\"" + doctype.systemId + "\"";
          }
          str += '>';
      }
      return str;
  };
  var restoreOwnerScroll = function (ownerDocument, x, y) {
      if (ownerDocument &&
          ownerDocument.defaultView &&
          (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x, y);
      }
  };
  var restoreNodeScroll = function (_a) {
      var element = _a[0], x = _a[1], y = _a[2];
      element.scrollLeft = x;
      element.scrollTop = y;
  };
  var PSEUDO_BEFORE = ':before';
  var PSEUDO_AFTER = ':after';
  var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
  var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
  var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
  var createPseudoHideStyles = function (body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  };
  var createStyles = function (body, styles) {
      var document = body.ownerDocument;
      if (document) {
          var style = document.createElement('style');
          style.textContent = styles;
          body.appendChild(style);
      }
  };

  var CacheStorage = /** @class */ (function () {
      function CacheStorage() {
      }
      CacheStorage.getOrigin = function (url) {
          var link = CacheStorage._link;
          if (!link) {
              return 'about:blank';
          }
          link.href = url;
          link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
          return link.protocol + link.hostname + link.port;
      };
      CacheStorage.isSameOrigin = function (src) {
          return CacheStorage.getOrigin(src) === CacheStorage._origin;
      };
      CacheStorage.setContext = function (window) {
          CacheStorage._link = window.document.createElement('a');
          CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
      };
      CacheStorage._origin = 'about:blank';
      return CacheStorage;
  }());
  var Cache = /** @class */ (function () {
      function Cache(context, _options) {
          this.context = context;
          this._options = _options;
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this._cache = {};
      }
      Cache.prototype.addImage = function (src) {
          var result = Promise.resolve();
          if (this.has(src)) {
              return result;
          }
          if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function () {
                  // prevent unhandled rejection
              });
              return result;
          }
          return result;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Cache.prototype.match = function (src) {
          return this._cache[src];
      };
      Cache.prototype.loadImage = function (key) {
          return __awaiter(this, void 0, void 0, function () {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          isSameOrigin = CacheStorage.isSameOrigin(key);
                          useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                          useProxy = !isInlineImage(key) &&
                              !isSameOrigin &&
                              !isBlobImage(key) &&
                              typeof this._options.proxy === 'string' &&
                              FEATURES.SUPPORT_CORS_XHR &&
                              !useCORS;
                          if (!isSameOrigin &&
                              this._options.allowTaint === false &&
                              !isInlineImage(key) &&
                              !isBlobImage(key) &&
                              !useProxy &&
                              !useCORS) {
                              return [2 /*return*/];
                          }
                          src = key;
                          if (!useProxy) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.proxy(src)];
                      case 1:
                          src = _a.sent();
                          _a.label = 2;
                      case 2:
                          this.context.logger.debug("Added image " + key.substring(0, 256));
                          return [4 /*yield*/, new Promise(function (resolve, reject) {
                                  var img = new Image();
                                  img.onload = function () { return resolve(img); };
                                  img.onerror = reject;
                                  //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                                  if (isInlineBase64Image(src) || useCORS) {
                                      img.crossOrigin = 'anonymous';
                                  }
                                  img.src = src;
                                  if (img.complete === true) {
                                      // Inline XML images may fail to parse, throwing an Error later on
                                      setTimeout(function () { return resolve(img); }, 500);
                                  }
                                  if (_this._options.imageTimeout > 0) {
                                      setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
                                  }
                              })];
                      case 3: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      Cache.prototype.has = function (key) {
          return typeof this._cache[key] !== 'undefined';
      };
      Cache.prototype.keys = function () {
          return Promise.resolve(Object.keys(this._cache));
      };
      Cache.prototype.proxy = function (src) {
          var _this = this;
          var proxy = this._options.proxy;
          if (!proxy) {
              throw new Error('No proxy defined');
          }
          var key = src.substring(0, 256);
          return new Promise(function (resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
              var xhr = new XMLHttpRequest();
              xhr.onload = function () {
                  if (xhr.status === 200) {
                      if (responseType === 'text') {
                          resolve(xhr.response);
                      }
                      else {
                          var reader_1 = new FileReader();
                          reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
                          reader_1.addEventListener('error', function (e) { return reject(e); }, false);
                          reader_1.readAsDataURL(xhr.response);
                      }
                  }
                  else {
                      reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                  }
              };
              xhr.onerror = reject;
              var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
              xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
                  xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                  var timeout_1 = _this._options.imageTimeout;
                  xhr.timeout = timeout_1;
                  xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
              }
              xhr.send();
          });
      };
      return Cache;
  }());
  var INLINE_SVG = /^data:image\/svg\+xml/i;
  var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  var INLINE_IMG = /^data:image\/.*/i;
  var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
  var isInlineImage = function (src) { return INLINE_IMG.test(src); };
  var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
  var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
  var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

  var Vector = /** @class */ (function () {
      function Vector(x, y) {
          this.type = 0 /* VECTOR */;
          this.x = x;
          this.y = y;
      }
      Vector.prototype.add = function (deltaX, deltaY) {
          return new Vector(this.x + deltaX, this.y + deltaY);
      };
      return Vector;
  }());

  var lerp = function (a, b, t) {
      return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
  };
  var BezierCurve = /** @class */ (function () {
      function BezierCurve(start, startControl, endControl, end) {
          this.type = 1 /* BEZIER_CURVE */;
          this.start = start;
          this.startControl = startControl;
          this.endControl = endControl;
          this.end = end;
      }
      BezierCurve.prototype.subdivide = function (t, firstHalf) {
          var ab = lerp(this.start, this.startControl, t);
          var bc = lerp(this.startControl, this.endControl, t);
          var cd = lerp(this.endControl, this.end, t);
          var abbc = lerp(ab, bc, t);
          var bccd = lerp(bc, cd, t);
          var dest = lerp(abbc, bccd, t);
          return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
      };
      BezierCurve.prototype.add = function (deltaX, deltaY) {
          return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve.prototype.reverse = function () {
          return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve;
  }());
  var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

  var BoundCurves = /** @class */ (function () {
      function BoundCurves(element) {
          var styles = element.styles;
          var bounds = element.bounds;
          var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
          var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
          var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
          var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
          var factors = [];
          factors.push((tlh + trh) / bounds.width);
          factors.push((blh + brh) / bounds.width);
          factors.push((tlv + blv) / bounds.height);
          factors.push((trv + brv) / bounds.height);
          var maxFactor = Math.max.apply(Math, factors);
          if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
          }
          var topWidth = bounds.width - trh;
          var rightHeight = bounds.height - brv;
          var bottomWidth = bounds.width - brh;
          var leftHeight = bounds.height - blv;
          var borderTopWidth = styles.borderTopWidth;
          var borderRightWidth = styles.borderRightWidth;
          var borderBottomWidth = styles.borderBottomWidth;
          var borderLeftWidth = styles.borderLeftWidth;
          var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
          var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
          var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
          var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
          this.topLeftBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
          this.topRightBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
          this.bottomRightBorderDoubleOuterBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.bottomLeftBorderDoubleOuterBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.topLeftBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.topRightBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.bottomRightBorderDoubleInnerBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.bottomLeftBorderDoubleInnerBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.topLeftBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
          this.topRightBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
          this.bottomRightBorderStroke =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.bottomLeftBorderStroke =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.topLeftBorderBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
                  : new Vector(bounds.left, bounds.top);
          this.topRightBorderBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top);
          this.bottomRightBorderBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
          this.bottomLeftBorderBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left, bounds.top + bounds.height);
          this.topLeftPaddingBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
          this.topRightPaddingBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
          this.bottomRightPaddingBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
          this.bottomLeftPaddingBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
          this.topLeftContentBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
          this.topRightContentBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
          this.bottomRightContentBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
          this.bottomLeftContentBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
      }
      return BoundCurves;
  }());
  var CORNER;
  (function (CORNER) {
      CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  })(CORNER || (CORNER = {}));
  var getCurvePoints = function (x, y, r1, r2, position) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa; // control point offset horizontal
      var oy = r2 * kappa; // control point offset vertical
      var xm = x + r1; // x-middle
      var ym = y + r2; // y-middle
      switch (position) {
          case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
          case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
          case CORNER.BOTTOM_LEFT:
          default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
      }
  };
  var calculateBorderBoxPath = function (curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  };
  var calculateContentBoxPath = function (curves) {
      return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
      ];
  };
  var calculatePaddingBoxPath = function (curves) {
      return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
      ];
  };

  var TransformEffect = /** @class */ (function () {
      function TransformEffect(offsetX, offsetY, matrix) {
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          this.matrix = matrix;
          this.type = 0 /* TRANSFORM */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return TransformEffect;
  }());
  var ClipEffect = /** @class */ (function () {
      function ClipEffect(path, target) {
          this.path = path;
          this.target = target;
          this.type = 1 /* CLIP */;
      }
      return ClipEffect;
  }());
  var OpacityEffect = /** @class */ (function () {
      function OpacityEffect(opacity) {
          this.opacity = opacity;
          this.type = 2 /* OPACITY */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return OpacityEffect;
  }());
  var isTransformEffect = function (effect) {
      return effect.type === 0 /* TRANSFORM */;
  };
  var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
  var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

  var equalPath = function (a, b) {
      if (a.length === b.length) {
          return a.some(function (v, i) { return v === b[i]; });
      }
      return false;
  };
  var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function (point, index) {
          switch (index) {
              case 0:
                  return point.add(deltaX, deltaY);
              case 1:
                  return point.add(deltaX + deltaW, deltaY);
              case 2:
                  return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                  return point.add(deltaX, deltaY + deltaH);
          }
          return point;
      });
  };

  var StackingContext = /** @class */ (function () {
      function StackingContext(container) {
          this.element = container;
          this.inlineLevel = [];
          this.nonInlineLevel = [];
          this.negativeZIndex = [];
          this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
          this.positiveZIndex = [];
          this.nonPositionedFloats = [];
          this.nonPositionedInlineLevel = [];
      }
      return StackingContext;
  }());
  var ElementPaint = /** @class */ (function () {
      function ElementPaint(container, parent) {
          this.container = container;
          this.parent = parent;
          this.effects = [];
          this.curves = new BoundCurves(this.container);
          if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
          }
          if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
          }
          if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox)) {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
              }
              else {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
                  this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
              }
          }
      }
      ElementPaint.prototype.getEffects = function (target) {
          var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
          var parent = this.parent;
          var effects = this.effects.slice(0);
          while (parent) {
              var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
              if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
                  effects.unshift.apply(effects, croplessEffects);
                  inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
                  if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
                      var borderBox = calculateBorderBoxPath(parent.curves);
                      var paddingBox = calculatePaddingBoxPath(parent.curves);
                      if (!equalPath(borderBox, paddingBox)) {
                          effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                      }
                  }
              }
              else {
                  effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
          }
          return effects.filter(function (effect) { return contains(effect.target, target); });
      };
      return ElementPaint;
  }());
  var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function (child) {
          var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
          var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
          var paintContainer = new ElementPaint(child, parent);
          if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
              listItems.push(paintContainer);
          }
          var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                  var order_1 = child.styles.zIndex.order;
                  if (order_1 < 0) {
                      var index_1 = 0;
                      parentStack.negativeZIndex.some(function (current, i) {
                          if (order_1 > current.element.container.styles.zIndex.order) {
                              index_1 = i;
                              return false;
                          }
                          else if (index_1 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.negativeZIndex.splice(index_1, 0, stack);
                  }
                  else if (order_1 > 0) {
                      var index_2 = 0;
                      parentStack.positiveZIndex.some(function (current, i) {
                          if (order_1 >= current.element.container.styles.zIndex.order) {
                              index_2 = i + 1;
                              return false;
                          }
                          else if (index_2 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.positiveZIndex.splice(index_2, 0, stack);
                  }
                  else {
                      parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                  }
              }
              else {
                  if (child.styles.isFloating()) {
                      parentStack.nonPositionedFloats.push(stack);
                  }
                  else {
                      parentStack.nonPositionedInlineLevel.push(stack);
                  }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          }
          else {
              if (child.styles.isInlineLevel()) {
                  stackingContext.inlineLevel.push(paintContainer);
              }
              else {
                  stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
              processListItems(child, listOwnerItems);
          }
      });
  };
  var processListItems = function (owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i = 0; i < elements.length; i++) {
          var item = elements[i];
          if (item.container instanceof LIElementContainer &&
              typeof item.container.value === 'number' &&
              item.container.value !== 0) {
              numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
      }
  };
  var parseStackingContexts = function (container) {
      var paintContainer = new ElementPaint(container, null);
      var root = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root, root, listItems);
      processListItems(paintContainer.container, listItems);
      return root;
  };

  var parsePathForBorder = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderDoubleOuter = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
  };
  var parsePathForBorderDoubleInner = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderStroke = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
  };
  var createStrokePathFromCurves = function (outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      return path;
  };
  var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
          path.push(inner2.subdivide(0.5, true).reverse());
      }
      else {
          path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
          path.push(inner1.subdivide(0.5, false).reverse());
      }
      else {
          path.push(inner1);
      }
      return path;
  };

  var paddingBox = function (element) {
      var bounds = element.bounds;
      var styles = element.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  };
  var contentBox = function (element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
  };

  var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
      if (backgroundOrigin === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundOrigin === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundPaintingArea = function (backgroundClip, element) {
      if (backgroundClip === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundClip === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundRendering = function (container, index, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  };
  var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
  var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
  var calculateBackgroundSize = function (size, _a, bounds) {
      var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
      var first = size[0], second = size[1];
      if (!first) {
          return [0, 0];
      }
      if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
                  ? [bounds.width, bounds.width / intrinsicProportion]
                  : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      // If the background-size is auto or auto auto:
      if (isAuto(first) && (!second || isAuto(second))) {
          // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
          }
          // If the image has no intrinsic dimensions and has no intrinsic proportions,
          // it's rendered at the size of the background positioning area.
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
          }
          // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
          // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
          // The other dimension is computed using the specified dimension and the intrinsic proportions.
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth
                  ? intrinsicWidth
                  : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight
                  ? intrinsicHeight
                  : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
          }
          // If the image has only one intrinsic dimension but has no intrinsic proportions,
          // it's rendered using the specified dimension and the other dimension of the background positioning area.
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
      }
      // If the image has intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
      if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
          }
          else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
          }
          else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
      }
      // If the image has no intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
      // if there is one. If there is no such intrinsic dimension,
      // it becomes the corresponding dimension of the background positioning area.
      var width = null;
      var height = null;
      if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
      }
      else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
          height =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (width / intrinsicWidth) * intrinsicHeight
                  : bounds.height;
      }
      if (height !== null && isAuto(first)) {
          width =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (height / intrinsicHeight) * intrinsicWidth
                  : bounds.width;
      }
      if (width !== null && height !== null) {
          return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
  };
  var getBackgroundValueForIndex = function (values, index) {
      var value = values[index];
      if (typeof value === 'undefined') {
          return values[0];
      }
      return value;
  };
  var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
      var x = _a[0], y = _a[1];
      var width = _b[0], height = _b[1];
      switch (repeat) {
          case 2 /* REPEAT_X */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
              ];
          case 3 /* REPEAT_Y */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
              ];
          case 1 /* NO_REPEAT */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
              ];
          default:
              return [
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
              ];
      }
  };

  var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

  var SAMPLE_TEXT = 'Hidden Text';
  var FontMetrics = /** @class */ (function () {
      function FontMetrics(document) {
          this._data = {};
          this._document = document;
      }
      FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
          var container = this._document.createElement('div');
          var img = this._document.createElement('img');
          var span = this._document.createElement('span');
          var body = this._document.body;
          container.style.visibility = 'hidden';
          container.style.fontFamily = fontFamily;
          container.style.fontSize = fontSize;
          container.style.margin = '0';
          container.style.padding = '0';
          container.style.whiteSpace = 'nowrap';
          body.appendChild(container);
          img.src = SMALL_IMAGE;
          img.width = 1;
          img.height = 1;
          img.style.margin = '0';
          img.style.padding = '0';
          img.style.verticalAlign = 'baseline';
          span.style.fontFamily = fontFamily;
          span.style.fontSize = fontSize;
          span.style.margin = '0';
          span.style.padding = '0';
          span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.appendChild(span);
          container.appendChild(img);
          var baseline = img.offsetTop - span.offsetTop + 2;
          container.removeChild(span);
          container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.style.lineHeight = 'normal';
          img.style.verticalAlign = 'super';
          var middle = img.offsetTop - container.offsetTop + 2;
          body.removeChild(container);
          return { baseline: baseline, middle: middle };
      };
      FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
          var key = fontFamily + " " + fontSize;
          if (typeof this._data[key] === 'undefined') {
              this._data[key] = this.parseMetrics(fontFamily, fontSize);
          }
          return this._data[key];
      };
      return FontMetrics;
  }());

  var Renderer = /** @class */ (function () {
      function Renderer(context, options) {
          this.context = context;
          this.options = options;
      }
      return Renderer;
  }());

  var MASK_OFFSET = 10000;
  var CanvasRenderer = /** @class */ (function (_super) {
      __extends(CanvasRenderer, _super);
      function CanvasRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this._activeEffects = [];
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
          }
          _this.fontMetrics = new FontMetrics(document);
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.ctx.textBaseline = 'bottom';
          _this._activeEffects = [];
          _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
          return _this;
      }
      CanvasRenderer.prototype.applyEffects = function (effects) {
          var _this = this;
          while (this._activeEffects.length) {
              this.popEffect();
          }
          effects.forEach(function (effect) { return _this.applyEffect(effect); });
      };
      CanvasRenderer.prototype.applyEffect = function (effect) {
          this.ctx.save();
          if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
          }
          if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
          }
          if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
          }
          this._activeEffects.push(effect);
      };
      CanvasRenderer.prototype.popEffect = function () {
          this._activeEffects.pop();
          this.ctx.restore();
      };
      CanvasRenderer.prototype.renderStack = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var styles;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          styles = stack.element.container.styles;
                          if (!styles.isVisible()) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderStackContent(stack)];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNode = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
                      case 1:
                          _a.sent();
                          return [4 /*yield*/, this.renderNodeContent(paint)];
                      case 2:
                          _a.sent();
                          _a.label = 3;
                      case 3: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
          var _this = this;
          if (letterSpacing === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
          }
          else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function (left, letter) {
                  _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                  return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
          }
      };
      CanvasRenderer.prototype.createFontStyle = function (styles) {
          var fontVariant = styles.fontVariant
              .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
              .join('');
          var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
          var fontSize = isDimensionToken(styles.fontSize)
              ? "" + styles.fontSize.number + styles.fontSize.unit
              : styles.fontSize.number + "px";
          return [
              [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
              fontFamily,
              fontSize
          ];
      };
      CanvasRenderer.prototype.renderTextNode = function (text, styles) {
          return __awaiter(this, void 0, void 0, function () {
              var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
              var _this = this;
              return __generator(this, function (_c) {
                  _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
                  this.ctx.font = font;
                  this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
                  this.ctx.textAlign = 'left';
                  this.ctx.textBaseline = 'alphabetic';
                  _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
                  paintOrder = styles.paintOrder;
                  text.textBounds.forEach(function (text) {
                      paintOrder.forEach(function (paintOrderLayer) {
                          switch (paintOrderLayer) {
                              case 0 /* FILL */:
                                  _this.ctx.fillStyle = asString(styles.color);
                                  _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                  var textShadows = styles.textShadow;
                                  if (textShadows.length && text.text.trim().length) {
                                      textShadows
                                          .slice(0)
                                          .reverse()
                                          .forEach(function (textShadow) {
                                          _this.ctx.shadowColor = asString(textShadow.color);
                                          _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                                          _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                                          _this.ctx.shadowBlur = textShadow.blur.number;
                                          _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                      });
                                      _this.ctx.shadowColor = '';
                                      _this.ctx.shadowOffsetX = 0;
                                      _this.ctx.shadowOffsetY = 0;
                                      _this.ctx.shadowBlur = 0;
                                  }
                                  if (styles.textDecorationLine.length) {
                                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                                      styles.textDecorationLine.forEach(function (textDecorationLine) {
                                          switch (textDecorationLine) {
                                              case 1 /* UNDERLINE */:
                                                  // Draws a line at the baseline of the font
                                                  // TODO As some browsers display the line as more than 1px if the font-size is big,
                                                  // need to take that into account both in position and size
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                                                  break;
                                              case 2 /* OVERLINE */:
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                                                  break;
                                              case 3 /* LINE_THROUGH */:
                                                  // TODO try and find exact position for line-through
                                                  _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                                                  break;
                                          }
                                      });
                                  }
                                  break;
                              case 1 /* STROKE */:
                                  if (styles.webkitTextStrokeWidth && text.text.trim().length) {
                                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                      _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
                                      _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
                                  }
                                  _this.ctx.strokeStyle = '';
                                  _this.ctx.lineWidth = 0;
                                  _this.ctx.lineJoin = 'miter';
                                  break;
                          }
                      });
                  });
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
          if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
          }
      };
      CanvasRenderer.prototype.renderNodeContent = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
              return __generator(this, function (_c) {
                  switch (_c.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(4 /* CONTENT */));
                          container = paint.container;
                          curves = paint.curves;
                          styles = container.styles;
                          _i = 0, _a = container.textNodes;
                          _c.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderTextNode(child, styles)];
                      case 2:
                          _c.sent();
                          _c.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4:
                          if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
                          _c.label = 5;
                      case 5:
                          _c.trys.push([5, 7, , 8]);
                          return [4 /*yield*/, this.context.cache.match(container.src)];
                      case 6:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 8];
                      case 7:
                          _c.sent();
                          this.context.logger.error("Error loading image " + container.src);
                          return [3 /*break*/, 8];
                      case 8:
                          if (container instanceof CanvasElementContainer) {
                              this.renderReplacedElement(container, curves, container.canvas);
                          }
                          if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
                          _c.label = 9;
                      case 9:
                          _c.trys.push([9, 11, , 12]);
                          return [4 /*yield*/, this.context.cache.match(container.svg)];
                      case 10:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 12];
                      case 11:
                          _c.sent();
                          this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                          return [3 /*break*/, 12];
                      case 12:
                          if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
                          iframeRenderer = new CanvasRenderer(this.context, {
                              scale: this.options.scale,
                              backgroundColor: container.backgroundColor,
                              x: 0,
                              y: 0,
                              width: container.width,
                              height: container.height
                          });
                          return [4 /*yield*/, iframeRenderer.render(container.tree)];
                      case 13:
                          canvas = _c.sent();
                          if (container.width && container.height) {
                              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                          }
                          _c.label = 14;
                      case 14:
                          if (container instanceof InputElementContainer) {
                              size = Math.min(container.bounds.width, container.bounds.height);
                              if (container.type === CHECKBOX) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.path([
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                                          new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                                          new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                                          new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                                          new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                                          new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                                      ]);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                              else if (container.type === RADIO) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.ctx.beginPath();
                                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                          }
                          if (isTextInputElement(container) && container.value.length) {
                              _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
                              baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                              bounds = contentBox(container);
                              x = 0;
                              switch (container.styles.textAlign) {
                                  case 1 /* CENTER */:
                                      x += bounds.width / 2;
                                      break;
                                  case 2 /* RIGHT */:
                                      x += bounds.width;
                                      break;
                              }
                              textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                              this.ctx.save();
                              this.path([
                                  new Vector(bounds.left, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                                  new Vector(bounds.left, bounds.top + bounds.height)
                              ]);
                              this.ctx.clip();
                              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                              this.ctx.restore();
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = 'left';
                          }
                          if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
                          if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
                          img = container.styles.listStyleImage;
                          if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
                          image = void 0;
                          url = img.url;
                          _c.label = 15;
                      case 15:
                          _c.trys.push([15, 17, , 18]);
                          return [4 /*yield*/, this.context.cache.match(url)];
                      case 16:
                          image = _c.sent();
                          this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
                          return [3 /*break*/, 18];
                      case 17:
                          _c.sent();
                          this.context.logger.error("Error loading list-style-image " + url);
                          return [3 /*break*/, 18];
                      case 18: return [3 /*break*/, 20];
                      case 19:
                          if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
                              fontFamily = this.createFontStyle(styles)[0];
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'middle';
                              this.ctx.textAlign = 'right';
                              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                              this.ctx.textBaseline = 'bottom';
                              this.ctx.textAlign = 'left';
                          }
                          _c.label = 20;
                      case 20: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderStackContent = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function (_p) {
                  switch (_p.label) {
                      case 0:
                          if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
                      case 1:
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          _p.sent();
                          _i = 0, _a = stack.negativeZIndex;
                          _p.label = 2;
                      case 2:
                          if (!(_i < _a.length)) return [3 /*break*/, 5];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 3:
                          _p.sent();
                          _p.label = 4;
                      case 4:
                          _i++;
                          return [3 /*break*/, 2];
                      case 5: 
                      // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                      return [4 /*yield*/, this.renderNodeContent(stack.element)];
                      case 6:
                          // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                          _p.sent();
                          _b = 0, _c = stack.nonInlineLevel;
                          _p.label = 7;
                      case 7:
                          if (!(_b < _c.length)) return [3 /*break*/, 10];
                          child = _c[_b];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 8:
                          _p.sent();
                          _p.label = 9;
                      case 9:
                          _b++;
                          return [3 /*break*/, 7];
                      case 10:
                          _d = 0, _e = stack.nonPositionedFloats;
                          _p.label = 11;
                      case 11:
                          if (!(_d < _e.length)) return [3 /*break*/, 14];
                          child = _e[_d];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 12:
                          _p.sent();
                          _p.label = 13;
                      case 13:
                          _d++;
                          return [3 /*break*/, 11];
                      case 14:
                          _f = 0, _g = stack.nonPositionedInlineLevel;
                          _p.label = 15;
                      case 15:
                          if (!(_f < _g.length)) return [3 /*break*/, 18];
                          child = _g[_f];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 16:
                          _p.sent();
                          _p.label = 17;
                      case 17:
                          _f++;
                          return [3 /*break*/, 15];
                      case 18:
                          _h = 0, _j = stack.inlineLevel;
                          _p.label = 19;
                      case 19:
                          if (!(_h < _j.length)) return [3 /*break*/, 22];
                          child = _j[_h];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 20:
                          _p.sent();
                          _p.label = 21;
                      case 21:
                          _h++;
                          return [3 /*break*/, 19];
                      case 22:
                          _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                          _p.label = 23;
                      case 23:
                          if (!(_k < _l.length)) return [3 /*break*/, 26];
                          child = _l[_k];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 24:
                          _p.sent();
                          _p.label = 25;
                      case 25:
                          _k++;
                          return [3 /*break*/, 23];
                      case 26:
                          _m = 0, _o = stack.positiveZIndex;
                          _p.label = 27;
                      case 27:
                          if (!(_m < _o.length)) return [3 /*break*/, 30];
                          child = _o[_m];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 28:
                          _p.sent();
                          _p.label = 29;
                      case 29:
                          _m++;
                          return [3 /*break*/, 27];
                      case 30: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.mask = function (paths) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, 0);
          this.ctx.lineTo(this.canvas.width, 0);
          this.ctx.lineTo(this.canvas.width, this.canvas.height);
          this.ctx.lineTo(0, this.canvas.height);
          this.ctx.lineTo(0, 0);
          this.formatPath(paths.slice(0).reverse());
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.path = function (paths) {
          this.ctx.beginPath();
          this.formatPath(paths);
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.formatPath = function (paths) {
          var _this = this;
          paths.forEach(function (point, index) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                  _this.ctx.moveTo(start.x, start.y);
              }
              else {
                  _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                  _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
          });
      };
      CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
          this.path(path);
          this.ctx.fillStyle = pattern;
          this.ctx.translate(offsetX, offsetY);
          this.ctx.fill();
          this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer.prototype.resizeImage = function (image, width, height) {
          var _a;
          if (image.width === width && image.height === height) {
              return image;
          }
          var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
          var canvas = ownerDocument.createElement('canvas');
          canvas.width = Math.max(1, width);
          canvas.height = Math.max(1, height);
          var ctx = canvas.getContext('2d');
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
          return canvas;
      };
      CanvasRenderer.prototype.renderBackgroundImage = function (container) {
          return __awaiter(this, void 0, void 0, function () {
              var index, _loop_1, this_1, _i, _a, backgroundImage;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          index = container.styles.backgroundImage.length - 1;
                          _loop_1 = function (backgroundImage) {
                              var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
                              return __generator(this, function (_h) {
                                  switch (_h.label) {
                                      case 0:
                                          if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
                                          image = void 0;
                                          url = backgroundImage.url;
                                          _h.label = 1;
                                      case 1:
                                          _h.trys.push([1, 3, , 4]);
                                          return [4 /*yield*/, this_1.context.cache.match(url)];
                                      case 2:
                                          image = _h.sent();
                                          return [3 /*break*/, 4];
                                      case 3:
                                          _h.sent();
                                          this_1.context.logger.error("Error loading background-image " + url);
                                          return [3 /*break*/, 4];
                                      case 4:
                                          if (image) {
                                              _c = calculateBackgroundRendering(container, index, [
                                                  image.width,
                                                  image.height,
                                                  image.width / image.height
                                              ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                                              this_1.renderRepeat(path, pattern, x, y);
                                          }
                                          return [3 /*break*/, 6];
                                      case 5:
                                          if (isLinearGradient(backgroundImage)) {
                                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                                              _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                                              canvas = document.createElement('canvas');
                                              canvas.width = width;
                                              canvas.height = height;
                                              ctx = canvas.getContext('2d');
                                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                              processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                                                  return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                              });
                                              ctx.fillStyle = gradient_1;
                                              ctx.fillRect(0, 0, width, height);
                                              if (width > 0 && height > 0) {
                                                  pattern = this_1.ctx.createPattern(canvas, 'repeat');
                                                  this_1.renderRepeat(path, pattern, x, y);
                                              }
                                          }
                                          else if (isRadialGradient(backgroundImage)) {
                                              _f = calculateBackgroundRendering(container, index, [
                                                  null,
                                                  null,
                                                  null
                                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                                              position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                                              x = getAbsoluteValue(position[0], width);
                                              y = getAbsoluteValue(position[position.length - 1], height);
                                              _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
                                              if (rx > 0 && ry > 0) {
                                                  radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                                  processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                                                      return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                  });
                                                  this_1.path(path);
                                                  this_1.ctx.fillStyle = radialGradient_1;
                                                  if (rx !== ry) {
                                                      midX = container.bounds.left + 0.5 * container.bounds.width;
                                                      midY = container.bounds.top + 0.5 * container.bounds.height;
                                                      f = ry / rx;
                                                      invF = 1 / f;
                                                      this_1.ctx.save();
                                                      this_1.ctx.translate(midX, midY);
                                                      this_1.ctx.transform(1, 0, 0, f, 0, 0);
                                                      this_1.ctx.translate(-midX, -midY);
                                                      this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                                      this_1.ctx.restore();
                                                  }
                                                  else {
                                                      this_1.ctx.fill();
                                                  }
                                              }
                                          }
                                          _h.label = 6;
                                      case 6:
                                          index--;
                                          return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                          _b.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          backgroundImage = _a[_i];
                          return [5 /*yield**/, _loop_1(backgroundImage)];
                      case 2:
                          _b.sent();
                          _b.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.path(parsePathForBorder(curvePoints, side));
                  this.ctx.fillStyle = asString(color);
                  this.ctx.fill();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              var outerPaths, innerPaths;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(width < 3)) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                      case 2:
                          outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                          this.path(outerPaths);
                          this.ctx.fillStyle = asString(color);
                          this.ctx.fill();
                          innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                          this.path(innerPaths);
                          this.ctx.fill();
                          return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
                          styles = paint.container.styles;
                          hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                          borders = [
                              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                          ];
                          backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                          if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
                          this.ctx.save();
                          this.path(backgroundPaintingArea);
                          this.ctx.clip();
                          if (!isTransparent(styles.backgroundColor)) {
                              this.ctx.fillStyle = asString(styles.backgroundColor);
                              this.ctx.fill();
                          }
                          return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
                      case 1:
                          _a.sent();
                          this.ctx.restore();
                          styles.boxShadow
                              .slice(0)
                              .reverse()
                              .forEach(function (shadow) {
                              _this.ctx.save();
                              var borderBoxArea = calculateBorderBoxPath(paint.curves);
                              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                              if (shadow.inset) {
                                  _this.path(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.mask(shadowPaintingArea);
                              }
                              else {
                                  _this.mask(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.path(shadowPaintingArea);
                              }
                              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                              _this.ctx.shadowOffsetY = shadow.offsetY.number;
                              _this.ctx.shadowColor = asString(shadow.color);
                              _this.ctx.shadowBlur = shadow.blur.number;
                              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                              _this.ctx.fill();
                              _this.ctx.restore();
                          });
                          _a.label = 2;
                      case 2:
                          side = 0;
                          _i = 0, borders_1 = borders;
                          _a.label = 3;
                      case 3:
                          if (!(_i < borders_1.length)) return [3 /*break*/, 13];
                          border = borders_1[_i];
                          if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
                          if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
                      case 4:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 5:
                          if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
                      case 6:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 7:
                          if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
                          return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                      case 8:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
                      case 10:
                          _a.sent();
                          _a.label = 11;
                      case 11:
                          side++;
                          _a.label = 12;
                      case 12:
                          _i++;
                          return [3 /*break*/, 3];
                      case 13: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
          return __awaiter(this, void 0, void 0, function () {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function (_a) {
                  this.ctx.save();
                  strokePaths = parsePathForBorderStroke(curvePoints, side);
                  boxPaths = parsePathForBorder(curvePoints, side);
                  if (style === 2 /* DASHED */) {
                      this.path(boxPaths);
                      this.ctx.clip();
                  }
                  if (isBezierCurve(boxPaths[0])) {
                      startX = boxPaths[0].start.x;
                      startY = boxPaths[0].start.y;
                  }
                  else {
                      startX = boxPaths[0].x;
                      startY = boxPaths[0].y;
                  }
                  if (isBezierCurve(boxPaths[1])) {
                      endX = boxPaths[1].end.x;
                      endY = boxPaths[1].end.y;
                  }
                  else {
                      endX = boxPaths[1].x;
                      endY = boxPaths[1].y;
                  }
                  if (side === 0 || side === 2) {
                      length = Math.abs(startX - endX);
                  }
                  else {
                      length = Math.abs(startY - endY);
                  }
                  this.ctx.beginPath();
                  if (style === 3 /* DOTTED */) {
                      this.formatPath(strokePaths);
                  }
                  else {
                      this.formatPath(boxPaths.slice(0, 2));
                  }
                  dashLength = width < 3 ? width * 3 : width * 2;
                  spaceLength = width < 3 ? width * 2 : width;
                  if (style === 3 /* DOTTED */) {
                      dashLength = width;
                      spaceLength = width;
                  }
                  useLineDash = true;
                  if (length <= dashLength * 2) {
                      useLineDash = false;
                  }
                  else if (length <= dashLength * 2 + spaceLength) {
                      multiplier = length / (2 * dashLength + spaceLength);
                      dashLength *= multiplier;
                      spaceLength *= multiplier;
                  }
                  else {
                      numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                      minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                      maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                      spaceLength =
                          maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
                              ? minSpace
                              : maxSpace;
                  }
                  if (useLineDash) {
                      if (style === 3 /* DOTTED */) {
                          this.ctx.setLineDash([0, dashLength + spaceLength]);
                      }
                      else {
                          this.ctx.setLineDash([dashLength, spaceLength]);
                      }
                  }
                  if (style === 3 /* DOTTED */) {
                      this.ctx.lineCap = 'round';
                      this.ctx.lineWidth = width;
                  }
                  else {
                      this.ctx.lineWidth = width * 2 + 1.1;
                  }
                  this.ctx.strokeStyle = asString(color);
                  this.ctx.stroke();
                  this.ctx.setLineDash([]);
                  // dashed round edge gap
                  if (style === 2 /* DASHED */) {
                      if (isBezierCurve(boxPaths[0])) {
                          path1 = boxPaths[3];
                          path2 = boxPaths[0];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                      if (isBezierCurve(boxPaths[1])) {
                          path1 = boxPaths[1];
                          path2 = boxPaths[2];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                  }
                  this.ctx.restore();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var stack;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                          }
                          stack = parseStackingContexts(element);
                          return [4 /*yield*/, this.renderStack(stack)];
                      case 1:
                          _a.sent();
                          this.applyEffects([]);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return CanvasRenderer;
  }(Renderer));
  var isTextInputElement = function (container) {
      if (container instanceof TextareaElementContainer) {
          return true;
      }
      else if (container instanceof SelectElementContainer) {
          return true;
      }
      else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
      }
      return false;
  };
  var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
      switch (clip) {
          case 0 /* BORDER_BOX */:
              return calculateBorderBoxPath(curves);
          case 2 /* CONTENT_BOX */:
              return calculateContentBoxPath(curves);
          case 1 /* PADDING_BOX */:
          default:
              return calculatePaddingBoxPath(curves);
      }
  };
  var canvasTextAlign = function (textAlign) {
      switch (textAlign) {
          case 1 /* CENTER */:
              return 'center';
          case 2 /* RIGHT */:
              return 'right';
          case 0 /* LEFT */:
          default:
              return 'left';
      }
  };
  // see https://github.com/niklasvh/html2canvas/pull/2645
  var iOSBrokenFonts = ['-apple-system', 'system-ui'];
  var fixIOSSystemFonts = function (fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
          ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
          : fontFamilies;
  };

  var ForeignObjectRenderer = /** @class */ (function (_super) {
      __extends(ForeignObjectRenderer, _super);
      function ForeignObjectRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          _this.options = options;
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
          return _this;
      }
      ForeignObjectRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var svg, img;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                          return [4 /*yield*/, loadSerializedSVG(svg)];
                      case 1:
                          img = _a.sent();
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                          }
                          this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return ForeignObjectRenderer;
  }(Renderer));
  var loadSerializedSVG = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () {
              resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };

  var Logger = /** @class */ (function () {
      function Logger(_a) {
          var id = _a.id, enabled = _a.enabled;
          this.id = id;
          this.enabled = enabled;
          this.start = Date.now();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.debug = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
                  // eslint-disable-next-line no-console
                  console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.prototype.getTime = function () {
          return Date.now() - this.start;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.info = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
                  // eslint-disable-next-line no-console
                  console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.warn = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
                  // eslint-disable-next-line no-console
                  console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.error = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
                  // eslint-disable-next-line no-console
                  console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.instances = {};
      return Logger;
  }());

  var Context = /** @class */ (function () {
      function Context(options, windowBounds) {
          var _a;
          this.windowBounds = windowBounds;
          this.instanceName = "#" + Context.instanceCount++;
          this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
          this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
      }
      Context.instanceCount = 1;
      return Context;
  }());

  var html2canvas = function (element, options) {
      if (options === void 0) { options = {}; }
      return renderElement(element, options);
  };
  if (typeof window !== 'undefined') {
      CacheStorage.setContext(window);
  }
  var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
      var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      return __generator(this, function (_u) {
          switch (_u.label) {
              case 0:
                  if (!element || typeof element !== 'object') {
                      return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
                  }
                  ownerDocument = element.ownerDocument;
                  if (!ownerDocument) {
                      throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                      throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                      allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                      imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
                      proxy: opts.proxy,
                      useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
                  windowOptions = {
                      windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                      windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                      scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                      scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                      allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                      onclone: opts.onclone,
                      ignoreElements: opts.ignoreElements,
                      inlineImages: foreignObjectRendering,
                      copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                      return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                  container = _u.sent();
                  _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
                      ? parseDocumentSize(clonedElement.ownerDocument)
                      : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                  backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                      canvas: opts.canvas,
                      backgroundColor: backgroundColor,
                      scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                      x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                      y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                      width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                      height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering) return [3 /*break*/, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(clonedElement)];
              case 2:
                  canvas = _u.sent();
                  return [3 /*break*/, 5];
              case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor === root.styles.backgroundColor) {
                      root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(root)];
              case 4:
                  canvas = _u.sent();
                  _u.label = 5;
              case 5:
                  if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                      if (!DocumentCloner.destroy(container)) {
                          context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                      }
                  }
                  context.logger.debug("Finished rendering");
                  return [2 /*return*/, canvas];
          }
      });
  }); };
  var parseBackgroundColor = function (context, element, backgroundColorOverride) {
      var ownerDocument = element.ownerDocument;
      // http://www.w3.org/TR/css3-background/#special-backgrounds
      var documentBackgroundColor = ownerDocument.documentElement
          ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
          : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body
          ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
          : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
          ? parseColor(context, backgroundColorOverride)
          : backgroundColorOverride === null
              ? COLORS.TRANSPARENT
              : 0xffffffff;
      return element === ownerDocument.documentElement
          ? isTransparent(documentBackgroundColor)
              ? isTransparent(bodyBackgroundColor)
                  ? defaultBackgroundColor
                  : bodyBackgroundColor
              : documentBackgroundColor
          : defaultBackgroundColor;
  };

  var html2canvas_esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': html2canvas
  });

  /*! @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty$1 = Object.hasOwnProperty,
      setPrototypeOf$2 = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf$2 = Object.getPrototypeOf,
      getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create$3 = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply$4 = _ref.apply,
      construct$1 = _ref.construct;

  if (!apply$4) {
    apply$4 = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct$1) {
    construct$1 = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf$2 = unapply(String.prototype.indexOf);
  var stringTrim$1 = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply$4(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct$1(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf$2) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf$2(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create$3(null);

    var property = void 0;
    for (property in object) {
      if (apply$4(hasOwnProperty$1, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor$5(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf$2(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$3 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof$1(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.6';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$3), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */
    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Parsing of strict XHTML documents */
    var PARSER_MEDIA_TYPE = void 0;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc = void 0;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof$1(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      PARSER_MEDIA_TYPE =
      // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
        return x;
      } : stringToLowerCase;

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$3);
          addToSet(ALLOWED_ATTR, html$1$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof$1(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof$1(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = transformCaseFunc(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Mitigate a problem with templates inside select */
      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }

        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
        // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf$2(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */
    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim$1(attr.value);
        lcName = transformCaseFunc(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof$1(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Serialize doctype if allowed */
      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  var purify_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': purify
  });

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global$J =
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () { return this; })() || Function('return this')();

  var objectGetOwnPropertyDescriptor = {};

  var fails$k = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$j = fails$k;

  // Detect IE8's incomplete defineProperty implementation
  var descriptors = !fails$j(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var fails$i = fails$k;

  var functionBindNative = !fails$i(function () {
    var test = (function () { /* empty */ }).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var NATIVE_BIND$3 = functionBindNative;

  var call$f = Function.prototype.call;

  var functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function () {
    return call$f.apply(call$f, arguments);
  };

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$4(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;

  var createPropertyDescriptor$4 = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var NATIVE_BIND$2 = functionBindNative;

  var FunctionPrototype$2 = Function.prototype;
  var bind$5 = FunctionPrototype$2.bind;
  var call$e = FunctionPrototype$2.call;
  var uncurryThis$q = NATIVE_BIND$2 && bind$5.bind(call$e, call$e);

  var functionUncurryThis = NATIVE_BIND$2 ? function (fn) {
    return fn && uncurryThis$q(fn);
  } : function (fn) {
    return fn && function () {
      return call$e.apply(fn, arguments);
    };
  };

  var uncurryThis$p = functionUncurryThis;

  var toString$b = uncurryThis$p({}.toString);
  var stringSlice$6 = uncurryThis$p(''.slice);

  var classofRaw$1 = function (it) {
    return stringSlice$6(toString$b(it), 8, -1);
  };

  var global$I = global$J;
  var uncurryThis$o = functionUncurryThis;
  var fails$h = fails$k;
  var classof$8 = classofRaw$1;

  var Object$5 = global$I.Object;
  var split = uncurryThis$o(''.split);

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails$h(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object$5('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$8(it) == 'String' ? split(it, '') : Object$5(it);
  } : Object$5;

  var global$H = global$J;

  var TypeError$h = global$H.TypeError;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible$a = function (it) {
    if (it == undefined) throw TypeError$h("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings
  var IndexedObject$1 = indexedObject;
  var requireObjectCoercible$9 = requireObjectCoercible$a;

  var toIndexedObject$5 = function (it) {
    return IndexedObject$1(requireObjectCoercible$9(it));
  };

  // `IsCallable` abstract operation
  // https://tc39.es/ecma262/#sec-iscallable
  var isCallable$j = function (argument) {
    return typeof argument == 'function';
  };

  var isCallable$i = isCallable$j;

  var isObject$8 = function (it) {
    return typeof it == 'object' ? it !== null : isCallable$i(it);
  };

  var global$G = global$J;
  var isCallable$h = isCallable$j;

  var aFunction = function (argument) {
    return isCallable$h(argument) ? argument : undefined;
  };

  var getBuiltIn$7 = function (namespace, method) {
    return arguments.length < 2 ? aFunction(global$G[namespace]) : global$G[namespace] && global$G[namespace][method];
  };

  var uncurryThis$n = functionUncurryThis;

  var objectIsPrototypeOf = uncurryThis$n({}.isPrototypeOf);

  var getBuiltIn$6 = getBuiltIn$7;

  var engineUserAgent = getBuiltIn$6('navigator', 'userAgent') || '';

  var global$F = global$J;
  var userAgent$3 = engineUserAgent;

  var process$4 = global$F.process;
  var Deno = global$F.Deno;
  var versions = process$4 && process$4.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }

  // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0
  if (!version && userAgent$3) {
    match = userAgent$3.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent$3.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es/no-symbol -- required for testing */

  var V8_VERSION$1 = engineV8Version;
  var fails$g = fails$k;

  // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function () {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
  });

  /* eslint-disable es/no-symbol -- required for testing */

  var NATIVE_SYMBOL$1 = nativeSymbol;

  var useSymbolAsUid = NATIVE_SYMBOL$1
    && !Symbol.sham
    && typeof Symbol.iterator == 'symbol';

  var global$E = global$J;
  var getBuiltIn$5 = getBuiltIn$7;
  var isCallable$g = isCallable$j;
  var isPrototypeOf$3 = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

  var Object$4 = global$E.Object;

  var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$5('Symbol');
    return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it));
  };

  var global$D = global$J;

  var String$5 = global$D.String;

  var tryToString$4 = function (argument) {
    try {
      return String$5(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var global$C = global$J;
  var isCallable$f = isCallable$j;
  var tryToString$3 = tryToString$4;

  var TypeError$g = global$C.TypeError;

  // `Assert: IsCallable(argument) is true`
  var aCallable$6 = function (argument) {
    if (isCallable$f(argument)) return argument;
    throw TypeError$g(tryToString$3(argument) + ' is not a function');
  };

  var aCallable$5 = aCallable$6;

  // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod
  var getMethod$6 = function (V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$5(func);
  };

  var global$B = global$J;
  var call$d = functionCall;
  var isCallable$e = isCallable$j;
  var isObject$7 = isObject$8;

  var TypeError$f = global$B.TypeError;

  // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive
  var ordinaryToPrimitive$1 = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input))) return val;
    if (isCallable$e(fn = input.valueOf) && !isObject$7(val = call$d(fn, input))) return val;
    if (pref !== 'string' && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input))) return val;
    throw TypeError$f("Can't convert object to primitive value");
  };

  var shared$4 = {exports: {}};

  var global$A = global$J;

  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var defineProperty$2 = Object.defineProperty;

  var setGlobal$3 = function (key, value) {
    try {
      defineProperty$2(global$A, key, { value: value, configurable: true, writable: true });
    } catch (error) {
      global$A[key] = value;
    } return value;
  };

  var global$z = global$J;
  var setGlobal$2 = setGlobal$3;

  var SHARED = '__core-js_shared__';
  var store$3 = global$z[SHARED] || setGlobal$2(SHARED, {});

  var sharedStore = store$3;

  var store$2 = sharedStore;

  (shared$4.exports = function (key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.21.1',
    mode: 'global',
    copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });

  var global$y = global$J;
  var requireObjectCoercible$8 = requireObjectCoercible$a;

  var Object$3 = global$y.Object;

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject$4 = function (argument) {
    return Object$3(requireObjectCoercible$8(argument));
  };

  var uncurryThis$m = functionUncurryThis;
  var toObject$3 = toObject$4;

  var hasOwnProperty = uncurryThis$m({}.hasOwnProperty);

  // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject$3(it), key);
  };

  var uncurryThis$l = functionUncurryThis;

  var id$1 = 0;
  var postfix = Math.random();
  var toString$a = uncurryThis$l(1.0.toString);

  var uid$2 = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$a(++id$1 + postfix, 36);
  };

  var global$x = global$J;
  var shared$3 = shared$4.exports;
  var hasOwn$9 = hasOwnProperty_1;
  var uid$1 = uid$2;
  var NATIVE_SYMBOL = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;

  var WellKnownSymbolsStore = shared$3('wks');
  var Symbol$1 = global$x.Symbol;
  var symbolFor = Symbol$1 && Symbol$1['for'];
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;

  var wellKnownSymbol$i = function (name) {
    if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
      var description = 'Symbol.' + name;
      if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {
        WellKnownSymbolsStore[name] = Symbol$1[name];
      } else if (USE_SYMBOL_AS_UID && symbolFor) {
        WellKnownSymbolsStore[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
      }
    } return WellKnownSymbolsStore[name];
  };

  var global$w = global$J;
  var call$c = functionCall;
  var isObject$6 = isObject$8;
  var isSymbol$1 = isSymbol$2;
  var getMethod$5 = getMethod$6;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$h = wellKnownSymbol$i;

  var TypeError$e = global$w.TypeError;
  var TO_PRIMITIVE = wellKnownSymbol$h('toPrimitive');

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  var toPrimitive$1 = function (input, pref) {
    if (!isObject$6(input) || isSymbol$1(input)) return input;
    var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = call$c(exoticToPrim, input, pref);
      if (!isObject$6(result) || isSymbol$1(result)) return result;
      throw TypeError$e("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol = isSymbol$2;

  // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey
  var toPropertyKey$3 = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
  };

  var global$v = global$J;
  var isObject$5 = isObject$8;

  var document$3 = global$v.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);

  var documentCreateElement$2 = function (it) {
    return EXISTS$1 ? document$3.createElement(it) : {};
  };

  var DESCRIPTORS$8 = descriptors;
  var fails$f = fails$k;
  var createElement$1 = documentCreateElement$2;

  // Thanks to IE8 for its funny defineProperty
  var ie8DomDefine = !DESCRIPTORS$8 && !fails$f(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement$1('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  var DESCRIPTORS$7 = descriptors;
  var call$b = functionCall;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var createPropertyDescriptor$3 = createPropertyDescriptor$4;
  var toIndexedObject$4 = toIndexedObject$5;
  var toPropertyKey$2 = toPropertyKey$3;
  var hasOwn$8 = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$4(O);
    P = toPropertyKey$2(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) { /* empty */ }
    if (hasOwn$8(O, P)) return createPropertyDescriptor$3(!call$b(propertyIsEnumerableModule.f, O, P), O[P]);
  };

  var objectDefineProperty = {};

  var DESCRIPTORS$6 = descriptors;
  var fails$e = fails$k;

  // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334
  var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$e(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () { /* empty */ }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var global$u = global$J;
  var isObject$4 = isObject$8;

  var String$4 = global$u.String;
  var TypeError$d = global$u.TypeError;

  // `Assert: Type(argument) is Object`
  var anObject$g = function (argument) {
    if (isObject$4(argument)) return argument;
    throw TypeError$d(String$4(argument) + ' is not an object');
  };

  var global$t = global$J;
  var DESCRIPTORS$5 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$f = anObject$g;
  var toPropertyKey$1 = toPropertyKey$3;

  var TypeError$c = global$t.TypeError;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var $defineProperty = Object.defineProperty;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE$1 = 'configurable';
  var WRITABLE = 'writable';

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
    anObject$f(O);
    P = toPropertyKey$1(P);
    anObject$f(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    } return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject$f(O);
    P = toPropertyKey$1(P);
    anObject$f(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError$c('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var DESCRIPTORS$4 = descriptors;
  var definePropertyModule$5 = objectDefineProperty;
  var createPropertyDescriptor$2 = createPropertyDescriptor$4;

  var createNonEnumerableProperty$6 = DESCRIPTORS$4 ? function (object, key, value) {
    return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var redefine$7 = {exports: {}};

  var uncurryThis$k = functionUncurryThis;
  var isCallable$d = isCallable$j;
  var store$1 = sharedStore;

  var functionToString = uncurryThis$k(Function.toString);

  // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
  if (!isCallable$d(store$1.inspectSource)) {
    store$1.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource$4 = store$1.inspectSource;

  var global$s = global$J;
  var isCallable$c = isCallable$j;
  var inspectSource$3 = inspectSource$4;

  var WeakMap$1 = global$s.WeakMap;

  var nativeWeakMap = isCallable$c(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));

  var shared$2 = shared$4.exports;
  var uid = uid$2;

  var keys = shared$2('keys');

  var sharedKey$3 = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys$4 = {};

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$r = global$J;
  var uncurryThis$j = functionUncurryThis;
  var isObject$3 = isObject$8;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
  var hasOwn$7 = hasOwnProperty_1;
  var shared$1 = sharedStore;
  var sharedKey$2 = sharedKey$3;
  var hiddenKeys$3 = hiddenKeys$4;

  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$b = global$r.TypeError;
  var WeakMap = global$r.WeakMap;
  var set$1, get, has;

  var enforce = function (it) {
    return has(it) ? get(it) : set$1(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject$3(it) || (state = get(it)).type !== TYPE) {
        throw TypeError$b('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared$1.state) {
    var store = shared$1.state || (shared$1.state = new WeakMap());
    var wmget = uncurryThis$j(store.get);
    var wmhas = uncurryThis$j(store.has);
    var wmset = uncurryThis$j(store.set);
    set$1 = function (it, metadata) {
      if (wmhas(store, it)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset(store, it, metadata);
      return metadata;
    };
    get = function (it) {
      return wmget(store, it) || {};
    };
    has = function (it) {
      return wmhas(store, it);
    };
  } else {
    var STATE = sharedKey$2('state');
    hiddenKeys$3[STATE] = true;
    set$1 = function (it, metadata) {
      if (hasOwn$7(it, STATE)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$5(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return hasOwn$7(it, STATE) ? it[STATE] : {};
    };
    has = function (it) {
      return hasOwn$7(it, STATE);
    };
  }

  var internalState = {
    set: set$1,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var DESCRIPTORS$3 = descriptors;
  var hasOwn$6 = hasOwnProperty_1;

  var FunctionPrototype$1 = Function.prototype;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;

  var EXISTS = hasOwn$6(FunctionPrototype$1, 'name');
  // additional protection from minified / mangled / dropped function names
  var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || (DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, 'name').configurable));

  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var global$q = global$J;
  var isCallable$b = isCallable$j;
  var hasOwn$5 = hasOwnProperty_1;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
  var setGlobal$1 = setGlobal$3;
  var inspectSource$2 = inspectSource$4;
  var InternalStateModule$2 = internalState;
  var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;

  var getInternalState$3 = InternalStateModule$2.get;
  var enforceInternalState = InternalStateModule$2.enforce;
  var TEMPLATE = String(String).split('String');

  (redefine$7.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var name = options && options.name !== undefined ? options.name : key;
    var state;
    if (isCallable$b(value)) {
      if (String(name).slice(0, 7) === 'Symbol(') {
        name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
      }
      if (!hasOwn$5(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {
        createNonEnumerableProperty$4(value, 'name', name);
      }
      state = enforceInternalState(value);
      if (!state.source) {
        state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
      }
    }
    if (O === global$q) {
      if (simple) O[key] = value;
      else setGlobal$1(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$4(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return isCallable$b(this) && getInternalState$3(this).source || inspectSource$2(this);
  });

  var objectGetOwnPropertyNames = {};

  var ceil = Math.ceil;
  var floor$1 = Math.floor;

  // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity
  var toIntegerOrInfinity$4 = function (argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- safe
    return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
  };

  var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;

  var max$2 = Math.max;
  var min$5 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex$2 = function (index, length) {
    var integer = toIntegerOrInfinity$3(index);
    return integer < 0 ? max$2(integer + length, 0) : min$5(integer, length);
  };

  var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;

  var min$4 = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength$6 = function (argument) {
    return argument > 0 ? min$4(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength$5 = toLength$6;

  // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike
  var lengthOfArrayLike$4 = function (obj) {
    return toLength$5(obj.length);
  };

  var toIndexedObject$3 = toIndexedObject$5;
  var toAbsoluteIndex$1 = toAbsoluteIndex$2;
  var lengthOfArrayLike$3 = lengthOfArrayLike$4;

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod$3 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$3($this);
      var length = lengthOfArrayLike$3(O);
      var index = toAbsoluteIndex$1(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare -- NaN check
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$3(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$3(false)
  };

  var uncurryThis$i = functionUncurryThis;
  var hasOwn$4 = hasOwnProperty_1;
  var toIndexedObject$2 = toIndexedObject$5;
  var indexOf$1 = arrayIncludes.indexOf;
  var hiddenKeys$2 = hiddenKeys$4;

  var push$2 = uncurryThis$i([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject$2(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O, key) && push$2(result, key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (hasOwn$4(O, key = names[i++])) {
      ~indexOf$1(result, key) || push$2(result, key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys$3 = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;

  var hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys$1);
  };

  var objectGetOwnPropertySymbols = {};

  // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

  var getBuiltIn$4 = getBuiltIn$7;
  var uncurryThis$h = functionUncurryThis;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var anObject$e = anObject$g;

  var concat$1 = uncurryThis$h([].concat);

  // all object keys, includes non-enumerable and symbols
  var ownKeys$4 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject$e(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
  };

  var hasOwn$3 = hasOwnProperty_1;
  var ownKeys$3 = ownKeys$4;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule$4 = objectDefineProperty;

  var copyConstructorProperties$1 = function (target, source, exceptions) {
    var keys = ownKeys$3(source);
    var defineProperty = definePropertyModule$4.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };

  var fails$d = fails$k;
  var isCallable$a = isCallable$j;

  var replacement = /#|\.prototype\./;

  var isForced$2 = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : isCallable$a(detection) ? fails$d(detection)
      : !!detection;
  };

  var normalize = isForced$2.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$2.data = {};
  var NATIVE = isForced$2.NATIVE = 'N';
  var POLYFILL = isForced$2.POLYFILL = 'P';

  var isForced_1 = isForced$2;

  var global$p = global$J;
  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
  var redefine$6 = redefine$7.exports;
  var setGlobal = setGlobal$3;
  var copyConstructorProperties = copyConstructorProperties$1;
  var isForced$1 = isForced_1;

  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
    options.name        - the .name of the function if it does not match the key
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$p;
    } else if (STATIC) {
      target = global$p[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global$p[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contained in target
      if (!FORCED && targetProperty !== undefined) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$3(sourceProperty, 'sham', true);
      }
      // extend global
      redefine$6(target, key, sourceProperty, options);
    }
  };

  var global$o = global$J;

  var nativePromiseConstructor = global$o.Promise;

  var redefine$5 = redefine$7.exports;

  var redefineAll$1 = function (target, src, options) {
    for (var key in src) redefine$5(target, key, src[key], options);
    return target;
  };

  var global$n = global$J;
  var isCallable$9 = isCallable$j;

  var String$3 = global$n.String;
  var TypeError$a = global$n.TypeError;

  var aPossiblePrototype$1 = function (argument) {
    if (typeof argument == 'object' || isCallable$9(argument)) return argument;
    throw TypeError$a("Can't set " + String$3(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */

  var uncurryThis$g = functionUncurryThis;
  var anObject$d = anObject$g;
  var aPossiblePrototype = aPossiblePrototype$1;

  // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe
  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = uncurryThis$g(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject$d(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var defineProperty$1 = objectDefineProperty.f;
  var hasOwn$2 = hasOwnProperty_1;
  var wellKnownSymbol$g = wellKnownSymbol$i;

  var TO_STRING_TAG$3 = wellKnownSymbol$g('toStringTag');

  var setToStringTag$3 = function (target, TAG, STATIC) {
    if (target && !STATIC) target = target.prototype;
    if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {
      defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
    }
  };

  var getBuiltIn$3 = getBuiltIn$7;
  var definePropertyModule$3 = objectDefineProperty;
  var wellKnownSymbol$f = wellKnownSymbol$i;
  var DESCRIPTORS$2 = descriptors;

  var SPECIES$3 = wellKnownSymbol$f('species');

  var setSpecies$1 = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule$3.f;

    if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {
      defineProperty(Constructor, SPECIES$3, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var global$m = global$J;
  var isPrototypeOf$2 = objectIsPrototypeOf;

  var TypeError$9 = global$m.TypeError;

  var anInstance$1 = function (it, Prototype) {
    if (isPrototypeOf$2(Prototype, it)) return it;
    throw TypeError$9('Incorrect invocation');
  };

  var uncurryThis$f = functionUncurryThis;
  var aCallable$4 = aCallable$6;
  var NATIVE_BIND$1 = functionBindNative;

  var bind$4 = uncurryThis$f(uncurryThis$f.bind);

  // optional / simple context binding
  var functionBindContext = function (fn, that) {
    aCallable$4(fn);
    return that === undefined ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var iterators = {};

  var wellKnownSymbol$e = wellKnownSymbol$i;
  var Iterators$4 = iterators;

  var ITERATOR$5 = wellKnownSymbol$e('iterator');
  var ArrayPrototype$1 = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod$1 = function (it) {
    return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
  };

  var wellKnownSymbol$d = wellKnownSymbol$i;

  var TO_STRING_TAG$2 = wellKnownSymbol$d('toStringTag');
  var test$1 = {};

  test$1[TO_STRING_TAG$2] = 'z';

  var toStringTagSupport = String(test$1) === '[object z]';

  var global$l = global$J;
  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var isCallable$8 = isCallable$j;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$c = wellKnownSymbol$i;

  var TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');
  var Object$2 = global$l.Object;

  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof$7 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = Object$2(it), TO_STRING_TAG$1)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable$8(O.callee) ? 'Arguments' : result;
  };

  var classof$6 = classof$7;
  var getMethod$4 = getMethod$6;
  var Iterators$3 = iterators;
  var wellKnownSymbol$b = wellKnownSymbol$i;

  var ITERATOR$4 = wellKnownSymbol$b('iterator');

  var getIteratorMethod$2 = function (it) {
    if (it != undefined) return getMethod$4(it, ITERATOR$4)
      || getMethod$4(it, '@@iterator')
      || Iterators$3[classof$6(it)];
  };

  var global$k = global$J;
  var call$a = functionCall;
  var aCallable$3 = aCallable$6;
  var anObject$c = anObject$g;
  var tryToString$2 = tryToString$4;
  var getIteratorMethod$1 = getIteratorMethod$2;

  var TypeError$8 = global$k.TypeError;

  var getIterator$1 = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
    if (aCallable$3(iteratorMethod)) return anObject$c(call$a(iteratorMethod, argument));
    throw TypeError$8(tryToString$2(argument) + ' is not iterable');
  };

  var call$9 = functionCall;
  var anObject$b = anObject$g;
  var getMethod$3 = getMethod$6;

  var iteratorClose$1 = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject$b(iterator);
    try {
      innerResult = getMethod$3(iterator, 'return');
      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }
      innerResult = call$9(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$b(innerResult);
    return value;
  };

  var global$j = global$J;
  var bind$3 = functionBindContext;
  var call$8 = functionCall;
  var anObject$a = anObject$g;
  var tryToString$1 = tryToString$4;
  var isArrayIteratorMethod = isArrayIteratorMethod$1;
  var lengthOfArrayLike$2 = lengthOfArrayLike$4;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var getIterator = getIterator$1;
  var getIteratorMethod = getIteratorMethod$2;
  var iteratorClose = iteratorClose$1;

  var TypeError$7 = global$j.TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate$1 = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$3(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject$a(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      } return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw TypeError$7(tryToString$1(iterable) + ' is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf$1(ResultPrototype, result)) return result;
        } return new Result(false);
      }
      iterator = getIterator(iterable, iterFn);
    }

    next = iterator.next;
    while (!(step = call$8(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
      if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;
    } return new Result(false);
  };

  var wellKnownSymbol$a = wellKnownSymbol$i;

  var ITERATOR$3 = wellKnownSymbol$a('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return { done: !!called++ };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$3] = function () {
      return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function () { throw 2; });
  } catch (error) { /* empty */ }

  var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$3] = function () {
        return {
          next: function () {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
  };

  var uncurryThis$e = functionUncurryThis;
  var fails$c = fails$k;
  var isCallable$7 = isCallable$j;
  var classof$5 = classof$7;
  var getBuiltIn$2 = getBuiltIn$7;
  var inspectSource$1 = inspectSource$4;

  var noop$1 = function () { /* empty */ };
  var empty = [];
  var construct = getBuiltIn$2('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec$2 = uncurryThis$e(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;
    try {
      construct(noop$1, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;
    switch (classof$5(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction': return false;
    }
    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true;

  // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor
  var isConstructor$1 = !construct || fails$c(function () {
    var called;
    return isConstructorModern(isConstructorModern.call)
      || !isConstructorModern(Object)
      || !isConstructorModern(function () { called = true; })
      || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var global$i = global$J;
  var isConstructor = isConstructor$1;
  var tryToString = tryToString$4;

  var TypeError$6 = global$i.TypeError;

  // `Assert: IsConstructor(argument) is true`
  var aConstructor$1 = function (argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError$6(tryToString(argument) + ' is not a constructor');
  };

  var anObject$9 = anObject$g;
  var aConstructor = aConstructor$1;
  var wellKnownSymbol$9 = wellKnownSymbol$i;

  var SPECIES$2 = wellKnownSymbol$9('species');

  // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor
  var speciesConstructor$2 = function (O, defaultConstructor) {
    var C = anObject$9(O).constructor;
    var S;
    return C === undefined || (S = anObject$9(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);
  };

  var NATIVE_BIND = functionBindNative;

  var FunctionPrototype = Function.prototype;
  var apply$3 = FunctionPrototype.apply;
  var call$7 = FunctionPrototype.call;

  // eslint-disable-next-line es/no-reflect -- safe
  var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$7.bind(apply$3) : function () {
    return call$7.apply(apply$3, arguments);
  });

  var getBuiltIn$1 = getBuiltIn$7;

  var html$2 = getBuiltIn$1('document', 'documentElement');

  var uncurryThis$d = functionUncurryThis;

  var arraySlice$2 = uncurryThis$d([].slice);

  var global$h = global$J;

  var TypeError$5 = global$h.TypeError;

  var validateArgumentsLength$1 = function (passed, required) {
    if (passed < required) throw TypeError$5('Not enough arguments');
    return passed;
  };

  var userAgent$2 = engineUserAgent;

  var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);

  var classof$4 = classofRaw$1;
  var global$g = global$J;

  var engineIsNode = classof$4(global$g.process) == 'process';

  var global$f = global$J;
  var apply$2 = functionApply;
  var bind$2 = functionBindContext;
  var isCallable$6 = isCallable$j;
  var hasOwn$1 = hasOwnProperty_1;
  var fails$b = fails$k;
  var html$1 = html$2;
  var arraySlice$1 = arraySlice$2;
  var createElement = documentCreateElement$2;
  var validateArgumentsLength = validateArgumentsLength$1;
  var IS_IOS$1 = engineIsIos;
  var IS_NODE$3 = engineIsNode;

  var set = global$f.setImmediate;
  var clear = global$f.clearImmediate;
  var process$3 = global$f.process;
  var Dispatch = global$f.Dispatch;
  var Function$1 = global$f.Function;
  var MessageChannel = global$f.MessageChannel;
  var String$2 = global$f.String;
  var counter = 0;
  var queue$2 = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var location$1, defer, channel, port;

  try {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    location$1 = global$f.location;
  } catch (error) { /* empty */ }

  var run = function (id) {
    if (hasOwn$1(queue$2, id)) {
      var fn = queue$2[id];
      delete queue$2[id];
      fn();
    }
  };

  var runner = function (id) {
    return function () {
      run(id);
    };
  };

  var listener = function (event) {
    run(event.data);
  };

  var post = function (id) {
    // old engines have not location.origin
    global$f.postMessage(String$2(id), location$1.protocol + '//' + location$1.host);
  };

  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!set || !clear) {
    set = function setImmediate(handler) {
      validateArgumentsLength(arguments.length, 1);
      var fn = isCallable$6(handler) ? handler : Function$1(handler);
      var args = arraySlice$1(arguments, 1);
      queue$2[++counter] = function () {
        apply$2(fn, undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue$2[id];
    };
    // Node.js 0.8-
    if (IS_NODE$3) {
      defer = function (id) {
        process$3.nextTick(runner(id));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(runner(id));
      };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !IS_IOS$1) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = bind$2(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
      global$f.addEventListener &&
      isCallable$6(global$f.postMessage) &&
      !global$f.importScripts &&
      location$1 && location$1.protocol !== 'file:' &&
      !fails$b(post)
    ) {
      defer = post;
      global$f.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement('script')) {
      defer = function (id) {
        html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
          html$1.removeChild(this);
          run(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task$1 = {
    set: set,
    clear: clear
  };

  var userAgent$1 = engineUserAgent;
  var global$e = global$J;

  var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$e.Pebble !== undefined;

  var userAgent = engineUserAgent;

  var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

  var global$d = global$J;
  var bind$1 = functionBindContext;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task$1.set;
  var IS_IOS = engineIsIos;
  var IS_IOS_PEBBLE = engineIsIosPebble;
  var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
  var IS_NODE$2 = engineIsNode;

  var MutationObserver = global$d.MutationObserver || global$d.WebKitMutationObserver;
  var document$2 = global$d.document;
  var process$2 = global$d.process;
  var Promise$1 = global$d.Promise;
  // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$d, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

  var flush, head, last$1, notify$1, toggle, node$1, promise, then;

  // modern engines have queueMicrotask method
  if (!queueMicrotask) {
    flush = function () {
      var parent, fn;
      if (IS_NODE$2 && (parent = process$2.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error) {
          if (head) notify$1();
          else last$1 = undefined;
          throw error;
        }
      } last$1 = undefined;
      if (parent) parent.enter();
    };

    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
      toggle = true;
      node$1 = document$2.createTextNode('');
      new MutationObserver(flush).observe(node$1, { characterData: true });
      notify$1 = function () {
        node$1.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      // workaround of WebKit ~ iOS Safari 10.1 bug
      promise.constructor = Promise$1;
      then = bind$1(promise.then, promise);
      notify$1 = function () {
        then(flush);
      };
    // Node.js without promises
    } else if (IS_NODE$2) {
      notify$1 = function () {
        process$2.nextTick(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      // strange IE + webpack dev server bug - use .bind(global)
      macrotask = bind$1(macrotask, global$d);
      notify$1 = function () {
        macrotask(flush);
      };
    }
  }

  var microtask$1 = queueMicrotask || function (fn) {
    var task = { fn: fn, next: undefined };
    if (last$1) last$1.next = task;
    if (!head) {
      head = task;
      notify$1();
    } last$1 = task;
  };

  var newPromiseCapability$2 = {};

  var aCallable$2 = aCallable$6;

  var PromiseCapability = function (C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aCallable$2(resolve);
    this.reject = aCallable$2(reject);
  };

  // `NewPromiseCapability` abstract operation
  // https://tc39.es/ecma262/#sec-newpromisecapability
  newPromiseCapability$2.f = function (C) {
    return new PromiseCapability(C);
  };

  var anObject$8 = anObject$g;
  var isObject$2 = isObject$8;
  var newPromiseCapability$1 = newPromiseCapability$2;

  var promiseResolve$1 = function (C, x) {
    anObject$8(C);
    if (isObject$2(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$1.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var global$c = global$J;

  var hostReportErrors$1 = function (a, b) {
    var console = global$c.console;
    if (console && console.error) {
      arguments.length == 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform$1 = function (exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };

  var Queue$1 = function () {
    this.head = null;
    this.tail = null;
  };

  Queue$1.prototype = {
    add: function (item) {
      var entry = { item: item, next: null };
      if (this.head) this.tail.next = entry;
      else this.head = entry;
      this.tail = entry;
    },
    get: function () {
      var entry = this.head;
      if (entry) {
        this.head = entry.next;
        if (this.tail === entry) this.tail = null;
        return entry.item;
      }
    }
  };

  var queue$1 = Queue$1;

  var engineIsBrowser = typeof window == 'object';

  var $$9 = _export;
  var global$b = global$J;
  var getBuiltIn = getBuiltIn$7;
  var call$6 = functionCall;
  var NativePromise = nativePromiseConstructor;
  var redefine$4 = redefine$7.exports;
  var redefineAll = redefineAll$1;
  var setPrototypeOf$1 = objectSetPrototypeOf;
  var setToStringTag$2 = setToStringTag$3;
  var setSpecies = setSpecies$1;
  var aCallable$1 = aCallable$6;
  var isCallable$5 = isCallable$j;
  var isObject$1 = isObject$8;
  var anInstance = anInstance$1;
  var inspectSource = inspectSource$4;
  var iterate = iterate$1;
  var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
  var speciesConstructor$1 = speciesConstructor$2;
  var task = task$1.set;
  var microtask = microtask$1;
  var promiseResolve = promiseResolve$1;
  var hostReportErrors = hostReportErrors$1;
  var newPromiseCapabilityModule = newPromiseCapability$2;
  var perform = perform$1;
  var Queue = queue$1;
  var InternalStateModule$1 = internalState;
  var isForced = isForced_1;
  var wellKnownSymbol$8 = wellKnownSymbol$i;
  var IS_BROWSER = engineIsBrowser;
  var IS_NODE$1 = engineIsNode;
  var V8_VERSION = engineV8Version;

  var SPECIES$1 = wellKnownSymbol$8('species');
  var PROMISE = 'Promise';

  var getInternalState$2 = InternalStateModule$1.getterFor(PROMISE);
  var setInternalState$1 = InternalStateModule$1.set;
  var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
  var NativePromisePrototype = NativePromise && NativePromise.prototype;
  var PromiseConstructor = NativePromise;
  var PromisePrototype = NativePromisePrototype;
  var TypeError$4 = global$b.TypeError;
  var document$1 = global$b.document;
  var process$1 = global$b.process;
  var newPromiseCapability = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability;

  var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$b.dispatchEvent);
  var NATIVE_REJECTION_EVENT = isCallable$5(global$b.PromiseRejectionEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var SUBCLASSING = false;

  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  var FORCED = isForced(PROMISE, function () {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = new PromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
  });

  var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
  });

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject$1(it) && isCallable$5(then = it.then) ? then : false;
  };

  var callReaction = function (reaction, state) {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
      if (handler) {
        if (!ok) {
          if (state.rejection === UNHANDLED) onHandleUnhandled(state);
          state.rejection = HANDLED;
        }
        if (handler === true) result = value;
        else {
          if (domain) domain.enter();
          result = handler(value); // can throw
          if (domain) {
            domain.exit();
            exited = true;
          }
        }
        if (result === reaction.promise) {
          reject(TypeError$4('Promise-chain cycle'));
        } else if (then = isThenable(result)) {
          call$6(then, result, resolve, reject);
        } else resolve(result);
      } else reject(value);
    } catch (error) {
      if (domain && !exited) domain.exit();
      reject(error);
    }
  };

  var notify = function (state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function () {
      var reactions = state.reactions;
      var reaction;
      while (reaction = reactions.get()) {
        callReaction(reaction, state);
      }
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$1.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$b.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (!NATIVE_REJECTION_EVENT && (handler = global$b['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (state) {
    call$6(task, global$b, function () {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$1.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (state) {
    call$6(task, global$b, function () {
      var promise = state.facade;
      if (IS_NODE$1) {
        process$1.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function (fn, state, unwrap) {
    return function (value) {
      fn(state, value, unwrap);
    };
  };

  var internalReject = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
  };

  var internalResolve = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw TypeError$4("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            call$6(then, value,
              bind(internalResolve, wrapper, state),
              bind(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromisePrototype);
      aCallable$1(executor);
      call$6(Internal, this);
      var state = getInternalState$2(this);
      try {
        executor(bind(internalResolve, state), bind(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    PromisePrototype = PromiseConstructor.prototype;
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
      setInternalState$1(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: new Queue(),
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };
    Internal.prototype = redefineAll(PromisePrototype, {
      // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then
      // eslint-disable-next-line unicorn/no-thenable -- safe
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable$5(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$5(onRejected) && onRejected;
        reaction.domain = IS_NODE$1 ? process$1.domain : undefined;
        if (state.state == PENDING) state.reactions.add(reaction);
        else microtask(function () {
          callReaction(reaction, state);
        });
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.es/ecma262/#sec-promise.prototype.catch
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalState$2(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, state);
      this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if (isCallable$5(NativePromise) && NativePromisePrototype !== Object.prototype) {
      nativeThen = NativePromisePrototype.then;

      if (!SUBCLASSING) {
        // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
        redefine$4(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function (resolve, reject) {
            call$6(nativeThen, that, resolve, reject);
          }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
        }, { unsafe: true });

        // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
        redefine$4(NativePromisePrototype, 'catch', PromisePrototype['catch'], { unsafe: true });
      }

      // make `.constructor === Promise` work for native promise-based APIs
      try {
        delete NativePromisePrototype.constructor;
      } catch (error) { /* empty */ }

      // make `instanceof Promise` work for native promise-based APIs
      if (setPrototypeOf$1) {
        setPrototypeOf$1(NativePromisePrototype, PromisePrototype);
      }
    }
  }

  $$9({ global: true, wrap: true, forced: FORCED }, {
    Promise: PromiseConstructor
  });

  setToStringTag$2(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);

  PromiseWrapper = getBuiltIn(PROMISE);

  // statics
  $$9({ target: PROMISE, stat: true, forced: FORCED }, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      call$6(capability.reject, undefined, r);
      return capability.promise;
    }
  });

  $$9({ target: PROMISE, stat: true, forced: FORCED }, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve(this, x);
    }
  });

  $$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          remaining++;
          call$6($promiseResolve, C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable$1(C.resolve);
        iterate(iterable, function (promise) {
          call$6($promiseResolve, C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var global$a = global$J;
  var classof$3 = classof$7;

  var String$1 = global$a.String;

  var toString$9 = function (argument) {
    if (classof$3(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String$1(argument);
  };

  var anObject$7 = anObject$g;

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags$1 = function () {
    var that = anObject$7(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  var fails$a = fails$k;
  var global$9 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var $RegExp$2 = global$9.RegExp;

  var UNSUPPORTED_Y$2 = fails$a(function () {
    var re = $RegExp$2('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });

  // UC Browser bug
  // https://github.com/zloirock/core-js/issues/1008
  var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function () {
    return !$RegExp$2('a', 'y').sticky;
  });

  var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = $RegExp$2('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });

  var regexpStickyHelpers = {
    BROKEN_CARET: BROKEN_CARET,
    MISSED_STICKY: MISSED_STICKY,
    UNSUPPORTED_Y: UNSUPPORTED_Y$2
  };

  var objectDefineProperties = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys$1 = enumBugKeys$3;

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe
  var objectKeys$1 = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys$1);
  };

  var DESCRIPTORS$1 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$2 = objectDefineProperty;
  var anObject$6 = anObject$g;
  var toIndexedObject$1 = toIndexedObject$5;
  var objectKeys = objectKeys$1;

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe
  objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$6(O);
    var props = toIndexedObject$1(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
    return O;
  };

  /* global ActiveXObject -- old IE, WSH */

  var anObject$5 = anObject$g;
  var definePropertiesModule = objectDefineProperties;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys = hiddenKeys$4;
  var html = html$2;
  var documentCreateElement$1 = documentCreateElement$2;
  var sharedKey$1 = sharedKey$3;

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$1('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement$1('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = typeof document != 'undefined'
      ? document.domain && activeXDocument
        ? NullProtoObjectViaActiveX(activeXDocument) // old IE
        : NullProtoObjectViaIFrame()
      : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO$1] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$5(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
  };

  var fails$9 = fails$k;
  var global$8 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
  var $RegExp$1 = global$8.RegExp;

  var regexpUnsupportedDotAll = fails$9(function () {
    var re = $RegExp$1('.', 's');
    return !(re.dotAll && re.exec('\n') && re.flags === 's');
  });

  var fails$8 = fails$k;
  var global$7 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
  var $RegExp = global$7.RegExp;

  var regexpUnsupportedNcg = fails$8(function () {
    var re = $RegExp('(?<a>b)', 'g');
    return re.exec('b').groups.a !== 'b' ||
      'b'.replace(re, '$<a>c') !== 'bc';
  });

  /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
  /* eslint-disable regexp/no-useless-quantifier -- testing */
  var call$5 = functionCall;
  var uncurryThis$c = functionUncurryThis;
  var toString$8 = toString$9;
  var regexpFlags = regexpFlags$1;
  var stickyHelpers$1 = regexpStickyHelpers;
  var shared = shared$4.exports;
  var create$2 = objectCreate;
  var getInternalState$1 = internalState.get;
  var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
  var UNSUPPORTED_NCG = regexpUnsupportedNcg;

  var nativeReplace = shared('native-string-replace', String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt$3 = uncurryThis$c(''.charAt);
  var indexOf = uncurryThis$c(''.indexOf);
  var replace$2 = uncurryThis$c(''.replace);
  var stringSlice$5 = uncurryThis$c(''.slice);

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    call$5(nativeExec, re1, 'a');
    call$5(nativeExec, re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

  if (PATCH) {
    patchedExec = function exec(string) {
      var re = this;
      var state = getInternalState$1(re);
      var str = toString$8(string);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i, object, group;

      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call$5(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
      }

      var groups = state.groups;
      var sticky = UNSUPPORTED_Y$1 && re.sticky;
      var flags = call$5(regexpFlags, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = replace$2(flags, 'y', '');
        if (indexOf(flags, 'g') === -1) {
          flags += 'g';
        }

        strCopy = stringSlice$5(str, re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = call$5(nativeExec, sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = stringSlice$5(match.input, charsAdded);
          match[0] = stringSlice$5(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        call$5(nativeReplace, match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      if (match && groups) {
        match.groups = object = create$2(null);
        for (i = 0; i < groups.length; i++) {
          group = groups[i];
          object[group[0]] = match[group[1]];
        }
      }

      return match;
    };
  }

  var regexpExec$3 = patchedExec;

  var $$8 = _export;
  var exec$1 = regexpExec$3;

  // `RegExp.prototype.exec` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.exec
  $$8({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {
    exec: exec$1
  });

  // TODO: Remove from `core-js@4` since it's moved to entry points

  var uncurryThis$b = functionUncurryThis;
  var redefine$3 = redefine$7.exports;
  var regexpExec$2 = regexpExec$3;
  var fails$7 = fails$k;
  var wellKnownSymbol$7 = wellKnownSymbol$i;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;

  var SPECIES = wellKnownSymbol$7('species');
  var RegExpPrototype$1 = RegExp.prototype;

  var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol$7(KEY);

    var DELEGATES_TO_SYMBOL = !fails$7(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES] = function () { return re; };
        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      FORCED
    ) {
      var uncurriedNativeRegExpMethod = uncurryThis$b(/./[SYMBOL]);
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        var uncurriedNativeMethod = uncurryThis$b(nativeMethod);
        var $exec = regexp.exec;
        if ($exec === regexpExec$2 || $exec === RegExpPrototype$1.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
          }
          return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
        }
        return { done: false };
      });

      redefine$3(String.prototype, KEY, methods[0]);
      redefine$3(RegExpPrototype$1, SYMBOL, methods[1]);
    }

    if (SHAM) createNonEnumerableProperty$2(RegExpPrototype$1[SYMBOL], 'sham', true);
  };

  var uncurryThis$a = functionUncurryThis;
  var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
  var toString$7 = toString$9;
  var requireObjectCoercible$7 = requireObjectCoercible$a;

  var charAt$2 = uncurryThis$a(''.charAt);
  var charCodeAt = uncurryThis$a(''.charCodeAt);
  var stringSlice$4 = uncurryThis$a(''.slice);

  var createMethod$2 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$7(requireObjectCoercible$7($this));
      var position = toIntegerOrInfinity$1(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING
            ? charAt$2(S, position)
            : first
          : CONVERT_TO_STRING
            ? stringSlice$4(S, position, position + 2)
            : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$2(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$2(true)
  };

  var charAt$1 = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.es/ecma262/#sec-advancestringindex
  var advanceStringIndex$3 = function (S, index, unicode) {
    return index + (unicode ? charAt$1(S, index).length : 1);
  };

  var global$6 = global$J;
  var call$4 = functionCall;
  var anObject$4 = anObject$g;
  var isCallable$4 = isCallable$j;
  var classof$2 = classofRaw$1;
  var regexpExec$1 = regexpExec$3;

  var TypeError$3 = global$6.TypeError;

  // `RegExpExec` abstract operation
  // https://tc39.es/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (isCallable$4(exec)) {
      var result = call$4(exec, R, S);
      if (result !== null) anObject$4(result);
      return result;
    }
    if (classof$2(R) === 'RegExp') return call$4(regexpExec$1, R, S);
    throw TypeError$3('RegExp#exec called on incompatible receiver');
  };

  var call$3 = functionCall;
  var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
  var anObject$3 = anObject$g;
  var toLength$4 = toLength$6;
  var toString$6 = toString$9;
  var requireObjectCoercible$6 = requireObjectCoercible$a;
  var getMethod$2 = getMethod$6;
  var advanceStringIndex$2 = advanceStringIndex$3;
  var regExpExec$1 = regexpExecAbstract;

  // @@match logic
  fixRegExpWellKnownSymbolLogic$2('match', function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible$6(this);
        var matcher = regexp == undefined ? undefined : getMethod$2(regexp, MATCH);
        return matcher ? call$3(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString$6(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (string) {
        var rx = anObject$3(this);
        var S = toString$6(string);
        var res = maybeCallNative(nativeMatch, rx, S);

        if (res.done) return res.value;

        if (!rx.global) return regExpExec$1(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec$1(rx, S)) !== null) {
          var matchStr = toString$6(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex$2(S, toLength$4(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  var uncurryThis$9 = functionUncurryThis;
  var toObject$2 = toObject$4;

  var floor = Math.floor;
  var charAt = uncurryThis$9(''.charAt);
  var replace$1 = uncurryThis$9(''.replace);
  var stringSlice$3 = uncurryThis$9(''.slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

  // `GetSubstitution` abstract operation
  // https://tc39.es/ecma262/#sec-getsubstitution
  var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject$2(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace$1(replacement, symbols, function (match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return stringSlice$3(str, 0, position);
        case "'": return stringSlice$3(str, tailPos);
        case '<':
          capture = namedCaptures[stringSlice$3(ch, 1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  };

  var apply$1 = functionApply;
  var call$2 = functionCall;
  var uncurryThis$8 = functionUncurryThis;
  var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
  var fails$6 = fails$k;
  var anObject$2 = anObject$g;
  var isCallable$3 = isCallable$j;
  var toIntegerOrInfinity = toIntegerOrInfinity$4;
  var toLength$3 = toLength$6;
  var toString$5 = toString$9;
  var requireObjectCoercible$5 = requireObjectCoercible$a;
  var advanceStringIndex$1 = advanceStringIndex$3;
  var getMethod$1 = getMethod$6;
  var getSubstitution = getSubstitution$1;
  var regExpExec = regexpExecAbstract;
  var wellKnownSymbol$6 = wellKnownSymbol$i;

  var REPLACE = wellKnownSymbol$6('replace');
  var max$1 = Math.max;
  var min$3 = Math.min;
  var concat = uncurryThis$8([].concat);
  var push$1 = uncurryThis$8([].push);
  var stringIndexOf$1 = uncurryThis$8(''.indexOf);
  var stringSlice$2 = uncurryThis$8(''.slice);

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
    return 'a'.replace(/./, '$0') === '$0';
  })();

  // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }
    return false;
  })();

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function () {
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
    return ''.replace(re, '$<a>') !== '7';
  });

  // @@replace logic
  fixRegExpWellKnownSymbolLogic$1('replace', function (_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible$5(this);
        var replacer = searchValue == undefined ? undefined : getMethod$1(searchValue, REPLACE);
        return replacer
          ? call$2(replacer, searchValue, O, replaceValue)
          : call$2(nativeReplace, toString$5(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (string, replaceValue) {
        var rx = anObject$2(this);
        var S = toString$5(string);

        if (
          typeof replaceValue == 'string' &&
          stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
          stringIndexOf$1(replaceValue, '$<') === -1
        ) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }

        var functionalReplace = isCallable$3(replaceValue);
        if (!functionalReplace) replaceValue = toString$5(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;

          push$1(results, result);
          if (!global) break;

          var matchStr = toString$5(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex$1(S, toLength$3(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = toString$5(result[0]);
          var position = max$1(min$3(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) push$1(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined) push$1(replacerArgs, namedCaptures);
            var replacement = toString$5(apply$1(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice$2(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice$2(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

  var isObject = isObject$8;
  var classof$1 = classofRaw$1;
  var wellKnownSymbol$5 = wellKnownSymbol$i;

  var MATCH$1 = wellKnownSymbol$5('match');

  // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$1(it) == 'RegExp');
  };

  var global$5 = global$J;
  var isRegExp$1 = isRegexp;

  var TypeError$2 = global$5.TypeError;

  var notARegexp = function (it) {
    if (isRegExp$1(it)) {
      throw TypeError$2("The method doesn't accept regular expressions");
    } return it;
  };

  var wellKnownSymbol$4 = wellKnownSymbol$i;

  var MATCH = wellKnownSymbol$4('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) { /* empty */ }
    } return false;
  };

  var $$7 = _export;
  var uncurryThis$7 = functionUncurryThis;
  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var toLength$2 = toLength$6;
  var toString$4 = toString$9;
  var notARegExp$2 = notARegexp;
  var requireObjectCoercible$4 = requireObjectCoercible$a;
  var correctIsRegExpLogic$2 = correctIsRegexpLogic;

  // eslint-disable-next-line es/no-string-prototype-startswith -- safe
  var un$StartsWith = uncurryThis$7(''.startsWith);
  var stringSlice$1 = uncurryThis$7(''.slice);
  var min$2 = Math.min;

  var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2('startsWith');
  // https://github.com/zloirock/core-js/pull/702
  var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
    var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'startsWith');
    return descriptor && !descriptor.writable;
  }();

  // `String.prototype.startsWith` method
  // https://tc39.es/ecma262/#sec-string.prototype.startswith
  $$7({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
    startsWith: function startsWith(searchString /* , position = 0 */) {
      var that = toString$4(requireObjectCoercible$4(this));
      notARegExp$2(searchString);
      var index = toLength$2(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = toString$4(searchString);
      return un$StartsWith
        ? un$StartsWith(that, search, index)
        : stringSlice$1(that, index, index + search.length) === search;
    }
  });

  var wellKnownSymbol$3 = wellKnownSymbol$i;
  var create$1 = objectCreate;
  var definePropertyModule$1 = objectDefineProperty;

  var UNSCOPABLES = wellKnownSymbol$3('unscopables');
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create$1(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables$1 = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var fails$5 = fails$k;

  var correctPrototypeGetter = !fails$5(function () {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var global$4 = global$J;
  var hasOwn = hasOwnProperty_1;
  var isCallable$2 = isCallable$j;
  var toObject$1 = toObject$4;
  var sharedKey = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

  var IE_PROTO = sharedKey('IE_PROTO');
  var Object$1 = global$4.Object;
  var ObjectPrototype = Object$1.prototype;

  // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function (O) {
    var object = toObject$1(O);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable$2(constructor) && object instanceof constructor) {
      return constructor.prototype;
    } return object instanceof Object$1 ? ObjectPrototype : null;
  };

  var fails$4 = fails$k;
  var isCallable$1 = isCallable$j;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var redefine$2 = redefine$7.exports;
  var wellKnownSymbol$2 = wellKnownSymbol$i;

  var ITERATOR$2 = wellKnownSymbol$2('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false;

  // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

  /* eslint-disable es/no-array-prototype-keys -- safe */
  if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$4(function () {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype$2[ITERATOR$2].call(test) !== test;
  });

  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

  // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
  if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
    redefine$2(IteratorPrototype$2, ITERATOR$2, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$2,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
  var create = objectCreate;
  var createPropertyDescriptor$1 = createPropertyDescriptor$4;
  var setToStringTag$1 = setToStringTag$3;
  var Iterators$2 = iterators;

  var returnThis$1 = function () { return this; };

  var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });
    setToStringTag$1(IteratorConstructor, TO_STRING_TAG, false);
    Iterators$2[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var $$6 = _export;
  var call$1 = functionCall;
  var FunctionName = functionName;
  var isCallable = isCallable$j;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf = objectGetPrototypeOf;
  var setPrototypeOf = objectSetPrototypeOf;
  var setToStringTag = setToStringTag$3;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
  var redefine$1 = redefine$7.exports;
  var wellKnownSymbol$1 = wellKnownSymbol$i;
  var Iterators$1 = iterators;
  var IteratorsCore = iteratorsCore;

  var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol$1('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function () { return this; };

  var defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
        case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
        case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
      } return function () { return new IteratorConstructor(this); };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1]
      || IterablePrototype['@@iterator']
      || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
            redefine$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
          }
        }
        // Set @@toStringTag to native iterators
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    }

    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() { return call$1(nativeIterator, this); };
      }
    }

    // export additional methods
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }

    // define iterator
    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
      redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
    }
    Iterators$1[NAME] = defaultIterator;

    return methods;
  };

  var toIndexedObject = toIndexedObject$5;
  var addToUnscopables = addToUnscopables$1;
  var Iterators = iterators;
  var InternalStateModule = internalState;
  var defineProperty = objectDefineProperty.f;
  var defineIterator = defineIterator$1;
  var DESCRIPTORS = descriptors;

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return { value: undefined, done: true };
    }
    if (kind == 'keys') return { value: index, done: false };
    if (kind == 'values') return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  var values = Iterators.Arguments = Iterators.Array;

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  // V8 ~ Chrome 45- bug
  if (DESCRIPTORS && values.name !== 'values') try {
    defineProperty(values, 'name', { value: 'values' });
  } catch (error) { /* empty */ }

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
  var documentCreateElement = documentCreateElement$2;

  var classList = documentCreateElement('span').classList;
  var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;

  var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;

  var global$3 = global$J;
  var DOMIterables = domIterables;
  var DOMTokenListPrototype = domTokenListPrototype;
  var ArrayIteratorMethods = es_array_iterator;
  var createNonEnumerableProperty = createNonEnumerableProperty$6;
  var wellKnownSymbol = wellKnownSymbol$i;

  var ITERATOR = wellKnownSymbol('iterator');
  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var ArrayValues = ArrayIteratorMethods.values;

  var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
    if (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
      if (!CollectionPrototype[TO_STRING_TAG]) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
      }
      if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
        }
      }
    }
  };

  for (var COLLECTION_NAME in DOMIterables) {
    handlePrototype(global$3[COLLECTION_NAME] && global$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
  }

  handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var global$2 = global$J;
  var aCallable = aCallable$6;
  var toObject = toObject$4;
  var IndexedObject = indexedObject;
  var lengthOfArrayLike$1 = lengthOfArrayLike$4;

  var TypeError$1 = global$2.TypeError;

  // `Array.prototype.{ reduce, reduceRight }` methods implementation
  var createMethod$1 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aCallable(callbackfn);
      var O = toObject(that);
      var self = IndexedObject(O);
      var length = lengthOfArrayLike$1(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError$1('Reduce of empty array with no initial value');
        }
      }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$1(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$1(true)
  };

  var fails$3 = fails$k;

  var arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails$3(function () {
      // eslint-disable-next-line no-useless-call -- required for testing
      method.call(null, argument || function () { return 1; }, 1);
    });
  };

  var $$5 = _export;
  var $reduce = arrayReduce.left;
  var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
  var CHROME_VERSION = engineV8Version;
  var IS_NODE = engineIsNode;

  var STRICT_METHOD$1 = arrayMethodIsStrict$1('reduce');
  // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  $$5({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {
    reduce: function reduce(callbackfn /* , initialValue */) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });

  var $$4 = _export;
  var uncurryThis$6 = functionUncurryThis;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var toLength$1 = toLength$6;
  var toString$3 = toString$9;
  var notARegExp$1 = notARegexp;
  var requireObjectCoercible$3 = requireObjectCoercible$a;
  var correctIsRegExpLogic$1 = correctIsRegexpLogic;

  // eslint-disable-next-line es/no-string-prototype-endswith -- safe
  var un$EndsWith = uncurryThis$6(''.endsWith);
  var slice = uncurryThis$6(''.slice);
  var min$1 = Math.min;

  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1('endsWith');
  // https://github.com/zloirock/core-js/pull/702
  var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
    return descriptor && !descriptor.writable;
  }();

  // `String.prototype.endsWith` method
  // https://tc39.es/ecma262/#sec-string.prototype.endswith
  $$4({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    endsWith: function endsWith(searchString /* , endPosition = @length */) {
      var that = toString$3(requireObjectCoercible$3(this));
      notARegExp$1(searchString);
      var endPosition = arguments.length > 1 ? arguments[1] : undefined;
      var len = that.length;
      var end = endPosition === undefined ? len : min$1(toLength$1(endPosition), len);
      var search = toString$3(searchString);
      return un$EndsWith
        ? un$EndsWith(that, search, end)
        : slice(that, end - search.length, end) === search;
    }
  });

  var toPropertyKey = toPropertyKey$3;
  var definePropertyModule = objectDefineProperty;
  var createPropertyDescriptor = createPropertyDescriptor$4;

  var createProperty$1 = function (object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var global$1 = global$J;
  var toAbsoluteIndex = toAbsoluteIndex$2;
  var lengthOfArrayLike = lengthOfArrayLike$4;
  var createProperty = createProperty$1;

  var Array$1 = global$1.Array;
  var max = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = Array$1(max(fin - k, 0));
    for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  };

  var apply = functionApply;
  var call = functionCall;
  var uncurryThis$5 = functionUncurryThis;
  var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
  var isRegExp = isRegexp;
  var anObject$1 = anObject$g;
  var requireObjectCoercible$2 = requireObjectCoercible$a;
  var speciesConstructor = speciesConstructor$2;
  var advanceStringIndex = advanceStringIndex$3;
  var toLength = toLength$6;
  var toString$2 = toString$9;
  var getMethod = getMethod$6;
  var arraySlice = arraySliceSimple;
  var callRegExpExec = regexpExecAbstract;
  var regexpExec = regexpExec$3;
  var stickyHelpers = regexpStickyHelpers;
  var fails$2 = fails$k;

  var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
  var MAX_UINT32 = 0xFFFFFFFF;
  var min = Math.min;
  var $push = [].push;
  var exec = uncurryThis$5(/./.exec);
  var push = uncurryThis$5($push);
  var stringSlice = uncurryThis$5(''.slice);

  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function () {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  // @@split logic
  fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = toString$2(requireObjectCoercible$2(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) {
          return call(nativeSplit, string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = call(regexpExec, separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            push(output, stringSlice(string, lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !exec(separatorCopy, '')) push(output, '');
        } else push(output, stringSlice(string, lastLastIndex));
        return output.length > lim ? arraySlice(output, 0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible$2(this);
        var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
        return splitter
          ? call(splitter, separator, O, limit)
          : call(internalSplit, toString$2(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (string, limit) {
        var rx = anObject$1(this);
        var S = toString$2(string);
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

        if (res.done) return res.value;

        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (UNSUPPORTED_Y ? 'g' : 'y');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
          var e;
          if (
            z === null ||
            (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push(A, stringSlice(S, p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              push(A, z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        push(A, stringSlice(S, p));
        return A;
      }
    ];
  }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

  var raf$1 = {exports: {}};

  var performanceNow = {exports: {}};

  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      performanceNow.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      performanceNow.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(commonjsGlobal);

  var now = performanceNow.exports
    , root = typeof window === 'undefined' ? commonjsGlobal : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root['request' + suffix]
    , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for(var i$1 = 0; !raf && i$1 < vendors.length; i$1++) {
    raf = root[vendors[i$1] + 'Request' + suffix];
    caf = root[vendors[i$1] + 'Cancel' + suffix]
        || root[vendors[i$1] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = now()
          , next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  raf$1.exports = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn)
  };
  raf$1.exports.cancel = function() {
    caf.apply(root, arguments);
  };
  raf$1.exports.polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };

  var requestAnimationFrame = raf$1.exports;

  // a string of all valid unicode whitespaces
  var whitespaces$2 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
    '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var uncurryThis$4 = functionUncurryThis;
  var requireObjectCoercible$1 = requireObjectCoercible$a;
  var toString$1 = toString$9;
  var whitespaces$1 = whitespaces$2;

  var replace = uncurryThis$4(''.replace);
  var whitespace = '[' + whitespaces$1 + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$');

  // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
  var createMethod = function (TYPE) {
    return function ($this) {
      var string = toString$1(requireObjectCoercible$1($this));
      if (TYPE & 1) string = replace(string, ltrim, '');
      if (TYPE & 2) string = replace(string, rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };

  var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
  var fails$1 = fails$k;
  var whitespaces = whitespaces$2;

  var non = '\u200B\u0085\u180E';

  // check that a method works with the correct list
  // of whitespaces and has a correct name
  var stringTrimForced = function (METHOD_NAME) {
    return fails$1(function () {
      return !!whitespaces[METHOD_NAME]()
        || non[METHOD_NAME]() !== non
        || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);
    });
  };

  var $$3 = _export;
  var $trim = stringTrim.trim;
  var forcedStringTrimMethod = stringTrimForced;

  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  $$3({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  /*
  	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
  	http://www.phpied.com/rgb-color-parser-in-javascript/
  */

  var rgbcolor = function(color_string) {
      this.ok = false;
      this.alpha = 1.0;

      // strip any leading #
      if (color_string.charAt(0) == '#') { // remove # if any
          color_string = color_string.substr(1,6);
      }

      color_string = color_string.replace(/ /g,'');
      color_string = color_string.toLowerCase();

      // before getting into regexps, try simple matches
      // and overwrite the input
      var simple_colors = {
          aliceblue: 'f0f8ff',
          antiquewhite: 'faebd7',
          aqua: '00ffff',
          aquamarine: '7fffd4',
          azure: 'f0ffff',
          beige: 'f5f5dc',
          bisque: 'ffe4c4',
          black: '000000',
          blanchedalmond: 'ffebcd',
          blue: '0000ff',
          blueviolet: '8a2be2',
          brown: 'a52a2a',
          burlywood: 'deb887',
          cadetblue: '5f9ea0',
          chartreuse: '7fff00',
          chocolate: 'd2691e',
          coral: 'ff7f50',
          cornflowerblue: '6495ed',
          cornsilk: 'fff8dc',
          crimson: 'dc143c',
          cyan: '00ffff',
          darkblue: '00008b',
          darkcyan: '008b8b',
          darkgoldenrod: 'b8860b',
          darkgray: 'a9a9a9',
          darkgreen: '006400',
          darkkhaki: 'bdb76b',
          darkmagenta: '8b008b',
          darkolivegreen: '556b2f',
          darkorange: 'ff8c00',
          darkorchid: '9932cc',
          darkred: '8b0000',
          darksalmon: 'e9967a',
          darkseagreen: '8fbc8f',
          darkslateblue: '483d8b',
          darkslategray: '2f4f4f',
          darkturquoise: '00ced1',
          darkviolet: '9400d3',
          deeppink: 'ff1493',
          deepskyblue: '00bfff',
          dimgray: '696969',
          dodgerblue: '1e90ff',
          feldspar: 'd19275',
          firebrick: 'b22222',
          floralwhite: 'fffaf0',
          forestgreen: '228b22',
          fuchsia: 'ff00ff',
          gainsboro: 'dcdcdc',
          ghostwhite: 'f8f8ff',
          gold: 'ffd700',
          goldenrod: 'daa520',
          gray: '808080',
          green: '008000',
          greenyellow: 'adff2f',
          honeydew: 'f0fff0',
          hotpink: 'ff69b4',
          indianred : 'cd5c5c',
          indigo : '4b0082',
          ivory: 'fffff0',
          khaki: 'f0e68c',
          lavender: 'e6e6fa',
          lavenderblush: 'fff0f5',
          lawngreen: '7cfc00',
          lemonchiffon: 'fffacd',
          lightblue: 'add8e6',
          lightcoral: 'f08080',
          lightcyan: 'e0ffff',
          lightgoldenrodyellow: 'fafad2',
          lightgrey: 'd3d3d3',
          lightgreen: '90ee90',
          lightpink: 'ffb6c1',
          lightsalmon: 'ffa07a',
          lightseagreen: '20b2aa',
          lightskyblue: '87cefa',
          lightslateblue: '8470ff',
          lightslategray: '778899',
          lightsteelblue: 'b0c4de',
          lightyellow: 'ffffe0',
          lime: '00ff00',
          limegreen: '32cd32',
          linen: 'faf0e6',
          magenta: 'ff00ff',
          maroon: '800000',
          mediumaquamarine: '66cdaa',
          mediumblue: '0000cd',
          mediumorchid: 'ba55d3',
          mediumpurple: '9370d8',
          mediumseagreen: '3cb371',
          mediumslateblue: '7b68ee',
          mediumspringgreen: '00fa9a',
          mediumturquoise: '48d1cc',
          mediumvioletred: 'c71585',
          midnightblue: '191970',
          mintcream: 'f5fffa',
          mistyrose: 'ffe4e1',
          moccasin: 'ffe4b5',
          navajowhite: 'ffdead',
          navy: '000080',
          oldlace: 'fdf5e6',
          olive: '808000',
          olivedrab: '6b8e23',
          orange: 'ffa500',
          orangered: 'ff4500',
          orchid: 'da70d6',
          palegoldenrod: 'eee8aa',
          palegreen: '98fb98',
          paleturquoise: 'afeeee',
          palevioletred: 'd87093',
          papayawhip: 'ffefd5',
          peachpuff: 'ffdab9',
          peru: 'cd853f',
          pink: 'ffc0cb',
          plum: 'dda0dd',
          powderblue: 'b0e0e6',
          purple: '800080',
          rebeccapurple: '663399',
          red: 'ff0000',
          rosybrown: 'bc8f8f',
          royalblue: '4169e1',
          saddlebrown: '8b4513',
          salmon: 'fa8072',
          sandybrown: 'f4a460',
          seagreen: '2e8b57',
          seashell: 'fff5ee',
          sienna: 'a0522d',
          silver: 'c0c0c0',
          skyblue: '87ceeb',
          slateblue: '6a5acd',
          slategray: '708090',
          snow: 'fffafa',
          springgreen: '00ff7f',
          steelblue: '4682b4',
          tan: 'd2b48c',
          teal: '008080',
          thistle: 'd8bfd8',
          tomato: 'ff6347',
          turquoise: '40e0d0',
          violet: 'ee82ee',
          violetred: 'd02090',
          wheat: 'f5deb3',
          white: 'ffffff',
          whitesmoke: 'f5f5f5',
          yellow: 'ffff00',
          yellowgreen: '9acd32'
      };
      color_string = simple_colors[color_string] || color_string;
      // emd of simple type-in colors

      // array of color definition objects
      var color_defs = [
          {
              re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
              example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
              process: function (bits){
                  return [
                      parseInt(bits[1]),
                      parseInt(bits[2]),
                      parseInt(bits[3]),
                      parseFloat(bits[4])
                  ];
              }
          },
          {
              re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
              example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
              process: function (bits){
                  return [
                      parseInt(bits[1]),
                      parseInt(bits[2]),
                      parseInt(bits[3])
                  ];
              }
          },
          {
              re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              example: ['#00ff00', '336699'],
              process: function (bits){
                  return [
                      parseInt(bits[1], 16),
                      parseInt(bits[2], 16),
                      parseInt(bits[3], 16)
                  ];
              }
          },
          {
              re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              example: ['#fb0', 'f0f'],
              process: function (bits){
                  return [
                      parseInt(bits[1] + bits[1], 16),
                      parseInt(bits[2] + bits[2], 16),
                      parseInt(bits[3] + bits[3], 16)
                  ];
              }
          }
      ];

      // search through the definitions to find a match
      for (var i = 0; i < color_defs.length; i++) {
          var re = color_defs[i].re;
          var processor = color_defs[i].process;
          var bits = re.exec(color_string);
          if (bits) {
              var channels = processor(bits);
              this.r = channels[0];
              this.g = channels[1];
              this.b = channels[2];
              if (channels.length > 3) {
                  this.alpha = channels[3];
              }
              this.ok = true;
          }

      }

      // validate/cleanup values
      this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
      this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
      this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
      this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

      // some getters
      this.toRGB = function () {
          return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
      };
      this.toRGBA = function () {
          return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
      };
      this.toHex = function () {
          var r = this.r.toString(16);
          var g = this.g.toString(16);
          var b = this.b.toString(16);
          if (r.length == 1) r = '0' + r;
          if (g.length == 1) g = '0' + g;
          if (b.length == 1) b = '0' + b;
          return '#' + r + g + b;
      };

      // help
      this.getHelpXML = function () {

          var examples = new Array();
          // add regexps
          for (var i = 0; i < color_defs.length; i++) {
              var example = color_defs[i].example;
              for (var j = 0; j < example.length; j++) {
                  examples[examples.length] = example[j];
              }
          }
          // add type-in colors
          for (var sc in simple_colors) {
              examples[examples.length] = sc;
          }

          var xml = document.createElement('ul');
          xml.setAttribute('id', 'rgbcolor-examples');
          for (var i = 0; i < examples.length; i++) {
              try {
                  var list_item = document.createElement('li');
                  var list_color = new RGBColor(examples[i]);
                  var example_div = document.createElement('div');
                  example_div.style.cssText =
                          'margin: 3px; '
                          + 'border: 1px solid black; '
                          + 'background:' + list_color.toHex() + '; '
                          + 'color:' + list_color.toHex()
                  ;
                  example_div.appendChild(document.createTextNode('test'));
                  var list_item_value = document.createTextNode(
                      ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                  );
                  list_item.appendChild(example_div);
                  list_item.appendChild(list_item_value);
                  xml.appendChild(list_item);

              } catch(e){}
          }
          return xml;

      };

  };

  /* eslint-disable es/no-array-prototype-indexof -- required for testing */
  var $$2 = _export;
  var uncurryThis$3 = functionUncurryThis;
  var $IndexOf = arrayIncludes.indexOf;
  var arrayMethodIsStrict = arrayMethodIsStrict$2;

  var un$IndexOf = uncurryThis$3([].indexOf);

  var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
  var STRICT_METHOD = arrayMethodIsStrict('indexOf');

  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  $$2({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? un$IndexOf(this, searchElement, fromIndex) || 0
        : $IndexOf(this, searchElement, fromIndex);
    }
  });

  var $$1 = _export;
  var uncurryThis$2 = functionUncurryThis;
  var notARegExp = notARegexp;
  var requireObjectCoercible = requireObjectCoercible$a;
  var toString = toString$9;
  var correctIsRegExpLogic = correctIsRegexpLogic;

  var stringIndexOf = uncurryThis$2(''.indexOf);

  // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes
  $$1({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~stringIndexOf(
        toString(requireObjectCoercible(this)),
        toString(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : undefined
      );
    }
  });

  var classof = classofRaw$1;

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe
  var isArray$1 = Array.isArray || function isArray(argument) {
    return classof(argument) == 'Array';
  };

  var $ = _export;
  var uncurryThis$1 = functionUncurryThis;
  var isArray = isArray$1;

  var un$Reverse = uncurryThis$1([].reverse);
  var test = [1, 2];

  // `Array.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-array.prototype.reverse
  // fix for Safari 12.0 bug
  // https://bugs.webkit.org/show_bug.cgi?id=188794
  $({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
    reverse: function reverse() {
      // eslint-disable-next-line no-self-assign -- dirty hack
      if (isArray(this)) this.length = this.length;
      return un$Reverse(this);
    }
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var t=function(r,e){return (t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r;}||function(t,r){for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e]);})(r,e)};function r(r,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function i(){this.constructor=r;}t(r,e),r.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i);}function e(t){var r="";Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.type===_.CLOSE_PATH)r+="z";else if(i.type===_.HORIZ_LINE_TO)r+=(i.relative?"h":"H")+i.x;else if(i.type===_.VERT_LINE_TO)r+=(i.relative?"v":"V")+i.y;else if(i.type===_.MOVE_TO)r+=(i.relative?"m":"M")+i.x+" "+i.y;else if(i.type===_.LINE_TO)r+=(i.relative?"l":"L")+i.x+" "+i.y;else if(i.type===_.CURVE_TO)r+=(i.relative?"c":"C")+i.x1+" "+i.y1+" "+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_CURVE_TO)r+=(i.relative?"s":"S")+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.QUAD_TO)r+=(i.relative?"q":"Q")+i.x1+" "+i.y1+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_QUAD_TO)r+=(i.relative?"t":"T")+i.x+" "+i.y;else {if(i.type!==_.ARC)throw new Error('Unexpected command type "'+i.type+'" at index '+e+".");r+=(i.relative?"a":"A")+i.rX+" "+i.rY+" "+i.xRot+" "+ +i.lArcFlag+" "+ +i.sweepFlag+" "+i.x+" "+i.y;}}return r}function i(t,r){var e=t[0],i=t[1];return [e*Math.cos(r)-i*Math.sin(r),e*Math.sin(r)+i*Math.cos(r)]}function a(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var e=0;e<t.length;e++)if("number"!=typeof t[e])throw new Error("assertNumbers arguments["+e+"] is not a number. "+typeof t[e]+" == typeof "+t[e]);return !0}var n=Math.PI;function o(t,r,e){t.lArcFlag=0===t.lArcFlag?0:1,t.sweepFlag=0===t.sweepFlag?0:1;var a=t.rX,o=t.rY,s=t.x,u=t.y;a=Math.abs(t.rX),o=Math.abs(t.rY);var h=i([(r-s)/2,(e-u)/2],-t.xRot/180*n),c=h[0],y=h[1],p=Math.pow(c,2)/Math.pow(a,2)+Math.pow(y,2)/Math.pow(o,2);1<p&&(a*=Math.sqrt(p),o*=Math.sqrt(p)),t.rX=a,t.rY=o;var m=Math.pow(a,2)*Math.pow(y,2)+Math.pow(o,2)*Math.pow(c,2),O=(t.lArcFlag!==t.sweepFlag?1:-1)*Math.sqrt(Math.max(0,(Math.pow(a,2)*Math.pow(o,2)-m)/m)),l=a*y/o*O,T=-o*c/a*O,v=i([l,T],t.xRot/180*n);t.cX=v[0]+(r+s)/2,t.cY=v[1]+(e+u)/2,t.phi1=Math.atan2((y-T)/o,(c-l)/a),t.phi2=Math.atan2((-y-T)/o,(-c-l)/a),0===t.sweepFlag&&t.phi2>t.phi1&&(t.phi2-=2*n),1===t.sweepFlag&&t.phi2<t.phi1&&(t.phi2+=2*n),t.phi1*=180/n,t.phi2*=180/n;}function s(t,r,e){a(t,r,e);var i=t*t+r*r-e*e;if(0>i)return [];if(0===i)return [[t*e/(t*t+r*r),r*e/(t*t+r*r)]];var n=Math.sqrt(i);return [[(t*e+r*n)/(t*t+r*r),(r*e-t*n)/(t*t+r*r)],[(t*e-r*n)/(t*t+r*r),(r*e+t*n)/(t*t+r*r)]]}var u,h=Math.PI/180;function c$1(t,r,e){return (1-e)*t+e*r}function y(t,r,e,i){return t+Math.cos(i/180*n)*r+Math.sin(i/180*n)*e}function p(t,r,e,i){var a=1e-6,n=r-t,o=e-r,s=3*n+3*(i-e)-6*o,u=6*(o-n),h=3*n;return Math.abs(s)<a?[-h/u]:function(t,r,e){void 0===e&&(e=1e-6);var i=t*t/4-r;if(i<-e)return [];if(i<=e)return [-t/2];var a=Math.sqrt(i);return [-t/2-a,-t/2+a]}(u/s,h/s,a)}function m$1(t,r,e,i,a){var n=1-a;return t*(n*n*n)+r*(3*n*n*a)+e*(3*n*a*a)+i*(a*a*a)}!function(t){function r(){return u((function(t,r,e){return t.relative&&(void 0!==t.x1&&(t.x1+=r),void 0!==t.y1&&(t.y1+=e),void 0!==t.x2&&(t.x2+=r),void 0!==t.y2&&(t.y2+=e),void 0!==t.x&&(t.x+=r),void 0!==t.y&&(t.y+=e),t.relative=!1),t}))}function e(){var t=NaN,r=NaN,e=NaN,i=NaN;return u((function(a,n,o){return a.type&_.SMOOTH_CURVE_TO&&(a.type=_.CURVE_TO,t=isNaN(t)?n:t,r=isNaN(r)?o:r,a.x1=a.relative?n-t:2*n-t,a.y1=a.relative?o-r:2*o-r),a.type&_.CURVE_TO?(t=a.relative?n+a.x2:a.x2,r=a.relative?o+a.y2:a.y2):(t=NaN,r=NaN),a.type&_.SMOOTH_QUAD_TO&&(a.type=_.QUAD_TO,e=isNaN(e)?n:e,i=isNaN(i)?o:i,a.x1=a.relative?n-e:2*n-e,a.y1=a.relative?o-i:2*o-i),a.type&_.QUAD_TO?(e=a.relative?n+a.x1:a.x1,i=a.relative?o+a.y1:a.y1):(e=NaN,i=NaN),a}))}function n(){var t=NaN,r=NaN;return u((function(e,i,a){if(e.type&_.SMOOTH_QUAD_TO&&(e.type=_.QUAD_TO,t=isNaN(t)?i:t,r=isNaN(r)?a:r,e.x1=e.relative?i-t:2*i-t,e.y1=e.relative?a-r:2*a-r),e.type&_.QUAD_TO){t=e.relative?i+e.x1:e.x1,r=e.relative?a+e.y1:e.y1;var n=e.x1,o=e.y1;e.type=_.CURVE_TO,e.x1=((e.relative?0:i)+2*n)/3,e.y1=((e.relative?0:a)+2*o)/3,e.x2=(e.x+2*n)/3,e.y2=(e.y+2*o)/3;}else t=NaN,r=NaN;return e}))}function u(t){var r=0,e=0,i=NaN,a=NaN;return function(n){if(isNaN(i)&&!(n.type&_.MOVE_TO))throw new Error("path must start with moveto");var o=t(n,r,e,i,a);return n.type&_.CLOSE_PATH&&(r=i,e=a),void 0!==n.x&&(r=n.relative?r+n.x:n.x),void 0!==n.y&&(e=n.relative?e+n.y:n.y),n.type&_.MOVE_TO&&(i=r,a=e),o}}function O(t,r,e,i,n,o){return a(t,r,e,i,n,o),u((function(a,s,u,h){var c=a.x1,y=a.x2,p=a.relative&&!isNaN(h),m=void 0!==a.x?a.x:p?0:s,O=void 0!==a.y?a.y:p?0:u;function l(t){return t*t}a.type&_.HORIZ_LINE_TO&&0!==r&&(a.type=_.LINE_TO,a.y=a.relative?0:u),a.type&_.VERT_LINE_TO&&0!==e&&(a.type=_.LINE_TO,a.x=a.relative?0:s),void 0!==a.x&&(a.x=a.x*t+O*e+(p?0:n)),void 0!==a.y&&(a.y=m*r+a.y*i+(p?0:o)),void 0!==a.x1&&(a.x1=a.x1*t+a.y1*e+(p?0:n)),void 0!==a.y1&&(a.y1=c*r+a.y1*i+(p?0:o)),void 0!==a.x2&&(a.x2=a.x2*t+a.y2*e+(p?0:n)),void 0!==a.y2&&(a.y2=y*r+a.y2*i+(p?0:o));var T=t*i-r*e;if(void 0!==a.xRot&&(1!==t||0!==r||0!==e||1!==i))if(0===T)delete a.rX,delete a.rY,delete a.xRot,delete a.lArcFlag,delete a.sweepFlag,a.type=_.LINE_TO;else {var v=a.xRot*Math.PI/180,f=Math.sin(v),N=Math.cos(v),x=1/l(a.rX),d=1/l(a.rY),E=l(N)*x+l(f)*d,A=2*f*N*(x-d),C=l(f)*x+l(N)*d,M=E*i*i-A*r*i+C*r*r,R=A*(t*i+r*e)-2*(E*e*i+C*t*r),g=E*e*e-A*t*e+C*t*t,I=(Math.atan2(R,M-g)+Math.PI)%Math.PI/2,S=Math.sin(I),L=Math.cos(I);a.rX=Math.abs(T)/Math.sqrt(M*l(L)+R*S*L+g*l(S)),a.rY=Math.abs(T)/Math.sqrt(M*l(S)-R*S*L+g*l(L)),a.xRot=180*I/Math.PI;}return void 0!==a.sweepFlag&&0>T&&(a.sweepFlag=+!a.sweepFlag),a}))}function l(){return function(t){var r={};for(var e in t)r[e]=t[e];return r}}t.ROUND=function(t){function r(r){return Math.round(r*t)/t}return void 0===t&&(t=1e13),a(t),function(t){return void 0!==t.x1&&(t.x1=r(t.x1)),void 0!==t.y1&&(t.y1=r(t.y1)),void 0!==t.x2&&(t.x2=r(t.x2)),void 0!==t.y2&&(t.y2=r(t.y2)),void 0!==t.x&&(t.x=r(t.x)),void 0!==t.y&&(t.y=r(t.y)),void 0!==t.rX&&(t.rX=r(t.rX)),void 0!==t.rY&&(t.rY=r(t.rY)),t}},t.TO_ABS=r,t.TO_REL=function(){return u((function(t,r,e){return t.relative||(void 0!==t.x1&&(t.x1-=r),void 0!==t.y1&&(t.y1-=e),void 0!==t.x2&&(t.x2-=r),void 0!==t.y2&&(t.y2-=e),void 0!==t.x&&(t.x-=r),void 0!==t.y&&(t.y-=e),t.relative=!0),t}))},t.NORMALIZE_HVZ=function(t,r,e){return void 0===t&&(t=!0),void 0===r&&(r=!0),void 0===e&&(e=!0),u((function(i,a,n,o,s){if(isNaN(o)&&!(i.type&_.MOVE_TO))throw new Error("path must start with moveto");return r&&i.type&_.HORIZ_LINE_TO&&(i.type=_.LINE_TO,i.y=i.relative?0:n),e&&i.type&_.VERT_LINE_TO&&(i.type=_.LINE_TO,i.x=i.relative?0:a),t&&i.type&_.CLOSE_PATH&&(i.type=_.LINE_TO,i.x=i.relative?o-a:o,i.y=i.relative?s-n:s),i.type&_.ARC&&(0===i.rX||0===i.rY)&&(i.type=_.LINE_TO,delete i.rX,delete i.rY,delete i.xRot,delete i.lArcFlag,delete i.sweepFlag),i}))},t.NORMALIZE_ST=e,t.QT_TO_C=n,t.INFO=u,t.SANITIZE=function(t){void 0===t&&(t=0),a(t);var r=NaN,e=NaN,i=NaN,n=NaN;return u((function(a,o,s,u,h){var c=Math.abs,y=!1,p=0,m=0;if(a.type&_.SMOOTH_CURVE_TO&&(p=isNaN(r)?0:o-r,m=isNaN(e)?0:s-e),a.type&(_.CURVE_TO|_.SMOOTH_CURVE_TO)?(r=a.relative?o+a.x2:a.x2,e=a.relative?s+a.y2:a.y2):(r=NaN,e=NaN),a.type&_.SMOOTH_QUAD_TO?(i=isNaN(i)?o:2*o-i,n=isNaN(n)?s:2*s-n):a.type&_.QUAD_TO?(i=a.relative?o+a.x1:a.x1,n=a.relative?s+a.y1:a.y2):(i=NaN,n=NaN),a.type&_.LINE_COMMANDS||a.type&_.ARC&&(0===a.rX||0===a.rY||!a.lArcFlag)||a.type&_.CURVE_TO||a.type&_.SMOOTH_CURVE_TO||a.type&_.QUAD_TO||a.type&_.SMOOTH_QUAD_TO){var O=void 0===a.x?0:a.relative?a.x:a.x-o,l=void 0===a.y?0:a.relative?a.y:a.y-s;p=isNaN(i)?void 0===a.x1?p:a.relative?a.x:a.x1-o:i-o,m=isNaN(n)?void 0===a.y1?m:a.relative?a.y:a.y1-s:n-s;var T=void 0===a.x2?0:a.relative?a.x:a.x2-o,v=void 0===a.y2?0:a.relative?a.y:a.y2-s;c(O)<=t&&c(l)<=t&&c(p)<=t&&c(m)<=t&&c(T)<=t&&c(v)<=t&&(y=!0);}return a.type&_.CLOSE_PATH&&c(o-u)<=t&&c(s-h)<=t&&(y=!0),y?[]:a}))},t.MATRIX=O,t.ROTATE=function(t,r,e){void 0===r&&(r=0),void 0===e&&(e=0),a(t,r,e);var i=Math.sin(t),n=Math.cos(t);return O(n,i,-i,n,r-r*n+e*i,e-r*i-e*n)},t.TRANSLATE=function(t,r){return void 0===r&&(r=0),a(t,r),O(1,0,0,1,t,r)},t.SCALE=function(t,r){return void 0===r&&(r=t),a(t,r),O(t,0,0,r,0,0)},t.SKEW_X=function(t){return a(t),O(1,0,Math.atan(t),1,0,0)},t.SKEW_Y=function(t){return a(t),O(1,Math.atan(t),0,1,0,0)},t.X_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(-1,0,0,1,t,0)},t.Y_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(1,0,0,-1,0,t)},t.A_TO_C=function(){return u((function(t,r,e){return _.ARC===t.type?function(t,r,e){var a,n,s,u;t.cX||o(t,r,e);for(var y=Math.min(t.phi1,t.phi2),p=Math.max(t.phi1,t.phi2)-y,m=Math.ceil(p/90),O=new Array(m),l=r,T=e,v=0;v<m;v++){var f=c$1(t.phi1,t.phi2,v/m),N=c$1(t.phi1,t.phi2,(v+1)/m),x=N-f,d=4/3*Math.tan(x*h/4),E=[Math.cos(f*h)-d*Math.sin(f*h),Math.sin(f*h)+d*Math.cos(f*h)],A=E[0],C=E[1],M=[Math.cos(N*h),Math.sin(N*h)],R=M[0],g=M[1],I=[R+d*Math.sin(N*h),g-d*Math.cos(N*h)],S=I[0],L=I[1];O[v]={relative:t.relative,type:_.CURVE_TO};var H=function(r,e){var a=i([r*t.rX,e*t.rY],t.xRot),n=a[0],o=a[1];return [t.cX+n,t.cY+o]};a=H(A,C),O[v].x1=a[0],O[v].y1=a[1],n=H(S,L),O[v].x2=n[0],O[v].y2=n[1],s=H(R,g),O[v].x=s[0],O[v].y=s[1],t.relative&&(O[v].x1-=l,O[v].y1-=T,O[v].x2-=l,O[v].y2-=T,O[v].x-=l,O[v].y-=T),l=(u=[O[v].x,O[v].y])[0],T=u[1];}return O}(t,t.relative?0:r,t.relative?0:e):t}))},t.ANNOTATE_ARCS=function(){return u((function(t,r,e){return t.relative&&(r=0,e=0),_.ARC===t.type&&o(t,r,e),t}))},t.CLONE=l,t.CALCULATE_BOUNDS=function(){var t=function(t){var r={};for(var e in t)r[e]=t[e];return r},i=r(),a=n(),h=e(),c=u((function(r,e,n){var u=h(a(i(t(r))));function O(t){t>c.maxX&&(c.maxX=t),t<c.minX&&(c.minX=t);}function l(t){t>c.maxY&&(c.maxY=t),t<c.minY&&(c.minY=t);}if(u.type&_.DRAWING_COMMANDS&&(O(e),l(n)),u.type&_.HORIZ_LINE_TO&&O(u.x),u.type&_.VERT_LINE_TO&&l(u.y),u.type&_.LINE_TO&&(O(u.x),l(u.y)),u.type&_.CURVE_TO){O(u.x),l(u.y);for(var T=0,v=p(e,u.x1,u.x2,u.x);T<v.length;T++){0<(w=v[T])&&1>w&&O(m$1(e,u.x1,u.x2,u.x,w));}for(var f=0,N=p(n,u.y1,u.y2,u.y);f<N.length;f++){0<(w=N[f])&&1>w&&l(m$1(n,u.y1,u.y2,u.y,w));}}if(u.type&_.ARC){O(u.x),l(u.y),o(u,e,n);for(var x=u.xRot/180*Math.PI,d=Math.cos(x)*u.rX,E=Math.sin(x)*u.rX,A=-Math.sin(x)*u.rY,C=Math.cos(x)*u.rY,M=u.phi1<u.phi2?[u.phi1,u.phi2]:-180>u.phi2?[u.phi2+360,u.phi1+360]:[u.phi2,u.phi1],R=M[0],g=M[1],I=function(t){var r=t[0],e=t[1],i=180*Math.atan2(e,r)/Math.PI;return i<R?i+360:i},S=0,L=s(A,-d,0).map(I);S<L.length;S++){(w=L[S])>R&&w<g&&O(y(u.cX,d,A,w));}for(var H=0,U=s(C,-E,0).map(I);H<U.length;H++){var w;(w=U[H])>R&&w<g&&l(y(u.cY,E,C,w));}}return r}));return c.minX=1/0,c.maxX=-1/0,c.minY=1/0,c.maxY=-1/0,c};}(u||(u={}));var O,l=function(){function t(){}return t.prototype.round=function(t){return this.transform(u.ROUND(t))},t.prototype.toAbs=function(){return this.transform(u.TO_ABS())},t.prototype.toRel=function(){return this.transform(u.TO_REL())},t.prototype.normalizeHVZ=function(t,r,e){return this.transform(u.NORMALIZE_HVZ(t,r,e))},t.prototype.normalizeST=function(){return this.transform(u.NORMALIZE_ST())},t.prototype.qtToC=function(){return this.transform(u.QT_TO_C())},t.prototype.aToC=function(){return this.transform(u.A_TO_C())},t.prototype.sanitize=function(t){return this.transform(u.SANITIZE(t))},t.prototype.translate=function(t,r){return this.transform(u.TRANSLATE(t,r))},t.prototype.scale=function(t,r){return this.transform(u.SCALE(t,r))},t.prototype.rotate=function(t,r,e){return this.transform(u.ROTATE(t,r,e))},t.prototype.matrix=function(t,r,e,i,a,n){return this.transform(u.MATRIX(t,r,e,i,a,n))},t.prototype.skewX=function(t){return this.transform(u.SKEW_X(t))},t.prototype.skewY=function(t){return this.transform(u.SKEW_Y(t))},t.prototype.xSymmetry=function(t){return this.transform(u.X_AXIS_SYMMETRY(t))},t.prototype.ySymmetry=function(t){return this.transform(u.Y_AXIS_SYMMETRY(t))},t.prototype.annotateArcs=function(){return this.transform(u.ANNOTATE_ARCS())},t}(),T=function(t){return " "===t||"\t"===t||"\r"===t||"\n"===t},v=function(t){return "0".charCodeAt(0)<=t.charCodeAt(0)&&t.charCodeAt(0)<="9".charCodeAt(0)},f=function(t){function e(){var r=t.call(this)||this;return r.curNumber="",r.curCommandType=-1,r.curCommandRelative=!1,r.canParseCommandOrComma=!0,r.curNumberHasExp=!1,r.curNumberHasExpDigits=!1,r.curNumberHasDecimal=!1,r.curArgs=[],r}return r(e,t),e.prototype.finish=function(t){if(void 0===t&&(t=[]),this.parse(" ",t),0!==this.curArgs.length||!this.canParseCommandOrComma)throw new SyntaxError("Unterminated command at the path end.");return t},e.prototype.parse=function(t,r){var e=this;void 0===r&&(r=[]);for(var i=function(t){r.push(t),e.curArgs.length=0,e.canParseCommandOrComma=!0;},a=0;a<t.length;a++){var n=t[a],o=!(this.curCommandType!==_.ARC||3!==this.curArgs.length&&4!==this.curArgs.length||1!==this.curNumber.length||"0"!==this.curNumber&&"1"!==this.curNumber),s=v(n)&&("0"===this.curNumber&&"0"===n||o);if(!v(n)||s)if("e"!==n&&"E"!==n)if("-"!==n&&"+"!==n||!this.curNumberHasExp||this.curNumberHasExpDigits)if("."!==n||this.curNumberHasExp||this.curNumberHasDecimal||o){if(this.curNumber&&-1!==this.curCommandType){var u=Number(this.curNumber);if(isNaN(u))throw new SyntaxError("Invalid number ending at "+a);if(this.curCommandType===_.ARC)if(0===this.curArgs.length||1===this.curArgs.length){if(0>u)throw new SyntaxError('Expected positive number, got "'+u+'" at index "'+a+'"')}else if((3===this.curArgs.length||4===this.curArgs.length)&&"0"!==this.curNumber&&"1"!==this.curNumber)throw new SyntaxError('Expected a flag, got "'+this.curNumber+'" at index "'+a+'"');this.curArgs.push(u),this.curArgs.length===N[this.curCommandType]&&(_.HORIZ_LINE_TO===this.curCommandType?i({type:_.HORIZ_LINE_TO,relative:this.curCommandRelative,x:u}):_.VERT_LINE_TO===this.curCommandType?i({type:_.VERT_LINE_TO,relative:this.curCommandRelative,y:u}):this.curCommandType===_.MOVE_TO||this.curCommandType===_.LINE_TO||this.curCommandType===_.SMOOTH_QUAD_TO?(i({type:this.curCommandType,relative:this.curCommandRelative,x:this.curArgs[0],y:this.curArgs[1]}),_.MOVE_TO===this.curCommandType&&(this.curCommandType=_.LINE_TO)):this.curCommandType===_.CURVE_TO?i({type:_.CURVE_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x2:this.curArgs[2],y2:this.curArgs[3],x:this.curArgs[4],y:this.curArgs[5]}):this.curCommandType===_.SMOOTH_CURVE_TO?i({type:_.SMOOTH_CURVE_TO,relative:this.curCommandRelative,x2:this.curArgs[0],y2:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.QUAD_TO?i({type:_.QUAD_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.ARC&&i({type:_.ARC,relative:this.curCommandRelative,rX:this.curArgs[0],rY:this.curArgs[1],xRot:this.curArgs[2],lArcFlag:this.curArgs[3],sweepFlag:this.curArgs[4],x:this.curArgs[5],y:this.curArgs[6]})),this.curNumber="",this.curNumberHasExpDigits=!1,this.curNumberHasExp=!1,this.curNumberHasDecimal=!1,this.canParseCommandOrComma=!0;}if(!T(n))if(","===n&&this.canParseCommandOrComma)this.canParseCommandOrComma=!1;else if("+"!==n&&"-"!==n&&"."!==n)if(s)this.curNumber=n,this.curNumberHasDecimal=!1;else {if(0!==this.curArgs.length)throw new SyntaxError("Unterminated command at index "+a+".");if(!this.canParseCommandOrComma)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+". Command cannot follow comma");if(this.canParseCommandOrComma=!1,"z"!==n&&"Z"!==n)if("h"===n||"H"===n)this.curCommandType=_.HORIZ_LINE_TO,this.curCommandRelative="h"===n;else if("v"===n||"V"===n)this.curCommandType=_.VERT_LINE_TO,this.curCommandRelative="v"===n;else if("m"===n||"M"===n)this.curCommandType=_.MOVE_TO,this.curCommandRelative="m"===n;else if("l"===n||"L"===n)this.curCommandType=_.LINE_TO,this.curCommandRelative="l"===n;else if("c"===n||"C"===n)this.curCommandType=_.CURVE_TO,this.curCommandRelative="c"===n;else if("s"===n||"S"===n)this.curCommandType=_.SMOOTH_CURVE_TO,this.curCommandRelative="s"===n;else if("q"===n||"Q"===n)this.curCommandType=_.QUAD_TO,this.curCommandRelative="q"===n;else if("t"===n||"T"===n)this.curCommandType=_.SMOOTH_QUAD_TO,this.curCommandRelative="t"===n;else {if("a"!==n&&"A"!==n)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+".");this.curCommandType=_.ARC,this.curCommandRelative="a"===n;}else r.push({type:_.CLOSE_PATH}),this.canParseCommandOrComma=!0,this.curCommandType=-1;}else this.curNumber=n,this.curNumberHasDecimal="."===n;}else this.curNumber+=n,this.curNumberHasDecimal=!0;else this.curNumber+=n;else this.curNumber+=n,this.curNumberHasExp=!0;else this.curNumber+=n,this.curNumberHasExpDigits=this.curNumberHasExp;}return r},e.prototype.transform=function(t){return Object.create(this,{parse:{value:function(r,e){void 0===e&&(e=[]);for(var i=0,a=Object.getPrototypeOf(this).parse.call(this,r);i<a.length;i++){var n=a[i],o=t(n);Array.isArray(o)?e.push.apply(e,o):e.push(o);}return e}}})},e}(l),_=function(t){function i(r){var e=t.call(this)||this;return e.commands="string"==typeof r?i.parse(r):r,e}return r(i,t),i.prototype.encode=function(){return i.encode(this.commands)},i.prototype.getBounds=function(){var t=u.CALCULATE_BOUNDS();return this.transform(t),t},i.prototype.transform=function(t){for(var r=[],e=0,i=this.commands;e<i.length;e++){var a=t(i[e]);Array.isArray(a)?r.push.apply(r,a):r.push(a);}return this.commands=r,this},i.encode=function(t){return e(t)},i.parse=function(t){var r=new f,e=[];return r.parse(t,e),r.finish(e),e},i.CLOSE_PATH=1,i.MOVE_TO=2,i.HORIZ_LINE_TO=4,i.VERT_LINE_TO=8,i.LINE_TO=16,i.CURVE_TO=32,i.SMOOTH_CURVE_TO=64,i.QUAD_TO=128,i.SMOOTH_QUAD_TO=256,i.ARC=512,i.LINE_COMMANDS=i.LINE_TO|i.HORIZ_LINE_TO|i.VERT_LINE_TO,i.DRAWING_COMMANDS=i.HORIZ_LINE_TO|i.VERT_LINE_TO|i.LINE_TO|i.CURVE_TO|i.SMOOTH_CURVE_TO|i.QUAD_TO|i.SMOOTH_QUAD_TO|i.ARC,i}(l),N=((O={})[_.MOVE_TO]=2,O[_.LINE_TO]=2,O[_.HORIZ_LINE_TO]=1,O[_.VERT_LINE_TO]=1,O[_.CLOSE_PATH]=0,O[_.QUAD_TO]=4,O[_.SMOOTH_QUAD_TO]=2,O[_.CURVE_TO]=6,O[_.SMOOTH_CURVE_TO]=4,O[_.ARC]=7,O);

  var uncurryThis = functionUncurryThis;
  var PROPER_FUNCTION_NAME = functionName.PROPER;
  var redefine = redefine$7.exports;
  var anObject = anObject$g;
  var isPrototypeOf = objectIsPrototypeOf;
  var $toString = toString$9;
  var fails = fails$k;
  var regExpFlags = regexpFlags$1;

  var TO_STRING = 'toString';
  var RegExpPrototype = RegExp.prototype;
  var n$ToString = RegExpPrototype[TO_STRING];
  var getFlags = uncurryThis(regExpFlags);

  var NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
  // FF44- RegExp#toString has a wrong name
  var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;

  // `RegExp.prototype.toString` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING, function toString() {
      var R = anObject(this);
      var p = $toString(R.source);
      var rf = R.flags;
      var f = $toString(rf === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype) ? getFlags(R) : rf);
      return '/' + p + '/' + f;
    }, { unsafe: true });
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /* eslint-disable no-bitwise -- used for calculations */

  /* eslint-disable unicorn/prefer-query-selector -- aiming at
    backward-compatibility */

  /**
  * StackBlur - a fast almost Gaussian Blur For Canvas
  *
  * In case you find this class useful - especially in commercial projects -
  * I am not totally unhappy for a small donation to my PayPal account
  * mario@quasimondo.de
  *
  * Or support me on flattr:
  * {@link https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript}.
  *
  * @module StackBlur
  * @author Mario Klingemann
  * Contact: mario@quasimondo.com
  * Website: {@link http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html}
  * Twitter: @quasimondo
  *
  * @copyright (c) 2010 Mario Klingemann
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
  * files (the "Software"), to deal in the Software without
  * restriction, including without limitation the rights to use,
  * copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following
  * conditions:
  *
  * The above copyright notice and this permission notice shall be
  * included in all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  */
  var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
  var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
  /**
   * @param {string|HTMLCanvasElement} canvas
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @throws {Error|TypeError}
   * @returns {ImageData} See {@link https://html.spec.whatwg.org/multipage/canvas.html#imagedata}
   */


  function getImageDataFromCanvas(canvas, topX, topY, width, height) {
    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
    }

    if (!canvas || _typeof(canvas) !== 'object' || !('getContext' in canvas)) {
      throw new TypeError('Expecting canvas with `getContext` method ' + 'in processCanvasRGB(A) calls!');
    }

    var context = canvas.getContext('2d');

    try {
      return context.getImageData(topX, topY, width, height);
    } catch (e) {
      throw new Error('unable to access image data: ' + e);
    }
  }
  /**
   * @param {HTMLCanvasElement} canvas
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @param {Float} radius
   * @returns {undefined}
   */


  function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
    if (isNaN(radius) || radius < 1) {
      return;
    }

    radius |= 0;
    var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
    imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
    canvas.getContext('2d').putImageData(imageData, topX, topY);
  }
  /**
   * @param {ImageData} imageData
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @param {Float} radius
   * @returns {ImageData}
   */


  function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
    var pixels = imageData.data;
    var div = 2 * radius + 1; // const w4 = width << 2;

    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack();
    var stack = stackStart;
    var stackEnd;

    for (var i = 1; i < div; i++) {
      stack = stack.next = new BlurStack();

      if (i === radiusPlus1) {
        stackEnd = stack;
      }
    }

    stack.next = stackStart;
    var stackIn = null,
        stackOut = null,
        yw = 0,
        yi = 0;
    var mulSum = mulTable[radius];
    var shgSum = shgTable[radius];

    for (var y = 0; y < height; y++) {
      stack = stackStart;
      var pr = pixels[yi],
          pg = pixels[yi + 1],
          pb = pixels[yi + 2],
          pa = pixels[yi + 3];

      for (var _i = 0; _i < radiusPlus1; _i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      var rInSum = 0,
          gInSum = 0,
          bInSum = 0,
          aInSum = 0,
          rOutSum = radiusPlus1 * pr,
          gOutSum = radiusPlus1 * pg,
          bOutSum = radiusPlus1 * pb,
          aOutSum = radiusPlus1 * pa,
          rSum = sumFactor * pr,
          gSum = sumFactor * pg,
          bSum = sumFactor * pb,
          aSum = sumFactor * pa;

      for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
        var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
        var r = pixels[p],
            g = pixels[p + 1],
            b = pixels[p + 2],
            a = pixels[p + 3];
        var rbs = radiusPlus1 - _i2;
        rSum += (stack.r = r) * rbs;
        gSum += (stack.g = g) * rbs;
        bSum += (stack.b = b) * rbs;
        aSum += (stack.a = a) * rbs;
        rInSum += r;
        gInSum += g;
        bInSum += b;
        aInSum += a;
        stack = stack.next;
      }

      stackIn = stackStart;
      stackOut = stackEnd;

      for (var x = 0; x < width; x++) {
        var paInitial = aSum * mulSum >> shgSum;
        pixels[yi + 3] = paInitial;

        if (paInitial !== 0) {
          var _a2 = 255 / paInitial;

          pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
          pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
          pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }

        rSum -= rOutSum;
        gSum -= gOutSum;
        bSum -= bOutSum;
        aSum -= aOutSum;
        rOutSum -= stackIn.r;
        gOutSum -= stackIn.g;
        bOutSum -= stackIn.b;
        aOutSum -= stackIn.a;

        var _p = x + radius + 1;

        _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
        rInSum += stackIn.r = pixels[_p];
        gInSum += stackIn.g = pixels[_p + 1];
        bInSum += stackIn.b = pixels[_p + 2];
        aInSum += stackIn.a = pixels[_p + 3];
        rSum += rInSum;
        gSum += gInSum;
        bSum += bInSum;
        aSum += aInSum;
        stackIn = stackIn.next;
        var _stackOut = stackOut,
            _r = _stackOut.r,
            _g = _stackOut.g,
            _b = _stackOut.b,
            _a = _stackOut.a;
        rOutSum += _r;
        gOutSum += _g;
        bOutSum += _b;
        aOutSum += _a;
        rInSum -= _r;
        gInSum -= _g;
        bInSum -= _b;
        aInSum -= _a;
        stackOut = stackOut.next;
        yi += 4;
      }

      yw += width;
    }

    for (var _x = 0; _x < width; _x++) {
      yi = _x << 2;

      var _pr = pixels[yi],
          _pg = pixels[yi + 1],
          _pb = pixels[yi + 2],
          _pa = pixels[yi + 3],
          _rOutSum = radiusPlus1 * _pr,
          _gOutSum = radiusPlus1 * _pg,
          _bOutSum = radiusPlus1 * _pb,
          _aOutSum = radiusPlus1 * _pa,
          _rSum = sumFactor * _pr,
          _gSum = sumFactor * _pg,
          _bSum = sumFactor * _pb,
          _aSum = sumFactor * _pa;

      stack = stackStart;

      for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
        stack.r = _pr;
        stack.g = _pg;
        stack.b = _pb;
        stack.a = _pa;
        stack = stack.next;
      }

      var yp = width;
      var _gInSum = 0,
          _bInSum = 0,
          _aInSum = 0,
          _rInSum = 0;

      for (var _i4 = 1; _i4 <= radius; _i4++) {
        yi = yp + _x << 2;

        var _rbs = radiusPlus1 - _i4;

        _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
        _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
        _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
        _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
        _rInSum += _pr;
        _gInSum += _pg;
        _bInSum += _pb;
        _aInSum += _pa;
        stack = stack.next;

        if (_i4 < heightMinus1) {
          yp += width;
        }
      }

      yi = _x;
      stackIn = stackStart;
      stackOut = stackEnd;

      for (var _y = 0; _y < height; _y++) {
        var _p2 = yi << 2;

        pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;

        if (_pa > 0) {
          _pa = 255 / _pa;
          pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
          pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
          pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
        } else {
          pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
        }

        _rSum -= _rOutSum;
        _gSum -= _gOutSum;
        _bSum -= _bOutSum;
        _aSum -= _aOutSum;
        _rOutSum -= stackIn.r;
        _gOutSum -= stackIn.g;
        _bOutSum -= stackIn.b;
        _aOutSum -= stackIn.a;
        _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
        _rSum += _rInSum += stackIn.r = pixels[_p2];
        _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
        _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
        _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
        stackIn = stackIn.next;
        _rOutSum += _pr = stackOut.r;
        _gOutSum += _pg = stackOut.g;
        _bOutSum += _pb = stackOut.b;
        _aOutSum += _pa = stackOut.a;
        _rInSum -= _pr;
        _gInSum -= _pg;
        _bInSum -= _pb;
        _aInSum -= _pa;
        stackOut = stackOut.next;
        yi += width;
      }
    }

    return imageData;
  }
  /**
   *
   */


  var BlurStack =
  /**
   * Set properties.
   */
  function BlurStack() {
    _classCallCheck(this, BlurStack);

    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  };

  /**
   * Options preset for `OffscreenCanvas`.
   * @param config - Preset requirements.
   * @param config.DOMParser - XML/HTML parser from string into DOM Document.
   * @returns Preset object.
   */
  function offscreen() {
    var {
      DOMParser: DOMParserFallback
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var preset = {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParserFallback,

      createCanvas(width, height) {
        return new OffscreenCanvas(width, height);
      },

      createImage(url) {
        return _asyncToGenerator(function* () {
          var response = yield fetch(url);
          var blob = yield response.blob();
          var img = yield createImageBitmap(blob);
          return img;
        })();
      }

    };

    if (typeof DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {
      Reflect.deleteProperty(preset, 'DOMParser');
    }

    return preset;
  }

  /**
   * Options preset for `node-canvas`.
   * @param config - Preset requirements.
   * @param config.DOMParser - XML/HTML parser from string into DOM Document.
   * @param config.canvas - `node-canvas` exports.
   * @param config.fetch - WHATWG-compatible `fetch` function.
   * @returns Preset object.
   */
  function node(_ref) {
    var {
      DOMParser,
      canvas,
      fetch
    } = _ref;
    return {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser,
      fetch,
      createCanvas: canvas.createCanvas,
      createImage: canvas.loadImage
    };
  }

  var index = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	offscreen: offscreen,
  	node: node
  });

  /**
   * HTML-safe compress white-spaces.
   * @param str - String to compress.
   * @returns String.
   */
  function compressSpaces(str) {
    return str.replace(/(?!\u3000)\s+/gm, ' ');
  }
  /**
   * HTML-safe left trim.
   * @param str - String to trim.
   * @returns String.
   */

  function trimLeft(str) {
    return str.replace(/^[\n \t]+/, '');
  }
  /**
   * HTML-safe right trim.
   * @param str - String to trim.
   * @returns String.
   */

  function trimRight(str) {
    return str.replace(/[\n \t]+$/, '');
  }
  /**
   * String to numbers array.
   * @param str - Numbers string.
   * @returns Numbers array.
   */

  function toNumbers(str) {
    var matches = (str || '').match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
    return matches.map(parseFloat);
  } // Microsoft Edge fix

  var allUppercase = /^[A-Z-]+$/;
  /**
   * Normalize attribute name.
   * @param name - Attribute name.
   * @returns Normalized attribute name.
   */

  function normalizeAttributeName(name) {
    if (allUppercase.test(name)) {
      return name.toLowerCase();
    }

    return name;
  }
  /**
   * Parse external URL.
   * @param url - CSS url string.
   * @returns Parsed URL.
   */

  function parseExternalUrl(url) {
    //                      single quotes [2]
    //                      v         double quotes [3]
    //                      v         v         no quotes [4]
    //                      v         v         v
    var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
    return urlMatch[2] || urlMatch[3] || urlMatch[4];
  }
  /**
   * Transform floats to integers in rgb colors.
   * @param color - Color to normalize.
   * @returns Normalized color.
   */

  function normalizeColor(color) {
    if (!color.startsWith('rgb')) {
      return color;
    }

    var rgbParts = 3;
    var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
    return normalizedColor;
  }

  // slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
  var attributeRegex = /(\[[^\]]+\])/g;
  var idRegex = /(#[^\s+>~.[:]+)/g;
  var classRegex = /(\.[^\s+>~.[:]+)/g;
  var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
  var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
  var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
  var elementRegex = /([^\s+>~.[:]+)/g;

  function findSelectorMatch(selector, regex) {
    var matches = regex.exec(selector);

    if (!matches) {
      return [selector, 0];
    }

    return [selector.replace(regex, ' '), matches.length];
  }
  /**
   * Measure selector specificity.
   * @param selector - Selector to measure.
   * @returns Specificity.
   */


  function getSelectorSpecificity(selector) {
    var specificity = [0, 0, 0];
    var currentSelector = selector.replace(/:not\(([^)]*)\)/g, '     $1 ').replace(/{[\s\S]*/gm, ' ');
    var delta = 0;
    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
    specificity[0] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
    specificity[2] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
    specificity[1] += delta;
    currentSelector = currentSelector.replace(/[*\s+>~]/g, ' ').replace(/[#.]/g, ' ');
    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]

    specificity[2] += delta;
    return specificity.join('');
  }

  var PSEUDO_ZERO = .00000001;
  /**
   * Vector magnitude.
   * @param v
   * @returns Number result.
   */

  function vectorMagnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
  }
  /**
   * Ratio between two vectors.
   * @param u
   * @param v
   * @returns Number result.
   */

  function vectorsRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));
  }
  /**
   * Angle between two vectors.
   * @param u
   * @param v
   * @returns Number result.
   */

  function vectorsAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));
  }
  function CB1(t) {
    return t * t * t;
  }
  function CB2(t) {
    return 3 * t * t * (1 - t);
  }
  function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
  }
  function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }
  function QB1(t) {
    return t * t;
  }
  function QB2(t) {
    return 2 * t * (1 - t);
  }
  function QB3(t) {
    return (1 - t) * (1 - t);
  }

  class Property {
    constructor(document, name, value) {
      this.document = document;
      this.name = name;
      this.value = value;
      this.isNormalizedColor = false;
    }

    static empty(document) {
      return new Property(document, 'EMPTY', '');
    }

    split() {
      var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
      var {
        document,
        name
      } = this;
      return compressSpaces(this.getString()).trim().split(separator).map(value => new Property(document, name, value));
    }

    hasValue(zeroIsValue) {
      var {
        value
      } = this;
      return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';
    }

    isString(regexp) {
      var {
        value
      } = this;
      var result = typeof value === 'string';

      if (!result || !regexp) {
        return result;
      }

      return regexp.test(value);
    }

    isUrlDefinition() {
      return this.isString(/^url\(/);
    }

    isPixels() {
      if (!this.hasValue()) {
        return false;
      }

      var asString = this.getString();

      switch (true) {
        case asString.endsWith('px'):
        case /^[0-9]+$/.test(asString):
          return true;

        default:
          return false;
      }
    }

    setValue(value) {
      this.value = value;
      return this;
    }

    getValue(def) {
      if (typeof def === 'undefined' || this.hasValue()) {
        return this.value;
      }

      return def;
    }

    getNumber(def) {
      if (!this.hasValue()) {
        if (typeof def === 'undefined') {
          return 0;
        }

        return parseFloat(def);
      }

      var {
        value
      } = this;
      var n = parseFloat(value);

      if (this.isString(/%$/)) {
        n /= 100.0;
      }

      return n;
    }

    getString(def) {
      if (typeof def === 'undefined' || this.hasValue()) {
        return typeof this.value === 'undefined' ? '' : String(this.value);
      }

      return String(def);
    }

    getColor(def) {
      var color = this.getString(def);

      if (this.isNormalizedColor) {
        return color;
      }

      this.isNormalizedColor = true;
      color = normalizeColor(color);
      this.value = color;
      return color;
    }

    getDpi() {
      return 96.0; // TODO: compute?
    }

    getRem() {
      return this.document.rootEmSize;
    }

    getEm() {
      return this.document.emSize;
    }

    getUnits() {
      return this.getString().replace(/[0-9.-]/g, '');
    }

    getPixels(axisOrIsFontSize) {
      var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.hasValue()) {
        return 0;
      }

      var [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [undefined, axisOrIsFontSize] : [axisOrIsFontSize];
      var {
        viewPort
      } = this.document.screen;

      switch (true) {
        case this.isString(/vmin$/):
          return this.getNumber() / 100.0 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));

        case this.isString(/vmax$/):
          return this.getNumber() / 100.0 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));

        case this.isString(/vw$/):
          return this.getNumber() / 100.0 * viewPort.computeSize('x');

        case this.isString(/vh$/):
          return this.getNumber() / 100.0 * viewPort.computeSize('y');

        case this.isString(/rem$/):
          return this.getNumber() * this.getRem();

        case this.isString(/em$/):
          return this.getNumber() * this.getEm();

        case this.isString(/ex$/):
          return this.getNumber() * this.getEm() / 2.0;

        case this.isString(/px$/):
          return this.getNumber();

        case this.isString(/pt$/):
          return this.getNumber() * this.getDpi() * (1.0 / 72.0);

        case this.isString(/pc$/):
          return this.getNumber() * 15;

        case this.isString(/cm$/):
          return this.getNumber() * this.getDpi() / 2.54;

        case this.isString(/mm$/):
          return this.getNumber() * this.getDpi() / 25.4;

        case this.isString(/in$/):
          return this.getNumber() * this.getDpi();

        case this.isString(/%$/) && isFontSize:
          return this.getNumber() * this.getEm();

        case this.isString(/%$/):
          return this.getNumber() * viewPort.computeSize(axis);

        default:
          {
            var n = this.getNumber();

            if (processPercent && n < 1.0) {
              return n * viewPort.computeSize(axis);
            }

            return n;
          }
      }
    }

    getMilliseconds() {
      if (!this.hasValue()) {
        return 0;
      }

      if (this.isString(/ms$/)) {
        return this.getNumber();
      }

      return this.getNumber() * 1000;
    }

    getRadians() {
      if (!this.hasValue()) {
        return 0;
      }

      switch (true) {
        case this.isString(/deg$/):
          return this.getNumber() * (Math.PI / 180.0);

        case this.isString(/grad$/):
          return this.getNumber() * (Math.PI / 200.0);

        case this.isString(/rad$/):
          return this.getNumber();

        default:
          return this.getNumber() * (Math.PI / 180.0);
      }
    }

    getDefinition() {
      var asString = this.getString();
      var name = /#([^)'"]+)/.exec(asString);

      if (name) {
        name = name[1];
      }

      if (!name) {
        name = asString;
      }

      return this.document.definitions[name];
    }

    getFillStyleDefinition(element, opacity) {
      var def = this.getDefinition();

      if (!def) {
        return null;
      } // gradient


      if (typeof def.createGradient === 'function') {
        return def.createGradient(this.document.ctx, element, opacity);
      } // pattern


      if (typeof def.createPattern === 'function') {
        if (def.getHrefAttribute().hasValue()) {
          var patternTransform = def.getAttribute('patternTransform');
          def = def.getHrefAttribute().getDefinition();

          if (patternTransform.hasValue()) {
            def.getAttribute('patternTransform', true).setValue(patternTransform.value);
          }
        }

        return def.createPattern(this.document.ctx, element, opacity);
      }

      return null;
    }

    getTextBaseline() {
      if (!this.hasValue()) {
        return null;
      }

      return Property.textBaselineMapping[this.getString()];
    }

    addOpacity(opacity) {
      var value = this.getColor();
      var len = value.length;
      var commas = 0; // Simulate old RGBColor version, which can't parse rgba.

      for (var i = 0; i < len; i++) {
        if (value[i] === ',') {
          commas++;
        }

        if (commas === 3) {
          break;
        }
      }

      if (opacity.hasValue() && this.isString() && commas !== 3) {
        var color = new rgbcolor(value);

        if (color.ok) {
          color.alpha = opacity.getNumber();
          value = color.toRGBA();
        }
      }

      return new Property(this.document, this.name, value);
    }

  }
  Property.textBaselineMapping = {
    'baseline': 'alphabetic',
    'before-edge': 'top',
    'text-before-edge': 'top',
    'middle': 'middle',
    'central': 'middle',
    'after-edge': 'bottom',
    'text-after-edge': 'bottom',
    'ideographic': 'ideographic',
    'alphabetic': 'alphabetic',
    'hanging': 'hanging',
    'mathematical': 'alphabetic'
  };

  class ViewPort {
    constructor() {
      this.viewPorts = [];
    }

    clear() {
      this.viewPorts = [];
    }

    setCurrent(width, height) {
      this.viewPorts.push({
        width,
        height
      });
    }

    removeCurrent() {
      this.viewPorts.pop();
    }

    getCurrent() {
      var {
        viewPorts
      } = this;
      return viewPorts[viewPorts.length - 1];
    }

    get width() {
      return this.getCurrent().width;
    }

    get height() {
      return this.getCurrent().height;
    }

    computeSize(d) {
      if (typeof d === 'number') {
        return d;
      }

      if (d === 'x') {
        return this.width;
      }

      if (d === 'y') {
        return this.height;
      }

      return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
    }

  }

  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    static parse(point) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var [x = defaultValue, y = defaultValue] = toNumbers(point);
      return new Point(x, y);
    }

    static parseScale(scale) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var [x = defaultValue, y = x] = toNumbers(scale);
      return new Point(x, y);
    }

    static parsePath(path) {
      var points = toNumbers(path);
      var len = points.length;
      var pathPoints = [];

      for (var i = 0; i < len; i += 2) {
        pathPoints.push(new Point(points[i], points[i + 1]));
      }

      return pathPoints;
    }

    angleTo(point) {
      return Math.atan2(point.y - this.y, point.x - this.x);
    }

    applyTransform(transform) {
      var {
        x,
        y
      } = this;
      var xp = x * transform[0] + y * transform[2] + transform[4];
      var yp = x * transform[1] + y * transform[3] + transform[5];
      this.x = xp;
      this.y = yp;
    }

  }

  class Mouse {
    constructor(screen) {
      this.screen = screen;
      this.working = false;
      this.events = [];
      this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

      this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

      this.onMouseMove = this.onMouseMove.bind(this);
    }

    isWorking() {
      return this.working;
    }

    start() {
      if (this.working) {
        return;
      }

      var {
        screen,
        onClick,
        onMouseMove
      } = this;
      var canvas = screen.ctx.canvas;
      canvas.onclick = onClick;
      canvas.onmousemove = onMouseMove;
      this.working = true;
    }

    stop() {
      if (!this.working) {
        return;
      }

      var canvas = this.screen.ctx.canvas;
      this.working = false;
      canvas.onclick = null;
      canvas.onmousemove = null;
    }

    hasEvents() {
      return this.working && this.events.length > 0;
    }

    runEvents() {
      if (!this.working) {
        return;
      }

      var {
        screen: document,
        events,
        eventElements
      } = this;
      var {
        style
      } = document.ctx.canvas;

      if (style) {
        style.cursor = '';
      }

      events.forEach((_ref, i) => {
        var {
          run
        } = _ref;
        var element = eventElements[i];

        while (element) {
          run(element);
          element = element.parent;
        }
      }); // done running, clear

      this.events = [];
      this.eventElements = [];
    }

    checkPath(element, ctx) {
      if (!this.working || !ctx) {
        return;
      }

      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref2, i) => {
        var {
          x,
          y
        } = _ref2;

        if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {
          eventElements[i] = element;
        }
      });
    }

    checkBoundingBox(element, boundingBox) {
      if (!this.working || !boundingBox) {
        return;
      }

      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref3, i) => {
        var {
          x,
          y
        } = _ref3;

        if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {
          eventElements[i] = element;
        }
      });
    }

    mapXY(x, y) {
      var {
        window,
        ctx
      } = this.screen;
      var point = new Point(x, y);
      var element = ctx.canvas;

      while (element) {
        point.x -= element.offsetLeft;
        point.y -= element.offsetTop;
        element = element.offsetParent;
      }

      if (window.scrollX) {
        point.x += window.scrollX;
      }

      if (window.scrollY) {
        point.y += window.scrollY;
      }

      return point;
    }

    onClick(event) {
      var {
        x,
        y
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: 'onclick',
        x,
        y,

        run(eventTarget) {
          if (eventTarget.onClick) {
            eventTarget.onClick();
          }
        }

      });
    }

    onMouseMove(event) {
      var {
        x,
        y
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: 'onmousemove',
        x,
        y,

        run(eventTarget) {
          if (eventTarget.onMouseMove) {
            eventTarget.onMouseMove();
          }
        }

      });
    }

  }

  var defaultWindow = typeof window !== 'undefined' ? window : null;
  var defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.
  : null;
  class Screen {
    constructor(ctx) {
      var {
        fetch = defaultFetch$1,
        window = defaultWindow
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.ctx = ctx;
      this.FRAMERATE = 30;
      this.MAX_VIRTUAL_PIXELS = 30000;
      this.CLIENT_WIDTH = 800;
      this.CLIENT_HEIGHT = 600;
      this.viewPort = new ViewPort();
      this.mouse = new Mouse(this);
      this.animations = [];
      this.waits = [];
      this.frameDuration = 0;
      this.isReadyLock = false;
      this.isFirstRender = true;
      this.intervalId = null;
      this.window = window;
      this.fetch = fetch;
    }

    wait(checker) {
      this.waits.push(checker);
    }

    ready() {
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      if (!this.readyPromise) {
        return Promise.resolve();
      }

      return this.readyPromise;
    }

    isReady() {
      if (this.isReadyLock) {
        return true;
      }

      var isReadyLock = this.waits.every(_ => _());

      if (isReadyLock) {
        this.waits = [];

        if (this.resolveReady) {
          this.resolveReady();
        }
      }

      this.isReadyLock = isReadyLock;
      return isReadyLock;
    }

    setDefaults(ctx) {
      // initial values and defaults
      ctx.strokeStyle = 'rgba(0,0,0,0)';
      ctx.lineCap = 'butt';
      ctx.lineJoin = 'miter';
      ctx.miterLimit = 4;
    }

    setViewBox(_ref) {
      var {
        document,
        ctx,
        aspectRatio,
        width,
        desiredWidth,
        height,
        desiredHeight,
        minX = 0,
        minY = 0,
        refX,
        refY,
        clip = false,
        clipX = 0,
        clipY = 0
      } = _ref;
      // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
      var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, ''); // ignore defer

      var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');
      var align = aspectRatioAlign || 'xMidYMid';
      var meetOrSlice = aspectRatioMeetOrSlice || 'meet'; // calculate scale

      var scaleX = width / desiredWidth;
      var scaleY = height / desiredHeight;
      var scaleMin = Math.min(scaleX, scaleY);
      var scaleMax = Math.max(scaleX, scaleY);
      var finalDesiredWidth = desiredWidth;
      var finalDesiredHeight = desiredHeight;

      if (meetOrSlice === 'meet') {
        finalDesiredWidth *= scaleMin;
        finalDesiredHeight *= scaleMin;
      }

      if (meetOrSlice === 'slice') {
        finalDesiredWidth *= scaleMax;
        finalDesiredHeight *= scaleMax;
      }

      var refXProp = new Property(document, 'refX', refX);
      var refYProp = new Property(document, 'refY', refY);
      var hasRefs = refXProp.hasValue() && refYProp.hasValue();

      if (hasRefs) {
        ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));
      }

      if (clip) {
        var scaledClipX = scaleMin * clipX;
        var scaledClipY = scaleMin * clipY;
        ctx.beginPath();
        ctx.moveTo(scaledClipX, scaledClipY);
        ctx.lineTo(width, scaledClipY);
        ctx.lineTo(width, height);
        ctx.lineTo(scaledClipX, height);
        ctx.closePath();
        ctx.clip();
      }

      if (!hasRefs) {
        var isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;
        var isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;
        var isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;
        var isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;

        if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);
        }

        if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);
        }

        if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width - finalDesiredWidth, 0);
        }

        if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height - finalDesiredHeight);
        }
      } // scale


      switch (true) {
        case align === 'none':
          ctx.scale(scaleX, scaleY);
          break;

        case meetOrSlice === 'meet':
          ctx.scale(scaleMin, scaleMin);
          break;

        case meetOrSlice === 'slice':
          ctx.scale(scaleMax, scaleMax);
          break;
      } // translate


      ctx.translate(-minX, -minY);
    }

    start(element) {
      var {
        enableRedraw = false,
        ignoreMouse = false,
        ignoreAnimation = false,
        ignoreDimensions = false,
        ignoreClear = false,
        forceRedraw,
        scaleWidth,
        scaleHeight,
        offsetX,
        offsetY
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var {
        FRAMERATE,
        mouse
      } = this;
      var frameDuration = 1000 / FRAMERATE;
      this.frameDuration = frameDuration;
      this.readyPromise = new Promise(resolve => {
        this.resolveReady = resolve;
      });

      if (this.isReady()) {
        this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
      }

      if (!enableRedraw) {
        return;
      }

      var now = Date.now();
      var then = now;
      var delta = 0;

      var tick = () => {
        now = Date.now();
        delta = now - then;

        if (delta >= frameDuration) {
          then = now - delta % frameDuration;

          if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
            mouse.runEvents();
          }
        }

        this.intervalId = requestAnimationFrame(tick);
      };

      if (!ignoreMouse) {
        mouse.start();
      }

      this.intervalId = requestAnimationFrame(tick);
    }

    stop() {
      if (this.intervalId) {
        requestAnimationFrame.cancel(this.intervalId);
        this.intervalId = null;
      }

      this.mouse.stop();
    }

    shouldUpdate(ignoreAnimation, forceRedraw) {
      // need update from animations?
      if (!ignoreAnimation) {
        var {
          frameDuration
        } = this;
        var shouldUpdate = this.animations.reduce((shouldUpdate, animation) => animation.update(frameDuration) || shouldUpdate, false);

        if (shouldUpdate) {
          return true;
        }
      } // need update from redraw?


      if (typeof forceRedraw === 'function' && forceRedraw()) {
        return true;
      }

      if (!this.isReadyLock && this.isReady()) {
        return true;
      } // need update from mouse events?


      if (this.mouse.hasEvents()) {
        return true;
      }

      return false;
    }

    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
      var {
        CLIENT_WIDTH,
        CLIENT_HEIGHT,
        viewPort,
        ctx,
        isFirstRender
      } = this;
      var canvas = ctx.canvas;
      viewPort.clear();

      if (canvas.width && canvas.height) {
        viewPort.setCurrent(canvas.width, canvas.height);
      } else {
        viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
      }

      var widthStyle = element.getStyle('width');
      var heightStyle = element.getStyle('height');

      if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {
        // set canvas size
        if (widthStyle.hasValue()) {
          canvas.width = widthStyle.getPixels('x');

          if (canvas.style) {
            canvas.style.width = "".concat(canvas.width, "px");
          }
        }

        if (heightStyle.hasValue()) {
          canvas.height = heightStyle.getPixels('y');

          if (canvas.style) {
            canvas.style.height = "".concat(canvas.height, "px");
          }
        }
      }

      var cWidth = canvas.clientWidth || canvas.width;
      var cHeight = canvas.clientHeight || canvas.height;

      if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
        cWidth = widthStyle.getPixels('x');
        cHeight = heightStyle.getPixels('y');
      }

      viewPort.setCurrent(cWidth, cHeight);

      if (typeof offsetX === 'number') {
        element.getAttribute('x', true).setValue(offsetX);
      }

      if (typeof offsetY === 'number') {
        element.getAttribute('y', true).setValue(offsetY);
      }

      if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {
        var viewBox = toNumbers(element.getAttribute('viewBox').getString());
        var xRatio = 0;
        var yRatio = 0;

        if (typeof scaleWidth === 'number') {
          var _widthStyle = element.getStyle('width');

          if (_widthStyle.hasValue()) {
            xRatio = _widthStyle.getPixels('x') / scaleWidth;
          } else if (!isNaN(viewBox[2])) {
            xRatio = viewBox[2] / scaleWidth;
          }
        }

        if (typeof scaleHeight === 'number') {
          var _heightStyle = element.getStyle('height');

          if (_heightStyle.hasValue()) {
            yRatio = _heightStyle.getPixels('y') / scaleHeight;
          } else if (!isNaN(viewBox[3])) {
            yRatio = viewBox[3] / scaleHeight;
          }
        }

        if (!xRatio) {
          xRatio = yRatio;
        }

        if (!yRatio) {
          yRatio = xRatio;
        }

        element.getAttribute('width', true).setValue(scaleWidth);
        element.getAttribute('height', true).setValue(scaleHeight);
        var transformStyle = element.getStyle('transform', true, true);
        transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1.0 / xRatio, ", ").concat(1.0 / yRatio, ")"));
      } // clear and render


      if (!ignoreClear) {
        ctx.clearRect(0, 0, cWidth, cHeight);
      }

      element.render(ctx);

      if (isFirstRender) {
        this.isFirstRender = false;
      }
    }

  }
  Screen.defaultWindow = defaultWindow;
  Screen.defaultFetch = defaultFetch$1;

  var {
    defaultFetch
  } = Screen;
  var DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : null;
  class Parser {
    constructor() {
      var {
        fetch = defaultFetch,
        DOMParser = DefaultDOMParser
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.fetch = fetch;
      this.DOMParser = DOMParser;
    }

    parse(resource) {
      var _this = this;

      return _asyncToGenerator(function* () {
        if (resource.startsWith('<')) {
          return _this.parseFromString(resource);
        }

        return _this.load(resource);
      })();
    }

    parseFromString(xml) {
      var parser = new this.DOMParser();

      try {
        return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));
      } catch (err) {
        return this.checkDocument(parser.parseFromString(xml, 'text/xml'));
      }
    }

    checkDocument(document) {
      var parserError = document.getElementsByTagName('parsererror')[0];

      if (parserError) {
        throw new Error(parserError.textContent);
      }

      return document;
    }

    load(url) {
      var _this2 = this;

      return _asyncToGenerator(function* () {
        var response = yield _this2.fetch(url);
        var xml = yield response.text();
        return _this2.parseFromString(xml);
      })();
    }

  }

  class Translate {
    constructor(_, point) {
      this.type = 'translate';
      this.point = null;
      this.point = Point.parse(point);
    }

    apply(ctx) {
      var {
        x,
        y
      } = this.point;
      ctx.translate(x || 0.0, y || 0.0);
    }

    unapply(ctx) {
      var {
        x,
        y
      } = this.point;
      ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);
    }

    applyToPoint(point) {
      var {
        x,
        y
      } = this.point;
      point.applyTransform([1, 0, 0, 1, x || 0.0, y || 0.0]);
    }

  }

  class Rotate {
    constructor(document, rotate, transformOrigin) {
      this.type = 'rotate';
      this.angle = null;
      this.originX = null;
      this.originY = null;
      this.cx = 0;
      this.cy = 0;
      var numbers = toNumbers(rotate);
      this.angle = new Property(document, 'angle', numbers[0]);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
      this.cx = numbers[1] || 0;
      this.cy = numbers[2] || 0;
    }

    apply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle
      } = this;
      var tx = cx + originX.getPixels('x');
      var ty = cy + originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.rotate(angle.getRadians());
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle
      } = this;
      var tx = cx + originX.getPixels('x');
      var ty = cy + originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.rotate(-1.0 * angle.getRadians());
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      var {
        cx,
        cy,
        angle
      } = this;
      var rad = angle.getRadians();
      point.applyTransform([1, 0, 0, 1, cx || 0.0, cy || 0.0 // this.p.y
      ]);
      point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
      point.applyTransform([1, 0, 0, 1, -cx || 0.0, -cy || 0.0 // -this.p.y
      ]);
    }

  }

  class Scale {
    constructor(_, scale, transformOrigin) {
      this.type = 'scale';
      this.scale = null;
      this.originX = null;
      this.originY = null;
      var scaleSize = Point.parseScale(scale); // Workaround for node-canvas

      if (scaleSize.x === 0 || scaleSize.y === 0) {
        scaleSize.x = PSEUDO_ZERO;
        scaleSize.y = PSEUDO_ZERO;
      }

      this.scale = scaleSize;
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }

    apply(ctx) {
      var {
        scale: {
          x,
          y
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.scale(x, y || x);
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        scale: {
          x,
          y
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.scale(1.0 / x, 1.0 / y || x);
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      var {
        x,
        y
      } = this.scale;
      point.applyTransform([x || 0.0, 0, 0, y || 0.0, 0, 0]);
    }

  }

  class Matrix {
    constructor(_, matrix, transformOrigin) {
      this.type = 'matrix';
      this.matrix = [];
      this.originX = null;
      this.originY = null;
      this.matrix = toNumbers(matrix);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }

    apply(ctx) {
      var {
        originX,
        originY,
        matrix
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        originX,
        originY,
        matrix
      } = this;
      var a = matrix[0];
      var b = matrix[2];
      var c = matrix[4];
      var d = matrix[1];
      var e = matrix[3];
      var f = matrix[5];
      var g = 0.0;
      var h = 0.0;
      var i = 1.0;
      var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      point.applyTransform(this.matrix);
    }

  }

  class Skew extends Matrix {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skew';
      this.angle = null;
      this.angle = new Property(document, 'angle', skew);
    }

  }

  class SkewX extends Skew {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skewX';
      this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
    }

  }

  class SkewY extends Skew {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skewY';
      this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
    }

  }

  function parseTransforms(transform) {
    return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
  }

  function parseTransform(transform) {
    var [type, value] = transform.split('(');
    return [type.trim(), value.trim().replace(')', '')];
  }

  class Transform {
    constructor(document, transform, transformOrigin) {
      this.document = document;
      this.transforms = [];
      var data = parseTransforms(transform);
      data.forEach(transform => {
        if (transform === 'none') {
          return;
        }

        var [type, value] = parseTransform(transform);
        var TransformType = Transform.transformTypes[type];

        if (typeof TransformType !== 'undefined') {
          this.transforms.push(new TransformType(this.document, value, transformOrigin));
        }
      });
    }

    static fromElement(document, element) {
      var transformStyle = element.getStyle('transform', false, true);
      var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();
      var transformOrigin = [transformOriginXProperty, transformOriginYProperty];

      if (transformStyle.hasValue()) {
        return new Transform(document, transformStyle.getString(), transformOrigin);
      }

      return null;
    }

    apply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = 0; i < len; i++) {
        transforms[i].apply(ctx);
      }
    }

    unapply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = len - 1; i >= 0; i--) {
        transforms[i].unapply(ctx);
      }
    } // TODO: applyToPoint unused ... remove?


    applyToPoint(point) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = 0; i < len; i++) {
        transforms[i].applyToPoint(point);
      }
    }

  }
  Transform.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
  };

  class Element$1 {
    constructor(document, node) {
      var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.document = document;
      this.node = node;
      this.captureTextNodes = captureTextNodes;
      this.attributes = {};
      this.styles = {};
      this.stylesSpecificity = {};
      this.animationFrozen = false;
      this.animationFrozenValue = '';
      this.parent = null;
      this.children = [];

      if (!node || node.nodeType !== 1) {
        // ELEMENT_NODE
        return;
      } // add attributes


      Array.from(node.attributes).forEach(attribute => {
        var nodeName = normalizeAttributeName(attribute.nodeName);
        this.attributes[nodeName] = new Property(document, nodeName, attribute.value);
      });
      this.addStylesFromStyleDefinition(); // add inline styles

      if (this.getAttribute('style').hasValue()) {
        var styles = this.getAttribute('style').getString().split(';').map(_ => _.trim());
        styles.forEach(style => {
          if (!style) {
            return;
          }

          var [name, value] = style.split(':').map(_ => _.trim());
          this.styles[name] = new Property(document, name, value);
        });
      }

      var {
        definitions
      } = document;
      var id = this.getAttribute('id'); // add id

      if (id.hasValue()) {
        if (!definitions[id.getString()]) {
          definitions[id.getString()] = this;
        }
      }

      Array.from(node.childNodes).forEach(childNode => {
        if (childNode.nodeType === 1) {
          this.addChild(childNode); // ELEMENT_NODE
        } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
          var textNode = document.createTextNode(childNode);

          if (textNode.getText().length > 0) {
            this.addChild(textNode); // TEXT_NODE
          }
        }
      });
    }

    getAttribute(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var attr = this.attributes[name];

      if (!attr && createIfNotExists) {
        var _attr = new Property(this.document, name, '');

        this.attributes[name] = _attr;
        return _attr;
      }

      return attr || Property.empty(this.document);
    }

    getHrefAttribute() {
      for (var key in this.attributes) {
        if (key === 'href' || key.endsWith(':href')) {
          return this.attributes[key];
        }
      }

      return Property.empty(this.document);
    }

    getStyle(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var style = this.styles[name];

      if (style) {
        return style;
      }

      var attr = this.getAttribute(name);

      if (attr !== null && attr !== void 0 && attr.hasValue()) {
        this.styles[name] = attr; // move up to me to cache

        return attr;
      }

      if (!skipAncestors) {
        var {
          parent
        } = this;

        if (parent) {
          var parentStyle = parent.getStyle(name);

          if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
            return parentStyle;
          }
        }
      }

      if (createIfNotExists) {
        var _style = new Property(this.document, name, '');

        this.styles[name] = _style;
        return _style;
      }

      return style || Property.empty(this.document);
    }

    render(ctx) {
      // don't render display=none
      // don't render visibility=hidden
      if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {
        return;
      }

      ctx.save();

      if (this.getStyle('mask').hasValue()) {
        // mask
        var mask = this.getStyle('mask').getDefinition();

        if (mask) {
          this.applyEffects(ctx);
          mask.apply(ctx, this);
        }
      } else if (this.getStyle('filter').getValue('none') !== 'none') {
        // filter
        var filter = this.getStyle('filter').getDefinition();

        if (filter) {
          this.applyEffects(ctx);
          filter.apply(ctx, this);
        }
      } else {
        this.setContext(ctx);
        this.renderChildren(ctx);
        this.clearContext(ctx);
      }

      ctx.restore();
    }

    setContext(_) {// NO RENDER
    }

    applyEffects(ctx) {
      // transform
      var transform = Transform.fromElement(this.document, this);

      if (transform) {
        transform.apply(ctx);
      } // clip


      var clipPathStyleProp = this.getStyle('clip-path', false, true);

      if (clipPathStyleProp.hasValue()) {
        var clip = clipPathStyleProp.getDefinition();

        if (clip) {
          clip.apply(ctx);
        }
      }
    }

    clearContext(_) {// NO RENDER
    }

    renderChildren(ctx) {
      this.children.forEach(child => {
        child.render(ctx);
      });
    }

    addChild(childNode) {
      var child = childNode instanceof Element$1 ? childNode : this.document.createElement(childNode);
      child.parent = this;

      if (!Element$1.ignoreChildTypes.includes(child.type)) {
        this.children.push(child);
      }
    }

    matchesSelector(selector) {
      var _node$getAttribute;

      var {
        node
      } = this;

      if (typeof node.matches === 'function') {
        return node.matches(selector);
      }

      var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'class');

      if (!styleClasses || styleClasses === '') {
        return false;
      }

      return styleClasses.split(' ').some(styleClass => ".".concat(styleClass) === selector);
    }

    addStylesFromStyleDefinition() {
      var {
        styles,
        stylesSpecificity
      } = this.document;

      for (var selector in styles) {
        if (!selector.startsWith('@') && this.matchesSelector(selector)) {
          var style = styles[selector];
          var specificity = stylesSpecificity[selector];

          if (style) {
            for (var name in style) {
              var existingSpecificity = this.stylesSpecificity[name];

              if (typeof existingSpecificity === 'undefined') {
                existingSpecificity = '000';
              }

              if (specificity >= existingSpecificity) {
                this.styles[name] = style[name];
                this.stylesSpecificity[name] = specificity;
              }
            }
          }
        }
      }
    }

    removeStyles(element, ignoreStyles) {
      var toRestore = ignoreStyles.reduce((toRestore, name) => {
        var styleProp = element.getStyle(name);

        if (!styleProp.hasValue()) {
          return toRestore;
        }

        var value = styleProp.getString();
        styleProp.setValue('');
        return [...toRestore, [name, value]];
      }, []);
      return toRestore;
    }

    restoreStyles(element, styles) {
      styles.forEach(_ref => {
        var [name, value] = _ref;
        element.getStyle(name, true).setValue(value);
      });
    }

    isFirstChild() {
      var _this$parent;

      return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
    }

  }
  Element$1.ignoreChildTypes = ['title'];

  class UnknownElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
    }

  }

  function wrapFontFamily(fontFamily) {
    var trimmed = fontFamily.trim();
    return /^('|")/.test(trimmed) ? trimmed : "\"".concat(trimmed, "\"");
  }

  function prepareFontFamily(fontFamily) {
    return typeof process === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
   * @param fontStyle
   * @returns CSS font style.
   */


  function prepareFontStyle(fontStyle) {
    if (!fontStyle) {
      return '';
    }

    var targetFontStyle = fontStyle.trim().toLowerCase();

    switch (targetFontStyle) {
      case 'normal':
      case 'italic':
      case 'oblique':
      case 'inherit':
      case 'initial':
      case 'unset':
        return targetFontStyle;

      default:
        if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
          return targetFontStyle;
        }

        return '';
    }
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
   * @param fontWeight
   * @returns CSS font weight.
   */


  function prepareFontWeight(fontWeight) {
    if (!fontWeight) {
      return '';
    }

    var targetFontWeight = fontWeight.trim().toLowerCase();

    switch (targetFontWeight) {
      case 'normal':
      case 'bold':
      case 'lighter':
      case 'bolder':
      case 'inherit':
      case 'initial':
      case 'unset':
        return targetFontWeight;

      default:
        if (/^[\d.]+$/.test(targetFontWeight)) {
          return targetFontWeight;
        }

        return '';
    }
  }

  class Font {
    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
      var inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};
      this.fontFamily = fontFamily || inheritFont.fontFamily;
      this.fontSize = fontSize || inheritFont.fontSize;
      this.fontStyle = fontStyle || inheritFont.fontStyle;
      this.fontWeight = fontWeight || inheritFont.fontWeight;
      this.fontVariant = fontVariant || inheritFont.fontVariant;
    }

    static parse() {
      var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var inherit = arguments.length > 1 ? arguments[1] : undefined;
      var fontStyle = '';
      var fontVariant = '';
      var fontWeight = '';
      var fontSize = '';
      var fontFamily = '';
      var parts = compressSpaces(font).trim().split(' ');
      var set = {
        fontSize: false,
        fontStyle: false,
        fontWeight: false,
        fontVariant: false
      };
      parts.forEach(part => {
        switch (true) {
          case !set.fontStyle && Font.styles.includes(part):
            if (part !== 'inherit') {
              fontStyle = part;
            }

            set.fontStyle = true;
            break;

          case !set.fontVariant && Font.variants.includes(part):
            if (part !== 'inherit') {
              fontVariant = part;
            }

            set.fontStyle = true;
            set.fontVariant = true;
            break;

          case !set.fontWeight && Font.weights.includes(part):
            if (part !== 'inherit') {
              fontWeight = part;
            }

            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            break;

          case !set.fontSize:
            if (part !== 'inherit') {
              [fontSize] = part.split('/');
            }

            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            set.fontSize = true;
            break;

          default:
            if (part !== 'inherit') {
              fontFamily += part;
            }

        }
      });
      return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
    }

    toString() {
      return [prepareFontStyle(this.fontStyle), this.fontVariant, prepareFontWeight(this.fontWeight), this.fontSize, // Wrap fontFamily only on nodejs and only for canvas.ctx
      prepareFontFamily(this.fontFamily)].join(' ').trim();
    }

  }
  Font.styles = 'normal|italic|oblique|inherit';
  Font.variants = 'normal|small-caps|inherit';
  Font.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

  class BoundingBox {
    constructor() {
      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;
      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;
      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;
      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }

    get x() {
      return this.x1;
    }

    get y() {
      return this.y1;
    }

    get width() {
      return this.x2 - this.x1;
    }

    get height() {
      return this.y2 - this.y1;
    }

    addPoint(x, y) {
      if (typeof x !== 'undefined') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = x;
          this.x2 = x;
        }

        if (x < this.x1) {
          this.x1 = x;
        }

        if (x > this.x2) {
          this.x2 = x;
        }
      }

      if (typeof y !== 'undefined') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = y;
          this.y2 = y;
        }

        if (y < this.y1) {
          this.y1 = y;
        }

        if (y > this.y2) {
          this.y2 = y;
        }
      }
    }

    addX(x) {
      this.addPoint(x, null);
    }

    addY(y) {
      this.addPoint(null, y);
    }

    addBoundingBox(boundingBox) {
      if (!boundingBox) {
        return;
      }

      var {
        x1,
        y1,
        x2,
        y2
      } = boundingBox;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }

    sumCubic(t, p0, p1, p2, p3) {
      return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
    }

    bezierCurveAdd(forX, p0, p1, p2, p3) {
      var b = 6 * p0 - 12 * p1 + 6 * p2;
      var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
      var c = 3 * p1 - 3 * p0;

      if (a === 0) {
        if (b === 0) {
          return;
        }

        var t = -c / b;

        if (0 < t && t < 1) {
          if (forX) {
            this.addX(this.sumCubic(t, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t, p0, p1, p2, p3));
          }
        }

        return;
      }

      var b2ac = Math.pow(b, 2) - 4 * c * a;

      if (b2ac < 0) {
        return;
      }

      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);

      if (0 < t1 && t1 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t1, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t1, p0, p1, p2, p3));
        }
      }

      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);

      if (0 < t2 && t2 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t2, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t2, p0, p1, p2, p3));
        }
      }
    } // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html


    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
      this.addPoint(p0x, p0y);
      this.addPoint(p3x, p3y);
      this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
      this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
    }

    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
      var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)

      var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)

      var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)

      var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)

      this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
    }

    isPointInBox(x, y) {
      var {
        x1,
        y1,
        x2,
        y2
      } = this;
      return x1 <= x && x <= x2 && y1 <= y && y <= y2;
    }

  }

  class PathParser extends _ {
    constructor(path) {
      super(path // Fix spaces after signs.
      .replace(/([+\-.])\s+/gm, '$1') // Remove invalid part.
      .replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ''));
      this.control = null;
      this.start = null;
      this.current = null;
      this.command = null;
      this.commands = this.commands;
      this.i = -1;
      this.previousCommand = null;
      this.points = [];
      this.angles = [];
    }

    reset() {
      this.i = -1;
      this.command = null;
      this.previousCommand = null;
      this.start = new Point(0, 0);
      this.control = new Point(0, 0);
      this.current = new Point(0, 0);
      this.points = [];
      this.angles = [];
    }

    isEnd() {
      var {
        i,
        commands
      } = this;
      return i >= commands.length - 1;
    }

    next() {
      var command = this.commands[++this.i];
      this.previousCommand = this.command;
      this.command = command;
      return command;
    }

    getPoint() {
      var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';
      var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';
      var point = new Point(this.command[xProp], this.command[yProp]);
      return this.makeAbsolute(point);
    }

    getAsControlPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.control = point;
      return point;
    }

    getAsCurrentPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.current = point;
      return point;
    }

    getReflectedControlPoint() {
      var previousCommand = this.previousCommand.type;

      if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
        return this.current;
      } // reflect point


      var {
        current: {
          x: cx,
          y: cy
        },
        control: {
          x: ox,
          y: oy
        }
      } = this;
      var point = new Point(2 * cx - ox, 2 * cy - oy);
      return point;
    }

    makeAbsolute(point) {
      if (this.command.relative) {
        var {
          x,
          y
        } = this.current;
        point.x += x;
        point.y += y;
      }

      return point;
    }

    addMarker(point, from, priorTo) {
      var {
        points,
        angles
      } = this; // if the last angle isn't filled in because we didn't have this point yet ...

      if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
        angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
      }

      this.addMarkerAngle(point, from ? from.angleTo(point) : null);
    }

    addMarkerAngle(point, angle) {
      this.points.push(point);
      this.angles.push(angle);
    }

    getMarkerPoints() {
      return this.points;
    }

    getMarkerAngles() {
      var {
        angles
      } = this;
      var len = angles.length;

      for (var i = 0; i < len; i++) {
        if (!angles[i]) {
          for (var j = i + 1; j < len; j++) {
            if (angles[j]) {
              angles[i] = angles[j];
              break;
            }
          }
        }
      }

      return angles;
    }

  }

  class RenderedElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.modifiedEmSizeStack = false;
    }

    calculateOpacity() {
      var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this

      var element = this;

      while (element) {
        var opacityStyle = element.getStyle('opacity', false, true); // no ancestors on style call

        if (opacityStyle.hasValue(true)) {
          opacity *= opacityStyle.getNumber();
        }

        element = element.parent;
      }

      return opacity;
    }

    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!fromMeasure) {
        // causes stack overflow when measuring text with gradients
        // fill
        var fillStyleProp = this.getStyle('fill');
        var fillOpacityStyleProp = this.getStyle('fill-opacity');
        var strokeStyleProp = this.getStyle('stroke');
        var strokeOpacityProp = this.getStyle('stroke-opacity');

        if (fillStyleProp.isUrlDefinition()) {
          var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);

          if (fillStyle) {
            ctx.fillStyle = fillStyle;
          }
        } else if (fillStyleProp.hasValue()) {
          if (fillStyleProp.getString() === 'currentColor') {
            fillStyleProp.setValue(this.getStyle('color').getColor());
          }

          var _fillStyle = fillStyleProp.getColor();

          if (_fillStyle !== 'inherit') {
            ctx.fillStyle = _fillStyle === 'none' ? 'rgba(0,0,0,0)' : _fillStyle;
          }
        }

        if (fillOpacityStyleProp.hasValue()) {
          var _fillStyle2 = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();

          ctx.fillStyle = _fillStyle2;
        } // stroke


        if (strokeStyleProp.isUrlDefinition()) {
          var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);

          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
          }
        } else if (strokeStyleProp.hasValue()) {
          if (strokeStyleProp.getString() === 'currentColor') {
            strokeStyleProp.setValue(this.getStyle('color').getColor());
          }

          var _strokeStyle = strokeStyleProp.getString();

          if (_strokeStyle !== 'inherit') {
            ctx.strokeStyle = _strokeStyle === 'none' ? 'rgba(0,0,0,0)' : _strokeStyle;
          }
        }

        if (strokeOpacityProp.hasValue()) {
          var _strokeStyle2 = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();

          ctx.strokeStyle = _strokeStyle2;
        }

        var strokeWidthStyleProp = this.getStyle('stroke-width');

        if (strokeWidthStyleProp.hasValue()) {
          var newLineWidth = strokeWidthStyleProp.getPixels();
          ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)
          : newLineWidth;
        }

        var strokeLinecapStyleProp = this.getStyle('stroke-linecap');
        var strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');
        var strokeMiterlimitProp = this.getStyle('stroke-miterlimit'); // NEED TEST
        // const pointOrderStyleProp = this.getStyle('paint-order');

        var strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');
        var strokeDashoffsetProp = this.getStyle('stroke-dashoffset');

        if (strokeLinecapStyleProp.hasValue()) {
          ctx.lineCap = strokeLinecapStyleProp.getString();
        }

        if (strokeLinejoinStyleProp.hasValue()) {
          ctx.lineJoin = strokeLinejoinStyleProp.getString();
        }

        if (strokeMiterlimitProp.hasValue()) {
          ctx.miterLimit = strokeMiterlimitProp.getNumber();
        } // NEED TEST
        // if (pointOrderStyleProp.hasValue()) {
        // 	// ?
        // 	ctx.paintOrder = pointOrderStyleProp.getValue();
        // }


        if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {
          var gaps = toNumbers(strokeDasharrayStyleProp.getString());

          if (typeof ctx.setLineDash !== 'undefined') {
            ctx.setLineDash(gaps);
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.webkitLineDash !== 'undefined') {
              // @ts-expect-error Handle browser prefix.
              ctx.webkitLineDash = gaps;
            } else // @ts-expect-error Handle browser prefix.
              if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {
                // @ts-expect-error Handle browser prefix.
                ctx.mozDash = gaps;
              }

          var offset = strokeDashoffsetProp.getPixels();

          if (typeof ctx.lineDashOffset !== 'undefined') {
            ctx.lineDashOffset = offset;
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.webkitLineDashOffset !== 'undefined') {
              // @ts-expect-error Handle browser prefix.
              ctx.webkitLineDashOffset = offset;
            } else // @ts-expect-error Handle browser prefix.
              if (typeof ctx.mozDashOffset !== 'undefined') {
                // @ts-expect-error Handle browser prefix.
                ctx.mozDashOffset = offset;
              }
        }
      } // font


      this.modifiedEmSizeStack = false;

      if (typeof ctx.font !== 'undefined') {
        var fontStyleProp = this.getStyle('font');
        var fontStyleStyleProp = this.getStyle('font-style');
        var fontVariantStyleProp = this.getStyle('font-variant');
        var fontWeightStyleProp = this.getStyle('font-weight');
        var fontSizeStyleProp = this.getStyle('font-size');
        var fontFamilyStyleProp = this.getStyle('font-family');
        var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
        fontStyleStyleProp.setValue(font.fontStyle);
        fontVariantStyleProp.setValue(font.fontVariant);
        fontWeightStyleProp.setValue(font.fontWeight);
        fontSizeStyleProp.setValue(font.fontSize);
        fontFamilyStyleProp.setValue(font.fontFamily);
        ctx.font = font.toString();

        if (fontSizeStyleProp.isPixels()) {
          this.document.emSize = fontSizeStyleProp.getPixels();
          this.modifiedEmSizeStack = true;
        }
      }

      if (!fromMeasure) {
        // effects
        this.applyEffects(ctx); // opacity

        ctx.globalAlpha = this.calculateOpacity();
      }
    }

    clearContext(ctx) {
      super.clearContext(ctx);

      if (this.modifiedEmSizeStack) {
        this.document.popEmSize();
      }
    }

  }

  class PathElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'path';
      this.pathParser = null;
      this.pathParser = new PathParser(this.getAttribute('d').getString());
    }

    path(ctx) {
      var {
        pathParser
      } = this;
      var boundingBox = new BoundingBox();
      pathParser.reset();

      if (ctx) {
        ctx.beginPath();
      }

      while (!pathParser.isEnd()) {
        switch (pathParser.next().type) {
          case PathParser.MOVE_TO:
            this.pathM(ctx, boundingBox);
            break;

          case PathParser.LINE_TO:
            this.pathL(ctx, boundingBox);
            break;

          case PathParser.HORIZ_LINE_TO:
            this.pathH(ctx, boundingBox);
            break;

          case PathParser.VERT_LINE_TO:
            this.pathV(ctx, boundingBox);
            break;

          case PathParser.CURVE_TO:
            this.pathC(ctx, boundingBox);
            break;

          case PathParser.SMOOTH_CURVE_TO:
            this.pathS(ctx, boundingBox);
            break;

          case PathParser.QUAD_TO:
            this.pathQ(ctx, boundingBox);
            break;

          case PathParser.SMOOTH_QUAD_TO:
            this.pathT(ctx, boundingBox);
            break;

          case PathParser.ARC:
            this.pathA(ctx, boundingBox);
            break;

          case PathParser.CLOSE_PATH:
            this.pathZ(ctx, boundingBox);
            break;
        }
      }

      return boundingBox;
    }

    getBoundingBox(_) {
      return this.path();
    }

    getMarkers() {
      var {
        pathParser
      } = this;
      var points = pathParser.getMarkerPoints();
      var angles = pathParser.getMarkerAngles();
      var markers = points.map((point, i) => [point, angles[i]]);
      return markers;
    }

    renderChildren(ctx) {
      this.path(ctx);
      this.document.screen.mouse.checkPath(this, ctx);
      var fillRuleStyleProp = this.getStyle('fill-rule');

      if (ctx.fillStyle !== '') {
        if (fillRuleStyleProp.getString('inherit') !== 'inherit') {
          ctx.fill(fillRuleStyleProp.getString());
        } else {
          ctx.fill();
        }
      }

      if (ctx.strokeStyle !== '') {
        if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.stroke();
        }
      }

      var markers = this.getMarkers();

      if (markers) {
        var markersLastIndex = markers.length - 1;
        var markerStartStyleProp = this.getStyle('marker-start');
        var markerMidStyleProp = this.getStyle('marker-mid');
        var markerEndStyleProp = this.getStyle('marker-end');

        if (markerStartStyleProp.isUrlDefinition()) {
          var marker = markerStartStyleProp.getDefinition();
          var [point, angle] = markers[0];
          marker.render(ctx, point, angle);
        }

        if (markerMidStyleProp.isUrlDefinition()) {
          var _marker = markerMidStyleProp.getDefinition();

          for (var i = 1; i < markersLastIndex; i++) {
            var [_point, _angle] = markers[i];

            _marker.render(ctx, _point, _angle);
          }
        }

        if (markerEndStyleProp.isUrlDefinition()) {
          var _marker2 = markerEndStyleProp.getDefinition();

          var [_point2, _angle2] = markers[markersLastIndex];

          _marker2.render(ctx, _point2, _angle2);
        }
      }
    }

    static pathM(pathParser) {
      var point = pathParser.getAsCurrentPoint();
      pathParser.start = pathParser.current;
      return {
        point
      };
    }

    pathM(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        point
      } = PathElement.pathM(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.moveTo(x, y);
      }
    }

    static pathL(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getAsCurrentPoint();
      return {
        current,
        point
      };
    }

    pathL(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathL(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathH(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }

    pathH(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathH(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathV(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }

    pathV(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathV(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathC(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getPoint('x1', 'y1');
      var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }

    pathC(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathS(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getReflectedControlPoint();
      var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }

    pathS(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathQ(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getAsControlPoint('x1', 'y1');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }

    pathQ(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathT(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getReflectedControlPoint();
      pathParser.control = controlPoint;
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }

    pathT(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathA(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var {
        rX,
        rY,
        xRot,
        lArcFlag,
        sweepFlag
      } = command;
      var xAxisRotation = xRot * (Math.PI / 180.0);
      var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization
      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
      // x1', y1'

      var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii

      var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);

      if (l > 1) {
        rX *= Math.sqrt(l);
        rY *= Math.sqrt(l);
      } // cx', cy'


      var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));

      if (isNaN(s)) {
        s = 0;
      }

      var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy

      var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle

      var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]); // θ1
      // angle delta

      var u = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
      var v = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
      var ad = vectorsAngle(u, v); // Δθ

      if (vectorsRatio(u, v) <= -1) {
        ad = Math.PI;
      }

      if (vectorsRatio(u, v) >= 1) {
        ad = 0;
      }

      return {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      };
    }

    pathA(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser); // for markers

      var dir = 1 - sweepFlag ? 1.0 : -1.0;
      var ah = a1 + dir * (ad / 2.0);
      var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
      pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
      pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
      boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better

      if (ctx && !isNaN(a1) && !isNaN(ad)) {
        var r = rX > rY ? rX : rY;
        var sx = rX > rY ? 1 : rX / rY;
        var sy = rX > rY ? rY / rX : 1;
        ctx.translate(centp.x, centp.y);
        ctx.rotate(xAxisRotation);
        ctx.scale(sx, sy);
        ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));
        ctx.scale(1 / sx, 1 / sy);
        ctx.rotate(-xAxisRotation);
        ctx.translate(-centp.x, -centp.y);
      }
    }

    static pathZ(pathParser) {
      pathParser.current = pathParser.start;
    }

    pathZ(ctx, boundingBox) {
      PathElement.pathZ(this.pathParser);

      if (ctx) {
        // only close path if it is not a straight line
        if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
          ctx.closePath();
        }
      }
    }

  }

  class GlyphElement extends PathElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'glyph';
      this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
      this.unicode = this.getAttribute('unicode').getString();
      this.arabicForm = this.getAttribute('arabic-form').getString();
    }

  }

  class TextElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, new.target === TextElement ? true : captureTextNodes);
      this.type = 'text';
      this.x = 0;
      this.y = 0;
      this.measureCache = -1;
    }

    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      super.setContext(ctx, fromMeasure);
      var textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();

      if (textBaseline) {
        ctx.textBaseline = textBaseline;
      }
    }

    initializeCoordinates() {
      this.x = 0;
      this.y = 0;
      this.leafTexts = [];
      this.textChunkStart = 0;
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
    }

    getBoundingBox(ctx) {
      if (this.type !== 'text') {
        return this.getTElementBoundingBox(ctx);
      } // first, calculate child positions


      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      var boundingBox = null; // then calculate bounding box

      this.children.forEach((_, i) => {
        var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);

        if (!boundingBox) {
          boundingBox = childBoundingBox;
        } else {
          boundingBox.addBoundingBox(childBoundingBox);
        }
      });
      return boundingBox;
    }

    getFontSize() {
      var {
        document,
        parent
      } = this;
      var inheritFontSize = Font.parse(document.ctx.font).fontSize;
      var fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);
      return fontSize;
    }

    getTElementBoundingBox(ctx) {
      var fontSize = this.getFontSize();
      return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
    }

    getGlyph(font, text, i) {
      var char = text[i];
      var glyph = null;

      if (font.isArabic) {
        var len = text.length;
        var prevChar = text[i - 1];
        var nextChar = text[i + 1];
        var arabicForm = 'isolated';

        if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {
          arabicForm = 'terminal';
        }

        if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {
          arabicForm = 'medial';
        }

        if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {
          arabicForm = 'initial';
        }

        if (typeof font.glyphs[char] !== 'undefined') {
          // NEED TEST
          var maybeGlyph = font.glyphs[char];
          glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
        }
      } else {
        glyph = font.glyphs[char];
      }

      if (!glyph) {
        glyph = font.missingGlyph;
      }

      return glyph;
    }

    getText() {
      return '';
    }

    getTextFromNode(node) {
      var textNode = node || this.node;
      var childNodes = Array.from(textNode.parentNode.childNodes);
      var index = childNodes.indexOf(textNode);
      var lastIndex = childNodes.length - 1;
      var text = compressSpaces( // textNode.value
      // || textNode.text
      textNode.textContent || '');

      if (index === 0) {
        text = trimLeft(text);
      }

      if (index === lastIndex) {
        text = trimRight(text);
      }

      return text;
    }

    renderChildren(ctx) {
      if (this.type !== 'text') {
        this.renderTElementChildren(ctx);
        return;
      } // first, calculate child positions


      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx); // then render

      this.children.forEach((_, i) => {
        this.renderChild(ctx, this, this, i);
      });
      var {
        mouse
      } = this.document.screen; // Do not calc bounding box if mouse is not working.

      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
      }
    }

    renderTElementChildren(ctx) {
      var {
        document,
        parent
      } = this;
      var renderText = this.getText();
      var customFont = parent.getStyle('font-family').getDefinition();

      if (customFont) {
        var {
          unitsPerEm
        } = customFont.fontFace;
        var ctxFont = Font.parse(document.ctx.font);
        var fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);
        var fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);
        var scale = fontSize / unitsPerEm;
        var text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;
        var dx = toNumbers(parent.getAttribute('dx').getString());
        var len = text.length;

        for (var i = 0; i < len; i++) {
          var glyph = this.getGlyph(customFont, text, i);
          ctx.translate(this.x, this.y);
          ctx.scale(scale, -scale);
          var lw = ctx.lineWidth;
          ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;

          if (fontStyle === 'italic') {
            ctx.transform(1, 0, .4, 1, 0, 0);
          }

          glyph.render(ctx);

          if (fontStyle === 'italic') {
            ctx.transform(1, 0, -.4, 1, 0, 0);
          }

          ctx.lineWidth = lw;
          ctx.scale(1 / scale, -1 / scale);
          ctx.translate(-this.x, -this.y);
          this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;

          if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
            this.x += dx[i];
          }
        }

        return;
      }

      var {
        x,
        y
      } = this; // NEED TEST
      // if (ctx.paintOrder === 'stroke') {
      // 	if (ctx.strokeStyle) {
      // 		ctx.strokeText(renderText, x, y);
      // 	}
      // 	if (ctx.fillStyle) {
      // 		ctx.fillText(renderText, x, y);
      // 	}
      // } else {

      if (ctx.fillStyle) {
        ctx.fillText(renderText, x, y);
      }

      if (ctx.strokeStyle) {
        ctx.strokeText(renderText, x, y);
      } // }

    }

    applyAnchoring() {
      if (this.textChunkStart >= this.leafTexts.length) {
        return;
      } // This is basically the "Apply anchoring" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.
      // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.
      // Vertical text is not supported.


      var firstElement = this.leafTexts[this.textChunkStart];
      var textAnchor = firstElement.getStyle('text-anchor').getString('start');
      var isRTL = false; // we treat RTL like LTR

      var shift = 0;

      if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {
        shift = firstElement.x - this.minX;
      } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {
        shift = firstElement.x - this.maxX;
      } else {
        shift = firstElement.x - (this.minX + this.maxX) / 2;
      }

      for (var i = this.textChunkStart; i < this.leafTexts.length; i++) {
        this.leafTexts[i].x += shift;
      } // start new chunk


      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.textChunkStart = this.leafTexts.length;
    }

    adjustChildCoordinatesRecursive(ctx) {
      this.children.forEach((_, i) => {
        this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);
      });
      this.applyAnchoring();
    }

    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {
      var child = parent.children[i];

      if (child.children.length > 0) {
        child.children.forEach((_, i) => {
          textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);
        });
      } else {
        // only leafs are relevant
        this.adjustChildCoordinates(ctx, textParent, parent, i);
      }
    }

    adjustChildCoordinates(ctx, textParent, parent, i) {
      var child = parent.children[i];

      if (typeof child.measureText !== 'function') {
        return child;
      }

      ctx.save();
      child.setContext(ctx, true);
      var xAttr = child.getAttribute('x');
      var yAttr = child.getAttribute('y');
      var dxAttr = child.getAttribute('dx');
      var dyAttr = child.getAttribute('dy');
      var customFont = child.getStyle('font-family').getDefinition();
      var isRTL = Boolean(customFont) && customFont.isRTL;

      if (i === 0) {
        // First children inherit attributes from parent(s). Positional attributes
        // are only inherited from a parent to it's first child.
        if (!xAttr.hasValue()) {
          xAttr.setValue(child.getInheritedAttribute('x'));
        }

        if (!yAttr.hasValue()) {
          yAttr.setValue(child.getInheritedAttribute('y'));
        }

        if (!dxAttr.hasValue()) {
          dxAttr.setValue(child.getInheritedAttribute('dx'));
        }

        if (!dyAttr.hasValue()) {
          dyAttr.setValue(child.getInheritedAttribute('dy'));
        }
      }

      var width = child.measureText(ctx);

      if (isRTL) {
        textParent.x -= width;
      }

      if (xAttr.hasValue()) {
        // an "x" attribute marks the start of a new chunk
        textParent.applyAnchoring();
        child.x = xAttr.getPixels('x');

        if (dxAttr.hasValue()) {
          child.x += dxAttr.getPixels('x');
        }
      } else {
        if (dxAttr.hasValue()) {
          textParent.x += dxAttr.getPixels('x');
        }

        child.x = textParent.x;
      }

      textParent.x = child.x;

      if (!isRTL) {
        textParent.x += width;
      }

      if (yAttr.hasValue()) {
        child.y = yAttr.getPixels('y');

        if (dyAttr.hasValue()) {
          child.y += dyAttr.getPixels('y');
        }
      } else {
        if (dyAttr.hasValue()) {
          textParent.y += dyAttr.getPixels('y');
        }

        child.y = textParent.y;
      }

      textParent.y = child.y; // update the current chunk and it's bounds

      textParent.leafTexts.push(child);
      textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
      textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
      child.clearContext(ctx);
      ctx.restore();
      return child;
    }

    getChildBoundingBox(ctx, textParent, parent, i) {
      var child = parent.children[i]; // not a text node?

      if (typeof child.getBoundingBox !== 'function') {
        return null;
      }

      var boundingBox = child.getBoundingBox(ctx);

      if (!boundingBox) {
        return null;
      }

      child.children.forEach((_, i) => {
        var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);
        boundingBox.addBoundingBox(childBoundingBox);
      });
      return boundingBox;
    }

    renderChild(ctx, textParent, parent, i) {
      var child = parent.children[i];
      child.render(ctx);
      child.children.forEach((_, i) => {
        textParent.renderChild(ctx, textParent, child, i);
      });
    }

    measureText(ctx) {
      var {
        measureCache
      } = this;

      if (~measureCache) {
        return measureCache;
      }

      var renderText = this.getText();
      var measure = this.measureTargetText(ctx, renderText);
      this.measureCache = measure;
      return measure;
    }

    measureTargetText(ctx, targetText) {
      if (!targetText.length) {
        return 0;
      }

      var {
        parent
      } = this;
      var customFont = parent.getStyle('font-family').getDefinition();

      if (customFont) {
        var fontSize = this.getFontSize();
        var text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;
        var dx = toNumbers(parent.getAttribute('dx').getString());
        var len = text.length;
        var _measure = 0;

        for (var i = 0; i < len; i++) {
          var glyph = this.getGlyph(customFont, text, i);
          _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;

          if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
            _measure += dx[i];
          }
        }

        return _measure;
      }

      if (!ctx.measureText) {
        return targetText.length * 10;
      }

      ctx.save();
      this.setContext(ctx, true);
      var {
        width: measure
      } = ctx.measureText(targetText);
      this.clearContext(ctx);
      ctx.restore();
      return measure;
    }
    /**
     * Inherits positional attributes from {@link TextElement} parent(s). Attributes
     * are only inherited from a parent to its first child.
     * @param name - The attribute name.
     * @returns The attribute value or null.
     */


    getInheritedAttribute(name) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
      var current = this;

      while (current instanceof TextElement && current.isFirstChild()) {
        var parentAttr = current.parent.getAttribute(name);

        if (parentAttr.hasValue(true)) {
          return parentAttr.getValue('0');
        }

        current = current.parent;
      }

      return null;
    }

  }

  class TSpanElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, new.target === TSpanElement ? true : captureTextNodes);
      this.type = 'tspan'; // if this node has children, then they own the text

      this.text = this.children.length > 0 ? '' : this.getTextFromNode();
    }

    getText() {
      return this.text;
    }

  }

  class TextNode extends TSpanElement {
    constructor() {
      super(...arguments);
      this.type = 'textNode';
    }

  }

  class SVGElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'svg';
      this.root = false;
    }

    setContext(ctx) {
      var _this$node$parentNode;

      var {
        document
      } = this;
      var {
        screen,
        window
      } = document;
      var canvas = ctx.canvas;
      screen.setDefaults(ctx);

      if (canvas.style && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {
        ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');
        var fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);

        if (fontSizeProp.hasValue()) {
          document.rootEmSize = fontSizeProp.getPixels('y');
          document.emSize = document.rootEmSize;
        }
      } // create new view port


      if (!this.getAttribute('x').hasValue()) {
        this.getAttribute('x', true).setValue(0);
      }

      if (!this.getAttribute('y').hasValue()) {
        this.getAttribute('y', true).setValue(0);
      }

      var {
        width,
        height
      } = screen.viewPort;

      if (!this.getStyle('width').hasValue()) {
        this.getStyle('width', true).setValue('100%');
      }

      if (!this.getStyle('height').hasValue()) {
        this.getStyle('height', true).setValue('100%');
      }

      if (!this.getStyle('color').hasValue()) {
        this.getStyle('color', true).setValue('black');
      }

      var refXAttr = this.getAttribute('refX');
      var refYAttr = this.getAttribute('refY');
      var viewBoxAttr = this.getAttribute('viewBox');
      var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
      var clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';
      var minX = 0;
      var minY = 0;
      var clipX = 0;
      var clipY = 0;

      if (viewBox) {
        minX = viewBox[0];
        minY = viewBox[1];
      }

      if (!this.root) {
        width = this.getStyle('width').getPixels('x');
        height = this.getStyle('height').getPixels('y');

        if (this.type === 'marker') {
          clipX = minX;
          clipY = minY;
          minX = 0;
          minY = 0;
        }
      }

      screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements
      // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin

      if (this.node // is not temporary SVGElement
      && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {
        this.getStyle('transform-origin', true, true).setValue('50% 50%');
      }

      super.setContext(ctx);
      ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));

      if (viewBox) {
        width = viewBox[2];
        height = viewBox[3];
      }

      document.setViewBox({
        ctx,
        aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
        width: screen.viewPort.width,
        desiredWidth: width,
        height: screen.viewPort.height,
        desiredHeight: height,
        minX,
        minY,
        refX: refXAttr.getValue(),
        refY: refYAttr.getValue(),
        clip,
        clipX,
        clipY
      });

      if (viewBox) {
        screen.viewPort.removeCurrent();
        screen.viewPort.setCurrent(width, height);
      }
    }

    clearContext(ctx) {
      super.clearContext(ctx);
      this.document.screen.viewPort.removeCurrent();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */


    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var widthAttr = this.getAttribute('width', true);
      var heightAttr = this.getAttribute('height', true);
      var viewBoxAttr = this.getAttribute('viewBox');
      var styleAttr = this.getAttribute('style');
      var originWidth = widthAttr.getNumber(0);
      var originHeight = heightAttr.getNumber(0);

      if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === 'string') {
          this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);
        } else {
          var preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');

          if (preserveAspectRatioAttr.hasValue()) {
            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, '$1'));
          }
        }
      }

      widthAttr.setValue(width);
      heightAttr.setValue(height);

      if (!viewBoxAttr.hasValue()) {
        viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
      }

      if (styleAttr.hasValue()) {
        var widthStyle = this.getStyle('width');
        var heightStyle = this.getStyle('height');

        if (widthStyle.hasValue()) {
          widthStyle.setValue("".concat(width, "px"));
        }

        if (heightStyle.hasValue()) {
          heightStyle.setValue("".concat(height, "px"));
        }
      }
    }

  }

  class RectElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'rect';
    }

    path(ctx) {
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width', false, true).getPixels('x');
      var height = this.getStyle('height', false, true).getPixels('y');
      var rxAttr = this.getAttribute('rx');
      var ryAttr = this.getAttribute('ry');
      var rx = rxAttr.getPixels('x');
      var ry = ryAttr.getPixels('y');

      if (rxAttr.hasValue() && !ryAttr.hasValue()) {
        ry = rx;
      }

      if (ryAttr.hasValue() && !rxAttr.hasValue()) {
        rx = ry;
      }

      rx = Math.min(rx, width / 2.0);
      ry = Math.min(ry, height / 2.0);

      if (ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        ctx.beginPath(); // always start the path so we don't fill prior paths

        if (height > 0 && width > 0) {
          ctx.moveTo(x + rx, y);
          ctx.lineTo(x + width - rx, y);
          ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);
          ctx.lineTo(x + width, y + height - ry);
          ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);
          ctx.lineTo(x + rx, y + height);
          ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);
          ctx.lineTo(x, y + ry);
          ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);
          ctx.closePath();
        }
      }

      return new BoundingBox(x, y, x + width, y + height);
    }

    getMarkers() {
      return null;
    }

  }

  class CircleElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'circle';
    }

    path(ctx) {
      var cx = this.getAttribute('cx').getPixels('x');
      var cy = this.getAttribute('cy').getPixels('y');
      var r = this.getAttribute('r').getPixels();

      if (ctx && r > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2, false);
        ctx.closePath();
      }

      return new BoundingBox(cx - r, cy - r, cx + r, cy + r);
    }

    getMarkers() {
      return null;
    }

  }

  class EllipseElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'ellipse';
    }

    path(ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      var rx = this.getAttribute('rx').getPixels('x');
      var ry = this.getAttribute('ry').getPixels('y');
      var cx = this.getAttribute('cx').getPixels('x');
      var cy = this.getAttribute('cy').getPixels('y');

      if (ctx && rx > 0 && ry > 0) {
        ctx.beginPath();
        ctx.moveTo(cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
        ctx.closePath();
      }

      return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }

    getMarkers() {
      return null;
    }

  }

  class LineElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'line';
    }

    getPoints() {
      return [new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')), new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))];
    }

    path(ctx) {
      var [{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }] = this.getPoints();

      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
      }

      return new BoundingBox(x0, y0, x1, y1);
    }

    getMarkers() {
      var [p0, p1] = this.getPoints();
      var a = p0.angleTo(p1);
      return [[p0, a], [p1, a]];
    }

  }

  class PolylineElement extends PathElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'polyline';
      this.points = [];
      this.points = Point.parsePath(this.getAttribute('points').getString());
    }

    path(ctx) {
      var {
        points
      } = this;
      var [{
        x: x0,
        y: y0
      }] = points;
      var boundingBox = new BoundingBox(x0, y0);

      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
      }

      points.forEach(_ref => {
        var {
          x,
          y
        } = _ref;
        boundingBox.addPoint(x, y);

        if (ctx) {
          ctx.lineTo(x, y);
        }
      });
      return boundingBox;
    }

    getMarkers() {
      var {
        points
      } = this;
      var lastIndex = points.length - 1;
      var markers = [];
      points.forEach((point, i) => {
        if (i === lastIndex) {
          return;
        }

        markers.push([point, point.angleTo(points[i + 1])]);
      });

      if (markers.length > 0) {
        markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
      }

      return markers;
    }

  }

  class PolygonElement extends PolylineElement {
    constructor() {
      super(...arguments);
      this.type = 'polygon';
    }

    path(ctx) {
      var boundingBox = super.path(ctx);
      var [{
        x,
        y
      }] = this.points;

      if (ctx) {
        ctx.lineTo(x, y);
        ctx.closePath();
      }

      return boundingBox;
    }

  }

  class PatternElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'pattern';
    }

    createPattern(ctx, _, parentOpacityProp) {
      var width = this.getStyle('width').getPixels('x', true);
      var height = this.getStyle('height').getPixels('y', true); // render me using a temporary svg element

      var patternSvg = new SVGElement(this.document, null);
      patternSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
      patternSvg.attributes.width = new Property(this.document, 'width', "".concat(width, "px"));
      patternSvg.attributes.height = new Property(this.document, 'height', "".concat(height, "px"));
      patternSvg.attributes.transform = new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue());
      patternSvg.children = this.children;
      var patternCanvas = this.document.createCanvas(width, height);
      var patternCtx = patternCanvas.getContext('2d');
      var xAttr = this.getAttribute('x');
      var yAttr = this.getAttribute('y');

      if (xAttr.hasValue() && yAttr.hasValue()) {
        patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));
      }

      if (parentOpacityProp.hasValue()) {
        this.styles['fill-opacity'] = parentOpacityProp;
      } else {
        Reflect.deleteProperty(this.styles, 'fill-opacity');
      } // render 3x3 grid so when we transform there's no white space on edges


      for (var x = -1; x <= 1; x++) {
        for (var y = -1; y <= 1; y++) {
          patternCtx.save();
          patternSvg.attributes.x = new Property(this.document, 'x', x * patternCanvas.width);
          patternSvg.attributes.y = new Property(this.document, 'y', y * patternCanvas.height);
          patternSvg.render(patternCtx);
          patternCtx.restore();
        }
      }

      var pattern = ctx.createPattern(patternCanvas, 'repeat');
      return pattern;
    }

  }

  class MarkerElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'marker';
    }

    render(ctx, point, angle) {
      if (!point) {
        return;
      }

      var {
        x,
        y
      } = point;
      var orient = this.getAttribute('orient').getString('auto');
      var markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');
      ctx.translate(x, y);

      if (orient === 'auto') {
        ctx.rotate(angle);
      }

      if (markerUnits === 'strokeWidth') {
        ctx.scale(ctx.lineWidth, ctx.lineWidth);
      }

      ctx.save(); // render me using a temporary svg element

      var markerSvg = new SVGElement(this.document, null);
      markerSvg.type = this.type;
      markerSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
      markerSvg.attributes.refX = new Property(this.document, 'refX', this.getAttribute('refX').getValue());
      markerSvg.attributes.refY = new Property(this.document, 'refY', this.getAttribute('refY').getValue());
      markerSvg.attributes.width = new Property(this.document, 'width', this.getAttribute('markerWidth').getValue());
      markerSvg.attributes.height = new Property(this.document, 'height', this.getAttribute('markerHeight').getValue());
      markerSvg.attributes.overflow = new Property(this.document, 'overflow', this.getAttribute('overflow').getValue());
      markerSvg.attributes.fill = new Property(this.document, 'fill', this.getAttribute('fill').getColor('black'));
      markerSvg.attributes.stroke = new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none'));
      markerSvg.children = this.children;
      markerSvg.render(ctx);
      ctx.restore();

      if (markerUnits === 'strokeWidth') {
        ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
      }

      if (orient === 'auto') {
        ctx.rotate(-angle);
      }

      ctx.translate(-x, -y);
    }

  }

  class DefsElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'defs';
    }

    render() {// NOOP
    }

  }

  class GElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'g';
    }

    getBoundingBox(ctx) {
      var boundingBox = new BoundingBox();
      this.children.forEach(child => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      return boundingBox;
    }

  }

  class GradientElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.attributesToInherit = ['gradientUnits'];
      this.stops = [];
      var {
        stops,
        children
      } = this;
      children.forEach(child => {
        if (child.type === 'stop') {
          stops.push(child);
        }
      });
    }

    getGradientUnits() {
      return this.getAttribute('gradientUnits').getString('objectBoundingBox');
    }

    createGradient(ctx, element, parentOpacityProp) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
      var stopsContainer = this;

      if (this.getHrefAttribute().hasValue()) {
        stopsContainer = this.getHrefAttribute().getDefinition();
        this.inheritStopContainer(stopsContainer);
      }

      var {
        stops
      } = stopsContainer;
      var gradient = this.getGradient(ctx, element);

      if (!gradient) {
        return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
      }

      stops.forEach(stop => {
        gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
      });

      if (this.getAttribute('gradientTransform').hasValue()) {
        // render as transformed pattern on temporary canvas
        var {
          document
        } = this;
        var {
          MAX_VIRTUAL_PIXELS,
          viewPort
        } = document.screen;
        var [rootView] = viewPort.viewPorts;
        var rect = new RectElement(document, null);
        rect.attributes.x = new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3.0);
        rect.attributes.y = new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3.0);
        rect.attributes.width = new Property(document, 'width', MAX_VIRTUAL_PIXELS);
        rect.attributes.height = new Property(document, 'height', MAX_VIRTUAL_PIXELS);
        var group = new GElement(document, null);
        group.attributes.transform = new Property(document, 'transform', this.getAttribute('gradientTransform').getValue());
        group.children = [rect];
        var patternSvg = new SVGElement(document, null);
        patternSvg.attributes.x = new Property(document, 'x', 0);
        patternSvg.attributes.y = new Property(document, 'y', 0);
        patternSvg.attributes.width = new Property(document, 'width', rootView.width);
        patternSvg.attributes.height = new Property(document, 'height', rootView.height);
        patternSvg.children = [group];
        var patternCanvas = document.createCanvas(rootView.width, rootView.height);
        var patternCtx = patternCanvas.getContext('2d');
        patternCtx.fillStyle = gradient;
        patternSvg.render(patternCtx);
        return patternCtx.createPattern(patternCanvas, 'no-repeat');
      }

      return gradient;
    }

    inheritStopContainer(stopsContainer) {
      this.attributesToInherit.forEach(attributeToInherit => {
        if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
          this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
        }
      });
    }

    addParentOpacity(parentOpacityProp, color) {
      if (parentOpacityProp.hasValue()) {
        var colorProp = new Property(this.document, 'color', color);
        return colorProp.addOpacity(parentOpacityProp).getColor();
      }

      return color;
    }

  }

  class LinearGradientElement extends GradientElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'linearGradient';
      this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');
    }

    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
      var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;

      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }

      if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {
        this.getAttribute('x1', true).setValue(0);
        this.getAttribute('y1', true).setValue(0);
        this.getAttribute('x2', true).setValue(1);
        this.getAttribute('y2', true).setValue(0);
      }

      var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');
      var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');
      var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');
      var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');

      if (x1 === x2 && y1 === y2) {
        return null;
      }

      return ctx.createLinearGradient(x1, y1, x2, y2);
    }

  }

  class RadialGradientElement extends GradientElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'radialGradient';
      this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');
    }

    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
      var boundingBox = element.getBoundingBox(ctx);

      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }

      if (!this.getAttribute('cx').hasValue()) {
        this.getAttribute('cx', true).setValue('50%');
      }

      if (!this.getAttribute('cy').hasValue()) {
        this.getAttribute('cy', true).setValue('50%');
      }

      if (!this.getAttribute('r').hasValue()) {
        this.getAttribute('r', true).setValue('50%');
      }

      var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');
      var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');
      var fx = cx;
      var fy = cy;

      if (this.getAttribute('fx').hasValue()) {
        fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');
      }

      if (this.getAttribute('fy').hasValue()) {
        fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');
      }

      var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();
      var fr = this.getAttribute('fr').getPixels();
      return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);
    }

  }

  class StopElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'stop';
      var offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));
      var stopOpacity = this.getStyle('stop-opacity');
      var stopColor = this.getStyle('stop-color', true);

      if (stopColor.getString() === '') {
        stopColor.setValue('#000');
      }

      if (stopOpacity.hasValue()) {
        stopColor = stopColor.addOpacity(stopOpacity);
      }

      this.offset = offset;
      this.color = stopColor.getColor();
    }

  }

  class AnimateElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'animate';
      this.duration = 0;
      this.initialValue = null;
      this.initialUnits = '';
      this.removed = false;
      this.frozen = false;
      document.screen.animations.push(this);
      this.begin = this.getAttribute('begin').getMilliseconds();
      this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();
      this.from = this.getAttribute('from');
      this.to = this.getAttribute('to');
      this.values = new Property(document, 'values', null);
      var valuesAttr = this.getAttribute('values');

      if (valuesAttr.hasValue()) {
        this.values.setValue(valuesAttr.getString().split(';'));
      }
    }

    getProperty() {
      var attributeType = this.getAttribute('attributeType').getString();
      var attributeName = this.getAttribute('attributeName').getString();

      if (attributeType === 'CSS') {
        return this.parent.getStyle(attributeName, true);
      }

      return this.parent.getAttribute(attributeName, true);
    }

    calcValue() {
      var {
        initialUnits
      } = this;
      var {
        progress,
        from,
        to
      } = this.getProgress(); // tween value linearly

      var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;

      if (initialUnits === '%') {
        newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100
      }

      return "".concat(newValue).concat(initialUnits);
    }

    update(delta) {
      var {
        parent
      } = this;
      var prop = this.getProperty(); // set initial value

      if (!this.initialValue) {
        this.initialValue = prop.getString();
        this.initialUnits = prop.getUnits();
      } // if we're past the end time


      if (this.duration > this.maxDuration) {
        var fill = this.getAttribute('fill').getString('remove'); // loop for indefinitely repeating animations

        if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {
          this.duration = 0;
        } else if (fill === 'freeze' && !this.frozen) {
          this.frozen = true;
          parent.animationFrozen = true;
          parent.animationFrozenValue = prop.getString();
        } else if (fill === 'remove' && !this.removed) {
          this.removed = true;
          prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
          return true;
        }

        return false;
      }

      this.duration += delta; // if we're past the begin time

      var updated = false;

      if (this.begin < this.duration) {
        var newValue = this.calcValue(); // tween

        var typeAttr = this.getAttribute('type');

        if (typeAttr.hasValue()) {
          // for transform, etc.
          var type = typeAttr.getString();
          newValue = "".concat(type, "(").concat(newValue, ")");
        }

        prop.setValue(newValue);
        updated = true;
      }

      return updated;
    }

    getProgress() {
      var {
        document,
        values
      } = this;
      var result = {
        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
      };

      if (values.hasValue()) {
        var p = result.progress * (values.getValue().length - 1);
        var lb = Math.floor(p);
        var ub = Math.ceil(p);
        result.from = new Property(document, 'from', parseFloat(values.getValue()[lb]));
        result.to = new Property(document, 'to', parseFloat(values.getValue()[ub]));
        result.progress = (p - lb) / (ub - lb);
      } else {
        result.from = this.from;
        result.to = this.to;
      }

      return result;
    }

  }

  class AnimateColorElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = 'animateColor';
    }

    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var colorFrom = new rgbcolor(from.getColor());
      var colorTo = new rgbcolor(to.getColor());

      if (colorFrom.ok && colorTo.ok) {
        // tween color linearly
        var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
        var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
        var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha

        return "rgb(".concat(Math.floor(r), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
      }

      return this.getAttribute('from').getColor();
    }

  }

  class AnimateTransformElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = 'animateTransform';
    }

    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress(); // tween value linearly

      var transformFrom = toNumbers(from.getString());
      var transformTo = toNumbers(to.getString());
      var newValue = transformFrom.map((from, i) => {
        var to = transformTo[i];
        return from + (to - from) * progress;
      }).join(' ');
      return newValue;
    }

  }

  class FontElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'font';
      this.glyphs = {};
      this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
      var {
        definitions
      } = document;
      var {
        children
      } = this;

      for (var child of children) {
        switch (child.type) {
          case 'font-face':
            {
              this.fontFace = child;
              var fontFamilyStyle = child.getStyle('font-family');

              if (fontFamilyStyle.hasValue()) {
                definitions[fontFamilyStyle.getString()] = this;
              }

              break;
            }

          case 'missing-glyph':
            this.missingGlyph = child;
            break;

          case 'glyph':
            {
              var glyph = child;

              if (glyph.arabicForm) {
                this.isRTL = true;
                this.isArabic = true;

                if (typeof this.glyphs[glyph.unicode] === 'undefined') {
                  this.glyphs[glyph.unicode] = {};
                }

                this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
              } else {
                this.glyphs[glyph.unicode] = glyph;
              }

              break;
            }
        }
      }
    }

    render() {// NO RENDER
    }

  }

  class FontFaceElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'font-face';
      this.ascent = this.getAttribute('ascent').getNumber();
      this.descent = this.getAttribute('descent').getNumber();
      this.unitsPerEm = this.getAttribute('units-per-em').getNumber();
    }

  }

  class MissingGlyphElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'missing-glyph';
      this.horizAdvX = 0;
    }

  }

  class TRefElement extends TextElement {
    constructor() {
      super(...arguments);
      this.type = 'tref';
    }

    getText() {
      var element = this.getHrefAttribute().getDefinition();

      if (element) {
        var firstChild = element.children[0];

        if (firstChild) {
          return firstChild.getText();
        }
      }

      return '';
    }

  }

  class AElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'a';
      var {
        childNodes
      } = node;
      var firstChild = childNodes[0];
      var hasText = childNodes.length > 0 && Array.from(childNodes).every(node => node.nodeType === 3);
      this.hasText = hasText;
      this.text = hasText ? this.getTextFromNode(firstChild) : '';
    }

    getText() {
      return this.text;
    }

    renderChildren(ctx) {
      if (this.hasText) {
        // render as text element
        super.renderChildren(ctx);
        var {
          document,
          x,
          y
        } = this;
        var {
          mouse
        } = document.screen;
        var fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.

        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));
        }
      } else if (this.children.length > 0) {
        // render as temporary group
        var g = new GElement(this.document, null);
        g.children = this.children;
        g.parent = this;
        g.render(ctx);
      }
    }

    onClick() {
      var {
        window
      } = this.document;

      if (window) {
        window.open(this.getHrefAttribute().getString());
      }
    }

    onMouseMove() {
      var ctx = this.document.ctx;
      ctx.canvas.style.cursor = 'pointer';
    }

  }

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  class TextPathElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'textPath';
      this.textWidth = 0;
      this.textHeight = 0;
      this.pathLength = -1;
      this.glyphInfo = null;
      this.letterSpacingCache = [];
      this.measuresCache = new Map([['', 0]]);
      var pathElement = this.getHrefAttribute().getDefinition();
      this.text = this.getTextFromNode();
      this.dataArray = this.parsePathData(pathElement);
    }

    getText() {
      return this.text;
    }

    path(ctx) {
      var {
        dataArray
      } = this;

      if (ctx) {
        ctx.beginPath();
      }

      dataArray.forEach(_ref => {
        var {
          type,
          points
        } = _ref;

        switch (type) {
          case PathParser.LINE_TO:
            if (ctx) {
              ctx.lineTo(points[0], points[1]);
            }

            break;

          case PathParser.MOVE_TO:
            if (ctx) {
              ctx.moveTo(points[0], points[1]);
            }

            break;

          case PathParser.CURVE_TO:
            if (ctx) {
              ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
            }

            break;

          case PathParser.QUAD_TO:
            if (ctx) {
              ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
            }

            break;

          case PathParser.ARC:
            {
              var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;

              if (ctx) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              }

              break;
            }

          case PathParser.CLOSE_PATH:
            if (ctx) {
              ctx.closePath();
            }

            break;
        }
      });
    }

    renderChildren(ctx) {
      this.setTextData(ctx);
      ctx.save();
      var textDecoration = this.parent.getStyle('text-decoration').getString();
      var fontSize = this.getFontSize();
      var {
        glyphInfo
      } = this;
      var fill = ctx.fillStyle;

      if (textDecoration === 'underline') {
        ctx.beginPath();
      }

      glyphInfo.forEach((glyph, i) => {
        var {
          p0,
          p1,
          rotation,
          text: partialText
        } = glyph;
        ctx.save();
        ctx.translate(p0.x, p0.y);
        ctx.rotate(rotation);

        if (ctx.fillStyle) {
          ctx.fillText(partialText, 0, 0);
        }

        if (ctx.strokeStyle) {
          ctx.strokeText(partialText, 0, 0);
        }

        ctx.restore();

        if (textDecoration === 'underline') {
          if (i === 0) {
            ctx.moveTo(p0.x, p0.y + fontSize / 8);
          }

          ctx.lineTo(p1.x, p1.y + fontSize / 5);
        } // // To assist with debugging visually, uncomment following
        //
        // ctx.beginPath();
        // if (i % 2)
        // 	ctx.strokeStyle = 'red';
        // else
        // 	ctx.strokeStyle = 'green';
        // ctx.moveTo(p0.x, p0.y);
        // ctx.lineTo(p1.x, p1.y);
        // ctx.stroke();
        // ctx.closePath();

      });

      if (textDecoration === 'underline') {
        ctx.lineWidth = fontSize / 20;
        ctx.strokeStyle = fill;
        ctx.stroke();
        ctx.closePath();
      }

      ctx.restore();
    }

    getLetterSpacingAt() {
      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.letterSpacingCache[idx] || 0;
    }

    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {
      var offset = inputOffset;
      var glyphWidth = this.measureText(ctx, c);

      if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {
        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
      }

      if (charI > -1) {
        offset += this.getLetterSpacingAt(charI);
      }

      var splineStep = this.textHeight / 20;
      var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
      var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
      var segment = {
        p0,
        p1
      };
      var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;

      if (dy) {
        var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
        var dyY = Math.cos(-rotation) * dy;
        segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
          x: p0.x + dyX,
          y: p0.y + dyY
        });
        segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
          x: p1.x + dyX,
          y: p1.y + dyY
        });
      }

      offset += glyphWidth;
      return {
        offset,
        segment,
        rotation
      };
    }

    measureText(ctx, text) {
      var {
        measuresCache
      } = this;
      var targetText = text || this.getText();

      if (measuresCache.has(targetText)) {
        return measuresCache.get(targetText);
      }

      var measure = this.measureTargetText(ctx, targetText);
      measuresCache.set(targetText, measure);
      return measure;
    } // This method supposes what all custom fonts already loaded.
    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
    // You need to call this method manually to update glyphs cache.


    setTextData(ctx) {
      if (this.glyphInfo) {
        return;
      }

      var renderText = this.getText();
      var chars = renderText.split('');
      var spacesNumber = renderText.split(' ').length - 1;
      var dx = this.parent.getAttribute('dx').split().map(_ => _.getPixels('x'));
      var dy = this.parent.getAttribute('dy').getPixels('y');
      var anchor = this.parent.getStyle('text-anchor').getString('start');
      var thisSpacing = this.getStyle('letter-spacing');
      var parentSpacing = this.parent.getStyle('letter-spacing');
      var letterSpacing = 0;

      if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {
        letterSpacing = parentSpacing.getPixels();
      } else if (thisSpacing.hasValue()) {
        if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {
          letterSpacing = thisSpacing.getPixels();
        }
      } // fill letter-spacing cache


      var letterSpacingCache = [];
      var textLen = renderText.length;
      this.letterSpacingCache = letterSpacingCache;

      for (var i = 0; i < textLen; i++) {
        letterSpacingCache.push(typeof dx[i] !== 'undefined' ? dx[i] : letterSpacing);
      }

      var dxSum = letterSpacingCache.reduce((acc, cur, i) => i === 0 ? 0 : acc + cur || 0, 0);
      var textWidth = this.measureText(ctx);
      var textFullWidth = Math.max(textWidth + dxSum, 0);
      this.textWidth = textWidth;
      this.textHeight = this.getFontSize();
      this.glyphInfo = [];
      var fullPathWidth = this.getPathLength();
      var startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;
      var offset = 0;

      if (anchor === 'middle' || anchor === 'center') {
        offset = -textFullWidth / 2;
      }

      if (anchor === 'end' || anchor === 'right') {
        offset = -textFullWidth;
      }

      offset += startOffset;
      chars.forEach((char, i) => {
        // Find such segment what distance between p0 and p1 is approx. width of glyph
        var {
          offset: nextOffset,
          segment,
          rotation
        } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);
        offset = nextOffset;

        if (!segment.p0 || !segment.p1) {
          return;
        } // const width = this.getLineLength(
        // 	segment.p0.x,
        // 	segment.p0.y,
        // 	segment.p1.x,
        // 	segment.p1.y
        // );
        // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
        // Can foresee having a rough pair table built in that the developer can override as needed.
        // Or use "dx" attribute of the <text> node as a naive replacement
        // const kern = 0;
        // placeholder for future implementation
        // const midpoint = this.getPointOnLine(
        // 	kern + width / 2.0,
        // 	segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y
        // );


        this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: chars[i],
          p0: segment.p0,
          p1: segment.p1,
          rotation
        });
      });
    }

    parsePathData(path) {
      this.pathLength = -1; // reset path length

      if (!path) {
        return [];
      }

      var pathCommands = [];
      var {
        pathParser
      } = path;
      pathParser.reset(); // convert l, H, h, V, and v to L

      while (!pathParser.isEnd()) {
        var {
          current
        } = pathParser;
        var startX = current ? current.x : 0;
        var startY = current ? current.y : 0;
        var command = pathParser.next();
        var nextCommandType = command.type;
        var points = [];

        switch (command.type) {
          case PathParser.MOVE_TO:
            this.pathM(pathParser, points);
            break;

          case PathParser.LINE_TO:
            nextCommandType = this.pathL(pathParser, points);
            break;

          case PathParser.HORIZ_LINE_TO:
            nextCommandType = this.pathH(pathParser, points);
            break;

          case PathParser.VERT_LINE_TO:
            nextCommandType = this.pathV(pathParser, points);
            break;

          case PathParser.CURVE_TO:
            this.pathC(pathParser, points);
            break;

          case PathParser.SMOOTH_CURVE_TO:
            nextCommandType = this.pathS(pathParser, points);
            break;

          case PathParser.QUAD_TO:
            this.pathQ(pathParser, points);
            break;

          case PathParser.SMOOTH_QUAD_TO:
            nextCommandType = this.pathT(pathParser, points);
            break;

          case PathParser.ARC:
            points = this.pathA(pathParser);
            break;

          case PathParser.CLOSE_PATH:
            PathElement.pathZ(pathParser);
            break;
        }

        if (command.type !== PathParser.CLOSE_PATH) {
          pathCommands.push({
            type: nextCommandType,
            points,
            start: {
              x: startX,
              y: startY
            },
            pathLength: this.calcLength(startX, startY, nextCommandType, points)
          });
        } else {
          pathCommands.push({
            type: PathParser.CLOSE_PATH,
            points: [],
            pathLength: 0
          });
        }
      }

      return pathCommands;
    }

    pathM(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathM(pathParser).point;
      points.push(x, y);
    }

    pathL(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathL(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathH(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathH(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathV(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathV(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathC(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }

    pathS(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.CURVE_TO;
    }

    pathQ(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }

    pathT(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.QUAD_TO;
    }

    pathA(pathParser) {
      var {
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);

      if (sweepFlag === 0 && ad > 0) {
        ad -= 2 * Math.PI;
      }

      if (sweepFlag === 1 && ad < 0) {
        ad += 2 * Math.PI;
      }

      return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
    }

    calcLength(x, y, commandType, points) {
      var len = 0;
      var p1 = null;
      var p2 = null;
      var t = 0;

      switch (commandType) {
        case PathParser.LINE_TO:
          return this.getLineLength(x, y, points[0], points[1]);

        case PathParser.CURVE_TO:
          // Approximates by breaking curve into 100 line segments
          len = 0.0;
          p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);

          for (t = 0.01; t <= 1; t += 0.01) {
            p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }

          return len;

        case PathParser.QUAD_TO:
          // Approximates by breaking curve into 100 line segments
          len = 0.0;
          p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);

          for (t = 0.01; t <= 1; t += 0.01) {
            p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }

          return len;

        case PathParser.ARC:
          {
            // Approximates by breaking curve into line segments
            len = 0.0;
            var start = points[4]; // 4 = theta

            var dTheta = points[5]; // 5 = dTheta

            var end = points[4] + dTheta;
            var inc = Math.PI / 180.0; // 1 degree resolution

            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi


            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);

            if (dTheta < 0) {
              // clockwise
              for (t = start - inc; t > end; t -= inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            } else {
              // counter-clockwise
              for (t = start + inc; t < end; t += inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            }

            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
          }
      }

      return 0;
    }

    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
      var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;
      var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;
      var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
      var run = Math.sqrt(dist * dist / (1 + m * m));

      if (p2x < p1x) {
        run *= -1;
      }

      var rise = m * run;
      var pt = null;

      if (p2x === p1x) {
        // vertical line
        pt = {
          x: fromX,
          y: fromY + rise
        };
      } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {
        pt = {
          x: fromX + run,
          y: fromY + rise
        };
      } else {
        var ix = 0;
        var iy = 0;
        var len = this.getLineLength(p1x, p1y, p2x, p2y);

        if (len < PSEUDO_ZERO) {
          return null;
        }

        var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
        u /= len * len;
        ix = p1x + u * (p2x - p1x);
        iy = p1y + u * (p2y - p1y);
        var pRise = this.getLineLength(fromX, fromY, ix, iy);
        var pRun = Math.sqrt(dist * dist - pRise * pRise);
        run = Math.sqrt(pRun * pRun / (1 + m * m));

        if (p2x < p1x) {
          run *= -1;
        }

        rise = m * run;
        pt = {
          x: ix + run,
          y: iy + rise
        };
      }

      return pt;
    }

    getPointOnPath(distance) {
      var fullLen = this.getPathLength();
      var cumulativePathLength = 0;
      var p = null;

      if (distance < -0.00005 || distance - 0.00005 > fullLen) {
        return null;
      }

      var {
        dataArray
      } = this;

      for (var command of dataArray) {
        if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {
          cumulativePathLength += command.pathLength;
          continue;
        }

        var delta = distance - cumulativePathLength;
        var currentT = 0;

        switch (command.type) {
          case PathParser.LINE_TO:
            p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
            break;

          case PathParser.ARC:
            {
              var start = command.points[4]; // 4 = theta

              var dTheta = command.points[5]; // 5 = dTheta

              var end = command.points[4] + dTheta;
              currentT = start + delta / command.pathLength * dTheta;

              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                break;
              }

              p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
              break;
            }

          case PathParser.CURVE_TO:
            currentT = delta / command.pathLength;

            if (currentT > 1) {
              currentT = 1;
            }

            p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
            break;

          case PathParser.QUAD_TO:
            currentT = delta / command.pathLength;

            if (currentT > 1) {
              currentT = 1;
            }

            p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
            break;
        }

        if (p) {
          return p;
        }

        break;
      }

      return null;
    }

    getLineLength(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    getPathLength() {
      if (this.pathLength === -1) {
        this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
      }

      return this.pathLength;
    }

    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
      var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
      return {
        x,
        y
      };
    }

    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
      var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
      var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
      return {
        x,
        y
      };
    }

    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
      var cosPsi = Math.cos(psi);
      var sinPsi = Math.sin(psi);
      var pt = {
        x: rx * Math.cos(theta),
        y: ry * Math.sin(theta)
      };
      return {
        x: cx + (pt.x * cosPsi - pt.y * sinPsi),
        y: cy + (pt.x * sinPsi + pt.y * cosPsi)
      };
    } // TODO need some optimisations. possibly build cache only for curved segments?


    buildEquidistantCache(inputStep, inputPrecision) {
      var fullLen = this.getPathLength();
      var precision = inputPrecision || 0.25; // accuracy vs performance

      var step = inputStep || fullLen / 100;

      if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
        // Prepare cache
        this.equidistantCache = {
          step,
          precision,
          points: []
        }; // Calculate points

        var s = 0;

        for (var l = 0; l <= fullLen; l += precision) {
          var p0 = this.getPointOnPath(l);
          var p1 = this.getPointOnPath(l + precision);

          if (!p0 || !p1) {
            continue;
          }

          s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);

          if (s >= step) {
            this.equidistantCache.points.push({
              x: p0.x,
              y: p0.y,
              distance: l
            });
            s -= step;
          }
        }
      }
    }

    getEquidistantPointOnPath(targetDistance, step, precision) {
      this.buildEquidistantCache(step, precision);

      if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {
        return null;
      }

      var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
      return this.equidistantCache.points[idx] || null;
    }

  }

  var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
  class ImageElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'image';
      this.loaded = false;
      var href = this.getHrefAttribute().getString();

      if (!href) {
        return;
      }

      var isSvg = href.endsWith('.svg') || /^\s*data:image\/svg\+xml/i.test(href);
      document.images.push(this);

      if (!isSvg) {
        void this.loadImage(href);
      } else {
        void this.loadSvg(href);
      }

      this.isSvg = isSvg;
    }

    loadImage(href) {
      var _this = this;

      return _asyncToGenerator(function* () {
        try {
          var image = yield _this.document.createImage(href);
          _this.image = image;
        } catch (err) {
          console.error("Error while loading image \"".concat(href, "\":"), err);
        }

        _this.loaded = true;
      })();
    }

    loadSvg(href) {
      var _this2 = this;

      return _asyncToGenerator(function* () {
        var match = dataUriRegex.exec(href);

        if (match) {
          var data = match[5];

          if (match[4] === 'base64') {
            _this2.image = atob(data);
          } else {
            _this2.image = decodeURIComponent(data);
          }
        } else {
          try {
            var response = yield _this2.document.fetch(href);
            var svg = yield response.text();
            _this2.image = svg;
          } catch (err) {
            console.error("Error while loading image \"".concat(href, "\":"), err);
          }
        }

        _this2.loaded = true;
      })();
    }

    renderChildren(ctx) {
      var {
        document,
        image,
        loaded
      } = this;
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');

      if (!loaded || !image || !width || !height) {
        return;
      }

      ctx.save();
      ctx.translate(x, y);

      if (this.isSvg) {
        var subDocument = document.canvg.forkString(ctx, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: width,
          scaleHeight: height
        });
        subDocument.document.documentElement.parent = this;
        void subDocument.render();
      } else {
        var _image = this.image;
        document.setViewBox({
          ctx,
          aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
          width,
          desiredWidth: _image.width,
          height,
          desiredHeight: _image.height
        });

        if (this.loaded) {
          if (typeof _image.complete === 'undefined' || _image.complete) {
            ctx.drawImage(_image, 0, 0);
          }
        }
      }

      ctx.restore();
    }

    getBoundingBox() {
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');
      return new BoundingBox(x, y, x + width, y + height);
    }

  }

  class SymbolElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'symbol';
    }

    render(_) {// NO RENDER
    }

  }

  class SVGFontLoader {
    constructor(document) {
      this.document = document;
      this.loaded = false;
      document.fonts.push(this);
    }

    load(fontFamily, url) {
      var _this = this;

      return _asyncToGenerator(function* () {
        try {
          var {
            document
          } = _this;
          var svgDocument = yield document.canvg.parser.load(url);
          var fonts = svgDocument.getElementsByTagName('font');
          Array.from(fonts).forEach(fontNode => {
            var font = document.createElement(fontNode);
            document.definitions[fontFamily] = font;
          });
        } catch (err) {
          console.error("Error while loading font \"".concat(url, "\":"), err);
        }

        _this.loaded = true;
      })();
    }

  }

  class StyleElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'style';
      var css = compressSpaces(Array.from(node.childNodes) // NEED TEST
      .map(_ => _.textContent).join('').replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '') // remove comments
      .replace(/@import.*;/g, '') // remove imports
      );
      var cssDefs = css.split('}');
      cssDefs.forEach(_ => {
        var def = _.trim();

        if (!def) {
          return;
        }

        var cssParts = def.split('{');
        var cssClasses = cssParts[0].split(',');
        var cssProps = cssParts[1].split(';');
        cssClasses.forEach(_ => {
          var cssClass = _.trim();

          if (!cssClass) {
            return;
          }

          var props = document.styles[cssClass] || {};
          cssProps.forEach(cssProp => {
            var prop = cssProp.indexOf(':');
            var name = cssProp.substr(0, prop).trim();
            var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();

            if (name && value) {
              props[name] = new Property(document, name, value);
            }
          });
          document.styles[cssClass] = props;
          document.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);

          if (cssClass === '@font-face') {
            //  && !nodeEnv
            var fontFamily = props['font-family'].getString().replace(/"|'/g, '');
            var srcs = props.src.getString().split(',');
            srcs.forEach(src => {
              if (src.indexOf('format("svg")') > 0) {
                var url = parseExternalUrl(src);

                if (url) {
                  void new SVGFontLoader(document).load(fontFamily, url);
                }
              }
            });
          }
        });
      });
    }

  }
  StyleElement.parseExternalUrl = parseExternalUrl;

  class UseElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'use';
    }

    setContext(ctx) {
      super.setContext(ctx);
      var xAttr = this.getAttribute('x');
      var yAttr = this.getAttribute('y');

      if (xAttr.hasValue()) {
        ctx.translate(xAttr.getPixels('x'), 0);
      }

      if (yAttr.hasValue()) {
        ctx.translate(0, yAttr.getPixels('y'));
      }
    }

    path(ctx) {
      var {
        element
      } = this;

      if (element) {
        element.path(ctx);
      }
    }

    renderChildren(ctx) {
      var {
        document,
        element
      } = this;

      if (element) {
        var tempSvg = element;

        if (element.type === 'symbol') {
          // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
          tempSvg = new SVGElement(document, null);
          tempSvg.attributes.viewBox = new Property(document, 'viewBox', element.getAttribute('viewBox').getString());
          tempSvg.attributes.preserveAspectRatio = new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString());
          tempSvg.attributes.overflow = new Property(document, 'overflow', element.getAttribute('overflow').getString());
          tempSvg.children = element.children; // element is still the parent of the children

          element.styles.opacity = new Property(document, 'opacity', this.calculateOpacity());
        }

        if (tempSvg.type === 'svg') {
          var widthStyle = this.getStyle('width', false, true);
          var heightStyle = this.getStyle('height', false, true); // if symbol or svg, inherit width/height from me

          if (widthStyle.hasValue()) {
            tempSvg.attributes.width = new Property(document, 'width', widthStyle.getString());
          }

          if (heightStyle.hasValue()) {
            tempSvg.attributes.height = new Property(document, 'height', heightStyle.getString());
          }
        }

        var oldParent = tempSvg.parent;
        tempSvg.parent = this;
        tempSvg.render(ctx);
        tempSvg.parent = oldParent;
      }
    }

    getBoundingBox(ctx) {
      var {
        element
      } = this;

      if (element) {
        return element.getBoundingBox(ctx);
      }

      return null;
    }

    elementTransform() {
      var {
        document,
        element
      } = this;
      return Transform.fromElement(document, element);
    }

    get element() {
      if (!this.cachedElement) {
        this.cachedElement = this.getHrefAttribute().getDefinition();
      }

      return this.cachedElement;
    }

  }

  function imGet(img, x, y, width, _height, rgba) {
    return img[y * width * 4 + x * 4 + rgba];
  }

  function imSet(img, x, y, width, _height, rgba, val) {
    img[y * width * 4 + x * 4 + rgba] = val;
  }

  function m(matrix, i, v) {
    var mi = matrix[i];
    return mi * v;
  }

  function c(a, m1, m2, m3) {
    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;
  }

  class FeColorMatrixElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feColorMatrix';
      var matrix = toNumbers(this.getAttribute('values').getString());

      switch (this.getAttribute('type').getString('matrix')) {
        // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
        case 'saturate':
          {
            var s = matrix[0];
            /* eslint-disable array-element-newline */

            matrix = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            /* eslint-enable array-element-newline */

            break;
          }

        case 'hueRotate':
          {
            var a = matrix[0] * Math.PI / 180.0;
            /* eslint-disable array-element-newline */

            matrix = [c(a, 0.213, 0.787, -0.213), c(a, 0.715, -0.715, -0.715), c(a, 0.072, -0.072, 0.928), 0, 0, c(a, 0.213, -0.213, 0.143), c(a, 0.715, 0.285, 0.140), c(a, 0.072, -0.072, -0.283), 0, 0, c(a, 0.213, -0.213, -0.787), c(a, 0.715, -0.715, 0.715), c(a, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            /* eslint-enable array-element-newline */

            break;
          }

        case 'luminanceToAlpha':
          /* eslint-disable array-element-newline */
          matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
          /* eslint-enable array-element-newline */

          break;
      }

      this.matrix = matrix;
      this.includeOpacity = this.getAttribute('includeOpacity').hasValue();
    }

    apply(ctx, _x, _y, width, height) {
      // assuming x==0 && y==0 for now
      var {
        includeOpacity,
        matrix
      } = this;
      var srcData = ctx.getImageData(0, 0, width, height);

      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var r = imGet(srcData.data, x, y, width, height, 0);
          var g = imGet(srcData.data, x, y, width, height, 1);
          var b = imGet(srcData.data, x, y, width, height, 2);
          var a = imGet(srcData.data, x, y, width, height, 3);
          var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);
          var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);
          var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);
          var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);

          if (includeOpacity) {
            nr = 0;
            ng = 0;
            nb = 0;
            na *= a / 255;
          }

          imSet(srcData.data, x, y, width, height, 0, nr);
          imSet(srcData.data, x, y, width, height, 1, ng);
          imSet(srcData.data, x, y, width, height, 2, nb);
          imSet(srcData.data, x, y, width, height, 3, na);
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.putImageData(srcData, 0, 0);
    }

  }

  class MaskElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'mask';
    }

    apply(ctx, element) {
      var {
        document
      } = this; // render as temp svg

      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');

      if (!width && !height) {
        var boundingBox = new BoundingBox();
        this.children.forEach(child => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        x = Math.floor(boundingBox.x1);
        y = Math.floor(boundingBox.y1);
        width = Math.floor(boundingBox.width);
        height = Math.floor(boundingBox.height);
      }

      var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
      var maskCanvas = document.createCanvas(x + width, y + height);
      var maskCtx = maskCanvas.getContext('2d');
      document.screen.setDefaults(maskCtx);
      this.renderChildren(maskCtx); // convert mask to alpha with a fake node
      // TODO: refactor out apply from feColorMatrix

      new FeColorMatrixElement(document, {
        nodeType: 1,
        childNodes: [],
        attributes: [{
          nodeName: 'type',
          value: 'luminanceToAlpha'
        }, {
          nodeName: 'includeOpacity',
          value: 'true'
        }]
      }).apply(maskCtx, 0, 0, x + width, y + height);
      var tmpCanvas = document.createCanvas(x + width, y + height);
      var tmpCtx = tmpCanvas.getContext('2d');
      document.screen.setDefaults(tmpCtx);
      element.render(tmpCtx);
      tmpCtx.globalCompositeOperation = 'destination-in';
      tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');
      tmpCtx.fillRect(0, 0, x + width, y + height);
      ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');
      ctx.fillRect(0, 0, x + width, y + height); // reassign mask

      this.restoreStyles(element, ignoredStyles);
    }

    render(_) {// NO RENDER
    }

  }
  MaskElement.ignoreStyles = ['mask', 'transform', 'clip-path'];

  var noop = () => {// NOOP
  };

  class ClipPathElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'clipPath';
    }

    apply(ctx) {
      var {
        document
      } = this;
      var contextProto = Reflect.getPrototypeOf(ctx);
      var {
        beginPath,
        closePath
      } = ctx;

      if (contextProto) {
        contextProto.beginPath = noop;
        contextProto.closePath = noop;
      }

      Reflect.apply(beginPath, ctx, []);
      this.children.forEach(child => {
        if (typeof child.path === 'undefined') {
          return;
        }

        var transform = typeof child.elementTransform !== 'undefined' ? child.elementTransform() : null; // handle <use />

        if (!transform) {
          transform = Transform.fromElement(document, child);
        }

        if (transform) {
          transform.apply(ctx);
        }

        child.path(ctx);

        if (contextProto) {
          contextProto.closePath = closePath;
        }

        if (transform) {
          transform.unapply(ctx);
        }
      });
      Reflect.apply(closePath, ctx, []);
      ctx.clip();

      if (contextProto) {
        contextProto.beginPath = beginPath;
        contextProto.closePath = closePath;
      }
    }

    render(_) {// NO RENDER
    }

  }

  class FilterElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'filter';
    }

    apply(ctx, element) {
      // render as temp svg
      var {
        document,
        children
      } = this;
      var boundingBox = element.getBoundingBox(ctx);

      if (!boundingBox) {
        return;
      }

      var px = 0;
      var py = 0;
      children.forEach(child => {
        var efd = child.extraFilterDistance || 0;
        px = Math.max(px, efd);
        py = Math.max(py, efd);
      });
      var width = Math.floor(boundingBox.width);
      var height = Math.floor(boundingBox.height);
      var tmpCanvasWidth = width + 2 * px;
      var tmpCanvasHeight = height + 2 * py;

      if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
        return;
      }

      var x = Math.floor(boundingBox.x);
      var y = Math.floor(boundingBox.y);
      var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
      var tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
      var tmpCtx = tmpCanvas.getContext('2d');
      document.screen.setDefaults(tmpCtx);
      tmpCtx.translate(-x + px, -y + py);
      element.render(tmpCtx); // apply filters

      children.forEach(child => {
        if (typeof child.apply === 'function') {
          child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
        }
      }); // render on me

      ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);
      this.restoreStyles(element, ignoredStyles);
    }

    render(_) {// NO RENDER
    }

  }
  FilterElement.ignoreStyles = ['filter', 'transform', 'clip-path'];

  class FeDropShadowElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feDropShadow';
      this.addStylesFromStyleDefinition();
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeMorphologyElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'feMorphology';
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeCompositeElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'feComposite';
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeGaussianBlurElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feGaussianBlur';
      this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());
      this.extraFilterDistance = this.blurRadius;
    }

    apply(ctx, x, y, width, height) {
      var {
        document,
        blurRadius
      } = this;
      var body = document.window ? document.window.document.body : null;
      var canvas = ctx.canvas; // StackBlur requires canvas be on document

      canvas.id = document.getUniqueId();

      if (body) {
        canvas.style.display = 'none';
        body.appendChild(canvas);
      }

      processCanvasRGBA(canvas, x, y, width, height, blurRadius);

      if (body) {
        body.removeChild(canvas);
      }
    }

  }

  class TitleElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'title';
    }

  }

  class DescElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'desc';
    }

  }

  var elements = {
    'svg': SVGElement,
    'rect': RectElement,
    'circle': CircleElement,
    'ellipse': EllipseElement,
    'line': LineElement,
    'polyline': PolylineElement,
    'polygon': PolygonElement,
    'path': PathElement,
    'pattern': PatternElement,
    'marker': MarkerElement,
    'defs': DefsElement,
    'linearGradient': LinearGradientElement,
    'radialGradient': RadialGradientElement,
    'stop': StopElement,
    'animate': AnimateElement,
    'animateColor': AnimateColorElement,
    'animateTransform': AnimateTransformElement,
    'font': FontElement,
    'font-face': FontFaceElement,
    'missing-glyph': MissingGlyphElement,
    'glyph': GlyphElement,
    'text': TextElement,
    'tspan': TSpanElement,
    'tref': TRefElement,
    'a': AElement,
    'textPath': TextPathElement,
    'image': ImageElement,
    'g': GElement,
    'symbol': SymbolElement,
    'style': StyleElement,
    'use': UseElement,
    'mask': MaskElement,
    'clipPath': ClipPathElement,
    'filter': FilterElement,
    'feDropShadow': FeDropShadowElement,
    'feMorphology': FeMorphologyElement,
    'feComposite': FeCompositeElement,
    'feColorMatrix': FeColorMatrixElement,
    'feGaussianBlur': FeGaussianBlurElement,
    'title': TitleElement,
    'desc': DescElement
  };

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function createCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

  function createImage(_x) {
    return _createImage.apply(this, arguments);
  }

  function _createImage() {
    _createImage = _asyncToGenerator(function* (src) {
      var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var image = document.createElement('img');

      if (anonymousCrossOrigin) {
        image.crossOrigin = 'Anonymous';
      }

      return new Promise((resolve, reject) => {
        image.onload = () => {
          resolve(image);
        };

        image.onerror = (_event, _source, _lineno, _colno, error) => {
          reject(error);
        };

        image.src = src;
      });
    });
    return _createImage.apply(this, arguments);
  }

  class Document {
    constructor(canvg) {
      var {
        rootEmSize = 12,
        emSize = 12,
        createCanvas = Document.createCanvas,
        createImage = Document.createImage,
        anonymousCrossOrigin
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.canvg = canvg;
      this.definitions = {};
      this.styles = {};
      this.stylesSpecificity = {};
      this.images = [];
      this.fonts = [];
      this.emSizeStack = [];
      this.uniqueId = 0;
      this.screen = canvg.screen;
      this.rootEmSize = rootEmSize;
      this.emSize = emSize;
      this.createCanvas = createCanvas;
      this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);
      this.screen.wait(this.isImagesLoaded.bind(this));
      this.screen.wait(this.isFontsLoaded.bind(this));
    }

    bindCreateImage(createImage, anonymousCrossOrigin) {
      if (typeof anonymousCrossOrigin === 'boolean') {
        return (source, forceAnonymousCrossOrigin) => createImage(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
      }

      return createImage;
    }

    get window() {
      return this.screen.window;
    }

    get fetch() {
      return this.screen.fetch;
    }

    get ctx() {
      return this.screen.ctx;
    }

    get emSize() {
      var {
        emSizeStack
      } = this;
      return emSizeStack[emSizeStack.length - 1];
    }

    set emSize(value) {
      var {
        emSizeStack
      } = this;
      emSizeStack.push(value);
    }

    popEmSize() {
      var {
        emSizeStack
      } = this;
      emSizeStack.pop();
    }

    getUniqueId() {
      return "canvg".concat(++this.uniqueId);
    }

    isImagesLoaded() {
      return this.images.every(_ => _.loaded);
    }

    isFontsLoaded() {
      return this.fonts.every(_ => _.loaded);
    }

    createDocumentElement(document) {
      var documentElement = this.createElement(document.documentElement);
      documentElement.root = true;
      documentElement.addStylesFromStyleDefinition();
      this.documentElement = documentElement;
      return documentElement;
    }

    createElement(node) {
      var elementType = node.nodeName.replace(/^[^:]+:/, '');
      var ElementType = Document.elementTypes[elementType];

      if (typeof ElementType !== 'undefined') {
        return new ElementType(this, node);
      }

      return new UnknownElement(this, node);
    }

    createTextNode(node) {
      return new TextNode(this, node);
    }

    setViewBox(config) {
      this.screen.setViewBox(_objectSpread$1({
        document: this
      }, config));
    }

  }
  Document.createCanvas = createCanvas;
  Document.createImage = createImage;
  Document.elementTypes = elements;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * SVG renderer on canvas.
   */

  class Canvg {
    /**
     * Main constructor.
     * @param ctx - Rendering context.
     * @param svg - SVG Document.
     * @param options - Rendering options.
     */
    constructor(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.parser = new Parser(options);
      this.screen = new Screen(ctx, options);
      this.options = options;
      var document = new Document(this, options);
      var documentElement = document.createDocumentElement(svg);
      this.document = document;
      this.documentElement = documentElement;
    }
    /**
     * Create Canvg instance from SVG source string or URL.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    static from(ctx, svg) {
      var _arguments = arguments;
      return _asyncToGenerator(function* () {
        var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
        var parser = new Parser(options);
        var svgDocument = yield parser.parse(svg);
        return new Canvg(ctx, svgDocument, options);
      })();
    }
    /**
     * Create Canvg instance from SVG source string.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    static fromString(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = parser.parseFromString(svg);
      return new Canvg(ctx, svgDocument, options);
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    fork(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    forkString(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Document is ready promise.
     * @returns Ready promise.
     */


    ready() {
      return this.screen.ready();
    }
    /**
     * Document is ready value.
     * @returns Is ready or not.
     */


    isReady() {
      return this.screen.isReady();
    }
    /**
     * Render only first frame, ignoring animations and mouse.
     * @param options - Rendering options.
     */


    render() {
      var _arguments2 = arguments,
          _this = this;

      return _asyncToGenerator(function* () {
        var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};

        _this.start(_objectSpread({
          enableRedraw: true,
          ignoreAnimation: true,
          ignoreMouse: true
        }, options));

        yield _this.ready();

        _this.stop();
      })();
    }
    /**
     * Start rendering.
     * @param options - Render options.
     */


    start() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var {
        documentElement,
        screen,
        options: baseOptions
      } = this;
      screen.start(documentElement, _objectSpread(_objectSpread({
        enableRedraw: true
      }, baseOptions), options));
    }
    /**
     * Stop rendering.
     */


    stop() {
      this.screen.stop();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */


    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.documentElement.resize(width, height, preserveAspectRatio);
    }

  }

  var index_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AElement: AElement,
    AnimateColorElement: AnimateColorElement,
    AnimateElement: AnimateElement,
    AnimateTransformElement: AnimateTransformElement,
    BoundingBox: BoundingBox,
    CB1: CB1,
    CB2: CB2,
    CB3: CB3,
    CB4: CB4,
    Canvg: Canvg,
    CircleElement: CircleElement,
    ClipPathElement: ClipPathElement,
    DefsElement: DefsElement,
    DescElement: DescElement,
    Document: Document,
    Element: Element$1,
    EllipseElement: EllipseElement,
    FeColorMatrixElement: FeColorMatrixElement,
    FeCompositeElement: FeCompositeElement,
    FeDropShadowElement: FeDropShadowElement,
    FeGaussianBlurElement: FeGaussianBlurElement,
    FeMorphologyElement: FeMorphologyElement,
    FilterElement: FilterElement,
    Font: Font,
    FontElement: FontElement,
    FontFaceElement: FontFaceElement,
    GElement: GElement,
    GlyphElement: GlyphElement,
    GradientElement: GradientElement,
    ImageElement: ImageElement,
    LineElement: LineElement,
    LinearGradientElement: LinearGradientElement,
    MarkerElement: MarkerElement,
    MaskElement: MaskElement,
    Matrix: Matrix,
    MissingGlyphElement: MissingGlyphElement,
    Mouse: Mouse,
    PSEUDO_ZERO: PSEUDO_ZERO,
    Parser: Parser,
    PathElement: PathElement,
    PathParser: PathParser,
    PatternElement: PatternElement,
    Point: Point,
    PolygonElement: PolygonElement,
    PolylineElement: PolylineElement,
    Property: Property,
    QB1: QB1,
    QB2: QB2,
    QB3: QB3,
    RadialGradientElement: RadialGradientElement,
    RectElement: RectElement,
    RenderedElement: RenderedElement,
    Rotate: Rotate,
    SVGElement: SVGElement,
    SVGFontLoader: SVGFontLoader,
    Scale: Scale,
    Screen: Screen,
    Skew: Skew,
    SkewX: SkewX,
    SkewY: SkewY,
    StopElement: StopElement,
    StyleElement: StyleElement,
    SymbolElement: SymbolElement,
    TRefElement: TRefElement,
    TSpanElement: TSpanElement,
    TextElement: TextElement,
    TextPathElement: TextPathElement,
    TitleElement: TitleElement,
    Transform: Transform,
    Translate: Translate,
    UnknownElement: UnknownElement,
    UseElement: UseElement,
    ViewPort: ViewPort,
    compressSpaces: compressSpaces,
    'default': Canvg,
    getSelectorSpecificity: getSelectorSpecificity,
    normalizeAttributeName: normalizeAttributeName,
    normalizeColor: normalizeColor,
    parseExternalUrl: parseExternalUrl,
    presets: index,
    toNumbers: toNumbers,
    trimLeft: trimLeft,
    trimRight: trimRight,
    vectorMagnitude: vectorMagnitude,
    vectorsAngle: vectorsAngle,
    vectorsRatio: vectorsRatio
  });

  exports.Map = Map$1;
  exports.component = index$2;
  exports.config = index$7;
  exports.feature = index$4;
  exports.geojson = GeoJson;
  exports.layer = index$5;
  exports.model = index$1;
  exports.name = name;
  exports.overlay = index$3;
  exports.proj = ProjUtil;
  exports.style = Style;
  exports.util = index$6;
  exports.version = version$1;
  exports.wkt = WKT;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=mti-gis-cesium-src.js.map
