/**
* @preserve
* mti-gis-ol-v1.0.0-beta.7, 一个基于Openlayers的GIS封装库
* dev+g0e095ee(2022-10-14 17:19:14 +0800)
* (c) 2010-2022 新智道枢
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ol/proj'), require('ol/proj/proj4'), require('@turf/turf'), require('ol/layer/Tile'), require('ol/source/XYZ'), require('ol/tilegrid/TileGrid'), require('ol/source/TileImage'), require('ol/source/ImageStatic'), require('ol/layer/Image'), require('ol/source/WMTS'), require('ol/tilegrid/WMTS'), require('ol/source/ImageWMS'), require('ol/source/TileWMS'), require('ol/source/TileArcGISRest'), require('ol/style/Style'), require('ol/style/Icon'), require('ol/style/Text'), require('ol/style/Fill'), require('ol/style/Stroke'), require('ol/style/Circle'), require('ol/geom/Circle'), require('ol/render'), require('ol/geom/LineString'), require('ol/geom/Point'), require('ol/Feature'), require('ol/geom/MultiPoint'), require('ol/geom/MultiLineString'), require('ol/geom/Polygon'), require('ol/geom/MultiPolygon'), require('ol/format/GeoJSON'), require('ol/source/ImageCanvas'), require('ol/extent'), require('ol/source/Vector'), require('ol/layer/Vector'), require('ol/easing'), require('ol/render/canvas/Immediate'), require('ol/transform'), require('ol/Overlay'), require('ol/interaction/DragPan'), require('ol/interaction/DoubleClickZoom'), require('ol/interaction/Interaction'), require('ol/interaction/Draw'), require('ol/Observable'), require('ol/control/Rotate'), require('ol/control/ScaleLine'), require('ol/proj/Units'), require('ol/control/Zoom'), require('ol/Map'), require('echarts'), require('ol/interaction/Snap'), require('ol/interaction/Modify'), require('ol/View'), require('ol/events/condition'), require('ol/interaction/MouseWheelZoom'), require('ol/interaction')) :
  typeof define === 'function' && define.amd ? define(['exports', 'ol/proj', 'ol/proj/proj4', '@turf/turf', 'ol/layer/Tile', 'ol/source/XYZ', 'ol/tilegrid/TileGrid', 'ol/source/TileImage', 'ol/source/ImageStatic', 'ol/layer/Image', 'ol/source/WMTS', 'ol/tilegrid/WMTS', 'ol/source/ImageWMS', 'ol/source/TileWMS', 'ol/source/TileArcGISRest', 'ol/style/Style', 'ol/style/Icon', 'ol/style/Text', 'ol/style/Fill', 'ol/style/Stroke', 'ol/style/Circle', 'ol/geom/Circle', 'ol/render', 'ol/geom/LineString', 'ol/geom/Point', 'ol/Feature', 'ol/geom/MultiPoint', 'ol/geom/MultiLineString', 'ol/geom/Polygon', 'ol/geom/MultiPolygon', 'ol/format/GeoJSON', 'ol/source/ImageCanvas', 'ol/extent', 'ol/source/Vector', 'ol/layer/Vector', 'ol/easing', 'ol/render/canvas/Immediate', 'ol/transform', 'ol/Overlay', 'ol/interaction/DragPan', 'ol/interaction/DoubleClickZoom', 'ol/interaction/Interaction', 'ol/interaction/Draw', 'ol/Observable', 'ol/control/Rotate', 'ol/control/ScaleLine', 'ol/proj/Units', 'ol/control/Zoom', 'ol/Map', 'echarts', 'ol/interaction/Snap', 'ol/interaction/Modify', 'ol/View', 'ol/events/condition', 'ol/interaction/MouseWheelZoom', 'ol/interaction'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mtiMap = {}, global.ol.proj, global.ol.proj.proj4, global.turf, global.ol.layer.Tile, global.ol.source.XYZ, global.ol.tilegrid.TileGrid, global.ol.source.TileImage, global.ol.source.ImageStatic, global.ol.layer.Image, global.ol.source.WMTS, global.ol.tilegrid.WMTS, global.ol.source.ImageWMS, global.ol.source.TileWMS, global.ol.source.TileArcGISRest, global.ol.style.Style, global.ol.style.Icon, global.ol.style.Text, global.ol.style.Fill, global.ol.style.Stroke, global.ol.style.Circle, global.ol.geom.Circle, global.ol.render, global.ol.geom.LineString, global.ol.geom.Point, global.ol.Feature, global.ol.geom.MultiPoint, global.ol.geom.MultiLineString, global.ol.geom.Polygon, global.ol.geom.MultiPolygon, global.ol.format.GeoJSON, global.ol.source.ImageCanvas, global.ol.extent, global.ol.source.Vector, global.ol.layer.Vector, global.ol.easing, global.ol.render.canvas.Immediate, global.ol.transform, global.ol.Overlay, global.ol.interaction.DragPan, global.ol.interaction.DoubleClickZoom, global.ol.interaction.Interaction, global.ol.interaction.Draw, global.ol.Observable, global.ol.control.Rotate, global.ol.control.ScaleLine, global.ol.proj.Units, global.ol.control.Zoom, global.ol.Map, global.echarts, global.ol.interaction.Snap, global.ol.interaction.Modify, global.ol.View, global.ol.events.condition, global.ol.interaction.MouseWheelZoom, global.ol.interaction));
})(this, (function (exports, proj, proj4$1, Turf, Tile, XYZ, TileGrid, TileImage, StaticImageSource, ImageLayer, WMTS, WMTSTileGrid, ImageWMS, TileWMS, TileArcGISRest, OlStyle, OlIcon, Text, Fill, Stroke, CircleStyle, OLCircleGeom, render, LineString, Point$3, OlFeature, OlMultiPoint, OlMultiLineString, Polygon$2, OlMultiPolygon, Geojson, ImageCanvas, extent, VectorSource, VectorLayer$1, easing, CanvasImmediateRenderer, transform$5, Overlay$1, DragPan, DoubleClickZoom, Interaction, DrawClass, Observable$3, Rotate$1, OLScaleLine, ProjUnits, Zoom, Map$4, echarts, SnapInteraction, Modify, OlView, condition, MouseWheelZoom, interaction) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var proj__namespace = /*#__PURE__*/_interopNamespace(proj);
  var Turf__namespace = /*#__PURE__*/_interopNamespace(Turf);
  var Tile__default = /*#__PURE__*/_interopDefaultLegacy(Tile);
  var XYZ__default = /*#__PURE__*/_interopDefaultLegacy(XYZ);
  var TileGrid__default = /*#__PURE__*/_interopDefaultLegacy(TileGrid);
  var TileImage__default = /*#__PURE__*/_interopDefaultLegacy(TileImage);
  var StaticImageSource__default = /*#__PURE__*/_interopDefaultLegacy(StaticImageSource);
  var ImageLayer__default = /*#__PURE__*/_interopDefaultLegacy(ImageLayer);
  var WMTS__default = /*#__PURE__*/_interopDefaultLegacy(WMTS);
  var WMTSTileGrid__default = /*#__PURE__*/_interopDefaultLegacy(WMTSTileGrid);
  var ImageWMS__default = /*#__PURE__*/_interopDefaultLegacy(ImageWMS);
  var TileWMS__default = /*#__PURE__*/_interopDefaultLegacy(TileWMS);
  var TileArcGISRest__default = /*#__PURE__*/_interopDefaultLegacy(TileArcGISRest);
  var OlStyle__default = /*#__PURE__*/_interopDefaultLegacy(OlStyle);
  var OlIcon__default = /*#__PURE__*/_interopDefaultLegacy(OlIcon);
  var Text__default = /*#__PURE__*/_interopDefaultLegacy(Text);
  var Fill__default = /*#__PURE__*/_interopDefaultLegacy(Fill);
  var Stroke__default = /*#__PURE__*/_interopDefaultLegacy(Stroke);
  var CircleStyle__default = /*#__PURE__*/_interopDefaultLegacy(CircleStyle);
  var OLCircleGeom__default = /*#__PURE__*/_interopDefaultLegacy(OLCircleGeom);
  var LineString__default = /*#__PURE__*/_interopDefaultLegacy(LineString);
  var Point__default = /*#__PURE__*/_interopDefaultLegacy(Point$3);
  var OlFeature__default = /*#__PURE__*/_interopDefaultLegacy(OlFeature);
  var OlMultiPoint__default = /*#__PURE__*/_interopDefaultLegacy(OlMultiPoint);
  var OlMultiLineString__default = /*#__PURE__*/_interopDefaultLegacy(OlMultiLineString);
  var Polygon__default = /*#__PURE__*/_interopDefaultLegacy(Polygon$2);
  var OlMultiPolygon__default = /*#__PURE__*/_interopDefaultLegacy(OlMultiPolygon);
  var Geojson__default = /*#__PURE__*/_interopDefaultLegacy(Geojson);
  var ImageCanvas__default = /*#__PURE__*/_interopDefaultLegacy(ImageCanvas);
  var VectorSource__default = /*#__PURE__*/_interopDefaultLegacy(VectorSource);
  var VectorLayer__default = /*#__PURE__*/_interopDefaultLegacy(VectorLayer$1);
  var CanvasImmediateRenderer__default = /*#__PURE__*/_interopDefaultLegacy(CanvasImmediateRenderer);
  var Overlay__default = /*#__PURE__*/_interopDefaultLegacy(Overlay$1);
  var DragPan__default = /*#__PURE__*/_interopDefaultLegacy(DragPan);
  var DoubleClickZoom__default = /*#__PURE__*/_interopDefaultLegacy(DoubleClickZoom);
  var Interaction__default = /*#__PURE__*/_interopDefaultLegacy(Interaction);
  var DrawClass__default = /*#__PURE__*/_interopDefaultLegacy(DrawClass);
  var Rotate__default = /*#__PURE__*/_interopDefaultLegacy(Rotate$1);
  var OLScaleLine__default = /*#__PURE__*/_interopDefaultLegacy(OLScaleLine);
  var ProjUnits__default = /*#__PURE__*/_interopDefaultLegacy(ProjUnits);
  var Zoom__default = /*#__PURE__*/_interopDefaultLegacy(Zoom);
  var Map__default = /*#__PURE__*/_interopDefaultLegacy(Map$4);
  var echarts__namespace = /*#__PURE__*/_interopNamespace(echarts);
  var SnapInteraction__default = /*#__PURE__*/_interopDefaultLegacy(SnapInteraction);
  var Modify__default = /*#__PURE__*/_interopDefaultLegacy(Modify);
  var OlView__default = /*#__PURE__*/_interopDefaultLegacy(OlView);
  var MouseWheelZoom__default = /*#__PURE__*/_interopDefaultLegacy(MouseWheelZoom);

  var ProjUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get getProjection () { return getProjection; },
    get CoordinateDecryptType () { return CoordinateDecryptType; },
    get register () { return register; },
    get transformToDataProjection () { return transformToDataProjection; },
    get transformToProjection () { return transformToProjection; },
    get transform () { return transform$3; },
    get transformInternal () { return transformInternal; },
    get WGStoGCJ () { return WGStoGCJ; },
    get GCJtoWGS () { return GCJtoWGS; },
    get GCJtoBD () { return GCJtoBD; },
    get BDtoGCJ () { return BDtoGCJ; },
    get WGStoBD () { return WGStoBD; },
    get BDtoWGS () { return BDtoWGS; },
    get transformGeoJsonFeature () { return transformGeoJsonFeature; },
    get transformGeoJsonGeometryCoordinates () { return transformGeoJsonGeometryCoordinates; },
    get dataOffset () { return dataOffset; }
  });

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$1 = "@charset \"UTF-8\";\n.mti-gis-overlay-tooltip {\n  position: absolute;\n}\n.mti-gis-overlay-tooltip .tooltip-container {\n  border-radius: 4px;\n  padding: 10px;\n  z-index: 2000;\n  font-size: 12px;\n  line-height: 1.2;\n  min-width: 10px;\n  word-wrap: break-word;\n}\n.mti-gis-overlay-tooltip .tooltip-container .popper-arrow,\n.mti-gis-overlay-tooltip .tooltip-container .popper-arrow:after {\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n  border-color: transparent;\n  border-style: solid;\n  border-width: 6px;\n}\n.mti-gis-overlay-tooltip .is-dark {\n  background: #303133;\n  color: #fff;\n}\n.mti-gis-overlay-tooltip .is-light {\n  background: #fff;\n  color: #303133;\n  border: 1px solid #303133;\n}\n.mti-gis-overlay-tooltip div[class~=is-top] {\n  margin-bottom: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-top] .popper-arrow {\n  bottom: 1px;\n  border-bottom-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-top is-dark\"] .popper-arrow {\n  border-top-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-top is-light\"] .popper-arrow {\n  border-top-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-bottom] {\n  margin-top: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-bottom] .popper-arrow {\n  top: 1px;\n  border-top-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-bottom is-dark\"] .popper-arrow {\n  border-bottom-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-bottom is-light\"] .popper-arrow {\n  border-bottom-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-left] {\n  margin-right: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-left] .popper-arrow {\n  right: 1px;\n  border-right-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-left is-dark\"] .popper-arrow {\n  border-left-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-left is-light\"] .popper-arrow {\n  border-left-color: #fff;\n}\n.mti-gis-overlay-tooltip div[class~=is-right] {\n  margin-left: 6px;\n}\n.mti-gis-overlay-tooltip div[class~=is-right] .popper-arrow {\n  left: 1px;\n  border-left-width: 0;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-right is-dark\"] .popper-arrow {\n  border-right-color: #303133;\n}\n.mti-gis-overlay-tooltip div[class$=\"is-right is-light\"] .popper-arrow {\n  border-right-color: #fff;\n}\n\n.mti-gis-overlay .context-menu {\n  font-size: 12px;\n  box-shadow: 0px 0px 5px 0px;\n  text-align: center;\n  width: 130px;\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  user-select: none;\n}\n.mti-gis-overlay .context-menu .item {\n  cursor: pointer;\n  height: 34px;\n  line-height: 34px;\n  list-style: none;\n}\n.mti-gis-overlay .context-menu .item::before {\n  content: \"☆\";\n  position: absolute;\n  left: 10px;\n}\n.mti-gis-overlay .context-menu .item:last-child {\n  border-bottom: none;\n  height: 35px;\n  line-height: 35px;\n}\n.mti-gis-overlay .dark .item {\n  color: #fff;\n  background-color: #303133;\n  border-bottom: 1px solid #606266;\n}\n.mti-gis-overlay .dark .item:hover {\n  background-color: #606266;\n}\n.mti-gis-overlay .light .item {\n  color: #303133;\n  background-color: #fff;\n  border-bottom: 1px solid #eee;\n}\n.mti-gis-overlay .light .item:hover {\n  background-color: #eee;\n}\n\n.gis-widget-coordinate {\n  position: absolute;\n  bottom: 0px;\n  right: 10px;\n  color: white;\n  z-index: 10;\n  font-size: 12px;\n}\n\n.mti-measure-tool {\n  position: absolute;\n  padding: 1px 1px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  font-size: 12px;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-move {\n  position: absolute;\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: left;\n  white-space: nowrap;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  font-size: 12px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-move .tool-tip {\n  color: #7a7a7a;\n}\n\n.mti-measure-tool-move span .measure-result {\n  color: #ff6319;\n}\n\n.mti-measure-tool-overlay-label {\n  border: 1px solid #7a7a7a;\n  border-radius: 4px;\n  color: #7a7a7a;\n  font-size: 12px;\n  padding: 1px 4px;\n  background-color: #ffffff;\n}\n\n.mti-measure-tool-area-overlay-label {\n  font-size: 12px;\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  background-color: #ffffff;\n  border: 1px solid #ff0103;\n  color: #333333;\n}\n\n.mti-measure-tool-end-overlay-label {\n  padding: 3px 5px;\n  line-height: normal;\n  text-align: center;\n  white-space: nowrap;\n  font-size: 12px;\n  word-spacing: 3px;\n  letter-spacing: 1px;\n  border: 1px solid #ff0103;\n  color: #333333;\n  background-color: white;\n}\n\n.mti-measure-tool-end-overlay-label .measure-end-label {\n  color: #ff6319;\n}\n\n/* 右键菜单组件 */\n#mti-contextmenu {\n  background: #15191bd1;\n  border: 1px solid #0da4a9;\n  min-width: 110px;\n  box-shadow: 1px 1px 2px 1px rgba(255, 255, 255, 0.3);\n}\n\n#mti-contextmenu ul,\n#mti-contextmenu li {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  color: #a1afaf;\n}\n\n.mti-contextmenu {\n  background: #15191bd1;\n  min-width: 110px;\n  font-size: 12px;\n}\n\n.mti-contextmenu a {\n  border-bottom: 1px solid rgba(5, 99, 98, 0.82);\n  padding: 5px 15px;\n  transition: background-color 0.15s;\n  display: block;\n  clear: both;\n  font-weight: 400;\n  line-height: 1.6;\n  white-space: nowrap;\n  color: #a1afaf;\n  text-decoration: none;\n}\n\n.mti-contextmenu li:last-child a {\n  border-bottom: none;\n}\n\n.mti-contextmenu a:hover {\n  background-color: #444d59;\n  color: #fff;\n}\n\n.ole-scale-line-control {\n  position: absolute;\n  bottom: 0.5em;\n  left: 0.5em;\n  border-radius: 4px;\n  padding: 2px;\n  transition: 0.3s;\n}\n\n.ole-scale-line-control .ole-scale-line-control-inner {\n  border: 2px solid #2d2922;\n  border-top: none;\n  color: #2d2922;\n  font-size: 12px;\n  text-align: center;\n  height: 10px;\n  line-height: 0px;\n  font-family: \"Microsoft YaHei\";\n  margin: 1px;\n  will-change: contents, width;\n}\n\n.mti-gis-ol-scale-line {\n  position: absolute;\n  left: 10px;\n  bottom: 10px;\n}\n\n.mti-gis-ol-scale-line-text {\n  text-align: center;\n  font-size: 10px;\n}\n\n.mti-gis-ol-scale-line-line {\n  position: relative;\n  height: 8px;\n}\n\n.mti-gis-ol-scale-line-line > div {\n  box-sizing: content-box !important;\n  position: absolute;\n  background-color: #333;\n  overflow: hidden;\n}\n\n.mti-gis-ol-scale-line-edgeleft,\n.mti-gis-ol-scale-line-edgeright {\n  width: 1px;\n  height: 6px;\n  border: solid 1px #fff;\n}\n\n.mti-gis-ol-scale-line-middle {\n  height: 2px;\n  left: 2px;\n  top: 2px;\n  border-top: solid 1px #fff;\n  border-bottom: solid 1px #fff;\n}\n\n.p-helper-circle-point-div {\n  width: 60px;\n  height: 22px;\n  opacity: 0.8;\n}\n\n.p-helper-control-point-div {\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  border-color: red;\n  background-color: red;\n  opacity: 0.8;\n}\n\n.p-helper-lbutton-point-div {\n  width: 30px;\n  height: 100%;\n  cursor: move;\n  float: left;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAeCAYAAADQBxWhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMkZCRkJBNUYxODAxMUU5QTRBRkFGRjVBQjEyN0EzQyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMkZCRkJBNkYxODAxMUU5QTRBRkFGRjVBQjEyN0EzQyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkUyRkJGQkEzRjE4MDExRTlBNEFGQUZGNUFCMTI3QTNDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkUyRkJGQkE0RjE4MDExRTlBNEFGQUZGNUFCMTI3QTNDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+sycNXwAAA+xJREFUeNq8l11MW2UYx/+n57SkX4MOSrXANlSKxYld1xa22GAhNFISUNMsSDTBxTs/oolyQ0i4kHjhx4UmuzCacKESnTHqDEOXTF2iYILxxlgSs/oBWtrSln5u7drz+pxOFoEhtGt9kt70nL6/Pl//53k5j8eD3YzjODDGkM1mFbFYbKhQKNxfX19/XK1WH1EoFLUoz1LCbk9kMhkymUxtJBJ5rqGh4cn+/v7mrq4umEwmGAwGELhMJrTCzbyTLBAInFIqla+NjY01Dw8Po7W1FRWypLAdSCHEysrKGzab7Znx8XF0dHSg0iZsB66urr7n9XpHJycnwfM8qmE3oFLBkIdvSsCpqSlU02SbRbO2tua1Wq1PVxtY5ElhTafTaiqamenp6apAKIhboVJYqS1eGB0dVbe0tFQMJIrAzPs5vPx6dgcUfX19cpfLFQ2FQqwS9legwM68nWXuR1IMtRvM0ZvY/kpCiEajnoGBAZ1er78lz5Z+zOPjz/K48E0ev1wWqU6uf99slO2sXmqTB7u7u8uGfT5PsHM5XFooIBBkRZhaCRw183C7BDw0KN8JJYnrbGtrKwm0EWc4d/4aPvzkGr7/oYB4kg6i5jtyiMNJOw+PW45B+igUu/SpRqM5vN/QpjMMZ97J4SzBfvtdhFQfSiWHY52yoleDbgF3m/YWFEEul9fuV7yDYYaXXs1CqwEOHpThUBOHF5+tQb9LKF0c9msqylXbHTJEogxXswyZqwwXL+Ux92UeV66wfZ/DUz6fopl6QKVS7fmyRs3B5RRQr+OwHmH4ySfi6++uQy98lccff4pQ0zHG2//Tlxx6e3u/9fl8JfdjPCGydz/IsqGRFDOY4kx5W5ypm+LsTmuCjZxOs9mzWZZMiTf7aYLXarV2i8Via29vLykvNTUcOu/h8ahXUWwPQc4QizGshRgu/yrii4t5fDqXh1hgsB3bkvMcbzQaBdLdEVKmsnv1Lsrz0IAczhMCajUctRBDmMLv94vYSIg4/VjN1vBWWgYlC4ZE9tZMlll7ksz9cJKJ4rbwms1mMRgMkrPKB+x2e0XEXk0Fd9zC4/FTcljvE2DQy/DPFlT0tDjaaMN7ZXZ2Nk1DvKIjTaXiYLmXv6HDW0YbiUOaNr8nJiYm8H+Y1KfFVYXk8Ofl5WX9+vq6o6enp5rMHL8p9lKYqX3mFhcXzeFw+KjT6SyuMVWFbu5KBP5oYWGhYWlpySEt1rc6Z/eEboLr6urO+/1+3/z8/IlkMnlA2uh1Ol3FoNxud5l/XSuel64V1E5NDocDknI1NjbSSFOWHX6uhAvUMG0ZJ+kP2Gk4HKaRqKXn5VBTfwswAHSScicWQmgwAAAAAElFTkSuQmCC) no-repeat;\n}\n\n.p-helper-rbutton-point-div {\n  width: 30px;\n  height: 100%;\n  cursor: move;\n  float: left;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAeCAYAAADQBxWhAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQyIDc5LjE2MDkyNCwgMjAxNy8wNy8xMy0wMTowNjozOSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6REU3NTczRjBGMTgwMTFFOTk0NTlERTJDNEY1RUMzRDgiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6REU3NTczRUZGMTgwMTFFOTk0NTlERTJDNEY1RUMzRDgiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZBOTRBQjUwRjE3QzExRTk5N0Y4OTdEODI4RkYyMjg2IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZBOTRBQjUxRjE3QzExRTk5N0Y4OTdEODI4RkYyMjg2Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+6YlDwwAAA9pJREFUeNq8V2tom2UUfr5cSbLVpiVb6EULzm1ECk5QLILYVocW5+bSKQQsrCqIWP/on9k/XWkR+0PFqfhjlSFTcW2FVN1mRzdkm70k68akjU2RtjTb7C1t2lyay/cdzzstdE3D0izZ8yfwfnx5vnPe55zzHMlut98EsAUZIBaLBUKh0MT8/PwVtVp9yWw2d+v1+pgkSSCilO9J4XCYkCGYENPT0/B6vRgYGIDb7fbNzc0dLyws/MxoNAYURdmYlL9oiX+3IgsYHx+H0+lEV1eXLxKJvG+1Wk+J8/VRZ5V0FSMjI2hraxORHystLX2PU38HsQo5gM1mQ3t7O2praxt8Pt93sixD3HNOSQVEdE1NTWChOqampo6tjTQn6V2Puro6DA8PHyoqKuoU4rojUqLckLa2tsJgMJxgtZtEmpNIP/okihPfx5BC7RmBxQSHw2Hiev7gdppFemkNnqxaIjywSHsPBumr41G6eUumbGBmZoYqKyv91dXV2iQhlRT9d+QaknGkeQUvO8L48OgK3FcT9xStxWJBRUWF2e/316hZYUf4TL/6cE+5BqXFKoQjgH+BcGua0O+W8VtvAteuy6xKCTt3ZCZ67n7o7e1dTErvKqJRop9+jtGbDSGyPbVExuIA6bYHyLIjQC+9FqRvf4jSwqKyqRR7PB6qqqq6nFbJ/OWV8WtPAj0XEvB4FUQiBFHqZQ+pcOiAFu+8oYPJKN01UhYS6uvrb6SMNBV6zsfp+QNB2vXEMhXbApT3YID+nkhPbNyPiZvFsibd+xDRXbgo42JfAuEVwkqUMO8nPLpbDaNhc3d7V1Kh2tPnEjj/ewJ/ehQsBQlbOJXlNhXeel2PV1/RwbpNlfYojMfjgQ1JgyHCL2ficJ5JwHVNxj+sYEUG8vKAmmoNE2mx70Ut8rZKm4pwdnYWwWBwMon062+iaD8Zx8SkgjiXpsydqdgq4Zmn1bDv0+GF5zQZ1+rY2Bh4yF9P+oeTp2JwX1GQb5aw6xEV9j6rgX2/Fo+Vq++5Hfb394vpc1azvvcK6T++R423D+uwv0aLbRYpK/1XpLavr2+hoKDgdBLpx0cN2PmwCkajlNVJ09HRIer085KSkvh9mac8xMWUCWm12u1s2EIq3Ac0NjaKvnvYZDKFxGjLOWlzczOGhoa+ZGfYsWpJNbkiE2aspaUFnZ2dP/IQf3etAc8J6RoL+gUTNqy3oFklFWa7u7tbRHfbbJeVlW1otjX8MCPlivvhd8E2BKOjoxgcHITL5brx/1rxaX5+fuq1ItMFir9e4ea9zKqcZCIXp/APXqCc6SxQ/wowAHXm3jQy9m6CAAAAAElFTkSuQmCC) no-repeat;\n}\n\n.cesium-credit-logoContainer {\n  visibility: hidden;\n}\n\n.cesium-viewer-overlay-container-stopevent > * {\n  pointer-events: auto;\n}\n\n.cesium-viewer-overlay-container-stopevent,\n.cesium-viewer-overlay-container {\n  user-select: none;\n  overflow: hidden;\n  pointer-events: none;\n  position: absolute;\n  z-index: 0;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n\n.mti-gis-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n/* 军事标会提示信息框 */\n.mti3d-tips {\n  position: absolute;\n  z-index: 9998;\n  min-height: 10px;\n  min-width: 100px;\n  background-color: rgba(0, 0, 0, 0.75);\n  border-radius: 14px;\n  white-space: nowrap;\n  color: #c7cece;\n  font-size: 12px;\n  padding: 3px 8px 3px 12px;\n  user-select: none;\n}\n\n.mti3d-tips::after {\n  position: absolute;\n  z-index: 999;\n  top: 50%;\n  left: -3px;\n  margin-top: -4px;\n  content: \"\";\n  width: 8px;\n  height: 8px;\n  background-color: black;\n  box-sizing: border-box;\n  transform: rotate(-45deg);\n  box-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3);\n}\n\n/**\n  popup style created by qzj\n*/\n.mti-gis-cesium-popups .info-popup {\n  position: absolute;\n  z-index: 9;\n  left: 0;\n  top: 0;\n  margin: 0;\n  user-select: none;\n}\n.mti-gis-cesium-popups .info-box {\n  position: relative;\n  height: auto;\n  padding: 0;\n}";
  styleInject(css_248z$1);

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal$1 || freeSelf || Function('return this')();

  var root$2 = root$1;

  /** Built-in value references. */
  var Symbol$2 = root$2.Symbol;

  var Symbol$3 = Symbol$2;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$a.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$a.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$9.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$a(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject$a(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$2['__core-js_shared__'];

  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$8 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$8.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$a(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var Map$2 = getNative(root$2, 'Map');

  var Map$3 = Map$2;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$7.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$6.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$3 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$3 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  var defineProperty$3 = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var defineProperty$4 = defineProperty$3;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty$4) {
      defineProperty$4(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  var baseFor$1 = baseFor;

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root$2.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */
  var Uint8Array$1 = root$2.Uint8Array;

  var Uint8Array$2 = Uint8Array$1;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Built-in value references. */
  var objectCreate$1 = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$a(proto)) {
        return {};
      }
      if (objectCreate$1) {
        return objectCreate$1(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  var baseCreate$1 = baseCreate;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  var getPrototype$1 = getPrototype;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

    return value === proto;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate$1(getPrototype$1(object))
      : {};
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$1;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$4.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$7.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments$1 = isArguments;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$2 = Array.isArray;

  var isArray$3 = isArray$2;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$1(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength$1(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer = moduleExports$1 ? root$2.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  var isBuffer$1 = isBuffer;

  /** `Object#toString` result references. */
  var objectTag$1 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$3 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$3.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto = getPrototype$1(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength$1(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal$1.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  var nodeUtil$1 = nodeUtil;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  var isTypedArray$1 = isTypedArray;

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$2.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$1.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$3(value),
        isArg = !isArr && isArguments$1(value),
        isBuff = !isArr && !isArg && isBuffer$1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$4.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$a(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray$3(srcValue),
          isBuff = !isArr && isBuffer$1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$3(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
        newValue = objValue;
        if (isArguments$1(objValue)) {
          newValue = toPlainObject(objValue);
        }
        else if (!isObject$a(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor$1(source, function(srcValue, key) {
      stack || (stack = new Stack);
      if (isObject$a(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$2(value) {
    return value;
  }

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply$5(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply$5(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty$4 ? identity$2 : function(func, string) {
    return defineProperty$4(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  var baseSetToString$1 = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString$1);

  var setToString$1 = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString$1(overRest(func, start, identity$2), func + '');
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject$a(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge$3 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  var merge$4 = merge$3;

  var GeoJsonGeometryType;
  (function (GeoJsonGeometryType) {
      GeoJsonGeometryType["POINT"] = "Point";
      GeoJsonGeometryType["MULTI_POINT"] = "MultiPoint";
      GeoJsonGeometryType["LINE_STRING"] = "LineString";
      GeoJsonGeometryType["MULTI_LINE_STRING"] = "MultiLineString";
      GeoJsonGeometryType["POLYGON"] = "Polygon";
      GeoJsonGeometryType["MULTI_POLYGON"] = "MultiPolygon";
  })(GeoJsonGeometryType || (GeoJsonGeometryType = {}));
  var FeatureType;
  (function (FeatureType) {
      FeatureType["CIRCLE"] = "Circle";
  })(FeatureType || (FeatureType = {}));
  var GeoJsonType;
  (function (GeoJsonType) {
      GeoJsonType["FEATURE"] = "Feature";
      GeoJsonType["FEATURE_COLLECTION"] = "FeatureCollection";
  })(GeoJsonType || (GeoJsonType = {}));
  /**
   * 互联网地图类型
   * @enum {number}
   * @ignore
   */
  var MapType;
  (function (MapType) {
      MapType["VECTOR"] = "vec";
      MapType["IMAGE"] = "img";
      MapType["TERRAIN"] = "ter";
      MapType["LABEL"] = "label"; // 注记
  })(MapType || (MapType = {}));
  /**
   * 百度地图风格枚举
   */
  var BDMapType;
  (function (BDMapType) {
      BDMapType["IMAGE"] = "img";
      BDMapType["LABEL"] = "label";
      BDMapType["VEC"] = "vec";
      BDMapType["TRAFFIC"] = "traffic";
  })(BDMapType || (BDMapType = {}));
  /**
   *  切片方案类型
   * @enum {number}
   * @ignore
   */
  var TilingSchemeType;
  (function (TilingSchemeType) {
      TilingSchemeType["MERCATOR"] = "mercator";
      TilingSchemeType["GEOGRAPHIC"] = "geographic";
  })(TilingSchemeType || (TilingSchemeType = {}));
  /**
   * 锚点方位
   *
   * @enum {number}
   */
  var Positioning;
  (function (Positioning) {
      Positioning["BOTTOM_LEFT"] = "bottom-left";
      Positioning["BOTTOM_CENTER"] = "bottom-center";
      Positioning["BOTTOM_RIGHT"] = "bottom-right";
      Positioning["CENTER_LEFT"] = "center-left";
      Positioning["CENTER_CENTER"] = "center-center";
      Positioning["CENTER_RIGHT"] = "center-right";
      Positioning["TOP_LEFT"] = "top-left";
      Positioning["TOP_CENTER"] = "top-center";
      Positioning["TOP_RIGHT"] = "top-right";
  })(Positioning || (Positioning = {}));
  /**
   * 经纬度偏移加密类型
   */
  var CoordinateDecryptType;
  (function (CoordinateDecryptType) {
      /**
       * WGS84转到国测局02
       */
      CoordinateDecryptType["WGS_TO_GCJ"] = "WGStoGCJ";
      /**
       * 国测局02转到WGS84
       */
      CoordinateDecryptType["GCJ_TO_WGS"] = "GCJtoWGS";
      /**
       * 国测局02转到百度
       */
      CoordinateDecryptType["GCJ_TO_BD"] = "GCJtoBD";
      /**
       * 百度转到国测局02
       */
      CoordinateDecryptType["BD_TO_GCJ"] = "BDtoGCJ";
      /**
       * WGS84转到百度
       */
      CoordinateDecryptType["WGS_TO_BD"] = "WGStoBD";
      /**
       * 百度转到WGS84
       */
      CoordinateDecryptType["BD_TO_WGS"] = "BDtoWGS";
  })(CoordinateDecryptType || (CoordinateDecryptType = {}));
  var BaseEventType;
  (function (BaseEventType) {
      //----------------通用鼠标事件-------------------
      BaseEventType["CLICK"] = "click";
      BaseEventType["DOUBLE_CLICK"] = "doubleclick";
      BaseEventType["MOUSE_DOWN"] = "mousedown";
      BaseEventType["MOUSE_UP"] = "mouseup";
      BaseEventType["RIGHT_CLICK"] = "rightclick";
      BaseEventType["MOUSE_MOVE"] = "mousemove";
      BaseEventType["PICK"] = "pick";
      BaseEventType["DOUBLE_PICK"] = "doublepick";
      BaseEventType["RIGHT_PICK"] = "rightpick";
      //----------------------------------------------
      BaseEventType["ZOOM_CHANGED"] = "zoomchanged";
      BaseEventType["CENTER_CHANGED"] = "centerchanged";
      BaseEventType["MOVE_START"] = "movestart";
      BaseEventType["MOVE_END"] = "moveend";
      //----------------地球对象事件-------------------
      BaseEventType["ADD_LAYER"] = "addlayer";
      BaseEventType["REMOVE_LAYER"] = "removelayer";
      BaseEventType["ADD_MODEL"] = "addmodel";
      BaseEventType["REMOVE_MODEL"] = "removemodel";
      BaseEventType["ADD_OVERLAY"] = "addoverlay";
      BaseEventType["REMOVE_OVERLAY"] = "removeoverlay";
      BaseEventType["ADD_COMPONENT"] = "addcomponent";
      BaseEventType["ADD_PARTICLE"] = "addparticle";
      BaseEventType["REMOVE_COMPONENT"] = "removecomponent";
      BaseEventType["REMOVE_PARTICLE"] = "removeparticle";
      BaseEventType["CAMERA_CHANGED"] = "camerachanged";
      BaseEventType["CAMERA_MOVE_END"] = "cameramoveend";
      BaseEventType["CAMERA_MOVE_START"] = "cameramovestart";
      //---------------------------------------
      //----------------矢量图层事件-----------------------
      BaseEventType["ADD_FEATURE"] = "addfeature";
      BaseEventType["ADD_FEATURES"] = "addfeatures";
      BaseEventType["REMOVE_FEATURE"] = "removefeature";
      BaseEventType["STYLE_CHANGED"] = "stylechanged";
      //----------------------------------------
      //-----------------覆盖物相关事件----------------------
      BaseEventType["POST_RENDER"] = "postrender";
      //---------------------------------------
      //------------------绘制组件--------------------
      BaseEventType["DRAW_START"] = "drawstart";
      BaseEventType["DRAW_END"] = "drawend";
      //-------------------军事标绘组件
      BaseEventType["EDIT_START"] = "editstart";
      BaseEventType["EDIT_END"] = "editend";
      //----------周边搜索-------------
      BaseEventType["RADIUS_CHANGE"] = "radiuschange";
      //------------历史轨迹-----------------
      BaseEventType["TRACK_MOVE"] = "trackmove";
      BaseEventType["TRACK_MOVE_END"] = "trackmoveend";
      //---------------------------------------
      BaseEventType["FLY_END"] = "flyend";
      BaseEventType["FLY_START"] = "flystart";
      //-----------------模型调整器----------------------
      BaseEventType["MOVE"] = "move";
      BaseEventType["ROTATE_START"] = "rotatestart";
      BaseEventType["ROTATE"] = "rotate";
      BaseEventType["ROTATE_END"] = "rotateend";
      BaseEventType["SCALE_START"] = "scalestart";
      BaseEventType["SCALE"] = "scale";
      BaseEventType["SCALE_END"] = "scaleend";
      //----------------------------------------------
      //------------------右键菜单---------------------
      BaseEventType["SHOW"] = "show";
      BaseEventType["HIDE"] = "hide";
      //-----------------------------------------------------
      BaseEventType["MEASURE_END"] = "measureend";
      //-------------------------------------------------
      BaseEventType["TRANSLATION_END"] = "translationend";
      //----------------------------------------------
      BaseEventType["CHANGE"] = "change";
      BaseEventType["ERROR"] = "error";
      BaseEventType["BLUR"] = "blur";
      BaseEventType["CLEAR"] = "clear";
      BaseEventType["DRAGENTER"] = "dragenter";
      BaseEventType["DRAGOVER"] = "dragover";
      BaseEventType["DROP"] = "drop";
      BaseEventType["FOCUS"] = "focus";
      BaseEventType["KEYDOWN"] = "keydown";
      BaseEventType["KEYPRESS"] = "keypress";
      BaseEventType["LOAD"] = "load";
      BaseEventType["RESIZE"] = "resize";
      BaseEventType["TOUCHMOVE"] = "touchmove";
      BaseEventType["WHEEL"] = "wheel";
  })(BaseEventType || (BaseEventType = {}));

  /**
   * 高度定位时的参考方式
   */
  var HeightReference;
  (function (HeightReference) {
      /**
       * 绝对高度
       */
      HeightReference[HeightReference["NONE"] = 0] = "NONE";
      /**
       * 贴紧地形
       */
      HeightReference[HeightReference["CLAMP_TO_GROUND"] = 1] = "CLAMP_TO_GROUND";
      /**
       * 地形之上的高度
       */
      HeightReference[HeightReference["RELATIVE_TO_GROUND"] = 2] = "RELATIVE_TO_GROUND";
  })(HeightReference || (HeightReference = {}));
  /**
   * 样式类别
   */
  var StyleItemType;
  (function (StyleItemType) {
      /**
       * 图片渲染点
       */
      StyleItemType["ICON"] = "icon";
      /**
       * 文字标注
       */
      StyleItemType["LABEL"] = "label";
      /**
       * 颜色渲染
       */
      StyleItemType["COLOR"] = "color";
      /**
       * 图片填充渲染
       */
      StyleItemType["IMAGE"] = "image";
      StyleItemType["POLYLINE_ARROW"] = "polylineArrow";
      StyleItemType["ARROW_LINE"] = "arrowLine";
      /**
       * 发光线
       */
      StyleItemType["POLYLINE_GLOW"] = "polylineGlow";
      StyleItemType["POLYLINE_OUTLINE"] = "polylineOutline";
      StyleItemType["POLYGON_ENTITY"] = "polygonEntity";
      StyleItemType["ELLIPSE_ENTITY"] = "ellipseEntity";
      /**
       * 模型渲染点
       */
      StyleItemType["MODEL"] = "model";
      StyleItemType["MODEL_ENTITY"] = "modelEntity";
      /**
       * 水面
       */
      StyleItemType["WATER"] = "water";
      StyleItemType["POLYGON"] = "polygon";
      /**
       * 点要素 圆圈
       */
      StyleItemType["CIRCLE"] = "circle";
      /**
       * 二维自定义渲染器
       */
      StyleItemType["RENDERER"] = "renderer";
      /**
       * 流动渲染
       */
      StyleItemType["FLOW"] = "flow";
      /**
       * 闪烁渲染
       */
      StyleItemType["LINEAR_GRADIENT"] = "linearGradient";
      /**
       * 直线流动渲染
       */
      StyleItemType["LINEAR_FOW"] = "linearFlow";
      /**
       * 箭头流动渲染
       */
      StyleItemType["ARROW_FOW"] = "arrowFlow";
      /**
       * 径向渐变
       */
      StyleItemType["RADIAL_GRADIENT"] = "radialGradient";
      /**
       * 扩散波纹
       */
      StyleItemType["RIPPLE"] = "ripple";
      /**
       * 旋转
       */
      StyleItemType["ROTATE"] = "rotate";
  })(StyleItemType || (StyleItemType = {}));

  var Style = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get HeightReference () { return HeightReference; },
    get StyleItemType () { return StyleItemType; },
    get Positioning () { return Positioning; }
  });

  var _a$3, _b$1;
  var PROJECTION_NAME = Symbol.for("Projection");
  var WGS84_PROJECTION_NAME = "EPSG:4326";
  var WEB_MERCATOR_PROJECTION_NAME = "EPSG:3857";
  var PUBLIC_CONFIG = (_a$3 = {},
      _a$3[PROJECTION_NAME] = WEB_MERCATOR_PROJECTION_NAME,
      Object.defineProperty(_a$3, "projection", {
          get: function () {
              // @ts-ignore
              return this[PROJECTION_NAME];
          },
          set: function (projection) {
              this[PROJECTION_NAME] = projection;
          },
          enumerable: false,
          configurable: true
      }),
      _a$3.dataProjection = WGS84_PROJECTION_NAME,
      _a$3.key = {
          tKey: "461d3e793f21ff8d082b522a788b4f8b"
      },
      _a$3.zoom = 3,
      _a$3);
  /**
   * 修改当前全局配置
   *
   * @param {object} [options] 全局配置
   */
  function set$2(options) {
      merge$4(PUBLIC_CONFIG, options);
  }
  /**
   * 获取当前全局配置
   */
  function get$3() {
      return JSON.parse(JSON.stringify(PUBLIC_CONFIG));
  }
  var DEFAULT_STYLE_ITEM = (_b$1 = {},
      _b$1[StyleItemType.IMAGE] = {
          entity: true,
          transparent: true
      },
      _b$1[StyleItemType.ICON] = {
          entity: true,
          positioning: Positioning.BOTTOM_CENTER,
          rotated: false
      },
      _b$1[StyleItemType.LABEL] = {
          entity: true,
          font: "10px sans-serif",
          showBackground: false,
          outlineWidth: 0,
          outlineColor: "rgba(255,255,255,1)",
          fillColor: "rgba(255,255,255,1)",
          backgroundColor: "rgba(255,255,255,1)",
          positioning: Positioning.CENTER_CENTER,
          style: 2,
          backgroundPadding: [0, 0],
          offset: [0, 0]
      },
      _b$1[StyleItemType.CIRCLE] = {
          entity: true,
          radius: 5,
          fillColor: "yellow",
          outlineColor: "red",
          outlineWidth: 1
      },
      _b$1[StyleItemType.COLOR] = {
          entity: true,
          width: 1,
          fillColor: "rgba(255,0,0,0.2)",
          borderColor: "rgba(255,0,0,0.8)"
      },
      _b$1[StyleItemType.RADIAL_GRADIENT] = {
          entity: true,
          width: 0,
          borderColor: "rgba(255,0,0,0.8)",
          get gradientStep() {
              return [
                  [0, "rgba(255,0,0,0)"],
                  [0.5, "rgba(255,0,0,0.5)"],
                  [1, "rgba(255,0,0,1)"]
              ];
          }
      },
      _b$1[StyleItemType.LINEAR_GRADIENT] = {
          entity: true,
          horizontalDirection: false,
          reverse: false,
          duration: 0,
          get stop() {
              return [
                  [0, "rgba(255,0,0,0)"],
                  [0.5, "rgba(255,0,0,0.5)"],
                  [1, "rgba(255,0,0,1)"]
              ];
          }
      },
      _b$1[StyleItemType.LINEAR_FOW] = {
          entity: true
      },
      _b$1[StyleItemType.WATER] = {
          isSurface: true,
          baseWaterColor: "rgba(51,76.5,153,1)",
          animationSpeed: 0.01,
          frequency: 1000.0,
          amplitude: 10,
          flat: false,
          normalMap: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAABmCAMAAAAOARRQAAADAFBMVEWBg/2OcPx9g/54iP2LdP2Hhv2HcP2KavyBe/19iP2Efv5tk/uCiv2Rhf2Fdf19bf2Qdv2chft2c/2JkP2BdP2Ucfx+kv18jP19ZfuJi/1zhv14hP5zgf2Kg/15ef13Zvxpff2Da/x4bP1wff1+eP58ff2CcP1ahvprbvxxeP2Gef2Uk/xvaPuLef2DZPx3f/18cv1ujv1ud/1/gP6YafqOfP2Eg/1vg/2Xgfxzi/2Dh/6TeP1hlvqLofuOk/xzb/yHf/5tiP2Yc/x4j/1mjPyFlP2SYfqCjv1xc/15n/uSfvyOiP1kkvuPgf11fP6YZPp3k/x0o/mKmvyQmvuUjvxihfuSbPxnZvpgfvtjefyeevtpW/iJYfpyl/xnh/x1XPqNZfuKfv1rhPxpePyCkf2Whv2SWPdyY/pfYfhynft0V/ibjfuhbvpejvqYfPyHWPltmPtnl/tXffl5tfSne/mVivxlgPxdcPlYnPZXjfdtqvd/mvyeafltnvmkg/hOhPWQjfxkc/ucVvV2eP1RdveAofqSZ/uEmPuZmvqmXfWEnvtad/p/VfmBm/ucXveccvtmnfl3rPeNhPxfn/eqcPiAXPt7X/qOW/qBTvZ5m/xTlvapkvd7lvx/p/iIUfdWaPh0kf2zjvSii/qDcv1udP2iZPd1TPSzevevg/ZNkPWdfv2Vpvhia/qKmf2idfuRTPRRXfSMqfinpPZmuvB9gf1/YPpppfhmkP5efvt+fP2oZfeycPVmUfWVsPVBkO9GavJ1kPx5r/WgmPmfk/uoVPGOcf1gjfmDbv1GevRkrvWfUfKOfP2JuvGFXPpma/qyZ/JNpO9ZrvGMPO5VefifmPiUb/tfpfWisfJzlPxuWfiRbfyyT+x7ev6CkP1knPmofPhtff1Wte1aVPN5hv5wUvW1XfCMd/6Lh/1QkfaVlfyBnvuRkP1+rPiau++Qq/eGcPyJsfecQ/CTyet7tvOee/txp/haWvR1xe2hZPhpPvC9dvGvifbHberAne6iq/OCz+Xx+G0/AAABAHRSTlNra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tra2tla2tra2Vra2tra2tra2tra2tra2trZXNra2tra2tra21ra2xra2plZWtrc3Nra2tqa2tlZWtram5lc2tra3Nrc2Vra2ttZWVlampzc3Nrb3NzZWVrbHNla3Bzc3RzbWtuc2lramtzc3NlanNsaXNsaHNzRCwyhQAAGMRJREFUaN4ADAjz9wCSKqPTzsTfkpLGxqOSo6O1taPO0/bkidWjtbXV09Pf35Lgo5KS1JKS1aOjo7Sj4LTO5PbAwcHy98GNwMDUwbTVkuC0jcHJ4cGNxqPf35LUjcHBjcHBjbTgzs6jo86j39/V4JLVJuAAB9qkuLn0+Mfj2M3Zx9ray+Pd3t7a2cfd6vTN2biwzfTLx8faucvpy8vd3djn47i5uaS4uLjY6vPu/vX18+3+6vPz2N7z0djn48fH9PvL2rje4/Xz3eru56S43djjx8v7y6Ta2tg3ANXLdnIOdKJJCxBPLD8tDGQLfUwBBzE8yaubwxxygS6OgoyWlRhcNG4XQxYWZEkXHDpEeVhYEkgyNj1zCTcRsnPh8vJ6fRo5e1IRJHyUrhWERGl5gHR3FqFjyBZDR0WcsteFKzO4kgCS40QoD0tSZA1sQDEeEjkTbWlLYTFteJChosMMKFtcj5QhLDAUAQYAAE4DFlBpPVAWTFV5eEUlKCMxqi0gE52R1km9sROgPFB+u2CObK4Kf39QRASnWB+UQcheRxcWXau9zNft2KMA1OMjBllDri4AshkeFCknhX1BPXOxRL4DqBEROB4iGEZsBRwSBwcbCQU5cVFJUBlkFgt5eGJhHWJEAkudcAkIHGISClSHQyKXpc9mTwc4nJqLX2eCATkEZHqadgI2JSMQDQIr8P7UANfpAAB2XIkmnxGiNghEVSgaJWN9wgupF6F+bhEACghKShs2JiYbQQkWkJNJE2ECUElkf3kJCRk3WDMJUGQNL0QJDiIOKk+vpi6na0WAM1B2ll9fhhhfSDyZI4EaTRIGFAxAAkPu8gD9/lJkKqUHCqxvNUORyUU3YxByJ8MJyDOnfmt1BQwWgCtHHWUlIDcLUbZxQytTcHGZiHKEAwUZfUMmI2IdDFF6h2sHX0bEiVtqAZHM1xMcBm9XHyFgZ6xoZyGLVYhKD0w+OBJZ3tQA3+mIWlZuHRQwMBoLk4V7kXuR0UFLiMgu5RUVS4ADCT6ATTY+h0EjcnG2kRNdzHNzkb2RJyBDSWlSikESBGKakYiimwilypc/P0ifAKHCnMMZIyYPYV5iVSkehJ8IskN3YcMWWNnVALTdoadGLioACiN4USAvkJH3s/CKnIgCl1o7YQAZQCMMokolC7GKXZqpPDY+kGmdfYU97LNRC0NDmVOKFknRkyF8DcOiqKgqYxIwaHenSgkRDRpNIkEDWZqKNWhbvAdCLDJLQ0rNtQDA5/r6VAkCADqTeGElMn94UZmdc8yrwis+iD4XHRMMDzgRMTyKPVHWbSAXkFFQaXrssbNzKwMvICYIXXOzkTU0Bi2PlHSiPi8eA2J3lBUpVCsDdR1XHyywZ6eW4oEmB1knPi0By+AAo8eom4hLCEBemhucnX3Qml1pSbarm2uIUxFFUj5HSgQHS0x2L4ddcXCTUV0LkXrJsXOzw4h7nBkAC0x5C644awBuQn5+WkobCxcbSLo2PD7DDGFrQy9Id7yCFbCwBwdXsFyuYMfOALXNiY8Rqh4akFgj0Mxz0da2UEMDWqePDkqIhT1rj4ZWFBwcMFdIN3lwPHCd0XqRs7P3m2xHEwlHyXNJMS5WJX4dEVRrqHVTcQMEgyaqcDxlZYAFe51TAyCGmF8s4lsOYmMffCrjtQCS2oYKVMJHdlUCcsgpC3h4mT4IJo+ndAQSCWR1p1pKBQJOTgk5I1h/GiBYTJAL0LPJPf2bKgYeTn8ZF1GIVGaeBio+w5srBS8qBQJQkXpkDYANFwMENDAiFTU/KHd3XpBpDU0JubQAvfuGliE4ExooSHl/HH+aMSNKHTVsuo8MUF1HoqFrDR0KL04/Yy8nhBiscnJYTKk/mK/EqK4uH2OfKDFiqrvlb4wsDlpUslQKCgeBeJwkS1RuSiQUfIYwDx4TEz9ohL48HTgMRerAAJL8fiGYV0UZGprQeHp9n3lkODUVa6EdGwtQdXWhfm4tCDASJYFIWGcsf4uBn39MbMrSnlx+SyNjKGh3MInbzwcsVy5WL36oDBkreXJPllkrwlNFYXQFLwIeMDszJ75/Z1wBAjO5wADx+Gt+HYsoZNHh0JM8ewvIE8NuHRWoaxpeFDs1qKERQB0OLCliIywiJ3+BKHe/V7uoLSohAUoaJR+EcmbblCsrJoymMkB8dT4DilE5VIeBGBGHPX5lE2ESDiEOC5rIW6/S+VshubUAZqRuERZQbdHhttaQGzJMeBenRlZ8AREcEg4OLainERkVEDBXdzA/cqlediBYv6aCfGEASg4qgyEjhJaOrkoKdEIBP2hcNQyHnVFRhxNlKhgmHk2hZRA7JCEkN21irIyvXF/id83EALWkBFpITOHhPNa2OgoSvjxu/EIqOC1aJIMKAAXDsqvCfgAMCycDoH/II3ZjgVeMEhk+hmAGIZdfLLxfATQQFVoRQAA/HxICGn2dRwU4S1QElWoYlLpGIQYGKTJ3IigBBjAIqT/bZgC0pG9WYr7QMTypUFMTfb5Zus8+SnxGhhQ/TgIFgKuym5sFOQtEC0M3sGgiX2qmaFcfj3RAhp4HMjIpdxANNRUOiCsJMyaBYkOBHj5NGXvCmzsfjIJsNSQlFgMcYyMaAA0mJ1nx+KMA4MstHHm+fzxwi3Kxq0ypHeUHNIk0FQcYSGcYgwozoaGiPkE5PDczJFmEGCIYLGimppVLiKgKYhpIKWMcdVp1FwmrPVQWTG0WF1UMK2Q6EZubYQZCOzUCGiQILyc8AxeiF2OvgqSjDNb5U5OJAcbxN+R43xwkb8gbkpCQi9zkJgdJgISYBCSByJFASAgBJIFIuEQRZV1uBEGYajgUgXWFVmXE3bXWG6fL2NbOqF1nra3T6bZOp47THzrT2c600x/K3/DM95kPMP9bUtPQ0xtDBb7+wBVk4/1++sKleNxjt1P4Ubft1UDtuc1TRyBJVoM9QSmvYibDYaUh/5/ZOHXHqHIrqCvO1ZzIX9OdNB9eZbTbpuL0n1FRdBiuApf0loAyIacalyObn+aBP/+9t/PU0xu9q0XRxL6oeWZmff39ixUZR9MabRM8us0aOYbfYcKR+nqmUslbaZYp57bnZHBXjN1W3xMTJ+L+pSWMaDwUYtodhQMPY5GFARt2xEuAOVIXQ8Hr8AwTdK53d4GfvOvr/Ytv78Yst5yciYnsj2FmXhhEO4ObOp/XY7DRYZtKkgCDiXCyefu77/7zeHt3u0PpeajXmZQ45vru+jqTxxTqR9Ppx0nw0SWUit4F53nbvVhXUauo0mpfxphzAg++B+b/VPp60fp0j6mSi1D0mYcV8eF2rEO410+STS1UPlwWGECBXRA82D+5PqcOh1e2B/slnpZfyIebeTPr9kqVUCvi50Wa1SuPV2YGMAJnY6UcyWRNEwMaiEFzIjlml+7BPDD/6XevDx9fLB/NAHCoLb/jkYFTW1zr7r/Tsz6HG34FpqdiTKEapRXZeRQKhbe9cmeiXk0oVezuJraHMWFhHSRnuxQ2fYsx0Rw3VKgw3hJsBhZ/6IiGoud0j6wxSkOU68+Bl++KpJeraX33Jlle6iOyv6u9XEug1VUlV3rCPf7GQgyIygIFlCwNgQspKAKJfOJOMsxj7r8Iy3CcEcf5lkq91FJRUa45hsdNgRKjw5SJzS5joAEMt42SceZM9dUW4fWXwJuPOf2/NrOigcoW7JUvqFTvCWyWCOk2pNPpZA8z6HSiIAkCYOqVsaUDW7DLOKFBvjzZM1zIH/V11hb3AflEKSY4xQyLui+ACIJToBRoBotBIs1ms3Nc1cerp7+e/fAD8M07YpHULmiQTwmY/oFj+bUl+WVYMr3RiGMmKMzYhZgIyrVYGynJ5URzOouPZvT5Um4TZDOWlg6GamqIkzUke4xuSNcnX1zgackQuYV9gEMWoW+2pKnTd3mWmkWr/fQWeP5jtatV09kqNAgk9K6gpLu7AlHR/f7x9pZx9ZKHfpAMNE6+rRKJuer6kzpx1dBnLqNNu6AIFNg31J4dcWNQLawcENmX42q73gqDdmL16ZprRwLBjD7ibw4td5k5q/96C7y572bLU61YlQ2n9nfBag/mZjA9bKjgRRw4MKKGHFYLoIjQCWxAVdA2wWF/djkqUJ+IqRlZSld0CpEl/XABF7yWqQYLEX0IA1dGP/ehqTWzsGaxczF11gkUhIZ+nAee3c8ipCy8CGhciMfBigXPXHxmJU6BDUoJHcTJVVzdoaNUowkP4SB00xD/4tteLSwPXgpF8/P6CSZL7riYhUVl5V6jlh+ttchxCvSiS8bDH22vvefrm46tZ9d4pdLrz4C79zm9PsYJCLM845cfOnt7wRAf6+FVOSvFWthJUXKJugxFlxFvsknkrT6XdEguInTmL9SsnSedCTG1AkqViEzHlIP0/NWMSjw+m2aWZpNcxErg8FEXP3jJ3gHSJ4bePQPmP7Smmo7U1t1cGG45yR346UO/oQsXEqrwLFsMRdaH+FyFsVGMzmzEyRpOjg+Gw+U63bVbZ+rMURamJ7nES6gjIIaCQyzu/NyczbWS6lPZq0TAvQpYcxBUNz25TZnYuz9/cDZ559s0hQPOs1RVem731aPgFGzlMoXamAGFMHpz9OMYzE3xuK2dxt2p55dWycIdTNAAovQhGO4W2dXJuTQFo0W4/M3iJ2csGb3fVLszqtBNI9YDY7EGnAWi0dDenTfAlw/y6neEY8N+1bEBSDWzu+WECYCJwI15QHKOb5PFqVKhgojZXXsCKx+cGNejJX9tGx5rjig3SHWZVkgBQWK7uIzAbYgySoqnGUOBtVqvq4/UDoznOvyXaNnuvtLP7/8bePmAm9cQ8/ttSHAgF/zvlgdEMtikTBRoNHKlpVVYtnZqGJRLN789a7KkzueZhXDo8QwskuRNjNblZxZYTZoCIGpi9Z56Ozl5/Mm50Ymib4sXIYkpU0tZ6FKxScRO9871N8DdPyQCuPiyhFRos92e2d9CYYR6EejHEFqwDKm5gIzzxD1ZgRS00E7TVcn6C3BCytwSQjb3EUehzHyvyGTisjnsztOvL1692vnLL+5dljmmTV6HAKWIxCocXHEe38j5+Bz4/lcbG6hu9KbK2bg19rdhWxAnslOcKggpwDfp8giKoAHlMJ+vF7TnkiDtyZ2ECRKaEGZeaQOndLOEdatWlFHGlaeIRRdzzGUtzuKriIwPYxBbbi5Mp4gyIb4up+XUxx+An39ISa0lq9hGw/77sS063QaJRUJ0cZ1JY3Hh2YCXWmFC4+3NHRkluZXmEMcsx25au7WDbeY2/tCTr6a/PmcxFURTulSg6bORxrXVm+4iCUKrqDp0rJ1G42a4W9tExIsHgLp7fShABtUx2//ev/CgunCMEgiJ+jLrajqb0Gw8wUSlua0YtSwkcyo6a1pTbkiuobeUlTbI29r2XL+/An11i3Z48dTb0/eK8NR/zHYBhxmTk4q6VRVc4i3MzULISmXHxh+/PMjz/5Xa+zeU+x4H8C9mmGHMmGFmGMatPYgYRoRiu4bcp6TjUkkhZVPjUlQkmsJMNSQK1TZdtXJvmTYZ5+xFxejE2GIvlzR7oYWVkrQ7++zzdP6Dz7O+vzxrPWt91vdZ6/l+3t/X97E2zNByJEf859V5tf10YxN9O7/0cy6k/Foi0w+x9Vxc2XQ9lGNuqemeExic5BjieFWTw3WP1jG2udnjcFt4rHtQ8OJFxWtBqZsT8xe3Y8zMw/e1TPRO0Ug/2ye6GpBNaD+m/n8VsNntaELy/eOPe7puYUwi13hniboFxcTJi6RzMGSHN0nX1zc88hbHMcmHu4GguWl/cpUNJ5xnXXFBoyy12qx0W3Bj3baKFyc8LoWwLopNwreVRNxhqMe6cTZRj2gjEsk2KPrEFJYFZHFmjlX1Ly++uuSia8TMZ5poux5K3OLDQwE+pEPZJNfYHV4JTq7axI02tI1ke4trHD8aj7XhufUuvjuFd1In04MkZBaX8ci7DvpW4k2jj2+udCZbsHd5cTWpRkQi3lUnvUzajtrnXOLKm4ZXio6G4Y3wOvlezgambqRQJouF1HGuhSFhsaimxFVbw8OZtumsrfehwIrSgG2Hgx+U2frVeV4/cRo5RxrhebN3uzjUM262xjmWmnbZWzmO3qQjOJwtFxlFOhmkjQ8hVf9DtaqIovprHD6fL7zMt9OvrQ1h+mvcQlySEcNNz/cnVqhXtgaTxDzobm6gUXrliWfptgpB3haTEyUfnlj/gPPBJZv9YJbS9fUqNcvY2NKScv6OFSI4at0RG1pY0sjnKFZkxRpaGxeLq1fEmuE5TD4/YG9IdqCffjaDZaLhcYtEZFdu32+r409qiQquW/RkGHP9E/KuBCzmXW9b0n1wQp3oQaNwNzymlxl7cMkpN+mxLG9XU4vzpyiUour6l8n7zHhOwXyihtvAELYKJD9tyshIMTf352eTnMJ08QSyt7q6vw6fSNDe/IsvIVTnVkJJXQkjf6cX3if6wEmhZ6Tfg2c3xq5v8KY42m8wMTly5B85hyzOJURr/2u3GZeekazGEYtp26/ZagflWifs3MnwXMYawdz5O1vVdXll5mXExhK2mh4nxFs9Muoyh6MftjlCtzHvNCs04fSV7lJGthszUyPneHoLlVdw1uJgrY/+paauJFb4qTsxcStme8zdceKjZuUvi6pjXB4HImphOBHtKa7KiDd3WlYiyWqWi756QNQBm7MFnmce7mBzyNqZb78MemqQK496+5TWRl7JrGgr8RwcbG0MdiceOPkctRJ7cvCWhikvfxc3N9tovqKbDd8t2JLEqxRHZJTHh7ndNHRLxBGoyNTZPK46IyUmtVOJpicekgJKnrR48coK6EfZu0J0macrnl3uXhqLPcquzQwwSn9S9+/fugWCpY8fBwUfoqxtYrL/mdTD2BUxPFzPdYr7Ohy/4ynuQcEBbkbRoftq54yRnfo+KxcSfb8VjYN1o6p9XbPN7ejPuXx+Ql5t4IdG65vi87TC7Jq8traK9Pwb929cyD+cKfSsiPazLmYJnWsGx1qDPVuYBo8M7Y16citfPXWw2UPAOaR1rSTzins2Fa1Up2VRrV98sKO6M8LIWbb2Zle3V5kZGqY0z6rQzKcvH7/U2YVmji1y6SF7NVryXr9djPK3vZcVdkGYd8VTIMjnBKWmalEeOTy+jwvCP7TagydTyuJ+fUoNCI0me7to1mdQYorj7l7cbJlSr1f8/Mw9to83Ff8zPkzPCscxdTQnnh1XYQHKSbjYPZaXJ1hqzRcM1pxue51gRDTQir29dfPeUPc8gX5pi9HZ40Q/rqbt/R1B++l+5lq7g6wJj09ZsJwc9lnQ9RJ9GJdD1dIM+TVu8ftym69l6Rk6qBF0j2x1YR5MIGnkOBOwtjbTCRTFvYV0HNAt3/ShvimgKOrgqAjollN96LdOoCiOXSgkAt3y+2wmgaLY+HFsJ9AtJ0fQyDugKD5p/KsV6JYL2GykQFFMPZV1AeiWy72o9zNQFK9muAqBbvm9zAJQFO2N3dlAt8TKKBeAokixoWgC3fJTG5qeBIoi16K8HOiWfyuRUgYURWd8oRrQLd//haZXgaIoTGi5DXTL4V9RxzegKBJ8XMBu2YQaJoCiGG64Iga65UADkvQDRTH+96YgoFsOtGMbD6goFlnGAN1yYRRJJoCiKLbn0IBuuTqNlN+AomhpwEoEuqVCgkYXgKIYHCV0AbollqE7pEBRjCTGhgHdUqFCQ1KgKDrvtq0BuiVWZqQfKIraAVEMoFtiL21IARRFmn++J9QtR5BqHCiKPz565AR0y841NCMFiqIfq+Ak0C07h7BkAxTFkhdvDwPdEstpfQNAURRUpC8C3XJejhr6gaIYLCzeA3TL+RkkkQJF0ZwRmQt0yzcNSLQAFMXDTLQX6JYyCZJ/A4piTj5/C9AtpXLU0Q8VxdxCBtAtx7HvZh0oirmplmSgW/avIdU6UBRvlsVwgG45MIM6FEBRfKZjmgZ0y/4G1C4DiuIDXiwO6JYyLNkMAEWRczVeHeiWc3I0OgAUxd2JpklAt5S2owYZUBR5RBQNdEtZBxqSAUXxmId3GdAtFR1YvwGKYpA22xToljI5Ek0BRbFrk2sI0C2nRFgZoCiWz8YZAN0SK9P7GSiKbJvZOKBbfj/0egMUxcaAjWlAt3wvwtoaUBRbWgN1gW45j+2k3wFF0bw1+yegW3a2o+wFac/kwsTwsEL2ZvzrsGJgvX9+XvpOsb76bUL6TrYgG+8fmJxQ9EtlinGFYnx8tnny28Tq5OT7z8sL0s75ifW5hbm5yamp+anlpf+urs+9mZqcm//8Hrv99Gnp499Ln5Y/d0ofoQ6cZGRo+s+nHUMj7Q0dKlXT6MzIyIx4RaWalvT19iqVcrmkYVry/Y/FDuxSra2pXklEInkvNrr7hkZH2yUSUW9bb1+fSDmtVIrkcpGor0/eNyIXtYt6x5Qi7FnC0P8A/dsOJCneiGAAAAAASUVORK5CYII="
      },
      _b$1[StyleItemType.MODEL] = {
          entity: true,
          orientation: [0, 0, 0]
      },
      _b$1[StyleItemType.RIPPLE] = {
          entity: true,
          duration: 3,
          color: "rgba(255,0,0,1)",
          image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAVFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////8wXzyWAAAAHHRSTlMABAgMSRgTEDYxHDsgQCQsKERMUFhkcFxUYGxoc2Qx5gAASRpJREFUeNrsnGtz2jAQReuWvps+DBQI//9/FldjX6+PVqtSZhKMrmknIaT9cM5eyebxpqWlpWX16S634ai4DUfLOjJi//vF+P30zSzmR+mvbvrVJsR9xVAfj39N4j9a02rhXqI59rhfp4JqoTXCa8wcusjfOKqDpsDryggmRv+25qiqg7Y9eA1JHIQ+5F4ZqkANWhG8eGaDXwZ/fQIR3rQzhRdLcYNfw/0djliEVgWvJNXsCTyO8YEatCZ48aD2S+wD7LEKWQtaE7xQNPox+xj8x+mITaixoJ0dILfG7ww+yHu86wIl6i1o+JEbDz8HH+yruH9AakygBjkH2obghvGv54fsgbw21AESoAnQA21DcGMFOPqEr6GPub9fxDeBdUALuqUC7cnEW84+m5/wOfYF4nF8DSiBiqD1wO3TOfQFn/QD8FeLUJBADlCC9hTitcMf0ufgR+S/hAk8gAWBA+21BNeHCz/g5we/Dvs3c+huX4WSBIEDrQb+Y/g5+0qZ/YL3PN+/FYJO8C1gEdCB9kLDKzwIZ5/0HfTiKvjfMxnuLqgACdQExR6QAm1XWPmyHh9/Ffw8eYH++b0meQ1cCdgDgwJtN/CvKdHn7As+2BvwYm/yQzcTiOBa4C4GcqBdG6hK6sY6/M7ogz24T+DdSI2FCbAgXwRhDbQK8EL8pC/8DnygJ/T66HehASSwDrAG2magSD7EH9In/Bz4z7XJigAJ6AB7YFKgbQbi4Sd+v/oBn+wL4D99/pRNwQRYQAmy+4HWAtdNP7f9Af0sewO9OpQha0HgQHk30N5thLU/GH7Qx+iDfRb81zAQIWsBioAOsAZaC2D6ve7n8JO+B5/oif1pOJS/3yMZDRwJ4ABqoLWAP/zh9Gv4ffqGfZa8gP96QnB/1gNjgeeAagAtQAUe98WknQzwpp/DT/qED/QGcVWeciL4EtAB1oDfAo/bAfHaz+H36GfZk/vm759NIekhNCFrgeMAayDaCzzaVqDLX/PF9OeG36Nv2YP8mH7T98MfJ5vhNskwJm+B4wBrIN8CD35dQOOP6Xfxk74dfcMe5JVtIXoURDAWmCKAA1SALfCwW4GuuPXn9NvhJ33Cn6MH9eP2WMr2SBfmGlACOqAacFrg4bcC3PoXpp/DT/qCD/bEvivnuJtkSIEFkgAOmBqgAjgheLitgN7R/W/T79EnfKBfYD9cbn6Gny5NsBpQAt+BmhZ4vJ2A+GP6I/za9YH+NPhiPwd/mFE/lSMXUuYaqAuSBHDgxxAoUN0CK/8Ammj8iV/dr+EnfU2+2GvmLfX9aR/ktLcqSANZoCagA6oBrQROC+AtJat/qYj2/iF+Dr+q39IXfLEHeQE+R9FDrQeyQBLAAS0FrAEqwBJY76dQdSP//8RP+oJv2Qu8qD/P89scyvl5MkEeyAIrAR2oVkBbgccogS4dwt9h8Qd+db+pftIXfMvecv9dm1GFv5EFRgI6YJYCrQRU4OFKoMu91JvjH+MX/VT8Gn2xJ/oZ2PN+wDgAHPElhdK/Mfz6/jx7PDWQBSqCzSXGgUCBYB1Y5TUhjT/2/sD/XvjR/Wb2zejP4AP98/50gd5vatP3FxlO+8mESYOZBKYITA9gJZAC7wsKLM8IV3NNIBj/GD+GX/QJf2Q/kc+C751jmYsIgweygBLIAdZArIAtgbVeGQzGX4t/gN+lL/hifz7ttr2H3Ev+Qf12dzrLAkngOBArwK1AyvreTJZ92h+Lv4uf3W/oE/7E3iK9pgGWd44WUALrAFcCKeBsBXRR4K0EWM8bSILxx94P+Dn8Wfqp8w9bAxDEo/CRxoJDWhEcB1QD9Qp4TxKu5CWDnT/+bH/it91P+hb+bgtkIfbYheXX252VQA6oBrQSUAG7DrAE1vTsQIf55/iz/bX2C38a/rH6Sf98MPA98r90LKKfKNRJTXCmA7YGpID2ArmtAPeCKzkbmJZ/1H/c/sL/JPxm+EV/GP1jD/jkPoTc6YFsKO4O++Pp2ThgaiApoM0ASqCowErOBlD/wfgDv7ofwy/6hy3gA73DPTIhbITtwTiAGtBmAArQACmwmo+WsPWf4rd/gN9Wf6Kv4if8MvUnHKEH+J+0GAwOmKUgUiBeB+79bKB29bftr/N+B7/oc/Z7FD6hV0U6GA8ggRx4Ng7kFdB1AbMOoATWcEWg807+w/bX1n+JXyt/on+a6CsOfYs2Ym8ebsIlQWvBKTmg3cBSAZ0QROvA2AH3bID4B7s/tL+Hf+h+Df/+KAAB+xB7rEKdA8e9amBYCawCXAdQArgmcMefKrHc/uHKP8Yfi7/Bb4d/J+wWP9GT/NfwMHEtyKTfnVUDkQIoAV0Y1CWBO+2AP9yd6XYSQRCFD26JQY2BIAx5//d02OZS/XVVNcEJg4XbUaM/7lo1RJX/iH9X/s3wd8sUfCEH3Of913h+zkUE0CAlwbJrpoDKIE2gtIB7+qeFTvkfx78n/yr88v7tepGgD+xD3HMikAWWA9wQ11slQYUCjgk4ReA+Y8CJf9q/5I/wB/y7pW/TgP6LgT5BPqfB4ZuSBbEPbJQEogDboGkCjIHD3NlNCPW/Wf5yf8JP7yf61vAj6B+jl8sCuUHOgYWSABRQDngmgCJwb28Ugv6Ffyj/BP5Fgv4LXL+K+2P/NR6XCuSAhoUwpEBgAowBecAdPBlI6n8of4U/4F878MP4iXwL7uTAQARywIRBZTdUGQAFVAVCExAD7mwZOPIT+qf95/IH/EAf2hf6UP17Z+7QwMkCO5YCrSbAbeCuPn0M+vfj38of7t/vUQn80j7BT1X/Ha+MBmZsGFgbIAV2S6FygCbgMIAeMPnHw8Jf2z/iX/Zv5U/3t/ATfRk/le+DvpvDdxzDBhIBJIAPVCmAHChNQDHAInCYye8CM+R/HP/a/a38bfh3rvod9APkCbrHATEBDAg44LaBzlYBawK6CfwPRcCr/779S/5y/wH+VaB+D/05oW9GnkwgDWgEaIQMgtVAAeWATMCLAcuAyf970zb9nfon+w/lv4f/bemo3+x7vvQJ/TU0IAe4GPgcWL7tKOCYAGNAReBuPGDm6B/xH8tf4b/dAP1Q/AS/Os/nr/PRz/pEIAnEAiaBnc1WVcA3ARaBu/AAnP8N/oh/tT/Jv3T/NdVvmx9iP8b+hPj3AnP9gGwISEAO5C6wLnJAJqAuaGLgrjwA5z8Hf9g/5K/wp/p56svRH8T+XfDHMzBFLIiMQBO4gKoATAAxsGfA3XkA13/ir+NPIf+l5L8Lf7g/4K+Kv4p9gnrOBJ8EWgzUBuACeEp0ZgJLawLDUejuPGBm85/rP+Nf+EP+60z9Qp+Nz4IfwH/6X2E0LgnEAnAAUUAK2FnDBCwDFANYB6fqASoAzH/Uf9i/lT/dH/DXxQ/l17An5PaLxrcCcoBrASiAHDAmwBjAMqCng728JscABYD0b/Fn/ZP9W/lvN4H5K/qFPmO/qnlBfnhpLCGKX675gV0Q623Ap0BP71eZALogqqAYgB4wnfcIefc/p/7B/iF/4Z+bvzV+D3rBmg4+wCGBWIA2oDKAOggTQAygCtIDpmQBM0f/cf2T/UP+cP8Q/f6Fxkfsq/OrGNcS9oMdIUgCdQFtBDgKyAQUA2kVnOR7hKh/4m/q394hjf3X5c+9n+J3jb+OfQG5+RKQgSRgGFgKsAtYDziagImBw1FIVZAMkAdM6D1CTfpX/NP+T+X/tRr+L0X3o/iJfgV7YX56afRr5S+CBSCBsxQUhwFWATUBxACqYOABk/jnhTP9s/7R/vvdH/Jn9Xdqv/F9gC/kJfN0DA98Eny3PsAcKKuAcYH+JoAYIAM8D5jIOYD6D/BX/MP+15B/NfxR++1NXxgB+/eNPrYgASiA/6zIrQJaB9aIARWBxAOm82lj0H+Gv+Jf9r81z/2s+3PxE/6CHui70P9Ix2UBOIA6oIfHc9TBigkst4oBFQExIPaACSyDl+p/PuCv449tf1z9BL/QN+In+kfYPOB/xS+HCCKBOGAYgDKANkgT2HfB4SgkBsxDBkzoEwfb9V/Uv3P7fw12Px//5wB9G/cGdwHMsQwhDWpGYGwAlwEFgdMETAyoCqYMmMg9oP+Lw/uP8Gf9k/2H8if6FL+MXygBe0xOA31c5APC32UATYAnAVRBMoA3wVulAD/9sxn/Mv5Xi1z+wF/o+4cdH/qncEgEhwXggOMCx/FvAm+2CLQz4OZPBWwAXI4/nvwJfnY/oA/4jevT7QXx7nX6jq/TwA3AAUMBloHHmALaBjoVgWYGKAQ+/CTI//fp04X4M/4pf4S/8Gfy16QP6AWwN/h9pEE/5EA/4ADvAroJ4OnAq4rAhQy40acNzq7Rv+rfdpnIX+EP9TvaB/aC9OLRh5UkKKKAbeA0kQnYfVBV8J0ecAMHuFD/tv5vtzr+Yfdn+FP9z4LfQf8E4nVDEvwqfcBzAVUBmYBuAiwCZhm42AM+sgeiAer9fxn+qv8dj3+S/5n9B+on+jn4X9PxWVByQEMXiE2AXbDTMpAx4AEe8PEXQeGP93+m+LP+VZc/hH+pfsEv9AV+if4Ab/byiGCcgFlAF4AJsAngIpAxACfB26wC3AAvwh/1D/YP+VfV76NvxgIfD39rQYEf4IDrAo4JuDHwejkD9nODa4C9ABP/Jwd/rX8bxn81/XX289Rv0Jf0hX0IfE4EsAAcwNsIGARaB+QC3AY2WgcbGXCri6A2QBTADH/Vf8U/nvxJ/jr7ueq36FfAv2r0Z5QcAAV+wwVCE+jHWQYCBvR/b1QEx+UAT4Cf3of/2yKyf8r/OIX65f1EP8b+W/DKSUAOmCTwqkBTDCzeyYBP414DSILwAHA5/lb9sfwhfqDvgH+O8jdnwASQABywNvDboYBnAuVVcPEWMyBZBj8CfhbAq/FH+6f8sfhJ/Ah9F/sBZU/+pALmZATiQOAC3AjVA0wR0CxW7QzgKjD+NWAmA0ABbMB/6+Jvwh/yh/ohfqAP6IFybAP6sWcEsgG6QGwC4UWgZ8C2gQEogqO3ABZALgA5/qtFJP+5I3+qn+Kn8cvthWgOP3hQMYMn2IDnAjgM6t1CqoJ2GehiBnAV+MBrwMwtADoAxPij/r8o/nX61+VP7k/1W/ET/MHtw8ntIOfAD7gAqoDbBV9+likQMkDLIJ4Nj14DZrgAVhcA8/zH4t+1xz/lD/VH6EvM14+oRA54LkATIANUBNo9QOcAtwhiRmqAfgFsxJ/xzwc/mfoJ/5lm3XlwJ8uGgQOqA3ABUsBfCLkMkAHm2SCXQdaAMYtgewG8DP9+WuRP9Vv0h9ROcM8nzgMNKOCaQD/qASoC7QxgERy/BlD/7QVQz/8P+x/xD+2f8FP9FD/RJ/LX8UAcQBLkFLjAA47boN4fkBfBcT9ZZBZfgHL8V034U/4+/ESf4D/8gyEFwAGHAmMygDVgtLcHiQMIgGgBaMffxP/zkQGQP+BH7gP8fzeBD5ACMAFuAzkDVoYBXAWCGjAG/Eb/bgEo8dfz3zfg78V/JH/AD/G3gf/ZmYQErRTITeDRMmDuMWBVZUBeA9QDRzgBRAXAHgA2mwH/2v1nvmfAo4s/3d9Tv4W/AfcH55UyARyoUgA54MeA7wGLtxMDNhuzDOZFUOCPeAIOCkCOP/Nf8AN/U/0Bf4vvG9iFM+dh+E0+D3g2BgW0EwYM4FsEcgYENYDPBcdKAL8AcAHsuh3+27r+59K/4h/2D/d/8r3fwV6oto8+Ig0DSwHmAGOg1QO2OwZ0HZZB1IDxQ2BWDwBcALUACP8/y2b9U/50f8GfoZ9An09AgvJQyHeVpiagg4DjAYvln4IBZQ14+qAQmBUB8BkGgAJ4OADp/V/Qv7f+BfLP4Sf4mmtZkFKAOYAi0OwBepfYcBBCEcQuiIPgyAHAAsAFsD8Avrr6D+uf4M/VH4M/HgkyCpiNEAzQNuD3gNf9SZCrgF8DRsiAw58UFgAUQB0A1qH+tf+n8g/gJ/rhfHKngQRtFEhMQFUw84C1zgEogkkNmI31LmCdAL/2wwJgFoCuTf/n/36rHvs78hf8QD+SvmD2XikTaj5Qp4AxAT0l3uPvMmBeeTbYaRVADdAuqLcH9RCN0ANnkQEQ/6UWwOL5P/V/HNo/5U/1N2q/CrzG/dXEB0iByAQYA4EHfNH8Je5cdJsKYiDK3pYWQXm2UVLy//+JKhSNlpPJ+Lo3ZEEgJEAC22dmvBs4hUEYwSQCY0sPmA0ADKACYJ5/8B/jr/qb8pvZn2s7V3z+qhO7gC3AUEgIUAW+BwYoDNII+m3AWK7QAVgBKQEaA6AAiPnP9ffjrzNXPxR/1WEb5B5A/QGBNgPewqCxAcqCzgWMayYAbwAYAOL80/7Z8Wf5WX3Uvnt8EzyiBTwEYAXXdMDhFAUOhxuJwOwAKQDGAOxX1//HJP8af0w/ht8X//Td1k1ADNAKvEEARuDH6g7YGxsQRGALAAwDACbAkwHQBnC3uv7a/XP8Mf1G+UPx20c9EFrAQ0BrQbMU/OQ6YHfaCMoGIAsCAVtpwAgAoAGAAdTHv/ThH1v/PP6e/SpUPn0QUAnqELjYAXgrLCMIG9AVgX4CqAnA4QADiAcAn3L9ufsplL+q+sOeJZ3UAoQAjUBmgKIAjODhUBWBvAvovwLQCmhKgLMBYADQ/V9x/k+nMv2F2Ved3Rc2Qu4BtsCp/u9iwNcZAS+TDVAWDCIgBlxZAJIBwP2frz+efD5g/Fn+UH3UPXy50AaSGbQAdMBAAB2AV2LRBkgEAgLGxpcAugSmAHgDoAVArj/ln+X/x/ipLsXam3O2DyIG1ALntgKAQKMDYAMoAroY5qXQRgQAAKwAyADkAODn/zPwj/GPw/9vUcun0gTCgI6RAcsA7QRTGJQNoAhsjwDWvyYAMgDU/1x/yL9WP778dvinOrLA5qvvgkoLPJoWiAzgOkBRgNuALALbIGAYB5AF4AgDkOv/dHn+100/ZlhVDwc/K/aAawGpwIMJA6EDYAOOUQQaCGgDYF4BzQkQBgABgPX/pvk/QVP2T+PP6ffVn+vYOGwC+kFSwDiBtz+WGPCt0QG/lAUhAldDAB1AFoAXFwBK8y/7p/pj/DH9rP4WpV/068EBUIBWgHmwwADeDOp9UBQBRsE+AkYAgBWAnTUAXv+n+XfyP5f/fPW3Kz7pAQ7ACwgC3ghkH+BtwM6IwLYIYAJQBAQAkACQAGEAnP+j/PvxPzf9KlDvZGMguJACDgI0Aj4LZBH4zSRABDw6BPR3AN4BUgAO3fpz/v3439nhT2bvQ+GrPx4DAQKzCjx1O+AAEYAPDAhoE8CvACgAOQDk+ff4X9YPfygufnJQA2CAVoBGIDDA3gokEaAPtAjovwPKDpAC4A3A+vmf934yACj/Uijo5ZcPH9gvvgVoBRAIAwP0PsDbAIhA3QcCAf2PAnkHeH+PBKArwGgAOf95/Dn93vOx8sN90QfrC6ZQQgAdgAzICZIB2Qj6JHB/Lx+4PQLgAIwDNAJwXzMAnH/Ff9k/X39VItd+VL7o/9+5QILlghBc6oAHMqBiA5wIyAfmKNg3AAQAHaDuAJIByPP/APw/ovyAfyr+aHyJKCAF7pAHZiNQZIBsgLYB9z+ndZDxgUAANKCeATIATg5Qz8D1CMAKQJh/CYDBP6a/UXxzzE+VKShQ4A4QmIxAZkAWgf3pmbh8oEcAjE/1eAfw5AFw9PWvz7+tP8Yf1g/Vn7gepkBTwh6IFIAX7DMgd8CxgYCxmQNgBJQD1CVwSIAIgNJ/2H+NP+lfn32UGF8vwkCOwNlBeMEKA6YokGyAPjUuH4goaBCA/u85AERAXQLNO+AGAP4eO///ZD9texZTfTf5Xg/ZCugBywBSYAkMSDYg+EBdCiEKAgFNCUgAUATkJWAyAKy/8j/nn6tfWf+A/nG+8oPfFmwBMTDfFZk08GgWArABuQPgAxUFMwJa9c8AUATctwzAkwwA/R/wD/qH6rP2UgPzLUFADDAVGgiAAdoJfl5pA+ADFQWLCBhr6l8EAHeAGQD1+Uf94/hPxQLw49/B4F8De0DbRb4wYhogA+zVIGyAF4FpHxgQ0CPAiWsAAHZA2gF2AJDmn/Kv8Q/lHxR3/cCYQNBBP1+/NSMhZABpgAyQD2iIwIE+kAjg06DxDgfAJTAiYMMAIACo/pB/4t+nPgAgHicREALx8UOQgbvMgIYIhCjoEVA+o+IAGAEDAKIBvDD/OifWRvijlBp02xPDGgTRAF4gpAHDgGAEgQD94zF6I9xAQPkkAHAH9AoAGAGAAYzzr+PxjxUuatsAABRhzKFAELAy4BkAETA2wCHgdTUCRmMLGAGgCIgVQBAAbQCD/lP+l4L4S+Z7KuAUZK6/wUCVATKCUQS+fvFRMCNgFQHG1QBAAWAA4Pzz5sfXPxW13wbqqnm/PLAVmGTgjgzgOoA2IPjAHgLwNxQJgFuAAIAkADkAuPmX/KfyBwS0moDhQBBwewHDACAARjCKQEYAbwQaEqAMiB0AAGB2QJ8sALAB9vOf5Z/enwPfP4wDsgKKAxSBEgNgBA0Czj8P2wMB2AV0roQGMuBGAPAbgIfS/MfxBwK2aAW6QMQBc0ucGVAVgT4CmATHygzgloAJAEUBOJ3q/C+o/zbuv+4dqALnIFBlQEUEAgLyOhAEaCyB+BCoCYC8Abjz8+/Lz/JsKQODruLt2OcCi2MAEcAsmBFgEDC9C+jug9kAzIAZAF++lh0gDcCjnf+M/9FwAS0UYDmMMEAGWBtQ94FFBHyzCHj3NVAfAF4AzPwj/nP+VX4awO3LTwSoB9xeEFvhog1oICAkwbGIAFcFgOofE8CF+b+rzL++zEW6/pEhtHvBBR1gbIC/FeohIC6DxoqnYD0AQAAaAAjzD/kfjOqb15zBAl6QDMg2oCgCXz41EUANyCGQCqAMiIdAr1UAZAOAAID5J/6F5Fbs63sBJMLAAGsDKAJ1BLziaZCSIGxgUQPWAGB3bACACYAGMM0/H3wBBOF0wc+XIm0GTAvBv6eDgN0aBOSn0aYB7BJoFwAQBEAA0AYgz/8EgPreZ/s4MAoMkAuQDYgI+FZEwM4tg7oaULSAegn4DAAEBygB8AYgzj/0Pxb/KiYwIQBpMNiA5AOJgGe9DizZwPwobqUFPDYBUN4AeP03gnzNgxjIdyJkQLQBH9+DgONqGzgqGQAW0GXAwwoAPBkAeAOY9R8u8H8d3BF7Blgb4JcBdQQcmASNDRQ+IwHqAPi9FgDTBmB+BMQFwOD8357+E3pUfs+AyQieTwJ8G1JHwO8yAjIBxoe1FnD/fgBwBSj8e/2nASScebZPgnSC62zA+xGwX28DRwKAFAAWUB8G2e20BFoJADoAGoC4/r3B8HsvwCzgl8I2CTQQoCT4IgRMNnCdBqy1gK9bAoACkPzfuG0TgD1nEbBAAxwCPhsEhF3A6zoNqGcAbgFhAZ/zNeCZCOgAMCdA//bTW7HrH7KfK6FzDIAICAFIAusQ8OsZNhDbQLwOrmUALQH0FAwWkNeAEQBmBQABGEvQ/9sNPj88AB+AMKgWAALe/HB8GMBLQSZBPg3TwyBpQDMD0AK+VBSAOyAAgAJQy3/9m59rLAXTTtAlgYCAaAN/vdAGZg2oZwBuAZ/ftoC0gH0AIAEk/zdurv3WDfooABHoIMDbQG4DqQEgAAFABfAWcBcAEBwAd4A0gNT/m+9//nB3BrtRxEAQxQsLCOWSJaNskv//T5BgZTlvK9XdM1I8Y3HgxCWm6lV1eyJ+9K3/wbIoMGAzCeBAgBhID9CP43IOcC0JgOkACQD0/0/PgEYC8GbghBvw/2wjAdekBzStAN4BiIB1AugdIDtgk//bPD99PiTtL4i/fFwGbCABbAO9B6iTdIAXWQKlBcAbAPL/FEGAd4EcQBPAXDgoAUyCrAK8B1AB+CCIDoBVIAyC+2OgJAGwApAAeDufb//wgOHv8gaAAzeSgN9cDKIHeAhoOQfwj0GqBKANoE3l/uyBdB1wemcCUQrQF+Cx7gEtjAB0AM6BgIDrCMAEgFlqoOE0UQdwKlSSAI+Bz8YDAAEWAXwGuMQRsEYADACTNQC4A8AA3oAIBVTKIJ8DUAauzABvzAAaATkGJAEMSyBwgNmyn/ECORhyEsChIDHQ1MHlHNBKDvCYdwDbAegA0PFvrmvQRBLASMhQALcDt/cArQAIgXQAZoAaAmoC6Ag4/Pf//AWAWBTAsmiOAr5jMSSdA+gBDIIZBOA2MFqgEgLqKdBHBDBRBRTBQUbBDyngnMVA5ADOAwgBVACPANYBWAJQAPqPf9gDGAng1Oj/8/649U+/O5enACiAlQDvAQYCCggABwgjoF8E0msgPf9PLwGAE4CgoIAfYjWIGBj3AA8BQgEYArkLtCxpB3jAKrD5+VMA5qeAIaT2NAAKcBJQ94BlwV4QgqBTgKADLHCAAgLiY+DYA2EAaBP/+OkDNIGG1SBIQLENXKwHEALqNeC14ABEwPdvAe4lgNkCnw0Cw3W9qwGMgqgCCh5wLZaBRAAfAvsukHcAiYAUABLA7f//bv77w584Ehg8gEEQbaD1gL4XZIIgIAAKEA6Bb1s6gCbAvUkAPyUzmgApgFVAPQe8ZYLgSgR4dg7gW0BmQJUAdycB/SAJkAI4EDAYCA/IBkGvAB4BGAK9AwQegzQiwLSpTx821kwCt6PbQOsBDIIWArwCkAG5CxIPgWMGVAhIAuAM4NP3v0t7QUgC2gO+sgqAB4SCILdCPAUyBCgEYAist0AsAdgBzPD2a60A3N0NafCAeg5AEBQQQAqsI8BT3gH0YwCRAW8ZauIVgMyKoLwBCgN/5T3gKQEBGyFA3QGIgPc7wCmHv/Y0bgbIJKgnQt4DyhDgFUC3ANgG3NAB+POfcg3QHGArKYAL4lAA7wEaAtgEeAUAAmAQcGsB+osgIEAiA0RawNkeAZR0QFBANQd4COhNQB8HEAKoAKyBsi2Ab4HOpgUcCWCK91/r18MoAcYDfBcUbAJ8FUQEIAMWEcC3QN4B9qX8/qEIFcB7QAoC6lWQYcBxEKAQwM4BTAaAAUy7Apj9RTMfeYD6lWL0AA8BwzjAUGA0BIy7AMM+cL0GpAOwBZ7w8de6JWHtAZSAdBnYxwHDTkA0BqRqoBcgQDYEegfYxR54Zj5MC0AXxDIwDQEviSrIhwBZA1UQgJNgZoDx5z/rK6DsAQaqHIAYEIUAXwXZGJBjwDwCuGVALAJN8g2wDRrhJpMgKBASYCBgLQX20yoM+A0XQIdA7wBkgF2ynxkLR+cBLghyJ6BAgVSAwCiwM2AKAfgikBngcAQwuBg8gDnAtMFhCvQDQa8A6AHBgIUWgClQZoADGD+igPEAQEC8CSAFogt0MaDIgHSA+iSQCLDPAgAHQUBDICTAQMA6ChQhwDNg/AL4HrjfgCMKQMO3g6JNQPECXDwFip0QEQLuzYIvCAERBGAPrDPA/ltgsxqIb4gXmwBS4OXORFjFgGIR/AoGTCCAbgFup5vTES4BoqB4JWieByQo8LUUA1qiCF5SDPigBgFUgFEADhcDtQeI3yR0U4CHFAUuiTLYKACXAWwI8DWQbwH29Bo4igFiMQgj4SgE2BjwFIsBUID+KEhPAp62ZMDeAhy6BBpg23jAdjGA04C//zByIBTApcBrpgfUuwBjChzO3B+DqmOAbgKEApAC/QW4mhwIBcAoCCmwFgIoAHIdENvAu10CCEOAXwo5BymQLwR1DuQ4CD2QSIGcBDAEaAb8xRqQL4IOigADB2gKPBkKtDGA0wCdA9kENdYAIgWaSQAWgtEDRhmw7eQdUO7g5+8pkKvBfhogciCKACiAfxUmUmCdAdkCHFIAMA5YT4E6B/r3YVSASA0gU+DPUgrULcCungLGTrNNgKJAEwNUDhRFgFCAzCzwuRoCzrEe8KjijyYgqADpGPCcmQfqC6BrgGII+HdsD3iAbXD31SChAPnd8FIRwAtQrwEyIYApQM+CD5j/MA4wCtA1wMSAahFQvwCXRApkCOAyCBXgOB0QXwtqBTjhcQB2QmI58FK+ALEeKJUCfQggAuz0LVjscC9MrgScqznQNkG8AG1dD7RpCNjbR6ESCGi6wNQ4CBawrgnCBTDbANUawIeAnX4UJHoLfBdYLwL8RgB3glYXgdvXAG2vb8HNaa4LXFEE1KvA24l/G2LZpgbQIWDmz0GvvwNeAdYXAUv+KxGJfaCXzAUI1wBH3Qb5w9617bYNxbDIDZqlCJAtfdnl//9zCDZAKAiZss4lts7xF6SwSlMUJQIAMAR4qzAQ/sU9QYgAvAAMP1BsJ8DmAAlloLUl4aV4QdD2BLlMYXwUgEqwXwi8eREgfRNgWQIwTxoChKgSxLVgjgDFowCOALYOKMsAMoBaAogWSM5EBAvgHuIA3BHIEYC7AWSRAZoANg14M+aBwAGCw4AgAmAB/NyKANgE4CdgGaEJEBQC/I6A+DAAC4BzAD4L4hyAywADWML9CMA9QeXTIIIAYAoni4HxUQBaQkdoAhQECAJEhwFkPdAwhm8eBn6SWRARAgkHOFw8RFQKjHuC+DTok44DEQGaFoAtBGIFZG0Cnk+UAzQsAAnYAeoNA4cyhOkfRRCgfBz4eFUBXLcOAycHCCPA9Q4I8PoCuE8O0I8DHK4AJgcIc4B9FUBFQ9BoOkAvDnDeZQE4OUDezfB/T0ME2HkBTAR4FnWIA+QoAD8HyA0Ah0eAx0SAEgiYOsDQOsDpdPwuYOoA+9ABrjssgDkLOKwOcNrZNDDn66+qA6AfoGAaKFsKYHKAPcwCak0D2xhCJgdoxwG4IeS8wRBiXIipcx6ALwdPDkAQoLklTGKmUP9ewNQBvBzgbZ0D3OqaQhEB4rZwvhewlQOkPBEiRAcwlgPLbsRwV3CLxRB+KnxQBNDlMH3/iACwGlRhMyiKAN9rbQZhZJy9F5C1ExRAALobqLdCPxqthkloOTTOAfh6eDroJxyQbAcrByxdDiUI0HI9XEvAWA4d5Fa8rF+KfMl6uPQ4EGEjwEhCgPc+wKXrgYhTlxMxPDVUljGkQCEIQJTg+idipOORKESA4S7FAgIYiQGQH9zkSBQiQHlcgBcBsBHMfSpW//+rIkB5YIB0PBTpzQvJeSrW1IEUAIK7oX5T8K3/qdgbHgjQElgGWxAXQwcEEqgIEIkMedQ4FVt3GvShUuC7LzUwoRqsva2sdYEXEhrU/Fg0jgPLb8RY34ARUgP17W9yBAIC9DoX7x8G/AheiuQIkPROEPMEIwL0DIx4TWQMIIB+A7LEh9NZoHEpVkugZWSM/r6uoVGIAMm/AYIqECJAuQyAQqA/M6hxbBwiAGiBXyogX2qksMyoerFxvyO3opsHR6ojgGuBebUg8v6BA9BZYFwHQgTwR8eGXIH2PBCTQ5MRAG1q3bNA9QO1iY4FBOgQHv3uYYFaAXnMoQIIsCUvpFl4NCBA7/h4Ozs2XWqUJkaZjtDO8fHYBbqFAPUEnVkbwPvANSUgVycIOjAgQHAxELvAkAzgj4zAPtA7DcCD4c9fkj04TFajg20OyFMD7S4Q/UDBAuCOAM4CgQT4lYBEzaCVGlklN5S6AXgBoBKEfSDOA3kb8HygDTBYYNrwUAAAEwEu7sAgch2CdIEgAxieILoe6GeBNgIk94QIAABBgGBkGFkMJDKAIgDpA0kb4DMFueNjJdlHAAAAKUClJoB3gYgApW0A1wL9vkA55RkIiikD26NArgOWNwGIAM5x0B8yDTCs4Ww/bMnJAmU1MnCNAvjjYsAS/L8JOPuaAH8bgNMAqgUGlQCVAjJwATFFIKQAfgT4xoODeRNg9IEtWKBCgK0E5BsJi50X14ACcA6ICFDIAstJACKAkoAM5kBR/occoD4FiHPA01oBAAssIwGoBNj5gYdOEgcAAAZQlwIgBzQLAL8AbjHYzQLdywF2H3DoJaG/3J3bbttADETFWHEvaIrGkeHY/v//LAIjYIRjaijKsqUYLdCXXtLdPZwZcjfGW+HDJlAMg6Q1YD4IrqvAkgjwdkDsA8iAb1EGUAAQA2EYpCABJmnAogrMiwCGgcM+YP33hN3HqALATmCqAlQ1oCaAUoGHtnA9CO0ARYBVR4GGvUAXGF8L3RbHwQ5CA/oGyKlAZoHdER3hQjsg9gE0AqsOhCyuAE+4E1S7GM5e8LFDDpgxAY3lX4k4tbIdoBHwYwMf8L2+j7T5r3QJoATknSAtAU75tyGQtJhQgTURwMHAfA1YbxHodbKCCwGQAJCAN5AAygSUVWAnRYAOA/Vk4NqLgAEA2gNcPkUT2CkNqAmgo6C8CKAP0P0AysBVfjd5DILpAgAAUAJqCZCMgZwAtAGiIQgRkK8B9AFBPwBWcGUz4oYsKKgAwRvRyRgwkgCqFRiagKYgAlgDSj5Aq4AVXhfFKFiSAM+VGLAuAYoNwUPWCOooIPYB1qwzD7JeG9swDEoT+EN4gJwJPEySALQBFAGeBJyjmQDWgBwCnABEwKoS4WwByEsAACCaBTh7CgAJoAlgTV8FQgT02wG7lAiQdwQ5GfZk9h1eizCef6MHDF4ITlUA3grsNQIgAVwDggC0AVoEvNd8AKMApoGMA1elApxSUQYMC8gQgBJQV4B3KQFoAuoiYF+oAXIuiFvAJYCtYg/4XuWFYF0BLp9qBdhPkQC0AWwH+EzAGCPIl+NlGkgGrGo2xNAKrikAVgBtAn0WAI0AbQIaVQNehRFkP0APB9MJEgGreULcQYVBMHjAMAXM9wFoAvUsAAhAEZA1gvUakEgDiYA1ZsJYf90G2BY9gDaBlAAEV94IihqQjwICFUAGrCAS/nr6cf6z4+AAQL4C5E0gjhBEgDCCqAECAbU0kG8GLfj9KFBKWwBMAigAiAogTSA1YL4doGqAloFRGqhVwBcZsPy7Ir45BQA2QwDQEpAVoG4CqQIpAtgRPLcjo4AIAUoFWLOKd6McAeA/1p8KsN4I9BgQnUBKAEkAioC4BuxEDVBpYJwFDEwGLNQOmJgDFMOgIgXUFWC3iyqAGAcEAmapAUwD006QO2DZT0hdtmbsAI0KUKSAc1SA6L9uXA04tVUZqFWAXd8BS1YA/o8TFUAAoCQB21O2AggAyBrQCh8wAQGJHfDxWd7LESZ6gLAAAAAUQB4A9ABtogJEKhBGcLAGHBEFiDSwqgI4IWiLC4YNq99YDQBaAjIEOKICZEwgP1aqAa+oAVUVAATACy4uETJMrMXnHwAQCmDGCiCMYNIHvOs0MKsCWATiQGiJmbCjKYwAywDQFeA96wE0AUbVgP1NEcDvIxXmQbagRMhgAPT61xRADID9qApg8deS9AFv3WU42KOAOgIuHxYBMsAWOB2CVEKuPweB6gDwWaBLJzhdAQa2wLga0MEJFhEgwgAIQVteY8DU+jMDvJUC6MoVgF9EWAPYE2YcPB0BvSJwDQGLej7I/AfqPxIgdIGKAOAG2J2vdIJFBRAigDUAc0GIAioIcB2onQADoUU9KW7SALIAiDkAAECFAD4LFFcAEkCHgToKmI6ATVIGYFD4Qa6QMoTrzwLAy0DeBiwDgBJQVID4Y6gBn/0AzgV1h30sA4kANAWBAGEFsQMeJgC4+MYJAAKAFgAA0AogloDHjrNA3gcQMaCWgb0agI4QZKBAAAaEIy8YMoCRwJ0hwD0Q8x8CoAgASkD2gXoV4CoAxPKPrQGntoYAPBumZADN4CPfEbQr1UfyX0cAFQC0p3QFAACUD4ijAKSBJQRsMSIOKyCqwL0hwD3A8y8VIK8Db+sA2H1JAYMQAB6g4ANiBJwFAsR46HOIAL0DHtAWhPewhP6DALwpAM55AJAAugZ4FICOkDvBHAL4ZIzHQWgMIw4QXuDexYDZX6z/LCgAAABGgRUA3AMyBfQQQFcAIkDLQDYEiggQRYDLTwbckf2GR+Cl/+P68ypAHQD7ggSUIiBfA/yicJwFBDvgt9CBvgVkKmz37BByw+XPfw8AcAC8C6BDwIsHzFcAqCfREw7TQIRBSgXEV0UZB2kZAALMXQH4t9jnT33+2QOQAPgnAcBJkCgFRAqkPuNkoEBAVATiu4KUAREDnAKPcwNc/7wD5FUAfIvICAAeAhUkoPx6UjIQYZBUAToMoAxwBighYDPwn6cf0V+8+jH/6QCw/goADIFSEtCSe/rTvG6mIuBnGQEbyQAgYE4I0AMq+w/+MwL028CiC1QGAEMAMCDnAxQCVFOQO4BekDIgz4B5EcB+kzkvsf44/wAABECw/rCAWQCUKwB9QN8JTkUAvaC2AmSAbgzMAQFj9CvPvxAAdAB/oQALAOh7QFaASU6wiIBfQwigE9AM4BaY7zlJCx7/wukX558OQGWANQBoCai/3D4Cttec4K0QQBkAK+AM0FKQGU1zP/evz78SAHUAXPOAWwAguQU0Al6GECDDgL9wAoEV2GgGOACIALsd+PtTSP6XTjj/27wDyADgpQoAXQOmIyBOhAc6w3SDAxBwKUgA2LQ9MNL8p8//c+85EEYA3ACvIwDgHhDjwHkAKCeIOLBaBD6OQ0YH+EfWgekUsAABWH3sAH3+XQAUCgBCQOEBCwQQYZBAAHVgvAP4dBR1QEIJBO2hiRTg7zIcf1H+cf4hANADEApQA4AhENc/HwXUEaCdwJ9ACEIHjIKAYc3tFqmfL79YfXsKzz8FgHYAdQAoCagbQlkE9OcCRhQBwQDogCcznQoJiFeefPc/R4l/ff6ZAFQU4NvHy8BZABQI0IxGwLmHgFdugFgGCAagOZiHQGOFox8hQMOf7Z/4/AsHKJoA7bmkAPKfFAJeegjoBAKUDCADfAeQAnIPEACqbexLnh/84RYYc/4jAfArBoDfBx4NgPx5MMjATBx4+s/buS0pFUNBVC0LBXUYGBWU//9PS2OmDYs+HXKIwdIHLV/6srt3gh57hgBjgDaCwQOQBKMLCMWcBSz4vPdJ7u/1X+HfFPhdAAj46ylwWALmlyB5BngL0I2AtkF/z6gFZA8QA/omAcEXpPzBV/9B/aBA1r/+Y1ATAHIC1A5ItwDGAMI1QGRAtoBYBdkEfBWgBzgKiAGZAng5miKApE/wvfo9+t7/cwDIFbDPAAbyb78F6H1oZECuAvQAPwYCB9o8wMec/Jn5n/h7DtD+qX//CjQHAFbAewxgIAUmC2AVtEOAMeDZVgHjATEKcjdkXw8TfYe9Pln+NADqPxcA4e8GwAsSYDSAgH6yAN4I5CqYYwBvBbwHkAPZBQAhvtDhOmBCnyQg/Hb/hzcAdw8AUwGdARD/9RbAbRByYGAAYkDyAI4BoB84AD9o45+g70VfDET6T/oPAYD6ZwKEATwtGQDPuAXsYAHMgYcyBHoZgHWAZYBOcIHIggZ/+2d4yAFv/0H/NgBshT9eASgBwgDcNaBo/nALUBV0OfCTiQFmHUAPoAlkF8gcyJ8e5Gn+tH/qv8if+u8zgG9tBcQOKCaA9RaghbCqoPaBeQiEdQAZwByQXWCcBR78rH7YP/q/XwDEAKBvA7cVUEtgGMC7jH++EoIFoApiH6g7ATsE9qoC8AAGARRCukBmQOZBP/BZ/h9g//Ws0f/xJwdANoBhBtACfBUMy4CuKtDgH8YAOSAbmHwM/I38af9mAYgCoAAQBgAq4DoDIPo+BbAKagic3RAwG8HsAeyDNg2at8PtD3/e8M/ytkdvfuj+HP9e/8Q/G4AGABJgMoDHpACfA80QMAwY8ADOAXJANMgoZ7jznS/df1z/2/sGgE+AKwyADIAFIAeaIRBjQJ8HeBNwNrBqDqS7nvqx+BP+rP8cAO0AYALMBjCeAnIO9E0gM4BdgAygCeA0QGWwCblX/hL6DfzCX/UP+n+KBYAE+KoBEBNgXgJm8JECTA7UpZDWQdgGpDL4dMsDKgXEgIYCixxYkQkpfaAf3B/4Q/8Jfz8AdAnEBLjeAEgCXwXtELi8jzGADJAH4IFAQwEduAB9YC0FhL1Hv81+Qf5Z/34AXNwAyDugOSnAD4GTjQE9OUAmsAljAC4QZ0E+THxAH83Pyd/v/6L+if/JDoCpBiALyENAdwIvsIBuBjAIBArABwwL8Iwk+T6kD/En+Kn/gH9lAAPA8UV3AF0DABVg2AFQBeMQYBf06wDvAWTAAAXAAP3KH/gAe45+ws/yT/1n/2cAcAOAFfBRFcCkgDQEahdkDAADggdkE2ArzDTop8Ai+tfw35T/Juv/twwa/JcaYBgAOQGMewCroBkC6oJ5J0wPGDMB2gCPk3gQvrX+LP8N1A/8YwBgA+QAQAKkAYzDH3IghwBjwMEwwHhANAHPAZDAnIT7w+Cn/Kn/RfwZADAAJiQAOED3EFiKAYdBD1AboAuAAvUz5bz+9USf2Z8GcKf+fQCIAwAGsDoF2H1gGQK6EwgxIHkAg4CvA6IAORBmwWr0Ofspf1//s/4PIQDkAQADeFQTyEMA2wBbBegBz81S0JgA5oA4MMEHgD7hp/xZ/rH+K/oPBYAbgL4BAAN4WArwQ4AxQDfDgQH0gHKMCYgC4gCOMFsJPcGn+Qt+yp/wQ/8Wfz0CQgBYGgDpFmD8bZBrAowBCoL9HsAg0E+BQIJx8IE90DfwS/4a/2P6LwEQAaCugCYOAD2iT0OgdkHFAARBwwCZQGKA5oAogDTA04j4TtU79D8Qfrq/3n47/LdL+CMAIgD4BiAGgARrr4X9EGAM0LVQXgmSAU/OBEgB2gCtgB8PO7Dn4Cf8lD/aP/AX/MBf54IAMKkB5NdhbALLMeDqn44hAxgEaAKoA6QAOZB4kD84EL+BH/LH+N8Lf/sC4OoR4FIAwACA/qdbgI8BqAK33of8+0pM3xtUFMQcEAUiB/JUIO4BfKIv+DeQ/4D+UQBsAJABTEoA6gFoAq4LKgbUKvA1MMAHAZqAowA4QBbkk9FP8Bv5q/0j/lP/2AArACoAoAES//J53Cn45y7IIFjKoGFA89VxlAGZgKEAOCASPJADfxkF9AP8kn+I/x7/83cEwBQAagV8JPpuH6gu6IIgyyB2gswBzgQKBxIFaAUTwM/wS/4a/6b+f2zxZwE0AVANcMoAYBeUBaQYIAaoDGYGKAigDZg6oFqYOPBhFHqCT/QFP+Rv2r/XPwug8O8KANMMQDnQDAEGQZXBfgYwCDQMIAUqA8QBHoHZh7ywT+hL/Vb+4/irACIAhgEw6b/NcEOAQXCcAQoCagOeAqUDhVkAHuSPPZsG/kJ/wk/5c/szgD8C4OwBQBNIDNjfqgK6GXQMQBCgCbAQ6MgGPAkyEwR8AJ/3vVQ/5b9vXv9stw5/LgAYAD3+YsCEFIAhYGIAy2AXA7Y3x8Az6gAogDAAEowegi/46+in+rH7M/af8UcBRACY3ADy10UZA1QFWgb8cAzgGNiiDQQK8J6gngngY/IDfshf6b/b/3+0+KsAMADgElj6n9AEsBB8CAM+1oWANgJqA+oDpMCOHOBZiz3Rh/dT/ZQ/45/Xf8X/lPA3O+BZ522KASyDdSEUPABBwJiAKEAb2DSREGcEeWIv6/fwE3/p/6Pq/yL+ZQHEAugDwLsZBsCNsI8BqAK9DPiinaCCgDEBUQA2ICKUjz0Jd4t+AR7oJ/jD+M/4swAwAMzXP5sAYwCqABiA22GWAZhAcIGbDIATxJPA19wX+lS/Fv+UP/FvHgA7/FEAEADCLeDUhWCoApEBh2oBcIHaBtQI6QK0AZ3q2eugB/iC36s/yx/27/FPBYArwLmHQ4BB0DPgm/cAmsAWJgAX0PkDCc/r5B6EHrYP7VP9Xv5bjP/D9f3/kfjfFwBn/wfaKQj2M+BgLgcVBa/D4DNcQCQwNlDNAEQIyAv7DeEH+lA/5N+t/28G/74AyAgwgQSyAARBMYBL4boROiIKBhPwLkAbIAcEYcU3fcqfAvZO/E79e8kf6rfx7/hN/e/s8ecr4HIs+vNjQD8DLoYBzgR0RQgXgA2QBKRBpQIPQPfgC32v/ix/4n/pxN8HgPmHXZBl0E8B3Q6LAdgIoA7IBBAHCwcqBcQBsYBUyL9D7Cl9wS/1C3/Kn+Pf40//ZwE0K+BEgvllMDPghWWgMEAuoDKgR8PKAuAAfGBXQVt/dpr6gh/il/o75c/69/JzDH8FwJkewCbgq8ASA/RKLAcBUQAugDAgH4AT7FZAL+VT+xK/1M/hT/n/+/VPvP9awN8UgHAJPEH9iAETGFA40JqAdwH6gI5gvBt6YQ/tC36o38kf6b/oH/h/7cH/vy6A8r1gNwO+VgacGgZkE9gbF8gcIA92QfCQvbQP9Kl+yV/wY/fP+ncawB8D4H9SgEFQ64DMAC0Fswl8DC4gDpAE5EH86AB8oM/oVw7h9+lf67+MvxYA8zcAeQiYKpAZUFZClyMZ4E2ALiAbIAfIgvHzuXwC+lQ/r/6Iv+J/Wf8k/BkA528AchPoZ0B9H2DKQGkDpQxgKQAXkA0EDnxeB76wF/qAH+pP8mf8f8X/mPCn/qePf26DRjygvBA5VwYoCmYToAs8wwbEAbAAPIjI109En+qX+Dvlf/7+iv+5vP/o1//EDUCOgc4DMgMUBZMJaA4scuAJJAANmo9FncgTfMV+iZ/4R/kr/v0i71x0lAiCKBofMRqjhgFc2Pn//zTQtsf2cLdm0ciwW2iiUWPMuY/qZnA5/j2P/9v/fQOQbwSvUwDvDKQQOLknKoBlAAmgAVRgJYywDd7soW/zR/qYX/yH2//n87/BDXB5I7hcARwG2iIAf4VAWwSCBogBiUAquHpAD/1ofvPP9qf+Wf+v4f/fjn/1UYALoayAfhhgEdg5AwgB90CSgDVwvQzse1sf89v9Sv9o/12rf9b/yN8XAIMCbpACOgrUChiOg30RuFwDvD+EBJZqIKrg63LukDd86LP3w9/4Pws/8d/rf1j/F/G/YQHko8C7JxXAcZBFQDWgEGj8nQJIAA04CayE8tVG7CN97C/3t/pP/A+PQ/1z/Fvmf/jfTgM+CtQKYBWkBjgNOATogedqQCoop4Jv+sn9H1P6M0fin/VvKX/i/0bw0cDyDLi0CrYa4FowpIAVIAlIA5LB9exNH/ymr5P/xe1v/hn/l9a/5f6/qv9vtgeMq+BYA7uB/58KkAYcAxYB00g+DzzoDd/mH/hT/tH+p+2P+Gf9W8b/ZgcAs6/3AJ4Q4TDAIkAN7IsQCOugNIAIPJ1spG7yhm/6Q/hT/n7sl+2P+Kf+Wf/78x/J/yvJ/zbeA4ICWARUAy0EDhdDYGMJMJ+sAUQgGUgLZh7YC77N7+7H/eBn+yP+Xf8/+a+8/8/w8x7w7k8FsAq6BkIIkAKFBiwCq6Aeoxd88GN+ol/uB7/t7/hn/YM/9z/2PxBuNpRAuBPkOUEtAtSAQkA9wCbA7SASUBBYBdZBTR72pm/z695H5S/7E/+qf57/g3//EDgL4M3p6yFBZUBaBYcaiCGwySnwcdgGkIBEwHSsBXeRF3u2fpn/pFLwq/6nwf5D/If1L/n/9vGvjwspA8JhwDVACPgdwq4AUuDLEANIQCKwDCwGMY/sTd/nPtPvwzt/g/0V/17/g/9XZH/WAGWAFOBV0CEwb9UDowYUA+oCpgG8cj6V9EGv8PfyP21n2V/1L/7J/7e/AVAOpAwYV0HXgELgOFkCvhYgBioR8LoGvOEbv+nb/tNxsL/iX+uf+a/pADCy1x4gBXgV1C7YQkA9oBRgGUAFUQRWAlow86fZm76rf/Nk+jf7e/sb6x/+a+9/tUCVAV4EHAKnHuA8oBTYqAisAYvAWhiBm/ly+tz52f3s/i39Zf+L9X9P/td1gDNAhwHXAJtA7wFWAQYJOAe4HWDO3K4cozd88Bfu386kP+2v+B/r3/5f1wWANBD3AI6DdQjQA14FNi6Cz8M+cCkIkMFV6Av6X0L1q/xJ/8L+Ov7Z/ys7ATBhDyhqQCFAD4wScBOgArWBpvFcCh7uAb4WP/hvhJ/0D/YP9X83/c91gL6wgBYB1wAh0JbBQQIPToHUBBaBVYASwktj+Hjf+O3+h1/4Wf6wv+Lf9e/nf96sLf7TKugLgToE6IG2CiABNKAYKFSQlODvjO95bH2bX+5/eGzlT/pjf8d/rP+bP/913VeWYBEICnAI6DwQJLCRBjgXwF8XBfXY9rJ+oh/cr91f9k/8Hf+rt//p2/JFIIQAPWAJOAacA06CSgfZ9aH14S/zC/+Q/sH+rv979b9bwApYEAKWwNES0KkglgEcP/Iy8v7SyPle+7z5C39t/3r9W9M7gEsvBFQDMQQKCXAvoEMBOaAokBL4Xv2Cr/kY6MOf2T6BX/ZP8b/665/lFwKsgjkE6IEogfnwnqEJQhd8tggM3cQNP1m/J7/mMCf8pH+2f+e/+rd/ChmwCboGHALuAUvgtFCzDDBoABWUaVBPV1Ck/x78WvyFX+kf7K/6v/3Hf66/EKAGsgIUAkECaoKwD8Q20MWhRmkf2NP7nu2+mz/gl/0H/tn+d5L/TFgEVAMKgVoC844YUBlUUSC+/lVrYJPgjzPt5gK/7B/iv3/8/z7jPywCdQiMq4AkQBN832sbKEVgznx32ps9rR/4H/bfyf4Bv8o/23/0/52tf9BfvggQAvRAkMAYA4/nKphOrywCZGAh1AN6nD/S5+/fHh8H80f8pD/2T/W/6nf/Fi4CREAOAfdA3wYHCdAELQbYCKeYBNbBpoYu8Gnjm9j7mvnJ/hF/2/2c/k/a/y7e/Vugg0IBuQeCBAYNzA/bwYqjCCQDyYGXoIdzvv667cM80A/4Q/qb/33e/l2cLl2mkMDXQgJDDJAD24ELU8igGke+/5It3h/MX+D/WuLn0x/3twB2+ohgSQhkCbQTwelqqMeANLA/TCQygJCBzooeez44v4f/dNiLfjf/6dqnbf4J/5P8h3d/767+pYTlIcAqgAT6oVAxcEQDlIFEwIAUOfDSb4rGn3rwD/Rl/n7wAz/lX9j/9v/70z/cABQCjf+ggNADSIAmIAasgcf9bgspetoa2PBD/zQVPvB3+0fRx/xkP/hD+o/839n+d70A+k6IDMg9YAmwDBADgwZGEZAElkE9Js9PmvNH+NDH/GP1G3+yf+O/qg///uVQYMNTIgoB9UCQADEQNNBE8H0+nqNgxNdf1fi3Tt34x/l7gx/oY/6AX+kv+/+aNT/3cYUGVAMKgSSBb0iAGEADSQRNBXSB+MYXQ5k09gk+9DE/+L8F/LX9V/Xx339ZA/SAQqCUQNYAIphRweP+uDtMqQ3q4J8Ou+P+EfYz8BP9Cj/29/Z3d+/9LxoOMiEE1AOSgJpg1IBFgAq6Dh5+5gETfN89/3Am3/54q/xL8Ef6zv6M3/a/n0d/r9FADoFCAiwDioGuAYIAEeznJgN0cEY5t8uavrCdyU99sWyXTPPvv7/ZvrEHPtZv9GV+qh/8Lv/R/i/i8u+JcQhYAh9KCaABcoAgkAqQQRNCPVge9GKP9U2/wn8a47f9X1QEvNF/JJF7wBJwE1zSwCCCpoImA4SAFJoehhczz4Bv6Bt74DfrK/md/cIf0v/+nvz7mwNh7oFaAkkDiAAVIIPjnpn7NNAafuexo4f9AD/Qr/C/OvsPInAIlBKgCYgBaQARoAJkcNJBmz1a8MD9J3nQwx74oo/5yf4a/2uwvz87wmQJpBiwBgiC9xMqQAYIAS1ooA74hh72DT7WF/1kfuMn/V+J/fu/yU+KLJcAMSANjEnQVIAM0MHpFaZR7+BBD/vB+aKP+Zfjf4lXf0svBp8pgaCBJAJkgBDQQp7DGTvgQR/gB/oF/pD+L+v2rwiB50qAGEgaQASooM122vY5NC2E2TLTdhL7Dj/Rx/wL8d/vY9/XayBI4G2WADFgDVgE/n/6EMIZKow9E9wn/Rdlhg99mz/hp/xf8M3fM3qAqSVgDZwmfIH28NHtqRh/7hD2wMf6pl/hp/xJ/zX8x///dzgP1BJwDFgDiAAV9Cme6tfzxICPX8w20Jf5I/63rzH9YZ9XAUvAMWANIAJU0Mcf8sgDd8iLPfBFX+Y3fsqf3f8FH/2evBMqJOAYsAaiCPz1GzQbXuGz5aDP8E3f5s/4X8QjXz/aO6PchGEgCirit/c/b1VZaLCmT4sCBkL2uX9tINLMrmNDkwdSKOA2EB1AAp7gR4p7PQi60cN+wI/0Kf4a/wm7v9sACpCkgB0IEmCB7u9ZRfcehn2AL/oZ/zVU/8ff82N9vDeIArUDNAIksAWIUAfyZg98Sr+mD/4Tr/wienUBHLAC2QEkwAI8mFMxN3nYAz/RD8V/9iv/+zcH88UAbQAHkEAWoIFNcMwd9GYPfOhT/MbvS7/zXfg73hgKCtQOWAI/4r+OwYPe8Cn9SJ8rv1Pu+u7/vgipHUCCET313Q9+VeLTZ80e+Ln2PfOD/5zbfnXCvoDaAA5kCbCAbmARHD94GvKwd99n3gf/heLX3H+82z28MMwEpHIACWyB+gE+TEP5Ab0Kv6Cv4mfZf/x/9l0VlsO5DdgBS2ALhgckPiL+B+iAH+jFHviBvoq/6d+VvCSQA2oEWGANbIJj7mZv+pdAf+tl/z70YU1QOIAFSIAGiIANDMYI3CEPethH+uN0e8v3IQuyA6UE9sAqOMZu9hl+Tb83fXfvDWyVA7YgaVDH4DN76F8m+r3oX7YowIFCAjRABFSouQ/yQi/4I5H+Ob7puSTb+IkOWIJKA/kwDyWgD/DHafXEvyBxmxgH9LERFhQmFNxL9uz0z/T7s95nNwI74NngggTEIkgHIQe8w1vdln7X/vJkB5CAAMwm1OGAUPfAD/R74l/RCKgsO+BWgAbg3BleV+ynFV/X/tKwO7AhwURCFsgDKTFGTZ4Y/V+u59br/VfEDkDF6wNNDUV8dK57+n5v9a+NK8vTAXTQAJLAdIo/NXrYd99/YbwycCswqYh5HkTgE3xOobd63xe3AlGTCkX0EsrtO/cXPN4USo46zBoYo+NDMvq/0ZX/WbEGBLL1GAnoT3Afn6MFHCK0PSV+4f6I59MCEGBNlboTe1f9wbOhgiLa6dCu+sMlAJ1H+du+yPuGzEUboSu9vvuyNMb/8wthK+NxFL06BAAAAABJRU5ErkJggg=="
      },
      _b$1[StyleItemType.ROTATE] = {
          entity: true,
          color: "rgba(255,255,255,1)",
          duration: 3,
          reverse: false
      },
      _b$1);
  var VECTOR_LAYER_STYLE = {
      get default() {
          return [
              {
                  type: StyleItemType.CIRCLE
              },
              {
                  type: StyleItemType.COLOR
              }
          ];
      }
  };
  var DEFAULT_ClUSTER_STYLE_ITEM = [
      {
          condition: function (feature) {
              return !feature.properties.cluster;
          },
          style: [
              {
                  type: StyleItemType.CIRCLE,
                  fillColor: "yellow",
                  outlineColor: "red",
                  outlineWidth: 1
              }
          ]
      },
      {
          condition: function (feature) {
              return feature.properties.cluster;
          },
          style: [
              {
                  type: StyleItemType.LABEL,
                  text: "{point_count}",
                  font: "bold 16px 微软雅黑",
                  eyeOffset: [0, 0, -5],
                  offset: [0, -25],
                  fillColor: "#fff",
                  scale: 0.8
              },
              {
                  type: StyleItemType.ICON,
                  image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAMAAADypuvZAAAAkFBMVEVHcEytj07QezOlklW8iEPEgzzChD6fmmCxjUvIgDm4ikXGgjupkVK5iUWmk1THgTqqkVHjaiahlV+vjk29h0Gfl1WqkFCnk1PpZCPqYSLMfjafm1yklVa0jEjKfzeklFW3ikbBhT66iUSnklTecCngbijWdy+pklPccivGgjvHgTq3ikbvUyPvVCLvViLuWSJVSoNWAAAALHRSTlMAZ+Y1scrHA37Wo9FUqETUWfsXdLkMX0z+/t4SIZLaLaHCrDz4+e5S9dDTn+/uy4kAAAHISURBVEjHnZaHcoMwDIYFYZhVssMIMzvB8P5vV9lpmpKFK90xzvDFkfg1AJ5tw4LKy5Mk96qAbUDBvtzwXDO/SG07LXxWn0P3awDRLC8b9ZdGmWdpH5CVZWr287KtmdbqDbJwnZm8WQf6Lu447+KdHqzl0sxxF6+YkWlMxc9eji3nvJGGN+2xFJtPDXP0zPgOExcjugE34zwyxBPm+I/M0hnjeTx5RK7YRD50ln3m4AhP5+0LRGLtXMTJOfT8kfvo/A0jNtPlXn/8WpjCn/1bRGJ74Zd5j2FpyH2ajyb3Mspf5YQY6/kAgxT6NQ1vmrLwmy7bYajF6M2sH72ZeJoMMkhN8EXzqkMhR0OBQcoQkpYeeTbYkRoU4aue8MrN8FBikHIBMjwgxA+2VYW2KIQQc/uEudA2itZippw2wGqAgKtCPACoGQRsWAx9WbAAKsySnTq0w8yrwCsA4kbZYoDCgzwF6NShDiDNIcEKwNUhjlUkoUGkv0cKhAj5Vj3kWxly0scVMrqoQxcpI5JgSalBS0JSupMKC62EkYolrSyTGgCt1Vybmv25qdkPTY3WPmmNmjYS3IeP8h/DB23MoQ1UxNGNOCSqjaPfoIkZyxIzEcUAAAAASUVORK5CYII="
              }
          ]
      }
  ];
  var CIRCLE_SEARCH_STYLE = {
      get linkedLine() {
          return [
              { type: StyleItemType.COLOR, width: 2, borderColor: "yellow", lineCap: "butt", entity: true, lineDash: [5] }
          ];
      },
      get centerPoint() {
          return [{ type: StyleItemType.CIRCLE, zIndex: 1 }];
      },
      get dragPoint() {
          return [{ type: StyleItemType.CIRCLE, zIndex: 1 }];
      },
      get circle() {
          return [
              {
                  type: StyleItemType.RADIAL_GRADIENT,
                  entity: true
              }
          ];
      }
  };
  var DRAW_STYLE = {
      get point() {
          return [
              {
                  type: StyleItemType.CIRCLE,
                  entity: true,
                  radius: 5,
                  fillColor: "yellow",
                  outlineColor: "red",
                  outlineWidth: 1
              }
          ];
      },
      get polyline() {
          return [
              {
                  type: StyleItemType.COLOR,
                  entity: true,
                  width: 2,
                  lineCap: "butt",
                  lineDash: [5],
                  borderColor: "rgba(255,0,0,1)"
              }
          ];
      },
      get polygon() {
          return [
              {
                  type: StyleItemType.COLOR,
                  entity: true,
                  width: 4,
                  fillColor: "rgba(255,0,0,0.2)",
                  borderColor: "rgba(255,0,0,0.8)",
                  lineCap: "butt",
                  lineDash: [5]
              }
          ];
      }
  };
  var Measure_STYLE = {
      draw: [
          {
              type: StyleItemType.CIRCLE,
              fillColor: "rgba(255, 255, 255, 0.8)",
              strokeColor: "rgba(255, 0, 0, 1)",
              radius: 4,
              entity: true
          },
          {
              type: StyleItemType.COLOR,
              width: 4,
              borderColor: "rgba(255,0,0,0.5)",
              entity: true,
              lineCap: "butt",
              lineDash: [5]
          },
          {
              width: 4,
              borderColor: "rgba(255,0,0,0.5)",
              lineCap: "butt",
              lineDash: [5],
              type: StyleItemType.COLOR,
              fillColor: "rgba(255,0,0,0.3)",
              entity: true
          }
      ],
      finsh: [
          {
              type: StyleItemType.CIRCLE,
              fillColor: "rgba(255, 255, 255, 0.8)",
              strokeColor: "rgba(255, 0, 0, 1)",
              radius: 4
          },
          {
              type: StyleItemType.COLOR,
              borderColor: "rgba(255,0,0,0.5)",
              width: 4,
              entity: true
          },
          {
              type: StyleItemType.COLOR,
              fillColor: "rgba(255,0,0,0.2)",
              entity: true,
              width: 4
          }
      ]
  };
  var EDIT_STYLE = [
      {
          type: StyleItemType.CIRCLE,
          fillColor: "red",
          strokeColor: "red",
          radius: 5,
          entity: true
      },
      {
          type: StyleItemType.LABEL,
          // text: "点击插入节点，拖拽编辑节点",
          font: "bold 16px 微软雅黑",
          pixelOffset: [-14, 0],
          eyeOffset: [0, 0, -5],
          offset: [0, -40],
          fillColor: "#fff",
          scale: 0.8
      },
      {
          type: StyleItemType.COLOR,
          width: 4,
          borderColor: "rgba(255,0,0,0.5)",
          material: "rgba(255,0,0,0.5)",
          entity: true
      },
      {
          type: StyleItemType.COLOR,
          fillColor: "rgba(255,0,0,0.3)",
          material: "rgba(255,0,0,0.3)",
          entity: true
      }
  ];
  var AREA_STYLE = {
      get outlineStyle() {
          return [
              {
                  type: StyleItemType.POLYLINE_GLOW,
                  color: "rgb(255,0,0)",
                  width: 10,
                  glowPower: 0.1
              }
          ];
      },
      get contentStyle() {
          return [
              {
                  type: StyleItemType.COLOR,
                  fillColor: "rgba(0,255,255,0.1)",
                  extrudedHeight: 5000
              }
          ];
      },
      get contentOutlineStyle() {
          return [
              {
                  type: StyleItemType.COLOR,
                  borderColor: "rgba(0,255,255,1)",
                  width: 2
              }
          ];
      },
      get contentLabelStyle() {
          return [
              {
                  type: StyleItemType.LABEL,
                  text: "{name}",
                  font: "bold 10px serif"
              }
          ];
      }
  };

  var index$7 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get: get$3,
    set: set$2
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics$1(d, b);
  };

  function __extends$6(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics$1(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign$1.apply(this, arguments);
  };

  function __awaiter$8(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator$1(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray$1(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  function globals(defs) {
    defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
  }

  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_GRIDSHIFT = 3;
  var PJD_WGS84 = 4; // WGS84 or equivalent
  var PJD_NODATUM = 5; // WGS84 or equivalent
  var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
  var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
  var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
  var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
  var HALF_PI = Math.PI/2;
  // ellipoid pj_set_ell.c
  var SIXTH = 0.1666666666666666667;
  /* 1/6 */
  var RA4 = 0.04722222222222222222;
  /* 17/360 */
  var RA6 = 0.02215608465608465608;
  var EPSLN = 1.0e-10;
  // you'd think you could use Number.EPSILON above but that makes
  // Mollweide get into an infinate loop.

  var D2R$1 = 0.01745329251994329577;
  var R2D = 57.29577951308232088;
  var FORTPI = Math.PI/4;
  var TWO_PI = Math.PI * 2;
  // SPI is slightly greater than Math.PI, so values that exceed the -180..180
  // degree range by a tiny amount don't get wrapped. This prevents points that
  // have drifted from their original location along the 180th meridian (due to
  // floating point error) from changing their sign.
  var SPI = 3.14159265359;

  var exports$3 = {};

  exports$3.greenwich = 0.0; //"0dE",
  exports$3.lisbon = -9.131906111111; //"9d07'54.862\"W",
  exports$3.paris = 2.337229166667; //"2d20'14.025\"E",
  exports$3.bogota = -74.080916666667; //"74d04'51.3\"W",
  exports$3.madrid = -3.687938888889; //"3d41'16.58\"W",
  exports$3.rome = 12.452333333333; //"12d27'8.4\"E",
  exports$3.bern = 7.439583333333; //"7d26'22.5\"E",
  exports$3.jakarta = 106.807719444444; //"106d48'27.79\"E",
  exports$3.ferro = -17.666666666667; //"17d40'W",
  exports$3.brussels = 4.367975; //"4d22'4.71\"E",
  exports$3.stockholm = 18.058277777778; //"18d3'29.8\"E",
  exports$3.athens = 23.7163375; //"23d42'58.815\"E",
  exports$3.oslo = 10.722916666667; //"10d43'22.5\"E"

  var units = {
    ft: {to_meter: 0.3048},
    'us-ft': {to_meter: 1200 / 3937}
  };

  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match$1(obj, key) {
    if (obj[key]) {
      return obj[key];
    }
    var keys = Object.keys(obj);
    var lkey = key.toLowerCase().replace(ignoredChar, '');
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, '');
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }

  function projStr(defData) {
    var self = {};
    var paramObj = defData.split('+').map(function(v) {
      return v.trim();
    }).filter(function(a) {
      return a;
    }).reduce(function(p, a) {
      var split = a.split('=');
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
      proj: 'projName',
      datum: 'datumCode',
      rf: function(v) {
        self.rf = parseFloat(v);
      },
      lat_0: function(v) {
        self.lat0 = v * D2R$1;
      },
      lat_1: function(v) {
        self.lat1 = v * D2R$1;
      },
      lat_2: function(v) {
        self.lat2 = v * D2R$1;
      },
      lat_ts: function(v) {
        self.lat_ts = v * D2R$1;
      },
      lon_0: function(v) {
        self.long0 = v * D2R$1;
      },
      lon_1: function(v) {
        self.long1 = v * D2R$1;
      },
      lon_2: function(v) {
        self.long2 = v * D2R$1;
      },
      alpha: function(v) {
        self.alpha = parseFloat(v) * D2R$1;
      },
      gamma: function(v) {
        self.rectified_grid_angle = parseFloat(v);
      },
      lonc: function(v) {
        self.longc = v * D2R$1;
      },
      x_0: function(v) {
        self.x0 = parseFloat(v);
      },
      y_0: function(v) {
        self.y0 = parseFloat(v);
      },
      k_0: function(v) {
        self.k0 = parseFloat(v);
      },
      k: function(v) {
        self.k0 = parseFloat(v);
      },
      a: function(v) {
        self.a = parseFloat(v);
      },
      b: function(v) {
        self.b = parseFloat(v);
      },
      r_a: function() {
        self.R_A = true;
      },
      zone: function(v) {
        self.zone = parseInt(v, 10);
      },
      south: function() {
        self.utmSouth = true;
      },
      towgs84: function(v) {
        self.datum_params = v.split(",").map(function(a) {
          return parseFloat(a);
        });
      },
      to_meter: function(v) {
        self.to_meter = parseFloat(v);
      },
      units: function(v) {
        self.units = v;
        var unit = match$1(units, v);
        if (unit) {
          self.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function(v) {
        self.from_greenwich = v * D2R$1;
      },
      pm: function(v) {
        var pm = match$1(exports$3, v);
        self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$1;
      },
      nadgrids: function(v) {
        if (v === '@null') {
          self.datumCode = 'none';
        }
        else {
          self.nadgrids = v;
        }
      },
      axis: function(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self.axis = v;
        }
      },
      approx: function() {
        self.approx = true;
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params) {
        paramOutname = params[paramName];
        if (typeof paramOutname === 'function') {
          paramOutname(paramVal);
        }
        else {
          self[paramOutname] = paramVal;
        }
      }
      else {
        self[paramName] = paramVal;
      }
    }
    if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
      self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
  }

  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace$1 = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84_]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  // const ignoredChar = /[\s_\-\/\(\)]/g;
  function Parser$2(text) {
    if (typeof text !== 'string') {
      throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser$2.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace$1.test(char)) {
        if (this.place >= this.text.length) {
          return;
        }
        char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(char);
      case KEYWORD:
        return this.keyword(char)
      case QUOTED:
        return this.quoted(char);
      case AFTERQUOTE:
        return this.afterquote(char);
      case NUMBER:
        return this.number(char);
      case ENDED:
        return;
    }
  };
  Parser$2.prototype.afterquote = function(char) {
    if (char === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(char)) {
      this.word = this.word.trim();
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
  };
  Parser$2.prototype.afterItem = function(char) {
    if (char === ',') {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (char === ']') {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }

      return;
    }
  };
  Parser$2.prototype.number = function(char) {
    if (digets.test(char)) {
      this.word += char;
      return;
    }
    if (endThings.test(char)) {
      this.word = parseFloat(this.word);
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
  };
  Parser$2.prototype.quoted = function(char) {
    if (char === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += char;
    return;
  };
  Parser$2.prototype.keyword = function(char) {
    if (keyword.test(char)) {
      this.word += char;
      return;
    }
    if (char === '[') {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
  };
  Parser$2.prototype.neutral = function(char) {
    if (latin.test(char)) {
      this.word = char;
      this.state = KEYWORD;
      return;
    }
    if (char === '"') {
      this.word = '';
      this.state = QUOTED;
      return;
    }
    if (digets.test(char)) {
      this.word = char;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
  };
  Parser$2.prototype.output = function() {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
  };

  function parseString(txt) {
    var parser = new Parser$2(txt);
    return parser.output();
  }

  function mapit(obj, key, value) {
    if (Array.isArray(key)) {
      value.unshift(key);
      key = null;
    }
    var thing = key ? {} : obj;

    var out = value.reduce(function(newObj, item) {
      sExpr(item, newObj);
      return newObj
    }, thing);
    if (key) {
      obj[key] = out;
    }
  }

  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
        return;
      }
      obj[key] = v[0];
      return;
    }
    if (!v.length) {
      obj[key] = true;
      return;
    }
    if (key === 'TOWGS84') {
      obj[key] = v;
      return;
    }
    if (key === 'AXIS') {
      if (!(key in obj)) {
        obj[key] = [];
      }
      obj[key].push(v);
      return;
    }
    if (!Array.isArray(key)) {
      obj[key] = {};
    }

    var i;
    switch (key) {
      case 'UNIT':
      case 'PRIMEM':
      case 'VERT_DATUM':
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key]);
        }
        return;
      case 'SPHEROID':
      case 'ELLIPSOID':
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key]);
        }
        return;
      case 'PROJECTEDCRS':
      case 'PROJCRS':
      case 'GEOGCS':
      case 'GEOCCS':
      case 'PROJCS':
      case 'LOCAL_CS':
      case 'GEODCRS':
      case 'GEODETICCRS':
      case 'GEODETICDATUM':
      case 'EDATUM':
      case 'ENGINEERINGDATUM':
      case 'VERT_CS':
      case 'VERTCRS':
      case 'VERTICALCRS':
      case 'COMPD_CS':
      case 'COMPOUNDCRS':
      case 'ENGINEERINGCRS':
      case 'ENGCRS':
      case 'FITTED_CS':
      case 'LOCAL_DATUM':
      case 'DATUM':
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key]);
          }
        }
        return mapit(obj, key, v);
    }
  }

  var D2R = 0.01745329251994329577;



  function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && (inName in obj)) {
      obj[outName] = obj[inName];
      if (params.length === 3) {
        obj[outName] = params[2](obj[outName]);
      }
    }
  }

  function d2r(input) {
    return input * D2R;
  }

  function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
      wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
      wkt.projName = 'identity';
      wkt.local = true;
    } else {
      if (typeof wkt.PROJECTION === 'object') {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = '';
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
        if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
          axisOrder += 'n';
        } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
          axisOrder += 's';
        } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
          axisOrder += 'e';
        } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
          axisOrder += 'w';
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += 'u';
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === 'metre') {
        wkt.units = 'meter';
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === 'GEOGCS') {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
      geogcs = wkt;
    }
    if (geogcs) {
      //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
      //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
      //}
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === 'd_') {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
        wkt.datumCode = 'nzgd49';
      }
      if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
        if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
          wkt.sphere = true;
        }
        wkt.datumCode = 'wgs84';
      }
      if (wkt.datumCode.slice(-6) === '_ferro') {
        wkt.datumCode = wkt.datumCode.slice(0, - 6);
      }
      if (wkt.datumCode.slice(-8) === '_jakarta') {
        wkt.datumCode = wkt.datumCode.slice(0, - 8);
      }
      if (~wkt.datumCode.indexOf('belge')) {
        wkt.datumCode = 'rnb72';
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
        if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
          wkt.ellps = 'intl';
        }

        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }

      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf('osgb_1936')) {
        wkt.datumCode = 'osgb36';
      }
      if (~wkt.datumCode.indexOf('osni_1952')) {
        wkt.datumCode = 'osni52';
      }
      if (~wkt.datumCode.indexOf('tm65')
        || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
        wkt.datumCode = 'ire65';
      }
      if (wkt.datumCode === 'ch1903+') {
        wkt.datumCode = 'ch1903';
      }
      if (~wkt.datumCode.indexOf('israel')) {
        wkt.datumCode = 'isr93';
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }

    function toMeter(input) {
      var ratio = wkt.to_meter || 1;
      return input * ratio;
    }
    var renamer = function(a) {
      return rename(wkt, a);
    };
    var list = [
      ['standard_parallel_1', 'Standard_Parallel_1'],
      ['standard_parallel_1', 'Latitude of 1st standard parallel'],
      ['standard_parallel_2', 'Standard_Parallel_2'],
      ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
      ['false_easting', 'False_Easting'],
      ['false_easting', 'False easting'],
      ['false-easting', 'Easting at false origin'],
      ['false_northing', 'False_Northing'],
      ['false_northing', 'False northing'],
      ['false_northing', 'Northing at false origin'],
      ['central_meridian', 'Central_Meridian'],
      ['central_meridian', 'Longitude of natural origin'],
      ['central_meridian', 'Longitude of false origin'],
      ['latitude_of_origin', 'Latitude_Of_Origin'],
      ['latitude_of_origin', 'Central_Parallel'],
      ['latitude_of_origin', 'Latitude of natural origin'],
      ['latitude_of_origin', 'Latitude of false origin'],
      ['scale_factor', 'Scale_Factor'],
      ['k0', 'scale_factor'],
      ['latitude_of_center', 'Latitude_Of_Center'],
      ['latitude_of_center', 'Latitude_of_center'],
      ['lat0', 'latitude_of_center', d2r],
      ['longitude_of_center', 'Longitude_Of_Center'],
      ['longitude_of_center', 'Longitude_of_center'],
      ['longc', 'longitude_of_center', d2r],
      ['x0', 'false_easting', toMeter],
      ['y0', 'false_northing', toMeter],
      ['long0', 'central_meridian', d2r],
      ['lat0', 'latitude_of_origin', d2r],
      ['lat0', 'standard_parallel_1', d2r],
      ['lat1', 'standard_parallel_1', d2r],
      ['lat2', 'standard_parallel_2', d2r],
      ['azimuth', 'Azimuth'],
      ['alpha', 'azimuth', d2r],
      ['srsCode', 'name']
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  function wkt(wkt) {
    var lisp = parseString(wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift(['name', name]);
    lisp.unshift(['type', type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  }

  function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === 'string') {
        if (def.charAt(0) === '+') {
          defs[name] = projStr(arguments[1]);
        }
        else {
          defs[name] = wkt(arguments[1]);
        }
      } else {
        defs[name] = def;
      }
    }
    else if (arguments.length === 1) {
      if (Array.isArray(name)) {
        return name.map(function(v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          }
          else {
            defs(v);
          }
        });
      }
      else if (typeof name === 'string') {
        if (name in defs) {
          return defs[name];
        }
      }
      else if ('EPSG' in name) {
        defs['EPSG:' + name.EPSG] = name;
      }
      else if ('ESRI' in name) {
        defs['ESRI:' + name.ESRI] = name;
      }
      else if ('IAU2000' in name) {
        defs['IAU2000:' + name.IAU2000] = name;
      }
      else {
        console.log(name);
      }
      return;
    }


  }
  globals(defs);

  function testObj(code){
    return typeof code === 'string';
  }
  function testDef(code){
    return code in defs;
  }
  var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
  function testWKT(code){
    return codeWords.some(function (word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ['3857', '900913', '3785', '102113'];
  function checkMercator(item) {
    var auth = match$1(item, 'authority');
    if (!auth) {
      return;
    }
    var code = match$1(auth, 'epsg');
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match$1(item, 'extension');
    if (!ext) {
      return;
    }
    return match$1(ext, 'proj4');
  }
  function testProj(code){
    return code[0] === '+';
  }
  function parse$3(code){
    if (testObj(code)) {
      //check to see if this is a WKT string
      if (testDef(code)) {
        return defs[code];
      }
      if (testWKT(code)) {
        var out = wkt(code);
        // test of spetial case, due to this being a very common and often malformed
        if (checkMercator(out)) {
          return defs['EPSG:3857'];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return projStr(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return projStr(code);
      }
    }else {
      return code;
    }
  }

  function extend$2(destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
      return destination;
    }
    for (property in source) {
      value = source[property];
      if (value !== undefined) {
        destination[property] = value;
      }
    }
    return destination;
  }

  function msfnz(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / (Math.sqrt(1 - con * con));
  }

  function sign(x) {
    return x<0 ? -1 : 1;
  }

  function adjust_lon(x) {
    return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
  }

  function tsfnz(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow(((1 - con) / (1 + con)), com);
    return (Math.tan(0.5 * (HALF_PI - phi)) / con);
  }

  function phi2z(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
  }

  function init$u() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if(!('x0' in this)){
      this.x0 = 0;
    }
    if(!('y0' in this)){
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      }
      else {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }
    else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        }
        else {
          this.k0 = 1;
        }
      }
    }
  }

  /* Mercator forward equations--mapping lat,long to x,y
    --------------------------------------------------*/

  function forward$t(p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
      return null;
    }

    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    }
    else {
      if (this.sphere) {
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      }
      else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz(this.e, lat, sinphi);
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x;
      p.y = y;
      return p;
    }
  }

  /* Mercator inverse equations--mapping x,y to lat/long
    --------------------------------------------------*/
  function inverse$t(p) {

    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;

    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    }
    else {
      var ts = Math.exp(-y / (this.a * this.k0));
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$v = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc = {
    init: init$u,
    forward: forward$t,
    inverse: inverse$t,
    names: names$v
  };

  function init$t() {
    //no-op for longlat
  }

  function identity$1(pt) {
    return pt;
  }
  var names$u = ["longlat", "identity"];
  var longlat = {
    init: init$t,
    forward: identity$1,
    inverse: identity$1,
    names: names$u
  };

  var projs = [merc, longlat];
  var names$t = {};
  var projStore = [];

  function add(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function(n) {
      names$t[n.toLowerCase()] = len;
    });
    return this;
  }

  function get$2(name) {
    if (!name) {
      return false;
    }
    var n = name.toLowerCase();
    if (typeof names$t[n] !== 'undefined' && projStore[names$t[n]]) {
      return projStore[names$t[n]];
    }
  }

  function start() {
    projs.forEach(add);
  }
  var projections = {
    start: start,
    add: add,
    get: get$2
  };

  var exports$2 = {};
  exports$2.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };

  exports$2.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };

  exports$2.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };

  exports$2.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };

  exports$2.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
  };

  exports$2.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };

  exports$2.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };

  exports$2.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
  };

  exports$2.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };

  exports$2.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };

  exports$2.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
  };

  exports$2.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };

  exports$2.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };

  exports$2.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
  };

  exports$2.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };

  exports$2.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };

  exports$2.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };

  exports$2.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };

  exports$2.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };

  exports$2.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };

  exports$2.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };

  exports$2.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };

  exports$2.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };

  exports$2.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };

  exports$2.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };

  exports$2.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };

  exports$2.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };

  exports$2.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };

  exports$2.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
  };

  exports$2.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
  };

  exports$2.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };

  exports$2.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };

  exports$2.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
  };

  exports$2.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
  };

  exports$2.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
  };

  exports$2.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };

  exports$2.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
  };

  exports$2.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
  };

  exports$2.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
  };

  exports$2.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
  };

  exports$2.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
  };

  var WGS84 = exports$2.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };

  exports$2.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
  };

  function eccentricity(a, b, rf, R_A) {
    var a2 = a * a; // used in geocentric
    var b2 = b * b; // used in geocentric
    var es = (a2 - b2) / a2; // e ^ 2
    var e = 0;
    if (R_A) {
      a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a2 = a * a;
      es = 0;
    } else {
      e = Math.sqrt(es); // eccentricity
    }
    var ep2 = (a2 - b2) / b2; // used in geocentric
    return {
      es: es,
      e: e,
      ep2: ep2
    };
  }
  function sphere(a, b, rf, ellps, sphere) {
    if (!a) { // do we have an ellipsoid?
      var ellipse = match$1(exports$2, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }

    if (rf && !b) {
      b = (1.0 - 1.0 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
      sphere = true;
      b = a;
    }
    return {
      a: a,
      b: b,
      rf: rf,
      sphere: sphere
    };
  }

  var exports$1 = {};
  exports$1.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };

  exports$1.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };

  exports$1.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };

  exports$1.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };

  exports$1.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };

  exports$1.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };

  exports$1.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };

  exports$1.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };

  exports$1.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };

  exports$1.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };

  exports$1.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };

  exports$1.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };

  exports$1.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };

  exports$1.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  };

  exports$1.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  };

  exports$1.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  };

  exports$1.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };

  function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
    var out = {};

    if (datumCode === undefined || datumCode === 'none') {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }

    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
        }
      }
    }

    if (nadgrids) {
      out.datum_type = PJD_GRIDSHIFT;
      out.grids = nadgrids;
    }
    out.a = a; //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }

  /**
   * Resources for details of NTv2 file formats:
   * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
   * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
   */

  var loadedNadgrids = {};

  /**
   * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
   * as an ArrayBuffer.
   */
  function nadgrid(key, data) {
    var view = new DataView(data);
    var isLittleEndian = detectLittleEndian(view);
    var header = readHeader(view, isLittleEndian);
    if (header.nSubgrids > 1) {
      console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
    }
    var subgrids = readSubgrids(view, header, isLittleEndian);
    var nadgrid = {header: header, subgrids: subgrids};
    loadedNadgrids[key] = nadgrid;
    return nadgrid;
  }

  /**
   * Given a proj4 value for nadgrids, return an array of loaded grids
   */
  function getNadgrids(nadgrids) {
    // Format details: http://proj.maptools.org/gen_parms.html
    if (nadgrids === undefined) { return null; }
    var grids = nadgrids.split(',');
    return grids.map(parseNadgridString);
  }

  function parseNadgridString(value) {
    if (value.length === 0) {
      return null;
    }
    var optional = value[0] === '@';
    if (optional) {
      value = value.slice(1);
    }
    if (value === 'null') {
      return {name: 'null', mandatory: !optional, grid: null, isNull: true};
    }
    return {
      name: value,
      mandatory: !optional,
      grid: loadedNadgrids[value] || null,
      isNull: false
    };
  }

  function secondsToRadians(seconds) {
    return (seconds / 3600) * Math.PI / 180;
  }

  function detectLittleEndian(view) {
    var nFields = view.getInt32(8, false);
    if (nFields === 11) {
      return false;
    }
    nFields = view.getInt32(8, true);
    if (nFields !== 11) {
      console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
    }
    return true;
  }

  function readHeader(view, isLittleEndian) {
    return {
      nFields: view.getInt32(8, isLittleEndian),
      nSubgridFields: view.getInt32(24, isLittleEndian),
      nSubgrids: view.getInt32(40, isLittleEndian),
      shiftType: decodeString(view, 56, 56 + 8).trim(),
      fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
      fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
      toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
      toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
    };
  }

  function decodeString(view, start, end) {
    return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
  }

  function readSubgrids(view, header, isLittleEndian) {
    var gridOffset = 176;
    var grids = [];
    for (var i = 0; i < header.nSubgrids; i++) {
      var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
      var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
      var lngColumnCount = Math.round(
        1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
      var latColumnCount = Math.round(
        1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
      // Proj4 operates on radians whereas the coordinates are in seconds in the grid
      grids.push({
        ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
        del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
        lim: [lngColumnCount, latColumnCount],
        count: subHeader.gridNodeCount,
        cvs: mapNodes(nodes)
      });
    }
    return grids;
  }

  function mapNodes(nodes) {
    return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
  }

  function readGridHeader(view, offset, isLittleEndian) {
    return {
      name: decodeString(view, offset + 8, offset + 16).trim(),
      parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
      lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
      upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
      lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
      upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
      latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
      longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
      gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
    };
  }

  function readGridNodes(view, offset, gridHeader, isLittleEndian) {
    var nodesOffset = offset + 176;
    var gridRecordLength = 16;
    var gridShiftRecords = [];
    for (var i = 0; i < gridHeader.gridNodeCount; i++) {
      var record = {
        latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
        longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
        latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
        longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
      };
      gridShiftRecords.push(record);
    }
    return gridShiftRecords;
  }

  function Projection(srsCode,callback) {
    if (!(this instanceof Projection)) {
      return new Projection(srsCode);
    }
    callback = callback || function(error){
      if(error){
        throw error;
      }
    };
    var json = parse$3(srsCode);
    if(typeof json !== 'object'){
      callback(srsCode);
      return;
    }
    var ourProj = Projection.projections.get(json.projName);
    if(!ourProj){
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
      var datumDef = match$1(exports$1, json.datumCode);
      if (datumDef) {
        json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1.0;
    json.axis = json.axis || 'enu';
    json.ellps = json.ellps || 'wgs84';
    json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var nadgrids = getNadgrids(json.nadgrids);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
      nadgrids);

    extend$2(this, json); // transfer everything over from the projection because we don't know what we'll need
    extend$2(this, ourProj); // transfer all the methods from the projection

    // copy the 4 things over we calulated in deriveConstants.sphere
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;

    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;

    // add in the datum object
    this.datum = datumObj;

    // init the projection
    this.init();

    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);

  }
  Projection.projections = projections;
  Projection.projections.start();

  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
      // the tolerance for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
    } else if (source.datum_type === PJD_7PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
    } else {
      return true; // datums are equal
    }
  } // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  function geodeticToGeocentric(p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return { x: -Infinity, y: -Infinity, z: p.z };
    } else if (Latitude > HALF_PI) {
      /* Latitude out of range */
      return { x: Infinity, y: Infinity, z: p.z };
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: ((Rn * (1 - es)) + Height) * Sin_Lat
    };
  } // cs_geodetic_to_geocentric()

  function geocentricToGeodetic(p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / a < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
    CPHI0 = ST * (1.0 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

      RK = es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  } // cs_geocentric_to_geodetic()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)


  /** point object, nothing fancy, just allows values to be
      passed back and forth by reference rather than by value.
      Other point classes may be used as long as they have
      x and y properties, which will get modified in the transform method.
  */
  function geocentricToWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2],
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  } // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  function geocentricFromWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2],
      };

    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    } //cs_geocentric_from_wgs84()
  }

  function checkParams(type) {
    return (type === PJD_3PARAM || type === PJD_7PARAM);
  }

  function datum_transform(source, dest, point) {
    // Short cut if the datums are identical.
    if (compareDatums(source, dest)) {
      return point; // in this case, zero is sucess,
      // whereas cs_compare_datums returns 1 to indicate TRUE
      // confusing, should fix this
    }

    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point;
    }

    // If this datum requires grid shifts, then apply it to geodetic coordinates.
    var source_a = source.a;
    var source_es = source.es;
    if (source.datum_type === PJD_GRIDSHIFT) {
      var gridShiftCode = applyGridShift(source, false, point);
      if (gridShiftCode !== 0) {
        return undefined;
      }
      source_a = SRS_WGS84_SEMIMAJOR;
      source_es = SRS_WGS84_ESQUARED;
    }

    var dest_a = dest.a;
    var dest_b = dest.b;
    var dest_es = dest.es;
    if (dest.datum_type === PJD_GRIDSHIFT) {
      dest_a = SRS_WGS84_SEMIMAJOR;
      dest_b = SRS_WGS84_SEMIMINOR;
      dest_es = SRS_WGS84_ESQUARED;
    }

    // Do we need to go through geocentric coordinates?
    if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
      return point;
    }

    // Convert to geocentric coordinates.
    point = geodeticToGeocentric(point, source_es, source_a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
      point = geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

    if (dest.datum_type === PJD_GRIDSHIFT) {
      var destGridShiftResult = applyGridShift(dest, true, point);
      if (destGridShiftResult !== 0) {
        return undefined;
      }
    }

    return point;
  }

  function applyGridShift(source, inverse, point) {
    if (source.grids === null || source.grids.length === 0) {
      console.log('Grid shift grids not found');
      return -1;
    }
    var input = {x: -point.x, y: point.y};
    var output = {x: Number.NaN, y: Number.NaN};
    var attemptedGrids = [];
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrid = grid.grid.subgrids[0];
      // skip tables that don't match our point at all
      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
      var minX = subgrid.ll[0] - epsilon;
      var minY = subgrid.ll[1] - epsilon;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
        continue;
      }
      output = applySubgridShift(input, inverse, subgrid);
      if (!isNaN(output.x)) {
        break;
      }
    }
    if (isNaN(output.x)) {
      console.log("Failed to find a grid shift table for location '"+
        -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
      return -1;
    }
    point.x = -output.x;
    point.y = output.y;
    return 0;
  }

  function applySubgridShift(pin, inverse, ct) {
    var val = {x: Number.NaN, y: Number.NaN};
    if (isNaN(pin.x)) { return val; }
    var tb = {x: pin.x, y: pin.y};
    tb.x -= ct.ll[0];
    tb.y -= ct.ll[1];
    tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
    var t = nadInterpolate(tb, ct);
    if (inverse) {
      if (isNaN(t.x)) {
        return val;
      }
      t.x = tb.x - t.x;
      t.y = tb.y - t.y;
      var i = 9, tol = 1e-12;
      var dif, del;
      do {
        del = nadInterpolate(t, ct);
        if (isNaN(del.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
        t.x += dif.x;
        t.y += dif.y;
      } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
      if (i < 0) {
        console.log("Inverse grid shift iterator failed to converge.");
        return val;
      }
      val.x = adjust_lon(t.x + ct.ll[0]);
      val.y = t.y + ct.ll[1];
    } else {
      if (!isNaN(t.x)) {
        val.x = pin.x + t.x;
        val.y = pin.y + t.y;
      }
    }
    return val;
  }

  function nadInterpolate(pin, ct) {
    var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
    var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
    var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
    var val= {x: Number.NaN, y: Number.NaN};
    var inx;
    if (indx.x < 0 || indx.x >= ct.lim[0]) {
      return val;
    }
    if (indx.y < 0 || indx.y >= ct.lim[1]) {
      return val;
    }
    inx = (indx.y * ct.lim[0]) + indx.x;
    var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx++;
    var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx += ct.lim[0];
    var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    inx--;
    var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
    var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
      m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
    val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
    val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
    return val;
  }

  function adjust_axis(crs, denorm, point) {
    var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point.z === undefined) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = 'x';
        } else {
          t = 'y';
        }

      }
      else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = 'y';
        } else {
          t = 'x';
        }
      }
      else {
        v = zin;
        t = 'z';
      }
      switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;
      case 'w':
        out[t] = -v;
        break;
      case 'n':
        out[t] = v;
        break;
      case 's':
        out[t] = -v;
        break;
      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }
        break;
      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }
        break;
      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
      }
    }
    return out;
  }

  function common (array){
    var out = {
      x: array[0],
      y: array[1]
    };
    if (array.length>2) {
      out.z = array[2];
    }
    if (array.length>3) {
      out.m = array[3];
    }
    return out;
  }

  function checkSanity (point) {
    checkCoord(point.x);
    checkCoord(point.y);
  }
  function checkCoord(num) {
    if (typeof Number.isFinite === 'function') {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError('coordinates must be finite numbers');
    }
    if (typeof num !== 'number' || num !== num || !isFinite(num)) {
      throw new TypeError('coordinates must be finite numbers');
    }
  }

  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
  }

  function transform$4(source, dest, point, enforceAxis) {
    var wgs84;
    if (Array.isArray(point)) {
      point = common(point);
    }
    checkSanity(point);
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs84 = new Projection('WGS84');
      point = transform$4(source, wgs84, point, enforceAxis);
      source = wgs84;
    }
    // DGR, 2010/11/12
    if (enforceAxis && source.axis !== 'enu') {
      point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
      point = {
        x: point.x * D2R$1,
        y: point.y * D2R$1,
        z: point.z || 0
      };
    } else {
      if (source.to_meter) {
        point = {
          x: point.x * source.to_meter,
          y: point.y * source.to_meter,
          z: point.z || 0
        };
      }
      point = source.inverse(point); // Convert Cartesian to longlat
      if (!point) {
        return;
      }
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
      point.x += source.from_greenwich;
    }

    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);
    if (!point) {
      return;
    }

    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
      point = {
        x: point.x - dest.from_greenwich,
        y: point.y,
        z: point.z || 0
      };
    }

    if (dest.projName === 'longlat') {
      // convert radians to decimal degrees
      point = {
        x: point.x * R2D,
        y: point.y * R2D,
        z: point.z || 0
      };
    } else { // else project
      point = dest.forward(point);
      if (dest.to_meter) {
        point = {
          x: point.x / dest.to_meter,
          y: point.y / dest.to_meter,
          z: point.z || 0
        };
      }
    }

    // DGR, 2010/11/12
    if (enforceAxis && dest.axis !== 'enu') {
      return adjust_axis(dest, true, point);
    }

    return point;
  }

  var wgs84 = Projection('WGS84');

  function transformer(from, to, coords, enforceAxis) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform$4(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
      if (coords.length > 2) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (typeof transformedArray.z === 'number') {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform$4(from, to, coords, enforceAxis);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function (key) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (key === 'x' || key === 'y' || key === 'z') {
            return;
          }
        } else {
          if (key === 'x' || key === 'y') {
            return;
          }
        }
        out[key] = coords[key];
      });
      return out;
    }
  }

  function checkProj(item) {
    if (item instanceof Projection) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Projection(item);
  }

  function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function (coords, enforceAxis) {
          return transformer(fromProj, toProj, coords, enforceAxis);
        },
        inverse: function (coords, enforceAxis) {
          return transformer(toProj, fromProj, coords, enforceAxis);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }

  /**
   * UTM zones are grouped, and assigned to one of a group of 6
   * sets.
   *
   * {int} @private
   */
  var NUM_100K_SETS = 6;

  /**
   * The column letters (for easting) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

  /**
   * The row letters (for northing) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

  var A$2 = 65; // A
  var I$1 = 73; // I
  var O$2 = 79; // O
  var V$2 = 86; // V
  var Z$2 = 90; // Z
  var mgrs = {
    forward: forward$s,
    inverse: inverse$s,
    toPoint: toPoint
  };
  /**
   * Conversion of lat/lon to MGRS.
   *
   * @param {object} ll Object literal with lat and lon properties on a
   *     WGS84 ellipsoid.
   * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
   *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
   * @return {string} the MGRS string for the given location and accuracy.
   */
  function forward$s(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }
  /**
   * Conversion of MGRS to lat/lon.
   *
   * @param {string} mgrs MGRS string.
   * @return {array} An array with left (longitude), bottom (latitude), right
   *     (longitude) and top (latitude) values in WGS84, representing the
   *     bounding box for the provided MGRS reference.
   */
  function inverse$s(mgrs) {
    var bbox = UTMtoLL(decode$4(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
    }
    return [bbox.left, bbox.bottom, bbox.right, bbox.top];
  }
  function toPoint(mgrs) {
    var bbox = UTMtoLL(decode$4(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat];
    }
    return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
  }/**
   * Conversion from degrees to radians.
   *
   * @private
   * @param {number} deg the angle in degrees.
   * @return {number} the angle in radians.
   */
  function degToRad(deg) {
    return (deg * (Math.PI / 180.0));
  }

  /**
   * Conversion from radians to degrees.
   *
   * @private
   * @param {number} rad the angle in radians.
   * @return {number} the angle in degrees.
   */
  function radToDeg(rad) {
    return (180.0 * (rad / Math.PI));
  }

  /**
   * Converts a set of Longitude and Latitude co-ordinates to UTM
   * using the WGS84 ellipsoid.
   *
   * @private
   * @param {object} ll Object literal with lat and lon properties
   *     representing the WGS84 coordinate to be converted.
   * @return {object} Object literal containing the UTM value with easting,
   *     northing, zoneNumber and zoneLetter properties, and an optional
   *     accuracy property in digits. Returns null if the conversion failed.
   */
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;

    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
      ZoneNumber = 60;
    }

    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
      ZoneNumber = 32;
    }

    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
      if (Long >= 0.0 && Long < 9.0) {
        ZoneNumber = 31;
      }
      else if (Long >= 9.0 && Long < 21.0) {
        ZoneNumber = 33;
      }
      else if (Long >= 21.0 && Long < 33.0) {
        ZoneNumber = 35;
      }
      else if (Long >= 33.0 && Long < 42.0) {
        ZoneNumber = 37;
      }
    }

    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);

    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

    var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

    var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
    if (Lat < 0.0) {
      UTMNorthing += 10000000.0; //10000000 meter offset for
      // southern hemisphere
    }

    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }

  /**
   * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
   * class where the Zone can be specified as a single string eg."60N" which
   * is then broken down into the ZoneNumber and ZoneLetter.
   *
   * @private
   * @param {object} utm An object literal with northing, easting, zoneNumber
   *     and zoneLetter properties. If an optional accuracy property is
   *     provided (in meters), a bounding box will be returned instead of
   *     latitude and longitude.
   * @return {object} An object literal containing either lat and lon values
   *     (if no accuracy was provided), or top, right, bottom and left values
   *     for the bounding box calculated according to the provided accuracy.
   *     Returns null if the conversion failed.
   */
  function UTMtoLL(utm) {

    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }

    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;

    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;

    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
      y -= 10000000.0; // remove 10,000,000 meter offset used
      // for southern hemisphere
    }

    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);

    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);

    var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);

    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);

    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    }
    else {
      result = {
        lat: lat,
        lon: lon
      };
    }
    return result;
  }

  /**
   * Calculates the MGRS letter designator for the given latitude.
   *
   * @private
   * @param {number} lat The latitude in WGS84 to get the letter designator
   *     for.
   * @return {char} The letter designator.
   */
  function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';

    if ((84 >= lat) && (lat >= 72)) {
      LetterDesignator = 'X';
    }
    else if ((72 > lat) && (lat >= 64)) {
      LetterDesignator = 'W';
    }
    else if ((64 > lat) && (lat >= 56)) {
      LetterDesignator = 'V';
    }
    else if ((56 > lat) && (lat >= 48)) {
      LetterDesignator = 'U';
    }
    else if ((48 > lat) && (lat >= 40)) {
      LetterDesignator = 'T';
    }
    else if ((40 > lat) && (lat >= 32)) {
      LetterDesignator = 'S';
    }
    else if ((32 > lat) && (lat >= 24)) {
      LetterDesignator = 'R';
    }
    else if ((24 > lat) && (lat >= 16)) {
      LetterDesignator = 'Q';
    }
    else if ((16 > lat) && (lat >= 8)) {
      LetterDesignator = 'P';
    }
    else if ((8 > lat) && (lat >= 0)) {
      LetterDesignator = 'N';
    }
    else if ((0 > lat) && (lat >= -8)) {
      LetterDesignator = 'M';
    }
    else if ((-8 > lat) && (lat >= -16)) {
      LetterDesignator = 'L';
    }
    else if ((-16 > lat) && (lat >= -24)) {
      LetterDesignator = 'K';
    }
    else if ((-24 > lat) && (lat >= -32)) {
      LetterDesignator = 'J';
    }
    else if ((-32 > lat) && (lat >= -40)) {
      LetterDesignator = 'H';
    }
    else if ((-40 > lat) && (lat >= -48)) {
      LetterDesignator = 'G';
    }
    else if ((-48 > lat) && (lat >= -56)) {
      LetterDesignator = 'F';
    }
    else if ((-56 > lat) && (lat >= -64)) {
      LetterDesignator = 'E';
    }
    else if ((-64 > lat) && (lat >= -72)) {
      LetterDesignator = 'D';
    }
    else if ((-72 > lat) && (lat >= -80)) {
      LetterDesignator = 'C';
    }
    return LetterDesignator;
  }

  /**
   * Encodes a UTM location as MGRS string.
   *
   * @private
   * @param {object} utm An object literal with easting, northing,
   *     zoneLetter, zoneNumber
   * @param {number} accuracy Accuracy in digits (1-5).
   * @return {string} MGRS string for the given UTM location.
   */
  function encode(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }

  /**
   * Get the two letter 100k designator for a given UTM easting,
   * northing and zone number value.
   *
   * @private
   * @param {number} easting
   * @param {number} northing
   * @param {number} zoneNumber
   * @return the two letter 100k designator for the given UTM location.
   */
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }

  /**
   * Given a UTM zone number, figure out the MGRS 100K set it is in.
   *
   * @private
   * @param {number} i An UTM zone number.
   * @return {number} the 100k set the UTM zone is in.
   */
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }

    return setParm;
  }

  /**
   * Get the two-letter MGRS 100k designator given information
   * translated from the UTM northing, easting and zone number.
   *
   * @private
   * @param {number} column the column index as it relates to the MGRS
   *        100k set spreadsheet, created from the UTM easting.
   *        Values are 1-8.
   * @param {number} row the row index as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM northing value. Values
   *        are from 0-19.
   * @param {number} parm the set block, as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM zone. Values are from
   *        1-60.
   * @return two letter MGRS 100k code.
   */
  function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;

    if (colInt > Z$2) {
      colInt = colInt - Z$2 + A$2 - 1;
      rollover = true;
    }

    if (colInt === I$1 || (colOrigin < I$1 && colInt > I$1) || ((colInt > I$1 || colOrigin < I$1) && rollover)) {
      colInt++;
    }

    if (colInt === O$2 || (colOrigin < O$2 && colInt > O$2) || ((colInt > O$2 || colOrigin < O$2) && rollover)) {
      colInt++;

      if (colInt === I$1) {
        colInt++;
      }
    }

    if (colInt > Z$2) {
      colInt = colInt - Z$2 + A$2 - 1;
    }

    if (rowInt > V$2) {
      rowInt = rowInt - V$2 + A$2 - 1;
      rollover = true;
    }
    else {
      rollover = false;
    }

    if (((rowInt === I$1) || ((rowOrigin < I$1) && (rowInt > I$1))) || (((rowInt > I$1) || (rowOrigin < I$1)) && rollover)) {
      rowInt++;
    }

    if (((rowInt === O$2) || ((rowOrigin < O$2) && (rowInt > O$2))) || (((rowInt > O$2) || (rowOrigin < O$2)) && rollover)) {
      rowInt++;

      if (rowInt === I$1) {
        rowInt++;
      }
    }

    if (rowInt > V$2) {
      rowInt = rowInt - V$2 + A$2 - 1;
    }

    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }

  /**
   * Decode the UTM parameters from a MGRS string.
   *
   * @private
   * @param {string} mgrsString an UPPERCASE coordinate string is expected.
   * @return {object} An object literal with easting, northing, zoneLetter,
   *     zoneNumber and accuracy (in meters) properties.
   */
  function decode$4(mgrsString) {

    if (mgrsString && mgrsString.length === 0) {
      throw ("MGRSPoint coverting from nothing");
    }

    var length = mgrsString.length;

    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;

    // get Zone number
    while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }
      sb += testChar;
      i++;
    }

    var zoneNumber = parseInt(sb, 10);

    if (i === 0 || i + 3 > length) {
      // A good MGRS string has to be 4-5 digits long,
      // ##AAA/#AAA at least.
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }

    var zoneLetter = mgrsString.charAt(i++);

    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
      throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
    }

    hunK = mgrsString.substring(i, i += 2);

    var set = get100kSetForZone(zoneNumber);

    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);

    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?

    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2000000;
    }

    // calculate the char index for easting/northing separator
    var remainder = length - i;

    if (remainder % 2 !== 0) {
      throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
    }

    var sep = remainder / 2;

    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 100000.0 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }

    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;

    return {
      easting: easting,
      northing: northing,
      zoneLetter: zoneLetter,
      zoneNumber: zoneNumber,
      accuracy: accuracyBonus
    };
  }

  /**
   * Given the first letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the easting value that
   * should be added to the other, secondary easting value.
   *
   * @private
   * @param {char} e The first letter from a two-letter MGRS 100´k zone.
   * @param {number} set The MGRS table set for the zone number.
   * @return {number} The easting value for the given letter and set.
   */
  function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;

    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I$1) {
        curCol++;
      }
      if (curCol === O$2) {
        curCol++;
      }
      if (curCol > Z$2) {
        if (rewindMarker) {
          throw ("Bad character: " + e);
        }
        curCol = A$2;
        rewindMarker = true;
      }
      eastingValue += 100000.0;
    }

    return eastingValue;
  }

  /**
   * Given the second letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the northing value that
   * should be added to the other, secondary northing value. You have to
   * remember that Northings are determined from the equator, and the vertical
   * cycle of letters mean a 2000000 additional northing meters. This happens
   * approx. every 18 degrees of latitude. This method does *NOT* count any
   * additional northings. You have to figure out how many 2000000 meters need
   * to be added for the zone letter of the MGRS coordinate.
   *
   * @private
   * @param {char} n Second letter of the MGRS 100k zone
   * @param {number} set The MGRS table set number, which is dependent on the
   *     UTM zone number.
   * @return {number} The northing value for the given letter and set.
   */
  function getNorthingFromChar(n, set) {

    if (n > 'V') {
      throw ("MGRSPoint given invalid Northing " + n);
    }

    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;

    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I$1) {
        curRow++;
      }
      if (curRow === O$2) {
        curRow++;
      }
      // fixing a bug making whole application hang in this loop
      // when 'n' is a wrong character
      if (curRow > V$2) {
        if (rewindMarker) { // making sure that this loop ends
          throw ("Bad character: " + n);
        }
        curRow = A$2;
        rewindMarker = true;
      }
      northingValue += 100000.0;
    }

    return northingValue;
  }

  /**
   * The function getMinNorthing returns the minimum northing value of a MGRS
   * zone.
   *
   * Ported from Geotrans' c Lattitude_Band_Value structure table.
   *
   * @private
   * @param {char} zoneLetter The MGRS zone to get the min northing for.
   * @return {number}
   */
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
    }
    if (northing >= 0.0) {
      return northing;
    }
    else {
      throw ("Invalid zone letter: " + zoneLetter);
    }

  }

  function Point$2(x, y, z) {
    if (!(this instanceof Point$2)) {
      return new Point$2(x, y, z);
    }
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2] || 0.0;
    } else if(typeof x === 'object') {
      this.x = x.x;
      this.y = x.y;
      this.z = x.z || 0.0;
    } else if (typeof x === 'string' && typeof y === 'undefined') {
      var coords = x.split(',');
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0.0;
    } else {
      this.x = x;
      this.y = y;
      this.z = z || 0.0;
    }
    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
  }

  Point$2.fromMGRS = function(mgrsStr) {
    return new Point$2(toPoint(mgrsStr));
  };
  Point$2.prototype.toMGRS = function(accuracy) {
    return forward$s([this.x, this.y], accuracy);
  };

  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.01302083333333333333;
  var C48 = 0.00712076822916666666;
  var C66 = 0.36458333333333333333;
  var C68 = 0.00569661458333333333;
  var C88 = 0.3076171875;

  function pj_enfn(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  }

  function pj_mlfn(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
  }

  var MAX_ITER$3 = 20;

  function pj_inv_mlfn(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER$3; i; --i) { /* rarely goes over 2 iterations */
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
      //phi -= t * (t * Math.sqrt(t)) * k;
      t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    //..reportError("cass:pj_inv_mlfn: Convergence error");
    return phi;
  }

  // Heavily based on this tmerc projection implementation

  function init$s() {
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    if (this.es) {
      this.en = pj_enfn(this.es);
      this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }

  /**
      Transverse Mercator Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$r(p) {
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var con;
    var x, y;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);

    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);

      if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
        return (93);
      }
      else {
        x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y);

        if (b >= 1) {
          if ((b - 1) > EPSLN) {
            return (93);
          }
          else {
            y = 0;
          }
        }
        else {
          y = Math.acos(y);
        }

        if (lat < 0) {
          y = -y;
        }

        y = this.a * this.k0 * (y - this.lat0) + this.y0;
      }
    }
    else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

      x = this.a * (this.k0 * al * (1 +
        als / 6 * (1 - t + c +
        als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
        als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
        this.x0;

      y = this.a * (this.k0 * (ml - this.ml0 +
        sin_phi * delta_lon * al / 2 * (1 +
        als / 12 * (5 - t + 9 * c + 4 * cs +
        als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
        als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
        this.y0;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  /**
      Transverse Mercator Inverse  -  x/y to long/lat
    */
  function inverse$r(p) {
    var con, phi;
    var lat, lon;
    var x = (p.x - this.x0) * (1 / this.a);
    var y = (p.y - this.y0) * (1 / this.a);

    if (!this.es) {
      var f = Math.exp(x / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp = this.lat0 + y / this.k0;
      var h = Math.cos(temp);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);

      if (y < 0) {
        lat = -lat;
      }

      if ((g === 0) && (h === 0)) {
        lon = 0;
      }
      else {
        lon = adjust_lon(Math.atan2(g, h) + this.long0);
      }
    }
    else { // ellipsoidal form
      con = this.ml0 + y / this.k0;
      phi = pj_inv_mlfn(con, this.es, this.en);

      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;

        lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
          ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
          ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
          ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

        lon = adjust_lon(this.long0 + (d * (1 -
          ds / 6 * (1 + 2 * t + c -
          ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
          ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
      }
      else {
        lat = HALF_PI * sign(y);
        lon = 0;
      }
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$s = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  var tmerc = {
    init: init$s,
    forward: forward$r,
    inverse: inverse$r,
    names: names$s
  };

  function sinh(x) {
    var r = Math.exp(x);
    r = (r - 1 / r) / 2;
    return r;
  }

  function hypot(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    var a = Math.max(x, y);
    var b = Math.min(x, y) / (a ? a : 1);

    return a * Math.sqrt(1 + Math.pow(b, 2));
  }

  function log1py(x) {
    var y = 1 + x;
    var z = y - 1;

    return z === 0 ? x : x * Math.log(y) / z;
  }

  function asinhy(x) {
    var y = Math.abs(x);
    y = log1py(y * (1 + y / (hypot(1, y) + 1)));

    return x < 0 ? -y : y;
  }

  function gatg(pp, B) {
    var cos_2B = 2 * Math.cos(2 * B);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;

    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }

    return (B + h * Math.sin(2 * B));
  }

  function clens(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;

    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }

    return Math.sin(arg_r) * hr;
  }

  function cosh(x) {
    var r = Math.exp(x);
    r = (r + 1 / r) / 2;
    return r;
  }

  function clens_cmplx(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh(arg_i);
    var cosh_arg_i = cosh(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;

    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }

    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;

    return [r * hr - i * hi, r * hi + i * hr];
  }

  // Heavily based on this etmerc projection implementation

  function init$r() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    }
    if (this.approx) {
      // When '+approx' is set, use tmerc instead
      tmerc.init.apply(this);
      this.forward = tmerc.forward;
      this.inverse = tmerc.inverse;
    }

    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];

    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;

    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
    this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);

    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

    this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);

    var Z = gatg(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
  }

  function forward$q(p) {
    var Ce = adjust_lon(p.x - this.long0);
    var Cn = p.y;

    Cn = gatg(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy(Math.tan(Ce));

    var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];

    var x;
    var y;

    if (Math.abs(Ce) <= 2.623395162778) {
      x = this.a * (this.Qn * Ce) + this.x0;
      y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    }
    else {
      x = Infinity;
      y = Infinity;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  function inverse$q(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);

    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;

    var lon;
    var lat;

    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh(Ce));

      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

      lon = adjust_lon(Ce + this.long0);
      lat = gatg(this.cgb, Cn);
    }
    else {
      lon = Infinity;
      lat = Infinity;
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$r = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var etmerc = {
    init: init$r,
    forward: forward$q,
    inverse: inverse$q,
    names: names$r
  };

  function adjust_zone(zone, lon) {
    if (zone === undefined) {
      zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  }

  var dependsOn = 'etmerc';


  function init$q() {
    var zone = adjust_zone(this.zone, this.long0);
    if (zone === undefined) {
      throw new Error('unknown utm zone');
    }
    this.lat0 = 0;
    this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R$1;
    this.x0 = 500000;
    this.y0 = this.utmSouth ? 10000000 : 0;
    this.k0 = 0.9996;

    etmerc.init.apply(this);
    this.forward = etmerc.forward;
    this.inverse = etmerc.inverse;
  }

  var names$q = ["Universal Transverse Mercator System", "utm"];
  var utm = {
    init: init$q,
    names: names$q,
    dependsOn: dependsOn
  };

  function srat(esinp, exp) {
    return (Math.pow((1 - esinp) / (1 + esinp), exp));
  }

  var MAX_ITER$2 = 20;

  function init$p() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
  }

  function forward$p(p) {
    var lon = p.x;
    var lat = p.y;

    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }

  function inverse$p(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER$2; i > 0; --i) {
      lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    /* convergence failed */
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$p = ["gauss"];
  var gauss = {
    init: init$p,
    forward: forward$p,
    inverse: inverse$p,
    names: names$p
  };

  function init$o() {
    gauss.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }

  function forward$o(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon(p.x - this.long0);
    gauss.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }

  function inverse$o(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;
    if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    gauss.inverse.apply(this, [p]);
    p.x = adjust_lon(p.x + this.long0);
    return p;
  }

  var names$o = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
  var sterea = {
    init: init$o,
    forward: forward$o,
    inverse: inverse$o,
    names: names$o
  };

  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
  }

  function init$n() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
      }
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          //North pole
          //trace('stere:north pole');
          this.con = 1;
        }
        else {
          //South pole
          //trace('stere:south pole');
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }

  // Stereographic forward equations--mapping lat,long to x,y
  function forward$n(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon(lon - this.long0);

    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      //case of the origine point
      //trace('stere:this is the origin point');
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      //trace('stere:sphere case');
      A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    }
    else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        //trace(p.toString());
        return p;
      }
      else if (Math.abs(this.sinlat0) < EPSLN) {
        //Eq
        //trace('stere:equateur');
        A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A * sinX;
      }
      else {
        //other case
        //trace('stere:normal case');
        A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A * cosX * Math.sin(dlon) + this.x0;
    }
    //trace(p.toString());
    return p;
  }

  //* Stereographic inverse equations--mapping x,y to lat/long
  function inverse$n(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        }
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          //trace(p.toString());
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z(this.e, ts);
        lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        }
        else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;

    //trace(p.toString());
    return p;

  }

  var names$n = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere = {
    init: init$n,
    forward: forward$n,
    inverse: inverse$n,
    names: names$n,
    ssfn_: ssfn_
  };

  /*
    references:
      Formules et constantes pour le Calcul pour la
      projection cylindrique conforme à axe oblique et pour la transformation entre
      des systèmes de référence.
      http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
    */

  function init$m() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e2 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e2);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }

  function forward$m(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;

    // spheric latitude
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

    // spheric longitude
    var I = this.alpha * (p.x - this.lambda0);

    // psoeudo equatorial rotation
    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }

  function inverse$m(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;

    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

    var lambda = this.lambda0 + I / this.alpha;

    var S = 0;
    var phy = b;
    var prevPhy = -1000;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 0.0000001) {
      if (++iteration > 20) {
        //...reportError("omercFwdInfinity");
        return;
      }
      //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }

    p.x = lambda;
    p.y = phy;
    return p;
  }

  var names$m = ["somerc"];
  var somerc = {
    init: init$m,
    forward: forward$m,
    inverse: inverse$m,
    names: names$m
  };

  var TOL = 1e-7;

  function isTypeA(P) {
    var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
    var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
    
    return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
  }


  /* Initialize the Oblique Mercator  projection
      ------------------------------------------*/
  function init$l() {  
    var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
      gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
    
    // only Type A uses the no_off or no_uoff property
    // https://github.com/OSGeo/proj.4/issues/104
    this.no_off = isTypeA(this);
    this.no_rot = 'no_rot' in this;
    
    var alp = false;
    if ("alpha" in this) {
      alp = true;
    }

    var gam = false;
    if ("rectified_grid_angle" in this) {
      gam = true;
    }

    if (alp) {
      alpha_c = this.alpha;
    }
    
    if (gam) {
      gamma = (this.rectified_grid_angle * D2R$1);
    }
    
    if (alp || gam) {
      lamc = this.longc;
    } else {
      lam1 = this.long1;
      phi1 = this.lat1;
      lam2 = this.long2;
      phi2 = this.lat2;
      
      if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
          Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
          Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
        throw new Error();
      }
    }
    
    var one_es = 1.0 - this.es;
    com = Math.sqrt(one_es);
    
    if (Math.abs(this.lat0) > EPSLN) {
      sinph0 = Math.sin(this.lat0);
      cosph0 = Math.cos(this.lat0);
      con = 1 - this.es * sinph0 * sinph0;
      this.B = cosph0 * cosph0;
      this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
      this.A = this.B * this.k0 * com / con;
      D = this.B * com / (cosph0 * Math.sqrt(con));
      F = D * D -1;
      
      if (F <= 0) {
        F = 0;
      } else {
        F = Math.sqrt(F);
        if (this.lat0 < 0) {
          F = -F;
        }
      }
      
      this.E = F += D;
      this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
    } else {
      this.B = 1 / com;
      this.A = this.k0;
      this.E = D = F = 1;
    }
    
    if (alp || gam) {
      if (alp) {
        gamma0 = Math.asin(Math.sin(alpha_c) / D);
        if (!gam) {
          gamma = alpha_c;
        }
      } else {
        gamma0 = gamma;
        alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
    } else {
      H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
      L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
      F = this.E / H;
      p = (L - H) / (L + H);
      J = this.E * this.E;
      J = (J - L * H) / (J + L * H);
      con = lam1 - lam2;
      
      if (con < -Math.pi) {
        lam2 -=TWO_PI;
      } else if (con > Math.pi) {
        lam2 += TWO_PI;
      }
      
      this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
      gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
      gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    
    this.singam = Math.sin(gamma0);
    this.cosgam = Math.cos(gamma0);
    this.sinrot = Math.sin(gamma);
    this.cosrot = Math.cos(gamma);
    
    this.rB = 1 / this.B;
    this.ArB = this.A * this.rB;
    this.BrA = 1 / this.ArB;
    this.A * this.B;
    
    if (this.no_off) {
      this.u_0 = 0;
    } else {
      this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
      
      if (this.lat0 < 0) {
        this.u_0 = - this.u_0;
      }  
    }
      
    F = 0.5 * gamma0;
    this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
    this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
  }


  /* Oblique Mercator forward equations--mapping lat,long to x,y
      ----------------------------------------------------------*/
  function forward$l(p) {
    var coords = {};
    var S, T, U, V, W, temp, u, v;
    p.x = p.x - this.lam0;
    
    if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
      W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
      
      temp = 1 / W;
      S = 0.5 * (W - temp);
      T = 0.5 * (W + temp);
      V = Math.sin(this.B * p.x);
      U = (S * this.singam - V * this.cosgam) / T;
          
      if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
        throw new Error();
      }
      
      v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
      temp = Math.cos(this.B * p.x);
      
      if (Math.abs(temp) < TOL) {
        u = this.A * p.x;
      } else {
        u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
      }    
    } else {
      v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
      u = this.ArB * p.y;
    }
       
    if (this.no_rot) {
      coords.x = u;
      coords.y = v;
    } else {
      u -= this.u_0;
      coords.x = v * this.cosrot + u * this.sinrot;
      coords.y = u * this.cosrot - v * this.sinrot;
    }
    
    coords.x = (this.a * coords.x + this.x0);
    coords.y = (this.a * coords.y + this.y0);
    
    return coords;
  }

  function inverse$l(p) {
    var u, v, Qp, Sp, Tp, Vp, Up;
    var coords = {};
    
    p.x = (p.x - this.x0) * (1.0 / this.a);
    p.y = (p.y - this.y0) * (1.0 / this.a);

    if (this.no_rot) {
      v = p.y;
      u = p.x;
    } else {
      v = p.x * this.cosrot - p.y * this.sinrot;
      u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
    }
    
    Qp = Math.exp(-this.BrA * v);
    Sp = 0.5 * (Qp - 1 / Qp);
    Tp = 0.5 * (Qp + 1 / Qp);
    Vp = Math.sin(this.BrA * u);
    Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
    
    if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
      coords.x = 0;
      coords.y = Up < 0 ? -HALF_PI : HALF_PI;
    } else {
      coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
      coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
      
      if (coords.y === Infinity) {
        throw new Error();
      }
          
      coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
    }
    
    coords.x += this.lam0;
    
    return coords;
  }

  var names$l = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  var omerc = {
    init: init$l,
    forward: forward$l,
    inverse: inverse$l,
    names: names$l
  };

  function init$k() {
    
    //double lat0;                    /* the reference latitude               */
    //double long0;                   /* the reference longitude              */
    //double lat1;                    /* first standard parallel              */
    //double lat2;                    /* second standard parallel             */
    //double r_maj;                   /* major axis                           */
    //double r_min;                   /* minor axis                           */
    //double false_east;              /* x offset in meters                   */
    //double false_north;             /* y offset in meters                   */
    
    //the above value can be set with proj4.defs
    //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

    if (!this.lat2) {
      this.lat2 = this.lat1;
    } //if lat2 is not defined
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }

    var temp = this.b / this.a;
    this.e = Math.sqrt(1 - temp * temp);

    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz(this.e, sin1, cos1);
    var ts1 = tsfnz(this.e, this.lat1, sin1);

    var sin2 = Math.sin(this.lat2);
    var cos2 = Math.cos(this.lat2);
    var ms2 = msfnz(this.e, sin2, cos2);
    var ts2 = tsfnz(this.e, this.lat2, sin2);

    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    }
    else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }

  // Lambert Conformal conic forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$k(p) {

    var lon = p.x;
    var lat = p.y;

    // singular cases :
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign(lat) * (HALF_PI - 2 * EPSLN);
    }

    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    }
    else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

    return p;
  }

  // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$k(p) {

    var rh1, con, ts;
    var lat, lon;
    var x = (p.x - this.x0) / this.k0;
    var y = (this.rh - (p.y - this.y0) / this.k0);
    if (this.ns > 0) {
      rh1 = Math.sqrt(x * x + y * y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(x * x + y * y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2((con * x), (con * y));
    }
    if ((rh1 !== 0) || (this.ns > 0)) {
      con = 1 / this.ns;
      ts = Math.pow((rh1 / (this.a * this.f0)), con);
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    else {
      lat = -HALF_PI;
    }
    lon = adjust_lon(theta / this.ns + this.long0);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$k = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc"
  ];

  var lcc = {
    init: init$k,
    forward: forward$k,
    inverse: inverse$k,
    names: names$k
  };

  function init$j() {
    this.a = 6377397.155;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    /* if scale not set default to 0.9999 */
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448; /* 45 */
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }

  /* ellipsoid */
  /* calculate xy from lat/lon */
  /* Constants, identical to inverse transform function */
  function forward$j(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    /* Transformation */
    gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;

    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return (p);
  }

  /* calculate lat/lon from xy */
  function inverse$j(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;

    /* Transformation */
    /* revert y, x*/
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 0.0000000001) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }

    return (p);
  }

  var names$j = ["Krovak", "krovak"];
  var krovak = {
    init: init$j,
    forward: forward$j,
    inverse: inverse$j,
    names: names$j
  };

  function mlfn(e0, e1, e2, e3, phi) {
    return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
  }

  function e0fn(x) {
    return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
  }

  function e1fn(x) {
    return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
  }

  function e2fn(x) {
    return (0.05859375 * x * x * (1 + 0.75 * x));
  }

  function e3fn(x) {
    return (x * x * x * (35 / 3072));
  }

  function gN(a, e, sinphi) {
    var temp = e * sinphi;
    return a / Math.sqrt(1 - temp * temp);
  }

  function adjust_lat(x) {
    return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
  }

  function imlfn(ml, e0, e1, e2, e3) {
    var phi;
    var dphi;

    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
    return NaN;
  }

  function init$i() {
    if (!this.sphere) {
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }

  /* Cassini forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$i(p) {

    /* Forward equations
        -----------------*/
    var x, y;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);

    if (this.sphere) {
      x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    }
    else {
      //ellipsoid
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

      x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


    }

    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$i(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var phi, lam;

    if (this.sphere) {
      var dd = y + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x));
      lam = Math.atan2(Math.tan(x), Math.cos(dd));
    }
    else {
      /* ellipsoid */
      var ml1 = this.ml0 / this.a + y;
      var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN(this.a, this.e, Math.sin(phi1));

      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

    }

    p.x = adjust_lon(lam + this.long0);
    p.y = adjust_lat(phi);
    return p;

  }

  var names$i = ["Cassini", "Cassini_Soldner", "cass"];
  var cass = {
    init: init$i,
    forward: forward$i,
    inverse: inverse$i,
    names: names$i
  };

  function qsfnz(eccent, sinphi) {
    var con;
    if (eccent > 1.0e-7) {
      con = eccent * sinphi;
      return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
    }
    else {
      return (2 * sinphi);
    }
  }

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  var S_POLE = 1;

  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;

  /* Initialize the Lambert Azimuthal Equal Area projection
    ------------------------------------------------------*/
  function init$h() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    }
    else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    }
    else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;

      this.qp = qsfnz(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
      }
    }
    else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }

  /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$h(p) {

    /* Forward equations
        -----------------*/
    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;

    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y <= EPSLN) {
          return null;
        }
        y = Math.sqrt(2 / y);
        x = y * cosphi * Math.sin(lam);
        y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y = FORTPI - phi * 0.5;
        y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
        x = y * Math.sin(lam);
        y *= coslam;
      }
    }
    else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        }
        else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * ((this.mode === this.S_POLE) ? b : -b);
        }
        else {
          x = y = 0;
        }
        break;
      }
    }

    p.x = this.a * x + this.x0;
    p.y = this.a * y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$h(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0,
        rh, sinz = 0;

      rh = Math.sqrt(x * x + y * y);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
      case this.EQUIT:
        phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
      }
      lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
    }
    else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x /= this.dd;
        y *= this.dd;
        rho = Math.sqrt(x * x + y * y);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x *= (sCe = Math.sin(sCe));
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
        }
        else {
          ab = y * sCe / rho;
          q = this.qp * ab;
          y = rho * cCe;
        }
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y = -y;
        }
        q = (x * x + y * y);
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x, y);
      phi = authlat(Math.asin(ab), this.apa);
    }

    p.x = adjust_lon(this.long0 + lam);
    p.y = phi;
    return p;
  }

  /* determine latitude from authalic latitude */
  var P00 = 0.33333333333333333333;

  var P01 = 0.17222222222222222222;
  var P02 = 0.10257936507936507936;
  var P10 = 0.06388888888888888888;
  var P11 = 0.06640211640211640211;
  var P20 = 0.01641501294219154443;

  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }

  function authlat(beta, APA) {
    var t = beta + beta;
    return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
  }

  var names$h = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea = {
    init: init$h,
    forward: forward$h,
    inverse: inverse$h,
    names: names$h,
    S_POLE: S_POLE,
    N_POLE: N_POLE,
    EQUIT: EQUIT,
    OBLIQ: OBLIQ
  };

  function asinz(x) {
    if (Math.abs(x) > 1) {
      x = (x > 1) ? 1 : -1;
    }
    return Math.asin(x);
  }

  function init$g() {

    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);

    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    }
    else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }

  /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
    -------------------------------------------------------------------*/
  function forward$g(p) {

    var lon = p.x;
    var lat = p.y;

    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);

    var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon(lon - this.long0);
    var x = rh1 * Math.sin(theta) + this.x0;
    var y = this.rh - rh1 * Math.cos(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$g(p) {
    var rh1, qs, con, theta, lon, lat;

    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    }
    else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }

    lon = adjust_lon(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }

  /* Function to compute phi1, the latitude for the inverse of the
     Albers Conical Equal-Area projection.
  -------------------------------------------*/
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }

    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }

  var names$g = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea = {
    init: init$g,
    forward: forward$g,
    inverse: inverse$g,
    names: names$g,
    phi1z: phi1z
  };

  /*
    reference:
      Wolfram Mathworld "Gnomonic Projection"
      http://mathworld.wolfram.com/GnomonicProjection.html
      Accessed: 12th November 2009
    */
  function init$f() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    // Approximation for projecting points to the horizon (infinity)
    this.infinity_dist = 1000 * this.a;
    this.rc = 1;
  }

  /* Gnomonic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$f(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g;
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    }
    else {

      // Point is in the opposing hemisphere and is unprojectable
      // We still need to return a reasonable point, so we project
      // to infinity, on a bearing
      // equivalent to the northern hemisphere equivalent
      // This is a reasonable approximation for short shapes and lines that
      // straddle the horizon.

      x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$f(p) {
    var rh; /* Rho */
    var sinc, cosc;
    var c;
    var lon, lat;

    /* Inverse equations
        -----------------*/
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;

    if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);

      lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon(this.long0 + lon);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$f = ["gnom"];
  var gnom = {
    init: init$f,
    forward: forward$f,
    inverse: inverse$f,
    names: names$f
  };

  function iqsfnz(eccent, q) {
    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
      if (q < 0) {
        return (-1 * HALF_PI);
      }
      else {
        return HALF_PI;
      }
    }
    //var phi = 0.5* q/(1-eccent*eccent);
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
    return NaN;
  }

  /*
    reference:
      "Cartographic Projection Procedures for the UNIX Environment-
      A User's Manual" by Gerald I. Evenden,
      USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  */
  function init$e() {
    //no-op
    if (!this.sphere) {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }

  /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$e(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    }
    else {
      var qs = qsfnz(this.e, Math.sin(lat));
      x = this.x0 + this.a * this.k0 * dlon;
      y = this.y0 + this.a * qs * 0.5 / this.k0;
    }

    p.x = x;
    p.y = y;
    return p;
  }

  /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$e(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;

    if (this.sphere) {
      lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
      lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
    }
    else {
      lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$e = ["cea"];
  var cea = {
    init: init$e,
    forward: forward$e,
    inverse: inverse$e,
    names: names$e
  };

  function init$d() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

    this.rc = Math.cos(this.lat_ts);
  }

  // forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$d(p) {

    var lon = p.x;
    var lat = p.y;

    var dlon = adjust_lon(lon - this.long0);
    var dlat = adjust_lat(lat - this.lat0);
    p.x = this.x0 + (this.a * dlon * this.rc);
    p.y = this.y0 + (this.a * dlat);
    return p;
  }

  // inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$d(p) {

    var x = p.x;
    var y = p.y;

    p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
    p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
    return p;
  }

  var names$d = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc = {
    init: init$d,
    forward: forward$d,
    inverse: inverse$d,
    names: names$d
  };

  var MAX_ITER$1 = 20;

  function init$c() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
  }

  /* Polyconic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$c(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y, el;
    var dlon = adjust_lon(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.a * this.lat0;
      }
      else {
        x = this.a * Math.sin(el) / Math.tan(lat);
        y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    }
    else {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.ml0;
      }
      else {
        var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x = nl * Math.sin(el);
        y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }

    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$c(p) {
    var lon, lat, x, y, i;
    var al, bl;
    var phi, dphi;
    x = p.x - this.x0;
    y = p.y - this.y0;

    if (this.sphere) {
      if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon(x / this.a + this.long0);
        lat = 0;
      }
      else {
        al = this.lat0 + y / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER$1; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
      }
    }
    else {
      if (Math.abs(y + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon(this.long0 + x / this.a);
      }
      else {

        al = (this.ml0 + y) / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER$1; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }

        //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$c = ["Polyconic", "poly"];
  var poly = {
    init: init$c,
    forward: forward$c,
    inverse: inverse$c,
    names: names$c
  };

  function init$b() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -0.0055161;
    this.A[7] = 0.0026906;
    this.A[8] = -0.001333;
    this.A[9] = 0.00067;
    this.A[10] = -0.00034;

    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 0.003371507;
    this.B_re[3] = -0.001541739;
    this.B_im[3] = 0.041058560;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;

    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -0.007809598;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;

    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 0.007317;
    this.D[7] = 0.01220;
    this.D[8] = 0.00394;
    this.D[9] = -0.0013;
  }

  /**
      New Zealand Map Grid Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$b(p) {
    var n;
    var lon = p.x;
    var lat = p.y;

    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;

    // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
    // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
    var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1; // d_phi^0

    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }

    // 2. Calculate theta
    var th_re = d_psi;
    var th_im = d_lambda;

    // 3. Calculate z
    var th_n_re = 1;
    var th_n_im = 0; // theta^0
    var th_n_re1;
    var th_n_im1;

    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }

    // 4. Calculate easting and northing
    p.x = (z_im * this.a) + this.x0;
    p.y = (z_re * this.a) + this.y0;

    return p;
  }

  /**
      New Zealand Map Grid Inverse  -  x/y to long/lat
    */
  function inverse$b(p) {
    var n;
    var x = p.x;
    var y = p.y;

    var delta_x = x - this.x0;
    var delta_y = y - this.y0;

    // 1. Calculate z
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;

    // 2a. Calculate theta - first approximation gives km accuracy
    var z_n_re = 1;
    var z_n_im = 0; // z^0
    var z_n_re1;
    var z_n_im1;

    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }

    // 2b. Iterate to refine the accuracy of the calculation
    //        0 iterations gives km accuracy
    //        1 iteration gives m accuracy -- good enough for most mapping applications
    //        2 iterations bives mm accuracy
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;

      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      // Complex division
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }

    // 3. Calculate d_phi              ...                                    // and d_lambda
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1; // d_psi^0

    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }

    // 4. Calculate latitude and longitude
    // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
    var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
    var lon = this.long0 + d_lambda;

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$b = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg = {
    init: init$b,
    forward: forward$b,
    inverse: inverse$b,
    names: names$b
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */


  /* Initialize the Miller Cylindrical projection
    -------------------------------------------*/
  function init$a() {
    //no-op
  }

  /* Miller Cylindrical forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$a(p) {
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x = this.x0 + this.a * dlon;
    var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

    p.x = x;
    p.y = y;
    return p;
  }

  /* Miller Cylindrical inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$a(p) {
    p.x -= this.x0;
    p.y -= this.y0;

    var lon = adjust_lon(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$a = ["Miller_Cylindrical", "mill"];
  var mill = {
    init: init$a,
    forward: forward$a,
    inverse: inverse$a,
    names: names$a
  };

  var MAX_ITER = 20;


  function init$9() {
    /* Place parameters in static storage for common use
      -------------------------------------------------*/


    if (!this.sphere) {
      this.en = pj_enfn(this.es);
    }
    else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }

  }

  /* Sinusoidal forward equations--mapping lat,long to x,y
    -----------------------------------------------------*/
  function forward$9(p) {
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
      -----------------*/
    lon = adjust_lon(lon - this.long0);

    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      }
      else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER; i; --i) {
          var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V;
          if (Math.abs(V) < EPSLN) {
            break;
          }
        }
      }
      x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y = this.a * this.C_y * lat;

    }
    else {

      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y = this.a * pj_mlfn(lat, s, c, this.en);
      x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$9(p) {
    var lat, temp, lon, s;

    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;

    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
      }
      else if (this.n !== 1) {
        lat = asinz(Math.sin(lat) / this.n);
      }
      lon = adjust_lon(lon + this.long0);
      lat = adjust_lat(lat);
    }
    else {
      lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        //temp = this.long0 + p.x / (this.a * Math.cos(lat));
        lon = adjust_lon(temp);
      }
      else if ((s - EPSLN) < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$9 = ["Sinusoidal", "sinu"];
  var sinu = {
    init: init$9,
    forward: forward$9,
    inverse: inverse$9,
    names: names$9
  };

  function init$8() {}
  /* Mollweide forward equations--mapping lat,long to x,y
      ----------------------------------------------------*/
  function forward$8(p) {

    /* Forward equations
        -----------------*/
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);

    /* Iterate using the Newton-Raphson method to find theta
        -----------------------------------------------------*/
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;

    /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
         this is done here because of precision problems with "cos(theta)"
         --------------------------------------------------------------------------*/
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$8(p) {
    var theta;
    var arg;

    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);

    /* Because of division by zero problems, 'arg' can not be 1.  Therefore
         a number very close to one is used instead.
         -------------------------------------------------------------------*/
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
    if (lon < (-Math.PI)) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$8 = ["Mollweide", "moll"];
  var moll = {
    init: init$8,
    forward: forward$8,
    inverse: inverse$8,
    names: names$8
  };

  function init$7() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);

    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);

    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    }
    else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }

  /* Equidistant Conic forward equations--mapping lat,long to x,y
    -----------------------------------------------------------*/
  function forward$7(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;

    /* Forward equations
        -----------------*/
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    }
    else {
      var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    var x = this.x0 + rh1 * Math.sin(theta);
    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x;
    p.y = y;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$7(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }

    if (this.sphere) {
      lon = adjust_lon(this.long0 + theta / this.ns);
      lat = adjust_lat(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }

  }

  var names$7 = ["Equidistant_Conic", "eqdc"];
  var eqdc = {
    init: init$7,
    forward: forward$7,
    inverse: inverse$7,
    names: names$7
  };

  /* Initialize the Van Der Grinten projection
    ----------------------------------------*/
  function init$6() {
    //this.R = 6370997; //Radius of earth
    this.R = this.a;
  }

  function forward$6(p) {

    var lon = p.x;
    var lat = p.y;

    /* Forward equations
      -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x, y;

    if (Math.abs(lat) <= EPSLN) {
      x = this.x0 + this.R * dlon;
      y = this.y0;
    }
    var theta = asinz(2 * Math.abs(lat / Math.PI));
    if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
      x = this.x0;
      if (lat >= 0) {
        y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      }
      else {
        y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
      //  return(OK);
    }
    var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);

    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x = this.x0 + con;
    //con = Math.abs(con / (Math.PI * this.R));
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 + con;
    }
    else {
      //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 - con;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Van Der Grinten inverse equations--mapping x,y to lat/long
    ---------------------------------------------------------*/
  function inverse$6(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;

    /* inverse equations
      -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = ((3 * d) / a1) / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      }
      else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }

    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$6 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg = {
    init: init$6,
    forward: forward$6,
    inverse: inverse$6,
    names: names$6
  };

  function init$5() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }

  function forward$5(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon(lon - this.long0);
    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      }
      else {
        //default case
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      }
      else {
        //Default case
        tanphi = sinphi / cosphi;
        Nl1 = gN(this.a, this.e, this.sin_p12);
        Nl = gN(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }


  }

  function inverse$5(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > (2 * HALF_PI * this.a)) {
        return;
      }
      z = rh / this.a;

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      }
      else {
        lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
          }
          else {
            lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
          }
        }
        else {
          /*con = cosz - this.sin_p12 * Math.sin(lat);
          if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
            //no-op, just keep the lon value as is
          } else {
            var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
            lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
          }*/
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;

        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        //default case
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A = -tmp * tmp / (1 - this.es);
        B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
        F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }

  }

  var names$5 = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd = {
    init: init$5,
    forward: forward$5,
    inverse: inverse$5,
    names: names$5
  };

  function init$4() {
    //double temp;      /* temporary variable    */

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }

  /* Orthographic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$4(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g, x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.a * ksp * cosphi * Math.sin(dlon);
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$4(p) {
    var rh; /* height above ellipsoid      */
    var z; /* angle          */
    var sinz, cosz; /* sin of z and cos of z      */
    var con;
    var lon, lat;
    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z = asinz(rh / this.a);

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
      }
      else {
        lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$4 = ["ortho"];
  var ortho = {
    init: init$4,
    forward: forward$4,
    inverse: inverse$4,
    names: names$4
  };

  // QSC projection rewritten from the original PROJ4

  /* constants */
  var FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
  };

  var AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
  };

  function init$3() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";

    /* Determine the cube face from the center of projection. */
    if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }

    /* Fill in useful values for the ellipsoid <-> sphere shift
     * described in [LK12]. */
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }

  // QSC forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$3(p) {
    var xy = {x: 0, y: 0};
    var lat, lon;
    var theta, phi;
    var t, mu;
    /* nu; */
    var area = {value: 0};

    // move lon according to projection's lon
    p.x -= this.long0;

    /* Convert the geodetic latitude to a geocentric latitude.
     * This corresponds to the shift from the ellipsoid to the sphere
     * described in [LK12]. */
    if (this.es !== 0) {//if (P->es != 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }

    /* Convert the input lat, lon into theta, phi as used by QSC.
     * This depends on the cube face and the area on it.
     * For the top and bottom face, we can compute theta and phi
     * directly from phi, lam. For the other faces, we must use
     * unit sphere cartesian coordinates as an intermediate step. */
    lon = p.x; //lon = lp.lam;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_1;
        theta = (lon > 0.0 ? lon - SPI : lon + SPI);
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;

      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;

      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area);
      } else {
        /* Impossible */
        phi = theta = 0;
        area.value = AREA_ENUM.AREA_0;
      }
    }

    /* Compute mu and nu for the area of definition.
     * For mu, see Eq. (3-21) in [OL76], but note the typos:
     * compare with Eq. (3-14). For nu, see Eq. (3-38). */
    mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

    /* Apply the result to the real area. */
    if (area.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }

    /* Now compute x, y from mu and nu */
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;

    p.x = xy.x;
    p.y = xy.y;
    return p;
  }

  // QSC inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$3(p) {
    var lp = {lam: 0, phi: 0};
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area = {value: 0};

    /* de-offset */
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    /* Convert the input x, y to the mu and nu angles as used by QSC.
     * This depends on the area of the cube face. */
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
      area.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_2;
      mu = (mu < 0.0 ? mu + SPI : mu - SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }

    /* Compute phi and theta for the area of definition.
     * The inverse projection is not described in the original paper, but some
     * good hints can be found here (as of 2011-12-14):
     * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
     * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
    t = (SPI / 12) * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > +1) {
      cosphi = +1;
    }

    /* Apply the result to the real area on the cube face.
     * For the top and bottom face, we can compute phi and lam directly.
     * For the other faces, we must use unit sphere cartesian coordinates
     * as an intermediate step. */
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = theta;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
      }
    } else {
      /* Compute phi and lam via cartesian unit sphere coordinates. */
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      /* Rotate q,r,s into the correct area. */
      if (area.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      /* Rotate q,r,s into the correct cube face. */
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      /* Now compute phi and lam from the unit sphere coordinates. */
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }

    /* Apply the shift from the sphere to the ellipsoid as described
     * in [LK12]. */
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = (lp.phi < 0 ? 1 : 0);
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }

    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }

  /* Helper function for forward projection: compute the theta angle
   * and determine the area number. */
  function qsc_fwd_equat_face_theta(phi, y, x, area) {
    var theta;
    if (phi < EPSLN) {
      area.value = AREA_ENUM.AREA_0;
      theta = 0.0;
    } else {
      theta = Math.atan2(y, x);
      if (Math.abs(theta) <= FORTPI) {
        area.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }

  /* Helper function: shift the longitude. */
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }

  var names$3 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc = {
    init: init$3,
    forward: forward$3,
    inverse: inverse$3,
    names: names$3
  };

  // Robinson projection

  var COEFS_X = [
      [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
      [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
      [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
      [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
      [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
      [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
      [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
      [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
      [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
      [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
      [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
      [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
      [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
      [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
      [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
      [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
      [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
      [0.5722, -0.00906601, 0.000182, 6.24051e-06],
      [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
  ];

  var COEFS_Y = [
      [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
      [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
      [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
      [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
      [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
      [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
      [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
      [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
      [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
      [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
      [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
      [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
      [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
      [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
      [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
      [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
      [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
      [0.9761, 0.00616527, -0.000256, -4.2106e-06],
      [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
  ];

  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D/5; // rad to 5-degree interval
  var RC1 = 1/C1;
  var NODES = 18;

  var poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
  };

  var poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
  };

  function newton_rapshon(f_df, start, max_err, iters) {
      var x = start;
      for (; iters; --iters) {
          var upd = f_df(x);
          x -= upd;
          if (Math.abs(upd) < max_err) {
              break;
          }
      }
      return x;
  }

  function init$2() {
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.long0 = this.long0 || 0;
      this.es = 0;
      this.title = this.title || "Robinson";
  }

  function forward$2(ll) {
      var lon = adjust_lon(ll.x - this.long0);

      var dphi = Math.abs(ll.y);
      var i = Math.floor(dphi * C1);
      if (i < 0) {
          i = 0;
      } else if (i >= NODES) {
          i = NODES - 1;
      }
      dphi = R2D * (dphi - RC1 * i);
      var xy = {
          x: poly3_val(COEFS_X[i], dphi) * lon,
          y: poly3_val(COEFS_Y[i], dphi)
      };
      if (ll.y < 0) {
          xy.y = -xy.y;
      }

      xy.x = xy.x * this.a * FXC + this.x0;
      xy.y = xy.y * this.a * FYC + this.y0;
      return xy;
  }

  function inverse$2(xy) {
      var ll = {
          x: (xy.x - this.x0) / (this.a * FXC),
          y: Math.abs(xy.y - this.y0) / (this.a * FYC)
      };

      if (ll.y >= 1) { // pathologic case
          ll.x /= COEFS_X[NODES][0];
          ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
      } else {
          // find table interval
          var i = Math.floor(ll.y * NODES);
          if (i < 0) {
              i = 0;
          } else if (i >= NODES) {
              i = NODES - 1;
          }
          for (;;) {
              if (COEFS_Y[i][0] > ll.y) {
                  --i;
              } else if (COEFS_Y[i+1][0] <= ll.y) {
                  ++i;
              } else {
                  break;
              }
          }
          // linear interpolation in 5 degree interval
          var coefs = COEFS_Y[i];
          var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
          // find t so that poly3_val(coefs, t) = ll.y
          t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
          }, t, EPSLN, 100);

          ll.x /= poly3_val(COEFS_X[i], t);
          ll.y = (5 * i + t) * D2R$1;
          if (xy.y < 0) {
              ll.y = -ll.y;
          }
      }

      ll.x = adjust_lon(ll.x + this.long0);
      return ll;
  }

  var names$2 = ["Robinson", "robin"];
  var robin = {
    init: init$2,
    forward: forward$2,
    inverse: inverse$2,
    names: names$2
  };

  function init$1() {
      this.name = 'geocent';

  }

  function forward$1(p) {
      var point = geodeticToGeocentric(p, this.es, this.a);
      return point;
  }

  function inverse$1(p) {
      var point = geocentricToGeodetic(p, this.es, this.a, this.b);
      return point;
  }

  var names$1 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
  var geocent = {
      init: init$1,
      forward: forward$1,
      inverse: inverse$1,
      names: names$1
  };

  var mode = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  };

  var params = {
    h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
    azi:   { def: 0, num: true, degrees: true }, // default is North
    tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
    long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
    lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
  };

  function init() {
    Object.keys(params).forEach(function (p) {
      if (typeof this[p] === "undefined") {
        this[p] = params[p].def;
      } else if (params[p].num && isNaN(this[p])) {
        throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
      } else if (params[p].num) {
        this[p] = parseFloat(this[p]);
      }
      if (params[p].degrees) {
        this[p] = this[p] * D2R$1;
      }
    }.bind(this));

    if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
      this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
    } else if (Math.abs(this.lat0) < EPSLN) {
      this.mode = mode.EQUIT;
    } else {
      this.mode = mode.OBLIQ;
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }

    this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

    if (this.pn1 <= 0 || this.pn1 > 1e10) {
      throw new Error("Invalid height");
    }
    
    this.p = 1 + this.pn1;
    this.rp = 1 / this.p;
    this.h1 = 1 / this.pn1;
    this.pfact = (this.p + 1) * this.h1;
    this.es = 0;

    var omega = this.tilt;
    var gamma = this.azi;
    this.cg = Math.cos(gamma);
    this.sg = Math.sin(gamma);
    this.cw = Math.cos(omega);
    this.sw = Math.sin(omega);
  }

  function forward(p) {
    p.x -= this.long0;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var coslam = Math.cos(p.x);
    var x, y;
    switch (this.mode) {
      case mode.OBLIQ:
        y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y = cosphi * coslam;
        break;
      case mode.S_POLE:
        y = -sinphi;
        break;
      case mode.N_POLE:
        y = sinphi;
        break;
    }
    y = this.pn1 / (this.p - y);
    x = y * cosphi * Math.sin(p.x);

    switch (this.mode) {
      case mode.OBLIQ:
        y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y *= sinphi;
        break;
      case mode.N_POLE:
        y *= -(cosphi * coslam);
        break;
      case mode.S_POLE:
        y *= cosphi * coslam;
        break;
    }

    // Tilt 
    var yt, ba;
    yt = y * this.cg + x * this.sg;
    ba = 1 / (yt * this.sw * this.h1 + this.cw);
    x = (x * this.cg - y * this.sg) * this.cw * ba;
    y = yt * ba;

    p.x = x * this.a;
    p.y = y * this.a;
    return p;
  }

  function inverse(p) {
    p.x /= this.a;
    p.y /= this.a;
    var r = { x: p.x, y: p.y };

    // Un-Tilt
    var bm, bq, yt;
    yt = 1 / (this.pn1 - p.y * this.sw);
    bm = this.pn1 * p.x * yt;
    bq = this.pn1 * p.y * this.cw * yt;
    p.x = bm * this.cg + bq * this.sg;
    p.y = bq * this.cg - bm * this.sg;

    var rh = hypot(p.x, p.y);
    if (Math.abs(rh) < EPSLN) {
      r.x = 0;
      r.y = p.y;
    } else {
      var cosz, sinz;
      sinz = 1 - rh * rh * this.pfact;
      sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
      cosz = Math.sqrt(1 - sinz * sinz);
      switch (this.mode) {
        case mode.OBLIQ:
          r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
          p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
          p.x *= sinz * this.cosph0;
          break;
        case mode.EQUIT:
          r.y = Math.asin(p.y * sinz / rh);
          p.y = cosz * rh;
          p.x *= sinz;
          break;
        case mode.N_POLE:
          r.y = Math.asin(cosz);
          p.y = -p.y;
          break;
        case mode.S_POLE:
          r.y = -Math.asin(cosz);
          break;
      }
      r.x = Math.atan2(p.x, p.y);
    }

    p.x = r.x + this.long0;
    p.y = r.y;
    return p;
  }

  var names = ["Tilted_Perspective", "tpers"];
  var tpers = {
    init: init,
    forward: forward,
    inverse: inverse,
    names: names
  };

  function includedProjections(proj4){
    proj4.Proj.projections.add(tmerc);
    proj4.Proj.projections.add(etmerc);
    proj4.Proj.projections.add(utm);
    proj4.Proj.projections.add(sterea);
    proj4.Proj.projections.add(stere);
    proj4.Proj.projections.add(somerc);
    proj4.Proj.projections.add(omerc);
    proj4.Proj.projections.add(lcc);
    proj4.Proj.projections.add(krovak);
    proj4.Proj.projections.add(cass);
    proj4.Proj.projections.add(laea);
    proj4.Proj.projections.add(aea);
    proj4.Proj.projections.add(gnom);
    proj4.Proj.projections.add(cea);
    proj4.Proj.projections.add(eqc);
    proj4.Proj.projections.add(poly);
    proj4.Proj.projections.add(nzmg);
    proj4.Proj.projections.add(mill);
    proj4.Proj.projections.add(sinu);
    proj4.Proj.projections.add(moll);
    proj4.Proj.projections.add(eqdc);
    proj4.Proj.projections.add(vandg);
    proj4.Proj.projections.add(aeqd);
    proj4.Proj.projections.add(ortho);
    proj4.Proj.projections.add(qsc);
    proj4.Proj.projections.add(robin);
    proj4.Proj.projections.add(geocent);
    proj4.Proj.projections.add(tpers);
  }

  proj4.defaultDatum = 'WGS84'; //default datum
  proj4.Proj = Projection;
  proj4.WGS84 = new proj4.Proj('WGS84');
  proj4.Point = Point$2;
  proj4.toPoint = common;
  proj4.defs = defs;
  proj4.nadgrid = nadgrid;
  proj4.transform = transform$4;
  proj4.mgrs = mgrs;
  proj4.version = '__VERSION__';
  includedProjections(proj4);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var download_min = {exports: {}};

  (function (module, exports) {
  (function(r,l){module.exports=l();})(commonjsGlobal,function(){return function l(a,e,k){function q(a){var h=a.split(/[:;,]/);a=h[1];var h=("base64"==h[2]?atob:decodeURIComponent)(h.pop()),d=h.length,b=0,c=new Uint8Array(d);for(b;b<d;++b)c[b]=h.charCodeAt(b);return new f([c],{type:a})}function m(a,b){if("download"in d)return d.href=a,d.setAttribute("download",n),d.className="download-js-link",d.innerHTML="downloading...",d.style.display="none",document.body.appendChild(d),setTimeout(function(){d.click(),document.body.removeChild(d),!0===b&&setTimeout(function(){g.URL.revokeObjectURL(d.href);},250);},66),!0;if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent))return /^data:/.test(a)&&(a="data:"+a.replace(/^data:([\w\/\-\+]+)/,"application/octet-stream")),!window.open(a)&&confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")&&(location.href=a),!0;var c=document.createElement("iframe");document.body.appendChild(c),!b&&/^data:/.test(a)&&(a="data:"+a.replace(/^data:([\w\/\-\+]+)/,"application/octet-stream")),c.src=a,setTimeout(function(){document.body.removeChild(c);},333);}var g=window,b=k||"application/octet-stream",c=!e&&!k&&a,d=document.createElement("a");k=function(a){return String(a)};var f=g.Blob||g.MozBlob||g.WebKitBlob||k,n=e||"download",f=f.call?f.bind(g):Blob;"true"===String(this)&&(a=[a,b],b=a[0],a=a[1]);if(c&&2048>c.length&&(n=c.split("/").pop().split("?")[0],d.href=c,-1!==d.href.indexOf(c))){var p=new XMLHttpRequest;return p.open("GET",c,!0),p.responseType="blob",p.onload=function(a){l(a.target.response,n,"application/octet-stream");},setTimeout(function(){p.send();},0),p}if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(a)){if(!(2096103.424<a.length&&f!==k))return navigator.msSaveBlob?navigator.msSaveBlob(q(a),n):m(a);a=q(a),b=a.type||"application/octet-stream";}else if(/([\x80-\xff])/.test(a)){e=0;var c=new Uint8Array(a.length),t=c.length;for(e;e<t;++e)c[e]=a.charCodeAt(e);a=new f([c],{type:b});}a=a instanceof f?a:new f([a],{type:b});if(navigator.msSaveBlob)return navigator.msSaveBlob(a,n);if(g.URL)m(g.URL.createObjectURL(a),!0);else {if("string"==typeof a||a.constructor===k)try{return m("data:"+b+";base64,"+g.btoa(a))}catch(h){return m("data:"+b+","+encodeURIComponent(a))}b=new FileReader,b.onload=function(a){m(this.result);},b.readAsDataURL(a);}return !0}});
  }(download_min));

  var download = download_min.exports;

  /**
   * 错误提示
   *
   * @export
   * @enum {number}
   */
  var ErrorNotification;
  (function (ErrorNotification) {
      ErrorNotification["NOT_IMPLEMENTED"] = "\u672A\u5B9E\u73B0";
      ErrorNotification["NOT_SUPPORTED"] = "\u6B64\u529F\u80FD\u8BE5\u5F15\u64CE\u4E0D\u652F\u6301";
      ErrorNotification["NOT_COMMEND"] = "\u8BE5\u56FE\u5C42\u4E3A\u805A\u5408\u56FE\u5C42\u65F6\uFF0C\u4E0D\u63A8\u8350\u4F7F\u7528\u8BE5\u65B9\u6CD5\u6DFB\u52A0\u8981\u7D20\uFF0C\u6B64\u65B9\u6CD5\u65E0\u6548\uFF0C\u8BF7\u4F7F\u7528addFeatures\u65B9\u6CD5\u6DFB\u52A0\u8981\u7D20";
      ErrorNotification["DESTROYED"] = "\u5BF9\u8C61\u5DF2\u88AB\u9500\u6BC1";
      ErrorNotification["UNEXPECTED_DATA_FORMAT"] = "\u4E1A\u52A1\u6570\u636E\u683C\u5F0F\u9519\u8BEF";
      ErrorNotification["UNSUPPORTED_PARAM"] = "\u53C2\u6570\u9519\u8BEF";
      ErrorNotification["OPTIONS_UNDEFINED"] = "\u53C2\u6570\u672A\u5B9A\u4E49";
      ErrorNotification["NOT_SUPPORTED_STYLE_TYPE"] = "\u4E0D\u652F\u6301\u8BE5\u7C7B\u578B\u6837\u5F0F";
      ErrorNotification["WALL_COORDINATES_NEED_HEIGHT"] = "\u5899\u4F53\u5750\u6807\u9700\u8981\u8BBE\u7F6E\u9AD8\u5EA6";
      ErrorNotification["NOT_ADD_MAP"] = "\u8BE5\u793A\u4F8B\u672A\u6DFB\u52A0\u5230\u5730\u56FE\u4E2D\uFF0C\u65E0\u6CD5\u6FC0\u6D3B";
      ErrorNotification["NOT_SUPPORTED_GEOJSON_TYPE"] = "geoJson\u7C7B\u578B\u6709\u8BEF";
      ErrorNotification["NOT_MODELTYPE_SUPPORTED"] = "\u8BE5\u6A21\u578B\u5E95\u5C42\u4F7F\u7528\u56FE\u5143\u6E32\u67D3\uFF0C\u4E0D\u652F\u6301\u81EA\u65CB\u8F6C\u52A8\u753B\uFF0C\u8BF7\u5B9E\u4F8B\u5316\u8BE5\u6A21\u578B\u65F6\u6307\u660E\u8BE5\u6A21\u578B\u7C7B\u578B\u4E3A\u5B9E\u4F53\uFF0C\u6216\u8005\u4F7F\u7528\u9ED8\u8BA4";
      ErrorNotification["ADDED_FEATURE"] = "\u8BE5\u8981\u7D20\u5DF2\u6DFB\u52A0\u81F3\u56FE\u5C42\uFF0C\u8BF7\u52FF\u518D\u6B21\u6DFB\u52A0";
  })(ErrorNotification || (ErrorNotification = {}));

  /**
   * 内部公共方法  不外暴露
   */
  /**
   * 判断className是否具有后续传入的名称,不需要则添加
   */
  function initClassName(className, defaultName) {
      var e_1, _a;
      if (defaultName === void 0) { defaultName = []; }
      className || (className = "");
      Array.isArray(defaultName) || (defaultName = [defaultName]);
      try {
          for (var defaultName_1 = __values(defaultName), defaultName_1_1 = defaultName_1.next(); !defaultName_1_1.done; defaultName_1_1 = defaultName_1.next()) {
              var name_1 = defaultName_1_1.value;
              className.includes(name_1) || (className = className + " " + name_1);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (defaultName_1_1 && !defaultName_1_1.done && (_a = defaultName_1.return)) _a.call(defaultName_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
      return className;
  }
  /**
   * 删除对象所有属性
   *
   * @param object
   */
  function clearProperty(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * 首字母大写
   *
   * @param {string} text
   * @returns {string}
   */
  function upperCaseFirstWord(text) {
      return text && text.slice(0, 1).toLocaleUpperCase() + text.slice(1, text.length);
  }
  function initTooltipElement() {
      var dom = document.createElement("div");
      dom.classList.add("tooltip-container");
      dom.classList.add("is-top");
      dom.classList.add("is-dark");
      dom.appendChild(document.createElement("div"));
      var arrow = document.createElement("div");
      arrow.classList.add("popper-arrow");
      dom.appendChild(arrow);
      return dom;
  }
  /**
   * @ignore
   */
  function replaceText(text, properties) {
      var e_2, _a;
      if (properties === void 0) { properties = {}; }
      if (/{|}/g.test(text)) {
          try {
              for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var key = _c.value;
                  text = text.replace(new RegExp("{" + key + "}", "g"), properties[key]);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
      }
      return text;
  }
  function createContextMenuElement(options, event) {
      var e_3, _a;
      var menuElement = document.createElement("ul");
      menuElement.classList.add("context-menu");
      menuElement.classList.add(options.theme);
      try {
          for (var _b = __values(options.list), _c = _b.next(); !_c.done; _c = _b.next()) {
              var item = _c.value;
              var itemElement = document.createElement("li");
              itemElement.classList.add("item");
              itemElement.innerHTML = item.text;
              itemElement.setAttribute("data-id", item.id);
              menuElement.appendChild(itemElement);
              itemElement.onclick = event;
          }
      }
      catch (e_3_1) { e_3 = { error: e_3_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_3) throw e_3.error; }
      }
      return menuElement;
  }
  function clearContextMenuElementEvent(element) {
      var e_4, _a;
      try {
          for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
              var iterator = _c.value;
              iterator.onclick = void 0;
          }
      }
      catch (e_4_1) { e_4 = { error: e_4_1 }; }
      finally {
          try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_4) throw e_4.error; }
      }
  }
  /**
   * 设置要素坐标系配置
   *
   * @param this
   * @param options
   */
  function setFeatureProjection(options) {
      if (options === null || options === void 0 ? void 0 : options.dataProjection) {
          this._dataProjection = options === null || options === void 0 ? void 0 : options.dataProjection;
      }
      if (options === null || options === void 0 ? void 0 : options.projection) {
          this._projection = options === null || options === void 0 ? void 0 : options.projection;
      }
      if (options === null || options === void 0 ? void 0 : options.offset) {
          this._offset = options === null || options === void 0 ? void 0 : options.offset;
      }
  }
  function isObject$9(value) {
      var type = typeof value;
      return value !== null && (type === "object" || type === "function");
  }
  function vertifyParam(options, keys) {
      var e_5, _a;
      if (keys === void 0) { keys = []; }
      if (!defined$1(options)) {
          throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
      }
      try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
              var key = keys_1_1.value;
              if (!defined$1(getValueByChaining(options, key))) {
                  throw new Error("".concat(key, " ").concat(ErrorNotification.OPTIONS_UNDEFINED));
              }
          }
      }
      catch (e_5_1) { e_5 = { error: e_5_1 }; }
      finally {
          try {
              if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          }
          finally { if (e_5) throw e_5.error; }
      }
  }
  /**
   * 链式取值
   */
  function getValueByChaining(target, chaining) {
      return chaining.split(".").reduce(function (prev, curr) {
          return prev === null || prev === void 0 ? void 0 : prev[curr];
      }, target);
  }
  function computeRotationRadians(startCoordinates, endCoordinates) {
      return ((Math.PI * 2.5 - Math.atan2(endCoordinates[1] - startCoordinates[1], endCoordinates[0] - startCoordinates[0])) %
          (Math.PI * 2));
  }

  /**
   * 判断对象是否存在
   *
   * @param val
   * @returns
   */
  function defined$1(val) {
      return val !== void 0 && val !== null;
  }
  /**
   * 角度转弧度
   *
   * @param degrees 角度值
   * @returns
   */
  function toRadians(degrees) {
      return (degrees * Math.PI) / 180;
  }
  /**
   * 弧度转角度
   *
   * @param radians 弧度值
   * @returns
   */
  function toDegrees(radians) {
      return (radians * 180) / Math.PI;
  }
  /**
   * 经纬度圆半径转化为投影圆半径
   *
   * @ignore
   * @param center
   * @param radius
   * @returns
   */
  function convertToProjectionRadius(center, radius, featureProjection) {
      if (featureProjection === void 0) { featureProjection = PUBLIC_CONFIG.projection; }
      return (transformInternal(Turf__namespace.transformTranslate(Turf__namespace.point(center), radius / 1000, 90).geometry.coordinates, {
          source: WGS84_PROJECTION_NAME,
          destination: featureProjection
      })[0] - transformInternal(center, { source: WGS84_PROJECTION_NAME, destination: featureProjection })[0]);
  }
  /**
   * 将投影圆半径转化为经纬度圆半径
   *
   * @ignore
   * @param point
   * @param distance
   * @returns
   */
  function calculatesDistance(point, distance) {
      return Number.parseFloat((Turf__namespace.distance(transformToDataProjection(point), transformToDataProjection([point[0], point[1] + distance])) * 1000).toFixed(4));
  }
  /**
   * @ignore
   * @param start
   * @param end
   * @returns
   */
  function calculatesRadius(start, end) {
      return Number.parseFloat(Turf__namespace.distance(start, end).toFixed(4));
  }
  /**
   * @ignore
   * @param center
   * @param radius
   * @returns
   */
  function getCircleCoordinates(center, radius) {
      return Turf__namespace.circle(center, radius, { steps: 20, units: "kilometers" }).geometry.coordinates[0];
  }
  /**
   * 根据起始点生成经过两点之间的抛物线的坐标数组
   */
  function createParabola(
  /**
   * 起始点GeoJSON
   */
  startPoint, 
  /**
   * 结束点GeoJSON
   */
  endPoint, options) {
      if (options === void 0) { options = {}; }
      var _a = options.heightProportion, heightProportion = _a === void 0 ? 0.125 : _a, _b = options.step, step = _b === void 0 ? 60 : _b;
      var _c = __read(startPoint, 3), lng1 = _c[0], lat1 = _c[1], _d = _c[2], height1 = _d === void 0 ? 0 : _d;
      var _e = __read(endPoint, 3), lng2 = _e[0], lat2 = _e[1], _f = _e[2], height2 = _f === void 0 ? 0 : _f;
      // const heightProportion = 0.125 // 最高点和总距离的比值
      var dLon = (lng2 - lng1) / step;
      var dLat = (lat2 - lat1) / step;
      var dHei = (height2 - height1) / step;
      var deltaLon = dLon * Math.abs(111000 * Math.cos((lat1 / 180) * Math.PI)); // 经度差（米）
      var deltaLat = dLat * 111000; // 纬度差(米)
      var interPolatePoint = [];
      interPolatePoint.push([lng1, lat1, height1]);
      var height = (step * Math.sqrt(deltaLon * deltaLon + deltaLat * deltaLat) * heightProportion).toFixed(0);
      var x2 = "1"; //(10000 * Math.sqrt(dLon * dLon + dLat * dLat)).toFixed(0) // 提高经度--
      var a = Number.parseFloat(height) / (Number.parseFloat(x2) * Number.parseFloat(x2));
      function y(x, height) {
          return height - a * x * x;
      }
      for (var i = 1; i < step; i++) {
          // 计算插值
          var _lon = lng1 + dLon * i;
          var _lat = lat1 + dLat * i;
          var _hei = height1 + dHei * i;
          var x = Number.parseFloat(x2) * ((2 * i) / step - 1);
          var _height = Number.parseFloat(y(x, height).toFixed(0));
          interPolatePoint.push([_lon, _lat, _height + _hei]);
      }
      interPolatePoint.push([lng2, lat2, height2]);
      return interPolatePoint;
  }
  /**
   * @ignore
   * @param fileName
   * @param dataURL
   * @param mimeType
   */
  function saveDataURL(fileName, dataURL, mimeType) {
      download(dataURL, fileName, mimeType);
  }
  /**
   * 计算起点与终点形成的方向与北方向的夹角（角度）
   */
  function calculateNorthAngleDegrees(starCoordinate, endCoordinate) {
      return toDegrees(computeRotationRadians(starCoordinate, endCoordinate));
  }

  var index$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defined: defined$1,
    toRadians: toRadians,
    toDegrees: toDegrees,
    convertToProjectionRadius: convertToProjectionRadius,
    calculatesDistance: calculatesDistance,
    calculatesRadius: calculatesRadius,
    getCircleCoordinates: getCircleCoordinates,
    createParabola: createParabola,
    saveDataURL: saveDataURL,
    calculateNorthAngleDegrees: calculateNorthAngleDegrees
  });

  var wellknown$1 = {exports: {}};

  /*eslint-disable no-cond-assign */

  wellknown$1.exports = parse$2;
  wellknown$1.exports.parse = parse$2;
  wellknown$1.exports.stringify = stringify;

  var numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;
  // Matches sequences like '100 100' or '100 100 100'.
  var tuples = new RegExp('^' + numberRegexp.source + '(\\s' + numberRegexp.source + '){1,}');

  /*
   * Parse WKT and return GeoJSON.
   *
   * @param {string} _ A WKT geometry
   * @return {?Object} A GeoJSON geometry object
   */
  function parse$2 (input) {
    var parts = input.split(';');
    var _ = parts.pop();
    var srid = (parts.shift() || '').split('=').pop();

    var i = 0;

    function $ (re) {
      var match = _.substring(i).match(re);
      if (!match) return null;
      else {
        i += match[0].length;
        return match[0];
      }
    }

    function crs (obj) {
      if (obj && srid.match(/\d+/)) {
        obj.crs = {
          type: 'name',
          properties: {
            name: 'urn:ogc:def:crs:EPSG::' + srid
          }
        };
      }

      return obj;
    }

    function white () { $(/^\s*/); }

    function multicoords () {
      white();
      var depth = 0;
      var rings = [];
      var stack = [rings];
      var pointer = rings;
      var elem;

      while (elem =
             $(/^(\()/) ||
               $(/^(\))/) ||
                 $(/^(,)/) ||
                   $(tuples)) {
        if (elem === '(') {
          stack.push(pointer);
          pointer = [];
          stack[stack.length - 1].push(pointer);
          depth++;
        } else if (elem === ')') {
          // For the case: Polygon(), ...
          if (pointer.length === 0) return null;

          pointer = stack.pop();
          // the stack was empty, input was malformed
          if (!pointer) return null;
          depth--;
          if (depth === 0) break;
        } else if (elem === ',') {
          pointer = [];
          stack[stack.length - 1].push(pointer);
        } else if (!elem.split(/\s/g).some(isNaN)) {
          Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
        } else {
          return null;
        }
        white();
      }

      if (depth !== 0) return null;

      return rings;
    }

    function coords () {
      var list = [];
      var item;
      var pt;
      while (pt =
             $(tuples) ||
               $(/^(,)/)) {
        if (pt === ',') {
          list.push(item);
          item = [];
        } else if (!pt.split(/\s/g).some(isNaN)) {
          if (!item) item = [];
          Array.prototype.push.apply(item, pt.split(/\s/g).map(parseFloat));
        }
        white();
      }

      if (item) list.push(item);
      else return null;

      return list.length ? list : null;
    }

    function point () {
      if (!$(/^(point(\sz)?)/i)) return null;
      white();
      if (!$(/^(\()/)) return null;
      var c = coords();
      if (!c) return null;
      white();
      if (!$(/^(\))/)) return null;
      return {
        type: 'Point',
        coordinates: c[0]
      };
    }

    function multipoint () {
      if (!$(/^(multipoint)/i)) return null;
      white();
      var newCoordsFormat = _
        .substring(_.indexOf('(') + 1, _.length - 1)
        .replace(/\(/g, '')
        .replace(/\)/g, '');
      _ = 'MULTIPOINT (' + newCoordsFormat + ')';
      var c = multicoords();
      if (!c) return null;
      white();
      return {
        type: 'MultiPoint',
        coordinates: c
      };
    }

    function multilinestring () {
      if (!$(/^(multilinestring)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      white();
      return {
        type: 'MultiLineString',
        coordinates: c
      };
    }

    function linestring () {
      if (!$(/^(linestring(\sz)?)/i)) return null;
      white();
      if (!$(/^(\()/)) return null;
      var c = coords();
      if (!c) return null;
      if (!$(/^(\))/)) return null;
      return {
        type: 'LineString',
        coordinates: c
      };
    }

    function polygon () {
      if (!$(/^(polygon(\sz)?)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      return {
        type: 'Polygon',
        coordinates: c
      };
    }

    function multipolygon () {
      if (!$(/^(multipolygon)/i)) return null;
      white();
      var c = multicoords();
      if (!c) return null;
      return {
        type: 'MultiPolygon',
        coordinates: c
      };
    }

    function geometrycollection () {
      var geometries = [];
      var geometry;

      if (!$(/^(geometrycollection)/i)) return null;
      white();

      if (!$(/^(\()/)) return null;
      while (geometry = root()) {
        geometries.push(geometry);
        white();
        $(/^(,)/);
        white();
      }
      if (!$(/^(\))/)) return null;

      return {
        type: 'GeometryCollection',
        geometries: geometries
      };
    }

    function root () {
      return point() ||
        linestring() ||
        polygon() ||
        multipoint() ||
        multilinestring() ||
        multipolygon() ||
        geometrycollection();
    }

    return crs(root());
  }

  /**
   * Stringifies a GeoJSON object into WKT
   */
  function stringify (gj) {
    if (gj.type === 'Feature') {
      gj = gj.geometry;
    }

    function pairWKT (c) {
      return c.join(' ');
    }

    function ringWKT (r) {
      return r.map(pairWKT).join(', ');
    }

    function ringsWKT (r) {
      return r.map(ringWKT).map(wrapParens).join(', ');
    }

    function multiRingsWKT (r) {
      return r.map(ringsWKT).map(wrapParens).join(', ');
    }

    function wrapParens (s) { return '(' + s + ')'; }

    switch (gj.type) {
      case 'Point':
        return 'POINT (' + pairWKT(gj.coordinates) + ')';
      case 'LineString':
        return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';
      case 'Polygon':
        return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';
      case 'MultiPoint':
        return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';
      case 'MultiPolygon':
        return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';
      case 'MultiLineString':
        return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';
      case 'GeometryCollection':
        return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';
      default:
        throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');
    }
  }

  var wellknown = wellknown$1.exports;

  /**
   * 第三方代码
   */
  var geoJsonParse = (function name() {
      // 配置
      var defaultConfig = {
          doThrows: {
              invalidGeometry: false
          }
      };
      var geoms = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeoJSON"];
      var geomAttrs = [];
      function applyDefaults(params, defaults) {
          var settings = params || {};
          settings = Object.assign(defaults, settings);
          return settings;
      }
      function addOptionals(geojson, settings) {
          if (settings.crs && checkCRS(settings.crs)) {
              if (settings.isPostgres)
                  geojson.geometry.crs = settings.crs;
              else
                  geojson.crs = settings.crs;
          }
          if (settings.bbox) {
              geojson.bbox = settings.bbox;
          }
          if (settings.extraGlobal) {
              geojson.properties = {};
              for (var key in settings.extraGlobal) {
                  geojson.properties[key] = settings.extraGlobal[key];
              }
          }
      }
      function checkCRS(crs) {
          if (crs.type === "name") {
              if (crs.properties && crs.properties.name) {
                  return true;
              }
              else {
                  throw new Error("无效的CRS，name属性不存在");
              }
          }
          else if (crs.type === "link") {
              if (crs.properties && crs.properties.href && crs.properties.type) {
                  return true;
              }
              else {
                  throw new Error("无效的CRS，href与type属性不存在");
              }
          }
          else {
              throw new Error("无效的CRS，类型属性必须包含name或link属性");
          }
      }
      function setGeom(params) {
          params.geom = {};
          for (var param in params) {
              if (Object.hasOwnProperty.call(params, param) && geoms.indexOf(param) !== -1) {
                  params.geom[param] = params[param];
                  delete params[param];
              }
          }
          setGeomAttrList(params.geom);
      }
      function setGeomAttrList(params) {
          for (var param in params) {
              if (Object.hasOwnProperty.call(params, param)) {
                  if (typeof params[param] === "string") {
                      geomAttrs.push(params[param]);
                  }
                  else if (typeof params[param] === "object") {
                      geomAttrs.push(params[param][0]);
                      geomAttrs.push(params[param][1]);
                      !params[param][2] || geomAttrs.push(params[param][2]);
                  }
              }
          }
          if (geomAttrs.length === 0) {
              throw new Error("几何属性为空");
          }
      }
      function getFeature(args) {
          var item = args.item;
          var params = args.params;
          var offset = args.offset;
          var propFunc = args.propFunc;
          return {
              type: "Feature",
              geometry: buildGeom(item, params, offset),
              properties: propFunc.call(item)
          };
      }
      function isNested(val) {
          return /^.+\..+$/.test(val);
      }
      function buildGeom(item, params, offset) {
          var geom = {};
          var _loop_1 = function (gtype) {
              var e_1, _a, e_2, _b, e_3, _c;
              var val = params.geom[gtype];
              if (typeof val === "string" && Object.hasOwnProperty.call(item, val)) {
                  if (gtype === "GeoJSON") {
                      geom = item[val];
                  }
                  else {
                      geom.type = gtype;
                      geom.coordinates = offset ? ProjUtil[offset](item[val]) : item[val];
                  }
              }
              else if (typeof val === "object" && !Array.isArray(val)) {
                  var points = Object.keys(val).map(function (key) {
                      var order = val[key];
                      var newItem = item[key];
                      return buildGeom(newItem, { geom: { Point: order } }, offset);
                  });
                  geom.type = gtype;
                  geom.coordinates = [].concat(points.map(function (p) {
                      return offset ? ProjUtil[offset](p.coordinates) : p.coordinates;
                  }));
              }
              else if (Array.isArray(val) &&
                  item.hasOwnProperty(val[0]) &&
                  item.hasOwnProperty(val[1]) &&
                  item.hasOwnProperty(val[2])) {
                  geom.type = gtype;
                  geom.coordinates = [Number(item[val[1]]), Number(item[val[0]]), Number(item[val[2]])];
              }
              else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([Number(item[val[1]]), Number(item[val[0]])])
                      : [Number(item[val[1]]), Number(item[val[0]])];
              }
              else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1]) && isNested(val[2])) {
                  var coordinates = [];
                  for (var i = 0; i < val.length; i++) {
                      var paths = val[i].split(".");
                      var itemClone = item;
                      try {
                          for (var paths_1 = (e_1 = void 0, __values(paths)), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
                              var path = paths_1_1.value;
                              if (!itemClone.hasOwnProperty(path)) {
                                  return { value: false };
                              }
                              itemClone = itemClone[path];
                          }
                      }
                      catch (e_1_1) { e_1 = { error: e_1_1 }; }
                      finally {
                          try {
                              if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                      }
                      coordinates[i] = itemClone;
                  }
                  geom.type = gtype;
                  geom.coordinates = [Number(coordinates[1]), Number(coordinates[0]), Number(coordinates[2])];
              }
              else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                  var coordinates = [];
                  try {
                      for (var val_1 = (e_2 = void 0, __values(val)), val_1_1 = val_1.next(); !val_1_1.done; val_1_1 = val_1.next()) {
                          var iterator = val_1_1.value;
                          var paths = iterator.split(".");
                          var itemClone = item;
                          try {
                              for (var paths_2 = (e_3 = void 0, __values(paths)), paths_2_1 = paths_2.next(); !paths_2_1.done; paths_2_1 = paths_2.next()) {
                                  var path = paths_2_1.value;
                                  if (!itemClone.hasOwnProperty(path)) {
                                      return { value: false };
                                  }
                                  itemClone = itemClone[path];
                              }
                          }
                          catch (e_3_1) { e_3 = { error: e_3_1 }; }
                          finally {
                              try {
                                  if (paths_2_1 && !paths_2_1.done && (_c = paths_2.return)) _c.call(paths_2);
                              }
                              finally { if (e_3) throw e_3.error; }
                          }
                          coordinates.push(itemClone);
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (val_1_1 && !val_1_1.done && (_b = val_1.return)) _b.call(val_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([Number(coordinates[1]), Number(coordinates[0])])
                      : [Number(coordinates[1]), Number(coordinates[0])];
              }
              else if (Array.isArray(val) &&
                  val[0].constructor.name === "Object" &&
                  Object.keys(val[0])[0] === "coordinates") {
                  geom.type = gtype;
                  geom.coordinates = offset
                      ? ProjUtil[offset]([
                          Number(item.coordinates[val[0].coordinates.indexOf("lng")]),
                          Number(item.coordinates[val[0].coordinates.indexOf("lat")])
                      ])
                      : [
                          Number(item.coordinates[val[0].coordinates.indexOf("lng")]),
                          Number(item.coordinates[val[0].coordinates.indexOf("lat")])
                      ];
              }
              else {
                  throw new Error("传入的数据缺少地理属性");
              }
          };
          for (var gtype in params.geom) {
              var state_1 = _loop_1(gtype);
              if (typeof state_1 === "object")
                  return state_1.value;
          }
          return geom;
      }
      /**
       * 构建属性生成函数
       * @param {*} params
       */
      function getPropFunction(params) {
          var func;
          if (!params.exclude && !params.include) {
              func = function (properties) {
                  for (var attr in this) {
                      if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
                          properties[attr] = this[attr];
                      }
                  }
              };
          }
          else if (params.include) {
              func = function (properties) {
                  params.include.forEach(function (attr) {
                      properties[attr] = this[attr];
                  }, this);
              };
          }
          else if (params.exclude) {
              func = function (properties) {
                  for (var attr in this) {
                      if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
                          properties[attr] = this[attr];
                      }
                  }
              };
          }
          return function () {
              var properties = {};
              func.call(this, properties);
              if (params.extra) {
                  addExtra(properties, params.extra);
              }
              return properties;
          };
      }
      function addExtra(properties, extra) {
          for (var key in extra) {
              if (extra.hasOwnProperty(key)) {
                  properties[key] = extra[key];
              }
          }
          return properties;
      }
      return function (objects, params, offset, callback) {
          if (offset === void 0) { offset = undefined; }
          if (callback === void 0) { callback = undefined; }
          var geojson;
          var settings = applyDefaults(params, __assign$1({}, defaultConfig));
          geomAttrs.length = 0;
          setGeom(settings);
          var propFunc = getPropFunction(settings);
          if (Array.isArray(objects)) {
              geojson = {
                  type: "FeatureCollection",
                  features: []
              };
              objects.forEach(function (item) {
                  geojson.features.push(getFeature({
                      item: item,
                      params: settings,
                      propFunc: propFunc,
                      offset: offset
                  }));
              });
              addOptionals(geojson, settings);
          }
          else {
              geojson = getFeature({
                  item: objects,
                  params: settings,
                  propFunc: propFunc,
                  offset: offset
              });
              addOptionals(geojson, settings);
          }
          if (callback && typeof callback === "function") {
              callback(geojson);
          }
          else {
              return geojson;
          }
      };
  })();
  /**
   * 构造geoJson点要素
   *
   * @param {PointCoordinate} coordinate 点坐标
   * @returns {GeoJsonFeature}
   */
  function point(coordinate, properties) {
      return Turf__namespace.point(coordinate, properties || {});
  }
  /**
   * 构造geoJson面要素
   *
   * @param {PolygonCoordinates} coordinates 面坐标
   * @returns {GeoJsonFeature}
   */
  function polygon(coordinates, properties) {
      return Turf__namespace.polygon(coordinates, properties || {});
  }
  /**
   * 构造geoJson线要素
   *
   * @param {LineStringCoordinates} coordinates 线坐标
   * @returns {GeoJsonFeature}
   */
  function lineString(coordinates, properties) {
      return Turf__namespace.lineString(coordinates, properties || {});
  }
  /**
   * 构造geoJson多点要素
   *
   * @param {MultiPointCoordinates} coordinates 多点坐标
   * @returns {GeoJsonFeature}
   */
  function multiPoint(coordinates, properties) {
      return Turf__namespace.multiPoint(coordinates, properties || {});
  }
  /**
   * 构造geoJson多线要素
   *
   * @param {MultiLineStringCoordinates} coordinates 多线坐标
   * @returns {GeoJsonFeature}
   */
  function multiLineString(coordinates, properties) {
      return Turf__namespace.multiLineString(coordinates, properties || {});
  }
  /**
   * 构造geoJson多面要素
   *
   * @param {MultiPolygonCoordinates} coordinates 多面坐标
   * @returns {GeoJsonFeature}
   */
  function multiPolygon(coordinates, properties) {
      return Turf__namespace.multiPolygon(coordinates, properties || {});
  }
  /**
   * 构造geoJson要素对象
   * @param geometry
   * @param properties
   * @returns GeoJsonFeature
   */
  function feature$2(geometry, properties) {
      return Turf__namespace.feature(geometry, properties);
  }
  /**
   * 构造geoJson要素集合对象
   *
   * @param {features} FeatureGeoJSON[] 要素数组
   * @returns {FeatureCollectionGeoJSON}
   */
  function featureCollection(features) {
      return {
          type: GeoJsonType.FEATURE_COLLECTION,
          features: features
      };
  }
  /**
   * 格式化geoJson数据为FeatureCollection
   *
   * @param geoJson
   * @returns
   */
  function normalize$1(geoJson) {
      if (geoJson.type === GeoJsonType.FEATURE) {
          return featureCollection([geoJson]);
      }
      else {
          return featureCollection([feature$2(geoJson)]);
      }
  }
  function featuresToGeoJsonFeatureCollection(features, options) {
      return featureCollection(features.map(function (f) {
          return featureToGeoJsonFeature(f, options);
      }));
  }
  function featureToGeoJsonFeature(f, options) {
      var geoJsonFeature = JSON.parse(JSON.stringify(f.geoJson));
      if ((options === null || options === void 0 ? void 0 : options.offset) || ((options === null || options === void 0 ? void 0 : options.dataProjection) && (options === null || options === void 0 ? void 0 : options.dataProjection) !== f.dataProjection)) {
          transformInternal(geoJsonFeature, {
              source: f.dataProjection,
              destination: (options === null || options === void 0 ? void 0 : options.dataProjection) || f.dataProjection,
              offset: options === null || options === void 0 ? void 0 : options.offset
          });
      }
      return geoJsonFeature;
  }
  function geoJsonToFeature(geoJson, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var result = [];
      if (geoJson.type !== GeoJsonType.FEATURE_COLLECTION) {
          geoJson = normalize$1(geoJson);
      }
      for (var index = 0, len = geoJson.features.length; index < len; index++) {
          var f = geoJson.features[index];
          result.push(geoJsonFeatureToFeature(f, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options));
      }
      return result;
  }
  /**
   * 将业务数据数组转为geoJson
   *
   * **业务数据格式**
   *
   * ```
   * { x: number; y: number; z?: number; [propName: string]: any }[]
   * | { lng: number; lat: number; height?: number; [propName: string]: any }[]
   * | { lon: number; lat: number; height?: number; [propName: string]: any }[];
   * | {
   *     longitude: number;
   *     latitude: number;
   *     height?: number;
   *     [propName: string]: any;
   *   }[]
   * ```
   *
   * @param {Array<object>} data 业务数据对象数组
   * @param {string} offset 偏移类型 可选值：'WGStoGCJ', 'GCJtoWGS','GCJtoBD','BDtoGCJ','WGStoBD','BDtoWGS'
   *
   */
  function dataToGeoJsonFeatureCollection(data, options) {
      if (data.length === 0) {
          return { type: GeoJsonType.FEATURE_COLLECTION, features: [] };
      }
      var _a = data[0], x = _a.x, y = _a.y, lng = _a.lng, lat = _a.lat, longitude = _a.longitude, latitude = _a.latitude, lon = _a.lon;
      var param;
      if (defined$1(x) && defined$1(y)) {
          param = ["y", "x", "z"];
      }
      else if (defined$1(lng) && defined$1(lat)) {
          param = ["lat", "lng", "height"];
      }
      else if (defined$1(longitude) && defined$1(latitude)) {
          param = ["latitude", "longitude", "height"];
      }
      else if (defined$1(lon) && defined$1(lat)) {
          param = ["lat", "lon", "height"];
      }
      else {
          throw new Error(ErrorNotification.UNEXPECTED_DATA_FORMAT);
      }
      return geoJsonParse(data, { Point: param }, options === null || options === void 0 ? void 0 : options.offset);
  }
  function geoJsonFeatureToFeature(geoJson, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var _b = geoJson.type === GeoJsonType.FEATURE ? geoJson.geometry : geoJson, type = _b.type, coordinates = _b.coordinates;
      switch (type) {
          case GeoJsonGeometryType.POINT:
          case GeoJsonGeometryType.MULTI_POINT:
              return new Point(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          case GeoJsonGeometryType.LINE_STRING:
          case GeoJsonGeometryType.MULTI_LINE_STRING:
              return new Polyline(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          case GeoJsonGeometryType.POLYGON:
          case GeoJsonGeometryType.MULTI_POLYGON:
              return new Polygon(__assign$1({ coordinates: coordinates, properties: geoJson.properties }, options));
          default:
              throw new Error(ErrorNotification.NOT_SUPPORTED_GEOJSON_TYPE);
      }
  }
  function featuresToWkts(features, options) {
      return features.map(function (f) {
          return featureToWkt(f, options);
      });
  }
  function featureToWkt(f, options) {
      if ((options === null || options === void 0 ? void 0 : options.offset) || ((options === null || options === void 0 ? void 0 : options.dataProjection) && (options === null || options === void 0 ? void 0 : options.dataProjection) !== f.dataProjection)) {
          return geoJsonFeatureToWkt(featureToGeoJsonFeature(f, options));
      }
      return f.wkt;
  }
  function wktsToFeatures(wkts, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      return wkts.map(function (wkt) {
          return wktToFeature(wkt, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options);
      });
  }
  function wktToFeature(wkt, _a, options) {
      var Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var geometry = wktToGeoJsonFeature(wkt);
      if (geometry) {
          return geoJsonFeatureToFeature(geometry, {
              Point: Point,
              Polyline: Polyline,
              Polygon: Polygon
          }, options);
      }
      else {
          throw new Error(ErrorNotification.UNSUPPORTED_PARAM);
      }
  }
  function wktToGeoJsonFeature(wkt) {
      return wellknown.parse(wkt);
  }
  function geoJsonFeatureToWkt(geoJson) {
      return wellknown.stringify(geoJson);
  }
  function vectorDataToFeatures(data, _a, options) {
      var Feature = _a.Feature, Point = _a.Point, Polyline = _a.Polyline, Polygon = _a.Polygon;
      var features = [];
      if (defined$1(data) && Array.isArray(data) && data.length > 0) {
          if (data[0] instanceof Feature) {
              features = data;
          }
          else if (typeof data[0] === "string") {
              features = wktsToFeatures(data, { Point: Point, Polyline: Polyline, Polygon: Polygon }, options);
          }
          else if (typeof data[0] === "object") {
              features = dataToGeoJsonFeatureCollection(data, { offset: options === null || options === void 0 ? void 0 : options.offset }).features.map(function (feature) {
                  return geoJsonFeatureToFeature(feature, { Point: Point, Polyline: Polyline, Polygon: Polygon }, { projection: options === null || options === void 0 ? void 0 : options.projection, dataProjection: options === null || options === void 0 ? void 0 : options.dataProjection });
              });
          }
      }
      else if (!Array.isArray(data) && typeof data === "object") {
          features = geoJsonToFeature(data, { Point: Point, Polygon: Polygon, Polyline: Polyline }, options);
      }
      return features;
  }

  var getProjection = proj__namespace.get;
  var coordinateOffsetUtil = {
      wgstogcj: _WGStoGCJ,
      gcjtowgs: _GCJtoWGS,
      gcjtobd: _GCJtoBD,
      bdtogcj: _BDtoGCJ,
      wgstobd: _WGStoBD,
      bdtowgs: _BDtoWGS
  };
  /**
   * 注册坐标系
   *
   * @param code 坐标名称
   * @param defs 坐标定义
   * @param extent 坐标范围
   */
  function register(code, defs, extent) {
      proj4.defs(code, defs);
      proj4$1.register(proj4);
      var projection = proj__namespace.get(code);
      extent && projection.setExtent(extent);
  }
  var GPS = {
      PI: parseFloat("3.14159265358979324"),
      x_pi: (parseFloat("3.14159265358979324") * 3000.0) / 180.0,
      delta: function (lat, lon) {
          var a = 6378245.0; //  a: 卫星椭球坐标投影到平面地图坐标系的投影因子。
          var ee = parseFloat("0.00669342162296594323"); //  ee: 椭球的偏心率。
          var dLat = this.transformLat(lon - 105.0, lat - 35.0);
          var dLon = this.transformLon(lon - 105.0, lat - 35.0);
          var radLat = (lat / 180.0) * this.PI;
          var magic = Math.sin(radLat);
          magic = 1 - ee * magic * magic;
          var sqrtMagic = Math.sqrt(magic);
          dLat = (dLat * 180.0) / (((a * (1 - ee)) / (magic * sqrtMagic)) * this.PI);
          dLon = (dLon * 180.0) / ((a / sqrtMagic) * Math.cos(radLat) * this.PI);
          return { lat: dLat, lon: dLon };
      },
      //WGS-84 to GCJ-02
      gcj_encrypt: function (wgsLat, wgsLon) {
          if (this.outOfChina(wgsLat, wgsLon))
              return { lat: wgsLat, lon: wgsLon };
          var d = this.delta(wgsLat, wgsLon);
          return { lat: wgsLat + d.lat, lon: wgsLon + d.lon };
      },
      //GCJ-02 to WGS-84
      gcj_decrypt: function (gcjLat, gcjLon) {
          if (this.outOfChina(gcjLat, gcjLon))
              return { lat: gcjLat, lon: gcjLon };
          var d = this.delta(gcjLat, gcjLon);
          return { lat: gcjLat - d.lat, lon: gcjLon - d.lon };
      },
      //GCJ-02 to WGS-84
      gcj_decrypt_exact: function (gcjLat, gcjLon) {
          var initDelta = 0.01;
          var threshold = 0.000000001;
          var dLat = initDelta, dLon = initDelta;
          var mLat = gcjLat - dLat, mLon = gcjLon - dLon;
          var pLat = gcjLat + dLat, pLon = gcjLon + dLon;
          var wgsLat, wgsLon, i = 0;
          while (1) {
              wgsLat = (mLat + pLat) / 2;
              wgsLon = (mLon + pLon) / 2;
              var tmp = this.gcj_encrypt(wgsLat, wgsLon);
              dLat = tmp.lat - gcjLat;
              dLon = tmp.lon - gcjLon;
              if (Math.abs(dLat) < threshold && Math.abs(dLon) < threshold)
                  break;
              if (dLat > 0)
                  pLat = wgsLat;
              else
                  mLat = wgsLat;
              if (dLon > 0)
                  pLon = wgsLon;
              else
                  mLon = wgsLon;
              if (++i > 10000)
                  break;
          }
          return { lat: wgsLat, lon: wgsLon };
      },
      //GCJ-02 to BD-09
      bd_encrypt: function (gcjLat, gcjLon) {
          var x = gcjLon, y = gcjLat;
          var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * this.x_pi);
          var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * this.x_pi);
          var bdLon = z * Math.cos(theta) + 0.0065;
          var bdLat = z * Math.sin(theta) + 0.006;
          return { lat: bdLat, lon: bdLon };
      },
      //BD-09 to GCJ-02
      bd_decrypt: function (bdLat, bdLon) {
          var x = bdLon - 0.0065, y = bdLat - 0.006;
          var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_pi);
          var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_pi);
          var gcjLon = z * Math.cos(theta);
          var gcjLat = z * Math.sin(theta);
          return { lat: gcjLat, lon: gcjLon };
      },
      //WGS-84 to Web mercator
      mercator_encrypt: function (wgsLat, wgsLon) {
          var x = (wgsLon * 20037508.34) / 180;
          var y = Math.log(Math.tan(((90 + wgsLat) * this.PI) / 360)) / (this.PI / 180);
          y = (y * 20037508.34) / 180;
          return { lat: y, lon: x };
      },
      // Web mercator to WGS-84
      mercator_decrypt: function (mercatorLat, mercatorLon) {
          var x = (mercatorLon / 20037508.34) * 180;
          var y = (mercatorLat / 20037508.34) * 180;
          y = (180 / this.PI) * (2 * Math.atan(Math.exp((y * this.PI) / 180)) - this.PI / 2);
          return { lat: y, lon: x };
      },
      // 计算两点在地球椭球体上的距离
      distance: function (latA, lonA, latB, lonB) {
          var earthR = 6371000;
          var x = Math.cos((latA * this.PI) / 180) * Math.cos((latB * this.PI) / 180) * Math.cos(((lonA - lonB) * this.PI) / 180);
          var y = Math.sin((latA * this.PI) / 180) * Math.sin((latB * this.PI) / 180);
          var s = x + y;
          if (s > 1)
              s = 1;
          if (s < -1)
              s = -1;
          var alpha = Math.acos(s);
          return alpha * earthR;
      },
      // 判断坐标是否超出中国范围-
      outOfChina: function (lat, lon) {
          if (lon < 72.004 || lon > 137.8347)
              return true;
          if (lat < 0.8293 || lat > 55.8271)
              return true;
          return false;
      },
      transformLat: function (x, y) {
          var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
          ret += ((20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0) / 3.0;
          ret += ((20.0 * Math.sin(y * this.PI) + 40.0 * Math.sin((y / 3.0) * this.PI)) * 2.0) / 3.0;
          ret += ((160.0 * Math.sin((y / 12.0) * this.PI) + 320 * Math.sin((y * this.PI) / 30.0)) * 2.0) / 3.0;
          return ret;
      },
      transformLon: function (x, y) {
          var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
          ret += ((20.0 * Math.sin(6.0 * x * this.PI) + 20.0 * Math.sin(2.0 * x * this.PI)) * 2.0) / 3.0;
          ret += ((20.0 * Math.sin(x * this.PI) + 40.0 * Math.sin((x / 3.0) * this.PI)) * 2.0) / 3.0;
          ret += ((150.0 * Math.sin((x / 12.0) * this.PI) + 300.0 * Math.sin((x / 30.0) * this.PI)) * 2.0) / 3.0;
          return ret;
      }
  };
  /**
   * 自定义并注册百度坐标系
   */
  (function () {
      if (proj4) {
          proj4.defs("BD-09", "+proj=merc +a=6378206 +b=6356584.314245179 +lat_ts=0.0 +lon_0=0.0 +x_0=0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs");
          proj4$1.register(proj4);
      }
      else {
          console.error("未引入proj4.js,无法调用修正百度地图加密坐标!");
      }
  })();
  /**
   * 自定义并注册CGCS2000坐标系
   */
  (function () {
      if (proj4) {
          proj4.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs");
          proj4$1.register(proj4);
      }
  })();
  function transformToDataProjection(coordinate, projection) {
      return transformInternal(coordinate, {
          source: projection || PUBLIC_CONFIG.projection,
          destination: PUBLIC_CONFIG.dataProjection
      });
  }
  function transformToProjection(coordinate, dataProjection) {
      return transformInternal(coordinate, {
          source: dataProjection || PUBLIC_CONFIG.dataProjection,
          destination: PUBLIC_CONFIG.projection
      });
  }
  function transform$3(coordinate, options) {
      var _a = options.source, source = _a === void 0 ? PUBLIC_CONFIG.dataProjection : _a, _b = options.destination, destination = _b === void 0 ? PUBLIC_CONFIG.projection : _b, offset = options.offset;
      if (source === destination && !defined$1(offset)) {
          return coordinate;
      }
      if (!Array.isArray(coordinate)) {
          if (coordinate.type === GeoJsonType.FEATURE) {
              return transformGeoJsonFeature(coordinate, options);
          }
          else if (coordinate.type === GeoJsonType.FEATURE_COLLECTION) {
              return featureCollection(coordinate.features.map(function (f) { return transformGeoJsonFeature(f, options); }));
          }
      }
      if (!Array.isArray(coordinate)) {
          console.warn(ErrorNotification.UNSUPPORTED_PARAM);
          return;
      }
      if (typeof coordinate[0] === "number" && coordinate.length === 4) {
          var _c = __read(transform$3([coordinate[0], coordinate[1]], options), 2), minX = _c[0], minY = _c[1];
          var _d = __read(transform$3([coordinate[2], coordinate[3]], options), 2), maxX = _d[0], maxY = _d[1];
          return [minX, minY, maxX, maxY];
      }
      if (offset) {
          if (source.toLocaleUpperCase() !== WGS84_PROJECTION_NAME) {
              coordinate = proj__namespace.transform(coordinate, source, WGS84_PROJECTION_NAME);
          }
          coordinate = coordinateOffsetUtil[offset.toLocaleLowerCase()](coordinate);
          return proj__namespace.transform(coordinate, WGS84_PROJECTION_NAME, destination);
      }
      return proj__namespace.transform(coordinate, source, destination);
  }
  /**
   * @ignore
   */
  function transformInternal(coordinate, options) {
      return transform$3(coordinate, options);
  }
  function dataTransform(coordinates, offsetType) {
      if (defined$1(coordinates) && Array.isArray(coordinates) && coordinates.length > 0) {
          // wkt 数组
          if (typeof coordinates[0] === "string") {
              return coordinates.map(function (wkt) {
                  var json = wktToGeoJsonFeature(wkt);
                  return geoJsonFeatureToWkt(dataOffset(json, offsetType));
              });
          }
          // PointCoordinate []
          if (Array.isArray(coordinates[0])) {
              return coordinates.map(function (coordinate) {
                  return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](coordinate);
              });
          }
          if (typeof coordinates[0] === "number") {
              return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](coordinates);
          }
          if (coordinates[0] instanceof Object) {
              var obj = coordinates[0];
              var _res = [];
              if (obj.hasOwnProperty("lon")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.lon, coordinate.lat]);
                      return Object.assign(coordinates, { lon: Tcoords[0], ltat: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("lng")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.lng, coordinate.lat]);
                      return Object.assign(coordinates, { lng: Tcoords[0], lat: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("x")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.x, coordinate.y]);
                      return Object.assign(coordinates, { x: Tcoords[0], y: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("longitude")) {
                  _res = coordinates.map(function (coordinate) {
                      var Tcoords = coordinateOffsetUtil[offsetType.toLocaleLowerCase()]([coordinate.x, coordinate.y]);
                      return Object.assign(coordinates, { longitude: Tcoords[0], lattitude: Tcoords[1] });
                  });
              }
              if (obj.hasOwnProperty("wkt")) {
                  _res = coordinates.map(function (coordinate) {
                      var json = wktToGeoJsonFeature(coordinate.wkt);
                      var _wkt = geoJsonFeatureToWkt(dataOffset(json, offsetType));
                      return Object.assign(coordinates, { wkt: _wkt });
                  });
              }
              return _res;
          }
          // GeoJson 数据格式
      }
      else if (!Array.isArray(coordinates) && typeof coordinates === "object") {
          return dataOffset(coordinates, offsetType);
      }
  }
  /**
   * 坐标从WGS84转到国测局02
   */
  function WGStoGCJ(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.WGS_TO_GCJ);
  }
  /**
   * 坐标从WGS84转到国测局02
   */
  function _WGStoGCJ(coordinate) {
      var Tcoords = GPS.gcj_encrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从国测局02转到WGS84
   */
  function GCJtoWGS(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.GCJ_TO_WGS);
  }
  /**
   * 坐标从国测局02转到WGS84
   */
  function _GCJtoWGS(coordinate) {
      var Tcoords = GPS.gcj_decrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从国测局02转到百度
   */
  function GCJtoBD(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.GCJ_TO_BD);
  }
  /**
   * 坐标从国测局02转到百度
   */
  function _GCJtoBD(coordinate) {
      var Tcoords = GPS.bd_encrypt(coordinate[1], coordinate[0]);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从百度转到国测局02
   */
  function BDtoGCJ(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.BD_TO_GCJ);
  }
  /**
   * 坐标从百度转到国测局02
   */
  function _BDtoGCJ(coordinates) {
      var Tcoords = GPS.bd_decrypt(coordinates[1], coordinates[0]);
      return coordinates.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinates[2]];
  }
  /**
   * 坐标从WGS84转到百度
   */
  function WGStoBD(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.WGS_TO_BD);
  }
  /**
   * 坐标从WGS84转到百度
   */
  function _WGStoBD(coordinate) {
      var Tcoords1 = GPS.gcj_encrypt(coordinate[1], coordinate[0]);
      var Tcoords = GPS.bd_encrypt(Tcoords1.lat, Tcoords1.lon);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * 坐标从百度转到WGS84
   */
  function BDtoWGS(coordinates) {
      return dataTransform(coordinates, CoordinateDecryptType.BD_TO_WGS);
  }
  /**
   * 坐标从百度转到WGS84
   */
  function _BDtoWGS(coordinate) {
      var Tcoords1 = GPS.bd_decrypt(coordinate[1], coordinate[0]);
      var Tcoords = GPS.gcj_decrypt(Tcoords1.lat, Tcoords1.lon);
      return coordinate.length === 2 ? [Tcoords.lon, Tcoords.lat] : [Tcoords.lon, Tcoords.lat, coordinate[2]];
  }
  /**
   * @ignore
   */
  function transformGeoJsonFeature(geoJson, options) {
      if ((options === null || options === void 0 ? void 0 : options.mutate) !== true) {
          geoJson = JSON.parse(JSON.stringify(geoJson));
      }
      transformGeoJsonGeometryCoordinatesInternal(geoJson.geometry.coordinates, options);
      return geoJson;
  }
  /**
   * @ignore
   */
  function transformGeoJsonGeometryCoordinates(coordinates, options) {
      if (options === void 0) { options = {}; }
      var _a = options.source, source = _a === void 0 ? PUBLIC_CONFIG.dataProjection : _a, _b = options.destination, destination = _b === void 0 ? PUBLIC_CONFIG.projection : _b, offset = options.offset;
      if (source === destination && !defined$1(offset)) {
          return coordinates;
      }
      if ((options === null || options === void 0 ? void 0 : options.mutate) !== true) {
          coordinates = JSON.parse(JSON.stringify(coordinates));
      }
      transformGeoJsonGeometryCoordinatesInternal(coordinates, options);
      return coordinates;
  }
  /**
   * 该方法会修改传入的参数
   */
  function transformGeoJsonGeometryCoordinatesInternal(coordinates, options) {
      var e_1, _a;
      if (Array.isArray(coordinates) && typeof coordinates[0] === "number") {
          var _b = __read(transformInternal(coordinates, options), 3), x = _b[0], y = _b[1], z = _b[2];
          coordinates[0] = x;
          coordinates[1] = y;
          defined$1(z) && (coordinates[2] = z);
      }
      else {
          try {
              for (var coordinates_1 = __values(coordinates), coordinates_1_1 = coordinates_1.next(); !coordinates_1_1.done; coordinates_1_1 = coordinates_1.next()) {
                  var coordinate = coordinates_1_1.value;
                  transformGeoJsonGeometryCoordinatesInternal(coordinate, options);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (coordinates_1_1 && !coordinates_1_1.done && (_a = coordinates_1.return)) _a.call(coordinates_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
      }
  }
  /**
   * @description 数据偏移
   * @export
   * @param {Object} data - GeoJSON对象
   * @param {*} offsetType
   * @returns {Object} GeoJSON对象
   */
  function dataOffset(data, offsetType) {
      if (!data || !offsetType) {
          console.error("参数错误");
          return;
      }
      if (data.type === "FeatureCollection") {
          for (var index = 0; index < data.features.length; index++) {
              var feature = data.features[index];
              featureOffset(feature, offsetType);
          }
      }
      else if (data.type === "Feature") {
          featureOffset(data, offsetType);
      }
      return data;
  }
  function geometryOffset(geo, offsetType) {
      if (geo.type === "Point") {
          geo.coordinates = coordinateOffsetUtil[offsetType.toLocaleLowerCase()](geo.coordinates);
      }
      else if (geo.type === "LineString" || geo.type === "MultiPoint") {
          geo.coordinates = geo.coordinates.map(function (currentValue) {
              return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](currentValue);
          });
      }
      else if (geo.type === "Polygon" || geo.type === "MultiLineString") {
          geo.coordinates = geo.coordinates.map(function (currentValue) {
              return currentValue.map(function (item) {
                  return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](item);
              });
          });
      }
      else if (geo.type === "MultiPolygon") {
          geo.coordinates = geo.coordinates.map(function (item1) {
              return item1.map(function (item2) {
                  return item2.map(function (item3) {
                      return coordinateOffsetUtil[offsetType.toLocaleLowerCase()](item3);
                  });
              });
          });
      }
      else {
          console.error("该GeoJSON格式不正确");
      }
  }
  function featureOffset(feature, offsetType) {
      geometryOffset(feature.geometry, offsetType);
  }

  var gitVersion = "1.0.0-beta.7-dev+g0e095ee";
  var gitDate = "2022-10-14 17:19:14 +0800";

  var css_248z = ".ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid blue;\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: rgba(0,60,136,0.3);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n  transition: all 0.25s;\n}\n.ol-scale-bar {\n  position: absolute;\n  bottom: 8px;\n  left: 8px;\n}\n.ol-scale-step-marker {\n  width: 1px;\n  height: 15px;\n  background-color: #000000;\n  float: right;\n  z-Index: 10;\n}\n.ol-scale-step-text {\n  position: absolute;\n  bottom: -5px;\n  font-size: 12px;\n  z-Index: 11;\n  color: #000000;\n  text-shadow: -2px 0 #FFFFFF, 0 2px #FFFFFF, 2px 0 #FFFFFF, 0 -2px #FFFFFF;\n}\n.ol-scale-text {\n  position: absolute;\n  font-size: 14px;\n  text-align: center;\n  bottom: 25px;\n  color: #000000;\n  text-shadow: -2px 0 #FFFFFF, 0 2px #FFFFFF, 2px 0 #FFFFFF, 0 -2px #FFFFFF;\n}\n.ol-scale-singlebar {\n  position: relative;\n  height: 10px;\n  z-Index: 9;\n  box-sizing: border-box;\n  border: 1px solid black;\n}\n\n.ol-unsupported {\n  display: none;\n}\n.ol-viewport, .ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n}\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.ol-control {\n  position: absolute;\n  background-color: rgba(255,255,255,0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.ol-control:hover {\n  background-color: rgba(255,255,255,0.6);\n}\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: white;\n  font-size: 1.14em;\n  font-weight: bold;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0,60,136,0.5);\n  border: none;\n  border-radius: 2px;\n}\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  background-color: rgba(0,60,136,0.7);\n}\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n}\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.ol-attribution ul, .ol-attribution button {\n  display: inline-block;\n}\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.ol-attribution:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n}\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: inline-block;\n}\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.ol-overviewmap:not(.ol-collapsed) button{\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-overviewmap-box {\n  border: 2px dotted rgba(0,60,136,0.7);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n";
  styleInject(css_248z);

  /**
   *  getUid方法的计数器
   * @type {number}
   * @private
   */
  var uidCounter$1 = 0;
  /**
   * 生成全局唯一ID
   */
  function getUid$2() {
      return ++uidCounter$1 + "";
  }
  [
      BaseEventType.CLICK,
      BaseEventType.DOUBLE_CLICK,
      BaseEventType.MOUSE_DOWN,
      BaseEventType.MOUSE_UP,
      BaseEventType.MOUSE_MOVE,
      BaseEventType.RIGHT_CLICK
  ];

  /**
   *  getUid方法的计数器
   * @type {number}
   * @private
   */
  var uidCounter = 0;
  /**
   * 生成全局唯一ID
   */
  function getUid$1() {
      return ++uidCounter + "";
  }
  function VOID$1() {
      // 一个可重用的函数，例如用作回调的默认值。
  }
  /**
   *
   * @param target 事件目标.
   * @param {string} type 事件类型.
   * @param {ListenerFunction} listener 事件监听器.
   * @param {Object=} optThis Object 事件监听器执行的上下文，默认为target
   * @param {boolean=} optOnce 如果为真，则将侦听器添加为一次性侦听器。.
   * @return {EventsKey} 该监听器的唯一值
   * @ignore
   */
  function listen$1(target, type, listener, optThis, optOnce) {
      if (optThis && optThis !== target) {
          listener = listener.bind(optThis);
      }
      if (optOnce) {
          var originalListener_1 = listener;
          listener = function (e) {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  function listenOnce$1(target, type, listener, optThis) {
      return listen$1(target, type, listener, optThis, true);
  }
  /**
   * 在事件目标上注销事件监听器.
   */
  function unListenByKey(key) {
      if (key === null || key === void 0 ? void 0 : key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clearProperty(key);
      }
  }
  /**
   * 使用' on() '或' once() '返回的唯一值删除事件监听器。.
   */
  function unByKey$1(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unListenByKey(key[i]);
          }
      }
      else {
          unListenByKey(key);
      }
  }
  var MAP_MOUSE_EVENT_TYPE = [
      BaseEventType.CLICK,
      BaseEventType.DOUBLE_CLICK,
      BaseEventType.MOUSE_DOWN,
      BaseEventType.MOUSE_UP,
      BaseEventType.MOUSE_MOVE,
      BaseEventType.RIGHT_CLICK
  ];
  function isMapMouseEventType(type) {
      return MAP_MOUSE_EVENT_TYPE.includes(type);
  }

  /**
   * 事件基础类，如果需要定义更高级别的事件，需要继承此类
   *
   * @ignore
   */
  var BaseEvent$1 = /** @class */ (function () {
      /**
       * @param {string} type 事件类型
       */
      function BaseEvent(type) {
          this.propagationStopped = false;
          /**
           * 事件类型
           * @type {string}
           */
          this.type = type;
      }
      /**
       * 阻止事件传播
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * 阻止事件传播
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());

  var Destroyer = /** @class */ (function () {
      function Destroyer() {
          /**
           * @ignore
           */
          this._destroyed = false;
      }
      Object.defineProperty(Destroyer.prototype, "destroyed", {
          /**
           * 对象是否已经销毁
           */
          get: function () {
              return this._destroyed;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 销毁对象
       *
       * 未从地球移除时,请勿调用该方法
       */
      Destroyer.prototype.destroy = function () {
          if (!this._destroyed) {
              this._destroyed = true;
              this._destroy();
          }
      };
      /**
       * @ignore
       */
      Destroyer.prototype._destroy = function () {
          // 需子类重写
      };
      return Destroyer;
  }());

  var EventTarget$1 = /** @class */ (function (_super) {
      __extends$6(EventTarget, _super);
      function EventTarget() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * @ignore
           */
          _this._pendingRemovals = {};
          /**
           * @ignore
           */
          _this._dispatching = {};
          /**
           * @ignore
           */
          _this._listeners = {};
          return _this;
      }
      Object.defineProperty(EventTarget.prototype, "listeners", {
          /**
           * @ignore
           */
          get: function () {
              return this._listeners;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      EventTarget.prototype.addEventListener = function (type, listener) {
          var _a;
          if (!type || !listener) {
              return false;
          }
          var listeners = this._listeners[type] || (this._listeners[type] = []);
          if (listeners.indexOf(listener) === -1) {
              listeners.push(listener);
              if (defined$1(this["registerEventEnable"])) {
                  this["registerEventEnable"](type);
              }
              else if (defined$1((_a = this["map"]) === null || _a === void 0 ? void 0 : _a["registerEventEnable"])) {
                  this["map"]["registerEventEnable"](type);
              }
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype.dispatchEvent = function (event) {
          var evt = typeof event === "string" ? new BaseEvent$1(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this;
          }
          // 获取该事件类型的监听器
          var listeners = this._listeners[type];
          var propagate;
          if (listeners) {
              // 没有该属性
              if (!(type in this._dispatching)) {
                  this._dispatching[type] = 0;
                  this._pendingRemovals[type] = 0;
              }
              ++this._dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --this._dispatching[type];
              if (this._dispatching[type] === 0) {
                  var pendingRemovals = this._pendingRemovals[type];
                  delete this._pendingRemovals[type];
                  while (pendingRemovals--) {
                      this.removeEventListener(type, VOID$1);
                  }
                  delete this._dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype.getListeners = function (type) {
          return this._listeners[type];
      };
      /**
       * @ignore
       */
      EventTarget.prototype.hasListener = function (type) {
          return type ? type in this._listeners : Object.keys(this._listeners).length > 0;
      };
      /**
       * @ignore
       */
      EventTarget.prototype.removeEventListener = function (type, listener) {
          var _a;
          var listeners = this._listeners[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (type in this._pendingRemovals) {
                      listeners[index] = VOID$1;
                      ++this._pendingRemovals[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this._listeners[type];
                      }
                      if (defined$1(this["unregisterEventEnable"])) {
                          this["unregisterEventEnable"](type);
                      }
                      else if (defined$1((_a = this["map"]) === null || _a === void 0 ? void 0 : _a["unregisterEventEnable"])) {
                          this["map"]["unregisterEventEnable"](type);
                      }
                  }
              }
          }
      };
      /**
       * @ignore
       */
      EventTarget.prototype._destroy = function () {
          for (var property in this._listeners) {
              delete this._listeners[property];
          }
      };
      return EventTarget;
  }(Destroyer));

  var Observable$2 = /** @class */ (function (_super) {
      __extends$6(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          _this._revision = 0;
          return _this;
      }
      /**
       * 增加版本号，触发一次更改事件
       * @ignore
       */
      Observable.prototype.changed = function () {
          ++this._revision;
          this.dispatchEvent(BaseEventType.CHANGE);
      };
      /**
       * 获取该对象的版本号。每次对象被修改时，其版本号都会递增
       * @return {number} Revision.
       * @ignore
       */
      Observable.prototype.getRevision = function () {
          return this._revision;
      };
      /**
       * 注册事件
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Observable.prototype.on = function (type, listener) {
          return on$1.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Observable.prototype.once = function (type, listener) {
          return once.call(this, type, listener);
      };
      /**
       * 注销事件类型的监听
       *
       * @param {(string | string[])} type 事件类型，或者事件类型数组
       * @param {Function} listener 事件监听器
       */
      Observable.prototype.un = function (type, listener) {
          un.call(this, type, listener);
      };
      /**
       * 注销事件
       *
       * @param {(eventKey | eventKey[])} key
       */
      Observable.prototype.unByKey = function (key) {
          unByKey$1(key);
      };
      return Observable;
  }(EventTarget$1));
  function once(type, listener) {
      if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
              keys[i] = listenOnce$1(this, type[i], listener);
          }
          return keys;
      }
      else {
          return listenOnce$1(this, type, listener);
      }
  }
  function un(type, listener) {
      if (Array.isArray(type)) {
          for (var i = 0, ii = type.length; i < ii; ++i) {
              this.removeEventListener(type[i], listener);
          }
      }
      else {
          this.removeEventListener(type, listener);
      }
  }
  function on$1(type, listener) {
      if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
              keys[i] = listen$1(this, type[i], listener);
          }
          return keys;
      }
      else {
          return listen$1(this, type, listener);
      }
  }

  /**
   * 对象事件，继承事件类，该对象事件用于对象属性变化的监听
   * @ignore
   */
  var ObjectEvent$1 = /** @class */ (function (_super) {
      __extends$6(ObjectEvent, _super);
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          _this.key = key;
          _this.oldValue = oldValue;
          return _this;
      }
      ObjectEvent.PROPERTYCHANGE = "propertychange";
      return ObjectEvent;
  }(BaseEvent$1));

  /**
   * @ignore
   */
  var AbstractObject = /** @class */ (function (_super) {
      __extends$6(AbstractObject, _super);
      function AbstractObject(values) {
          var _this = _super.call(this) || this;
          /**
           * @ignore
           */
          _this._values = {};
          /**
           * @ignore
           */
          _this._uid = getUid$2();
          if (values) {
              _this._values = values;
          }
          return _this;
      }
      Object.defineProperty(AbstractObject.prototype, "uid", {
          /**
           * 全局唯一id
           */
          get: function () {
              return this._uid;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 根据key获取监听属性值
       *
       * @param {string} key
       * @returns {*}
       * @ignore
       */
      AbstractObject.prototype.get = function (key) {
          var value;
          if (Object.hasOwnProperty.call(this._values, key)) {
              value = this._values[key];
          }
          return value;
      };
      /**
       * 获取当前对象监听的属性key列表
       *
       * @returns {string[]}
       * @ignore
       */
      AbstractObject.prototype.getKeys = function () {
          return Object.keys(this._values);
      };
      /**
       * @ignore
       * @returns
       */
      AbstractObject.prototype.getAttributes = function () {
          return Object.assign({}, this._values);
      };
      /**
       * 分发事件-----
       * @param {string} key 键值
       * @param {*} oldValue 该键值的旧值
       * @ignore
       */
      AbstractObject.prototype.notify = function (key, oldValue) {
          this.dispatchEvent(new ObjectEvent$1(getChangeEventType$1(key), key, oldValue));
          this.dispatchEvent(new ObjectEvent$1(ObjectEvent$1.PROPERTYCHANGE, key, oldValue));
      };
      /**
       * @param {string} key 键名称
       * @param {*} value 键值.
       * @param {boolean} silent 更新属性时是否触发事件.
       * @ignore
       */
      AbstractObject.prototype.set = function (key, value, silent) {
          if (silent === void 0) { silent = false; }
          var oldValue = this._values[key];
          this._values[key] = value;
          if (oldValue !== value && !silent) {
              this.notify(key, oldValue);
          }
      };
      /**
       * @param {string} key 键值名称
       * @param {boolean} silent 是否禁止触发事件
       * @ignore
       */
      AbstractObject.prototype.unset = function (key, silent) {
          if (silent === void 0) { silent = false; }
          if (key in this._values) {
              var oldValue = this._values[key];
              delete this._values[key];
              if (!silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * @override
       */
      AbstractObject.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._values = undefined;
      };
      return AbstractObject;
  }(Observable$2));
  /**
   * @ignore
   */
  var changeEventTypeCache$1 = {};
  /**
   * @ignore
   */
  function getChangeEventType$1(key) {
      if (!changeEventTypeCache$1.hasOwnProperty(key)) {
          changeEventTypeCache$1[key] = "change:" + key;
      }
      return changeEventTypeCache$1[key];
  }

  var BaseObject$1 = /** @class */ (function (_super) {
      __extends$6(BaseObject, _super);
      function BaseObject(options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, options) || this;
          _this._id = options.id || getUid$1();
          _this._options = options;
          return _this;
      }
      Object.defineProperty(BaseObject.prototype, "id", {
          /**
           * 对象id
           */
          get: function () {
              return this._id;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaseObject.prototype, "map", {
          /**
           * 地图对象
           */
          get: function () {
              return this._map;
          },
          /**
           * @ignore
           */
          set: function (map) {
              var e_1, _a;
              var _b, _c, _d, _e;
              var first = !defined$1(this.map) && defined$1(map);
              var mtiMap = this._map || map;
              this._map = map;
              try {
                  for (var _f = __values(Object.keys(this.listeners)), _g = _f.next(); !_g.done; _g = _f.next()) {
                      var key = _g.value;
                      for (var index = 0, count = this.listeners[key].length; index < count; index++) {
                          if (defined$1(map)) {
                              first && ((_c = (_b = mtiMap).registerEventEnable) === null || _c === void 0 ? void 0 : _c.call(_b, key));
                          }
                          else {
                              (_e = (_d = mtiMap).unregisterEventEnable) === null || _e === void 0 ? void 0 : _e.call(_d, key);
                          }
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(BaseObject.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 重写父类销毁方法
       * @ignore
       */
      BaseObject.prototype._destroy = function () {
          _super.prototype._destroy.call(this);
          this._map = undefined;
          this._options = undefined;
      };
      return BaseObject;
  }(AbstractObject));

  /**
   * 图层基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Layer = /** @class */ (function (_super) {
      __extends$6(Layer, _super);
      function Layer(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, basemap: false }, options)) || this;
          /**
           * @ignore
           */
          _this._initialized = false;
          _this._basemap = _this.options.basemap;
          if (defined$1(map)) {
              map.addLayer(_this);
          }
          return _this;
      }
      Object.defineProperty(Layer.prototype, "visible", {
          /**
           * 图层显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "layer", {
          /**
           * 内部图层对象
           *
           * @ignore
           */
          get: function () {
              return this._layer;
          },
          /**
           * @ignore
           *
           * @
           */
          set: function (layer) {
              this._layer = layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "initialized", {
          /**
           * 初始化状态
           *
           * @ignore
           */
          get: function () {
              return this._initialized;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "basemap", {
          get: function () {
              return this._basemap;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Layer.prototype, "zIndex", {
          get: function () {
              return this._zIndex;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化图层
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Layer.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Layer.prototype.addTo = function (map) {
          this.map = map;
          this.initialized || this.init();
          /** 子类有不同实现,自行重写 */
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Layer.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 显示图层
       */
      Layer.prototype.show = function () {
          if (this.visible === true)
              return;
          this.dispatchEvent({
              type: BaseEventType.SHOW,
              target: this
          });
          this._visible = true;
          this._setVisible();
          return this;
      };
      /**
       * 隐藏图层
       */
      Layer.prototype.hide = function () {
          if (this.visible === false)
              return;
          this.dispatchEvent({
              type: BaseEventType.HIDE,
              target: this
          });
          this._visible = false;
          this._setVisible();
          return this;
      };
      /**
       * @ignore
       */
      Layer.prototype._setVisible = function () {
          var _this = this;
          var _a;
          (_a = this.layer) === null || _a === void 0 ? void 0 : _a.forEach(function (i) {
              i.setVisible(_this._visible);
          });
      };
      Layer.prototype.setZIndex = function (zIndex) {
          var _this = this;
          this._zIndex = zIndex;
          this.layer.forEach(function (i) { return i.setZIndex(_this.zIndex); });
          return this;
      };
      return Layer;
  }(BaseObject$1));

  var AMapLayer = /** @class */ (function (_super) {
      __extends$6(AMapLayer, _super);
      // get options(): AMapLayerOptions {
      //   return this._options
      // }
      function AMapLayer(options, map) {
          return _super.call(this, __assign$1({ maxLevel: 18, visible: true, type: MapType.VECTOR }, options), map) || this;
      }
      AMapLayer.prototype.init = function () {
          this._initialized = true;
          var type = this.options.type;
          this._layer = [
              new Tile__default["default"](__assign$1({ source: new XYZ__default["default"](__assign$1(__assign$1({ crossOrigin: "anonymous", url: type === MapType.IMAGE
                          ? "//webst0{1-4}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}"
                          : type === MapType.VECTOR
                              ? "//wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}"
                              : "//webst0{1-4}.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}" }, this.options), { maxZoom: this.options.maxLevel })) }, this.options))
          ];
      };
      AMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      AMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = void 0;
      };
      /**
       * @ignore
       */
      AMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer = void 0;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return AMapLayer;
  }(Layer));

  var BMapLayer = /** @class */ (function (_super) {
      __extends$6(BMapLayer, _super);
      function BMapLayer(options, map) {
          return _super.call(this, __assign$1({ visible: true, type: BDMapType.VEC }, options), map) || this;
      }
      Object.defineProperty(BMapLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      BMapLayer.prototype.init = function () {
          this._initialized = true;
          var _options = __assign$1({}, this.options);
          this._layer = _getLayer(_options);
      };
      BMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      BMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      BMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
      };
      return BMapLayer;
  }(Layer));
  /**
   *
   * @param 获取相对应风格的百度地图图层
   */
  function _getLayer(options) {
      var config = __assign$1({}, options);
      var layer = null;
      if (config.type === "traffic") {
          layer = _getBDrealRoads(config);
      }
      else if (config.type === "img") {
          layer = _getBdSatMap(config);
      }
      else if (config.type === "label") {
          layer = _getBdAnnMap(config);
      }
      else {
          layer = _getBdMap(config);
      }
      return [layer];
  }
  /**
   * 百度地图实时路况
   */
  function _getBDrealRoads(options) {
      var resolutions = [];
      for (var i = 0; i < 19; i++) {
          resolutions[i] = Math.pow(2, 18 - i);
      }
      var timeKey = new Date().getTime();
      var tilegrid = new TileGrid__default["default"]({
          origin: [0, 0],
          resolutions: resolutions
      });
      var baiduSource = new TileImage__default["default"]({
          projection: "BD-09",
          tilePixelRatio: 2,
          tileGrid: tilegrid,
          crossOrigin: "anonymous",
          tileUrlFunction: function (tileCoord, pixelRatio, proj) {
              if (!tileCoord) {
                  return "";
              }
              var z = tileCoord[0];
              var x = tileCoord[1] ? tileCoord[1] : "M" + -tileCoord[1];
              var y = -tileCoord[2] - 1 ? -tileCoord[2] - 1 : "M" + -(-tileCoord[2] - 1);
              return ("//its.map.baidu.com:8002/traffic/TrafficTileService?level=" +
                  z +
                  "&x=" +
                  x +
                  "&y=" +
                  y +
                  "&time=" +
                  timeKey +
                  "&v=081&scaler=1");
          }
      });
      var _config = Object.assign({ source: baiduSource }, options);
      return new Tile__default["default"](_config);
  }
  /**
   * 百度地图卫星地图
   */
  function _getBdSatMap(options) {
      var resolutions = [];
      for (var i = 0; i < 19; i++) {
          resolutions[i] = Math.pow(2, 18 - i);
      }
      var tilegrid = new TileGrid__default["default"]({
          origin: [0, 0],
          resolutions: resolutions
      });
      var baiduSource = new TileImage__default["default"]({
          projection: "BD-09",
          crossOrigin: "anonymous",
          tilePixelRatio: 2,
          tileGrid: tilegrid,
          //url:"//shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46"
          tileUrlFunction: function (tileCoord, pixelRatio, proj) {
              if (!tileCoord) {
                  return "";
              }
              return ("//shangetu1.map.bdimg.com/it/u=x=" +
                  tileCoord[1] +
                  ";y=" +
                  (-tileCoord[2] - 1) +
                  ";z=" +
                  tileCoord[0] +
                  ";v=009;type=sate&fm=46");
              // const z = tileCoord[0];
              // const x = tileCoord[1] ? tileCoord[1] : "M" + -tileCoord[1];
              // const y = -tileCoord[2] - 1 ? -tileCoord[2] - 1 : "M" + -(-tileCoord[2] - 1);
              // const sub = tileCoord[1] % 2;
              //
              // return (
              //   "//ss" +
              //   sub +
              //   ".bdstatic.com/8bo_dTSlR1gBo1vgoIiO_jowehsv/starpic/?qt=satepc&u=x=" +
              //   x +
              //   ";y=" +
              //   y +
              //   ";z=" +
              //   z +
              //   ";v=009;type=sate&fm=46&app=webearth2&v=009"
              // );
          }
      });
      var _config = Object.assign({ source: baiduSource }, options);
      return new Tile__default["default"](_config);
  }
  /**
   * 百度地图注记
   */
  function _getBdAnnMap(options) {
      var resolutions = [];
      for (var i = 0; i < 19; i++) {
          resolutions[i] = Math.pow(2, 18 - i);
      }
      var tilegrid = new TileGrid__default["default"]({
          origin: [0, 0],
          resolutions: resolutions
      });
      var baiduSource = new TileImage__default["default"]({
          projection: "BD-09",
          tilePixelRatio: 2,
          tileGrid: tilegrid,
          crossOrigin: "anonymous",
          tileUrlFunction: function (tileCoord, pixelRatio, proj) {
              if (!tileCoord) {
                  return "";
              }
              var z = tileCoord[0];
              var x = tileCoord[1] ? tileCoord[1] : "M" + -tileCoord[1];
              var y = -tileCoord[2] - 1 ? -tileCoord[2] - 1 : "M" + -(-tileCoord[2] - 1);
              var sub = tileCoord[1] % 2;
              return "//online" + sub + ".map.bdimg.com/tile/?qt=tile&x=" + x + "&y=" + y + "&z=" + z + "&styles=sl";
          }
      });
      var _config = Object.assign({ source: baiduSource }, options);
      return new Tile__default["default"](_config);
  }
  /**
   * 根据样式添加百度地图
   * 默认地图样式(normal)
   * 清新蓝风格(light)
   * 黑夜风格(dark)
   * 红色警戒风格(redalert)
   * 精简风格(googlelite)
   * 自然绿风格(grassgreen)
   * 午夜蓝风格(midnight)
   * 浪漫粉风格(pink)
   * 青春绿风格(darkgreen)
   * 清新蓝绿风格(bluish)
   * 高端灰风格(grayscale)
   * 强边界风格(hardedge)
   * 具体见 //lbsyun.baidu.com/custom/list.htm
   */
  function _getBdMap(options) {
      var resolutions = [];
      for (var i = 0; i < 19; i++) {
          resolutions[i] = Math.pow(2, 18 - i);
      }
      var tilegrid = new TileGrid__default["default"]({
          origin: [0, 0],
          resolutions: resolutions
      });
      var baiduSource = new TileImage__default["default"]({
          projection: "BD-09",
          tilePixelRatio: 2,
          crossOrigin: "anonymous",
          tileGrid: tilegrid,
          tileUrlFunction: function (tileCoord, pixelRatio, proj) {
              if (!tileCoord) {
                  return "";
              }
              var z = tileCoord[0];
              var x = tileCoord[1];
              var y = tileCoord[2];
              // 百度瓦片服务url将负数使用M前缀来标识
              if (x < 0) {
                  x = -x;
              }
              if (y < 0) {
                  y = -y - 1;
              }
              return ("//maponline0.bdimg.com/tile/?qt=vtile&x=" +
                  x +
                  "&y=" +
                  y +
                  "&z=" +
                  z +
                  "&styles=pl&scaler=1&udt=20210506&from=jsapi3_0");
          }
      });
      var _config = Object.assign({ source: baiduSource }, options);
      return new Tile__default["default"](_config);
  }

  var StaticImageLayer = /** @class */ (function (_super) {
      __extends$6(StaticImageLayer, _super);
      function StaticImageLayer(options, map) {
          if (!defined$1(options.url)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ opacity: 1, visible: true, extent: [-180, -90, 180, 90] }, options), map) || this;
      }
      Object.defineProperty(StaticImageLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      StaticImageLayer.prototype.init = function () {
          this._initialized = true;
          var _options = Object.assign({}, this.options);
          _options.imageExtent = transformInternal(_options.extent, {
              source: PUBLIC_CONFIG.dataProjection,
              destination: PUBLIC_CONFIG.projection
          });
          delete _options.extent;
          this.layer = [
              new ImageLayer__default["default"](__assign$1({ source: new StaticImageSource__default["default"](_options) }, _options))
          ];
      };
      StaticImageLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      StaticImageLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      StaticImageLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return StaticImageLayer;
  }(Layer));

  var TMapLayer = /** @class */ (function (_super) {
      __extends$6(TMapLayer, _super);
      function TMapLayer(options, map) {
          return _super.call(this, __assign$1({ type: MapType.VECTOR, visible: true, tk: PUBLIC_CONFIG.key.tKey }, options), map) || this;
      }
      Object.defineProperty(TMapLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      TMapLayer.prototype.init = function () {
          this._initialized = true;
          var options = __assign$1({}, this.options);
          if (options.type === MapType.LABEL) {
              this.layer = [getTDTLayer(__assign$1(__assign$1({}, options), { type: "cva" })), getTDTLayer(__assign$1(__assign$1({}, options), { type: "ibo" }))];
          }
          else {
              this.layer = [getTDTLayer(options), getTDTLayer(__assign$1(__assign$1({}, options), { type: "ibo" }))];
          }
      };
      TMapLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      TMapLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      TMapLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return TMapLayer;
  }(Layer));
  var tdtExtent = [
      -20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892
  ];
  var tdtResolutions = [
      295829355.4545656, 147914677.7272828, 73957338.8636414, 36978669.4318207, 18489334.71591035, 9244667.357955175,
      4622333.678977588, 2311166.839488794, 1155583.419744397, 577791.7098721985, 288895.85493609926, 144447.92746804963,
      72223.96373402482, 36111.98186701241, 18055.990933506204, 9027.995466753102, 4513.997733376551, 2256.998866688275
  ].map(function (i) { return (i * 0.0254) / 96; });
  function getTDTLayer(options) {
      return new Tile__default["default"](__assign$1({ source: new WMTS__default["default"](__assign$1({ url: "//t{0-7}.tianditu.gov.cn/".concat(options.type, "_w/wmts?tk=").concat(options.tk), layer: options.type, matrixSet: "w", format: "tiles", projection: "EPSG:3857", tileGrid: new WMTSTileGrid__default["default"]({
                  extent: tdtExtent,
                  resolutions: tdtResolutions,
                  matrixIds: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18"]
              }), style: "default" }, options)) }, options));
  }

  /**
   * 对象集合基类,提供基础集合管理方法
   *
   * @ignore
   */
  var BaseCollection = /** @class */ (function (_super) {
      __extends$6(BaseCollection, _super);
      function BaseCollection(options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this) || this;
          _this._indexArray = [];
          _this._store = new Map();
          _this._uniqueKeyName = "id";
          _this.id = options.id || getUid$1();
          return _this;
      }
      Object.defineProperty(BaseCollection.prototype, "map", {
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      BaseCollection.prototype.getArray = function () {
          var _this = this;
          return this._indexArray.map(function (index) {
              return _this._store.get(index);
          });
      };
      BaseCollection.prototype.getLength = function () {
          return this._indexArray.length;
      };
      BaseCollection.prototype.forEach = function (f) {
          var _this = this;
          this._indexArray.forEach(function (index) {
              f(_this._store.get(index), index);
          });
      };
      BaseCollection.prototype.include = function (id) {
          return this._indexArray.includes(id);
      };
      BaseCollection.prototype.getItem = function (id) {
          if (this.include(id)) {
              return this._store.get(id);
          }
      };
      BaseCollection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this._remove(this._indexArray[this.getLength() - 1]);
          }
      };
      BaseCollection.prototype.add = function (item) {
          if (this.include(item[this._uniqueKeyName])) {
              throw new Error("id重复：" + item[this._uniqueKeyName]);
          }
          this._indexArray.push(item[this._uniqueKeyName]);
          this._store.set(item[this._uniqueKeyName], item);
      };
      BaseCollection.prototype.pop = function () {
          if (this.getLength() > 0) {
              return this._remove(this._indexArray[this.getLength() - 1]);
          }
      };
      BaseCollection.prototype.remove = function (item) {
          if ((typeof item === "string" && this.include(item)) || (typeof item !== "string" && this.include(item))) {
              return this._remove(item);
          }
          else if (typeof item !== "string" && this.include(item[this._uniqueKeyName])) {
              return this._remove(item[this._uniqueKeyName]);
          }
      };
      BaseCollection.prototype.insertAt = function (index, item) {
          if (!this.include(item[this._uniqueKeyName]) && index <= this.getLength()) {
              this._indexArray.splice(index, 0, item[this._uniqueKeyName]);
              this._store.set(item[this._uniqueKeyName], item);
          }
      };
      BaseCollection.prototype._remove = function (id) {
          var result = this._store.get(id);
          this._store.delete(id);
          this._indexArray.splice(this._indexArray.indexOf(id), 1);
          return result;
      };
      BaseCollection.prototype[Symbol.iterator] = function () {
          var list, list_1, list_1_1, index, e_1_1;
          var e_1, _a;
          return __generator$1(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      list = __spreadArray$1([], __read(this._indexArray), false);
                      _b.label = 1;
                  case 1:
                      _b.trys.push([1, 6, 7, 8]);
                      list_1 = __values(list), list_1_1 = list_1.next();
                      _b.label = 2;
                  case 2:
                      if (!!list_1_1.done) return [3 /*break*/, 5];
                      index = list_1_1.value;
                      return [4 /*yield*/, this._store.get(index)];
                  case 3:
                      _b.sent();
                      _b.label = 4;
                  case 4:
                      list_1_1 = list_1.next();
                      return [3 /*break*/, 2];
                  case 5: return [3 /*break*/, 8];
                  case 6:
                      e_1_1 = _b.sent();
                      e_1 = { error: e_1_1 };
                      return [3 /*break*/, 8];
                  case 7:
                      try {
                          if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                      return [7 /*endfinally*/];
                  case 8: return [2 /*return*/];
              }
          });
      };
      BaseCollection.prototype._destroy = function () {
          this._map = undefined;
          this._store = undefined;
          this._indexArray = undefined;
      };
      return BaseCollection;
  }(Destroyer));

  /**
   * 原生对象链接要素对象
   */
  var FEATURE_LINK = Symbol.for("FeatureLink");
  /**
   * 原生对象链接图层对象
   */
  var LAYER_LINK = Symbol.for("LayerLink");
  /**
   * 图片样式原始旋转角度
   */
  var ORIGINAL_ROTATION = Symbol.for("OriginRotation");
  /**
   * 二维图片样式是否跟随移动旋转
   */
  var ICON_ROTATED = Symbol.for("RotatedIcon");
  /**
   * 数据加载中
   */
  var LOADING_DATA = Symbol.for("LoadingData");
  var INITIALIZED = Symbol("Initialized");
  var NULL_STYLE_ITEM_LIST = [];
  NULL_STYLE_ITEM_LIST[INITIALIZED] = true;

  // export function radialGradientItemToCanvas(
  //   styleItem: RadialGradientStyleItem,
  //   width = 512,
  //   height = 512
  // ): HTMLCanvasElement {
  //   const canvas = document.createElement("canvas");
  //   canvas.height = height;
  //   canvas.width = width;
  //   const ctx = canvas.getContext("2d");
  //   drawRadialGradient(ctx, styleItem, [width / 2, height / 2], width / 2);
  //   return canvas;
  // }
  function drawRadialGradient(ctx, styleItem, center, radius) {
      var _a = styleItem.gradientStep, gradientStep = _a === void 0 ? [
          [0, "rgba(255,0,0,0)"],
          [0.5, "rgba(255,0,0,0.5)"],
          [1, "rgba(255,0,0,1)"]
      ] : _a;
      var _b = __read(gradientStep, 3), _c = __read(_b[0], 2), stop1 = _c[0], color1 = _c[1], _d = __read(_b[1], 2), stop2 = _d[0], color2 = _d[1], _e = __read(_b[2], 2), stop3 = _e[0], color3 = _e[1];
      var gradient = ctx.createRadialGradient(center[0], center[1], 0, center[0], center[1], radius);
      gradient.addColorStop(Math.min(Math.max(0, stop1), 1), color1);
      gradient.addColorStop(Math.min(Math.max(0, stop2), 1), color2);
      gradient.addColorStop(Math.min(Math.max(0, stop3), 1), color3);
      ctx.beginPath();
      ctx.arc(center[0], center[1], radius, 0, 2 * Math.PI, true);
      ctx.fillStyle = gradient;
      ctx.fill();
  }
  var PICK_EVENT_TYPE = [BaseEventType.CLICK, BaseEventType.DOUBLE_CLICK, BaseEventType.RIGHT_CLICK];
  function toPickEventType(type) {
      if (PICK_EVENT_TYPE.includes(type)) {
          switch (type) {
              case BaseEventType.CLICK:
                  return BaseEventType.PICK;
              case BaseEventType.DOUBLE_CLICK:
                  return BaseEventType.DOUBLE_PICK;
              case BaseEventType.RIGHT_CLICK:
                  return BaseEventType.RIGHT_PICK;
          }
      }
      return;
  }
  function pickEventTypeToClickType(type) {
      switch (type) {
          case BaseEventType.PICK:
              return BaseEventType.CLICK;
          case BaseEventType.DOUBLE_PICK:
              return BaseEventType.DOUBLE_CLICK;
          case BaseEventType.RIGHT_PICK:
              return BaseEventType.RIGHT_CLICK;
          default:
              return type;
      }
  }
  function toStyleItemList(style, callback) {
      if (Array.isArray(style)) {
          if (style.length === 0 || defined$1(style[0].type)) {
              return defined$1(callback) ? callback(style) : style;
          }
          else {
              return void 0;
          }
      }
      else {
          return void 0;
      }
  }
  function toStyleFunction(style, callback) {
      if (Array.isArray(style)) {
          if (style.length === 0 || defined$1(style[0].type)) {
              return function () {
                  return defined$1(callback) ? callback(style) : style;
              };
          }
          else {
              return function (feature) {
                  var _a;
                  var styleItemList = ((_a = style.find(function (item) {
                      if (!defined$1(item.condition)) {
                          return true;
                      }
                      else {
                          return item.condition(feature);
                      }
                  })) === null || _a === void 0 ? void 0 : _a.style) || NULL_STYLE_ITEM_LIST;
                  return defined$1(callback) ? callback(styleItemList) : styleItemList;
              };
          }
      }
      else {
          return style;
      }
  }

  var colorName = {
  	"aliceblue": [240, 248, 255],
  	"antiquewhite": [250, 235, 215],
  	"aqua": [0, 255, 255],
  	"aquamarine": [127, 255, 212],
  	"azure": [240, 255, 255],
  	"beige": [245, 245, 220],
  	"bisque": [255, 228, 196],
  	"black": [0, 0, 0],
  	"blanchedalmond": [255, 235, 205],
  	"blue": [0, 0, 255],
  	"blueviolet": [138, 43, 226],
  	"brown": [165, 42, 42],
  	"burlywood": [222, 184, 135],
  	"cadetblue": [95, 158, 160],
  	"chartreuse": [127, 255, 0],
  	"chocolate": [210, 105, 30],
  	"coral": [255, 127, 80],
  	"cornflowerblue": [100, 149, 237],
  	"cornsilk": [255, 248, 220],
  	"crimson": [220, 20, 60],
  	"cyan": [0, 255, 255],
  	"darkblue": [0, 0, 139],
  	"darkcyan": [0, 139, 139],
  	"darkgoldenrod": [184, 134, 11],
  	"darkgray": [169, 169, 169],
  	"darkgreen": [0, 100, 0],
  	"darkgrey": [169, 169, 169],
  	"darkkhaki": [189, 183, 107],
  	"darkmagenta": [139, 0, 139],
  	"darkolivegreen": [85, 107, 47],
  	"darkorange": [255, 140, 0],
  	"darkorchid": [153, 50, 204],
  	"darkred": [139, 0, 0],
  	"darksalmon": [233, 150, 122],
  	"darkseagreen": [143, 188, 143],
  	"darkslateblue": [72, 61, 139],
  	"darkslategray": [47, 79, 79],
  	"darkslategrey": [47, 79, 79],
  	"darkturquoise": [0, 206, 209],
  	"darkviolet": [148, 0, 211],
  	"deeppink": [255, 20, 147],
  	"deepskyblue": [0, 191, 255],
  	"dimgray": [105, 105, 105],
  	"dimgrey": [105, 105, 105],
  	"dodgerblue": [30, 144, 255],
  	"firebrick": [178, 34, 34],
  	"floralwhite": [255, 250, 240],
  	"forestgreen": [34, 139, 34],
  	"fuchsia": [255, 0, 255],
  	"gainsboro": [220, 220, 220],
  	"ghostwhite": [248, 248, 255],
  	"gold": [255, 215, 0],
  	"goldenrod": [218, 165, 32],
  	"gray": [128, 128, 128],
  	"green": [0, 128, 0],
  	"greenyellow": [173, 255, 47],
  	"grey": [128, 128, 128],
  	"honeydew": [240, 255, 240],
  	"hotpink": [255, 105, 180],
  	"indianred": [205, 92, 92],
  	"indigo": [75, 0, 130],
  	"ivory": [255, 255, 240],
  	"khaki": [240, 230, 140],
  	"lavender": [230, 230, 250],
  	"lavenderblush": [255, 240, 245],
  	"lawngreen": [124, 252, 0],
  	"lemonchiffon": [255, 250, 205],
  	"lightblue": [173, 216, 230],
  	"lightcoral": [240, 128, 128],
  	"lightcyan": [224, 255, 255],
  	"lightgoldenrodyellow": [250, 250, 210],
  	"lightgray": [211, 211, 211],
  	"lightgreen": [144, 238, 144],
  	"lightgrey": [211, 211, 211],
  	"lightpink": [255, 182, 193],
  	"lightsalmon": [255, 160, 122],
  	"lightseagreen": [32, 178, 170],
  	"lightskyblue": [135, 206, 250],
  	"lightslategray": [119, 136, 153],
  	"lightslategrey": [119, 136, 153],
  	"lightsteelblue": [176, 196, 222],
  	"lightyellow": [255, 255, 224],
  	"lime": [0, 255, 0],
  	"limegreen": [50, 205, 50],
  	"linen": [250, 240, 230],
  	"magenta": [255, 0, 255],
  	"maroon": [128, 0, 0],
  	"mediumaquamarine": [102, 205, 170],
  	"mediumblue": [0, 0, 205],
  	"mediumorchid": [186, 85, 211],
  	"mediumpurple": [147, 112, 219],
  	"mediumseagreen": [60, 179, 113],
  	"mediumslateblue": [123, 104, 238],
  	"mediumspringgreen": [0, 250, 154],
  	"mediumturquoise": [72, 209, 204],
  	"mediumvioletred": [199, 21, 133],
  	"midnightblue": [25, 25, 112],
  	"mintcream": [245, 255, 250],
  	"mistyrose": [255, 228, 225],
  	"moccasin": [255, 228, 181],
  	"navajowhite": [255, 222, 173],
  	"navy": [0, 0, 128],
  	"oldlace": [253, 245, 230],
  	"olive": [128, 128, 0],
  	"olivedrab": [107, 142, 35],
  	"orange": [255, 165, 0],
  	"orangered": [255, 69, 0],
  	"orchid": [218, 112, 214],
  	"palegoldenrod": [238, 232, 170],
  	"palegreen": [152, 251, 152],
  	"paleturquoise": [175, 238, 238],
  	"palevioletred": [219, 112, 147],
  	"papayawhip": [255, 239, 213],
  	"peachpuff": [255, 218, 185],
  	"peru": [205, 133, 63],
  	"pink": [255, 192, 203],
  	"plum": [221, 160, 221],
  	"powderblue": [176, 224, 230],
  	"purple": [128, 0, 128],
  	"rebeccapurple": [102, 51, 153],
  	"red": [255, 0, 0],
  	"rosybrown": [188, 143, 143],
  	"royalblue": [65, 105, 225],
  	"saddlebrown": [139, 69, 19],
  	"salmon": [250, 128, 114],
  	"sandybrown": [244, 164, 96],
  	"seagreen": [46, 139, 87],
  	"seashell": [255, 245, 238],
  	"sienna": [160, 82, 45],
  	"silver": [192, 192, 192],
  	"skyblue": [135, 206, 235],
  	"slateblue": [106, 90, 205],
  	"slategray": [112, 128, 144],
  	"slategrey": [112, 128, 144],
  	"snow": [255, 250, 250],
  	"springgreen": [0, 255, 127],
  	"steelblue": [70, 130, 180],
  	"tan": [210, 180, 140],
  	"teal": [0, 128, 128],
  	"thistle": [216, 191, 216],
  	"tomato": [255, 99, 71],
  	"turquoise": [64, 224, 208],
  	"violet": [238, 130, 238],
  	"wheat": [245, 222, 179],
  	"white": [255, 255, 255],
  	"whitesmoke": [245, 245, 245],
  	"yellow": [255, 255, 0],
  	"yellowgreen": [154, 205, 50]
  };

  /**
   * @module color-parse
   */

  /**
   * Base hues
   * http://dev.w3.org/csswg/css-color/#typedef-named-hue
   */
  //FIXME: use external hue detector
  var baseHues = {
  	red: 0,
  	orange: 60,
  	yellow: 120,
  	green: 180,
  	blue: 240,
  	purple: 300
  };

  /**
   * Parse color from the string passed
   *
   * @return {Object} A space indicator `space`, an array `values` and `alpha`
   */
  function parse$1 (cstr) {
  	var m, parts = [], alpha = 1, space;

  	if (typeof cstr === 'string') {
  		//keyword
  		if (colorName[cstr]) {
  			parts = colorName[cstr].slice();
  			space = 'rgb';
  		}

  		//reserved words
  		else if (cstr === 'transparent') {
  			alpha = 0;
  			space = 'rgb';
  			parts = [0,0,0];
  		}

  		//hex
  		else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
  			var base = cstr.slice(1);
  			var size = base.length;
  			var isShort = size <= 4;
  			alpha = 1;

  			if (isShort) {
  				parts = [
  					parseInt(base[0] + base[0], 16),
  					parseInt(base[1] + base[1], 16),
  					parseInt(base[2] + base[2], 16)
  				];
  				if (size === 4) {
  					alpha = parseInt(base[3] + base[3], 16) / 255;
  				}
  			}
  			else {
  				parts = [
  					parseInt(base[0] + base[1], 16),
  					parseInt(base[2] + base[3], 16),
  					parseInt(base[4] + base[5], 16)
  				];
  				if (size === 8) {
  					alpha = parseInt(base[6] + base[7], 16) / 255;
  				}
  			}

  			if (!parts[0]) parts[0] = 0;
  			if (!parts[1]) parts[1] = 0;
  			if (!parts[2]) parts[2] = 0;

  			space = 'rgb';
  		}

  		//color space
  		else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
  			var name = m[1];
  			var isRGB = name === 'rgb';
  			var base = name.replace(/a$/, '');
  			space = base;
  			var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3;
  			parts = m[2].trim()
  				.split(/\s*[,\/]\s*|\s+/)
  				.map(function (x, i) {
  					//<percentage>
  					if (/%$/.test(x)) {
  						//alpha
  						if (i === size)	return parseFloat(x) / 100
  						//rgb
  						if (base === 'rgb') return parseFloat(x) * 255 / 100
  						return parseFloat(x)
  					}
  					//hue
  					else if (base[i] === 'h') {
  						//<deg>
  						if (/deg$/.test(x)) {
  							return parseFloat(x)
  						}
  						//<base-hue>
  						else if (baseHues[x] !== undefined) {
  							return baseHues[x]
  						}
  					}
  					return parseFloat(x)
  				});

  			if (name === base) parts.push(1);
  			alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size];
  			parts = parts.slice(0, size);
  		}

  		//named channels case
  		else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
  			parts = cstr.match(/([0-9]+)/g).map(function (value) {
  				return parseFloat(value)
  			});

  			space = cstr.match(/([a-z])/ig).join('').toLowerCase();
  		}
  	}

  	//numeric case
  	else if (!isNaN(cstr)) {
  		space = 'rgb';
  		parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff];
  	}

  	//array-like
  	else if (Array.isArray(cstr) || cstr.length) {
  		parts = [cstr[0], cstr[1], cstr[2]];
  		space = 'rgb';
  		alpha = cstr.length === 4 ? cstr[3] : 1;
  	}

  	//object case - detects css cases of rgb and hsl
  	else if (cstr instanceof Object) {
  		if (cstr.r != null || cstr.red != null || cstr.R != null) {
  			space = 'rgb';
  			parts = [
  				cstr.r || cstr.red || cstr.R || 0,
  				cstr.g || cstr.green || cstr.G || 0,
  				cstr.b || cstr.blue || cstr.B || 0
  			];
  		}
  		else {
  			space = 'hsl';
  			parts = [
  				cstr.h || cstr.hue || cstr.H || 0,
  				cstr.s || cstr.saturation || cstr.S || 0,
  				cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
  			];
  		}

  		alpha = cstr.a || cstr.alpha || cstr.opacity || 1;

  		if (cstr.opacity != null) alpha /= 100;
  	}

  	return {
  		space: space,
  		values: parts,
  		alpha: alpha
  	}
  }

  /**
   * RGB space.
   *
   * @module  color-space/rgb
   */

  var rgb$1 = {
  	name: 'rgb',
  	min: [0,0,0],
  	max: [255,255,255],
  	channel: ['red', 'green', 'blue'],
  	alias: ['RGB']
  };

  /**
   * @module color-space/hsl
   */

  var hsl$1 = {
  	name: 'hsl',
  	min: [0,0,0],
  	max: [360,100,100],
  	channel: ['hue', 'saturation', 'lightness'],
  	alias: ['HSL'],

  	rgb: function(hsl) {
  		var h = hsl[0] / 360,
  				s = hsl[1] / 100,
  				l = hsl[2] / 100,
  				t1, t2, t3, rgb, val;

  		if (s === 0) {
  			val = l * 255;
  			return [val, val, val];
  		}

  		if (l < 0.5) {
  			t2 = l * (1 + s);
  		}
  		else {
  			t2 = l + s - l * s;
  		}
  		t1 = 2 * l - t2;

  		rgb = [0, 0, 0];
  		for (var i = 0; i < 3; i++) {
  			t3 = h + 1 / 3 * - (i - 1);
  			if (t3 < 0) {
  				t3++;
  			}
  			else if (t3 > 1) {
  				t3--;
  			}

  			if (6 * t3 < 1) {
  				val = t1 + (t2 - t1) * 6 * t3;
  			}
  			else if (2 * t3 < 1) {
  				val = t2;
  			}
  			else if (3 * t3 < 2) {
  				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
  			}
  			else {
  				val = t1;
  			}

  			rgb[i] = val * 255;
  		}

  		return rgb;
  	}
  };


  //extend rgb
  rgb$1.hsl = function(rgb) {
  	var r = rgb[0]/255,
  			g = rgb[1]/255,
  			b = rgb[2]/255,
  			min = Math.min(r, g, b),
  			max = Math.max(r, g, b),
  			delta = max - min,
  			h, s, l;

  	if (max === min) {
  		h = 0;
  	}
  	else if (r === max) {
  		h = (g - b) / delta;
  	}
  	else if (g === max) {
  		h = 2 + (b - r) / delta;
  	}
  	else if (b === max) {
  		h = 4 + (r - g)/ delta;
  	}

  	h = Math.min(h * 60, 360);

  	if (h < 0) {
  		h += 360;
  	}

  	l = (min + max) / 2;

  	if (max === min) {
  		s = 0;
  	}
  	else if (l <= 0.5) {
  		s = delta / (max + min);
  	}
  	else {
  		s = delta / (2 - max - min);
  	}

  	return [h, s * 100, l * 100];
  };

  /** @module  color-rgba */

  function rgba (color) {
  	// template literals
  	if (Array.isArray(color) && color.raw) color = String.raw(...arguments);

  	var values;

  	//attempt to parse non-array arguments
  	var parsed = parse$1(color);

  	if (!parsed.space) return []

  	const min = parsed.space[0] === 'h' ? hsl$1.min : rgb$1.min;
  	const max = parsed.space[0] === 'h' ? hsl$1.max : rgb$1.max;

  	values = Array(3);
  	values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  	values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  	values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);

  	if (parsed.space[0] === 'h') {
  		values = hsl$1.rgb(values);
  	}

  	values.push(Math.min(Math.max(parsed.alpha, 0), 1));

  	return values
  }

  var imageStore = new Map();
  function getImageAndMixColor(_a) {
      var image = _a.image, color = _a.color;
      return __awaiter$8(this, void 0, void 0, function () {
          return __generator$1(this, function (_b) {
              return [2 /*return*/, new Promise(function (resolve) {
                      if (imageStore.has(image + "|" + color)) {
                          resolve(imageStore.get(image + "|" + color));
                      }
                      else {
                          var _a = __read(rgba(color), 4), r_1 = _a[0], g_1 = _a[1], b_1 = _a[2], a_1 = _a[3];
                          var img_1 = new Image();
                          img_1.crossOrigin = "Anonymous";
                          img_1.src = image;
                          img_1.onload = function () {
                              var width = img_1.width, height = img_1.height;
                              var canvas = document.createElement("canvas");
                              canvas.width = width / 2;
                              canvas.height = height / 2;
                              var ct = canvas.getContext("2d");
                              ct.drawImage(img_1, 0, 0, width / 2, height / 2);
                              var id = ct.getImageData(0, 0, width, height);
                              for (var index = 0; index < id.data.length; index += 4) {
                                  id.data[index] = (id.data[index] * r_1) / 255;
                                  id.data[index + 1] = (id.data[index + 1] * g_1) / 255;
                                  id.data[index + 2] = (id.data[index + 2] * b_1) / 255;
                                  id.data[index + 3] = id.data[index + 3] * a_1;
                              }
                              ct.putImageData(id, 0, 0);
                              imageStore.set(image + "|" + color, canvas);
                              resolve(canvas);
                          };
                      }
                  })];
          });
      });
  }
  function getImage(image) {
      return __awaiter$8(this, void 0, void 0, function () {
          return __generator$1(this, function (_a) {
              return [2 /*return*/, new Promise(function (resolve) {
                      if (imageStore.has(image)) {
                          resolve(imageStore.get(image));
                      }
                      else {
                          var img_2 = new Image();
                          img_2.crossOrigin = "Anonymous";
                          img_2.src = image;
                          img_2.onload = function () {
                              var width = img_2.width, height = img_2.height;
                              var canvas = document.createElement("canvas");
                              canvas.width = width / 2;
                              canvas.height = height / 2;
                              var ct = canvas.getContext("2d");
                              ct.drawImage(img_2, 0, 0, width / 2, height / 2);
                              imageStore.set(image, canvas);
                              resolve(canvas);
                          };
                      }
                  })];
          });
      });
  }

  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap$1(arr, left, k);
          if (compare(arr[right], t) > 0) swap$1(arr, left, right);

          while (i < j) {
              swap$1(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) i++;
              while (compare(arr[j], t) > 0) j--;
          }

          if (compare(arr[left], t) === 0) swap$1(arr, left, j);
          else {
              j++;
              swap$1(arr, j, right);
          }

          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
      }
  }

  function swap$1(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  class RBush {
      constructor(maxEntries = 9) {
          // max entries in a node is 9 by default; min node fill is 40% for best performance
          this._maxEntries = Math.max(4, maxEntries);
          this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
          this.clear();
      }

      all() {
          return this._all(this.data, []);
      }

      search(bbox) {
          let node = this.data;
          const result = [];

          if (!intersects(bbox, node)) return result;

          const toBBox = this.toBBox;
          const nodesToSearch = [];

          while (node) {
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  const childBBox = node.leaf ? toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf) result.push(child);
                      else if (contains$1(bbox, childBBox)) this._all(child, result);
                      else nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return result;
      }

      collides(bbox) {
          let node = this.data;

          if (!intersects(bbox, node)) return false;

          const nodesToSearch = [];
          while (node) {
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  const childBBox = node.leaf ? this.toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf || contains$1(bbox, childBBox)) return true;
                      nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return false;
      }

      load(data) {
          if (!(data && data.length)) return this;

          if (data.length < this._minEntries) {
              for (let i = 0; i < data.length; i++) {
                  this.insert(data[i]);
              }
              return this;
          }

          // recursively build the tree with the given data from scratch using OMT algorithm
          let node = this._build(data.slice(), 0, data.length - 1, 0);

          if (!this.data.children.length) {
              // save as is if tree is empty
              this.data = node;

          } else if (this.data.height === node.height) {
              // split root if trees have the same height
              this._splitRoot(this.data, node);

          } else {
              if (this.data.height < node.height) {
                  // swap trees if inserted one is bigger
                  const tmpNode = this.data;
                  this.data = node;
                  node = tmpNode;
              }

              // insert the small tree into the large tree at appropriate level
              this._insert(node, this.data.height - node.height - 1, true);
          }

          return this;
      }

      insert(item) {
          if (item) this._insert(item, this.data.height - 1);
          return this;
      }

      clear() {
          this.data = createNode([]);
          return this;
      }

      remove(item, equalsFn) {
          if (!item) return this;

          let node = this.data;
          const bbox = this.toBBox(item);
          const path = [];
          const indexes = [];
          let i, parent, goingUp;

          // depth-first iterative tree traversal
          while (node || path.length) {

              if (!node) { // go up
                  node = path.pop();
                  parent = path[path.length - 1];
                  i = indexes.pop();
                  goingUp = true;
              }

              if (node.leaf) { // check current node
                  const index = findItem(item, node.children, equalsFn);

                  if (index !== -1) {
                      // item found, remove the item and condense tree upwards
                      node.children.splice(index, 1);
                      path.push(node);
                      this._condense(path);
                      return this;
                  }
              }

              if (!goingUp && !node.leaf && contains$1(node, bbox)) { // go down
                  path.push(node);
                  indexes.push(i);
                  i = 0;
                  parent = node;
                  node = node.children[0];

              } else if (parent) { // go right
                  i++;
                  node = parent.children[i];
                  goingUp = false;

              } else node = null; // nothing found
          }

          return this;
      }

      toBBox(item) { return item; }

      compareMinX(a, b) { return a.minX - b.minX; }
      compareMinY(a, b) { return a.minY - b.minY; }

      toJSON() { return this.data; }

      fromJSON(data) {
          this.data = data;
          return this;
      }

      _all(node, result) {
          const nodesToSearch = [];
          while (node) {
              if (node.leaf) result.push(...node.children);
              else nodesToSearch.push(...node.children);

              node = nodesToSearch.pop();
          }
          return result;
      }

      _build(items, left, right, height) {

          const N = right - left + 1;
          let M = this._maxEntries;
          let node;

          if (N <= M) {
              // reached leaf level; return leaf
              node = createNode(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
          }

          if (!height) {
              // target height of the bulk-loaded tree
              height = Math.ceil(Math.log(N) / Math.log(M));

              // target number of root entries to maximize storage utilization
              M = Math.ceil(N / Math.pow(M, height - 1));
          }

          node = createNode([]);
          node.leaf = false;
          node.height = height;

          // split the items into M mostly square tiles

          const N2 = Math.ceil(N / M);
          const N1 = N2 * Math.ceil(Math.sqrt(M));

          multiSelect(items, left, right, N1, this.compareMinX);

          for (let i = left; i <= right; i += N1) {

              const right2 = Math.min(i + N1 - 1, right);

              multiSelect(items, i, right2, N2, this.compareMinY);

              for (let j = i; j <= right2; j += N2) {

                  const right3 = Math.min(j + N2 - 1, right2);

                  // pack each entry recursively
                  node.children.push(this._build(items, j, right3, height - 1));
              }
          }

          calcBBox(node, this.toBBox);

          return node;
      }

      _chooseSubtree(bbox, node, level, path) {
          while (true) {
              path.push(node);

              if (node.leaf || path.length - 1 === level) break;

              let minArea = Infinity;
              let minEnlargement = Infinity;
              let targetNode;

              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  const area = bboxArea(child);
                  const enlargement = enlargedArea(bbox, child) - area;

                  // choose entry with the least area enlargement
                  if (enlargement < minEnlargement) {
                      minEnlargement = enlargement;
                      minArea = area < minArea ? area : minArea;
                      targetNode = child;

                  } else if (enlargement === minEnlargement) {
                      // otherwise choose one with the smallest area
                      if (area < minArea) {
                          minArea = area;
                          targetNode = child;
                      }
                  }
              }

              node = targetNode || node.children[0];
          }

          return node;
      }

      _insert(item, level, isNode) {
          const bbox = isNode ? item : this.toBBox(item);
          const insertPath = [];

          // find the best node for accommodating the item, saving all nodes along the path too
          const node = this._chooseSubtree(bbox, this.data, level, insertPath);

          // put the item into the node
          node.children.push(item);
          extend$1(node, bbox);

          // split on node overflow; propagate upwards if necessary
          while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                  this._split(insertPath, level);
                  level--;
              } else break;
          }

          // adjust bboxes along the insertion path
          this._adjustParentBBoxes(bbox, insertPath, level);
      }

      // split overflowed node into two
      _split(insertPath, level) {
          const node = insertPath[level];
          const M = node.children.length;
          const m = this._minEntries;

          this._chooseSplitAxis(node, m, M);

          const splitIndex = this._chooseSplitIndex(node, m, M);

          const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;

          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);

          if (level) insertPath[level - 1].children.push(newNode);
          else this._splitRoot(node, newNode);
      }

      _splitRoot(node, newNode) {
          // split root node
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
      }

      _chooseSplitIndex(node, m, M) {
          let index;
          let minOverlap = Infinity;
          let minArea = Infinity;

          for (let i = m; i <= M - m; i++) {
              const bbox1 = distBBox(node, 0, i, this.toBBox);
              const bbox2 = distBBox(node, i, M, this.toBBox);

              const overlap = intersectionArea(bbox1, bbox2);
              const area = bboxArea(bbox1) + bboxArea(bbox2);

              // choose distribution with minimum overlap
              if (overlap < minOverlap) {
                  minOverlap = overlap;
                  index = i;

                  minArea = area < minArea ? area : minArea;

              } else if (overlap === minOverlap) {
                  // otherwise choose distribution with minimum area
                  if (area < minArea) {
                      minArea = area;
                      index = i;
                  }
              }
          }

          return index || M - m;
      }

      // sorts node children by the best axis for split
      _chooseSplitAxis(node, m, M) {
          const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
          const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
          const xMargin = this._allDistMargin(node, m, M, compareMinX);
          const yMargin = this._allDistMargin(node, m, M, compareMinY);

          // if total distributions margin value is minimal for x, sort by minX,
          // otherwise it's already sorted by minY
          if (xMargin < yMargin) node.children.sort(compareMinX);
      }

      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin(node, m, M, compare) {
          node.children.sort(compare);

          const toBBox = this.toBBox;
          const leftBBox = distBBox(node, 0, m, toBBox);
          const rightBBox = distBBox(node, M - m, M, toBBox);
          let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

          for (let i = m; i < M - m; i++) {
              const child = node.children[i];
              extend$1(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
          }

          for (let i = M - m - 1; i >= m; i--) {
              const child = node.children[i];
              extend$1(rightBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(rightBBox);
          }

          return margin;
      }

      _adjustParentBBoxes(bbox, path, level) {
          // adjust bboxes along the given tree path
          for (let i = level; i >= 0; i--) {
              extend$1(path[i], bbox);
          }
      }

      _condense(path) {
          // go through the path, removing empty nodes and updating bboxes
          for (let i = path.length - 1, siblings; i >= 0; i--) {
              if (path[i].children.length === 0) {
                  if (i > 0) {
                      siblings = path[i - 1].children;
                      siblings.splice(siblings.indexOf(path[i]), 1);

                  } else this.clear();

              } else calcBBox(path[i], this.toBBox);
          }
      }
  }

  function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (let i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) return i;
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (let i = k; i < p; i++) {
          const child = node.children[i];
          extend$1(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend$1(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      const minX = Math.max(a.minX, b.minX);
      const minY = Math.max(a.minY, b.minY);
      const maxX = Math.min(a.maxX, b.maxX);
      const maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains$1(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      const stack = [left, right];

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) continue;

          const mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  var _a$2;
  function positioningToAnchor(positioning) {
      var p = positioning.split("-");
      var res = [0, 0];
      switch (p[0]) {
          case "top":
              res[1] = 0;
              break;
          case "center":
              res[1] = 0.5;
              break;
          case "bottom":
              res[1] = 1;
              break;
      }
      switch (p[1]) {
          case "left":
              res[0] = 0;
              break;
          case "center":
              res[0] = 0.5;
              break;
          case "right":
              res[0] = 1;
              break;
      }
      return res;
  }
  OlIcon__default["default"].prototype.getAnchor = function () {
      if (this.normalizedAnchor_) {
          return this.normalizedAnchor_;
      }
      var anchor = this.anchor_;
      var size = this.getSize();
      // if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
      if (this.anchorXUnits_ === "fraction" || this.anchorYUnits_ === "fraction") {
          if (!size) {
              return null;
          }
          anchor = this.anchor_.slice();
          if (this.anchorXUnits_ === "fraction") {
              anchor[0] *= size[0];
          }
          if (this.anchorYUnits_ === "fraction") {
              anchor[1] *= size[1];
          }
      }
      // if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
      if (this.anchorOrigin_ !== "top-left") {
          if (!size) {
              return null;
          }
          if (anchor === this.anchor_) {
              anchor = this.anchor_.slice();
          }
          // if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          if (this.anchorOrigin_ === "top-right" || this.anchorOrigin_ === "bottom-right") {
              anchor[0] = -anchor[0] + size[0];
          }
          // if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
          if (this.anchorOrigin_ === "bottom-left" || this.anchorOrigin_ === "bottom-right") {
              anchor[1] = -anchor[1] + size[1];
          }
      }
      this.normalizedAnchor_ = anchor;
      if (this.pixelOffset) {
          this.normalizedAnchor_[0] -= this.pixelOffset[0];
          this.normalizedAnchor_[1] -= this.pixelOffset[1];
      }
      return this.normalizedAnchor_;
  };
  function translateToIcon(styleItem, properties) {
      var config = __assign$1({}, styleItem);
      if (typeof config.image === "string") {
          config.src = config.image;
      }
      else {
          config.img = config.image;
      }
      defined$1(config.offset) && ((config.pixelOffset = config.offset), (config.offset = void 0));
      defined$1(config.olOffset) && (config.offset = config.olOffset);
      defined$1(config.rotation) && (config.rotation = toRadians(config.rotation));
      defined$1(config.width) && !defined$1(config.imgSize) && (config.imgSize = [config.width, config.height]);
      if (defined$1(config.positioning) && !defined$1(config.anchor)) {
          config.anchor = positioningToAnchor(config.positioning);
      }
      // TODO:实现图片偏移
      var icon = new OlIcon__default["default"](config);
      icon[ORIGINAL_ROTATION] = icon.getRotation();
      icon[ICON_ROTATED] = config.rotated;
      icon["pixelOffset"] = config.pixelOffset;
      return [new OlStyle__default["default"](__assign$1({ image: icon }, (defined$1(styleItem.zIndex) ? { zIndex: styleItem.zIndex } : {})))];
  }
  function translateToText(styleItem, properties) {
      var config = styleItem;
      if (/{|}/g.test(config.text)) {
          config.textTemplate = config.text;
          config.text = void 0;
      }
      if (defined$1(config.offset) && !defined$1(config.offsetX) && !defined$1(config.offsetY)) {
          config.offsetX = config.offset[0];
          config.offsetY = config.offset[1];
      }
      defined$1(config.fillColor) && !defined$1(config.fill) && (config.fill = new Fill__default["default"]({ color: config.fillColor }));
      defined$1(config.outlineWidth) &&
          config.outlineWidth > 0 &&
          !defined$1(config.stroke) &&
          (config.stroke = new Stroke__default["default"]({ color: config.outlineColor, width: config.outlineWidth }));
      config.showBackground === true &&
          !defined$1(config.backgroundFill) &&
          (config.backgroundFill = new Fill__default["default"]({ color: config.backgroundColor }));
      defined$1(config.backgroundPadding) &&
          !defined$1(config.padding) &&
          (config.padding = [
              config.backgroundPadding[1],
              config.backgroundPadding[0],
              config.backgroundPadding[1],
              config.backgroundPadding[0]
          ]);
      var text = new Text__default["default"](config);
      // 将含有占位符的文本模板转为字符串
      if (defined$1(config.textTemplate) && defined$1(properties)) {
          text.setText(replaceText(config.textTemplate, properties));
      }
      return [new OlStyle__default["default"](__assign$1({ text: text }, (defined$1(styleItem.zIndex) ? { zIndex: styleItem.zIndex } : {})))];
  }
  function translateToCircle(styleItem, properties) {
      var config = styleItem;
      defined$1(config.fillColor) && (config.fill = new Fill__default["default"]({ color: config.fillColor }));
      defined$1(config.outlineWidth) &&
          config.outlineWidth > 0 &&
          defined$1(config.outlineColor) &&
          !defined$1(config.stroke) &&
          (config.stroke = new Stroke__default["default"]({ color: config.outlineColor, width: config.outlineWidth }));
      var image = new CircleStyle__default["default"](config);
      return [new OlStyle__default["default"](__assign$1({ image: image }, (defined$1(styleItem.zIndex) ? { zIndex: styleItem.zIndex } : {})))];
  }
  function translateToFillAndStroke(styleItem, properties) {
      var config = styleItem;
      defined$1(config.fillColor) && (config.fill = new Fill__default["default"]({ color: config.fillColor }));
      config.width > 0 &&
          !defined$1(config.stroke) &&
          (config.stroke = new Stroke__default["default"](__assign$1(__assign$1({}, config), { lineCap: config.lineCap ? config.lineCap : "butt", color: config.borderColor, width: config.width })));
      defined$1(styleItem.zIndex) && (config.zIndex = styleItem.zIndex);
      return [new OlStyle__default["default"](config)];
  }
  // 转化为样式自定义渲染器
  function translateToRenderer(styleItem, properties) {
      return [
          new OlStyle__default["default"](__assign$1({ renderer: styleItem.renderFunction }, (defined$1(styleItem.zIndex) ? { zIndex: styleItem.zIndex } : {})))
      ];
  }
  // 转化为径向渐变
  function translateToRadialGradient(styleItem, properties) {
      return [
          new OlStyle__default["default"](__assign$1({ renderer: function (coordinates, states) {
                  var context = states.context, geometry = states.geometry;
                  if (geometry instanceof OLCircleGeom__default["default"]) {
                      var _a = __read(coordinates, 2), _b = __read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a[1], 2), x2 = _c[0], y2 = _c[1];
                      var borderColor = styleItem.borderColor, width = styleItem.width, lineDash = styleItem.lineDash;
                      var radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                      context.restore();
                      context.save();
                      drawRadialGradient(context, styleItem, [x1, y1], radius);
                      context.beginPath();
                      if (width > 0) {
                          context.lineWidth = width;
                          lineDash && context.setLineDash(lineDash);
                          context.strokeStyle = borderColor;
                          context.arc(x1, y1, radius, 0, 2 * Math.PI, true);
                          context.stroke();
                      }
                      context.restore();
                  }
              } }, (defined$1(styleItem.zIndex) ? { zIndex: styleItem.zIndex } : {})))
      ];
  }
  function translateToRotate(styleItem, properties) {
      var rate = 0;
      var time = performance.now();
      var duration = styleItem.duration, image = styleItem.image, color = styleItem.color, reverse = styleItem.reverse;
      var canvas;
      getImageAndMixColor({ image: image, color: color }).then(function (data) {
          canvas = data;
      });
      return translateToRenderer({
          type: StyleItemType.RENDERER,
          renderFunction: function (_a, states) {
              var _b = __read(_a, 2), _c = __read(_b[0], 2), x1 = _c[0], y1 = _c[1], _d = __read(_b[1], 2), x2 = _d[0], y2 = _d[1];
              if (!(states.geometry instanceof OLCircleGeom__default["default"]) || !defined$1(canvas)) {
                  states.layer.changed();
                  return;
              }
              var context = states.context;
              context.save();
              rate = ((performance.now() - time) % (duration * 1000)) / (duration * 1000);
              var radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
              context.translate(x1, y1);
              context.rotate(((360 * rate * Math.PI) / 180) * (reverse ? -1 : 1));
              context.translate(-x1, -y1);
              context.drawImage(canvas, x1 - radius, y1 - radius, radius * 2, radius * 2);
              context.setTransform(1, 0, 0, 1, 0, 0);
              context.restore();
              states.layer.changed();
          }
      });
  }
  var CANVAS_LINK = Symbol("CanvasLink");
  function translateToRippleStyle(styleItem, properties) {
      return translateToRenderer({
          type: StyleItemType.RENDERER,
          renderFunction: function (_a, states) {
              var _b, _c, _d;
              var _e = __read(_a, 2), _f = __read(_e[0], 2), x1 = _f[0], y1 = _f[1], _g = __read(_e[1], 2), x2 = _g[0], y2 = _g[1];
              if (!(states.geometry instanceof OLCircleGeom__default["default"])) {
                  return;
              }
              var duration = styleItem.duration, image = styleItem.image, color = styleItem.color;
              if (!defined$1((_b = states.feature) === null || _b === void 0 ? void 0 : _b[CANVAS_LINK])) {
                  states.feature[CANVAS_LINK] = { loading: true, canvas: void 0 };
                  var feature_1 = states.feature;
                  getImageAndMixColor({ image: image, color: color }).then(function (data) {
                      feature_1[CANVAS_LINK].loading = false;
                      feature_1[CANVAS_LINK].canvas = data;
                      feature_1[CANVAS_LINK].time = performance.now();
                  });
              }
              else if (((_d = (_c = states.feature) === null || _c === void 0 ? void 0 : _c[CANVAS_LINK]) === null || _d === void 0 ? void 0 : _d.loading) === false) {
                  var context_1 = states.context;
                  var _h = states.feature[CANVAS_LINK], time = _h.time, canvas = _h.canvas;
                  context_1.save();
                  var rate = ((performance.now() - time) % (duration * 1000)) / (duration * 1000);
                  var radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) * rate;
                  context_1.globalAlpha = 1 - rate;
                  context_1.drawImage(canvas, x1 - radius, y1 - radius, radius * 2, radius * 2);
                  context_1.restore();
              }
              states.layer.changed();
          }
      });
  }
  // 线性流动-----
  /**
   * color: 'green',
    width: 10,
    arrowSize: [5, 9],
    arrowLineWidth: 2,
    arrowLineColor: '#faf4ff'
   * @param styleItem
   * @param properties
   * @returns
   */
  function translateToLinearFlowStyle(styleItem, properties) {
      var canvas;
      if (defined$1(styleItem.arrowImage)) {
          getImage(styleItem.arrowImage).then(function (data) {
              canvas = data;
          });
      }
      else {
          canvas = createCanvasArrow(styleItem);
      }
      return translateToRenderer({
          type: StyleItemType.RENDERER,
          renderFunction: function (coordinates, states) {
              if (defined$1(canvas)) {
                  var offset = states.feature.__arrowLineOffset || 0;
                  var context_2 = render.toContext(states.context, { pixelRatio: 1 });
                  context_2.setStyle(new OlStyle__default["default"]({
                      stroke: new Stroke__default["default"](__assign$1({}, styleItem))
                  }));
                  // 绘制轨迹线
                  var trackLine = new LineString__default["default"](coordinates);
                  var tree_1 = new RBush();
                  trackLine.forEachSegment(function (start, end) {
                      var p = start;
                      var p0 = end;
                      // 计算每个segment的方向，即箭头旋转方向
                      var rotation;
                      if (p[1] <= p0[1]) {
                          rotation = Math.PI / 2 - Math.atan2(p[1] - p0[1], p[0] - p0[0]);
                      }
                      else {
                          var temR = -Math.atan2(p0[1] - p[1], p0[0] - p[0]);
                          if (temR > Math.PI / 2) {
                              rotation = (Math.PI * 3) / 2 + temR;
                          }
                          else {
                              rotation = temR - Math.PI / 2;
                          }
                      }
                      rotation = rotation + (90 / 180) * Math.PI;
                      var geom = new LineString__default["default"]([start, end]);
                      // 获取线范围
                      var extent = geom.getExtent();
                      var item = {
                          minX: extent[0],
                          minY: extent[1],
                          maxX: extent[2],
                          maxY: extent[3],
                          geom: geom,
                          rotation: rotation
                      };
                      tree_1.insert(item);
                  });
                  // 轨迹地理长度
                  var length_1 = trackLine.getLength();
                  // 像素间隔步长
                  var stpes = styleItem.interval || 40;
                  // 将像素步长转实际地理距离步长
                  var geo_steps = stpes;
                  // 计算箭头数量----
                  var arrowsNum = Math.round(length_1 / geo_steps);
                  if (offset > length_1 * (1 - 1 / arrowsNum)) {
                      offset = 0;
                  }
                  var _loop_1 = function (i) {
                      var fraction = (i * 1.0) / arrowsNum + offset / length_1;
                      if (fraction > 1) {
                          fraction = fraction - 1;
                      }
                      var arraw_coor = trackLine.getCoordinateAt(fraction);
                      var tol = 10; // 查询设置的点的容差，测试地图单位是米。如果是4326坐标系单位为度的话，改成0.0001.
                      var arraw_coor_buffer = [
                          arraw_coor[0] - tol,
                          arraw_coor[1] - tol,
                          arraw_coor[0] + tol,
                          arraw_coor[1] + tol
                      ];
                      // 进行btree查询
                      var treeSearch = tree_1.search({
                          minX: arraw_coor_buffer[0],
                          minY: arraw_coor_buffer[1],
                          maxX: arraw_coor_buffer[2],
                          maxY: arraw_coor_buffer[3]
                      });
                      var arrow_rotation = void 0;
                      if (treeSearch.length === 1) {
                          arrow_rotation = treeSearch[0].rotation;
                      }
                      else if (treeSearch.length > 1) {
                          var results = treeSearch.filter(function (item) {
                              // 换一种方案，设置一个稍小的容差，消除精度问题
                              var _tol = 1; // 消除精度误差的容差
                              if (item.geom.intersectsExtent([
                                  arraw_coor[0] - _tol,
                                  arraw_coor[1] - _tol,
                                  arraw_coor[0] + _tol,
                                  arraw_coor[1] + _tol
                              ]))
                                  return true;
                          });
                          if (results.length > 0) {
                              arrow_rotation = results[0].rotation;
                          }
                      }
                      context_2.setStyle(new OlStyle__default["default"]({
                          image: new OlIcon__default["default"]({
                              img: canvas,
                              imgSize: [canvas.width, canvas.height],
                              rotation: -arrow_rotation
                          })
                      }));
                      context_2.drawGeometry(new Point__default["default"](arraw_coor));
                  };
                  // 箭头总数
                  for (var i = 0; i < arrowsNum; i++) {
                      _loop_1(i);
                  }
                  states.feature.__arrowLineOffset = offset + Math.abs(styleItem.speed || 100) / 60;
              }
              states.layer.changed();
          }
      });
  }
  function translateToArrowStyle(styleItem, properties) {
      var image = styleItem.image;
      var color = styleItem.color;
      var canvas;
      getImageAndMixColor({ image: image, color: color }).then(function (data) {
          canvas = data;
      });
      return translateToRenderer({
          type: StyleItemType.RENDERER,
          renderFunction: function (coordinates, states) {
              var context = render.toContext(states.context, { pixelRatio: 1 });
              context.setStyle(new OlStyle__default["default"]({
                  stroke: new Stroke__default["default"](__assign$1({}, styleItem))
              }));
              // 绘制轨迹线
              var trackLine = new LineString__default["default"](coordinates);
              context.drawGeometry(trackLine);
              var start = coordinates[coordinates.length - 2];
              var end = coordinates[coordinates.length - 1];
              // 计算每个segment的方向，即箭头旋转方向
              var rotation;
              if (start[1] <= end[1]) {
                  rotation = Math.PI / 2 - Math.atan2(start[1] - end[1], start[0] - end[0]);
              }
              else {
                  var temR = -Math.atan2(end[1] - start[1], end[0] - start[0]);
                  if (temR > Math.PI / 2) {
                      rotation = (Math.PI * 3) / 2 + temR;
                  }
                  else {
                      rotation = temR - Math.PI / 2;
                  }
              }
              rotation = rotation + (90 / 180) * Math.PI;
              if (canvas) {
                  context.setStyle(new OlStyle__default["default"]({
                      image: new OlIcon__default["default"]({
                          img: canvas,
                          imgSize: [canvas.width, canvas.height],
                          rotation: -rotation
                      })
                  }));
                  context.drawGeometry(new Point__default["default"](end));
              }
              else {
                  states.layer.changed();
              }
          }
      });
  }
  // 样式转换器-------
  var styleTranslator = (_a$2 = {},
      _a$2[StyleItemType.ICON] = [translateToIcon],
      _a$2[StyleItemType.LABEL] = [translateToText],
      _a$2[StyleItemType.CIRCLE] = [translateToCircle],
      _a$2[StyleItemType.COLOR] = [translateToFillAndStroke],
      _a$2[StyleItemType.RENDERER] = [translateToRenderer],
      _a$2[StyleItemType.RADIAL_GRADIENT] = [translateToRadialGradient],
      _a$2[StyleItemType.RIPPLE] = [translateToRippleStyle],
      _a$2[StyleItemType.ROTATE] = [translateToRotate],
      _a$2[StyleItemType.ARROW_FOW] = [translateToLinearFlowStyle],
      _a$2[StyleItemType.POLYLINE_ARROW] = [translateToArrowStyle],
      _a$2);
  // 样式选项转化为ol样式数组
  function styleItemToOlStyleArray(styleItem, properties) {
      var _a;
      return (((_a = styleTranslator[styleItem === null || styleItem === void 0 ? void 0 : styleItem.type]) === null || _a === void 0 ? void 0 : _a.reduce(function (prev, curr) {
          return prev.concat(curr(__assign$1(__assign$1({}, DEFAULT_STYLE_ITEM[styleItem.type]), styleItem), properties));
      }, [])) || []);
  }
  // 样式
  function styleItemListToOlStyleArray(styleItemList, properties) {
      return styleItemList.map(function (i) { return styleItemToOlStyleArray(i, properties); }).flat();
  }
  function styleItemListToOlStyleFunction(styleItemList, properties) {
      var olStyleArray = styleItemList.map(function (i) { return styleItemToOlStyleArray(i, properties); }).flat();
      var labelStyleIndex = [];
      !defined$1(properties) &&
          olStyleArray.forEach(function (i, index) {
              var _a;
              // @ts-ignore
              if (((_a = i.getText()) === null || _a === void 0 ? void 0 : _a.getTextTemplate()) !== void 0) {
                  labelStyleIndex.push(index);
              }
          });
      return function (olFeature, resolution) {
          var e_1, _a;
          try {
              for (var labelStyleIndex_1 = __values(labelStyleIndex), labelStyleIndex_1_1 = labelStyleIndex_1.next(); !labelStyleIndex_1_1.done; labelStyleIndex_1_1 = labelStyleIndex_1.next()) {
                  var index = labelStyleIndex_1_1.value;
                  olStyleArray[index] = olStyleArray[index].clone();
                  olStyleArray[index]
                      .getText()
                      // @ts-ignore
                      // 替代占位符
                      .setText(replaceText(olStyleArray[index].getText().getTextTemplate(), olFeature.getProperties()));
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (labelStyleIndex_1_1 && !labelStyleIndex_1_1.done && (_a = labelStyleIndex_1.return)) _a.call(labelStyleIndex_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return olStyleArray;
      };
  }
  function styleConditionToOlStyleFunction(styleCondition) {
      var style = styleCondition.map(function (i) {
          var item = {
              style: styleItemListToOlStyleFunction(i.style)
          };
          if (defined$1(i.condition)) {
              item.condition = i.condition;
          }
          return item;
      });
      return function (olFeature, resolution) {
          var _a, _b;
          return (((_b = (_a = style
              .find(function (item) {
              if (!defined$1(item.condition)) {
                  return true;
              }
              else {
                  return item.condition(olFeature[FEATURE_LINK] || olFeature);
              }
          })) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.call(_a, olFeature, resolution)) || []);
      };
  }
  // 自定义样式函数转化为ol样式函数----
  function styleFunctionToOlStyleFunction(func) {
      return function (olFeature, resolution) {
          var _a;
          return styleItemListToOlStyleArray(func(olFeature[FEATURE_LINK] || olFeature), ((_a = olFeature[FEATURE_LINK]) === null || _a === void 0 ? void 0 : _a.properties) || olFeature.getProperties());
      };
  }
  // 创建箭头图标
  function createCanvasArrow(options) {
      var _options = Object.assign({
          arrowSize: [5, 9],
          arrowLineWidth: 2,
          arrowLineColor: "#faf4ff"
      }, options);
      var canvas = document.createElement("canvas");
      var context = render.toContext(canvas.getContext("2d"), {
          size: [_options.arrowSize[0], _options.arrowSize[1]],
          pixelRatio: 1
      });
      var width = _options.arrowSize[0];
      var height = _options.arrowSize[1];
      if (height < 2)
          return;
      if (width < 1)
          return;
      context.setStyle(new OlStyle__default["default"]({
          stroke: new Stroke__default["default"]({
              color: _options.arrowLineColor,
              width: _options.arrowLineWidth
          })
      }));
      context.drawGeometry(new LineString__default["default"]([
          [0, 0],
          [width, height / 2],
          [0, height]
      ]));
      return canvas;
  }

  function styleToOlStyleFunction(style) {
      var olStyle;
      if (Array.isArray(style)) {
          if (defined$1(style[0].type)) {
              olStyle = styleItemListToOlStyleFunction(style);
          }
          else {
              olStyle = styleConditionToOlStyleFunction(style);
          }
      }
      else {
          olStyle = styleFunctionToOlStyleFunction(style);
      }
      return olStyle;
  }

  /**
   * 要素基础类
   *
   * 此为基类,不可实例化
   */
  var Feature = /** @class */ (function (_super) {
      __extends$6(Feature, _super);
      function Feature(options, layer) {
          var _this = _super.call(this, options.properties) || this;
          _this._coordinates = options.coordinates;
          _this._properties = options.properties || {};
          setFeatureProjection.call(_this, options);
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Feature.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "properties", {
          get: function () {
              return this._properties;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "style", {
          get: function () {
              return this._style;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "styleItemList", {
          get: function () {
              var _a;
              return (_a = (toStyleItemList(this.style) || (toStyleFunction(this.style) || this.layer.styleFunction)(this))) === null || _a === void 0 ? void 0 : _a.map(function (i) { return (__assign$1(__assign$1({}, DEFAULT_STYLE_ITEM[i.type]), i)); });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "type", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "sourceFeature", {
          /**
           * 该要素引用的底层要素
           */
          get: function () {
              return this._sourceFeature;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "layer", {
          /**
           * 应用图层样式
           */
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "wkt", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "geoJson", {
          get: function () {
              throw new Error(ErrorNotification.NOT_IMPLEMENTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "dataProjection", {
          get: function () {
              return this._dataProjection || PUBLIC_CONFIG.dataProjection;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "projection", {
          get: function () {
              return this._projection || PUBLIC_CONFIG.projection;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Feature.prototype, "offset", {
          get: function () {
              return this._offset;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化要素
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Feature.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到图层
       *
       * @ignore
       */
      Feature.prototype.addToLayer = function (layer) {
          var _this = this;
          var _a;
          // 已有图层属性存在
          if (this.layer && this.layer !== layer) {
              console.warn(ErrorNotification.ADDED_FEATURE);
              this.layer.removeFeature(this);
          }
          if (!defined$1(this.sourceFeature)) {
              this.init();
              if (defined$1(this.style)) {
                  this.setStyle(this.style);
              }
          }
          this._layer = layer;
          this.map = layer.map;
          this.sourceFeature[FEATURE_LINK] = this;
          (_a = this.layer.layer) === null || _a === void 0 ? void 0 : _a.forEach(function (i) {
              i.getSource().addFeature(_this.sourceFeature);
          });
      };
      /**
       * 从图层中移除
       *
       * @ignore
       */
      Feature.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!defined$1(this.layer)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.layer.forEach(function (i) {
              i.getSource().removeFeature(_this.sourceFeature);
          });
          this._layer = void 0;
      };
      /**
       * 设置要素属性
       * @param properties
       */
      Feature.prototype.setProperties = function (properties) {
          this._properties = __assign$1({}, properties);
          this.sourceFeature.setProperties(this._properties);
          return this;
      };
      /**
       * 设置要素坐标
       * @param coordinates
       */
      Feature.prototype.setCoordinates = function (coordinates) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 设置样式
       * @param style
       * @param isLayerStyle
       * @returns
       */
      Feature.prototype.setStyle = function (style, isLayerStyle) {
          this._style = style;
          if (!defined$1(this.sourceFeature)) {
              return this;
          }
          var olStyle;
          if (!(!defined$1(style) || (Array.isArray(style) && style.length <= 0))) {
              olStyle = styleToOlStyleFunction(style);
          }
          this.sourceFeature.setStyle(olStyle);
          this.dispatchEvent({
              type: BaseEventType.STYLE_CHANGED
          });
          return this;
      };
      /**
       * @ignore
       */
      Feature.prototype._destroy = function () {
          this.remove();
          this._sourceFeature = this._coordinates = this._coordinates = this._properties = void 0;
          _super.prototype._destroy.call(this);
      };
      return Feature;
  }(BaseObject$1));

  var Polyline$1 = /** @class */ (function (_super) {
      __extends$6(Polyline, _super);
      function Polyline(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          return _super.call(this, { coordinates: coordinates, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }, layer) || this;
      }
      Object.defineProperty(Polyline.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "geoJson", {
          get: function () {
              if (this.type === GeoJsonGeometryType.LINE_STRING) {
                  return lineString(this.coordinates, this.properties);
              }
              else {
                  return multiLineString(this.coordinates, this.properties);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polyline.prototype, "type", {
          get: function () {
              var type;
              if (Array.isArray(this.coordinates[0][0])) {
                  type = GeoJsonGeometryType.MULTI_LINE_STRING;
              }
              else {
                  type = GeoJsonGeometryType.LINE_STRING;
              }
              return type;
          },
          enumerable: false,
          configurable: true
      });
      Polyline.prototype.init = function () {
          this._sourceFeature = new OlFeature__default["default"]({
              geometry: buildGeometry(this.coordinates, {
                  dataProjection: this.dataProjection,
                  projection: this.projection,
                  offset: this.offset
              })
          });
          this._sourceFeature.setProperties(this.properties, true);
      };
      Polyline.prototype.setCoordinates = function (coordinates, options) {
          this._coordinates = coordinates;
          setFeatureProjection.call(this, options);
          this.sourceFeature.setGeometry(buildGeometry(this._coordinates, options));
          return this;
      };
      return Polyline;
  }(Feature));
  function buildGeometry(coordinates, options) {
      if (Array.isArray(coordinates) && coordinates.length && Array.isArray(coordinates[0][0])) {
          return new OlMultiLineString__default["default"](coordinates.map(function (coordinate) {
              return coordinate.map(function (i) {
                  return transformInternal(i, {
                      source: options === null || options === void 0 ? void 0 : options.dataProjection,
                      destination: options === null || options === void 0 ? void 0 : options.projection,
                      offset: options === null || options === void 0 ? void 0 : options.offset
                  });
              });
          }));
      }
      else {
          return new LineString__default["default"](coordinates.map(function (m) {
              return transformInternal(m, {
                  source: options === null || options === void 0 ? void 0 : options.dataProjection,
                  destination: options === null || options === void 0 ? void 0 : options.projection,
                  offset: options === null || options === void 0 ? void 0 : options.offset
              });
          }));
      }
  }

  var Polygon$1 = /** @class */ (function (_super) {
      __extends$6(Polygon, _super);
      function Polygon(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          return _super.call(this, { coordinates: coordinates, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }, layer) || this;
      }
      Object.defineProperty(Polygon.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "geoJson", {
          get: function () {
              if (this.type === GeoJsonGeometryType.POLYGON) {
                  if (this.coordinates.length === 1) {
                      var first = this.coordinates[0][0];
                      var end = this.coordinates[0][this.coordinates[0].length - 1];
                      if (first[0] !== end[0] || first[1] !== end[1]) {
                          this.coordinates[0].push(first);
                      }
                  }
                  return polygon(this.coordinates, this.properties);
              }
              else {
                  return multiPolygon(this.coordinates, this.properties);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Polygon.prototype, "type", {
          get: function () {
              var type;
              if (Array.isArray(this.coordinates[0][0][0])) {
                  type = GeoJsonGeometryType.MULTI_POLYGON;
              }
              else {
                  type = GeoJsonGeometryType.POLYGON;
              }
              return type;
          },
          enumerable: false,
          configurable: true
      });
      Polygon.prototype.init = function () {
          this._sourceFeature = new OlFeature__default["default"]({
              geometry: buildPolygonGeometry(this.coordinates, {
                  dataProjection: this.dataProjection,
                  projection: this.projection,
                  offset: this.offset
              })
          });
          this._sourceFeature.setProperties(this.properties, true);
      };
      Polygon.prototype.setCoordinates = function (coordinates, options) {
          this._coordinates = coordinates;
          setFeatureProjection.call(this, options);
          var update = defined$1(options === null || options === void 0 ? void 0 : options.update) ? options === null || options === void 0 ? void 0 : options.update : true;
          update && this.sourceFeature.setGeometry(buildPolygonGeometry(this._coordinates, options));
          return this;
      };
      return Polygon;
  }(Feature));
  function buildPolygonGeometry(coordinates, options) {
      if (Array.isArray(coordinates) && coordinates.length && Array.isArray(coordinates[0][0][0])) {
          return new OlMultiPolygon__default["default"](coordinates.map(function (m) {
              return m.map(function (i) {
                  return i.map(function (j) {
                      return transformInternal(j, {
                          source: options === null || options === void 0 ? void 0 : options.dataProjection,
                          destination: options === null || options === void 0 ? void 0 : options.projection,
                          offset: options === null || options === void 0 ? void 0 : options.offset
                      });
                  });
              });
          }));
      }
      else {
          return new Polygon__default["default"](coordinates.map(function (m) {
              return m.map(function (i) {
                  return transformInternal(i, {
                      source: options === null || options === void 0 ? void 0 : options.dataProjection,
                      destination: options === null || options === void 0 ? void 0 : options.projection,
                      offset: options === null || options === void 0 ? void 0 : options.offset
                  });
              });
          }));
      }
  }

  /**
   * 将geoJson对象转换为要素数组
   *
   * @param geoJson geoJson数据
   * @returns
   */
  function read$2(geoJson, options) {
      return geoJsonToFeature(geoJson, { Point: Point$1, Polygon: Polygon$1, Polyline: Polyline$1 }, options);
  }
  /**
   * 将Feature对象数组转为geoJson集合对象
   *
   * @param {Feature[]} features 要素数组
   * @returns {FeatureCollectionGeoJSON}
   */
  function write$2(features, options) {
      return featuresToGeoJsonFeatureCollection(features, options);
  }

  var GeoJSON = /*#__PURE__*/Object.freeze({
    __proto__: null,
    read: read$2,
    write: write$2,
    get GeoJsonGeometryType () { return GeoJsonGeometryType; },
    get GeoJsonType () { return GeoJsonType; },
    create: dataToGeoJsonFeatureCollection,
    point: point,
    multiPoint: multiPoint,
    lineString: lineString,
    multiLineString: multiLineString,
    polygon: polygon,
    multiPolygon: multiPolygon,
    feature: feature$2,
    featureCollection: featureCollection
  });

  var Point$1 = /** @class */ (function (_super) {
      __extends$6(Point, _super);
      function Point(_a, layer) {
          var coordinates = _a.coordinates, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: coordinates, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }, layer) || this;
          _this._rotation = 0;
          return _this;
      }
      Object.defineProperty(Point.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "wkt", {
          get: function () {
              return geoJsonFeatureToWkt(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "type", {
          get: function () {
              var type;
              if (Array.isArray(this.coordinates[0])) {
                  type = GeoJsonGeometryType.MULTI_POINT;
              }
              else {
                  type = GeoJsonGeometryType.POINT;
              }
              return type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "geoJson", {
          get: function () {
              if (this.type === GeoJsonGeometryType.POINT) {
                  return point(this.coordinates, this.properties);
              }
              else {
                  return multiPoint(this.coordinates, this.properties);
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Point.prototype, "rotation", {
          get: function () {
              return this._rotation;
          },
          set: function (rotation) {
              this._rotation = rotation;
          },
          enumerable: false,
          configurable: true
      });
      Point.prototype.init = function () {
          this._sourceFeature = new OlFeature__default["default"]({
              geometry: buildPointGeometry(this.coordinates, {
                  dataProjection: this.dataProjection,
                  projection: this.projection,
                  offset: this.offset
              })
          });
          this._sourceFeature.setProperties(this.properties, true);
      };
      Point.prototype.setCoordinates = function (coordinates, options) {
          this._coordinates = coordinates;
          setFeatureProjection.call(this, options);
          this.sourceFeature.setGeometry(buildPointGeometry(this._coordinates, options));
          return this;
      };
      return Point;
  }(Feature));
  function buildPointGeometry(coordinates, options) {
      if (Array.isArray(coordinates[0])) {
          return new OlMultiPoint__default["default"](coordinates.map(function (coordinate) {
              return transformInternal(coordinate, {
                  source: options === null || options === void 0 ? void 0 : options.dataProjection,
                  destination: options === null || options === void 0 ? void 0 : options.projection,
                  offset: options === null || options === void 0 ? void 0 : options.offset
              });
          }));
      }
      else {
          return new Point__default["default"](transformInternal(coordinates, {
              source: options === null || options === void 0 ? void 0 : options.dataProjection,
              destination: options === null || options === void 0 ? void 0 : options.projection,
              offset: options === null || options === void 0 ? void 0 : options.offset
          }));
      }
  }

  /**
   * 将geoJson对象转换为要素数组
   *
   * @param geoJson geoJson数据
   * @returns
   */
  function read$1(geoJson, options) {
      return geoJsonToFeature(geoJson, { Point: Point$1, Polygon: Polygon$1, Polyline: Polyline$1 }, options);
  }
  /**
   * 将Feature对象数组转为geoJson集合对象
   *
   * @param {Feature[]} features 要素数组
   * @returns {FeatureCollectionGeoJSON}
   */
  function write$1(features, options) {
      return featuresToGeoJsonFeatureCollection(features, options);
  }

  /**
   * 将业务数据数组转为Feature对象数组
   *
   * **业务数据格式**
   *
   * ```
   * { x: number; y: number; z?: number; [propName: string]: any }[]
   * | { lng: number; lat: number; height?: number; [propName: string]: any }[]
   * | { lon: number; lat: number; height?: number; [propName: string]: any }[]
   * | {
   *     longitude: number;
   *     latitude: number;
   *     height?: number;
   *     [propName: string]: any;
   *   }[]
   * | { wkt: string; [propName: string]: any }[];
   * ```
   *
   * @param {Array<object>} data 业务数据对象数组
   * @param {string} offset 偏移类型 可选值：'WGStoGCJ', 'GCJtoWGS','GCJtoBD','BDtoGCJ','WGStoBD','BDtoWGS'
   * @returns {Array<Feature>}
   *
   */
  function create$5(data, options) {
      return dataToFeatures(data, options);
  }
  function dataToFeatures(data, options) {
      return vectorDataToFeatures(data, { Feature: Feature, Point: Point$1, Polyline: Polyline$1, Polygon: Polygon$1 }, options);
  }

  var AnimationClusterLayer = /** @class */ (function (_super) {
      __extends$6(AnimationClusterLayer, _super);
      function AnimationClusterLayer(options) {
          var _this = _super.call(this, options) || this;
          _this._oldcluster = new VectorSource__default["default"]();
          _this._clusters = [];
          _this._animation = { start: false };
          _this.set("animationDuration", typeof options.animationDuration === "number" ? options.animationDuration : 700);
          _this.set("animationMethod", options.animationMethod || easing.easeOut);
          _this.getSource().on("sendFeatures", _this.saveCluster.bind(_this));
          _this.on(["prerender"], _this.animate.bind(_this));
          _this.on(["postrender"], _this.postanimate.bind(_this));
          return _this;
      }
      AnimationClusterLayer.prototype.saveCluster = function (event) {
          if (this._oldcluster) {
              this._oldcluster.clear();
              if (!this.get("animationDuration"))
                  return;
              // 获取数据源中的聚合要素
              var features = event.features;
              if (features.length && features[0].get("features")) {
                  // 渲染之前先保存起来
                  this._oldcluster.addFeatures(this._clusters);
                  this._clusters = features.slice(0);
                  this._sourceChanged = true;
              }
          }
      };
      AnimationClusterLayer.prototype.getClusterForFeature = function (f, cluster) {
          for (var j = 0; j < cluster.length; j++) {
              var c = cluster[j];
              var features = c.get("features");
              if (features && features.length) {
                  for (var k = 0, f2 = void 0; (f2 = features[k]); k++) {
                      if (f === f2) {
                          return c;
                      }
                  }
              }
          }
          return false;
      };
      AnimationClusterLayer.prototype.stopAnimation = function () {
          this._animation.start = false;
          this._animation.cA = [];
          this._animation.cB = [];
      };
      AnimationClusterLayer.prototype.animate = function (e) {
          var duration = this.get("animationDuration");
          if (!duration)
              return;
          //  获取当前渲染帧地图分辨率---
          var resolution = e.frameState.viewState.resolution;
          // var ratio = e.frameState.pixelRatio;
          // 获取当前渲染时间
          var time = e.frameState.time;
          var f;
          // 开始一个动画，当数据源发生变化，或者地图缩放级别发生变化
          if (this._animation.resolution !== resolution && this._sourceChanged) {
              var extent$1 = e.frameState.extent;
              if (this._animation.resolution < resolution) {
                  extent$1 = extent.buffer(extent$1, 100 * resolution);
                  this._animation.cA = this._oldcluster.getFeaturesInExtent(extent$1);
                  this._animation.cB = this.getSource().getFeaturesInExtent(extent$1);
                  this._animation.revers = false;
              }
              else {
                  extent$1 = extent.buffer(extent$1, 100 * resolution);
                  this._animation.cA = this.getSource().getFeaturesInExtent(extent$1);
                  this._animation.cB = this._oldcluster.getFeaturesInExtent(extent$1);
                  this._animation.revers = true;
              }
              this._animation.clusters = [];
              for (var i = 0, c0 = void 0; (c0 = this._animation.cA[i]); i++) {
                  var f_1 = c0.get("features");
                  if (f_1 && f_1.length) {
                      var c = this.getClusterForFeature(f_1[0], this._animation.cB);
                      if (c)
                          this._animation.clusters.push({ f: c0, pt: c.getGeometry().getCoordinates() });
                  }
              }
              // 保存上一次聚合动画的状态
              this._animation.resolution = resolution;
              // 数据源是否更改状态
              this._sourceChanged = false;
              // 没有聚合or 太多的动画、停止动画
              if (!this._animation.clusters.length || this._animation.clusters.length > 1000) {
                  this.stopAnimation();
                  return;
              }
              // 从现在开始动画
              time = this._animation.start = new Date().getTime();
          }
          // 运行动画
          if (this._animation.start) {
              var vectorContext = render.getVectorContext(e);
              // 计算动画持续时间和已经设置的动画持续时间的比值，>=1 表动画结束
              var d = (time - this._animation.start) / duration;
              // 动画结束
              if (d > 1.0) {
                  // 动画结束
                  this.stopAnimation();
                  d = 1;
              }
              // 动画的松弛函数方法
              d = this.get("animationMethod")(d);
              // 动画
              var style_1 = this.getStyle();
              var stylefn = typeof style_1 === "function"
                  ? style_1
                  : Array.isArray(style_1) && style_1.length
                      ? function () {
                          return style_1;
                      }
                      : function () {
                          return [style_1];
                      };
              // 保存canvas 上下文状态
              e.context.save();
              // 上下文透明度设置为图层透明度
              e.context.globalAlpha = this.getOpacity();
              for (var i = 0, c = void 0; (c = this._animation.clusters[i]); i++) {
                  var pt = c.f.getGeometry().getCoordinates();
                  var dx = pt[0] - c.pt[0];
                  var dy = pt[1] - c.pt[1];
                  // 是否翻转动画
                  if (this._animation.revers) {
                      pt[0] = c.pt[0] + d * dx;
                      pt[1] = c.pt[1] + d * dy;
                  }
                  else {
                      pt[0] = pt[0] - d * dx;
                      pt[1] = pt[1] - d * dy;
                  }
                  // 获取要素样式
                  var st = stylefn(c.f, resolution);
                  if (!Array.isArray(st))
                      st = [st];
                  // 如果一个特征:绘制特征
                  if (c.f.get("features").length === 1 && !dx && !dy) {
                      f = c.f.get("features")[0];
                  }
                  // 或者绘制一个点
                  else {
                      var geo = new Point__default["default"](pt);
                      f = new OlFeature__default["default"](geo);
                  }
                  for (var k = st.length - 1; k >= 0; k--) {
                      var style_2 = st[k];
                      vectorContext.drawFeature(f, style_2);
                  }
              }
              e.context.restore();
              // 告诉ol继续postcompose动画
              e.frameState.animate = true;
              // 防止图层绘制
              e.context.save();
              e.context.beginPath();
              e.context.rect(0, 0, 0, 0);
              e.context.clip();
              this._clip = true;
          }
          return;
      };
      AnimationClusterLayer.prototype.postanimate = function (e) {
          if (this._clip) {
              e.context.restore();
              this._clip = false;
          }
      };
      return AnimationClusterLayer;
  }(VectorLayer__default["default"]));

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter$7(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function defined(value) {
      return value !== void 0 && value !== null;
  }
  class BaseJob {
      constructor(options = {}) {
          this._freeze = false;
          this._queue = [];
          this._id = options.id || performance.now() + "";
          if (options.tasks) {
              for (const task of options.tasks) {
                  this.add(task);
              }
          }
      }
      get id() {
          return this._id;
      }
      get freeze() {
          return this._freeze;
      }
      set freeze(value) {
          this._freeze = value;
      }
      get queue() {
          return this._queue;
      }
      add(task) {
          if (!this._freeze) {
              this._queue.push(task);
          }
          else {
              console.warn("工作已冻结,不可再添加");
          }
          return this;
      }
      run(previousTaskResult) {
          return __awaiter$7(this, void 0, void 0, function* () {
              this.job.freeze = true;
              for (const task of this.job.queue) {
                  previousTaskResult = yield task.run.call({ jobScheduler: this.jobScheduler, job: this.job, task }, previousTaskResult);
              }
              return previousTaskResult;
          });
      }
  }
  class JobScheduler {
      constructor() {
          this._id = performance.now() + "";
          this._schedulerStore = new Map();
          this._jobQueue = [];
          this._paused = false;
          this._pauseKeyStore = new Set();
      }
      get id() {
          return this._id;
      }
      get paused() {
          return this._paused;
      }
      get activeJob() {
          return this._activeJob;
      }
      _run(previousTaskResult) {
          this._activeJob = this._jobQueue[0];
          if (this._activeJob && !this._paused) {
              this._activeJob.run
                  .call({ jobScheduler: this, job: this._activeJob }, previousTaskResult)
                  .then((taskResult) => {
                  this._jobQueue = this._jobQueue.slice(1);
                  this._activeJob = void 0;
                  this._run(taskResult);
              });
          }
      }
      /**
       * 添加工作
       *
       * 如果传入调度器id则将工作添加到该id对应的调度器,调度器并行执行,工作串行执行
       */
      add(job, schedulerId) {
          if (defined(schedulerId)) {
              this._schedulerStore.has(schedulerId) ||
                  this._schedulerStore.set(schedulerId, new JobScheduler());
              this._schedulerStore.get(schedulerId).add(job);
          }
          else {
              this._jobQueue.push(job);
              this._jobQueue.length === 1 && this._run();
          }
          return this;
      }
      /**
       * 移除工作
       */
      remove(jobId, schedulerId) {
          var _a, _b;
          if (defined(schedulerId)) {
              return ((_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.remove(jobId)) || false;
          }
          else if (jobId !== ((_b = this._activeJob) === null || _b === void 0 ? void 0 : _b.id)) {
              this._jobQueue = this._jobQueue.filter((i) => i.id !== jobId);
              return true;
          }
          console.warn("执行中的工作不可删除");
          return false;
      }
      /**
       * 传入调度器id则只暂停对应的调度器
       */
      pause(key, schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              return (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.pause(key);
          }
          this._schedulerStore.forEach((jobScheduler) => {
              jobScheduler.pause(key);
          });
          key || (key = performance.now() + "");
          this._pauseKeyStore.add(key);
          this._paused = true;
          return key;
      }
      /**
       * 传入调度器id则只恢复对应的调度器
       */
      resume(key, schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              return (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.resume(key);
          }
          this._schedulerStore.forEach((jobScheduler) => {
              jobScheduler.resume(key);
          });
          if (key) {
              this._pauseKeyStore.delete(key);
              if (this._pauseKeyStore.size > 0) {
                  return false;
              }
          }
          else {
              this._pauseKeyStore.clear();
          }
          this._paused = false;
          this._run();
          return true;
      }
      /**
       * 传入调度器id则只清空对应的调度器
       */
      clear(schedulerId) {
          var _a;
          if (defined(schedulerId)) {
              (_a = this._schedulerStore.get(schedulerId)) === null || _a === void 0 ? void 0 : _a.clear();
          }
          else {
              this._jobQueue = [];
              this._pauseKeyStore.clear();
              this._schedulerStore.forEach((scheduler) => {
                  scheduler.clear();
              });
              this._schedulerStore.clear();
          }
          return this;
      }
  }

  /**
   * @module ol/ImageState
   */
  /**
   * @enum {number}
   */
  var ImageState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4,
  };

  var hiddenStyle = new OlStyle__default["default"]({
      image: new CircleStyle__default["default"]()
  });
  var FEATURE_INDEX = Symbol("FeatureIndex");
  var DEFAULT_STYLES = Symbol("DefaultStyles");
  function getFeatureDefaultStyle(feature) {
      var _a;
      var layer = feature.layer;
      var layerStyle = false;
      var featureStyle = (feature.sourceFeature.getStyle() ||
          ((layerStyle = true),
              (_a = layer.layer[0].getStyleFunction()) === null || _a === void 0 ? void 0 : _a(feature.sourceFeature, layer.map.map.getView().getResolution())));
      Array.isArray(featureStyle) || (featureStyle = [featureStyle]);
      featureStyle.forEach(function (item) {
          var icon = item.getImage();
          if (icon instanceof OlIcon__default["default"] && icon.getImageState() === ImageState.IDLE) {
              icon.load();
          }
      });
      feature.sourceFeature.setStyle(hiddenStyle);
      return {
          layerStyle: layerStyle,
          olStyle: featureStyle
      };
  }
  function styleChangeHandle(e) {
      e.target.sourceFeature[DEFAULT_STYLES][e.target.sourceFeature[FEATURE_INDEX]] = getFeatureDefaultStyle(e.target);
  }
  var BeforeFallDownTask = /** @class */ (function () {
      function BeforeFallDownTask(options) {
          this._options = options;
      }
      BeforeFallDownTask.prototype.run = function () {
          return __awaiter$8(this, void 0, void 0, function () {
              var layer, defaultStyles;
              return __generator$1(this, function (_a) {
                  layer = this.task._options.layer;
                  defaultStyles = this.task._options.features.map(function (feature) {
                      feature.on(BaseEventType.STYLE_CHANGED, styleChangeHandle);
                      return getFeatureDefaultStyle(feature);
                  });
                  this.task._options.features.forEach(function (feature, index) {
                      feature.sourceFeature[DEFAULT_STYLES] = defaultStyles;
                      feature.sourceFeature[FEATURE_INDEX] = index;
                  });
                  return [2 /*return*/, {
                          data: {
                              features: this.task._options.features,
                              defaultStyles: defaultStyles,
                              layer: layer
                          }
                      }];
              });
          });
      };
      return BeforeFallDownTask;
  }());
  var FallDownTask = /** @class */ (function () {
      function FallDownTask() {
      }
      FallDownTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve) {
                          var features = previousTaskResult.data.features;
                          var previousTime = performance.now();
                          var rate = 0;
                          var _a = (previousTaskResult.data.layer.options.animation === true ? {} : previousTaskResult.data.layer.options.animation), _b = _a.duration, duration = _b === void 0 ? 2 : _b, _c = _a.bouncePixel, bouncePixel = _c === void 0 ? 0 : _c, easingFunction = _a.easingFunction;
                          var eventKey = previousTaskResult.data.layer.layer[0].on(BaseEventType.POST_RENDER, function (e) {
                              var context = e.context, frameState = e.frameState, inversePixelTransform = e.inversePixelTransform;
                              var renderer = new CanvasImmediateRenderer__default["default"](context, frameState.pixelRatio, frameState.extent, transform$5.multiply(inversePixelTransform.slice(), frameState.coordinateToPixelTransform), frameState.viewState.rotation);
                              if (defined$1(previousTime)) {
                                  rate += (performance.now() - previousTime) / 1000 / duration;
                                  rate > 1 && (rate = 1);
                                  var resolution_1 = frameState.viewState.resolution;
                                  var rotation_1 = frameState.viewState.rotation;
                                  var newRate_1 = easingFunction ? easingFunction(rate) : Math.pow(rate, 3);
                                  features.forEach(function (feature, index) {
                                      fallAnimating.call(feature, previousTaskResult.data.defaultStyles[index].olStyle, bouncePixel, newRate_1, context, renderer, resolution_1, rotation_1);
                                  });
                              }
                              previousTime = performance.now();
                              if (rate >= 1) {
                                  previousTaskResult.data.layer.unByKey(eventKey);
                                  resolve(previousTaskResult);
                              }
                              else {
                                  previousTaskResult.data.layer.layer[0].changed();
                              }
                          });
                          previousTaskResult.data.layer.layer[0].changed();
                      })];
              });
          });
      };
      return FallDownTask;
  }());
  var AfterFallDownTask = /** @class */ (function () {
      function AfterFallDownTask() {
      }
      AfterFallDownTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  previousTaskResult.data.features.forEach(function (feature, index) {
                      delete feature.sourceFeature[DEFAULT_STYLES];
                      delete feature.sourceFeature[FEATURE_INDEX];
                      feature.un(BaseEventType.STYLE_CHANGED, styleChangeHandle);
                      feature.sourceFeature.setStyle(previousTaskResult.data.defaultStyles[index].layerStyle
                          ? null
                          : previousTaskResult.data.defaultStyles[index].olStyle);
                  });
                  return [2 /*return*/];
              });
          });
      };
      return AfterFallDownTask;
  }());
  function fallAnimating(style, bouncePixel, rate, context, renderer, resolution, rotation) {
      var e_1, _a;
      if (bouncePixel === void 0) { bouncePixel = 0; }
      context.save();
      context.globalAlpha = rate;
      var geometry = this.sourceFeature.getGeometry().clone();
      var translateLength = bouncePixel * (1 - rate) * resolution;
      geometry.translate(-translateLength * Math.sin(rotation), translateLength * Math.cos(rotation));
      try {
          for (var style_1 = __values(style), style_1_1 = style_1.next(); !style_1_1.done; style_1_1 = style_1.next()) {
              var iterator = style_1_1.value;
              renderer.setStyle(iterator);
              renderer.drawGeometry(geometry);
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (style_1_1 && !style_1_1.done && (_a = style_1.return)) _a.call(style_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
      context.restore();
  }

  function featureAnimate(_a) {
      var layer = _a.layer, features = _a.features;
      var point = [];
      features.forEach(function (item) {
          if (item instanceof Point$1) {
              point.push(item);
          }
      });
      layer.map.jobScheduler.add(new BaseJob({
          tasks: [new BeforeFallDownTask({ layer: layer, features: point }), new FallDownTask(), new AfterFallDownTask()]
      }));
  }

  function sortKD(ids, coords, nodeSize, left, right, depth) {
      if (right - left <= nodeSize) return;

      const m = (left + right) >> 1;

      select(ids, coords, m, left, right, depth % 2);

      sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
      sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
  }

  function select(ids, coords, k, left, right, inc) {

      while (right > left) {
          if (right - left > 600) {
              const n = right - left + 1;
              const m = k - left + 1;
              const z = Math.log(n);
              const s = 0.5 * Math.exp(2 * z / 3);
              const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              select(ids, coords, k, newLeft, newRight, inc);
          }

          const t = coords[2 * k + inc];
          let i = left;
          let j = right;

          swapItem(ids, coords, left, k);
          if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

          while (i < j) {
              swapItem(ids, coords, i, j);
              i++;
              j--;
              while (coords[2 * i + inc] < t) i++;
              while (coords[2 * j + inc] > t) j--;
          }

          if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
          else {
              j++;
              swapItem(ids, coords, j, right);
          }

          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
      }
  }

  function swapItem(ids, coords, i, j) {
      swap(ids, i, j);
      swap(coords, 2 * i, 2 * j);
      swap(coords, 2 * i + 1, 2 * j + 1);
  }

  function swap(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
      const stack = [0, ids.length - 1, 0];
      const result = [];
      let x, y;

      while (stack.length) {
          const axis = stack.pop();
          const right = stack.pop();
          const left = stack.pop();

          if (right - left <= nodeSize) {
              for (let i = left; i <= right; i++) {
                  x = coords[2 * i];
                  y = coords[2 * i + 1];
                  if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
              }
              continue;
          }

          const m = Math.floor((left + right) / 2);

          x = coords[2 * m];
          y = coords[2 * m + 1];

          if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

          const nextAxis = (axis + 1) % 2;

          if (axis === 0 ? minX <= x : minY <= y) {
              stack.push(left);
              stack.push(m - 1);
              stack.push(nextAxis);
          }
          if (axis === 0 ? maxX >= x : maxY >= y) {
              stack.push(m + 1);
              stack.push(right);
              stack.push(nextAxis);
          }
      }

      return result;
  }

  function within(ids, coords, qx, qy, r, nodeSize) {
      const stack = [0, ids.length - 1, 0];
      const result = [];
      const r2 = r * r;

      while (stack.length) {
          const axis = stack.pop();
          const right = stack.pop();
          const left = stack.pop();

          if (right - left <= nodeSize) {
              for (let i = left; i <= right; i++) {
                  if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
              }
              continue;
          }

          const m = Math.floor((left + right) / 2);

          const x = coords[2 * m];
          const y = coords[2 * m + 1];

          if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

          const nextAxis = (axis + 1) % 2;

          if (axis === 0 ? qx - r <= x : qy - r <= y) {
              stack.push(left);
              stack.push(m - 1);
              stack.push(nextAxis);
          }
          if (axis === 0 ? qx + r >= x : qy + r >= y) {
              stack.push(m + 1);
              stack.push(right);
              stack.push(nextAxis);
          }
      }

      return result;
  }

  function sqDist(ax, ay, bx, by) {
      const dx = ax - bx;
      const dy = ay - by;
      return dx * dx + dy * dy;
  }

  const defaultGetX = p => p[0];
  const defaultGetY = p => p[1];

  class KDBush {
      constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {
          this.nodeSize = nodeSize;
          this.points = points;

          const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;

          const ids = this.ids = new IndexArrayType(points.length);
          const coords = this.coords = new ArrayType(points.length * 2);

          for (let i = 0; i < points.length; i++) {
              ids[i] = i;
              coords[2 * i] = getX(points[i]);
              coords[2 * i + 1] = getY(points[i]);
          }

          sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
      }

      range(minX, minY, maxX, maxY) {
          return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
      }

      within(x, y, r) {
          return within(this.ids, this.coords, x, y, r, this.nodeSize);
      }
  }

  const defaultOptions = {
      minZoom: 0,   // min zoom to generate clusters on
      maxZoom: 16,  // max zoom level to cluster the points on
      minPoints: 2, // minimum points to form a cluster
      radius: 40,   // cluster radius in pixels
      extent: 512,  // tile extent (radius is calculated relative to it)
      nodeSize: 64, // size of the KD-tree leaf node, affects performance
      log: false,   // whether to log timing info

      // whether to generate numeric ids for input features (in vector tiles)
      generateId: false,

      // a reduce function for calculating custom cluster properties
      reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }

      // properties to use for individual points when running the reducer
      map: props => props // props => ({sum: props.my_value})
  };

  const fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));

  class Supercluster {
      constructor(options) {
          this.options = extend(Object.create(defaultOptions), options);
          this.trees = new Array(this.options.maxZoom + 1);
      }

      load(points) {
          const {log, minZoom, maxZoom, nodeSize} = this.options;

          if (log) console.time('total time');

          const timerId = `prepare ${  points.length  } points`;
          if (log) console.time(timerId);

          this.points = points;

          // generate a cluster object for each point and index input points into a KD-tree
          let clusters = [];
          for (let i = 0; i < points.length; i++) {
              if (!points[i].geometry) continue;
              clusters.push(createPointCluster(points[i], i));
          }
          this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

          if (log) console.timeEnd(timerId);

          // cluster points on max zoom, then cluster the results on previous zoom, etc.;
          // results in a cluster hierarchy across zoom levels
          for (let z = maxZoom; z >= minZoom; z--) {
              const now = +Date.now();

              // create a new set of clusters for the zoom and index them with a KD-tree
              clusters = this._cluster(clusters, z);
              this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);

              if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
          }

          if (log) console.timeEnd('total time');

          return this;
      }

      getClusters(bbox, zoom) {
          let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
          const minLat = Math.max(-90, Math.min(90, bbox[1]));
          let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
          const maxLat = Math.max(-90, Math.min(90, bbox[3]));

          if (bbox[2] - bbox[0] >= 360) {
              minLng = -180;
              maxLng = 180;
          } else if (minLng > maxLng) {
              const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
              const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
              return easternHem.concat(westernHem);
          }

          const tree = this.trees[this._limitZoom(zoom)];
          const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
          const clusters = [];
          for (const id of ids) {
              const c = tree.points[id];
              clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
          }
          return clusters;
      }

      getChildren(clusterId) {
          const originId = this._getOriginId(clusterId);
          const originZoom = this._getOriginZoom(clusterId);
          const errorMsg = 'No cluster with the specified id.';

          const index = this.trees[originZoom];
          if (!index) throw new Error(errorMsg);

          const origin = index.points[originId];
          if (!origin) throw new Error(errorMsg);

          const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
          const ids = index.within(origin.x, origin.y, r);
          const children = [];
          for (const id of ids) {
              const c = index.points[id];
              if (c.parentId === clusterId) {
                  children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
              }
          }

          if (children.length === 0) throw new Error(errorMsg);

          return children;
      }

      getLeaves(clusterId, limit, offset) {
          limit = limit || 10;
          offset = offset || 0;

          const leaves = [];
          this._appendLeaves(leaves, clusterId, limit, offset, 0);

          return leaves;
      }

      getTile(z, x, y) {
          const tree = this.trees[this._limitZoom(z)];
          const z2 = Math.pow(2, z);
          const {extent, radius} = this.options;
          const p = radius / extent;
          const top = (y - p) / z2;
          const bottom = (y + 1 + p) / z2;

          const tile = {
              features: []
          };

          this._addTileFeatures(
              tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
              tree.points, x, y, z2, tile);

          if (x === 0) {
              this._addTileFeatures(
                  tree.range(1 - p / z2, top, 1, bottom),
                  tree.points, z2, y, z2, tile);
          }
          if (x === z2 - 1) {
              this._addTileFeatures(
                  tree.range(0, top, p / z2, bottom),
                  tree.points, -1, y, z2, tile);
          }

          return tile.features.length ? tile : null;
      }

      getClusterExpansionZoom(clusterId) {
          let expansionZoom = this._getOriginZoom(clusterId) - 1;
          while (expansionZoom <= this.options.maxZoom) {
              const children = this.getChildren(clusterId);
              expansionZoom++;
              if (children.length !== 1) break;
              clusterId = children[0].properties.cluster_id;
          }
          return expansionZoom;
      }

      _appendLeaves(result, clusterId, limit, offset, skipped) {
          const children = this.getChildren(clusterId);

          for (const child of children) {
              const props = child.properties;

              if (props && props.cluster) {
                  if (skipped + props.point_count <= offset) {
                      // skip the whole cluster
                      skipped += props.point_count;
                  } else {
                      // enter the cluster
                      skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
                      // exit the cluster
                  }
              } else if (skipped < offset) {
                  // skip a single point
                  skipped++;
              } else {
                  // add a single point
                  result.push(child);
              }
              if (result.length === limit) break;
          }

          return skipped;
      }

      _addTileFeatures(ids, points, x, y, z2, tile) {
          for (const i of ids) {
              const c = points[i];
              const isCluster = c.numPoints;

              let tags, px, py;
              if (isCluster) {
                  tags = getClusterProperties(c);
                  px = c.x;
                  py = c.y;
              } else {
                  const p = this.points[c.index];
                  tags = p.properties;
                  px = lngX(p.geometry.coordinates[0]);
                  py = latY(p.geometry.coordinates[1]);
              }

              const f = {
                  type: 1,
                  geometry: [[
                      Math.round(this.options.extent * (px * z2 - x)),
                      Math.round(this.options.extent * (py * z2 - y))
                  ]],
                  tags
              };

              // assign id
              let id;
              if (isCluster) {
                  id = c.id;
              } else if (this.options.generateId) {
                  // optionally generate id
                  id = c.index;
              } else if (this.points[c.index].id) {
                  // keep id if already assigned
                  id = this.points[c.index].id;
              }

              if (id !== undefined) f.id = id;

              tile.features.push(f);
          }
      }

      _limitZoom(z) {
          return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));
      }

      _cluster(points, zoom) {
          const clusters = [];
          const {radius, extent, reduce, minPoints} = this.options;
          const r = radius / (extent * Math.pow(2, zoom));

          // loop through each point
          for (let i = 0; i < points.length; i++) {
              const p = points[i];
              // if we've already visited the point at this zoom level, skip it
              if (p.zoom <= zoom) continue;
              p.zoom = zoom;

              // find all nearby points
              const tree = this.trees[zoom + 1];
              const neighborIds = tree.within(p.x, p.y, r);

              const numPointsOrigin = p.numPoints || 1;
              let numPoints = numPointsOrigin;

              // count the number of points in a potential cluster
              for (const neighborId of neighborIds) {
                  const b = tree.points[neighborId];
                  // filter out neighbors that are already processed
                  if (b.zoom > zoom) numPoints += b.numPoints || 1;
              }

              // if there were neighbors to merge, and there are enough points to form a cluster
              if (numPoints > numPointsOrigin && numPoints >= minPoints) {
                  let wx = p.x * numPointsOrigin;
                  let wy = p.y * numPointsOrigin;

                  let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;

                  // encode both zoom and point index on which the cluster originated -- offset by total length of features
                  const id = (i << 5) + (zoom + 1) + this.points.length;

                  for (const neighborId of neighborIds) {
                      const b = tree.points[neighborId];

                      if (b.zoom <= zoom) continue;
                      b.zoom = zoom; // save the zoom (so it doesn't get processed twice)

                      const numPoints2 = b.numPoints || 1;
                      wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center
                      wy += b.y * numPoints2;

                      b.parentId = id;

                      if (reduce) {
                          if (!clusterProperties) clusterProperties = this._map(p, true);
                          reduce(clusterProperties, this._map(b));
                      }
                  }

                  p.parentId = id;
                  clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));

              } else { // left points as unclustered
                  clusters.push(p);

                  if (numPoints > 1) {
                      for (const neighborId of neighborIds) {
                          const b = tree.points[neighborId];
                          if (b.zoom <= zoom) continue;
                          b.zoom = zoom;
                          clusters.push(b);
                      }
                  }
              }
          }

          return clusters;
      }

      // get index of the point from which the cluster originated
      _getOriginId(clusterId) {
          return (clusterId - this.points.length) >> 5;
      }

      // get zoom of the point from which the cluster originated
      _getOriginZoom(clusterId) {
          return (clusterId - this.points.length) % 32;
      }

      _map(point, clone) {
          if (point.numPoints) {
              return clone ? extend({}, point.properties) : point.properties;
          }
          const original = this.points[point.index].properties;
          const result = this.options.map(original);
          return clone && result === original ? extend({}, result) : result;
      }
  }

  function createCluster(x, y, id, numPoints, properties) {
      return {
          x: fround(x), // weighted cluster center; round for consistency with Float32Array index
          y: fround(y),
          zoom: Infinity, // the last zoom the cluster was processed at
          id, // encodes index of the first child of the cluster and its zoom level
          parentId: -1, // parent cluster id
          numPoints,
          properties
      };
  }

  function createPointCluster(p, id) {
      const [x, y] = p.geometry.coordinates;
      return {
          x: fround(lngX(x)), // projected point coordinates
          y: fround(latY(y)),
          zoom: Infinity, // the last zoom the point was processed at
          index: id, // index of the source feature in the original input array,
          parentId: -1 // parent cluster id
      };
  }

  function getClusterJSON(cluster) {
      return {
          type: 'Feature',
          id: cluster.id,
          properties: getClusterProperties(cluster),
          geometry: {
              type: 'Point',
              coordinates: [xLng(cluster.x), yLat(cluster.y)]
          }
      };
  }

  function getClusterProperties(cluster) {
      const count = cluster.numPoints;
      const abbrev =
          count >= 10000 ? `${Math.round(count / 1000)  }k` :
          count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;
      return extend(extend({}, cluster.properties), {
          cluster: true,
          cluster_id: cluster.id,
          point_count: count,
          point_count_abbreviated: abbrev
      });
  }

  // longitude/latitude to spherical mercator in [0..1] range
  function lngX(lng) {
      return lng / 360 + 0.5;
  }
  function latY(lat) {
      const sin = Math.sin(lat * Math.PI / 180);
      const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
      return y < 0 ? 0 : y > 1 ? 1 : y;
  }

  // spherical mercator to longitude/latitude
  function xLng(x) {
      return (x - 0.5) * 360;
  }
  function yLat(y) {
      const y2 = (180 - y * 360) * Math.PI / 180;
      return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
  }

  function extend(dest, src) {
      for (const id in src) dest[id] = src[id];
      return dest;
  }

  function getX(p) {
      return p.x;
  }
  function getY(p) {
      return p.y;
  }

  var _a$1;
  Object.defineProperty(OlFeature__default["default"].prototype, "properties", {
      get: function () {
          return (this.values_ && Object.assign({}, this.values_)) || {};
      }
  });
  var VectorLayer = /** @class */ (function (_super) {
      __extends$6(VectorLayer, _super);
      function VectorLayer(options, map) {
          var _this = _super.call(this, __assign$1({ opacity: 1, visible: true, cluster: false, distance: 200, animation: false, expand: true }, options)) || this;
          /**
           * 数据加载中
           * @ignore
           */
          _this[_a$1] = false;
          _this._features = new BaseCollection();
          if (_this.cluster) {
              _this._style = _this.options.style || DEFAULT_ClUSTER_STYLE_ITEM;
          }
          else {
              _this._style = _this.options.style || VECTOR_LAYER_STYLE.default;
          }
          if (defined$1(map)) {
              map.addLayer(_this);
          }
          return _this;
      }
      Object.defineProperty(VectorLayer.prototype, "extent", {
          get: function () {
              return Turf__namespace.bbox(this.geoJson);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "geoJson", {
          get: function () {
              return featureCollection(this.features.map(function (f) { return f.geoJson; }));
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "wkts", {
          get: function () {
              return this.features.map(function (f) { return f.wkt; });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "style", {
          /**
           * 地图设置的样式
           */
          get: function () {
              return (this._style || (this.cluster ? DEFAULT_ClUSTER_STYLE_ITEM : VECTOR_LAYER_STYLE.default));
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "styleFunction", {
          /**
           * 当前地图使用的样式函数
           */
          get: function () {
              return toStyleFunction(this.style);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "features", {
          /**
           * 图层要素集合
           */
          get: function () {
              return this._features.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "layer", {
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(VectorLayer.prototype, "cluster", {
          get: function () {
              return this.options.cluster;
          },
          enumerable: false,
          configurable: true
      });
      VectorLayer.prototype.init = function () {
          var _this = this;
          this._initialized = true;
          var _options = __assign$1({}, this.options);
          delete _options.style;
          delete _options.id;
          var layer = this.cluster
              ? new AnimationClusterLayer(__assign$1({ source: new VectorSource__default["default"](_options) }, _options))
              : new VectorLayer__default["default"](__assign$1(__assign$1({ source: new VectorSource__default["default"](_options) }, _options), { visible: false }));
          layer[LAYER_LINK] = this;
          this._layer = [layer];
          if (this.cluster) {
              this._superCluster = new Supercluster({
                  radius: this.options.distance,
                  maxZoom: this.options.expandZoom || 19
              });
              this._eventKey = this.map.on(BaseEventType.MOVE_END, this._getCLusterFeature.bind(this));
              this.map.once(BaseEventType.POST_RENDER, this._getCLusterFeature.bind(this));
              if (!Array.isArray(this.options.data) && typeof this.options.data === "object") {
                  this._data = this.options.data;
              }
              else {
                  this._data = write$1(dataToFeatures(this.options.data));
              }
              if (!defined$1(this._data)) {
                  this._data = { type: "FeatureCollection", features: [] };
              }
              this._superCluster.load(this._data.features);
          }
          if (this.cluster === false) {
              this.addFeatures(dataToFeatures(this.options.data));
          }
          if (this.options.animation) {
              this.on([BaseEventType.SHOW, BaseEventType.ADD_FEATURE, BaseEventType.ADD_FEATURES], function (e) {
                  if (!_this.cluster && !_this[LOADING_DATA]) {
                      var features = void 0;
                      switch (e.type) {
                          case BaseEventType.SHOW:
                              features = _this.features;
                              break;
                          case BaseEventType.ADD_FEATURE:
                              features = [e.feature];
                              break;
                          case BaseEventType.ADD_FEATURES:
                              features = e.features;
                              break;
                      }
                      features.length > 0 && featureAnimate({ layer: _this, features: features });
                  }
              });
          }
          if (this.cluster) {
              this._layer[0].set("expandedStyle", styleToOlStyleFunction(this.style));
          }
          this.setStyle(this.style);
      };
      VectorLayer.prototype._getCLusterFeature = function () {
          var _this = this;
          if (this.map === undefined) {
              return;
          }
          var extent = this.map.currentExtent;
          var zoom = this.map.zoom;
          var features = read$1({
              type: "FeatureCollection",
              features: this._superCluster.getClusters(extent, Math.floor(zoom))
          });
          features.forEach(function (f) {
              var cluster = f.get("cluster");
              if (cluster) {
                  var clusterId = f.get("cluster_id");
                  var childs = _this._superCluster.getLeaves(clusterId, Infinity);
                  f.set("features", childs);
              }
          });
          this.layer[0].getSource().dispatchEvent({
              type: "sendFeatures",
              features: this.layer[0].getSource().getFeatures()
          });
          this.removeFeatures(this.getFeatures());
          this.layer[0].getSource().clear();
          this._addFeatures(features);
      };
      VectorLayer.prototype.addTo = function (map) {
          var _this = this;
          var _b, _c;
          var loaded = !this.initialized && this.features.length > 0;
          _super.prototype.addTo.call(this, map);
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (loaded && !this.cluster) {
              this.features.forEach(function (f) {
                  _this.layer.forEach(function (l) {
                      l.getSource().addFeature(f.sourceFeature);
                  });
              });
          }
          if (!this.cluster && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.visible) === true) {
              this._visible = false;
              this.show();
          }
          else if (!this.cluster && ((_c = this._options) === null || _c === void 0 ? void 0 : _c.visible) === false) {
              this._visible = true;
              this.hide();
          }
      };
      VectorLayer.prototype.addData = function (data, options) {
          var _b;
          if (this.cluster) {
              var _data = void 0;
              if (!Array.isArray(data) && typeof data === "object") {
                  _data = data;
              }
              else {
                  _data = write$1(dataToFeatures(data));
              }
              (_b = this._data.features).push.apply(_b, __spreadArray$1([], __read(_data.features), false));
              this._superCluster.load(this._data.features);
              this._getCLusterFeature();
          }
          else {
              this.addFeatures(dataToFeatures(data, options));
          }
          return this;
      };
      VectorLayer.prototype.addFeature = function (feature) {
          if (this.cluster) {
              console.warn(ErrorNotification.NOT_COMMEND);
              return;
          }
          this._features.add(feature);
          feature.addToLayer(this);
          this.dispatchEvent({
              type: BaseEventType.ADD_FEATURE,
              target: this,
              feature: feature
          });
          return this;
      };
      /**
       * 添加多个要素到矢量图层
       * @param features
       */
      VectorLayer.prototype.addFeatures = function (features) {
          var e_1, _b;
          if (this.cluster) {
              console.warn(ErrorNotification.NOT_COMMEND);
              return;
          }
          this[LOADING_DATA] = true;
          try {
              for (var features_1 = __values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                  var feature = features_1_1.value;
                  this.addFeature(feature);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (features_1_1 && !features_1_1.done && (_b = features_1.return)) _b.call(features_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          this[LOADING_DATA] = false;
          this.dispatchEvent({
              type: BaseEventType.ADD_FEATURES,
              target: this,
              features: features
          });
          return this;
      };
      VectorLayer.prototype._addFeatures = function (features) {
          var e_2, _b;
          try {
              for (var features_2 = __values(features), features_2_1 = features_2.next(); !features_2_1.done; features_2_1 = features_2.next()) {
                  var feature = features_2_1.value;
                  this._addFeature(feature);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (features_2_1 && !features_2_1.done && (_b = features_2.return)) _b.call(features_2);
              }
              finally { if (e_2) throw e_2.error; }
          }
      };
      VectorLayer.prototype._addFeature = function (feature) {
          this._features.add(feature);
          feature.addToLayer(this);
      };
      /**
       * 根据要素id获取要素
       */
      VectorLayer.prototype.getFeature = function (id) {
          return this._features.getItem(id);
      };
      /**
       * 获取矢量图层当前要素数组
       */
      VectorLayer.prototype.getFeatures = function () {
          return this._features.getArray();
      };
      /**
       * 移除要素
       */
      VectorLayer.prototype.removeFeature = function (feature) {
          if (this._features.include(feature.id)) {
              if (!this.cluster) {
                  feature.remove();
              }
              // 要素移除事件 在要素内部触发
              this._features.remove(feature);
          }
          return this;
      };
      /**
       * 移除多个要素
       * @param features
       */
      VectorLayer.prototype.removeFeatures = function (features) {
          var e_3, _b;
          if (features && features.length > 0) {
              try {
                  for (var features_3 = __values(features), features_3_1 = features_3.next(); !features_3_1.done; features_3_1 = features_3.next()) {
                      var feature = features_3_1.value;
                      this.removeFeature(feature);
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (features_3_1 && !features_3_1.done && (_b = features_3.return)) _b.call(features_3);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
          }
          return this;
      };
      /**
       * 清空要素
       */
      VectorLayer.prototype.clearFeatures = function () {
          this.removeFeatures(this.getFeatures());
          if (this.cluster) {
              this._superCluster.load([]);
          }
          return this;
      };
      VectorLayer.prototype.setStyle = function (style) {
          if (!defined$1(style) || (Array.isArray(style) && style.length <= 0)) {
              this._style = (this.cluster ? DEFAULT_ClUSTER_STYLE_ITEM : VECTOR_LAYER_STYLE.default);
          }
          else {
              this._style = style;
          }
          style = this._style;
          var olStyle = styleToOlStyleFunction(style);
          this.layer.forEach(function (layer) {
              layer.setStyle(olStyle);
          });
          return this;
      };
      /**
       * 显示图层
       */
      VectorLayer.prototype.show = function () {
          return _super.prototype.show.call(this);
      };
      /**
       * 隐藏图层
       */
      VectorLayer.prototype.hide = function () {
          return _super.prototype.hide.call(this);
      };
      /**
       * @override
       * @ignore
       */
      VectorLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map.unByKey(this._eventKey);
          this._eventKey = undefined;
          this.map = undefined;
      };
      /**
       * @ignore
       */
      VectorLayer.prototype._destroy = function () {
          this.remove();
          this._layer = void 0;
          this._features.destroyed || this._features.destroy();
          this._style = void 0;
          _super.prototype._destroy.call(this);
      };
      return VectorLayer;
  }(Layer));
  _a$1 = LOADING_DATA;

  var WebTileLayer = /** @class */ (function (_super) {
      __extends$6(WebTileLayer, _super);
      function WebTileLayer(options, map) {
          if (!defined$1(options.url)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ visible: true, type: "xyz" }, options), map) || this;
      }
      Object.defineProperty(WebTileLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WebTileLayer.prototype.init = function () {
          this._initialized = true;
          this.layer = _getWebTile(this.options);
      };
      WebTileLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WebTileLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
          this._initialized = false;
      };
      /**
       * @ignore
       */
      WebTileLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
      };
      return WebTileLayer;
  }(Layer));
  /**
   *
   * @param options
   * @returns
   */
  function _getWebTile(options) {
      if (options.type === "aef") {
          var url_1 = options.url;
          options.tileUrlFunction = function (tileCoord) {
              return url_1
                  .replace("{x}", "C" + zeroPad(tileCoord[1], 8, 16))
                  .replace("{y}", "R" + zeroPad(tileCoord[2], 8, 16))
                  .replace("{z}", "L" + zeroPad(tileCoord[0], 2, 10));
          };
          delete options.url;
      }
      else if (options.type === "bd09") {
          var URL_1 = options.url;
          options = Object.assign({
              source: new TileImage__default["default"]({
                  projection: "BD-09",
                  tilePixelRatio: 2,
                  crossOrigin: "anonymous",
                  tileGrid: new TileGrid__default["default"]({
                      origin: [0, 0],
                      resolutions: new Array(20).fill(1).map(function (val, i) { return Math.pow(2, 18 - i); })
                  }),
                  tileUrlFunction: function (tileCoord) {
                      if (!tileCoord) {
                          return "";
                      }
                      var z = tileCoord[0];
                      var x = tileCoord[1] ? tileCoord[1] : "M" + -tileCoord[1];
                      var y = -tileCoord[2] - 1 ? -tileCoord[2] - 1 : "M" + -(-tileCoord[2] - 1);
                      return URL_1.replace("{z}", z + "")
                          .replace("{x}", x + "")
                          .replace("{y}", y + "");
                  }
              })
          }, options);
          delete options.url;
      }
      var _options = __assign$1({}, options);
      if (options.tileGrid) {
          _options.tileGrid = new TileGrid__default["default"](__assign$1({}, options.tileGrid));
      }
      var _config = Object.assign({
          source: new XYZ__default["default"](__assign$1(__assign$1({ crossOrigin: "anonymous" }, (options.crs ? { projection: proj.get(options.crs) } : {})), _options))
      }, options);
      var tileLayer = new Tile__default["default"](_config);
      return [tileLayer];
  }
  function zeroPad(num, len, radix) {
      var str = num.toString(radix || 10);
      while (str.length < len) {
          str = "0" + str;
      }
      return str;
  }

  var WMSLayer = /** @class */ (function (_super) {
      __extends$6(WMSLayer, _super);
      function WMSLayer(options, map) {
          if (!defined$1(options.url) || !defined$1(options.layers)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ visible: true, tile: true, opacity: 1, params: {
                  version: options.version,
                  layers: options.layers,
                  crs: options.crs,
                  bbox: options.bbox,
                  cql_filter: options.cql_filter,
                  transparent: options.transparent,
                  format: options.format || "image/png"
              } }, options), map) || this;
      }
      Object.defineProperty(WMSLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WMSLayer.prototype.init = function () {
          this._initialized = true;
          initSQLViewStr(this.options.params);
          if (this.options.tile) {
              if (this.options.resolutions) {
                  this.options.tileGrid = new TileGrid__default["default"](this.options);
              }
              this.layer = [
                  new Tile__default["default"](__assign$1({ source: new TileWMSPlus(this.options) }, this.options))
              ];
          }
          else {
              this.layer = [
                  new ImageLayer__default["default"](Object.assign(this.options, {
                      source: new ImageWMSPlus(this.options)
                  }))
              ];
          }
      };
      WMSLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WMSLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
          this._initialized = false;
      };
      /**
       * @ignore
       */
      WMSLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
      };
      /**
       * 更新wms请求
       * @param params
       */
      WMSLayer.prototype.setParams = function (params) {
          this.layer && this.layer[0].updateParams(params);
          return this;
      };
      return WMSLayer;
  }(Layer));
  function initSQLViewStr(options) {
      var e_1, _a;
      if (options && typeof options.viewParams === "object") {
          var viewParams = "";
          try {
              for (var _b = __values(Object.keys(options.viewParams)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var key = _c.value;
                  if (viewParams) {
                      viewParams += ";";
                  }
                  viewParams += key + ":" + options.viewParams[key];
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          options.viewParams = viewParams;
      }
  }
  var TileWMSPlus = /** @class */ (function (_super) {
      __extends$6(TileWMSPlus, _super);
      function TileWMSPlus(options) {
          return _super.call(this, options) || this;
      }
      TileWMSPlus.prototype.updateParams = function (params) {
          initSQLViewStr(params);
          _super.prototype.updateParams.call(this, params);
      };
      return TileWMSPlus;
  }(TileWMS__default["default"]));
  var ImageWMSPlus = /** @class */ (function (_super) {
      __extends$6(ImageWMSPlus, _super);
      function ImageWMSPlus(options) {
          return _super.call(this, options) || this;
      }
      ImageWMSPlus.prototype.updateParams = function (params) {
          initSQLViewStr(params);
          _super.prototype.updateParams.call(this, params);
      };
      return ImageWMSPlus;
  }(ImageWMS__default["default"]));

  //http://t0.tianditu.gov.cn/img_w/wmts?request=GetCapabilities&service=wmts
  var WMTSLayer = /** @class */ (function (_super) {
      __extends$6(WMTSLayer, _super);
      function WMTSLayer(options, map) {
          if (!defined$1(options.url) ||
              !defined$1(options.layer) ||
              !defined$1(options.layer) ||
              !defined$1(options.matrixSet) ||
              !defined$1(options.resolutions) ||
              !defined$1(options.matrixIds)) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          return _super.call(this, __assign$1({ visible: true }, options), map) || this;
      }
      Object.defineProperty(WMTSLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      WMTSLayer.prototype.init = function () {
          this._initialized = true;
          var _layerOptions = getLayerConstructionOptions(this.options);
          var _soureOptions = getSourceConstructionOptions(this.options);
          var tileGrid = buildWMTSTileGrid(_soureOptions);
          delete _soureOptions[SourceProperty.MATRIXIDS];
          delete _soureOptions[SourceProperty.RESOLUTIONS];
          _soureOptions.tileGrid = tileGrid;
          _soureOptions.style = _soureOptions.style || "default";
          delete _layerOptions.extent;
          this.layer = [
              new Tile__default["default"](__assign$1({ source: new WMTS__default["default"](__assign$1({}, _soureOptions)) }, _layerOptions))
          ];
      };
      WMTSLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      WMTSLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
          this._initialized = false;
      };
      /**
       * @ignore
       */
      WMTSLayer.prototype._destroy = function () {
          this.remove();
          this.layer = undefined;
          _super.prototype._destroy.call(this);
      };
      return WMTSLayer;
  }(Layer));
  function buildResAndMatr(options) {
      var projection = proj.get(options.projection || PUBLIC_CONFIG.projection);
      var extent = options.extent || projection.getExtent();
      return {
          extent: extent,
          resolutions: options.resolutions,
          matrixIds: options.matrixIds,
          origin: options.origin
      };
  }
  function buildWMTSTileGrid(options) {
      var tem = buildResAndMatr(options);
      return new WMTSTileGrid__default["default"](tem);
  }
  var LayerProperty = {
      ID: "id",
      OPACITY: "opacity",
      CLASS_NAME: "className",
      VISIBLE: "visible",
      Z_INDEX: "zIndex",
      EXTENT: "extent",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution"
  };
  var SourceProperty = {
      URL: "url",
      LAYER: "layer",
      VERSION: "version",
      PROJECTION: "projection",
      FORMAT: "format",
      STYLE: "style",
      EXTENT: "extent",
      RESOLUTIONS: "resolutions",
      MATRIXIDS: "matrixIds",
      MATRIXSET: "matrixSet",
      ORIGIN: "origin"
  };
  function getLayerConstructionOptions(options) {
      var baseOptions = Object.assign({}, options);
      for (var key in SourceProperty) {
          var value = baseOptions[SourceProperty[key]];
          if (defined$1(value)) {
              if (SourceProperty[key] === "extent")
                  continue;
              delete baseOptions[SourceProperty[key]];
          }
      }
      return baseOptions;
  }
  function getSourceConstructionOptions(options) {
      var baseOptions = Object.assign({}, options);
      for (var key in LayerProperty) {
          var value = baseOptions[LayerProperty[key]];
          if (defined$1(value)) {
              if (LayerProperty[key] === "extent")
                  continue;
              delete baseOptions[LayerProperty[key]];
          }
      }
      return baseOptions;
  }

  var TerrainLayer = /** @class */ (function (_super) {
      __extends$6(TerrainLayer, _super);
      function TerrainLayer(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      TerrainLayer.prototype.init = function () {
          this._initialized = true;
      };
      /**
       * @ignore
       */
      TerrainLayer.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      TerrainLayer.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return TerrainLayer;
  }(Layer));

  var ArcGISLayer = /** @class */ (function (_super) {
      __extends$6(ArcGISLayer, _super);
      function ArcGISLayer(options, map) {
          return _super.call(this, __assign$1({ visible: true }, options), map) || this;
      }
      Object.defineProperty(ArcGISLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      ArcGISLayer.prototype.init = function () {
          this._initialized = true;
          var _options = __assign$1({}, this.options);
          if (_options.tileGrid) {
              _options.tileGrid = new TileGrid__default["default"](__assign$1({}, _options.tileGrid));
          }
          this._layer = [
              Object.assign(new Tile__default["default"](__assign$1({ source: new TileArcGISRest__default["default"](__assign$1({}, _options)) }, _options)), { id: this.id })
          ];
      };
      ArcGISLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          var visible = this.options.visible;
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
          if (defined$1(this.visible) ? this.visible : visible) {
              this.show();
          }
          else {
              this.hide();
          }
      };
      ArcGISLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = undefined;
      };
      /**
       * @ignore
       */
      ArcGISLayer.prototype._destroy = function () {
          this.remove();
          this.layer.forEach(function (i) { return i.dispose(); });
          this.layer = undefined;
          _super.prototype._destroy.call(this);
          this._initialized = false;
      };
      return ArcGISLayer;
  }(Layer));

  var IDWSource = /** @class */ (function (_super) {
      __extends$6(IDWSource, _super);
      function IDWSource(options) {
          var _this = this;
          options.canvasFunction = calculateImage;
          _this = _super.call(this, options) || this;
          _this._source = options.source;
          _this._geojson = new Geojson__default["default"]();
          _this._canvas = document.createElement("CANVAS");
          _this._minScope = 0.1;
          _this._maxScope = 1;
          _this._minOpacity = 0;
          _this._maxOpacity = 1;
          _this._source.on(["addfeature", "removefeature", "clear", "removefeature"], function () {
              this.changed();
          }.bind(_this));
          _this.set("scale", options.scale || 1);
          _this._weight =
              typeof options.weight === "function"
                  ? options.weight
                  : function (f) {
                      return f.get(options.weight || "weight");
                  };
          return _this;
      }
      IDWSource.prototype.getSource = function () {
          return this._source;
      };
      IDWSource.prototype._layerParams = function (zoom) {
          // 获取最大最小半径、最大最小模糊度
          var gradient = this.get("gradient");
          var _maxZoom = this.get("maxZoom");
          var _minZoom = this.get("minZoom");
          // 根据比例尺计算
          var rate = (_minZoom - zoom) / (_minZoom - _maxZoom);
          var radius = this.get("minRadius") - rate * (this.get("minRadius") - this.get("maxRadius"));
          var blur = this.get("minBlur") - rate * (this.get("minBlur") - this.get("maxBlur"));
          return { radius: radius, blur: blur, gradient: gradient };
      };
      IDWSource.prototype.getColorPaint = function (colorStep) {
          var paletteCanvas = document.createElement("canvas");
          var paletteCtx = paletteCanvas.getContext("2d");
          paletteCanvas.width = 256;
          paletteCanvas.height = 1;
          var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
          Object.keys(colorStep)
              .map(function (n) { return parseFloat(n); })
              .sort()
              .forEach(function (key) {
              gradient.addColorStop(key, colorStep[key]);
          });
          paletteCtx.fillStyle = gradient;
          paletteCtx.fillRect(0, 0, paletteCanvas.width, paletteCanvas.height);
          return paletteCtx.getImageData(0, 0, 256, 1).data;
      };
      return IDWSource;
  }(ImageCanvas__default["default"]));
  function calculateImage(extent$1, resolution, pixelRatio, size, projection) {
      var _this = this;
      if (!this._source)
          return this._canvas;
      var canvas = document.createElement("CANVAS");
      var width = (canvas.width = Math.round(size[0] / (this.get("scale") * pixelRatio)));
      var height = (canvas.height = Math.round(size[1] / (this.get("scale") * pixelRatio)));
      var dw = width / (extent$1[2] - extent$1[0]);
      var dh = height / (extent$1[1] - extent$1[3]);
      var context = canvas.getContext("2d");
      var _transform = function (coords, v) {
          return [(coords[0] - extent$1[0]) * dw, (coords[1] - extent$1[3]) * dh, v];
      };
      var pts = [];
      var params = (this.get("layerParams") || this._layerParams).bind(this)(Math.floor(this.get("view").getZoom()));
      var _radius = params.radius;
      var _extent = extent.buffer(__spreadArray$1([], __read(extent$1), false), _radius * resolution);
      // 获取要素计算要素的像素坐标以及权重、、、
      this._source.getFeaturesInExtent(_extent).forEach(function (f) {
          pts.push(_transform(f.getGeometry().getFirstCoordinate(), this._weight(f)));
      }.bind(this));
      pts.forEach(function (point) {
          // 设置globalAlpha: 需注意取值需规范在0-1之间
          var globalAlpha = (point[2] - _this.get("min")) / (_this.get("max") - _this.get("min"));
          context.globalAlpha = Math.max(Math.min(globalAlpha, 1), 0);
          context.beginPath();
          var radialGradient = context.createRadialGradient(point[0], point[1], 0, point[0], point[1], _radius);
          radialGradient.addColorStop(0.0, "rgba(0,0,0,1)");
          radialGradient.addColorStop(1.0, "rgba(0,0,0,0)");
          context.fillStyle = radialGradient;
          context.arc(point[0], point[1], _radius, 0, 2 * Math.PI);
          // 创建渐变色: r,g,b取值比较自由，我们只关注alpha的数值
          context.closePath();
          // 填充颜色
          context.fill();
      });
      var palette = this.getColorPaint(params.gradient); //取色面板
      var img = context.getImageData(0, 0, width, height);
      var imgData = img.data;
      var max_opacity = this._maxOpacity * 255;
      var min_opacity = this._minOpacity * 255;
      //权重区间
      var max_scope = (this._maxScope > 1 ? 1 : this._maxScope) * 255;
      var min_scope = (this._minScope < 0 ? 0 : this._minScope) * 255;
      var len = imgData.length;
      for (var i = 3; i < len; i += 4) {
          var alpha = imgData[i];
          var offset = alpha * 4;
          if (!offset) {
              continue;
          }
          //映射颜色
          imgData[i - 3] = palette[offset];
          imgData[i - 2] = palette[offset + 1];
          imgData[i - 1] = palette[offset + 2];
          // 范围区间
          if (imgData[i] > max_scope) {
              imgData[i] = 0;
          }
          if (imgData[i] < min_scope) {
              imgData[i] = 0;
          }
          // 透明度
          if (imgData[i] > max_opacity) {
              imgData[i] = max_opacity;
          }
          if (imgData[i] < min_opacity) {
              imgData[i] = min_opacity;
          }
      }
      //将设置后的像素数据放回画布
      context.putImageData(img, 0, 0);
      this._canvas.width = Math.round(size[0]);
      this._canvas.height = Math.round(size[1]);
      this._canvas.getContext("2d").drawImage(canvas, 0, 0, size[0], size[1]);
      return this._canvas;
  }

  var HeatLayer = /** @class */ (function (_super) {
      __extends$6(HeatLayer, _super);
      function HeatLayer(options, map) {
          return _super.call(this, __assign$1({ max: 3, min: 19, maxBlur: 20, minBlur: 1.5, maxRadius: 40, minRadius: 3, gradient: { 0.4: "blue", 0.6: "cyan", 0.7: "lime", 0.8: "yellow", 1: "red" } }, options), map) || this;
      }
      Object.defineProperty(HeatLayer.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      HeatLayer.prototype.init = function () {
          this._initialized = true;
          var _a = this.options, data = _a.data, visible = _a.visible, opacity = _a.opacity;
          var source = new IDWSource({ source: new VectorSource__default["default"](), weight: "value" });
          var layer = new ImageLayer__default["default"](__assign$1(__assign$1({}, this.options), { opacity: opacity, visible: defined$1(this.visible) ? this.visible : visible, source: source }));
          source.set("view", this.map.map.getView());
          source.set("minZoom", this.options.max);
          source.set("maxZoom", this.options.min);
          source.set("gradient", this.options.gradient);
          source.set("minRadius", this.options.minRadius);
          source.set("maxRadius", this.options.maxRadius);
          source.set("layerParams", this.options.renderFunction);
          this._layer = [layer];
          this._temLayer = new VectorLayer({ visible: false }, this.map);
          if (this._features && this._features.length > 0) {
              this._addFeature();
          }
          else {
              this.addData(data);
          }
      };
      HeatLayer.prototype.addTo = function (map) {
          var _this = this;
          _super.prototype.addTo.call(this, map);
          this.layer.forEach(function (i) { return _this.map.map.addLayer(i); });
      };
      HeatLayer.prototype.remove = function (destroy) {
          var _this = this;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.layer.forEach(function (i) { return _this.map.map.removeLayer(i); });
          this.map = void 0;
      };
      HeatLayer.prototype._destroy = function () {
          this.remove();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      HeatLayer.prototype.addData = function (data, options) {
          this._features || (this._features = []);
          this._features = this._features.concat(dataToFeatures(data, options));
          this._addFeature();
          return this;
      };
      HeatLayer.prototype._addFeature = function () {
          // 该实例还未添加到地图
          if (!this.map) {
              return this;
          }
          var values_ = this._features.map(function (_feature) {
              return _feature.get("value");
          });
          var max = Math.max.apply(Math, __spreadArray$1([], __read(values_), false));
          var min = Math.min.apply(Math, __spreadArray$1([], __read(values_), false));
          this._temLayer.addFeatures(this._features);
          var source_ = this.layer[0].getSource();
          source_.set("max", max);
          source_.set("min", min);
          source_.getSource().addFeatures(this._temLayer.features.map(function (f) { return f.sourceFeature; }));
      };
      HeatLayer.prototype.setData = function (data, options) {
          var _a, _b;
          this._features = [];
          (_a = this._temLayer) === null || _a === void 0 ? void 0 : _a.clearFeatures();
          ((_b = this.layer) === null || _b === void 0 ? void 0 : _b[0].getSource()).getSource().clear();
          this.addData(data, options);
          return this;
      };
      return HeatLayer;
  }(Layer));

  /**
   * Code
   */

  var index$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Layer: Layer,
    AMapLayer: AMapLayer,
    BMapLayer: BMapLayer,
    get BDMapType () { return BDMapType; },
    StaticImageLayer: StaticImageLayer,
    TMapLayer: TMapLayer,
    VectorLayer: VectorLayer,
    WebTileLayer: WebTileLayer,
    WMSLayer: WMSLayer,
    WMTSLayer: WMTSLayer,
    TerrainLayer: TerrainLayer,
    ArcGISLayer: ArcGISLayer,
    HeatLayer: HeatLayer
  });

  /**
   * 绘制类别
   *
   * @enum {number}
   */
  var DrawType;
  (function (DrawType) {
      /**
       * 点
       */
      DrawType["POINT"] = "point";
      DrawType["CIRCLE"] = "circle";
      /**
       * 面
       */
      DrawType["POLYGON"] = "polygon";
      /**
       * 线
       */
      DrawType["POLYLINE"] = "polyline";
      DrawType["ARC"] = "arc";
      DrawType["ELLIPSE"] = "ellipse";
      DrawType["CURVE"] = "curve";
      DrawType["CLOSED_CURVE"] = "closedcurve";
      DrawType["LUNE"] = "lune";
      DrawType["SECTOR"] = "sector";
      DrawType["GATHERING_PLACE"] = "gatheringplace";
      DrawType["STRAIGHT_ARROW"] = "straightarrow";
      DrawType["ASSAULT_DIRECTION"] = "assaultdirection";
      DrawType["ATTACK_ARROW"] = "attackarrow";
      DrawType["SQUAD_COMBAT"] = "squadcombat";
      DrawType["TAILED_SQUAD_COMBAT"] = "tailedsquadcombat";
      DrawType["FINE_ARROW"] = "finearrow";
      DrawType["DOUBLE_ARROW"] = "doublearrow";
      DrawType["RECTANGLE"] = "rectangle";
  })(DrawType || (DrawType = {}));

  /**
   * 抽象几何体
   */
  var Geometry = /** @class */ (function () {
      function Geometry(type, points) {
          this._fixPointCount = 0;
          this._coordinates = [];
          this._type = type;
          this.setPoints(points);
      }
      Object.defineProperty(Geometry.prototype, "fixPointCount", {
          get: function () {
              return this._fixPointCount;
          },
          set: function (count) {
              this._fixPointCount = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Geometry.prototype, "type", {
          get: function () {
              return this._type;
          },
          set: function (type) {
              this._type = type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Geometry.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Geometry.prototype.setPoints = function (points) {
          this._points = points ? points : [];
          if (this._points.length >= 1)
              this.generate();
      };
      Geometry.prototype.generate = function () {
          throw new Error("该方法未实现");
      };
      Geometry.prototype.setCoordinates = function (coordinates) {
          this._coordinates = coordinates;
      };
      Geometry.prototype.getPoints = function () {
          return this._points.slice(0);
      };
      Geometry.prototype.getPointCount = function () {
          return this._points.length;
      };
      Geometry.prototype.updatePoint = function (point, index) {
          if (index >= 0 && index < this._points.length) {
              this._points[index] = point;
              this.generate();
          }
      };
      Geometry.prototype.updateLastPoint = function (point) {
          this.updatePoint(point, this._points.length - 1);
      };
      Geometry.prototype.finishDrawing = function () { };
      return Geometry;
  }());

  var Circle$1 = /** @class */ (function (_super) {
      __extends$6(Circle, _super);
      function Circle(points, minRadius, maxRadius) {
          var _this = _super.call(this, DrawType.CIRCLE, points) || this;
          _this.fixPointCount = 2;
          _this._minRadius = minRadius || 50 / 1000;
          _this._maxRadius = maxRadius || Number.MAX_VALUE;
          return _this;
      }
      Object.defineProperty(Circle.prototype, "projectionRadius", {
          get: function () {
              return this._projectionRadius;
          },
          set: function (value) {
              this._projectionRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "ellipsoidRaduis", {
          get: function () {
              return this._ellipsoidRaduis;
          },
          set: function (value) {
              this._ellipsoidRaduis = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "minRadius", {
          set: function (value) {
              this._minRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "maxRadius", {
          set: function (value) {
              this._maxRadius = value;
          },
          enumerable: false,
          configurable: true
      });
      Circle.prototype.generate = function () {
          var count = this.getPointCount();
          this.center = this.getPoints()[0];
          if (count < 2) {
              return;
          }
          var radius = calculatesRadius(this.getPoints()[0], this.getPoints()[1]);
          this.projectionRadius = convertToProjectionRadius(this.getPoints()[0], radius);
          if (radius <= this._minRadius) {
              radius = this._minRadius;
          }
          if (radius >= this._maxRadius) {
              radius = this._maxRadius;
          }
          var point = Turf__namespace.transformTranslate(Turf__namespace.point(this.center), radius, 90).geometry.coordinates;
          // @ts-ignore
          this._points[1] = point;
          this.ellipsoidRaduis = radius;
          this.setCoordinates([this.generatePoints(this.getPoints()[0], radius)]);
      };
      Circle.prototype.generatePoints = function (center, radius) {
          return getCircleCoordinates(center, radius);
      };
      return Circle;
  }(Geometry));

  var Circle = /** @class */ (function (_super) {
      __extends$6(Circle, _super);
      function Circle(_a, layer) {
          var center = _a.center, radius = _a.radius, properties = _a.properties, dataProjection = _a.dataProjection, projection = _a.projection, offset = _a.offset;
          var _this = _super.call(this, { coordinates: center, properties: properties, dataProjection: dataProjection, projection: projection, offset: offset }) || this;
          _this._radius = radius || 0;
          if (defined$1(layer)) {
              layer.addFeature(_this);
          }
          return _this;
      }
      Object.defineProperty(Circle.prototype, "coordinates", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "center", {
          get: function () {
              return this._coordinates;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "radius", {
          get: function () {
              return this._radius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "wkt", {
          get: function () {
              throw new Error(ErrorNotification.NOT_SUPPORTED);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "geoJson", {
          get: function () {
              var center = __spreadArray$1([], __read(this.center), false);
              return point(center, {
                  shape: "Circle",
                  radius: this.radius,
                  center: center
              });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Circle.prototype, "type", {
          get: function () {
              return FeatureType.CIRCLE;
          },
          enumerable: false,
          configurable: true
      });
      Circle.prototype.init = function () {
          var radius = convertToProjectionRadius(this.coordinates, this.radius, this.projection);
          this._sourceFeature = new OlFeature__default["default"]({
              geometry: new OLCircleGeom__default["default"](transformInternal(this.coordinates, {
                  source: this.dataProjection,
                  destination: this.projection,
                  offset: this.offset
              }), radius)
          });
          this._sourceFeature.setProperties(this.properties, true);
          if (this.radius > 0) {
              this.set("isPlot", true);
              var dragPointCoordinates = transformToDataProjection(Turf__namespace.transformTranslate(this.geoJson, this.radius / 1000, 90).geometry.coordinates, WGS84_PROJECTION_NAME);
              this.set("plot", new Circle$1([this.center, dragPointCoordinates]));
          }
      };
      Circle.prototype.setCenter = function (center, options) {
          this._coordinates = center;
          setFeatureProjection.call(this, options);
          this.sourceFeature.getGeometry().setCenter(transformInternal(this.coordinates, {
              source: this.dataProjection,
              destination: this.projection,
              offset: this.offset
          }));
          return this;
      };
      Circle.prototype.setRadius = function (radius) {
          this._radius = radius;
          // TODO:计算半径此处未考虑坐标系转换,完善此处坐标系转换逻辑
          this.sourceFeature.getGeometry().setRadius(convertToProjectionRadius(this.coordinates, this.radius, this.projection));
          return this;
      };
      /**
       * @ignore
       */
      Circle.prototype.setCoordinates = function (coordinates, options) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      return Circle;
  }(Feature));

  var index$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Feature: Feature,
    Point: Point$1,
    Polygon: Polygon$1,
    Polyline: Polyline$1,
    Circle: Circle,
    create: create$5
  });

  var Overlay = /** @class */ (function (_super) {
      __extends$6(Overlay, _super);
      function Overlay(options, map) {
          var _this = _super.call(this, __assign$1({ offset: [0, 0], positioning: Positioning.BOTTOM_CENTER, useEvent: true, dispatchMapEvent: { wheel: false }, autoAdjustment: false }, options)) || this;
          _this._proxyHandle = proxyHandle.bind(_this);
          if (defined$1(map)) {
              map.addOverlay(_this);
          }
          return _this;
      }
      Object.defineProperty(Overlay.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "element", {
          /**
           * 覆盖物`DOM`对象
           */
          get: function () {
              return this._element;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "container", {
          /**
           * 覆盖物容器`DOM`
           *
           * @type {HTMLElement}
           */
          get: function () {
              return this._container;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "offset", {
          /**
           * 覆盖物的偏移量
           *
           * [x,y] x正值为向右偏移,y正值为向下偏移
           */
          get: function () {
              return this._offset;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "position", {
          /**
           * 覆盖物在地球上的位置点
           */
          get: function () {
              return this._position;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "useEvent", {
          /**
           * 覆盖物`DOM`对象是否触发鼠标事件
           *
           * `false` 不触发覆盖物`DOM`鼠标事件
           */
          get: function () {
              return this._useEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "visible", {
          /**
           * 覆盖物显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "positioning", {
          /**
           * 覆盖物定位方式原点位置
           */
          get: function () {
              return this._positioning;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "currentPositioning", {
          /**
           * 覆盖物当前定位方式原点位置
           */
          get: function () {
              return this._currentPositioning || this._positioning;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "width", {
          /**
           * @ignore
           */
          get: function () {
              return this._width;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "height", {
          /**
           * @ignore
           */
          get: function () {
              return this._height;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "overlayContainer", {
          /**
           * @ignore
           */
          get: function () {
              return this._overlayContainer;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "heightReference", {
          /**
           * 位置高度参考
           *
           * [cesium]
           */
          get: function () {
              return this._heightReference;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "dispatchMapEvent", {
          /**
           * 分发到地图的事件
           */
          get: function () {
              return this._dispatchMapEvent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Overlay.prototype, "autoAdjustment", {
          /**
           * 是否自动调整弹窗位置，当弹窗会超出地图范围时可进行调整
           */
          get: function () {
              return this._autoAdjustment;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Overlay.prototype.init = function () {
          var _a = this.options, element = _a.element, className = _a.className, offset = _a.offset, positioning = _a.positioning, useEvent = _a.useEvent, position = _a.position, heightReference = _a.heightReference, dispatchMapEvent = _a.dispatchMapEvent, autoAdjustment = _a.autoAdjustment;
          this._element = element;
          this._className = initClassName(className, "mti-gis-overlay");
          this._offset = offset;
          this._positioning = positioning;
          this._useEvent = useEvent;
          this._visible = false;
          this._initialized = true;
          defined$1(this._heightReference) || (this._heightReference = heightReference);
          defined$1(this._dispatchMapEvent) || (this._dispatchMapEvent = dispatchMapEvent);
          defined$1(this._autoAdjustment) || (this._autoAdjustment = autoAdjustment);
          this._olOverlay = new Overlay__default["default"](__assign$1(__assign$1(__assign$1({ stopEvent: this._useEvent }, this.options), { className: this._className }), (position ? { position: transformToProjection(position) } : {})));
          this._initEvent();
          if (defined$1(position)) {
              this.setPosition(position);
          }
      };
      /**
       * @ignore
       */
      Overlay.prototype._initEvent = function () {
          var _this = this;
          Object.keys(this.dispatchMapEvent).forEach(function (key) {
              var _a;
              _this.dispatchMapEvent[key] && ((_a = _this._olOverlay) === null || _a === void 0 ? void 0 : _a.getElement().addEventListener(key, _this._proxyHandle));
          });
      };
      /**
       * @ignore
       */
      Overlay.prototype._removeEvent = function () {
          var _this = this;
          Object.keys(this.dispatchMapEvent).forEach(function (key) {
              var _a;
              (_a = _this._olOverlay) === null || _a === void 0 ? void 0 : _a.getElement().removeEventListener(key, _this._proxyHandle);
          });
      };
      /**
       * @ignore
       */
      Overlay.prototype.addTo = function (map) {
          this.map = map;
          this.initialized || this.init();
          this.map.map.addOverlay(this._olOverlay);
      };
      /**
       * @ignore
       */
      Overlay.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.removeOverlay(this._olOverlay);
          this.map = undefined;
      };
      /**
       * 设置覆盖物显示位置并显示
       *
       * `position`参数若为`undefined`时,会清除显示位置并隐藏
       */
      Overlay.prototype.setPosition = function (position) {
          if (!this.map) {
              return this;
          }
          this._position = position;
          if (position) {
              this.show();
          }
          else {
              this.hide();
          }
          return this;
      };
      /**
       * 设置覆盖物`DOM`对象
       */
      Overlay.prototype.setElement = function (value) {
          if (this.element === value)
              return this;
          this._olOverlay.setElement(value);
          this._element = value;
          return this;
      };
      /**
       * 设置覆盖物的偏移量
       *
       * [x,y] x正值为向右偏移,y正值为向下偏移
       * @param value
       */
      Overlay.prototype.setOffset = function (value) {
          this._offset = value;
          this._olOverlay.setOffset(this._offset);
          return this;
      };
      // /**
      //  * 设置覆盖物`DOM`对象是否触发鼠标事件
      //  *
      //  * `false` 不触发覆盖物`DOM`鼠标事件
      //  * @param value
      //  */
      // setUseEvent(value: boolean): Overlay {
      //   if (this.useEvent === value) return this
      //   this._useEvent = value
      //   // this._olOverlay.set
      //   return this
      // }
      /**
       * 设置覆盖物定位方式原点位置
       *
       * 可选值:`'top-left','bottom-left', 'bottom-center', 'bottom-right', 'center-left', 'center-center', 'center-right', 'top-center', 'top-right'`
       */
      Overlay.prototype.setPositioning = function (value) {
          this._positioning = value;
          this._olOverlay.setPositioning(this._positioning);
          return this;
      };
      // /**
      //  * 设置覆盖物容器的className
      //  */
      // setClassName(className: string): Overlay {
      //   // this.container.className = this._className = initClassName(
      //   //   className,
      //   //   'mti-gis-overlay'
      //   // )
      //   // this._olOverlay./
      //   return this
      // }
      /**
       * 设置分发到地图的事件
       */
      Overlay.prototype.setDispatchMapEvent = function (dispatchMapEvent) {
          this._removeEvent();
          this._dispatchMapEvent = dispatchMapEvent;
          this._initEvent();
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype.show = function () {
          var _this = this;
          if (!this._position)
              return this;
          var projectionCoordinate = transformToProjection(this._position);
          if (this.map.map.isRendered() && this.autoAdjustment) {
              var _a = __read(this.map.coordinateToPixel(this._position), 2), x = _a[0], y = _a[1];
              var _b = this.map.map.getViewport(), containerClientHeight = _b.clientHeight, containerClientWidth = _b.clientWidth;
              var _c = this.element, elementClientHeight = _c.clientHeight, elementClientWidth = _c.clientWidth;
              x += this.offset[0];
              y += this.offset[1];
              var _d = __read(this.offset, 2), offsetX = _d[0], offsetY = _d[1];
              var positioning = this.positioning;
              var posX = "0%";
              var posY = "0%";
              if (positioning === Positioning.BOTTOM_RIGHT ||
                  positioning === Positioning.CENTER_RIGHT ||
                  positioning === Positioning.TOP_RIGHT) {
                  posX = "-100%";
              }
              else if (positioning === Positioning.BOTTOM_CENTER ||
                  positioning === Positioning.CENTER_CENTER ||
                  positioning === Positioning.TOP_CENTER) {
                  posX = "-50%";
              }
              if (positioning === Positioning.BOTTOM_LEFT ||
                  positioning === Positioning.BOTTOM_CENTER ||
                  positioning === Positioning.BOTTOM_RIGHT) {
                  posY = "-100%";
              }
              else if (positioning === Positioning.CENTER_LEFT ||
                  positioning === Positioning.CENTER_CENTER ||
                  positioning === Positioning.CENTER_RIGHT) {
                  posY = "-50%";
              }
              var _e = __read(this.positioning.split("-"), 2), positioningY = _e[0], positioningX = _e[1];
              var left = x + (parseInt(posX) / 100) * elementClientWidth + offsetX;
              var right = containerClientWidth - (x + (parseInt(posX) / 100) * elementClientWidth + elementClientWidth + offsetX);
              if (left < 0 && right > 0) {
                  positioningX = "left";
                  offsetX = 0;
              }
              else if (left > 0 && right < 0) {
                  positioningX = "right";
                  offsetX = 0;
              }
              var top_1 = y + (parseInt(posY) / 100) * elementClientHeight + offsetY;
              var bottom = containerClientHeight - (y + (parseInt(posY) / 100) * elementClientHeight + elementClientHeight + offsetY);
              if (top_1 < 0 && bottom > 0) {
                  offsetY = 0;
                  positioningY = "top";
              }
              else if (top_1 > 0 && bottom < 0) {
                  offsetY = 0;
                  positioningY = "bottom";
              }
              if (elementClientWidth !== 0 && elementClientHeight !== 0) {
                  this._currentPositioning = "".concat(positioningY, "-").concat(positioningX);
                  this._olOverlay.setPositioning(this._currentPositioning);
                  this._olOverlay.setOffset([offsetX, offsetY]);
              }
              else {
                  setTimeout(function () {
                      _this.show();
                  }, 0);
              }
              this._olOverlay.getElement().style.visibility = "hidden";
          }
          else {
              this._olOverlay.setPositioning(this._positioning);
              this._olOverlay.setOffset(this._offset);
          }
          this._olOverlay.setPosition(projectionCoordinate);
          setTimeout(function () {
              _this._olOverlay.getElement().style.visibility = "visible";
          }, 0);
          this._visible = true;
          this.dispatchEvent({
              type: BaseEventType.SHOW
          });
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype.hide = function () {
          if (!this._visible)
              return this;
          this._olOverlay.setPosition(undefined);
          this._visible = false;
          this.dispatchEvent({
              type: BaseEventType.HIDE
          });
          return this;
      };
      /**
       * @ignore
       */
      Overlay.prototype._destroy = function () {
          this.remove();
          this._removeEvent();
          this._olOverlay = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Overlay.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Overlay.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 设置位置高度参考
       *
       * [cesium]
       */
      Overlay.prototype.setHeightReference = function (heightReference) {
          this._heightReference = heightReference;
          return this;
      };
      /**
       * 设置是否自动调整弹窗位置
       * @param autoAdjustment
       */
      Overlay.prototype.setAutoAdjustment = function (autoAdjustment) {
          this._autoAdjustment = autoAdjustment;
          this.show();
          return;
      };
      return Overlay;
  }(BaseObject$1));
  function proxyHandle(e) {
      this.map.map.getViewport().dispatchEvent(new WheelEvent(e.type, {
          deltaX: e.deltaX,
          deltaY: e.deltaY,
          deltaZ: e.deltaZ,
          deltaMode: e.deltaMode,
          clientX: e.clientX,
          clientY: e.clientY
      }));
  }

  /**
   * 图片覆盖物类
   */
  var Image$1 = /** @class */ (function (_super) {
      __extends$6(Image, _super);
      function Image(options, map) {
          var img = document.createElement("img");
          img.src = options.img;
          if (options.size) {
              img.width = options.size[0];
              img.height = options.size[1];
          }
          var op = __assign$1({ element: img, positioning: Positioning.CENTER_CENTER, useEvent: false }, options);
          return _super.call(this, op, map) || this;
      }
      Object.defineProperty(Image.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Image.prototype._initEvent = function () {
          var e_1, _a;
          var _this = this;
          _super.prototype._initEvent.call(this);
          this._events = [
              {
                  type: "click",
                  func: function (e) {
                      _this.useEvent &&
                          _this.dispatchEvent({
                              type: BaseEventType.CLICK,
                              originEvent: e
                          });
                  }
              },
              {
                  type: "contextmenu",
                  func: function (e) {
                      _this.useEvent &&
                          _this.dispatchEvent({
                              type: BaseEventType.RIGHT_CLICK,
                              originEvent: e
                          });
                  }
              },
              {
                  type: "dblclick",
                  func: function (e) {
                      _this.useEvent &&
                          _this.dispatchEvent({
                              type: BaseEventType.DOUBLE_CLICK,
                              originEvent: e
                          });
                  }
              },
              {
                  type: "wheel",
                  func: function (e) {
                      _this.map.map.getViewport().dispatchEvent(new WheelEvent(e.type, {
                          deltaX: e.deltaX,
                          deltaY: e.deltaY,
                          deltaZ: e.deltaZ,
                          deltaMode: e.deltaMode,
                          clientX: e.clientX,
                          clientY: e.clientY
                      }));
                  }
              }
          ];
          try {
              for (var _b = __values(this._events), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var iterator = _c.value;
                  this.element.addEventListener(iterator.type, iterator.func);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Image.prototype._clearEvent = function () {
          var e_2, _a;
          try {
              for (var _b = __values(this._events), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var iterator = _c.value;
                  this.element.removeEventListener(iterator.type, iterator.func);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `doubleclick` |  左键双击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `rightclick` |  右键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param type
       * @param listener
       * @return {*}
       */
      Image.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `doubleclick` |  左键双击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `rightclick` |  右键单击  | (originEvent:MouseEvent)-原生浏览器事件
       *  `show`    |   弹窗显示  |
       *  `hide` |  弹窗隐藏  |
       *
       * @param type
       * @param listener
       * @return {*}
       */
      Image.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * @ignore
       * @override
       */
      Image.prototype._removeEvent = function () {
          _super.prototype._removeEvent.call(this);
          this._clearEvent();
      };
      return Image;
  }(Overlay));

  /**
   * 提示框定位类别
   *
   * @enum {number}
   */
  var PlacementType;
  (function (PlacementType) {
      PlacementType["TOP"] = "top";
      PlacementType["BOTTOM"] = "bottom";
      PlacementType["LEFT"] = "left";
      PlacementType["RIGHT"] = "right";
  })(PlacementType || (PlacementType = {}));

  /**
   * 提示框类
   */
  var Tooltip = /** @class */ (function (_super) {
      __extends$6(Tooltip, _super);
      function Tooltip(options, map) {
          var _this = this;
          var element = initTooltipElement();
          _this = _super.call(this, __assign$1({ element: element, positioning: Positioning.BOTTOM_CENTER, className: "mti-gis-overlay-tooltip", useEvent: false }, options), map) || this;
          _this._textElement = element.firstElementChild;
          _this._arrowElement = element.lastElementChild;
          options.properties && _this.setProperties(options.properties);
          options.text && _this.setText(options.text);
          _this._element = element;
          _this._theme = "dark";
          options.theme && _this.setTheme(options.theme);
          if (options.placement) {
              _this.setPlacement(options.placement);
          }
          else {
              _this._placement = PlacementType.TOP;
          }
          return _this;
      }
      Object.defineProperty(Tooltip.prototype, "properties", {
          /**
           * 提示框属性
           */
          get: function () {
              return this._properties;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Tooltip.prototype, "text", {
          /**
           * 提示框内容模板
           * @constructor
           */
          get: function () {
              return this._text;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Tooltip.prototype, "placement", {
          /**
           * 提示框定位位置
           */
          get: function () {
              return this._placement;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 设置提示框内容模板,可用`{propertyName}`占位
       * @param text
       */
      Tooltip.prototype.setText = function (text) {
          var e_1, _a;
          this._text = text;
          var template = text;
          if (this.properties && /{|}/g.test(text)) {
              try {
                  for (var _b = __values(Object.keys(this.properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var key = _c.value;
                      template = template.replace(new RegExp("{" + key + "}", "g"), this.properties[key]);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
          this._textElement.innerHTML = template;
          this._resetArrow();
          return this;
      };
      /**
       * 设置提示框属性
       * @param properties
       */
      Tooltip.prototype.setProperties = function (properties) {
          this._properties = properties;
          this.setText(this._text);
          return this;
      };
      /**
       * 设置提示框主题
       *
       * 可选值:'dark'(默认),'light'
       * @param theme
       */
      Tooltip.prototype.setTheme = function (theme) {
          if (this._theme === theme)
              return this;
          this._element.classList.replace("is-" + this._theme, "is-" + theme);
          this._theme = theme;
          return this;
      };
      /**
       * 此对象该方法无效
       */
      Tooltip.prototype.setElement = function (value) {
          return this;
      };
      /**
       * 此对象该方法无效
       */
      Tooltip.prototype.setPositioning = function (value) {
          return this;
      };
      /**
       * 设置提示框定位位置
       */
      Tooltip.prototype.setPlacement = function (value) {
          if (this._placement === value)
              return this;
          this._element.classList.replace("is-" + (this._placement || "top"), "is-" + value);
          switch (value) {
              case PlacementType.TOP:
                  _super.prototype.setPositioning.call(this, Positioning.BOTTOM_CENTER);
                  break;
              case PlacementType.BOTTOM:
                  _super.prototype.setPositioning.call(this, Positioning.TOP_CENTER);
                  break;
              case PlacementType.LEFT:
                  _super.prototype.setPositioning.call(this, Positioning.CENTER_RIGHT);
                  break;
              case PlacementType.RIGHT:
                  _super.prototype.setPositioning.call(this, Positioning.CENTER_LEFT);
                  break;
          }
          this._placement = value;
          this._resetArrow();
          return this;
      };
      /**
       * @override
       */
      Tooltip.prototype.setPosition = function (position) {
          var show = this._position;
          _super.prototype.setPosition.call(this, position);
          show || this._resetArrow();
          return this;
      };
      /**
       * @ignore
       */
      Tooltip.prototype._resetArrow = function () {
          var _this = this;
          if (this.initialized) {
              requestAnimationFrame(function () {
                  if (_this._placement === "top" || _this._placement === "bottom") {
                      _this._arrowElement.style.top = "";
                      _this._arrowElement.style.left = _this._element.offsetWidth / 2 - _this._arrowElement.offsetWidth / 2 + "px";
                  }
                  else if (_this.placement === "left" || _this.placement === "right") {
                      _this._arrowElement.style.left = "";
                      _this._arrowElement.style.top = _this._element.offsetHeight / 2 - _this._arrowElement.offsetHeight / 2 + "px";
                  }
              });
          }
      };
      return Tooltip;
  }(Overlay));

  /**
   * Code
   */

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Overlay: Overlay,
    Image: Image$1,
    Tooltip: Tooltip,
    get PlacementType () { return PlacementType; }
  });

  /**
   * 组件基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Component$1 = /** @class */ (function (_super) {
      __extends$6(Component, _super);
      function Component(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           * @private
           */
          _this._initialized = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Component.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化组件
       *
       * @ignore
       */
      Component.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Component.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this._initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Component.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      return Component;
  }(BaseObject$1));

  /**
   * 常量定义----
   */
  var Constants = {
      TWO_PI: Math.PI * 2,
      HALF_PI: Math.PI / 2,
      FITTING_COUNT: 100,
      ZERO_TOLERANCE: 0.0005
  };

  /**
   *
   * 常用的空间函数
   */
  function distance$1(pnt1, pnt2) {
      return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
  }
  function wholeDistance(points) {
      var dis = 0;
      for (var i = 0; i < points.length - 1; i++)
          dis += distance$1(points[i], points[i + 1]);
      return dis;
  }
  function getBaseLength(points) {
      return Math.pow(wholeDistance(points), 0.99);
  }
  /**
   * 获取两点之间的中点
   * @param pnt1 PointCoordinate
   * @param pnt2 PointCoordinate
   * @returns
   */
  function middle(pnt1, pnt2) {
      return [(pnt1[0] + pnt2[0]) / 2, (pnt1[1] + pnt2[1]) / 2];
  }
  /**
   * 从三点确定一圆，计算其外接圆的中心点
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function getCircleCenterOfThreePoints(pnt1, pnt2, pnt3) {
      var pntA = [(pnt1[0] + pnt2[0]) / 2, (pnt1[1] + pnt2[1]) / 2];
      var pntB = [pntA[0] - pnt1[1] + pnt2[1], pntA[1] + pnt1[0] - pnt2[0]];
      var pntC = [(pnt1[0] + pnt3[0]) / 2, (pnt1[1] + pnt3[1]) / 2];
      var pntD = [pntC[0] - pnt1[1] + pnt3[1], pntC[1] + pnt1[0] - pnt3[0]];
      return getIntersectPoint(pntA, pntB, pntC, pntD);
  }
  /**
   * 计算相交点坐标
   * @param pntA
   * @param pntB
   * @param pntC
   * @param pntD
   * @returns
   */
  function getIntersectPoint(pntA, pntB, pntC, pntD) {
      if (pntA[1] === pntB[1]) {
          var f_1 = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
          var x_1 = f_1 * (pntA[1] - pntC[1]) + pntC[0];
          var y_1 = pntA[1];
          return [x_1, y_1];
      }
      if (pntC[1] === pntD[1]) {
          var e_1 = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
          var x_2 = e_1 * (pntC[1] - pntA[1]) + pntA[0];
          var y_2 = pntC[1];
          return [x_2, y_2];
      }
      var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
      var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
      var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
      var x = e * y - e * pntA[1] + pntA[0];
      return [x, y];
  }
  // 计算方位角
  function getAzimuth(startPnt, endPnt) {
      var azimuth;
      var angle = Math.asin(Math.abs(endPnt[1] - startPnt[1]) / distance$1(startPnt, endPnt));
      if (endPnt[1] >= startPnt[1] && endPnt[0] >= startPnt[0])
          azimuth = angle + Math.PI;
      else if (endPnt[1] >= startPnt[1] && endPnt[0] < startPnt[0])
          azimuth = Constants.TWO_PI - angle;
      else if (endPnt[1] < startPnt[1] && endPnt[0] < startPnt[0])
          azimuth = angle;
      else if (endPnt[1] < startPnt[1] && endPnt[0] >= startPnt[0])
          azimuth = Math.PI - angle;
      return azimuth;
  }
  /**
   * 计算三点之间夹角
   * @param pntA
   * @param pntB
   * @param pntC
   * @returns
   */
  function getAngleOfThreePoints(pntA, pntB, pntC) {
      var angle = getAzimuth(pntB, pntA) - getAzimuth(pntB, pntC);
      return angle < 0 ? angle + Constants.TWO_PI : angle;
  }
  /**
   *  是否顺时针---
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function isClockWise(pnt1, pnt2, pnt3) {
      return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
  }
  function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
      t = Math.max(Math.min(t, 1), 0);
      var tp = 1 - t;
      var t2 = t * t;
      var t3 = t2 * t;
      var tp2 = tp * tp;
      var tp3 = tp2 * tp;
      var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
      var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
      return [x, y, 0];
  }
  function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
      var azimuth = getAzimuth(startPnt, endPnt);
      var alpha = clockWise ? azimuth + angle : azimuth - angle;
      var dx = distance * Math.cos(alpha);
      var dy = distance * Math.sin(alpha);
      return [endPnt[0] + dx, endPnt[1] + dy, 0];
  }
  /**
   *  根据圆心、起始角度、半径计算构成圆弧的点位置坐标数组
   * @param center
   * @param radius
   * @param startAngle
   * @param endAngle
   * @returns
   */
  function getArcPoints(center, radius, startAngle, endAngle) {
      var x;
      var y;
      var pnts = [];
      var angleDiff = endAngle - startAngle;
      angleDiff = angleDiff < 0 ? angleDiff + Constants.TWO_PI : angleDiff;
      for (var i = 0; i <= Constants.FITTING_COUNT; i++) {
          var angle = startAngle + (angleDiff * i) / Constants.FITTING_COUNT;
          x = center[0] + radius * Math.cos(angle);
          y = center[1] + radius * Math.sin(angle);
          pnts.push([x, y]);
      }
      return pnts;
  }
  function getBisectorNormals(t, pnt1, pnt2, pnt3) {
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var uX = normal[0] / dist;
      var uY = normal[1] / dist;
      var d1 = distance$1(pnt1, pnt2);
      var d2 = distance$1(pnt2, pnt3);
      var bisectorNormalRight;
      var bisectorNormalLeft;
      if (dist > Constants.ZERO_TOLERANCE) {
          if (isClockWise(pnt1, pnt2, pnt3)) {
              var dt = t * d1;
              var x = pnt2[0] - dt * uY;
              var y = pnt2[1] + dt * uX;
              bisectorNormalRight = [x, y, 0];
              dt = t * d2;
              x = pnt2[0] + dt * uY;
              y = pnt2[1] - dt * uX;
              bisectorNormalLeft = [x, y, 0];
          }
          else {
              var dt = t * d1;
              var x = pnt2[0] + dt * uY;
              var y = pnt2[1] - dt * uX;
              bisectorNormalRight = [x, y, 0];
              dt = t * d2;
              x = pnt2[0] - dt * uY;
              y = pnt2[1] + dt * uX;
              bisectorNormalLeft = [x, y, 0];
          }
      }
      else {
          var x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
          var y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
          bisectorNormalRight = [x, y, 0];
          x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
          y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
          bisectorNormalLeft = [x, y, 0];
      }
      return [bisectorNormalRight, bisectorNormalLeft];
  }
  /**
   * 获取法线
   * @param pnt1
   * @param pnt2
   * @param pnt3
   * @returns
   */
  function getNormal(pnt1, pnt2, pnt3) {
      var dX1 = pnt1[0] - pnt2[0];
      var dY1 = pnt1[1] - pnt2[1];
      var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
      dX1 /= d1;
      dY1 /= d1;
      var dX2 = pnt3[0] - pnt2[0];
      var dY2 = pnt3[1] - pnt2[1];
      var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
      dX2 /= d2;
      dY2 /= d2;
      var uX = dX1 + dX2;
      var uY = dY1 + dY2;
      return [uX, uY];
  }
  function getCurvePoints$1(t, controlPoints) {
      var leftControl = getLeftMostControlPoint(controlPoints, t);
      var normals = [leftControl];
      for (var i = 0; i < controlPoints.length - 2; i++) {
          var pnt1 = controlPoints[i];
          var pnt2 = controlPoints[i + 1];
          var pnt3 = controlPoints[i + 2];
          var normalPoints = getBisectorNormals(t, pnt1, pnt2, pnt3);
          normals = normals.concat(normalPoints);
      }
      var rightControl = getRightMostControlPoint(controlPoints, t);
      normals.push(rightControl);
      var points = [];
      for (var i = 0; i < controlPoints.length - 1; i++) {
          var pnt1 = controlPoints[i];
          var pnt2 = controlPoints[i + 1];
          points.push(pnt1);
          for (var t_1 = 0; t_1 < Constants.FITTING_COUNT; t_1++) {
              var pnt = getCubicValue(t_1 / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
              points.push(pnt);
          }
          points.push(pnt2);
      }
      return points;
  }
  function getLeftMostControlPoint(controlPoints, t) {
      var pnt1 = controlPoints[0];
      var pnt2 = controlPoints[1];
      var pnt3 = controlPoints[2];
      var pnts = getBisectorNormals(0, pnt1, pnt2, pnt3);
      var normalRight = pnts[0];
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var controlX;
      var controlY;
      if (dist > Constants.ZERO_TOLERANCE) {
          var mid = middle(pnt1, pnt2);
          var pX = pnt1[0] - mid[0];
          var pY = pnt1[1] - mid[1];
          var d1 = distance$1(pnt1, pnt2);
          // normal at midpoint
          var n = 2.0 / d1;
          var nX = -n * pY;
          var nY = n * pX;
          // upper triangle of symmetric transform matrix
          var a11 = nX * nX - nY * nY;
          var a12 = 2 * nX * nY;
          var a22 = nY * nY - nX * nX;
          var dX = normalRight[0] - mid[0];
          var dY = normalRight[1] - mid[1];
          // coordinates of reflected vector
          controlX = mid[0] + a11 * dX + a12 * dY;
          controlY = mid[1] + a12 * dX + a22 * dY;
      }
      else {
          controlX = pnt1[0] + t * (pnt2[0] - pnt1[0]);
          controlY = pnt1[1] + t * (pnt2[1] - pnt1[1]);
      }
      return [controlX, controlY, 0];
  }
  function getRightMostControlPoint(controlPoints, t) {
      var count = controlPoints.length;
      var pnt1 = controlPoints[count - 3];
      var pnt2 = controlPoints[count - 2];
      var pnt3 = controlPoints[count - 1];
      var pnts = getBisectorNormals(0, pnt1, pnt2, pnt3);
      var normalLeft = pnts[1];
      var normal = getNormal(pnt1, pnt2, pnt3);
      var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
      var controlX;
      var controlY;
      if (dist > Constants.ZERO_TOLERANCE) {
          var mid = middle(pnt2, pnt3);
          var pX = pnt3[0] - mid[0];
          var pY = pnt3[1] - mid[1];
          var d1 = distance$1(pnt2, pnt3);
          // normal at midpoint
          var n = 2.0 / d1;
          var nX = -n * pY;
          var nY = n * pX;
          // upper triangle of symmetric transform matrix
          var a11 = nX * nX - nY * nY;
          var a12 = 2 * nX * nY;
          var a22 = nY * nY - nX * nX;
          var dX = normalLeft[0] - mid[0];
          var dY = normalLeft[1] - mid[1];
          // coordinates of reflected vector
          controlX = mid[0] + a11 * dX + a12 * dY;
          controlY = mid[1] + a12 * dX + a22 * dY;
      }
      else {
          controlX = pnt3[0] + t * (pnt2[0] - pnt3[0]);
          controlY = pnt3[1] + t * (pnt2[1] - pnt3[1]);
      }
      return [controlX, controlY, 0];
  }
  function getBezierPoints(points) {
      if (points.length <= 2)
          return points;
      var bezierPoints = [];
      var n = points.length - 1;
      for (var t = 0; t <= 1; t += 0.01) {
          var x = 0;
          var y = 0;
          for (var index = 0; index <= n; index++) {
              var factor = getBinomialFactor(n, index);
              var a = Math.pow(t, index);
              var b = Math.pow(1 - t, n - index);
              x += factor * a * b * points[index][0];
              y += factor * a * b * points[index][1];
          }
          bezierPoints.push([x, y]);
      }
      bezierPoints.push(points[n]);
      return bezierPoints;
  }
  function getBinomialFactor(n, index) {
      return getFactorial(n) / (getFactorial(index) * getFactorial(n - index));
  }
  function getFactorial(n) {
      if (n <= 1)
          return 1;
      if (n === 2)
          return 2;
      if (n === 3)
          return 6;
      if (n === 4)
          return 24;
      if (n === 5)
          return 120;
      var result = 1;
      for (var i = 1; i <= n; i++)
          result *= i;
      return result;
  }
  function getQBSplinePoints(points) {
      if (points.length <= 2)
          return points;
      var n = 2;
      var bSplinePoints = [];
      var m = points.length - n - 1;
      bSplinePoints.push(points[0]);
      for (var i = 0; i <= m; i++) {
          for (var t = 0; t <= 1; t += 0.05) {
              var x = 0;
              var y = 0;
              for (var k = 0; k <= n; k++) {
                  var factor = getQuadricBSplineFactor(k, t);
                  x += factor * points[i + k][0];
                  y += factor * points[i + k][1];
              }
              bSplinePoints.push([x, y]);
          }
      }
      bSplinePoints.push(points[points.length - 1]);
      return bSplinePoints;
  }
  function getQuadricBSplineFactor(k, t) {
      if (k === 0)
          return Math.pow(t - 1, 2) / 2;
      if (k === 1)
          return (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
      if (k === 2)
          return Math.pow(t, 2) / 2;
      return 0;
  }
  // // 默认样式
  // export const defaultStyle = {
  //   plotFillColor: "#ffd500",
  //   plotAlpha: 0.6,
  //   drawPointColor: "blue",
  //   drawPointAlpha: 0.8,
  //   drawPointWidth: 10,
  //   drawPointOutlineColor: "white",
  //   drawPointActiveColor: "purple",
  //   drawPointOutlineWidth: 2
  // };
  // // 构造GeoJSON 要素
  // function createFeature(coord, type) {
  //   return {
  //     type: "Feature",
  //     properties: {
  //       type
  //     },
  //     geometry: {
  //       type: "Polygon",
  //       coordinates: [coord]
  //     }
  //   };
  // }
  // export function JsonToGeojson(jsonData) {
  //   if (!jsonData) {
  //     return;
  //   }
  //   const geojson = {
  //     type: "FeatureCollection",
  //     features: []
  //   };
  //   Object.keys(jsonData).forEach((key, i) => {
  //     if (key === "straightArrowData") {
  //       const value: any = Object.values(jsonData);
  //       if (value.length) {
  //         value[i].forEach((coord) => {
  //           const feature = createFeature(coord, DrawType.STRAIGHT_ARROW);
  //           geojson.features.push(feature);
  //         });
  //       }
  //     }
  //     if (key === "attackArrowData") {
  //       const value: any = Object.values(jsonData);
  //       if (value.length) {
  //         value[i].forEach((coord) => {
  //           const feature = createFeature(coord, DrawType.ATTACK_ARROW);
  //           geojson.features.push(feature);
  //         });
  //       }
  //     }
  //   });
  //   return geojson;
  // }
  // export function exportGeoJSON(geojsonData) {
  //   const content = JSON.stringify(geojsonData);
  //   const eleLink = document.createElement("a");
  //   eleLink.download = "plotData.json";
  //   eleLink.style.display = "none";
  //   const blob = new Blob([content]);
  //   eleLink.href = URL.createObjectURL(blob);
  //   document.body.appendChild(eleLink);
  //   eleLink.click();
  //   document.body.removeChild(eleLink);
  // }
  // export function GeojsonToJson(datas) {
  //   const jsonObj = JSON.parse(datas);
  //   const json = {
  //     straightArrowData: [],
  //     attackArrowData: []
  //   };
  //   jsonObj.features.forEach((item) => {
  //     switch (item.properties.type) {
  //       case DrawType.STRAIGHT_ARROW:
  //         json.straightArrowData.push(item.geometry.coordinates[0]);
  //         break;
  //       case DrawType.ATTACK_ARROW:
  //         json.attackArrowData.push(item.geometry.coordinates[0]);
  //         break;
  //     }
  //   });
  //   return json;
  // }
  // /**
  //  * 获取目标点被平移后新的点位 （平移矩阵的积运算  平移矩阵 * 原始位置）
  //  * @ignore
  //  * @export
  //  * @param {Cesium.Cartesian3} currentMousePoint 鼠标当前的点位
  //  * @param {Cesium.Cartesian3} lastMousePoint 上次鼠标移动的点位
  //  * @param {Cesium.Cartesian3} targetPoint 需要被移动的点位
  //  * @returns {Cesium.Cartesian3} 该点被移动后新的点位
  //  */
  // export function getNewPosition(currentMousePoint, lastMousePoint, targetPoint) {
  //   // 平移量（当前鼠标点的偏移量） ，如果不对，互换一下当前点与上一次移动点的位置。
  //   const translation = Cesium.Cartesian3.subtract(currentMousePoint, lastMousePoint, new Cesium.Cartesian3());
  //   // 创建一个平移矩阵(当前鼠标移动产生的平移矩阵)
  //   const matrix4 = Cesium.Matrix4.fromTranslation(translation);
  //   // 计算目标点的被移动后的位置
  //   const cart3 = Cesium.Matrix4.multiplyByPoint(matrix4, targetPoint, new Cesium.Cartesian3());
  //   return cart3;
  // }
  // /* 笛卡尔转经纬度 */
  // export function cartesianToLatlng(cartesian, viewer) {
  //   const latlng = viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);
  //   const lat = Cesium.Math.toDegrees(latlng.latitude);
  //   const lng = Cesium.Math.toDegrees(latlng.longitude);
  //   return [lng, lat];
  // }
  // /**
  //  * 拾取坐标与转换
  //  * @ignore
  //  * @param {Object} px 屏幕坐标
  //  * @param {Object} viewer 视图容器
  //  */
  // export function getCatesian3FromPX(px, viewer) {
  //   const picks = viewer.scene.drillPick(px);
  //   viewer.render();
  //   let cartesian = null;
  //   let isOn3dtiles = true;
  //   for (let i = 0; i < picks.length; i++) {
  //     if ((picks[i] && picks[i].primitive) || picks[i] instanceof Cesium.Cesium3DTileFeature) {
  //       // 模型上拾取
  //       isOn3dtiles = true;
  //     }
  //   }
  //   if (isOn3dtiles) {
  //     cartesian = viewer.scene.pickPosition(px);
  //   } else {
  //     const ray = viewer.camera.getPickRay(px);
  //     if (!ray) return null;
  //     cartesian = viewer.scene.globe.pick(ray, viewer.scene);
  //   }
  //   return cartesian;
  // }
  // /**
  //  * 创建编辑点
  //  * @ignore
  //  * @param {Cesium.Cartesian3} cartesian 笛卡尔坐标
  //  * @returns {Cesium.Entity<PointGraphics>}
  //  */
  // export function creatPoint(cartesian, style, viewer) {
  //   const { drawPointColor, drawPointOutlineColor, drawPointOutlineWidth, drawPointAlpha, drawPointWidth } = style;
  //   const point = viewer.entities.add({
  //     position: cartesian,
  //     point: {
  //       pixelSize: drawPointWidth,
  //       color: Cesium.Color.fromCssColorString(drawPointColor).withAlpha(drawPointAlpha),
  //       outlineWidth: drawPointOutlineWidth,
  //       outlineColor: Cesium.Color.fromCssColorString(drawPointOutlineColor).withAlpha(drawPointAlpha),
  //       heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
  //       disableDepthTestDistance: Number.POSITIVE_INFINITY
  //     }
  //   });
  //   point.attr = "editPoint";
  //   return point;
  // }
  // /* 两点的中点坐标 */
  // export function getCenterOfCartesian3(points) {
  //   const x = (points[0].x + points[1].x) / 2;
  //   const y = (points[0].y + points[1].y) / 2;
  //   const z = (points[0].z + points[1].z) / 2;
  //   return { x, y, z };
  // }
  // /* 平移矩阵 */
  // export function moveMatrix(pos) {
  //   const translation = Cesium.Cartesian3.fromArray([pos.x, pos.y, pos.z]);
  //   const mat4 = Cesium.Matrix4.fromTranslation(translation);
  //   return mat4;
  // }
  // export function getPointByDistance(position, distance, pos) {
  //   // 以点为原点建立局部坐标系（东方向为x轴,北方向为y轴,垂直于地面为z轴），得到一个局部坐标到世界坐标转换的变换矩阵
  //   const localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
  //   return Cesium.Matrix4.multiplyByPoint(
  //     localToWorld_Matrix,
  //     Cesium.Cartesian3.fromElements(0, distance, 0),
  //     new Cesium.Cartesian3()
  //   );
  // }

  /**
   * 圆弧扩展类
   * huhongxn
   */
  var Arc = /** @class */ (function (_super) {
      __extends$6(Arc, _super);
      function Arc(points) {
          var _this = _super.call(this, DrawType.ARC, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      // 重写父类方法
      Arc.prototype.generate = function () {
          var _points = this.getPoints();
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates(_points);
          }
          else {
              var startAngle = void 0;
              var endAngle = void 0;
              var pnt1 = _points[0];
              var pnt2 = _points[1];
              var pnt3 = _points[2];
              var center = getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
              var radius = distance$1(pnt1, center);
              var angle1 = getAzimuth(pnt1, center);
              var angle2 = getAzimuth(pnt2, center);
              if (isClockWise(pnt1, pnt2, pnt3)) {
                  startAngle = angle2;
                  endAngle = angle1;
              }
              else {
                  startAngle = angle1;
                  endAngle = angle2;
              }
              this.setCoordinates(getArcPoints(center, radius, startAngle, endAngle));
          }
      };
      return Arc;
  }(Geometry));

  /**
   * 椭圆扩展类
   * 胡红勋
   *
   */
  var Ellipse = /** @class */ (function (_super) {
      __extends$6(Ellipse, _super);
      function Ellipse(points) {
          var _this = _super.call(this, DrawType.ELLIPSE, points) || this;
          _this.fixPointCount = 2;
          return _this;
      }
      Ellipse.prototype.generate = function () {
          var count = this.getPointCount();
          var _points = this.getPoints();
          if (count < 2) {
              return;
          }
          var pnt1 = _points[0];
          var pnt2 = _points[1];
          var center = middle(pnt1, pnt2);
          var majorRadius = Math.abs((pnt1[0] - pnt2[0]) / 2);
          var minorRadius = Math.abs((pnt1[1] - pnt2[1]) / 2);
          this.setCoordinates([this.generatePoints(center, majorRadius, minorRadius)]);
      };
      Ellipse.prototype.generatePoints = function (center, majorRadius, minorRadius) {
          var x, y, angle;
          var points = [];
          for (var i = 0; i <= Constants.FITTING_COUNT; i++) {
              angle = (Math.PI * 2 * i) / Constants.FITTING_COUNT;
              x = center[0] + majorRadius * Math.cos(angle);
              y = center[1] + minorRadius * Math.sin(angle);
              points.push([x, y]);
          }
          return points;
      };
      return Ellipse;
  }(Geometry));

  /**
   * 曲线扩展类
   * huhongxun
   */
  var Curve = /** @class */ (function (_super) {
      __extends$6(Curve, _super);
      function Curve(points) {
          var _this = _super.call(this, DrawType.CURVE, points) || this;
          _this._t = 0.3;
          return _this;
      }
      Curve.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates(this.getPoints());
          }
          else {
              this.setCoordinates(getCurvePoints$1(this._t, this.getPoints()));
          }
      };
      return Curve;
  }(Geometry));

  /**
   * 闭合曲线扩展类
   * huhongunxun
   */
  var ClosedCurve = /** @class */ (function (_super) {
      __extends$6(ClosedCurve, _super);
      function ClosedCurve(points) {
          var _this = _super.call(this, DrawType.CLOSED_CURVE, points) || this;
          _this._t = 0.3;
          return _this;
      }
      ClosedCurve.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates([this.getPoints()]);
          }
          else {
              var pnts = this.getPoints();
              pnts.push(pnts[0], pnts[1]);
              var normals = [];
              for (var i = 0; i < pnts.length - 2; i++) {
                  var normalPoints = getBisectorNormals(this._t, pnts[i], pnts[i + 1], pnts[i + 2]);
                  normals = normals.concat(normalPoints);
              }
              var count_1 = normals.length;
              normals = [normals[count_1 - 1]].concat(normals.slice(0, count_1 - 1));
              var pList = [];
              for (var i = 0; i < pnts.length - 2; i++) {
                  var pnt1 = pnts[i];
                  var pnt2 = pnts[i + 1];
                  pList.push(pnt1);
                  for (var t = 0; t <= Constants.FITTING_COUNT; t++) {
                      var pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
                      pList.push(pnt);
                  }
                  pList.push(pnt2);
              }
              this.setCoordinates([pList]);
          }
      };
      return ClosedCurve;
  }(Geometry));

  /**
   * huhongxun
   * 面扩展类, 钳击
   */
  var Lune = /** @class */ (function (_super) {
      __extends$6(Lune, _super);
      function Lune(points) {
          var _this = _super.call(this, DrawType.LUNE, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      Lune.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          var pnts = this.getPoints();
          if (this.getPointCount() === 2) {
              var mid = middle(pnts[0], pnts[1]);
              var d = distance$1(pnts[0], mid);
              var pnt = getThirdPoint(pnts[0], mid, Constants.HALF_PI, d, false);
              pnts.push(pnt);
          }
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var pnt3 = pnts[2];
          var center = getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
          var radius = distance$1(pnt1, center);
          var angle1 = getAzimuth(pnt1, center);
          var angle2 = getAzimuth(pnt2, center);
          var startAngle = angle1;
          var endAngle = angle2;
          if (isClockWise(pnt1, pnt2, pnt3)) {
              startAngle = angle2;
              endAngle = angle1;
          }
          var _points = getArcPoints(center, radius, startAngle, endAngle);
          _points.push(pnts[0]);
          this.setCoordinates([_points]);
      };
      return Lune;
  }(Geometry));

  /**
   * 扇形扩展类
   * huhongxun
   */
  var Sector = /** @class */ (function (_super) {
      __extends$6(Sector, _super);
      function Sector(points) {
          var _this = _super.call(this, DrawType.SECTOR, points) || this;
          _this.fixPointCount = 3;
          return _this;
      }
      Sector.prototype.generate = function () {
          if (this.getPointCount() < 2)
              return;
          if (this.getPointCount() === 2)
              this.setCoordinates([this.getPoints()]);
          else {
              var pnts = this.getPoints();
              var center = pnts[0];
              var pnt2 = pnts[1];
              var pnt3 = pnts[2];
              var radius = distance$1(pnt2, center);
              var startAngle = getAzimuth(pnt2, center);
              var endAngle = getAzimuth(pnt3, center);
              var pList = getArcPoints(center, radius, startAngle, endAngle);
              pList.push(center, pList[0]);
              this.setCoordinates([pList]);
          }
      };
      return Sector;
  }(Geometry));

  /**
   * 聚集地扩展类
   * 胡红勋
   */
  var GatheringPlace = /** @class */ (function (_super) {
      __extends$6(GatheringPlace, _super);
      function GatheringPlace(points) {
          var _this = _super.call(this, DrawType.GATHERING_PLACE, points) || this;
          _this._t = 0.4;
          _this.fixPointCount = 3;
          return _this;
      }
      GatheringPlace.prototype.generate = function () {
          var pnts = this.getPoints();
          if (pnts.length < 2) {
              return;
          }
          if (this.getPointCount() === 2) {
              var mid = middle(pnts[0], pnts[1]);
              var d = distance$1(pnts[0], mid) / 0.9;
              var pnt = getThirdPoint(pnts[0], mid, Constants.HALF_PI, d, true);
              pnts = [pnts[0], pnt, pnts[1]];
          }
          var middle$1 = middle(pnts[0], pnts[2]);
          pnts.push(middle$1, pnts[0], pnts[1]);
          var normals = [];
          for (var i = 0; i < pnts.length - 2; i++) {
              var pnt1 = pnts[i];
              var pnt2 = pnts[i + 1];
              var pnt3 = pnts[i + 2];
              var normalPoints = getBisectorNormals(this._t, pnt1, pnt2, pnt3);
              normals = normals.concat(normalPoints);
          }
          var count = normals.length;
          normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
          var pList = [];
          for (var i = 0; i < pnts.length - 2; i++) {
              var pnt1 = pnts[i];
              var pnt2 = pnts[i + 1];
              pList.push(pnt1);
              for (var t = 0; t <= Constants.FITTING_COUNT; t++) {
                  var pnt = getCubicValue(t / Constants.FITTING_COUNT, pnt1, normals[i * 2], normals[i * 2 + 1], pnt2);
                  pList.push(pnt);
              }
              pList.push(pnt2);
          }
          this.setCoordinates([pList]);
      };
      return GatheringPlace;
  }(Geometry));

  /**
   * 直线箭头扩展类
   * 胡红勋
   */
  var StraightArrow = /** @class */ (function (_super) {
      __extends$6(StraightArrow, _super);
      function StraightArrow(points) {
          var _this = _super.call(this, DrawType.STRAIGHT_ARROW, points) || this;
          _this._maxArrowLength = 3000000;
          _this._arrowLengthScale = 40;
          _this.fixPointCount = 2;
          return _this;
      }
      StraightArrow.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          var pnts = this.getPoints();
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var distance = distance$1(pnt1, pnt2);
          var len = distance / this._arrowLengthScale;
          len = len > this._maxArrowLength ? this._maxArrowLength : len;
          var leftPnt = getThirdPoint(pnt1, pnt2, Math.PI / 5, len, false);
          var rightPnt = getThirdPoint(pnt1, pnt2, Math.PI / 5, len, true);
          this.setCoordinates([pnt1, pnt2, leftPnt, pnt2, rightPnt]);
      };
      return StraightArrow;
  }(Geometry));

  /**
   * 单箭头扩展类
   * 胡红勋
   */
  var FineArrow = /** @class */ (function (_super) {
      __extends$6(FineArrow, _super);
      function FineArrow(points) {
          var _this = _super.call(this, DrawType.FINE_ARROW, points) || this;
          _this._tailWidthFactor = 0.15;
          _this._neckWidthFactor = 0.2;
          _this._headWidthFactor = 0.25;
          _this._headAngle = Math.PI / 8.5;
          _this._neckAngle = Math.PI / 13;
          _this.fixPointCount = 2;
          return _this;
      }
      Object.defineProperty(FineArrow.prototype, "neckWidthFactor", {
          get: function () {
              return this._neckWidthFactor;
          },
          set: function (count) {
              this._neckWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "headWidthFactor", {
          get: function () {
              return this._headWidthFactor;
          },
          set: function (count) {
              this._headWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "headAngle", {
          get: function () {
              return this._headAngle;
          },
          set: function (count) {
              this._headAngle = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "neckAngle", {
          get: function () {
              return this._neckAngle;
          },
          set: function (count) {
              this._neckAngle = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(FineArrow.prototype, "tailWidthFactor", {
          get: function () {
              return this._tailWidthFactor;
          },
          set: function (count) {
              this._tailWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      FineArrow.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var pnt1 = pnts[0];
          var pnt2 = pnts[1];
          var len = getBaseLength(pnts);
          var tailWidth = len * this._tailWidthFactor;
          var neckWidth = len * this._neckWidthFactor;
          var headWidth = len * this._headWidthFactor;
          var tailLeft = getThirdPoint(pnt2, pnt1, Constants.HALF_PI, tailWidth, true);
          var tailRight = getThirdPoint(pnt2, pnt1, Constants.HALF_PI, tailWidth, false);
          var headLeft = getThirdPoint(pnt1, pnt2, this._headAngle, headWidth, false);
          var headRight = getThirdPoint(pnt1, pnt2, this._headAngle, headWidth, true);
          var neckLeft = getThirdPoint(pnt1, pnt2, this._neckAngle, neckWidth, false);
          var neckRight = getThirdPoint(pnt1, pnt2, this._neckAngle, neckWidth, true);
          var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];
          this.setCoordinates([pList]);
      };
      return FineArrow;
  }(Geometry));

  /**
   * 方向箭头扩展类
   * 胡红勋
   */
  var AssaultDirection = /** @class */ (function (_super) {
      __extends$6(AssaultDirection, _super);
      function AssaultDirection(points) {
          var _this = _super.call(this, points) || this;
          _this.type = DrawType.ASSAULT_DIRECTION;
          _this.tailWidthFactor = 0.2;
          _this.neckWidthFactor = 0.25;
          _this.headWidthFactor = 0.3;
          _this.headAngle = Math.PI / 4;
          _this.neckAngle = Math.PI * 0.17741;
          return _this;
      }
      return AssaultDirection;
  }(FineArrow));

  /**
   * 攻击箭头类扩展
   * huhongxun
   */
  var AttackArrow = /** @class */ (function (_super) {
      __extends$6(AttackArrow, _super);
      function AttackArrow(points) {
          var _this = _super.call(this, DrawType.ATTACK_ARROW, points) || this;
          _this._headHeightFactor = 0.18;
          _this._headWidthFactor = 0.3;
          _this._neckHeightFactor = 0.85;
          _this._neckWidthFactor = 0.15;
          _this._headTailFactor = 0.8;
          return _this;
      }
      Object.defineProperty(AttackArrow.prototype, "headHeightFactor", {
          get: function () {
              return this._headHeightFactor;
          },
          set: function (count) {
              this._headHeightFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "headWidthFactor", {
          get: function () {
              return this._headWidthFactor;
          },
          set: function (count) {
              this._headWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "neckHeightFactor", {
          get: function () {
              return this._neckHeightFactor;
          },
          set: function (count) {
              this._neckHeightFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "neckWidthFactor", {
          get: function () {
              return this._neckWidthFactor;
          },
          set: function (count) {
              this._neckWidthFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(AttackArrow.prototype, "headTailFactor", {
          get: function () {
              return this._headTailFactor;
          },
          set: function (count) {
              this._headTailFactor = count;
          },
          enumerable: false,
          configurable: true
      });
      AttackArrow.prototype.generate = function () {
          if (this.getPointCount() < 2) {
              return;
          }
          if (this.getPointCount() === 2) {
              this.setCoordinates([this.getPoints()]);
              return;
          }
          var pnts = this.getPoints();
          // 计算箭尾
          var tailLeft = pnts[0];
          var tailRight = pnts[1];
          if (isClockWise(pnts[0], pnts[1], pnts[2])) {
              tailLeft = pnts[1];
              tailRight = pnts[0];
          }
          var midTail = middle(tailLeft, tailRight);
          var bonePnts = [midTail].concat(pnts.slice(2));
          // 计算箭头
          var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var tailWidthFactor = distance$1(tailLeft, tailRight) / getBaseLength(bonePnts);
          // 计算箭身
          var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
          // 整合
          var count = bodyPnts.length;
          var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse());
          this.setCoordinates([coords]);
      };
      AttackArrow.prototype.getArrowHeadPoints = function (points, tailLeft, tailRight) {
          var len = getBaseLength(points);
          var headHeight = len * this._headHeightFactor;
          var headPnt = points[points.length - 1];
          len = distance$1(headPnt, points[points.length - 2]);
          var tailWidth = distance$1(tailLeft, tailRight);
          if (headHeight > tailWidth * this._headTailFactor) {
              headHeight = tailWidth * this._headTailFactor;
          }
          var headWidth = headHeight * this._headWidthFactor;
          var neckWidth = headHeight * this._neckWidthFactor;
          headHeight = headHeight > len ? len : headHeight;
          var neckHeight = headHeight * this._neckHeightFactor;
          var headEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
          var neckEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
          var headLeft = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, false);
          var headRight = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, true);
          var neckLeft = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, false);
          var neckRight = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, true);
          return [neckLeft, headLeft, headPnt, headRight, neckRight];
      };
      AttackArrow.prototype.getArrowBodyPoints = function (points, neckLeft, neckRight, tailWidthFactor) {
          var allLen = wholeDistance(points);
          var len = getBaseLength(points);
          var tailWidth = len * tailWidthFactor;
          var neckWidth = distance$1(neckLeft, neckRight);
          var widthDif = (tailWidth - neckWidth) / 2;
          var tempLen = 0;
          var leftBodyPnts = [];
          var rightBodyPnts = [];
          for (var i = 1; i < points.length - 1; i++) {
              var angle = getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
              tempLen += distance$1(points[i - 1], points[i]);
              var w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
              var left = getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
              var right = getThirdPoint(points[i - 1], points[i], angle, w, false);
              leftBodyPnts.push(left);
              rightBodyPnts.push(right);
          }
          return leftBodyPnts.concat(rightBodyPnts);
      };
      return AttackArrow;
  }(Geometry));

  /**
   * 双箭头类扩展
   * 胡红勋
   */
  var DoubleArrow = /** @class */ (function (_super) {
      __extends$6(DoubleArrow, _super);
      function DoubleArrow(points) {
          var _this = _super.call(this, DrawType.DOUBLE_ARROW, points) || this;
          _this._connPoint = null;
          _this._tempPoint4 = null;
          _this.fixPointCount = 4;
          _this._headHeightFactor = 0.25;
          _this._headWidthFactor = 0.3;
          _this._neckHeightFactor = 0.85;
          _this._neckWidthFactor = 0.15;
          return _this;
      }
      DoubleArrow.prototype.finishDrawing = function () {
          if (this.getPointCount() === 3 && this._tempPoint4 !== null)
              this.getPoints().push(this._tempPoint4);
          if (this._connPoint !== null)
              this.getPoints().push(this._connPoint);
      };
      DoubleArrow.prototype.generate = function () {
          var count = this.getPointCount();
          var _points = this.getPoints();
          if (count < 2) {
              return;
          }
          if (count === 2) {
              this.setCoordinates([_points]);
              return;
          }
          var pnt1 = _points[0];
          var pnt2 = _points[1];
          var pnt3 = _points[2];
          if (count === 3) {
              this._tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
          }
          else {
              this._tempPoint4 = _points[3];
          }
          if (count === 3 || count === 4) {
              this._connPoint = middle(pnt1, pnt2);
          }
          else {
              this._connPoint = _points[4];
          }
          var leftArrowPnts, rightArrowPnts;
          if (isClockWise(pnt1, pnt2, pnt3)) {
              leftArrowPnts = this.getArrowPoints(pnt1, this._connPoint, this._tempPoint4, false);
              rightArrowPnts = this.getArrowPoints(this._connPoint, pnt2, pnt3, true);
          }
          else {
              leftArrowPnts = this.getArrowPoints(pnt2, this._connPoint, pnt3, false);
              rightArrowPnts = this.getArrowPoints(this._connPoint, pnt1, this._tempPoint4, true);
          }
          var m = leftArrowPnts.length;
          var t = (m - 5) / 2;
          var llBodyPnts = leftArrowPnts.slice(0, t);
          var lArrowPnts = leftArrowPnts.slice(t, t + 5);
          var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
          var rlBodyPnts = rightArrowPnts.slice(0, t);
          var rArrowPnts = rightArrowPnts.slice(t, t + 5);
          var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
          rlBodyPnts = getBezierPoints(rlBodyPnts);
          var bodyPnts = getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
          lrBodyPnts = getBezierPoints(lrBodyPnts);
          var pnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);
          this.setCoordinates([pnts]);
      };
      DoubleArrow.prototype.getArrowPoints = function (pnt1, pnt2, pnt3, clockWise) {
          var midPnt = middle(pnt1, pnt2);
          var len = distance$1(midPnt, pnt3);
          var midPnt1 = getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
          var midPnt2 = getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
          //var midPnt3=PlotUtils.getThirdPoint(pnt3, midPnt, 0, len * 0.7, true);
          midPnt1 = getThirdPoint(midPnt, midPnt1, Constants.HALF_PI, len / 5, clockWise);
          midPnt2 = getThirdPoint(midPnt, midPnt2, Constants.HALF_PI, len / 4, clockWise);
          //midPnt3=PlotUtils.getThirdPoint(midPnt, midPnt3, Constants.HALF_PI, len / 5, clockWise);
          var points = [midPnt, midPnt1, midPnt2, pnt3];
          // 计算箭头部分
          var arrowPnts = this.getArrowHeadPoints(points, this._headHeightFactor || 0.25, this._headWidthFactor || 0.3);
          var neckLeftPoint = arrowPnts[0];
          var neckRightPoint = arrowPnts[4];
          // 计算箭身部分
          var tailWidthFactor = distance$1(pnt1, pnt2) / getBaseLength(points) / 2;
          var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
          var n = bodyPnts.length;
          var lPoints = bodyPnts.slice(0, n / 2);
          var rPoints = bodyPnts.slice(n / 2, n);
          lPoints.push(neckLeftPoint);
          rPoints.push(neckRightPoint);
          lPoints = lPoints.reverse();
          lPoints.push(pnt2);
          rPoints = rPoints.reverse();
          rPoints.push(pnt1);
          return lPoints.reverse().concat(arrowPnts, rPoints);
      };
      DoubleArrow.prototype.getArrowHeadPoints = function (points, tailLeft, tailRight) {
          var len = getBaseLength(points);
          var headHeight = len * (this._headHeightFactor || 0.25);
          var headPnt = points[points.length - 1];
          distance$1(tailLeft, tailRight);
          var headWidth = headHeight * (this._headWidthFactor || 0.3);
          var neckWidth = headHeight * (this._neckWidthFactor || 0.15);
          var neckHeight = headHeight * (this._neckHeightFactor || 0.85);
          var headEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
          var neckEndPnt = getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
          var headLeft = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, false);
          var headRight = getThirdPoint(headPnt, headEndPnt, Constants.HALF_PI, headWidth, true);
          var neckLeft = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, false);
          var neckRight = getThirdPoint(headPnt, neckEndPnt, Constants.HALF_PI, neckWidth, true);
          return [neckLeft, headLeft, headPnt, headRight, neckRight];
      };
      DoubleArrow.prototype.getArrowBodyPoints = function (points, neckLeft, neckRight, tailWidthFactor) {
          var allLen = wholeDistance(points);
          var len = getBaseLength(points);
          var tailWidth = len * tailWidthFactor;
          var neckWidth = distance$1(neckLeft, neckRight);
          var widthDif = (tailWidth - neckWidth) / 2;
          var tempLen = 0;
          var leftBodyPnts = [];
          var rightBodyPnts = [];
          for (var i = 1; i < points.length - 1; i++) {
              var angle = getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
              tempLen += distance$1(points[i - 1], points[i]);
              var w = (tailWidth / 2 - (tempLen / allLen) * widthDif) / Math.sin(angle);
              var left = getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
              var right = getThirdPoint(points[i - 1], points[i], angle, w, false);
              leftBodyPnts.push(left);
              rightBodyPnts.push(right);
          }
          return leftBodyPnts.concat(rightBodyPnts);
      };
      // 计算对称点
      DoubleArrow.prototype.getTempPoint4 = function (linePnt1, linePnt2, point) {
          var midPnt = middle(linePnt1, linePnt2);
          var len = distance$1(midPnt, point);
          var angle = getAngleOfThreePoints(linePnt1, midPnt, point);
          var symPnt, distance1, distance2, mid;
          if (angle < Constants.HALF_PI) {
              distance1 = len * Math.sin(angle);
              distance2 = len * Math.cos(angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, false);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, true);
          }
          else if (angle >= Constants.HALF_PI && angle < Math.PI) {
              distance1 = len * Math.sin(Math.PI - angle);
              distance2 = len * Math.cos(Math.PI - angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, false);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, false);
          }
          else if (angle >= Math.PI && angle < Math.PI * 1.5) {
              distance1 = len * Math.sin(angle - Math.PI);
              distance2 = len * Math.cos(angle - Math.PI);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, true);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, true);
          }
          else {
              distance1 = len * Math.sin(Math.PI * 2 - angle);
              distance2 = len * Math.cos(Math.PI * 2 - angle);
              mid = getThirdPoint(linePnt1, midPnt, Constants.HALF_PI, distance1, true);
              symPnt = getThirdPoint(midPnt, mid, Constants.HALF_PI, distance2, false);
          }
          return symPnt;
      };
      return DoubleArrow;
  }(Geometry));

  /**
   * 攻击箭头扩展类
   * 胡红勋
   */
  var SquadCombat = /** @class */ (function (_super) {
      __extends$6(SquadCombat, _super);
      function SquadCombat(points) {
          var _this = _super.call(this, points) || this;
          _this._tailWidthFactor = 0.1;
          _this.headHeightFactor = 0.18;
          _this.headWidthFactor = 0.3;
          _this.neckHeightFactor = 0.85;
          _this.neckWidthFactor = 0.15;
          _this.type = DrawType.SQUAD_COMBAT;
          return _this;
      }
      SquadCombat.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var tailPnts = this.getTailPoints(pnts);
          var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this._tailWidthFactor);
          count = bodyPnts.length;
          var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse());
          this.setCoordinates([coords]);
      };
      SquadCombat.prototype.getTailPoints = function (points) {
          var allLen = getBaseLength(points);
          var tailWidth = allLen * this._tailWidthFactor;
          var tailLeft = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, false);
          var tailRight = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, true);
          return [tailLeft, tailRight];
      };
      return SquadCombat;
  }(AttackArrow));

  /**
   * 攻击箭头扩展类
   * huhongxun
   */
  var TailedSquadCombat = /** @class */ (function (_super) {
      __extends$6(TailedSquadCombat, _super);
      function TailedSquadCombat(points) {
          var _this = _super.call(this, points) || this;
          _this._tailWidthFactor = 0.1;
          _this._swallowTailFactor = 1;
          _this.type = DrawType.TAILED_SQUAD_COMBAT;
          _this.headHeightFactor = 0.18;
          _this.headWidthFactor = 0.3;
          _this.neckHeightFactor = 0.85;
          _this.neckWidthFactor = 0.15;
          return _this;
      }
      TailedSquadCombat.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          var pnts = this.getPoints();
          var tailPnts = this.getTailPoints(pnts);
          var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
          var neckLeft = headPnts[0];
          var neckRight = headPnts[4];
          var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this._tailWidthFactor);
          count = bodyPnts.length;
          var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, count / 2));
          leftPnts.push(neckLeft);
          var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(count / 2, count));
          rightPnts.push(neckRight);
          leftPnts = getQBSplinePoints(leftPnts);
          rightPnts = getQBSplinePoints(rightPnts);
          var coords = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);
          this.setCoordinates([coords]);
      };
      TailedSquadCombat.prototype.getTailPoints = function (points) {
          var allLen = getBaseLength(points);
          var tailWidth = allLen * this._tailWidthFactor;
          var tailLeft = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, false);
          var tailRight = getThirdPoint(points[1], points[0], Constants.HALF_PI, tailWidth, true);
          var len = tailWidth * this._swallowTailFactor;
          var swallowTailPnt = getThirdPoint(points[1], points[0], 0, len, true);
          return [tailLeft, swallowTailPnt, tailRight];
      };
      return TailedSquadCombat;
  }(AttackArrow));

  /**
   * 军事标绘多变形扩展类
   * huhongxun
   */
  var Polygon = /** @class */ (function (_super) {
      __extends$6(Polygon, _super);
      function Polygon(points) {
          return _super.call(this, DrawType.POLYGON, points) || this;
      }
      Polygon.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          this.setCoordinates([this.getPoints()]);
      };
      return Polygon;
  }(Geometry));

  /**
   * huhongxun
   * 标记类
   *
   */
  var Marker = /** @class */ (function (_super) {
      __extends$6(Marker, _super);
      function Marker(points) {
          var _this = _super.call(this, DrawType.POINT, points) || this;
          _this.fixPointCount = 1;
          return _this;
      }
      Marker.prototype.generate = function () {
          var pnt = this.getPoints()[0];
          this.setCoordinates(pnt);
      };
      return Marker;
  }(Geometry));

  /**
   * 矩形类扩展类
   * huhongxun

   */
  var Rectangle = /** @class */ (function (_super) {
      __extends$6(Rectangle, _super);
      function Rectangle(points) {
          var _this = _super.call(this, DrawType.RECTANGLE, points) || this;
          _this.fixPointCount = 2;
          return _this;
      }
      Rectangle.prototype.generate = function () {
          var count = this.getPointCount();
          if (count < 2) {
              return;
          }
          else {
              var pnt1 = this.getPoints()[0];
              var pnt2 = this.getPoints()[1];
              var xmin = Math.min(pnt1[0], pnt2[0]);
              var xmax = Math.max(pnt1[0], pnt2[0]);
              var ymin = Math.min(pnt1[1], pnt2[1]);
              var ymax = Math.max(pnt1[1], pnt2[1]);
              var tl = [xmin, ymax];
              var tr = [xmax, ymax];
              var br = [xmax, ymin];
              var bl = [xmin, ymin];
              this.setCoordinates([[tl, tr, br, bl, tl]]);
          }
      };
      return Rectangle;
  }(Geometry));

  /**
   * huhongxun
   * 线的扩展类
   */
  var Polyline = /** @class */ (function (_super) {
      __extends$6(Polyline, _super);
      function Polyline(points) {
          return _super.call(this, DrawType.POLYLINE, points) || this;
      }
      Polyline.prototype.generate = function () {
          var count = this.getPointCount();
          if (count <= 1) {
              return;
          }
          this.setCoordinates(this.getPoints());
      };
      return Polyline;
  }(Geometry));

  /**
   * huhongxun 军事标绘的工厂方法---
   * @param {*} type  标绘类型---
   * @param {*} points  点数组
   */
  function createDraw(type, points) {
      switch (type) {
          case DrawType.ARC:
              return new Arc(points);
          case DrawType.ELLIPSE:
              return new Ellipse(points);
          case DrawType.CURVE:
              return new Curve(points);
          case DrawType.CLOSED_CURVE:
              return new ClosedCurve(points);
          case DrawType.LUNE:
              return new Lune(points);
          case DrawType.SECTOR:
              return new Sector(points);
          case DrawType.GATHERING_PLACE:
              return new GatheringPlace(points);
          case DrawType.STRAIGHT_ARROW:
              return new StraightArrow(points);
          case DrawType.ASSAULT_DIRECTION:
              return new AssaultDirection(points);
          case DrawType.ATTACK_ARROW:
              return new AttackArrow(points);
          case DrawType.FINE_ARROW:
              return new FineArrow(points);
          case DrawType.DOUBLE_ARROW:
              return new DoubleArrow(points);
          case DrawType.SQUAD_COMBAT:
              return new SquadCombat(points);
          case DrawType.TAILED_SQUAD_COMBAT:
              return new TailedSquadCombat(points);
          case DrawType.POLYGON:
              return new Polygon(points);
          case DrawType.POINT:
              return new Marker(points);
          case DrawType.RECTANGLE:
              return new Rectangle(points);
          case DrawType.POLYLINE:
              return new Polyline(points);
          case DrawType.CIRCLE:
              return new Circle$1(points);
      }
      return null;
  }

  /**
   * 组件基础类
   *
   * 此为基类,不可实例化
   *
   */
  var Component = /** @class */ (function (_super) {
      __extends$6(Component, _super);
      function Component(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           * @private
           */
          _this._initialized = false;
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Component.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化组件
       *
       * @ignore
       */
      Component.prototype.init = function () {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      /**
       * 添加到地球
       *
       * @ignore
       */
      Component.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this._initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Component.prototype.remove = function (destroy) {
          throw new Error(ErrorNotification.NOT_IMPLEMENTED);
      };
      return Component;
  }(BaseObject$1));

  /**
   * @module ol/events/EventType
   */
  /**
   * @enum {string}
   * @const
   */
  var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: 'change',
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: 'error',
      BLUR: 'blur',
      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      FOCUS: 'focus',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      RESIZE: 'resize',
      TOUCHMOVE: 'touchmove',
      WHEEL: 'wheel',
  };

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var MapBrowserEventType = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/util
   */
  /**
   * Counter for getUid.
   * @type {number}
   * @private
   */
  var uidCounter_ = 0;
  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. Unique IDs are generated
   * as a strictly increasing sequence. Adapted from goog.getUid.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {string} The unique ID for the object.
   * @api
   */
  function getUid(obj) {
      return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }
  /**
   * OpenLayers version.
   * @type {string}
   */
  var VERSION = '6.5.1-beta.6';

  var __extends$5 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Error object thrown when an assertion failed. This is an ECMA-262 Error,
   * extended with a `code` property.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
   */
  var AssertionError = /** @class */ (function (_super) {
      __extends$5(AssertionError, _super);
      /**
       * @param {number} code Error code.
       */
      function AssertionError(code) {
          var _this = this;
          var path = 'v' + VERSION.split('-')[0];
          var message = 'Assertion failed. See https://openlayers.org/en/' +
              path +
              '/doc/errors/#' +
              code +
              ' for details.';
          _this = _super.call(this, message) || this;
          /**
           * Error code. The meaning of the code can be found on
           * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
           * the version found in the OpenLayers script's header comment if a version
           * other than the latest is used).
           * @type {number}
           * @api
           */
          _this.code = code;
          /**
           * @type {string}
           */
          _this.name = 'AssertionError';
          // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
          _this.message = message;
          return _this;
      }
      return AssertionError;
  }(Error));
  var AssertionError$1 = AssertionError;

  /**
   * @module ol/events/Event
   */
  /**
   * @classdesc
   * Stripped down implementation of the W3C DOM Level 2 Event interface.
   * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
   *
   * This implementation only provides `type` and `target` properties, and
   * `stopPropagation` and `preventDefault` methods. It is meant as base class
   * for higher level events defined in the library, and works with
   * {@link module:ol/events/Target~Target}.
   */
  var BaseEvent = /** @class */ (function () {
      /**
       * @param {string} type Type.
       */
      function BaseEvent(type) {
          /**
           * @type {boolean}
           */
          this.propagationStopped;
          /**
           * The event type.
           * @type {string}
           * @api
           */
          this.type = type;
          /**
           * The event target.
           * @type {Object}
           * @api
           */
          this.target = null;
      }
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());
  var Event = BaseEvent;

  /**
   * @module ol/ObjectEventType
   */
  /**
   * @enum {string}
   */
  var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange',
  };

  /**
   * @module ol/Disposable
   */
  /**
   * @classdesc
   * Objects that need to clean up after themselves.
   */
  var Disposable = /** @class */ (function () {
      function Disposable() {
          /**
           * The object has already been disposed.
           * @type {boolean}
           * @protected
           */
          this.disposed = false;
      }
      /**
       * Clean up.
       */
      Disposable.prototype.dispose = function () {
          if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
          }
      };
      /**
       * Extension point for disposable objects.
       * @protected
       */
      Disposable.prototype.disposeInternal = function () { };
      return Disposable;
  }());
  var Disposable$1 = Disposable;

  /**
   * @module ol/functions
   */
  /**
   * A reusable function, used e.g. as a default for callbacks.
   *
   * @return {void} Nothing.
   */
  function VOID() { }

  /**
   * @module ol/obj
   */
  /**
   * Polyfill for Object.assign().  Assigns enumerable and own properties from
   * one or more source objects to a target object.
   * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
   *
   * @param {!Object} target The target object.
   * @param {...Object} var_sources The source object(s).
   * @return {!Object} The modified target object.
   */
  var assign = typeof Object.assign === 'function'
      ? Object.assign
      : function (target, var_sources) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== undefined && source !== null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          output[key] = source[key];
                      }
                  }
              }
          }
          return output;
      };
  /**
   * Removes all properties from an object.
   * @param {Object} object The object to clear.
   */
  function clear$1(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */
  function isEmpty(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }

  var __extends$4 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {EventTarget|Target} EventTargetLike
   */
  /**
   * @classdesc
   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
   * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
   *
   * There are two important simplifications compared to the specification:
   *
   * 1. The handling of `useCapture` in `addEventListener` and
   *    `removeEventListener`. There is no real capture model.
   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
   *    There is no event target hierarchy. When a listener calls
   *    `stopPropagation` or `preventDefault` on an event object, it means that no
   *    more listeners after this one will be called. Same as when the listener
   *    returns false.
   */
  var Target = /** @class */ (function (_super) {
      __extends$4(Target, _super);
      /**
       * @param {*=} opt_target Default event target for dispatched events.
       */
      function Target(opt_target) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {*}
           */
          _this.eventTarget_ = opt_target;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.pendingRemovals_ = null;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.dispatching_ = null;
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").Listener>>}
           */
          _this.listeners_ = null;
          return _this;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.addEventListener = function (type, listener) {
          if (!type || !listener) {
              return;
          }
          var listeners = this.listeners_ || (this.listeners_ = {});
          var listenersForType = listeners[type] || (listeners[type] = []);
          if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
          }
      };
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      Target.prototype.dispatchEvent = function (event) {
          /** @type {import("./Event.js").default|Event} */
          var evt = typeof event === 'string' ? new Event(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this.eventTarget_ || this;
          }
          var listeners = this.listeners_ && this.listeners_[type];
          var propagate;
          if (listeners) {
              var dispatching = this.dispatching_ || (this.dispatching_ = {});
              var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
              if (!(type in dispatching)) {
                  dispatching[type] = 0;
                  pendingRemovals[type] = 0;
              }
              ++dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if ('handleEvent' in listeners[i]) {
                      propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
                  }
                  else {
                      propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
                  }
                  if (propagate === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --dispatching[type];
              if (dispatching[type] === 0) {
                  var pr = pendingRemovals[type];
                  delete pendingRemovals[type];
                  while (pr--) {
                      this.removeEventListener(type, VOID);
                  }
                  delete dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * Clean up.
       */
      Target.prototype.disposeInternal = function () {
          this.listeners_ && clear$1(this.listeners_);
      };
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      Target.prototype.getListeners = function (type) {
          return (this.listeners_ && this.listeners_[type]) || undefined;
      };
      /**
       * @param {string=} opt_type Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      Target.prototype.hasListener = function (opt_type) {
          if (!this.listeners_) {
              return false;
          }
          return opt_type
              ? opt_type in this.listeners_
              : Object.keys(this.listeners_).length > 0;
      };
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.removeEventListener = function (type, listener) {
          var listeners = this.listeners_ && this.listeners_[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                      // make listener a no-op, and remove later in #dispatchEvent()
                      listeners[index] = VOID;
                      ++this.pendingRemovals_[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this.listeners_[type];
                      }
                  }
              }
          }
      };
      return Target;
  }(Disposable$1));
  var EventTarget = Target;

  /**
   * @module ol/events
   */
  /**
   * Key to use with {@link module:ol/Observable~Observable#unByKey}.
   * @typedef {Object} EventsKey
   * @property {ListenerFunction} listener
   * @property {import("./events/Target.js").EventTargetLike} target
   * @property {string} type
   * @api
   */
  /**
   * Listener function. This function is called with an event object as argument.
   * When the function returns `false`, event propagation will stop.
   *
   * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
   * @api
   */
  /**
   * @typedef {Object} ListenerObject
   * @property {ListenerFunction} handleEvent
   */
  /**
   * @typedef {ListenerFunction|ListenerObject} Listener
   */
  /**
   * Registers an event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` to a `this` object, and returns
   * a key for use with {@link module:ol/events~unlistenByKey}.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @param {boolean=} opt_once If true, add the listener as one-off listener.
   * @return {EventsKey} Unique key for the listener.
   */
  function listen(target, type, listener, opt_this, opt_once) {
      if (opt_this && opt_this !== target) {
          listener = listener.bind(opt_this);
      }
      if (opt_once) {
          var originalListener_1 = listener;
          listener = function () {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener,
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  /**
   * Registers a one-off event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` as self-unregistering listener
   * to a `this` object, and returns a key for use with
   * {@link module:ol/events~unlistenByKey} in case the listener needs to be
   * unregistered before it is called.
   *
   * When {@link module:ol/events~listen} is called with the same arguments after this
   * function, the self-unregistering listener will be turned into a permanent
   * listener.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @return {EventsKey} Key for unlistenByKey.
   */
  function listenOnce(target, type, listener, opt_this) {
      return listen(target, type, listener, opt_this, true);
  }
  /**
   * Unregisters event listeners on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * The argument passed to this function is the key returned from
   * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
   *
   * @param {EventsKey} key The key.
   */
  function unlistenByKey(key) {
      if (key && key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clear$1(key);
      }
  }

  var __extends$3 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * An event target providing convenient methods for listener registration
   * and unregistration. A generic `change` event is always available through
   * {@link module:ol/Observable~Observable#changed}.
   *
   * @fires import("./events/Event.js").default
   * @api
   */
  var Observable = /** @class */ (function (_super) {
      __extends$3(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.revision_ = 0;
          return _this;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      Observable.prototype.changed = function () {
          ++this.revision_;
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      Observable.prototype.getRevision = function () {
          return this.revision_;
      };
      /**
       * Listen for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.on = function (type, listener) {
          if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                  keys[i] = listen(this, type[i], listener);
              }
              return keys;
          }
          else {
              return listen(this, /** @type {string} */ (type), listener);
          }
      };
      /**
       * Listen once for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.once = function (type, listener) {
          var key;
          if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                  key[i] = listenOnce(this, type[i], listener);
              }
          }
          else {
              key = listenOnce(this, /** @type {string} */ (type), listener);
          }
          /** @type {Object} */ (listener).ol_key = key;
          return key;
      };
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @api
       */
      Observable.prototype.un = function (type, listener) {
          var key = /** @type {Object} */ (listener).ol_key;
          if (key) {
              unByKey(key);
          }
          else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                  this.removeEventListener(type[i], listener);
              }
          }
          else {
              this.removeEventListener(type, listener);
          }
      };
      return Observable;
  }(EventTarget));
  /**
   * Removes an event listener using the key returned by `on()` or `once()`.
   * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
   *     or `once()` (or an array of keys).
   * @api
   */
  function unByKey(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unlistenByKey(key[i]);
          }
      }
      else {
          unlistenByKey(/** @type {import("./events.js").EventsKey} */ (key));
      }
  }
  var Observable$1 = Observable;

  var __extends$2 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
   */
  var ObjectEvent = /** @class */ (function (_super) {
      __extends$2(ObjectEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          /**
           * The name of the property whose value is changing.
           * @type {string}
           * @api
           */
          _this.key = key;
          /**
           * The old value. To get the new value use `e.target.get(e.key)` where
           * `e` is the event object.
           * @type {*}
           * @api
           */
          _this.oldValue = oldValue;
          return _this;
      }
      return ObjectEvent;
  }(Event));
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Most non-trivial classes inherit from this.
   *
   * This extends {@link module:ol/Observable} with observable
   * properties, where each property is observable as well as the object as a
   * whole.
   *
   * Classes that inherit from this have pre-defined properties, to which you can
   * add your owns. The pre-defined properties are listed in this documentation as
   * 'Observable Properties', and have their own accessors; for example,
   * {@link module:ol/Map~Map} has a `target` property, accessed with
   * `getTarget()` and changed with `setTarget()`. Not all properties are however
   * settable. There are also general-purpose accessors `get()` and `set()`. For
   * example, `get('target')` is equivalent to `getTarget()`.
   *
   * The `set` accessors trigger a change event, and you can monitor this by
   * registering a listener. For example, {@link module:ol/View~View} has a
   * `center` property, so `view.on('change:center', function(evt) {...});` would
   * call the function whenever the value of the center property changes. Within
   * the function, `evt.target` would be the view, so `evt.target.getCenter()`
   * would return the new center.
   *
   * You can add your own observable properties with
   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
   * You can listen for changes on that property value with
   * `object.on('change:prop', listener)`. You can get a list of all
   * properties with {@link module:ol/Object~BaseObject#getProperties}.
   *
   * Note that the observable properties are separate from standard JS properties.
   * You can, for example, give your map object a title with
   * `map.title='New title'` and with `map.set('title', 'Another title')`. The
   * first will be a `hasOwnProperty`; the second will appear in
   * `getProperties()`. Only the second is observable.
   *
   * Properties can be deleted by using the unset method. E.g.
   * object.unset('foo').
   *
   * @fires ObjectEvent
   * @api
   */
  var BaseObject = /** @class */ (function (_super) {
      __extends$2(BaseObject, _super);
      /**
       * @param {Object<string, *>=} opt_values An object with key-value pairs.
       */
      function BaseObject(opt_values) {
          var _this = _super.call(this) || this;
          // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
          // the same as the order in which they were created.  This also helps to
          // ensure that object properties are always added in the same order, which
          // helps many JavaScript engines generate faster code.
          getUid(_this);
          /**
           * @private
           * @type {Object<string, *>}
           */
          _this.values_ = null;
          if (opt_values !== undefined) {
              _this.setProperties(opt_values);
          }
          return _this;
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      BaseObject.prototype.get = function (key) {
          var value;
          if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
          }
          return value;
      };
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      BaseObject.prototype.getKeys = function () {
          return (this.values_ && Object.keys(this.values_)) || [];
      };
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      BaseObject.prototype.getProperties = function () {
          return (this.values_ && assign({}, this.values_)) || {};
      };
      /**
       * @return {boolean} The object has properties.
       */
      BaseObject.prototype.hasProperties = function () {
          return !!this.values_;
      };
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      BaseObject.prototype.notify = function (key, oldValue) {
          var eventType;
          eventType = getChangeEventType(key);
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
          eventType = ObjectEventType.PROPERTYCHANGE;
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      };
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.set = function (key, value, opt_silent) {
          var values = this.values_ || (this.values_ = {});
          if (opt_silent) {
              values[key] = value;
          }
          else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.setProperties = function (values, opt_silent) {
          for (var key in values) {
              this.set(key, values[key], opt_silent);
          }
      };
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      BaseObject.prototype.applyProperties = function (source) {
          if (!source.values_) {
              return;
          }
          assign(this.values_ || (this.values_ = {}), source.values_);
      };
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean=} opt_silent Unset without triggering an event.
       * @api
       */
      BaseObject.prototype.unset = function (key, opt_silent) {
          if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (isEmpty(this.values_)) {
                  this.values_ = null;
              }
              if (!opt_silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      return BaseObject;
  }(Observable$1));
  /**
   * @type {Object<string, string>}
   */
  var changeEventTypeCache = {};
  /**
   * @param {string} key Key name.
   * @return {string} Change name.
   */
  function getChangeEventType(key) {
      return changeEventTypeCache.hasOwnProperty(key)
          ? changeEventTypeCache[key]
          : (changeEventTypeCache[key] = 'change:' + key);
  }
  var obj = BaseObject;

  /**
   * @module ol/CollectionEventType
   */
  /**
   * @enum {string}
   */
  var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove',
  };

  var __extends$1 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          if (typeof b !== "function" && b !== null)
              throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   * @private
   */
  var Property$1 = {
      LENGTH: 'length',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
   * type.
   */
  var CollectionEvent = /** @class */ (function (_super) {
      __extends$1(CollectionEvent, _super);
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {*=} opt_element Element.
       * @param {number=} opt_index The index of the added or removed element.
       */
      function CollectionEvent(type, opt_element, opt_index) {
          var _this = _super.call(this, type) || this;
          /**
           * The element that is added to or removed from the collection.
           * @type {*}
           * @api
           */
          _this.element = opt_element;
          /**
           * The index of the added or removed element.
           * @type {number}
           * @api
           */
          _this.index = opt_index;
          return _this;
      }
      return CollectionEvent;
  }(Event));
  /**
   * @typedef {Object} Options
   * @property {boolean} [unique=false] Disallow the same item from being added to
   * the collection twice.
   */
  /**
   * @classdesc
   * An expanded version of standard JS Array, adding convenience methods for
   * manipulation. Add and remove changes to the Collection trigger a Collection
   * event. Note that this does not cover changes to the objects _within_ the
   * Collection; they trigger events on the appropriate object, not on the
   * Collection as a whole.
   *
   * @fires CollectionEvent
   *
   * @template T
   * @api
   */
  var Collection = /** @class */ (function (_super) {
      __extends$1(Collection, _super);
      /**
       * @param {Array<T>=} opt_array Array.
       * @param {Options=} opt_options Collection options.
       */
      function Collection(opt_array, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @type {boolean}
           */
          _this.unique_ = !!options.unique;
          /**
           * @private
           * @type {!Array<T>}
           */
          _this.array_ = opt_array ? opt_array : [];
          if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                  _this.assertUnique_(_this.array_[i], i);
              }
          }
          _this.updateLength_();
          return _this;
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      Collection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this.pop();
          }
      };
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      Collection.prototype.extend = function (arr) {
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
          }
          return this;
      };
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      Collection.prototype.forEach = function (f) {
          var array = this.array_;
          for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
          }
      };
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      Collection.prototype.getArray = function () {
          return this.array_;
      };
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      Collection.prototype.item = function (index) {
          return this.array_[index];
      };
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      Collection.prototype.getLength = function () {
          return this.get(Property$1.LENGTH);
      };
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.insertAt = function (index, elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          this.array_.splice(index, 0, elem);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      };
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      Collection.prototype.pop = function () {
          return this.removeAt(this.getLength() - 1);
      };
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      Collection.prototype.push = function (elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          var n = this.getLength();
          this.insertAt(n, elem);
          return this.getLength();
      };
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      Collection.prototype.remove = function (elem) {
          var arr = this.array_;
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                  return this.removeAt(i);
              }
          }
          return undefined;
      };
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      Collection.prototype.removeAt = function (index) {
          var prev = this.array_[index];
          this.array_.splice(index, 1);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
          return prev;
      };
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.setAt = function (index, elem) {
          var n = this.getLength();
          if (index < n) {
              if (this.unique_) {
                  this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          }
          else {
              for (var j = n; j < index; ++j) {
                  this.insertAt(j, undefined);
              }
              this.insertAt(index, elem);
          }
      };
      /**
       * @private
       */
      Collection.prototype.updateLength_ = function () {
          this.set(Property$1.LENGTH, this.array_.length);
      };
      /**
       * @private
       * @param {T} elem Element.
       * @param {number=} opt_except Optional index to ignore.
       */
      Collection.prototype.assertUnique_ = function (elem, opt_except) {
          for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                  throw new AssertionError$1(58);
              }
          }
      };
      return Collection;
  }(obj));
  var Collection$1 = Collection;

  /**
   * @module ol/OverlayPositioning
   */
  /**
   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, `'top-right'`
   * @enum {string}
   */
  var OverlayPositioning = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_CENTER: 'bottom-center',
      BOTTOM_RIGHT: 'bottom-right',
      CENTER_LEFT: 'center-left',
      CENTER_CENTER: 'center-center',
      CENTER_RIGHT: 'center-right',
      TOP_LEFT: 'top-left',
      TOP_CENTER: 'top-center',
      TOP_RIGHT: 'top-right',
  };

  /**
   * 绘制类
   */
  var DrawInner$1 = /** @class */ (function (_super) {
      __extends$6(DrawInner, _super);
      function DrawInner(options, map) {
          return _super.call(this, __assign$1({ snap: true, edit: true, snapTarget: [] }, (options || {})), map) || this;
      }
      Object.defineProperty(DrawInner.prototype, "options", {
          /**
           * 构造器方法
           * @param {*} type
           * @param {*} options
           */
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(DrawInner.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(DrawInner.prototype, "drawing", {
          get: function () {
              return defined$1(this._draw);
          },
          enumerable: false,
          configurable: true
      });
      DrawInner.prototype.init = function () {
          this.initialized = true;
          this._style = this.options.polygonStyle
              ? styleToOlStyleFunction(this.options.polygonStyle)
              : styleToOlStyleFunction(this.options.polylineStyle);
      };
      /**
       * 添加绘制交互的方法------
       * @param {*} type  绘制类型
       * @param {*} active 是否激活
       */
      DrawInner.prototype.addDrawInteractions = function (type) {
          this._type = type;
          var _drawType = "Polygon";
          if (type === DrawType.POLYLINE) {
              _drawType = "LineString";
          }
          // 类型不一致转换
          this._draw = new DrawClass__default["default"](__assign$1({ style: this._style, source: new VectorSource__default["default"](), type: _drawType }, this.options));
          this._draw.setActive(true);
          var _collection = new Collection$1();
          // 添加交互组件到地图中
          this.map.map.addInteraction(this._draw);
          if (this.options.snap) {
              if (this.options.snapTarget.length) {
                  this.options.snapTarget
                      .map(function (_layer) {
                      return _layer.getFeatures();
                  })
                      .flat().forEach(function (f) {
                      _collection.push(f.sourceFeature);
                  });
                  this._snap = new SnapInteraction__default["default"]({ features: _collection });
              }
              else {
                  if (this.options.target) {
                      this._snap = new SnapInteraction__default["default"]({ source: this.options.target.layer[0].getSource() });
                  }
              }
              this._snap && this.map.map.addInteraction(this._snap);
          }
          this.drawendKey_ = this._draw.on("drawend", this.drawEndHandle.bind(this));
          this.drawstartKey_ = this._draw.on("drawstart", this.drawStartHandle.bind(this));
      };
      /**
       * 绘制完成时的回调------
       * @param event
       * @private
       */
      DrawInner.prototype.drawEndHandle = function (evt) {
          var _this = this;
          var feature = evt.feature.clone();
          var type = feature.getGeometry().getType();
          var coordinates;
          var _feature;
          if (type === "Polygon") {
              coordinates = feature.getGeometry().getCoordinates().map(function (coords) {
                  return coords.map(function (coord) {
                      return proj.transform(coord, _this.map.map.getView().getProjection(), PUBLIC_CONFIG.dataProjection);
                  });
              });
              _feature = new Polygon$1({ coordinates: coordinates });
          }
          if (type === "LineString") {
              coordinates = feature.getGeometry().getCoordinates().map(function (coord) {
                  return proj.transform(coord, _this.map.map.getView().getProjection(), PUBLIC_CONFIG.dataProjection);
              });
              _feature = new Polyline$1({ coordinates: coordinates });
          }
          // 属性一致-----
          this.options.target && this.options.target.addFeature(_feature);
          // 要素返回一致
          this.dispatchEvent({
              type: BaseEventType.DRAW_END,
              target: this,
              feature: _feature
          });
      };
      /**
       * 绘制开始时的监听处理--------
       * @param event
       * @private
       */
      DrawInner.prototype.drawStartHandle = function (event) {
          this.dispatchEvent({
              type: BaseEventType.DRAW_START
          });
      };
      /**
       * 移除上一次激活的工具
       * @private
       */
      DrawInner.prototype.deactive = function () {
          if (this._draw) {
              this.drawendKey_ && Observable$3.unByKey(this.drawendKey_);
              this.drawendKey_ = undefined;
              this.drawstartKey_ && Observable$3.unByKey(this.drawstartKey_);
              this.drawstartKey_ = undefined;
              this.map.map.removeInteraction(this._draw);
              this._draw = null;
          }
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
              this._snap = null;
          }
          return this;
      };
      /**
       * 激活或者禁用绘制控件
       * @param {*} flag
       */
      DrawInner.prototype.active = function (type) {
          this.deactive();
          this.addDrawInteractions(type);
          return this;
      };
      DrawInner.prototype.clearAll = function () {
          return this;
      };
      DrawInner.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
          this.initialized = false;
      };
      DrawInner.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy;
      };
      return DrawInner;
  }(Component));

  /**
   * 绘制类
   */
  var Draw$1 = /** @class */ (function (_super) {
      __extends$6(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, edit: true, pointStyle: DRAW_STYLE.point, polygonStyle: DRAW_STYLE.polygon, polylineStyle: DRAW_STYLE.polyline }, (options || {})), map) || this;
          _this._coords = [];
          return _this;
      }
      Object.defineProperty(Draw.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "drawing", {
          get: function () {
              if (defined$1(this._draw)) {
                  return this._draw.drawing;
              }
              else {
                  return this._clickListener ? true : false;
              }
          },
          enumerable: false,
          configurable: true
      });
      Draw.prototype.init = function () {
          this.initialized = true;
          var _element = document.createElement("span");
          _element.className = "mti-measure-tool mti-measure-tool-length";
          _element.innerHTML = "单击地图绘制要素";
          this._messageTip = new Overlay({
              element: _element,
              positioning: Positioning.TOP_LEFT,
              offset: [20, 5]
          });
      };
      Draw.prototype.active = function (type) {
          var _this = this;
          this.deactive();
          this.deactivateMapTools();
          this._type = type;
          this._pointermoveListener = this.map.map.on(MapBrowserEventType.POINTERMOVE, function (event) {
              _this._messageTip.setPosition(transformToDataProjection(event.coordinate));
          });
          if (this._type === DrawType.POLYGON || this._type === DrawType.POLYLINE) {
              if (this._draw) {
                  this.map.removeComponent(this._draw, true);
                  this._draw = undefined;
              }
              var _options = __assign$1({}, this.options);
              if (this._type === DrawType.POLYGON) {
                  delete _options.polylineStyle;
              }
              if (this._type === DrawType.POLYLINE) {
                  delete _options.polygonStyle;
              }
              this._draw = new DrawInner$1(_options, this.map);
              this._draw.active(this._type);
              this._draw.on(BaseEventType.DRAW_END, function (event) {
                  _this._draw.deactive();
                  _this.dispatchEvent({ type: BaseEventType.DRAW_END, feature: event.feature });
                  _this._messageTip.hide();
                  _this._messageTip.element.innerHTML = "<span>单击地图绘制要素</span>";
                  Observable$3.unByKey(_this._pointermoveListener);
              });
          }
          else {
              this._clickListener = this.map.map.on(MapBrowserEventType.CLICK, this.mapFirstClickHandler.bind(this));
          }
          return this;
      };
      Draw.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this._tempLayer = this.options.target || new VectorLayer({ zIndex: 100 });
          if (!this._tempLayer.map) {
              this.map.addLayer(this._tempLayer);
          }
          this.map.addOverlay(this._messageTip);
      };
      Draw.prototype.deactive = function () {
          this.disconnectEventHandlers();
          this._coords = [];
          this._geom = null;
          this._type = null;
          this.activateMapTools();
          this._feature && this._tempLayer.removeFeature(this._feature);
          this._feature = null;
          if (this._draw) {
              this._draw.deactive();
          }
          return this;
      };
      /**
       * 清除全部标绘
       */
      Draw.prototype.clearAll = function () {
          this._tempLayer.clearFeatures();
          return this;
      };
      // 地图首次单击事件监听
      Draw.prototype.mapFirstClickHandler = function (e) {
          this._messageTip.element.innerHTML = "<span>单击继续绘制要素，双击完成要素绘制!</span>";
          this._coords.push(transformToDataProjection(e.coordinate));
          this._geom = createDraw(this.type, this._coords);
          if (this.type === DrawType.CIRCLE) {
              // @ts-ignore
              this._geom.minRadius = this.options.minRadius / 1000 || 50 / 1000;
              // @ts-ignore
              this._geom.maxRadius = this.options.maxRadius / 1000 || Number.MAX_VALUE;
          }
          this._feature = this._creatFeature();
          this._tempLayer.addFeature(this._feature);
          // 取消监听
          Observable$3.unByKey(this._clickListener);
          // 特殊类型几何体需要几个点来插值生成特殊几何体
          if (this._geom.fixPointCount === this._geom.getPointCount()) {
              this.mapDoubleClickHandler(e);
              return;
          }
          // 地图添加单击事件
          this._clicknextListener = this.map.map.on(MapBrowserEventType.CLICK, this.mapNextClickHandler.bind(this));
          // 地图双击事件----
          this._doubleListener = this.map.map.on(MapBrowserEventType.DBLCLICK, this.mapDoubleClickHandler.bind(this));
          this._moveListener = this.map.map.on(MapBrowserEventType.POINTERMOVE, this.mapMouseMoveHandler.bind(this));
      };
      Draw.prototype._creatFeature = function () {
          var _feature;
          if (this.type === DrawType.POINT) {
              var _coordinates = this._geom.coordinates;
              _feature = new Point$1({ coordinates: _coordinates });
              _feature.setStyle(this.options.pointStyle);
          }
          else if (this.type === DrawType.POLYLINE ||
              this.type === DrawType.ARC ||
              this.type === DrawType.CURVE ||
              this.type === DrawType.STRAIGHT_ARROW) {
              _feature = new Polyline$1({ coordinates: [] });
              _feature.setStyle(this.options.polylineStyle);
          }
          else if (this.type === DrawType.CIRCLE) {
              _feature = new Circle({
                  radius: this._geom.ellipsoidRaduis,
                  center: this._geom.center
              });
              _feature.setStyle(this.options.polygonStyle);
          }
          else {
              _feature = new Polygon$1({ coordinates: [] });
              _feature.setStyle(this.options.polygonStyle);
          }
          return _feature;
      };
      Draw.prototype.mapMouseMoveHandler = function (e) {
          var coordinate = transformToDataProjection(e.coordinate);
          if (distance$1(coordinate, this._coords[this._coords.length - 1]) > Constants.ZERO_TOLERANCE) {
              this._geom.setPoints(this._coords.concat([coordinate]).slice(0));
              if (this.type === DrawType.CIRCLE) {
                  this._feature.setRadius(this._geom.ellipsoidRaduis * 1000);
              }
              else {
                  this._feature.setCoordinates(this._geom.coordinates);
              }
          }
      };
      Draw.prototype.mapNextClickHandler = function (e) {
          var coordinate = transformToDataProjection(e.coordinate);
          var distance = distance$1(coordinate, this._coords[this._coords.length - 1]);
          if (distance > Constants.ZERO_TOLERANCE) {
              this._coords.push(coordinate);
              this._geom.setPoints(this._coords);
              if (this.type === DrawType.CIRCLE) {
                  this._feature.setRadius(this._geom.ellipsoidRaduis * 1000);
              }
              else {
                  this._feature.setCoordinates(this._geom.coordinates);
              }
              if (this._geom.fixPointCount === this._geom.getPointCount()) {
                  // 结束绘制----销毁资源
                  this.mapDoubleClickHandler(e);
                  return;
              }
          }
      };
      Draw.prototype.mapDoubleClickHandler = function (e) {
          if (this._geom.finishDrawing) {
              this._geom.finishDrawing();
          }
          e.preventDefault();
          this.drawEnd();
      };
      Draw.prototype.disconnectEventHandlers = function () {
          this._clickListener && Observable$3.unByKey(this._clickListener);
          this._clickListener = void 0;
          this._clicknextListener && Observable$3.unByKey(this._clicknextListener);
          this._pointermoveListener && Observable$3.unByKey(this._pointermoveListener);
          this._doubleListener && Observable$3.unByKey(this._doubleListener);
          this._moveListener && Observable$3.unByKey(this._moveListener);
          this._messageTip.hide();
          this._messageTip.element.innerHTML = "<span>单击地图绘制要素</span>";
      };
      Draw.prototype.drawEnd = function () {
          var _this = this;
          window.setTimeout(function () {
              _this.activateMapTools();
          }, 500);
          this.disconnectEventHandlers();
          if (this.type === DrawType.POLYLINE || this.type === DrawType.POLYGON || this.type === DrawType.POINT) {
              this._feature.set("isPlot", false);
              this._feature.setProperties({ isPlot: false });
          }
          else {
              this._feature.set("isPlot", true);
              this._feature.set("plot", this._coords);
              this._feature.set("plotType", this.type);
              this._feature.setProperties({ plot: this._coords, plotType: this.type, isPlot: true });
          }
          this._coords = [];
          this._geom = null;
          this._type = null;
          this.options.target === undefined && this._tempLayer.removeFeature(this._feature);
          this._feature.setStyle(undefined);
          //图层添加到图层
          this.dispatchEvent({ type: BaseEventType.DRAW_END, feature: this._feature });
          /**
           *  添加圆逻辑
           */
          this._feature = null;
      };
      Draw.prototype.deactivateMapTools = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DoubleClickZoom__default["default"]) {
                  this._dblClickZoomInteraction = item;
                  interactions.remove(item);
                  break;
              }
          }
      };
      Draw.prototype.activateMapTools = function () {
          if (defined$1(this._dblClickZoomInteraction)) {
              this.map.map.getInteractions().push(this._dblClickZoomInteraction);
              this._dblClickZoomInteraction = null;
          }
      };
      Draw.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.disconnectEventHandlers();
          this._coords = [];
          this._geom = null;
          this._type = null;
          this._feature && this._tempLayer.removeFeature(this._feature);
          this.options.target === undefined && this.map.removeLayer(this._tempLayer);
          this._tempLayer = undefined;
          this._feature = null;
          this._draw && this.map.removeComponent(this._draw);
          this._draw = undefined;
          this.map = undefined;
      };
      Draw.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Draw;
  }(Component));

  /** @class */ ((function (_super) {
      __extends$6(CircleSearch, _super);
      function CircleSearch(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(CircleSearch.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "minRadius", {
          /**
           * 可拖拽的最小半径  单位: 米
           */
          get: function () {
              return this._minRadius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "maxRadius", {
          /**
           * 可拖拽的最大半径  单位: 米
           */
          get: function () {
              return this._maxRadius;
          },
          enumerable: false,
          configurable: true
      });
      CircleSearch.prototype.init = function () {
          var _a = this.options, infoPopup = _a.infoPopup, step = _a.step, _b = _a.minRadius, minRadius = _b === void 0 ? 5 : _b, maxRadius = _a.maxRadius;
          defined$1(this.minRadius) || this.setMinRadius(minRadius);
          defined$1(this.maxRadius) || this.setMaxRadius(maxRadius);
          this._eventKeys = [];
          this._step = step || 1;
          this._dragging = false;
          this._hovering = false;
          this.initialized = true;
          this._layer = new VectorLayer({});
          this._infoPopup = infoPopup;
      };
      CircleSearch.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          defined$1(this._infoPopup) && this.map.addOverlay(this._infoPopup);
      };
      CircleSearch.prototype.active = function (feature) {
          var _this = this;
          this.deactive();
          if (feature instanceof Circle) {
              this._active(feature);
          }
          else if (this.map) {
              this._draw = new Draw$1({}, this.map).active(DrawType.CIRCLE);
              this._draw.once(BaseEventType.DRAW_END, function (_a) {
                  var feature = _a.feature; _a.target;
                  _this._active(feature);
                  _this.dispatchEvent({
                      type: BaseEventType.EDIT_END,
                      radius: feature.radius,
                      center: feature.center,
                      dragPointCoordinate: _this._dragPoint.coordinates
                  });
                  window.setTimeout(function () {
                      _this._removeDraw();
                  });
              });
          }
          return this;
      };
      CircleSearch.prototype._initEvent = function () {
          var mapElement = this.map.map.getViewport();
          this._eventKeys.push(this.map.map.on("pointermove", pointerMoveHandler$1.bind(this)));
          this._eventKeys.push(listen$1(mapElement, "mouseup", pointerUpHandler$1, this));
          this._eventKeys.push(listen$1(mapElement, "mousedown", pointerDownHandler$1, this));
      };
      CircleSearch.prototype._clearEvent = function () {
          this.unByKey(this._eventKeys);
          this._eventKeys.length = 0;
      };
      CircleSearch.prototype._initFeatures = function (feature) {
          var _a;
          var centerCoordinates = feature.center;
          var radius = feature.radius;
          var dragPointCoordinates = transformToDataProjection(Turf__namespace.transformTranslate(feature.geoJson, radius / 1000, 90).geometry.coordinates, WGS84_PROJECTION_NAME);
          var _b = this.options, linkedLineStyle = _b.linkedLineStyle, centerPointStyle = _b.centerPointStyle, dragPointStyle = _b.dragPointStyle, circleStyle = _b.circleStyle;
          this._circle = new Circle({ center: centerCoordinates, radius: radius });
          this._circle.setStyle(circleStyle || CIRCLE_SEARCH_STYLE.circle);
          this._layer.addFeature(this._circle);
          this._centerPoint = new Point$1({ coordinates: centerCoordinates });
          this._centerPoint.setStyle(centerPointStyle || CIRCLE_SEARCH_STYLE.centerPoint);
          this._layer.addFeature(this._centerPoint);
          this._linkedLine = new Polyline$1({ coordinates: [centerCoordinates, dragPointCoordinates] });
          this._linkedLine.setStyle(linkedLineStyle || CIRCLE_SEARCH_STYLE.linkedLine);
          this._layer.addFeature(this._linkedLine);
          this._dragPoint = new Point$1({ coordinates: dragPointCoordinates });
          this._dragPoint.setStyle(dragPointStyle || CIRCLE_SEARCH_STYLE.dragPoint);
          this._layer.addFeature(this._dragPoint);
          (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(dragPointCoordinates);
      };
      CircleSearch.prototype._active = function (feature) {
          this._initEvent();
          this._initFeatures(feature);
      };
      CircleSearch.prototype._clearFeatures = function () {
          this._layer.clearFeatures();
          this._centerPoint = this._linkedLine = this._dragPoint = this._circle = void 0;
      };
      CircleSearch.prototype._removeDraw = function () {
          if (this._draw) {
              this.map.removeComponent(this._draw, true);
              this._draw = void 0;
          }
      };
      CircleSearch.prototype.deactive = function () {
          if (this._infoPopup) {
              this._infoPopup.setPosition();
          }
          this._removeDraw();
          this._clearFeatures();
          this._clearEvent();
          return this;
      };
      /**
       * 禁用地图平移交互组件
       */
      CircleSearch.prototype._disableMapDragPan = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DragPan__default["default"]) {
                  this._mapDragPan = item;
                  item.setActive(false);
                  break;
              }
          }
      };
      /**
       * 启用地图平移拖拽交互组件
       */
      CircleSearch.prototype._enableMapDragPan = function () {
          if (defined$1(this._mapDragPan)) {
              this._mapDragPan.setActive(true);
              this._mapDragPan = void 0;
          }
      };
      CircleSearch.prototype.setCircleRadius = function (radius) {
          if (typeof radius === "number" &&
              radius >= this.minRadius &&
              (!defined$1(this.maxRadius) || radius <= this.maxRadius)) {
              changeCircleRadius$1.call(this, radius);
          }
          return this;
      };
      CircleSearch.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._infoPopup);
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      CircleSearch.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          this._infoPopup = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置可拖拽的最小半径  单位: 米
       */
      CircleSearch.prototype.setMinRadius = function (radius) {
          this._minRadius = radius;
          return this;
      };
      /**
       * 设置可拖拽的最大半径  单位: 米
       */
      CircleSearch.prototype.setMaxRadius = function (radius) {
          this._maxRadius = radius;
          return this;
      };
      return CircleSearch;
  })(Component));
  function pointerDownHandler$1(e) {
      if (this._hovering) {
          this._disableMapDragPan();
          this._dragging = true;
      }
  }
  function pointerUpHandler$1() {
      this.map.map.getViewport().style.cursor = "";
      if (this._dragging) {
          this._hovering = false;
          this._dragging = false;
          this._enableMapDragPan();
          this.dispatchEvent({
              type: BaseEventType.EDIT_END,
              radius: this._circle.radius,
              center: this._circle.center,
              dragPointCoordinate: this._dragPoint.coordinates
          });
      }
  }
  function pointerMoveHandler$1(e) {
      var _this = this;
      var feature = this.map.map.forEachFeatureAtPixel(e.pixel, function (olFeature) {
          return olFeature === _this._dragPoint.sourceFeature;
      }, {
          layerFilter: function (olLayer) {
              return olLayer === _this._layer.layer[0];
          }
      });
      if (defined$1(feature)) {
          this._hovering = true;
          this.map.map.getViewport().style.cursor = "move";
      }
      else if (!this._dragging) {
          this._hovering = false;
          this.map.map.getViewport().style.cursor = "";
      }
      if (this._dragging) {
          var coordinate = transformInternal(this.map.map.getCoordinateFromPixel(e.pixel), {
              source: PUBLIC_CONFIG.projection,
              destination: WGS84_PROJECTION_NAME
          });
          var center = transformInternal(this._circle.center, {
              destination: WGS84_PROJECTION_NAME,
              source: this._circle.dataProjection
          });
          var newR = Turf__namespace.distance(center, coordinate) * 1000;
          if (this._step) {
              newR = newR - (newR % this._step);
          }
          if (!(newR >= this.minRadius && (!defined$1(this.maxRadius) || newR <= this.maxRadius))) {
              return;
          }
          changeCircleRadius$1.call(this, newR);
      }
  }
  function changeCircleRadius$1(radius) {
      var _a;
      if (this._circle.radius === radius) {
          return;
      }
      var newDragCoordinates = Turf__namespace.transformTranslate(this._circle.geoJson, radius / 1000, 90).geometry
          .coordinates;
      this._circle.setRadius(radius);
      this._dragPoint.setCoordinates(newDragCoordinates);
      this._linkedLine.setCoordinates([this._circle.center, newDragCoordinates]);
      (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(newDragCoordinates);
      this.dispatchEvent({
          type: BaseEventType.RADIUS_CHANGE,
          radius: radius,
          center: this._circle.center,
          dragPointCoordinate: this._dragPoint.coordinates
      });
  }

  /** @class */ ((function (_super) {
      __extends$6(HistoryTrack, _super);
      function HistoryTrack(options, map) {
          var _this = _super.call(this, options, map) || this;
          _this.setLoop(options.loop || false);
          _this.setVelocity(options.velocity || 1);
          _this.setTrack(options.track || false);
          _this._duration = options.duration;
          _this._paused = false;
          return _this;
      }
      Object.defineProperty(HistoryTrack.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "loop", {
          get: function () {
              return this._loop;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "velocity", {
          get: function () {
              return this._velocity;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "track", {
          get: function () {
              return this._track;
          },
          enumerable: false,
          configurable: true
      });
      HistoryTrack.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({});
          var _a = this.options, pathCoordinates = _a.path, targetStyle = _a.targetStyle, pathStyle = _a.pathStyle, originStyle = _a.originStyle, destinationStyle = _a.destinationStyle;
          this._pathGeoJsonFeature = Array.isArray(pathCoordinates) ? lineString(pathCoordinates) : pathCoordinates;
          this._pathCoordinates = this._pathGeoJsonFeature.geometry.coordinates;
          this._pathDistance = Turf__namespace.length(this._pathGeoJsonFeature) * 1000;
          if (pathStyle) {
              this._path = new Polyline$1({ coordinates: this._pathCoordinates });
              this._path.setStyle(pathStyle);
              this._layer.addFeature(this._path);
          }
          if (originStyle) {
              this._origin = new Point$1({ coordinates: this._pathCoordinates[0] });
              this._origin.setStyle(originStyle);
              this._layer.addFeature(this._origin);
          }
          if (destinationStyle) {
              this._destination = new Point$1({ coordinates: this._pathCoordinates[this._pathCoordinates.length - 1] });
              this._destination.setStyle(destinationStyle);
              this._layer.addFeature(this._destination);
          }
          this._target = new Point$1({ coordinates: this._pathCoordinates[0] });
          this._target.setStyle(targetStyle);
          this._layer.addFeature(this._target);
      };
      HistoryTrack.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      HistoryTrack.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._clearEvent();
          this._reset();
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      HistoryTrack.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._pathCoordinates =
              this._target =
                  this._origin =
                      this._path =
                          this._destination =
                              this._layer =
                                  this._pathGeoJsonFeature =
                                      void 0;
          _super.prototype._destroy.call(this);
      };
      HistoryTrack.prototype._initEvent = function () {
          var _this = this;
          var previousTime = performance.now();
          var olStyleList = this._target.sourceFeature.getStyleFunction()(this._target.sourceFeature, this.map.map.getView().getResolution()).filter(function (s) { return s.getImage() instanceof OlIcon__default["default"] && s.getImage()[ICON_ROTATED]; });
          this._eventKey = this.map.map.on("postrender", function (e) {
              if (!_this._paused) {
                  var rate = void 0;
                  if (defined$1(_this._duration)) {
                      _this._time += (performance.now() - previousTime) / 1000;
                      rate = _this._time / _this._duration;
                  }
                  else {
                      _this._distance += ((performance.now() - previousTime) / 1000) * _this.velocity;
                      rate = _this._distance / _this._pathDistance;
                  }
                  rate = rate >= 1 ? 1 : rate;
                  var slicedLineFeature = Turf__namespace.lineSliceAlong(_this._pathGeoJsonFeature, 0, (_this._pathDistance * rate) / 1000);
                  var newPointCoordinate = slicedLineFeature.geometry.coordinates[slicedLineFeature.geometry.coordinates.length - 1];
                  if (_this.track) {
                      _this.map.setCenter(newPointCoordinate);
                  }
                  var rotation_1 = computeRotationRadians(slicedLineFeature.geometry.coordinates[slicedLineFeature.geometry.coordinates.length - 2], newPointCoordinate) -
                      Math.PI * 0.5;
                  olStyleList.forEach(function (i) {
                      i.getImage().setRotation(i.getImage()[ORIGINAL_ROTATION] + rotation_1);
                  });
                  _this._target.setCoordinates(newPointCoordinate);
                  _this.dispatchEvent({
                      type: BaseEventType.MOVE,
                      progress: rate,
                      position: newPointCoordinate
                  });
                  if (rate >= 1) {
                      if (!_this.loop) {
                          _this._clearEvent();
                          _this.dispatchEvent({
                              type: BaseEventType.MOVE_END,
                              progress: rate,
                              position: newPointCoordinate
                          });
                      }
                      else {
                          _this._reset();
                      }
                      return;
                  }
              }
              previousTime = performance.now();
              _this._triggerRender();
          });
      };
      HistoryTrack.prototype._triggerRender = function () {
          this._layer.layer[0].changed();
      };
      HistoryTrack.prototype._clearEvent = function () {
          if (this._eventKey) {
              this.unByKey(this._eventKey);
              this._eventKey = void 0;
          }
      };
      HistoryTrack.prototype._reset = function () {
          this._time = this._distance = 0;
          this._target.setCoordinates(this._pathCoordinates[0]);
          this.resume();
      };
      HistoryTrack.prototype.start = function () {
          if (this._eventKey) {
              return this;
          }
          this._reset();
          this._clearEvent();
          this._initEvent();
          this._triggerRender();
          return this;
      };
      HistoryTrack.prototype.pause = function () {
          this._paused = true;
          return this;
      };
      HistoryTrack.prototype.resume = function () {
          this._paused = false;
          return this;
      };
      HistoryTrack.prototype.stop = function () {
          this._reset();
          this._clearEvent();
          return this;
      };
      HistoryTrack.prototype.setLoop = function (loop) {
          this._loop = loop;
          return this;
      };
      HistoryTrack.prototype.setVelocity = function (velocity) {
          this._velocity = velocity;
          return this;
      };
      HistoryTrack.prototype.setTrack = function (track) {
          this._track = track;
          return this;
      };
      return HistoryTrack;
  })(Component));

  /**
   * 创建元素
   * @param tagName
   * @param className
   * @param container
   * @param id
   * @returns {HTMLElement}
   */
  var create$4 = function (tagName, className, container, id) {
      var el = document.createElement(tagName);
      if (id)
          el.id = id;
      if (className)
          addClass(el, className);
      if (container) {
          container.appendChild(el);
      }
      return el;
  };
  /**
   * 创建隐藏元素---并添加到don结构中
   * @param tagName
   * @param parent
   * @param id
   * @returns {HTMLElement}
   */
  var createHidden = function (tagName, parent, id) {
      var element = document.createElement(tagName);
      element.style.display = "none";
      if (id) {
          element.id = id;
      }
      if (parent) {
          parent.appendChild(element);
      }
      return element;
  };
  /**
   * 检查元素是否含有某类名-----
   * @param el
   * @param cls
   * @returns {boolean}
   */
  var hasClass = function (el, cls) {
      if (!el || !cls)
          return false;
      if (cls.indexOf(" ") !== -1)
          throw new Error("className should not contain space.");
      if (el.classList) {
          return el.classList.contains(cls);
      }
      else {
          return (" " + el.className + " ").indexOf(" " + cls + " ") > -1;
      }
  };
  /**
   * 为元素添加类名------
   * @param el
   * @param cls
   */
  var addClass = function (el, cls) {
      if (!el)
          return;
      var curClass = el.className;
      var classes = (cls || "").split(" ");
      for (var i = 0, j = classes.length; i < j; i++) {
          var clsName = classes[i];
          if (!clsName)
              continue;
          if (el.classList) {
              el.classList.add(clsName);
          }
          else if (!hasClass(el, clsName)) {
              curClass += " " + clsName;
          }
      }
      if (!el.classList) {
          el.className = curClass;
      }
  };
  var get$1 = function (id) {
      return document.getElementById(id);
  };
  var stamp = function (obj) {
      var key = "_event_id_";
      obj[key] = obj[key] || getUid$2();
      return obj[key];
  };
  /**
   * 获取事件唯一标识
   * @param type
   * @param fn
   * @param context
   * @returns {string}
   */
  var getDomEventKey = function (type, fn, context) {
      return "_dom_event_" + type + "_" + stamp(fn) + (context ? "_" + stamp(context) : "");
  };
  /**
   * 对DOM对象添加事件监听
   * @param element
   * @param type
   * @param fn
   * @param context
   * @param isOnce
   * @returns {*}
   */
  var addListener = function (element, type, fn, context, isOnce) {
      var eventKey = getDomEventKey(type, fn, context);
      var handler = element[eventKey];
      if (handler) {
          if (!isOnce) {
              handler.callOnce = false;
          }
          return this;
      }
      handler = function (e) {
          return fn.call(context || element, e);
      };
      if ("addEventListener" in element) {
          element.addEventListener(type, handler, false);
      }
      else if ("attachEvent" in element) {
          element.attachEvent("on" + type, handler);
      }
      element[eventKey] = handler;
      return this;
  };
  var on = addListener;
  /**
   * 移除DOM对象监听事件
   * @param element
   * @param type
   * @param fn
   * @param context
   * @returns {removeListener}
   */
  var removeListener = function (element, type, fn, context) {
      var eventKey = getDomEventKey(type, fn, context);
      var handler = element[eventKey];
      if (!handler) {
          return this;
      }
      if ("removeEventListener" in element) {
          element.removeEventListener(type, handler, false);
      }
      else if ("detachEvent" in element) {
          element.detachEvent("on" + type, handler);
      }
      element[eventKey] = null;
      return this;
  };
  var off = removeListener;

  /**
   * 编辑军事组件
   */
  var PlotEdit$1 = /** @class */ (function (_super) {
      __extends$6(PlotEdit, _super);
      function PlotEdit(map) {
          var _this = _super.call(this, {}, map) || this;
          _this._elementTable = {};
          _this._activeControlPointId = null;
          _this._mapDragPan = null;
          return _this;
      }
      Object.defineProperty(PlotEdit.prototype, "isActive", {
          get: function () {
              return defined$1(this._feature);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PlotEdit.prototype, "minRadius", {
          set: function (val) {
              this._minRadius = val / 1000;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PlotEdit.prototype, "maxRadius", {
          set: function (val) {
              this._maxRadius = val / 1000;
          },
          enumerable: false,
          configurable: true
      });
      PlotEdit.prototype.init = function () {
          this.initialized = true;
          this._mapViewport = this.map.map.getViewport();
      };
      /**
       * 地图容器所属的父容器----
       */
      PlotEdit.prototype.getMapParentElement = function () {
          var mapElement = this.map.map.getTargetElement();
          return mapElement.parentNode;
      };
      PlotEdit.prototype.initHelperDom = function () {
          if (!this.map || !this._feature) {
              return;
          }
          var parent = this.getMapParentElement();
          if (!parent) {
              return;
          }
          // 创建隐藏div
          var hiddenDiv = createHidden("div", parent, "p-helper-hidden-div");
          var cPnts = this.getControlPoints();
          for (var i = 0; i < cPnts.length; i++) {
              var id = PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i;
              create$4("div", PlotEdit.HELPER_CONTROL_POINT_DIV, hiddenDiv, id);
              this._elementTable[id] = i;
          }
      };
      /**
       * 释放资源------销毁所有的overlay覆盖物，以及释放overlay的事件监听----
       */
      PlotEdit.prototype.destroyHelperDom = function () {
          if (this._controlPoints) {
              for (var i = 0; i < this._controlPoints.length; i++) {
                  // 删除overlay 覆盖物----
                  this.map.removeOverlay(this._controlPoints[i]);
                  var element = get$1(PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i);
                  if (element) {
                      off(element, "mousedown", this._controlPointMouseDownHandler, this);
                      off(element, "mousemove", this._controlPointMouseMoveHandler, this);
                  }
              }
              this._controlPoints = [];
          }
          var parent = this.getMapParentElement();
          var hiddenDiv = get$1(PlotEdit.HELPER_CONTROL_POINT_DIV);
          if (hiddenDiv && parent) {
              parent.removeChild(hiddenDiv);
          }
      };
      // 初始化控制点-----添加overlay,并添加事件-----
      PlotEdit.prototype.initControlPoints = function () {
          if (!this.map) {
              return;
          }
          this._controlPoints = [];
          var cPnts = this.getControlPoints();
          for (var i = 0; i < cPnts.length; i++) {
              var id = PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i;
              var element = get$1(id);
              var pnt = new Overlay({
                  positioning: Positioning.CENTER_CENTER,
                  id: id,
                  position: cPnts[i],
                  element: element
              });
              this._controlPoints.push(pnt);
              this.map.addOverlay(pnt);
              on(element, "mousedown", this._controlPointMouseDownHandler, this, false);
              on(element, "mousemove", this._controlPointMouseMoveHandler, this, false);
          }
      };
      /**
       * 编辑控制点的鼠标移动
       * @param e
       */
      PlotEdit.prototype._controlPointMouseMoveHandler = function (e) {
          e.stopImmediatePropagation();
      };
      PlotEdit.prototype._controlPointMouseDownHandler = function (e) {
          var id = e.target.id;
          this._activeControlPointId = id;
          on(this._mapViewport, "mousemove", this._mapViewportMouseMoveHandler, this, false);
          on(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this, false);
          this.dispatchEvent({ type: "modifystart", feature: this._feature });
      };
      PlotEdit.prototype._mapViewportMouseMoveHandler = function (e) {
          var coordinate = transformToDataProjection(this.map.map.getCoordinateFromPixel([e.offsetX, e.offsetY]));
          if (this._activeControlPointId) {
              var index = this._elementTable[this._activeControlPointId];
              var _raduis = this._feature.get("plot").ellipsoidRaduis;
              this._feature.get("plot").updatePoint(coordinate, index);
              if (this._feature.type === FeatureType.CIRCLE) {
                  if (index === 0) {
                      var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(this._feature.get("plot").center), _raduis, 90).geometry.coordinates;
                      this._feature.get("plot").updatePoint(dragPointCoordinates, index + 1);
                      this._controlPoints[0].setPosition(this._feature.get("plot").getPoints()[0]);
                      this._controlPoints[1].setPosition(this._feature.get("plot").getPoints()[1]);
                      this._feature.setCenter(this._feature.get("plot").center);
                  }
                  else {
                      var center = this._feature.center;
                      var _radius = calculatesRadius(center, coordinate);
                      if (_radius <= this._minRadius) {
                          coordinate = Turf__namespace.transformTranslate(Turf__namespace.point(center), this._minRadius, 90).geometry
                              .coordinates;
                          this._feature.get("plot").updatePoint(coordinate, index);
                      }
                      if (_radius >= this._maxRadius) {
                          coordinate = Turf__namespace.transformTranslate(Turf__namespace.point(center), this._maxRadius, 90).geometry
                              .coordinates;
                          this._feature.get("plot").updatePoint(coordinate, index);
                      }
                      this._feature.setRadius(this._feature.get("plot").ellipsoidRaduis * 1000);
                  }
              }
              else {
                  this._feature.setCoordinates(this._feature.get("plot").coordinates);
              }
              var overlay = this.map.getOverlay(this._activeControlPointId);
              overlay.setPosition(coordinate);
          }
      };
      PlotEdit.prototype._mapViewportMouseUpHandler = function (e) {
          off(this._mapViewport, "mousemove", this._mapViewportMouseMoveHandler, this);
          off(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this);
          this.dispatchEvent({ type: "modifyend", feature: this._feature });
      };
      /**
       * 激活编辑控件------
       * @param {*} plot 军事标绘实例
       */
      PlotEdit.prototype.active = function (feature) {
          if (feature === this._feature) {
              return;
          }
          this.deactive();
          // 保存示例
          this._feature = feature;
          if (this._feature.type === FeatureType.CIRCLE) {
              var center = this._feature.center;
              var radius = this._feature.radius / 1000;
              var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(center), radius, 90).geometry
                  .coordinates;
              this._feature.set("plot", createDraw(DrawType.CIRCLE, [center, dragPointCoordinates]));
              //在这做处理---圆可以反算
          }
          // 初始化dom元素点
          this.initHelperDom();
          // 初始化控件点
          this.initControlPoints();
          return this;
      };
      // 获取几何图形的控制点--
      PlotEdit.prototype.getControlPoints = function () {
          if (!this._feature) {
              return [];
          }
          var _coords = this._feature.get("plot").getPoints().slice();
          return _coords;
      };
      // 注销所有的事件监听器------
      PlotEdit.prototype.disconnectEventHandlers = function () {
          off(this._mapViewport, "mouseover", this._mapViewportMouseMoveHandler, this);
          off(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this);
      };
      // 销毁并释放资源---
      PlotEdit.prototype.deactive = function () {
          this._feature = null;
          this._mouseOver = false;
          this.destroyHelperDom();
          this.disconnectEventHandlers();
          this._elementTable = {};
          this._activeControlPointId = null;
          return this;
      };
      // 禁用拖拽平移交互组件---
      PlotEdit.prototype.disableMapDragPan = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DragPan__default["default"]) {
                  this._mapDragPan = item;
                  item.setActive(false);
                  break;
              }
          }
      };
      // 启用地图平移拖拽交互组件-----
      PlotEdit.prototype.enableMapDragPan = function () {
          if (this._mapDragPan !== null) {
              this._mapDragPan.setActive(true);
              this._mapDragPan = null;
          }
      };
      PlotEdit.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          this.deactive();
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = undefined;
      };
      PlotEdit.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
          this._mapViewport = undefined;
      };
      PlotEdit.HELPER_HIDDEN_DIV = "p-helper-hidden-div";
      PlotEdit.HELPER_CONTROL_POINT_DIV = "p-helper-control-point-div";
      return PlotEdit;
  }(Component));

  /**
   * 编辑类------huhongxun
   */
  /** @class */ ((function (_super) {
      __extends$6(Edit, _super);
      function Edit(options, map) {
          var _this = this;
          var baseOptions = __assign$1({}, (options || {}));
          if (baseOptions.target) {
              if (!Array.isArray(baseOptions.target)) {
                  baseOptions.target = [baseOptions.target];
              }
          }
          _this = _super.call(this, __assign$1({ snap: true, minRadius: 50, maxRadius: Number.MAX_VALUE }, baseOptions)) || this;
          _this._collection = new Collection$1();
          options.condition && (_this._conditionFunc = options.condition);
          _this._targetEventKeys = [];
          if (map) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Edit.prototype, "edit", {
          get: function () {
              return this._edit;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Edit.prototype, "isActive", {
          get: function () {
              if (defined$1(this._edit)) {
                  if (this._edit.constructor === Modify__default["default"]) {
                      return true;
                  }
                  else {
                      return this._edit.isActive;
                  }
              }
              else {
                  return false;
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Edit.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       *
       * @param feature    * 激活编辑组件
       * 二维可选，三维必传，二维如果编辑军事要素要素必传，
       * @returns
       */
      Edit.prototype.active = function (feature) {
          if (!defined$1(this.map)) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          this.deactive();
          if (defined$1(feature)) {
              if (feature.get("isPlot")) {
                  if (Array.isArray(feature.get("plot")) && defined$1(feature.get("plotType"))) {
                      feature.set("plot", createDraw(feature.get("plotType"), feature.get("plot")));
                  }
                  this._edit = new PlotEdit$1(this.map);
                  this._edit.minRadius = this.options.minRadius;
                  this._edit.maxRadius = this.options.maxRadius;
                  this._edit.active(feature);
                  this._eventStartKey = this.edit.on("modifystart", this._editStartHandle.bind(this));
                  this._eventEndKey = this.edit.on("modifyend", this._editEndHandle.bind(this));
              }
              else {
                  var collection = new Collection$1([feature.sourceFeature]);
                  this._addEditInteractions(collection);
              }
          }
          else {
              this._addEditInteractions();
          }
          return this;
      };
      Edit.prototype.addFeatures = function (features) {
          var _this = this;
          features.map(function (f) {
              _this._collection.push(f.sourceFeature);
          });
      };
      Edit.prototype.removeFeatures = function (features) {
          var _this = this;
          features.map(function (f) {
              _this._collection.remove(f.sourceFeature);
          });
      };
      Edit.prototype.deactive = function () {
          if (this.isActive) {
              if (this._edit.constructor === Modify__default["default"]) {
                  this._removeLastInteraction();
              }
              else {
                  this.map.removeComponent(this._edit);
                  this._edit = void 0;
              }
              this._eventEndKey && Observable$3.unByKey(this._eventEndKey);
              this._eventStartKey && Observable$3.unByKey(this._eventStartKey);
              this._eventEndKey = undefined;
              this._eventStartKey = undefined;
          }
          return this;
      };
      Edit.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          this._style = new OlStyle__default["default"]();
          var _styles = this.options.editStyle || EDIT_STYLE;
          this._style.setImage(new CircleStyle__default["default"]({
              radius: _styles[0].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[0].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[0].strokeColor }, _styles[0]))
          }));
          this._style.setText(new Text__default["default"](__assign$1({ text: _styles[1].text }, _styles[1])));
          this._style.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[2].borderColor }, _styles[2])));
          this._style.setFill(new Fill__default["default"]({ color: _styles[3].fillColor }));
          this.options.target &&
              this.options.target
                  .map(function (_layer) {
                  var _a;
                  (_a = _this._targetEventKeys).push.apply(_a, __spreadArray$1([], __read(_layer.on([BaseEventType.ADD_FEATURE, BaseEventType.REMOVE_FEATURE], _this._updateFeature.bind(_this))), false));
                  return _layer.getFeatures();
              })
                  .flat().forEach(function (f) {
                  _this._collection.push(f.sourceFeature);
              });
      };
      Edit.prototype._updateFeature = function (event) {
          var type = event.type;
          var feature = event.feature;
          if (type === BaseEventType.ADD_FEATURE) {
              this._collection.push(feature.sourceFeature);
          }
          if (type === BaseEventType.REMOVE_FEATURE) {
              this._collection.remove(feature.sourceFeature);
          }
      };
      Edit.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
      };
      Edit.prototype._destroy = function () {
          this.remove();
          this._targetEventKeys.length && this.unByKey(this._targetEventKeys);
          this._targetEventKeys = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 编辑开始时的监听处理--------
       * @param event
       * @private
       */
      Edit.prototype._editStartHandle = function (event) {
          var feature = event.feature || event.features.item(0);
          var _feature;
          if (feature instanceof Feature) {
              _feature = feature;
          }
          else {
              _feature = feature[FEATURE_LINK];
              this._originFeatures = this._collection.getArray().map(function (f) {
                  return { id: getUid(f), version: f.getRevision() };
              });
          }
          this.dispatchEvent({ type: BaseEventType.EDIT_START, feature: _feature });
      };
      /**
       * 编辑完成时的回调------
       * @param event
       * @private
       */
      Edit.prototype._editEndHandle = function (event) {
          var _this = this;
          var feature = event.feature || event.features.item(0);
          var _feature;
          var features = [];
          var _geojson = new Geojson__default["default"]();
          if (feature instanceof Feature) {
              _feature = feature;
          }
          else {
              this._collection.forEach(function (f) {
                  _this._originFeatures.forEach(function (_f) {
                      if (getUid(f) === _f.id && f.getRevision() !== _f.version) {
                          var vector = f[FEATURE_LINK];
                          var _coordinates = _geojson.writeFeatureObject(f, {
                              dataProjection: vector.dataProjection,
                              featureProjection: vector.projection
                          }).geometry.coordinates;
                          vector.setCoordinates(_coordinates, { update: false });
                          features.push(vector);
                      }
                  });
              });
              _feature = feature[FEATURE_LINK];
          }
          this.dispatchEvent({ type: BaseEventType.EDIT_END, feature: _feature, features: features });
      };
      Edit.prototype._removeLastInteraction = function () {
          if (this._edit) {
              this.map.map.removeInteraction(this._edit);
              this._edit = null;
          }
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
              this._snap = null;
          }
      };
      Edit.prototype._addEditInteractions = function (collection) {
          if (collection) {
              this._edit = new Modify__default["default"]({
                  condition: this._conditionFunc,
                  insertVertexCondition: this._conditionFunc,
                  features: collection,
                  style: this._style
              });
          }
          else {
              this._edit = new Modify__default["default"]({
                  condition: this._conditionFunc,
                  insertVertexCondition: this._conditionFunc,
                  features: this._collection,
                  style: this._style
              });
          }
          // 添加交互组件到地图中
          this.map.map.addInteraction(this._edit);
          // 绘制组件的事件监听----
          this._eventStartKey = this.edit.on("modifystart", this._editStartHandle.bind(this));
          this._eventEndKey = this.edit.on("modifyend", this._editEndHandle.bind(this));
          // 是否捕捉----
          if (this.options.snap) {
              if (this.options.target) {
                  this._snap = new SnapInteraction__default["default"]({ features: this._collection });
                  this.map.map.addInteraction(this._snap);
              }
          }
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成 | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Edit;
  })(Component));

  /**
   * 测量类型
   *
   * @enum {number}
   */
  var MeasureType;
  (function (MeasureType) {
      MeasureType["DISTANCE"] = "distance";
      MeasureType["AREA"] = "area";
  })(MeasureType || (MeasureType = {}));

  /**
   * 测量工具类
   */
  var MeasureInteraction$1 = /** @class */ (function (_super) {
      __extends$6(MeasureInteraction, _super);
      // 构造函数---
      function MeasureInteraction(options) {
          var _this = _super.call(this) || this;
          /**
           * 是否自由绘制--
           * @type {boolean}
           */
          _this._freehand = false;
          /**
           * 当前矢量图层，绘制所在的客户端图层---
           * @type {null}
           */
          _this._layer = null;
          /**
           * 交互工具
           * @type {null}
           */
          _this._draw = null;
          /**
           * 工具是否激活
           * @type {boolean}
           */
          _this._isActive = false;
          /**
           * 点击计数器
           * @type {string}
           */
          _this._clickCount = "";
          /**
           * 双击放大交互
           * @type {*}
           */
          _this._doubleClickZoom = null;
          _this._uuids = [];
          _this._layerName = "measure-layer";
          var _styles = options.measureStyle;
          _this._drawStyle = new OlStyle__default["default"]();
          _this._drawStyle.setImage(new CircleStyle__default["default"]({
              radius: _styles[0].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[0].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[0].strokeColor }, _styles[0]))
          }));
          _this._drawStyle.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[1].borderColor }, _styles[1])));
          _this._drawStyle.setFill(new Fill__default["default"]({ color: _styles[2].fillColor }));
          _this._finishStyle = new OlStyle__default["default"]();
          _this._finishStyle.setImage(new CircleStyle__default["default"]({
              radius: _styles[3].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[3].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[3].strokeColor }, _styles[0]))
          }));
          _this._finishStyle.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[4].borderColor }, _styles[4])));
          _this._finishStyle.setFill(new Fill__default["default"]({ color: _styles[5].fillColor }));
          return _this;
      }
      MeasureInteraction.prototype.handleEvent = function (mapBrowserEvent) {
          if (this.getTool()) {
              if (!this._drawStart && !mapBrowserEvent.dragging) {
                  this.beforeDrawPointClickHandler(mapBrowserEvent);
              }
              else if (this._drawStart && !mapBrowserEvent.dragging) {
                  this.afterDrawPointClickHandler(mapBrowserEvent);
              }
              else if (this._freehand && this._drawStart && mapBrowserEvent.dragging) {
                  this.afterDragHandler_(mapBrowserEvent);
              }
          }
          return true;
      };
      /**
       * 添加绘制交互组件-----
       * @param type
       */
      MeasureInteraction.prototype.addDrawInteractions_ = function (type) {
          var _type;
          if (type === MeasureType.DISTANCE) {
              _type = "LineString";
          }
          if (type === MeasureType.AREA) {
              _type = "Polygon";
          }
          this._draw = new DrawClass__default["default"]({
              type: _type,
              style: this._drawStyle,
              freehand: this._freehand
          });
          var uniqueKey = getUid$2();
          this._draw.set("uuid", uniqueKey);
          this._uuids.push(uniqueKey);
          // 添加交互组件到地图中
          this.getMap().addInteraction(this._draw);
          // 绘制组件的事件监听----
          this._drawstartListener = this._draw.on("drawstart", this.drawStartHandle_.bind(this));
          this._drawendListener = this._draw.on("drawend", this.drawEndHandle_.bind(this));
          // 距离测量标起点
          if (_type === "LineString" && !this._freehand) {
              this._clickListener = this.getMap().on("singleclick", this.drawClickHandle_.bind(this));
          }
      };
      /**
       * 单击事件处理
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawClickHandle_ = function (event) {
          if (this._drawStart && !event.dragging) {
              if (!this._clickCount) {
                  this._clickCount = getUid$2();
                  this._draw.set("measureResult", "起点");
              }
              this.addMeasureOverlay(event.coordinate, this._draw.get("measureResult") || "0.0 平方公里");
          }
      };
      /**
       * 绘制开始时的监听处理--------
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawStartHandle_ = function (event) {
          var _this = this;
          this._drawStart = true;
          event.feature.getGeometry().on("change", function (evt) {
              var geom = evt.target;
              if (geom instanceof LineString__default["default"]) {
                  var output = _this.formatData(geom);
                  _this._draw.set("measureResult", output);
              }
              else if (geom instanceof Polygon__default["default"]) {
                  var area = _this.formatData(geom);
                  _this._draw.set("measureResult", area);
              }
              else if (geom instanceof OLCircleGeom__default["default"]) {
                  var area = _this.formatData(geom);
                  _this._draw.set("measureResult", area);
              }
          });
      };
      /**
       * 绘制完成时的回调------
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawEndHandle_ = function (event) {
          var feature = event.feature;
          feature.set("uuid", this._draw.get("uuid"));
          this._layer.getSource().addFeature(feature);
          var coordinates = feature.getGeometry().getLastCoordinate();
          if (MeasureType.DISTANCE === this._type) {
              this.addMeasureOverlay(coordinates, this._draw.get("measureResult"), "length");
          }
          if (MeasureType.AREA === this._type) {
              // const center = extent.getCenter(feature.getGeometry().getExtent());
              this.addMeasureOverlay(coordinates, this._draw.get("measureResult"), "area");
          }
          this.addMeasureRemoveButton(coordinates);
          this.removeLastInteraction_();
          this.dispatchEvent(BaseEventType.MEASURE_END);
      };
      /**
       * 点击之前的帮助信息
       * @param event
       */
      MeasureInteraction.prototype.beforeDrawPointClickHandler = function (event) {
          if (!this._measureHelpTooltip && this.getTool()) {
              var helpTooltipElement = document.createElement("span");
              if (MeasureType.DISTANCE === this._type) {
                  helpTooltipElement.className = "mti-measure-tool mti-measure-tool-length";
                  if (this._freehand) {
                      helpTooltipElement.innerHTML = "按下鼠标拖拽开始测量";
                  }
                  else {
                      helpTooltipElement.innerHTML = "单击开始测距";
                  }
              }
              if (MeasureType.AREA === this._type) {
                  helpTooltipElement.className = "mti-measure-tool mti-measure-tool-area";
                  if (this._freehand) {
                      helpTooltipElement.innerHTML = "按下鼠标拖拽开始测量";
                  }
                  else {
                      helpTooltipElement.innerHTML = "单击开始测面";
                  }
              }
              this._measureHelpTooltip = new Overlay__default["default"]({
                  element: helpTooltipElement,
                  offset: [15, 0],
                  positioning: OverlayPositioning.CENTER_LEFT
              });
              this._measureHelpTooltip.set("layerName", this._layerName);
              this.getMap().addOverlay(this._measureHelpTooltip);
          }
          else if (this._measureHelpTooltip && this._measureHelpTooltip instanceof Overlay__default["default"]) {
              this._measureHelpTooltip.setPosition(event.coordinate);
          }
      };
      /**
       * 点击一次后的提示信息
       * @param event
       */
      MeasureInteraction.prototype.afterDrawPointClickHandler = function (event) {
          var helpTooltipElement = this._measureHelpTooltip.getElement();
          if (MeasureType.DISTANCE === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-length";
              var length_1 = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总长：" +
                      "<span class='measure-result'>" +
                      length_1 +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>单击确定地点，双击结束</span>";
          }
          if (MeasureType.AREA === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-area";
              var area = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总面积：" +
                      "<span class='measure-result'>" +
                      area +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>单击确定地点，双击结束</span>";
          }
          this._measureHelpTooltip.setPosition(event.coordinate);
      };
      /**
       * 自由测量时拖拽事件
       * @param event
       * @private
       */
      MeasureInteraction.prototype.afterDragHandler_ = function (event) {
          var helpTooltipElement = this._measureHelpTooltip.getElement();
          if (MeasureType.DISTANCE === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-length";
              var length_2 = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总长：" +
                      "<span class='measure-result'>" +
                      length_2 +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>松开鼠标按键结束测量</span>";
          }
          if (MeasureType.AREA === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-area";
              var area = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总面积：" +
                      "<span class='measure-result'>" +
                      area +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>松开鼠标按键结束测量</span>";
          }
          this._measureHelpTooltip.setPosition(event.coordinate);
      };
      /**
       * 添加测量结果overlay
       * @param coordinate
       * @param length
       * @param type
       */
      MeasureInteraction.prototype.addMeasureOverlay = function (coordinate, length, type) {
          var measureResult = document.createElement("span");
          var measureOverlay = null;
          if (type === "length") {
              measureResult.className = "mti-measure-tool-end-overlay-label";
              measureResult.innerHTML = "总长：<span class='measure-end-label'>" + length + "</span>";
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  offset: [10, 10],
                  positioning: OverlayPositioning.TOP_LEFT
              });
          }
          else if (type === "area") {
              measureResult.className = "mti-measure-tool-area-overlay-label";
              measureResult.innerHTML = "<span class='measure-label'>" + length + "</span>";
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  positioning: OverlayPositioning.CENTER_CENTER
              });
          }
          else {
              measureResult.className = "mti-measure-tool-overlay-label";
              measureResult.innerHTML = length;
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  offset: [0, -18],
                  positioning: OverlayPositioning.CENTER_CENTER
              });
          }
          measureOverlay.set("layerName", this._layerName);
          measureOverlay.set("uuid", this._draw.get("uuid"));
          this.getMap().addOverlay(measureOverlay);
          this.getMap().render();
      };
      /**
       * 添加单例清除按钮
       * @param coordinate
       */
      MeasureInteraction.prototype.addMeasureRemoveButton = function (coordinate) {
          var imageButton = document.createElement("img");
          imageButton.src =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEYzMzc1RDY3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEYzMzc1RDc3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0RjMzNzVENDdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0RjMzNzVENTdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsDx84AAAAC3SURBVHjavJIxDoMwDEV/ok5wDCbu0DvAdUBIwMLFSs/AxDXY6tZ2SCGVUikd+ifn20+2k5hHVd0AXJGmGQw+UyWMxY8KQGpbUNcB23aYHIsnuSgIy8dlAQ2DgwWSmD0YE5ReAq5pQOMIrKsDRByjKGC/dsxz2L7XQgU8JB7n4qDoY6SYF4J+p72T7/zeOXqr03SMx8XnsTUX7UgElKVCyDK3s8Tsae6sv/8ceceZ6jr1k99fAgwAsZy0Sa2HgDcAAAAASUVORK5CYII=";
          imageButton.style.cursor = "pointer";
          imageButton.title = "清除测量结果";
          imageButton.onclick = (function (id) {
              return function () {
                  this.removeMeasure_(id);
                  this.dispatchEvent(BaseEventType.CLEAR);
              };
          })(this._draw.get("uuid")).bind(this);
          var closeBtn = new Overlay__default["default"]({
              element: imageButton,
              offset: [-5, -10],
              position: coordinate,
              positioning: OverlayPositioning.BOTTOM_LEFT
          });
          closeBtn.set("uuid", this._draw.get("uuid"));
          closeBtn.set("layerName", this._layerName);
          this.getMap().addOverlay(closeBtn);
          //this.getMap().render();
      };
      /**
       * 移除测量结果
       * @param uuid
       * @private
       */
      MeasureInteraction.prototype.removeMeasure_ = function (uuid) {
          var overlays = this.getMap().getOverlays().getArray();
          if (overlays && Array.isArray(overlays)) {
              var length_3 = overlays.length;
              // TODO 注意地图移除Overlay时数组长度会变化
              for (var j = 0, i = 0; j < length_3; j++) {
                  i++;
                  if (overlays[length_3 - i] &&
                      overlays[length_3 - i] instanceof Overlay__default["default"] &&
                      overlays[length_3 - i].get("uuid") === uuid) {
                      this.getMap().removeOverlay(overlays[length_3 - i]);
                  }
              }
          }
          if (this._layer && this._layer.getSource()) {
              var source_1 = this._layer.getSource();
              var features = source_1.getFeatures();
              features.forEach(function (feat) {
                  if (feat.get("uuid") === uuid) {
                      source_1.removeFeature(feat);
                  }
              }, this);
          }
      };
      MeasureInteraction.prototype.clear = function () {
          var _this = this;
          if (this._isActive) {
              console.warn("绘制完成，在清除");
              return;
          }
          this._uuids.forEach(function (id) {
              _this.removeMeasure_(id);
          });
      };
      /**
       * 激活测量工具
       * @param active
       * @param key
       * @param freehand
       */
      MeasureInteraction.prototype.active = function (type, freehand) {
          if (freehand === void 0) { freehand = false; }
          this.removeLastInteraction_();
          this._isActive = true;
          this._freehand = freehand;
          this._type = type;
          if (!this._layer) {
              this._layer = new VectorLayer__default["default"]({
                  source: new VectorSource__default["default"]()
              });
              this._layer.set("layerName", this._layerName);
              this._layer.setStyle(this._finishStyle);
              this._layer.setMap(this.getMap());
          }
          this.addDrawInteractions_(type);
      };
      /**
       * 移除上一次激活的工具
       * @private
       */
      MeasureInteraction.prototype.removeLastInteraction_ = function () {
          this._isActive = false;
          this._freehand = false;
          this._drawStart = false;
          if (this._draw) {
              if (this._clickListener) {
                  Observable$3.unByKey(this._clickListener);
                  this._clickListener = undefined;
              }
              // 删除绘制开始监听
              if (this._drawstartListener) {
                  Observable$3.unByKey(this._drawstartListener);
                  this._drawstartListener = undefined;
              }
              // 删除绘制完成S监听
              if (this._drawendListener) {
                  Observable$3.unByKey(this._drawendListener);
                  this._drawendListener = undefined;
              }
              if (this._measureHelpTooltip && this._measureHelpTooltip instanceof Overlay__default["default"]) {
                  this.getMap().removeOverlay(this._measureHelpTooltip);
                  this._measureHelpTooltip = null;
              }
              this._clickCount = "";
              this.disActionInteraction();
              this.getMap().removeInteraction(this._draw);
              this._draw = null;
          }
      };
      /**
       * 判断是否激活---
       * @returns {boolean|*}
       */
      MeasureInteraction.prototype.getTool = function () {
          return this._isActive;
      };
      /**
       *
       *
       */
      MeasureInteraction.prototype.deactive = function () {
          if (this._isActive) {
              this.removeMeasure_(this._draw.get("uuid"));
              this.removeLastInteraction_();
              this._isActive = false;
          }
      };
      /**
       * 禁止交互
       */
      MeasureInteraction.prototype.disActionInteraction = function () {
          var _this = this;
          this._doubleClickZoom = this.getDoubleClickZoomInteraction();
          var active = this._doubleClickZoom.getActive();
          this._doubleClickZoom.setActive(false);
          window.setTimeout(function () {
              _this._doubleClickZoom.setActive(active);
          }, 200);
      };
      /**
       * 获取双击放大交互
       * @returns {ol.interaction.DoubleClickZoom|*}
       */
      MeasureInteraction.prototype.getDoubleClickZoomInteraction = function () {
          var _this = this;
          if (!this._doubleClickZoom) {
              var items = this.getMap().getInteractions().getArray();
              items.every(function (item) {
                  if (item && item instanceof DoubleClickZoom__default["default"]) {
                      _this._doubleClickZoom = item;
                      return false;
                  }
                  else {
                      return true;
                  }
              });
          }
          return this._doubleClickZoom;
      };
      /**
       * 测量结果格式化
       * @param geom
       * @returns {number}
       */
      MeasureInteraction.prototype.formatData = function (geom) {
          var output = "0.0";
          var sourceProj = this.getMap().getView().getProjection();
          var _transformFunc = proj__namespace.getTransform(sourceProj, WGS84_PROJECTION_NAME);
          if (geom) {
              if (this._type === MeasureType.DISTANCE) {
                  var line = /** @type {ol.geom.Polygon} */ geom.clone();
                  line.applyTransform(_transformFunc);
                  var coordinates = line.getCoordinates();
                  if (coordinates.length < 2) {
                      return output + " 米";
                  }
                  // 单位是米
                  var length_4 = Turf__namespace.length(lineString(coordinates)) * 1000;
                  if (length_4 > 100) {
                      output = (length_4 / 1000).toFixed(2) + " " + "公里";
                  }
                  else {
                      output = length_4.toFixed(2) + " " + "米";
                  }
              }
              if (this._type === MeasureType.AREA) {
                  var geometry = /** @type {ol.geom.Polygon} */ geom.clone();
                  geometry.applyTransform(_transformFunc);
                  var coordinates = geometry.getLinearRing(0).getCoordinates();
                  if (coordinates.length <= 3) {
                      return output + " " + "平方公里";
                  }
                  var polygon$1 = polygon([coordinates]);
                  // 单位平方米
                  var area = Math.abs(Turf__namespace.area(polygon$1)) / (1000 * 1000);
                  output = area.toFixed(3) + " " + "平方公里";
              }
          }
          return output;
      };
      return MeasureInteraction;
  }(Interaction__default["default"]));
  /** @class */ ((function (_super) {
      __extends$6(Measure, _super);
      function Measure(options, map) {
          return _super.call(this, options || {}, map) || this;
      }
      Object.defineProperty(Measure.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Measure.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Measure.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var measureStyle = this.options.measureStyle || __spreadArray$1(__spreadArray$1([], __read(Measure_STYLE.draw), false), __read(Measure_STYLE.finsh), false);
          this._measure = new MeasureInteraction$1({ measureStyle: measureStyle });
          this._measure.on(BaseEventType.CLEAR, function () {
              _this.dispatchEvent(BaseEventType.CLEAR);
          });
          this._measure.on(BaseEventType.MEASURE_END, function () {
              _this.dispatchEvent(BaseEventType.MEASURE_END);
          });
      };
      Measure.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.map.addInteraction(this._measure);
      };
      /**
       * 测量类型---
       * @param type
       * @returns
       */
      Measure.prototype.active = function (type) {
          this._type = type;
          this._measure && this._measure.active(type);
          return this;
      };
      Measure.prototype.deactive = function () {
          this._measure && this._measure.deactive();
          return this;
      };
      Measure.prototype.clear = function () {
          this._measure && this._measure.clear();
          return this;
      };
      Measure.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._measure.removeLastInteraction_();
          this._measure.clear();
          this.map.map.removeInteraction(this._measure);
          this.map = undefined;
          this._measure = undefined;
      };
      Measure.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      return Measure;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Wall, _super);
      function Wall(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Wall.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Wall.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Wall.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Wall.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      Wall.prototype.show = function () {
          this._visible = true;
          return this;
      };
      Wall.prototype.hide = function () {
          this._visible = false;
          return this;
      };
      return Wall;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Triangulation, _super);
      function Triangulation(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Triangulation.prototype.active = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.deactive = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.clear = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Triangulation.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Triangulation.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Triangulation;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Snap, _super);
      function Snap(options, map) {
          return _super.call(this, __assign$1({ pixelTolerance: 10 }, (options || {})), map) || this;
      }
      Object.defineProperty(Snap.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       *
       * @param layerId  图层的id标识数组
       * @returns
       */
      Snap.prototype.active = function () {
          if (!this.map) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          this.deactive();
          this._snap = new SnapInteraction__default["default"](__assign$1({ features: this._features }, this.options));
          this.map.map.addInteraction(this._snap);
          return this;
      };
      Snap.prototype.addFeatures = function (features) {
          var _this = this;
          if (this._snap) {
              features.forEach(function (feature) {
                  _this._snap.addFeature(feature.sourceFeature);
              });
          }
          return this;
      };
      Snap.prototype.removeFeatures = function (features) {
          var _this = this;
          if (this._snap) {
              features.forEach(function (feature) {
                  _this._snap.removeFeature(feature.sourceFeature);
              });
          }
          return this;
      };
      Snap.prototype.deactive = function () {
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
          }
          return this;
      };
      Snap.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var target = this.options.target;
          if (Array.isArray(target) && typeof target[0] === "string") {
              this._features = new Collection$1(target
                  .map(function (id) {
                  var _layer = _this.map.getLayer(id);
                  return _layer.layer[0].getSource().getFeatures();
              })
                  .flat());
          }
          if (Array.isArray(target) && target[0] instanceof VectorLayer) {
              this._features = new Collection$1(target
                  .map(function (_layer) {
                  return _layer.layer[0].getSource().getFeatures();
              })
                  .flat());
          }
          if (Array.isArray(target) && target[0] instanceof Feature) {
              this._features = new Collection$1(target.map(function (feature_) { return feature_.sourceFeature; }));
          }
      };
      Snap.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
          this._snap = undefined;
      };
      Snap.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snap;
  })(Component));

  var CIRCLE_WHITE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAVFBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////8wXzyWAAAAHHRSTlMABAgMSRgTEDYxHDsgQCQsKERMUFhkcFxUYGxoc2Qx5gAASRpJREFUeNrsnGtz2jAQReuWvps+DBQI//9/FldjX6+PVqtSZhKMrmknIaT9cM5eyebxpqWlpWX16S634ai4DUfLOjJi//vF+P30zSzmR+mvbvrVJsR9xVAfj39N4j9a02rhXqI59rhfp4JqoTXCa8wcusjfOKqDpsDryggmRv+25qiqg7Y9eA1JHIQ+5F4ZqkANWhG8eGaDXwZ/fQIR3rQzhRdLcYNfw/0djliEVgWvJNXsCTyO8YEatCZ48aD2S+wD7LEKWQtaE7xQNPox+xj8x+mITaixoJ0dILfG7ww+yHu86wIl6i1o+JEbDz8HH+yruH9AakygBjkH2obghvGv54fsgbw21AESoAnQA21DcGMFOPqEr6GPub9fxDeBdUALuqUC7cnEW84+m5/wOfYF4nF8DSiBiqD1wO3TOfQFn/QD8FeLUJBADlCC9hTitcMf0ufgR+S/hAk8gAWBA+21BNeHCz/g5we/Dvs3c+huX4WSBIEDrQb+Y/g5+0qZ/YL3PN+/FYJO8C1gEdCB9kLDKzwIZ5/0HfTiKvjfMxnuLqgACdQExR6QAm1XWPmyHh9/Ffw8eYH++b0meQ1cCdgDgwJtN/CvKdHn7As+2BvwYm/yQzcTiOBa4C4GcqBdG6hK6sY6/M7ogz24T+DdSI2FCbAgXwRhDbQK8EL8pC/8DnygJ/T66HehASSwDrAG2magSD7EH9In/Bz4z7XJigAJ6AB7YFKgbQbi4Sd+v/oBn+wL4D99/pRNwQRYQAmy+4HWAtdNP7f9Af0sewO9OpQha0HgQHk30N5thLU/GH7Qx+iDfRb81zAQIWsBioAOsAZaC2D6ve7n8JO+B5/oif1pOJS/3yMZDRwJ4ABqoLWAP/zh9Gv4ffqGfZa8gP96QnB/1gNjgeeAagAtQAUe98WknQzwpp/DT/qED/QGcVWeciL4EtAB1oDfAo/bAfHaz+H36GfZk/vm759NIekhNCFrgeMAayDaCzzaVqDLX/PF9OeG36Nv2YP8mH7T98MfJ5vhNskwJm+B4wBrIN8CD35dQOOP6Xfxk74dfcMe5JVtIXoURDAWmCKAA1SALfCwW4GuuPXn9NvhJ33Cn6MH9eP2WMr2SBfmGlACOqAacFrg4bcC3PoXpp/DT/qCD/bEvivnuJtkSIEFkgAOmBqgAjgheLitgN7R/W/T79EnfKBfYD9cbn6Gny5NsBpQAt+BmhZ4vJ2A+GP6I/za9YH+NPhiPwd/mFE/lSMXUuYaqAuSBHDgxxAoUN0CK/8Ammj8iV/dr+EnfU2+2GvmLfX9aR/ktLcqSANZoCagA6oBrQROC+AtJat/qYj2/iF+Dr+q39IXfLEHeQE+R9FDrQeyQBLAAS0FrAEqwBJY76dQdSP//8RP+oJv2Qu8qD/P89scyvl5MkEeyAIrAR2oVkBbgccogS4dwt9h8Qd+db+pftIXfMvecv9dm1GFv5EFRgI6YJYCrQRU4OFKoMu91JvjH+MX/VT8Gn2xJ/oZ2PN+wDgAHPElhdK/Mfz6/jx7PDWQBSqCzSXGgUCBYB1Y5TUhjT/2/sD/XvjR/Wb2zejP4AP98/50gd5vatP3FxlO+8mESYOZBKYITA9gJZAC7wsKLM8IV3NNIBj/GD+GX/QJf2Q/kc+C751jmYsIgweygBLIAdZArIAtgbVeGQzGX4t/gN+lL/hifz7ttr2H3Ev+Qf12dzrLAkngOBArwK1AyvreTJZ92h+Lv4uf3W/oE/7E3iK9pgGWd44WUALrAFcCKeBsBXRR4K0EWM8bSILxx94P+Dn8Wfqp8w9bAxDEo/CRxoJDWhEcB1QD9Qp4TxKu5CWDnT/+bH/it91P+hb+bgtkIfbYheXX252VQA6oBrQSUAG7DrAE1vTsQIf55/iz/bX2C38a/rH6Sf98MPA98r90LKKfKNRJTXCmA7YGpID2ArmtAPeCKzkbmJZ/1H/c/sL/JPxm+EV/GP1jD/jkPoTc6YFsKO4O++Pp2ThgaiApoM0ASqCowErOBlD/wfgDv7ofwy/6hy3gA73DPTIhbITtwTiAGtBmAArQACmwmo+WsPWf4rd/gN9Wf6Kv4if8MvUnHKEH+J+0GAwOmKUgUiBeB+79bKB29bftr/N+B7/oc/Z7FD6hV0U6GA8ggRx4Ng7kFdB1AbMOoATWcEWg807+w/bX1n+JXyt/on+a6CsOfYs2Ym8ebsIlQWvBKTmg3cBSAZ0QROvA2AH3bID4B7s/tL+Hf+h+Df/+KAAB+xB7rEKdA8e9amBYCawCXAdQArgmcMefKrHc/uHKP8Yfi7/Bb4d/J+wWP9GT/NfwMHEtyKTfnVUDkQIoAV0Y1CWBO+2AP9yd6XYSQRCFD26JQY2BIAx5//d02OZS/XVVNcEJg4XbUaM/7lo1RJX/iH9X/s3wd8sUfCEH3Of913h+zkUE0CAlwbJrpoDKIE2gtIB7+qeFTvkfx78n/yr88v7tepGgD+xD3HMikAWWA9wQ11slQYUCjgk4ReA+Y8CJf9q/5I/wB/y7pW/TgP6LgT5BPqfB4ZuSBbEPbJQEogDboGkCjIHD3NlNCPW/Wf5yf8JP7yf61vAj6B+jl8sCuUHOgYWSABRQDngmgCJwb28Ugv6Ffyj/BP5Fgv4LXL+K+2P/NR6XCuSAhoUwpEBgAowBecAdPBlI6n8of4U/4F878MP4iXwL7uTAQARywIRBZTdUGQAFVAVCExAD7mwZOPIT+qf95/IH/EAf2hf6UP17Z+7QwMkCO5YCrSbAbeCuPn0M+vfj38of7t/vUQn80j7BT1X/Ha+MBmZsGFgbIAV2S6FygCbgMIAeMPnHw8Jf2z/iX/Zv5U/3t/ATfRk/le+DvpvDdxzDBhIBJIAPVCmAHChNQDHAInCYye8CM+R/HP/a/a38bfh3rvod9APkCbrHATEBDAg44LaBzlYBawK6CfwPRcCr/779S/5y/wH+VaB+D/05oW9GnkwgDWgEaIQMgtVAAeWATMCLAcuAyf970zb9nfon+w/lv4f/bemo3+x7vvQJ/TU0IAe4GPgcWL7tKOCYAGNAReBuPGDm6B/xH8tf4b/dAP1Q/AS/Os/nr/PRz/pEIAnEAiaBnc1WVcA3ARaBu/AAnP8N/oh/tT/Jv3T/NdVvmx9iP8b+hPj3AnP9gGwISEAO5C6wLnJAJqAuaGLgrjwA5z8Hf9g/5K/wp/p56svRH8T+XfDHMzBFLIiMQBO4gKoATAAxsGfA3XkA13/ir+NPIf+l5L8Lf7g/4K+Kv4p9gnrOBJ8EWgzUBuACeEp0ZgJLawLDUejuPGBm85/rP+Nf+EP+60z9Qp+Nz4IfwH/6X2E0LgnEAnAAUUAK2FnDBCwDFANYB6fqASoAzH/Uf9i/lT/dH/DXxQ/l17An5PaLxrcCcoBrASiAHDAmwBjAMqCng728JscABYD0b/Fn/ZP9W/lvN4H5K/qFPmO/qnlBfnhpLCGKX675gV0Q623Ap0BP71eZALogqqAYgB4wnfcIefc/p/7B/iF/4Z+bvzV+D3rBmg4+wCGBWIA2oDKAOggTQAygCtIDpmQBM0f/cf2T/UP+cP8Q/f6Fxkfsq/OrGNcS9oMdIUgCdQFtBDgKyAQUA2kVnOR7hKh/4m/q394hjf3X5c+9n+J3jb+OfQG5+RKQgSRgGFgKsAtYDziagImBw1FIVZAMkAdM6D1CTfpX/NP+T+X/tRr+L0X3o/iJfgV7YX56afRr5S+CBSCBsxQUhwFWATUBxACqYOABk/jnhTP9s/7R/vvdH/Jn9Xdqv/F9gC/kJfN0DA98Eny3PsAcKKuAcYH+JoAYIAM8D5jIOYD6D/BX/MP+15B/NfxR++1NXxgB+/eNPrYgASiA/6zIrQJaB9aIARWBxAOm82lj0H+Gv+Jf9r81z/2s+3PxE/6CHui70P9Ix2UBOIA6oIfHc9TBigkst4oBFQExIPaACSyDl+p/PuCv449tf1z9BL/QN+In+kfYPOB/xS+HCCKBOGAYgDKANkgT2HfB4SgkBsxDBkzoEwfb9V/Uv3P7fw12Px//5wB9G/cGdwHMsQwhDWpGYGwAlwEFgdMETAyoCqYMmMg9oP+Lw/uP8Gf9k/2H8if6FL+MXygBe0xOA31c5APC32UATYAnAVRBMoA3wVulAD/9sxn/Mv5Xi1z+wF/o+4cdH/qncEgEhwXggOMCx/FvAm+2CLQz4OZPBWwAXI4/nvwJfnY/oA/4jevT7QXx7nX6jq/TwA3AAUMBloHHmALaBjoVgWYGKAQ+/CTI//fp04X4M/4pf4S/8Gfy16QP6AWwN/h9pEE/5EA/4ADvAroJ4OnAq4rAhQy40acNzq7Rv+rfdpnIX+EP9TvaB/aC9OLRh5UkKKKAbeA0kQnYfVBV8J0ecAMHuFD/tv5vtzr+Yfdn+FP9z4LfQf8E4nVDEvwqfcBzAVUBmYBuAiwCZhm42AM+sgeiAer9fxn+qv8dj3+S/5n9B+on+jn4X9PxWVByQEMXiE2AXbDTMpAx4AEe8PEXQeGP93+m+LP+VZc/hH+pfsEv9AV+if4Ab/byiGCcgFlAF4AJsAngIpAxACfB26wC3AAvwh/1D/YP+VfV76NvxgIfD39rQYEf4IDrAo4JuDHwejkD9nODa4C9ABP/Jwd/rX8bxn81/XX289Rv0Jf0hX0IfE4EsAAcwNsIGARaB+QC3AY2WgcbGXCri6A2QBTADH/Vf8U/nvxJ/jr7ueq36FfAv2r0Z5QcAAV+wwVCE+jHWQYCBvR/b1QEx+UAT4Cf3of/2yKyf8r/OIX65f1EP8b+W/DKSUAOmCTwqkBTDCzeyYBP414DSILwAHA5/lb9sfwhfqDvgH+O8jdnwASQABywNvDboYBnAuVVcPEWMyBZBj8CfhbAq/FH+6f8sfhJ/Ah9F/sBZU/+pALmZATiQOAC3AjVA0wR0CxW7QzgKjD+NWAmA0ABbMB/6+Jvwh/yh/ohfqAP6IFybAP6sWcEsgG6QGwC4UWgZ8C2gQEogqO3ABZALgA5/qtFJP+5I3+qn+Kn8cvthWgOP3hQMYMn2IDnAjgM6t1CqoJ2GehiBnAV+MBrwMwtADoAxPij/r8o/nX61+VP7k/1W/ET/MHtw8ntIOfAD7gAqoDbBV9+likQMkDLIJ4Nj14DZrgAVhcA8/zH4t+1xz/lD/VH6EvM14+oRA54LkATIANUBNo9QOcAtwhiRmqAfgFsxJ/xzwc/mfoJ/5lm3XlwJ8uGgQOqA3ABUsBfCLkMkAHm2SCXQdaAMYtgewG8DP9+WuRP9Vv0h9ROcM8nzgMNKOCaQD/qASoC7QxgERy/BlD/7QVQz/8P+x/xD+2f8FP9FD/RJ/LX8UAcQBLkFLjAA47boN4fkBfBcT9ZZBZfgHL8V034U/4+/ESf4D/8gyEFwAGHAmMygDVgtLcHiQMIgGgBaMffxP/zkQGQP+BH7gP8fzeBD5ACMAFuAzkDVoYBXAWCGjAG/Eb/bgEo8dfz3zfg78V/JH/AD/G3gf/ZmYQErRTITeDRMmDuMWBVZUBeA9QDRzgBRAXAHgA2mwH/2v1nvmfAo4s/3d9Tv4W/AfcH55UyARyoUgA54MeA7wGLtxMDNhuzDOZFUOCPeAIOCkCOP/Nf8AN/U/0Bf4vvG9iFM+dh+E0+D3g2BgW0EwYM4FsEcgYENYDPBcdKAL8AcAHsuh3+27r+59K/4h/2D/d/8r3fwV6oto8+Ig0DSwHmAGOg1QO2OwZ0HZZB1IDxQ2BWDwBcALUACP8/y2b9U/50f8GfoZ9An09AgvJQyHeVpiagg4DjAYvln4IBZQ14+qAQmBUB8BkGgAJ4OADp/V/Qv7f+BfLP4Sf4mmtZkFKAOYAi0OwBepfYcBBCEcQuiIPgyAHAAsAFsD8Avrr6D+uf4M/VH4M/HgkyCpiNEAzQNuD3gNf9SZCrgF8DRsiAw58UFgAUQB0A1qH+tf+n8g/gJ/rhfHKngQRtFEhMQFUw84C1zgEogkkNmI31LmCdAL/2wwJgFoCuTf/n/36rHvs78hf8QD+SvmD2XikTaj5Qp4AxAT0l3uPvMmBeeTbYaRVADdAuqLcH9RCN0ANnkQEQ/6UWwOL5P/V/HNo/5U/1N2q/CrzG/dXEB0iByAQYA4EHfNH8Je5cdJsKYiDK3pYWQXm2UVLy//+JKhSNlpPJ+Lo3ZEEgJEAC22dmvBs4hUEYwSQCY0sPmA0ADKACYJ5/8B/jr/qb8pvZn2s7V3z+qhO7gC3AUEgIUAW+BwYoDNII+m3AWK7QAVgBKQEaA6AAiPnP9ffjrzNXPxR/1WEb5B5A/QGBNgPewqCxAcqCzgWMayYAbwAYAOL80/7Z8Wf5WX3Uvnt8EzyiBTwEYAXXdMDhFAUOhxuJwOwAKQDGAOxX1//HJP8af0w/ht8X//Td1k1ADNAKvEEARuDH6g7YGxsQRGALAAwDACbAkwHQBnC3uv7a/XP8Mf1G+UPx20c9EFrAQ0BrQbMU/OQ6YHfaCMoGIAsCAVtpwAgAoAGAAdTHv/ThH1v/PP6e/SpUPn0QUAnqELjYAXgrLCMIG9AVgX4CqAnA4QADiAcAn3L9ufsplL+q+sOeJZ3UAoQAjUBmgKIAjODhUBWBvAvovwLQCmhKgLMBYADQ/V9x/k+nMv2F2Ved3Rc2Qu4BtsCp/u9iwNcZAS+TDVAWDCIgBlxZAJIBwP2frz+efD5g/Fn+UH3UPXy50AaSGbQAdMBAAB2AV2LRBkgEAgLGxpcAugSmAHgDoAVArj/ln+X/x/ipLsXam3O2DyIG1ALntgKAQKMDYAMoAroY5qXQRgQAAKwAyADkAODn/zPwj/GPw/9vUcun0gTCgI6RAcsA7QRTGJQNoAhsjwDWvyYAMgDU/1x/yL9WP778dvinOrLA5qvvgkoLPJoWiAzgOkBRgNuALALbIGAYB5AF4AgDkOv/dHn+100/ZlhVDwc/K/aAawGpwIMJA6EDYAOOUQQaCGgDYF4BzQkQBgABgPX/pvk/QVP2T+PP6ffVn+vYOGwC+kFSwDiBtz+WGPCt0QG/lAUhAldDAB1AFoAXFwBK8y/7p/pj/DH9rP4WpV/068EBUIBWgHmwwADeDOp9UBQBRsE+AkYAgBWAnTUAXv+n+XfyP5f/fPW3Kz7pAQ7ACwgC3ghkH+BtwM6IwLYIYAJQBAQAkACQAGEAnP+j/PvxPzf9KlDvZGMguJACDgI0Aj4LZBH4zSRABDw6BPR3AN4BUgAO3fpz/v3439nhT2bvQ+GrPx4DAQKzCjx1O+AAEYAPDAhoE8CvACgAOQDk+ff4X9YPfygufnJQA2CAVoBGIDDA3gokEaAPtAjovwPKDpAC4A3A+vmf934yACj/Uijo5ZcPH9gvvgVoBRAIAwP0PsDbAIhA3QcCAf2PAnkHeH+PBKArwGgAOf95/Dn93vOx8sN90QfrC6ZQQgAdgAzICZIB2Qj6JHB/Lx+4PQLgAIwDNAJwXzMAnH/Ff9k/X39VItd+VL7o/9+5QILlghBc6oAHMqBiA5wIyAfmKNg3AAQAHaDuAJIByPP/APw/ovyAfyr+aHyJKCAF7pAHZiNQZIBsgLYB9z+ndZDxgUAANKCeATIATg5Qz8D1CMAKQJh/CYDBP6a/UXxzzE+VKShQ4A4QmIxAZkAWgf3pmbh8oEcAjE/1eAfw5AFw9PWvz7+tP8Yf1g/Vn7gepkBTwh6IFIAX7DMgd8CxgYCxmQNgBJQD1CVwSIAIgNJ/2H+NP+lfn32UGF8vwkCOwNlBeMEKA6YokGyAPjUuH4goaBCA/u85AERAXQLNO+AGAP4eO///ZD9texZTfTf5Xg/ZCugBywBSYAkMSDYg+EBdCiEKAgFNCUgAUATkJWAyAKy/8j/nn6tfWf+A/nG+8oPfFmwBMTDfFZk08GgWArABuQPgAxUFMwJa9c8AUATctwzAkwwA/R/wD/qH6rP2UgPzLUFADDAVGgiAAdoJfl5pA+ADFQWLCBhr6l8EAHeAGQD1+Uf94/hPxQLw49/B4F8De0DbRb4wYhogA+zVIGyAF4FpHxgQ0CPAiWsAAHZA2gF2AJDmn/Kv8Q/lHxR3/cCYQNBBP1+/NSMhZABpgAyQD2iIwIE+kAjg06DxDgfAJTAiYMMAIACo/pB/4t+nPgAgHicREALx8UOQgbvMgIYIhCjoEVA+o+IAGAEDAKIBvDD/OifWRvijlBp02xPDGgTRAF4gpAHDgGAEgQD94zF6I9xAQPkkAHAH9AoAGAGAAYzzr+PxjxUuatsAABRhzKFAELAy4BkAETA2wCHgdTUCRmMLGAGgCIgVQBAAbQCD/lP+l4L4S+Z7KuAUZK6/wUCVATKCUQS+fvFRMCNgFQHG1QBAAWAA4Pzz5sfXPxW13wbqqnm/PLAVmGTgjgzgOoA2IPjAHgLwNxQJgFuAAIAkADkAuPmX/KfyBwS0moDhQBBwewHDACAARjCKQEYAbwQaEqAMiB0AAGB2QJ8sALAB9vOf5Z/enwPfP4wDsgKKAxSBEgNgBA0Czj8P2wMB2AV0roQGMuBGAPAbgIfS/MfxBwK2aAW6QMQBc0ucGVAVgT4CmATHygzgloAJAEUBOJ3q/C+o/zbuv+4dqALnIFBlQEUEAgLyOhAEaCyB+BCoCYC8Abjz8+/Lz/JsKQODruLt2OcCi2MAEcAsmBFgEDC9C+jug9kAzIAZAF++lh0gDcCjnf+M/9FwAS0UYDmMMEAGWBtQ94FFBHyzCHj3NVAfAF4AzPwj/nP+VX4awO3LTwSoB9xeEFvhog1oICAkwbGIAFcFgOofE8CF+b+rzL++zEW6/pEhtHvBBR1gbIC/FeohIC6DxoqnYD0AQAAaAAjzD/kfjOqb15zBAl6QDMg2oCgCXz41EUANyCGQCqAMiIdAr1UAZAOAAID5J/6F5Fbs63sBJMLAAGsDKAJ1BLziaZCSIGxgUQPWAGB3bACACYAGMM0/H3wBBOF0wc+XIm0GTAvBv6eDgN0aBOSn0aYB7BJoFwAQBEAA0AYgz/8EgPreZ/s4MAoMkAuQDYgI+FZEwM4tg7oaULSAegn4DAAEBygB8AYgzj/0Pxb/KiYwIQBpMNiA5AOJgGe9DizZwPwobqUFPDYBUN4AeP03gnzNgxjIdyJkQLQBH9+DgONqGzgqGQAW0GXAwwoAPBkAeAOY9R8u8H8d3BF7Blgb4JcBdQQcmASNDRQ+IwHqAPi9FgDTBmB+BMQFwOD8357+E3pUfs+AyQieTwJ8G1JHwO8yAjIBxoe1FnD/fgBwBSj8e/2nASScebZPgnSC62zA+xGwX28DRwKAFAAWUB8G2e20BFoJADoAGoC4/r3B8HsvwCzgl8I2CTQQoCT4IgRMNnCdBqy1gK9bAoACkPzfuG0TgD1nEbBAAxwCPhsEhF3A6zoNqGcAbgFhAZ/zNeCZCOgAMCdA//bTW7HrH7KfK6FzDIAICAFIAusQ8OsZNhDbQLwOrmUALQH0FAwWkNeAEQBmBQABGEvQ/9sNPj88AB+AMKgWAALe/HB8GMBLQSZBPg3TwyBpQDMD0AK+VBSAOyAAgAJQy3/9m59rLAXTTtAlgYCAaAN/vdAGZg2oZwBuAZ/ftoC0gH0AIAEk/zdurv3WDfooABHoIMDbQG4DqQEgAAFABfAWcBcAEBwAd4A0gNT/m+9//nB3BrtRxEAQxQsLCOWSJaNskv//T5BgZTlvK9XdM1I8Y3HgxCWm6lV1eyJ+9K3/wbIoMGAzCeBAgBhID9CP43IOcC0JgOkACQD0/0/PgEYC8GbghBvw/2wjAdekBzStAN4BiIB1AugdIDtgk//bPD99PiTtL4i/fFwGbCABbAO9B6iTdIAXWQKlBcAbAPL/FEGAd4EcQBPAXDgoAUyCrAK8B1AB+CCIDoBVIAyC+2OgJAGwApAAeDufb//wgOHv8gaAAzeSgN9cDKIHeAhoOQfwj0GqBKANoE3l/uyBdB1wemcCUQrQF+Cx7gEtjAB0AM6BgIDrCMAEgFlqoOE0UQdwKlSSAI+Bz8YDAAEWAXwGuMQRsEYADACTNQC4A8AA3oAIBVTKIJ8DUAauzABvzAAaATkGJAEMSyBwgNmyn/ECORhyEsChIDHQ1MHlHNBKDvCYdwDbAegA0PFvrmvQRBLASMhQALcDt/cArQAIgXQAZoAaAmoC6Ag4/Pf//AWAWBTAsmiOAr5jMSSdA+gBDIIZBOA2MFqgEgLqKdBHBDBRBRTBQUbBDyngnMVA5ADOAwgBVACPANYBWAJQAPqPf9gDGAng1Oj/8/649U+/O5enACiAlQDvAQYCCggABwgjoF8E0msgPf9PLwGAE4CgoIAfYjWIGBj3AA8BQgEYArkLtCxpB3jAKrD5+VMA5qeAIaT2NAAKcBJQ94BlwV4QgqBTgKADLHCAAgLiY+DYA2EAaBP/+OkDNIGG1SBIQLENXKwHEALqNeC14ABEwPdvAe4lgNkCnw0Cw3W9qwGMgqgCCh5wLZaBRAAfAvsukHcAiYAUABLA7f//bv77w584Ehg8gEEQbaD1gL4XZIIgIAAKEA6Bb1s6gCbAvUkAPyUzmgApgFVAPQe8ZYLgSgR4dg7gW0BmQJUAdycB/SAJkAI4EDAYCA/IBkGvAB4BGAK9AwQegzQiwLSpTx821kwCt6PbQOsBDIIWArwCkAG5CxIPgWMGVAhIAuAM4NP3v0t7QUgC2gO+sgqAB4SCILdCPAUyBCgEYAist0AsAdgBzPD2a60A3N0NafCAeg5AEBQQQAqsI8BT3gH0YwCRAW8ZauIVgMyKoLwBCgN/5T3gKQEBGyFA3QGIgPc7wCmHv/Y0bgbIJKgnQt4DyhDgFUC3ANgG3NAB+POfcg3QHGArKYAL4lAA7wEaAtgEeAUAAmAQcGsB+osgIEAiA0RawNkeAZR0QFBANQd4COhNQB8HEAKoAKyBsi2Ab4HOpgUcCWCK91/r18MoAcYDfBcUbAJ8FUQEIAMWEcC3QN4B9qX8/qEIFcB7QAoC6lWQYcBxEKAQwM4BTAaAAUy7Apj9RTMfeYD6lWL0AA8BwzjAUGA0BIy7AMM+cL0GpAOwBZ7w8de6JWHtAZSAdBnYxwHDTkA0BqRqoBcgQDYEegfYxR54Zj5MC0AXxDIwDQEviSrIhwBZA1UQgJNgZoDx5z/rK6DsAQaqHIAYEIUAXwXZGJBjwDwCuGVALAJN8g2wDRrhJpMgKBASYCBgLQX20yoM+A0XQIdA7wBkgF2ynxkLR+cBLghyJ6BAgVSAwCiwM2AKAfgikBngcAQwuBg8gDnAtMFhCvQDQa8A6AHBgIUWgClQZoADGD+igPEAQEC8CSAFogt0MaDIgHSA+iSQCLDPAgAHQUBDICTAQMA6ChQhwDNg/AL4HrjfgCMKQMO3g6JNQPECXDwFip0QEQLuzYIvCAERBGAPrDPA/ltgsxqIb4gXmwBS4OXORFjFgGIR/AoGTCCAbgFup5vTES4BoqB4JWieByQo8LUUA1qiCF5SDPigBgFUgFEADhcDtQeI3yR0U4CHFAUuiTLYKACXAWwI8DWQbwH29Bo4igFiMQgj4SgE2BjwFIsBUID+KEhPAp62ZMDeAhy6BBpg23jAdjGA04C//zByIBTApcBrpgfUuwBjChzO3B+DqmOAbgKEApAC/QW4mhwIBcAoCCmwFgIoAHIdENvAu10CCEOAXwo5BymQLwR1DuQ4CD2QSIGcBDAEaAb8xRqQL4IOigADB2gKPBkKtDGA0wCdA9kENdYAIgWaSQAWgtEDRhmw7eQdUO7g5+8pkKvBfhogciCKACiAfxUmUmCdAdkCHFIAMA5YT4E6B/r3YVSASA0gU+DPUgrULcCungLGTrNNgKJAEwNUDhRFgFCAzCzwuRoCzrEe8KjijyYgqADpGPCcmQfqC6BrgGII+HdsD3iAbXD31SChAPnd8FIRwAtQrwEyIYApQM+CD5j/MA4wCtA1wMSAahFQvwCXRApkCOAyCBXgOB0QXwtqBTjhcQB2QmI58FK+ALEeKJUCfQggAuz0LVjscC9MrgScqznQNkG8AG1dD7RpCNjbR6ESCGi6wNQ4CBawrgnCBTDbANUawIeAnX4UJHoLfBdYLwL8RgB3glYXgdvXAG2vb8HNaa4LXFEE1KvA24l/G2LZpgbQIWDmz0GvvwNeAdYXAUv+KxGJfaCXzAUI1wBH3Qb5w9617bYNxbDIDZqlCJAtfdnl//9zCDZAKAiZss4lts7xF6SwSlMUJQIAMAR4qzAQ/sU9QYgAvAAMP1BsJ8DmAAlloLUl4aV4QdD2BLlMYXwUgEqwXwi8eREgfRNgWQIwTxoChKgSxLVgjgDFowCOALYOKMsAMoBaAogWSM5EBAvgHuIA3BHIEYC7AWSRAZoANg14M+aBwAGCw4AgAmAB/NyKANgE4CdgGaEJEBQC/I6A+DAAC4BzAD4L4hyAywADWML9CMA9QeXTIIIAYAoni4HxUQBaQkdoAhQECAJEhwFkPdAwhm8eBn6SWRARAgkHOFw8RFQKjHuC+DTok44DEQGaFoAtBGIFZG0Cnk+UAzQsAAnYAeoNA4cyhOkfRRCgfBz4eFUBXLcOAycHCCPA9Q4I8PoCuE8O0I8DHK4AJgcIc4B9FUBFQ9BoOkAvDnDeZQE4OUDezfB/T0ME2HkBTAR4FnWIA+QoAD8HyA0Ah0eAx0SAEgiYOsDQOsDpdPwuYOoA+9ABrjssgDkLOKwOcNrZNDDn66+qA6AfoGAaKFsKYHKAPcwCak0D2xhCJgdoxwG4IeS8wRBiXIipcx6ALwdPDkAQoLklTGKmUP9ewNQBvBzgbZ0D3OqaQhEB4rZwvhewlQOkPBEiRAcwlgPLbsRwV3CLxRB+KnxQBNDlMH3/iACwGlRhMyiKAN9rbQZhZJy9F5C1ExRAALobqLdCPxqthkloOTTOAfh6eDroJxyQbAcrByxdDiUI0HI9XEvAWA4d5Fa8rF+KfMl6uPQ4EGEjwEhCgPc+wKXrgYhTlxMxPDVUljGkQCEIQJTg+idipOORKESA4S7FAgIYiQGQH9zkSBQiQHlcgBcBsBHMfSpW//+rIkB5YIB0PBTpzQvJeSrW1IEUAIK7oX5T8K3/qdgbHgjQElgGWxAXQwcEEqgIEIkMedQ4FVt3GvShUuC7LzUwoRqsva2sdYEXEhrU/Fg0jgPLb8RY34ARUgP17W9yBAIC9DoX7x8G/AheiuQIkPROEPMEIwL0DIx4TWQMIIB+A7LEh9NZoHEpVkugZWSM/r6uoVGIAMm/AYIqECJAuQyAQqA/M6hxbBwiAGiBXyogX2qksMyoerFxvyO3opsHR6ojgGuBebUg8v6BA9BZYFwHQgTwR8eGXIH2PBCTQ5MRAG1q3bNA9QO1iY4FBOgQHv3uYYFaAXnMoQIIsCUvpFl4NCBA7/h4Ozs2XWqUJkaZjtDO8fHYBbqFAPUEnVkbwPvANSUgVycIOjAgQHAxELvAkAzgj4zAPtA7DcCD4c9fkj04TFajg20OyFMD7S4Q/UDBAuCOAM4CgQT4lYBEzaCVGlklN5S6AXgBoBKEfSDOA3kb8HygDTBYYNrwUAAAEwEu7sAgch2CdIEgAxieILoe6GeBNgIk94QIAABBgGBkGFkMJDKAIgDpA0kb4DMFueNjJdlHAAAAKUClJoB3gYgApW0A1wL9vkA55RkIiikD26NArgOWNwGIAM5x0B8yDTCs4Ww/bMnJAmU1MnCNAvjjYsAS/L8JOPuaAH8bgNMAqgUGlQCVAjJwATFFIKQAfgT4xoODeRNg9IEtWKBCgK0E5BsJi50X14ACcA6ICFDIAstJACKAkoAM5kBR/occoD4FiHPA01oBAAssIwGoBNj5gYdOEgcAAAZQlwIgBzQLAL8AbjHYzQLdywF2H3DoJaG/3J3bbttADETFWHEvaIrGkeHY/v//LAIjYIRjaijKsqUYLdCXXtLdPZwZcjfGW+HDJlAMg6Q1YD4IrqvAkgjwdkDsA8iAb1EGUAAQA2EYpCABJmnAogrMiwCGgcM+YP33hN3HqALATmCqAlQ1oCaAUoGHtnA9CO0ARYBVR4GGvUAXGF8L3RbHwQ5CA/oGyKlAZoHdER3hQjsg9gE0AqsOhCyuAE+4E1S7GM5e8LFDDpgxAY3lX4k4tbIdoBHwYwMf8L2+j7T5r3QJoATknSAtAU75tyGQtJhQgTURwMHAfA1YbxHodbKCCwGQAJCAN5AAygSUVWAnRYAOA/Vk4NqLgAEA2gNcPkUT2CkNqAmgo6C8CKAP0P0AysBVfjd5DILpAgAAUAJqCZCMgZwAtAGiIQgRkK8B9AFBPwBWcGUz4oYsKKgAwRvRyRgwkgCqFRiagKYgAlgDSj5Aq4AVXhfFKFiSAM+VGLAuAYoNwUPWCOooIPYB1qwzD7JeG9swDEoT+EN4gJwJPEySALQBFAGeBJyjmQDWgBwCnABEwKoS4WwByEsAACCaBTh7CgAJoAlgTV8FQgT02wG7lAiQdwQ5GfZk9h1eizCef6MHDF4ITlUA3grsNQIgAVwDggC0AVoEvNd8AKMApoGMA1elApxSUQYMC8gQgBJQV4B3KQFoAuoiYF+oAXIuiFvAJYCtYg/4XuWFYF0BLp9qBdhPkQC0AWwH+EzAGCPIl+NlGkgGrGo2xNAKrikAVgBtAn0WAI0AbQIaVQNehRFkP0APB9MJEgGreULcQYVBMHjAMAXM9wFoAvUsAAhAEZA1gvUakEgDiYA1ZsJYf90G2BY9gDaBlAAEV94IihqQjwICFUAGrCAS/nr6cf6z4+AAQL4C5E0gjhBEgDCCqAECAbU0kG8GLfj9KFBKWwBMAigAiAogTSA1YL4doGqAloFRGqhVwBcZsPy7Ir45BQA2QwDQEpAVoG4CqQIpAtgRPLcjo4AIAUoFWLOKd6McAeA/1p8KsN4I9BgQnUBKAEkAioC4BuxEDVBpYJwFDEwGLNQOmJgDFMOgIgXUFWC3iyqAGAcEAmapAUwD006QO2DZT0hdtmbsAI0KUKSAc1SA6L9uXA04tVUZqFWAXd8BS1YA/o8TFUAAoCQB21O2AggAyBrQCh8wAQGJHfDxWd7LESZ6gLAAAAAUQB4A9ABtogJEKhBGcLAGHBEFiDSwqgI4IWiLC4YNq99YDQBaAjIEOKICZEwgP1aqAa+oAVUVAATACy4uETJMrMXnHwAQCmDGCiCMYNIHvOs0MKsCWATiQGiJmbCjKYwAywDQFeA96wE0AUbVgP1NEcDvIxXmQbagRMhgAPT61xRADID9qApg8deS9AFv3WU42KOAOgIuHxYBMsAWOB2CVEKuPweB6gDwWaBLJzhdAQa2wLga0MEJFhEgwgAIQVteY8DU+jMDvJUC6MoVgF9EWAPYE2YcPB0BvSJwDQGLej7I/AfqPxIgdIGKAOAG2J2vdIJFBRAigDUAc0GIAioIcB2onQADoUU9KW7SALIAiDkAAECFAD4LFFcAEkCHgToKmI6ATVIGYFD4Qa6QMoTrzwLAy0DeBiwDgBJQVID4Y6gBn/0AzgV1h30sA4kANAWBAGEFsQMeJgC4+MYJAAKAFgAA0AogloDHjrNA3gcQMaCWgb0agI4QZKBAAAaEIy8YMoCRwJ0hwD0Q8x8CoAgASkD2gXoV4CoAxPKPrQGntoYAPBumZADN4CPfEbQr1UfyX0cAFQC0p3QFAACUD4ijAKSBJQRsMSIOKyCqwL0hwD3A8y8VIK8Db+sA2H1JAYMQAB6g4ANiBJwFAsR46HOIAL0DHtAWhPewhP6DALwpAM55AJAAugZ4FICOkDvBHAL4ZIzHQWgMIw4QXuDexYDZX6z/LCgAAABGgRUA3AMyBfQQQFcAIkDLQDYEiggQRYDLTwbckf2GR+Cl/+P68ypAHQD7ggSUIiBfA/yicJwFBDvgt9CBvgVkKmz37BByw+XPfw8AcAC8C6BDwIsHzFcAqCfREw7TQIRBSgXEV0UZB2kZAALMXQH4t9jnT33+2QOQAPgnAcBJkCgFRAqkPuNkoEBAVATiu4KUAREDnAKPcwNc/7wD5FUAfIvICAAeAhUkoPx6UjIQYZBUAToMoAxwBighYDPwn6cf0V+8+jH/6QCw/goADIFSEtCSe/rTvG6mIuBnGQEbyQAgYE4I0AMq+w/+MwL028CiC1QGAEMAMCDnAxQCVFOQO4BekDIgz4B5EcB+kzkvsf44/wAABECw/rCAWQCUKwB9QN8JTkUAvaC2AmSAbgzMAQFj9CvPvxAAdAB/oQALAOh7QFaASU6wiIBfQwigE9AM4BaY7zlJCx7/wukX558OQGWANQBoCai/3D4Cttec4K0QQBkAK+AM0FKQGU1zP/evz78SAHUAXPOAWwAguQU0Al6GECDDgL9wAoEV2GgGOACIALsd+PtTSP6XTjj/27wDyADgpQoAXQOmIyBOhAc6w3SDAxBwKUgA2LQ9MNL8p8//c+85EEYA3ACvIwDgHhDjwHkAKCeIOLBaBD6OQ0YH+EfWgekUsAABWH3sAH3+XQAUCgBCQOEBCwQQYZBAAHVgvAP4dBR1QEIJBO2hiRTg7zIcf1H+cf4hANADEApQA4AhENc/HwXUEaCdwJ9ACEIHjIKAYc3tFqmfL79YfXsKzz8FgHYAdQAoCagbQlkE9OcCRhQBwQDogCcznQoJiFeefPc/R4l/ff6ZAFQU4NvHy8BZABQI0IxGwLmHgFdugFgGCAagOZiHQGOFox8hQMOf7Z/4/AsHKJoA7bmkAPKfFAJeegjoBAKUDCADfAeQAnIPEACqbexLnh/84RYYc/4jAfArBoDfBx4NgPx5MMjATBx4+s/buS0pFUNBVC0LBXUYGBWU//9PS2OmDYs+HXKIwdIHLV/6srt3gh57hgBjgDaCwQOQBKMLCMWcBSz4vPdJ7u/1X+HfFPhdAAj46ylwWALmlyB5BngL0I2AtkF/z6gFZA8QA/omAcEXpPzBV/9B/aBA1r/+Y1ATAHIC1A5ItwDGAMI1QGRAtoBYBdkEfBWgBzgKiAGZAng5miKApE/wvfo9+t7/cwDIFbDPAAbyb78F6H1oZECuAvQAPwYCB9o8wMec/Jn5n/h7DtD+qX//CjQHAFbAewxgIAUmC2AVtEOAMeDZVgHjATEKcjdkXw8TfYe9Pln+NADqPxcA4e8GwAsSYDSAgH6yAN4I5CqYYwBvBbwHkAPZBQAhvtDhOmBCnyQg/Hb/hzcAdw8AUwGdARD/9RbAbRByYGAAYkDyAI4BoB84AD9o45+g70VfDET6T/oPAYD6ZwKEATwtGQDPuAXsYAHMgYcyBHoZgHWAZYBOcIHIggZ/+2d4yAFv/0H/NgBshT9eASgBwgDcNaBo/nALUBV0OfCTiQFmHUAPoAlkF8gcyJ8e5Gn+tH/qv8if+u8zgG9tBcQOKCaA9RaghbCqoPaBeQiEdQAZwByQXWCcBR78rH7YP/q/XwDEAKBvA7cVUEtgGMC7jH++EoIFoApiH6g7ATsE9qoC8AAGARRCukBmQOZBP/BZ/h9g//Ws0f/xJwdANoBhBtACfBUMy4CuKtDgH8YAOSAbmHwM/I38af9mAYgCoAAQBgAq4DoDIPo+BbAKagic3RAwG8HsAeyDNg2at8PtD3/e8M/ytkdvfuj+HP9e/8Q/G4AGABJgMoDHpACfA80QMAwY8ADOAXJANMgoZ7jznS/df1z/2/sGgE+AKwyADIAFIAeaIRBjQJ8HeBNwNrBqDqS7nvqx+BP+rP8cAO0AYALMBjCeAnIO9E0gM4BdgAygCeA0QGWwCblX/hL6DfzCX/UP+n+KBYAE+KoBEBNgXgJm8JECTA7UpZDWQdgGpDL4dMsDKgXEgIYCixxYkQkpfaAf3B/4Q/8Jfz8AdAnEBLjeAEgCXwXtELi8jzGADJAH4IFAQwEduAB9YC0FhL1Hv81+Qf5Z/34AXNwAyDugOSnAD4GTjQE9OUAmsAljAC4QZ0E+THxAH83Pyd/v/6L+if/JDoCpBiALyENAdwIvsIBuBjAIBArABwwL8Iwk+T6kD/En+Kn/gH9lAAPA8UV3AF0DABVg2AFQBeMQYBf06wDvAWTAAAXAAP3KH/gAe45+ws/yT/1n/2cAcAOAFfBRFcCkgDQEahdkDAADggdkE2ArzDTop8Ai+tfw35T/Juv/twwa/JcaYBgAOQGMewCroBkC6oJ5J0wPGDMB2gCPk3gQvrX+LP8N1A/8YwBgA+QAQAKkAYzDH3IghwBjwMEwwHhANAHPAZDAnIT7w+Cn/Kn/RfwZADAAJiQAOED3EFiKAYdBD1AboAuAAvUz5bz+9USf2Z8GcKf+fQCIAwAGsDoF2H1gGQK6EwgxIHkAg4CvA6IAORBmwWr0Ofspf1//s/4PIQDkAQADeFQTyEMA2wBbBegBz81S0JgA5oA4MMEHgD7hp/xZ/rH+K/oPBYAbgL4BAAN4WArwQ4AxQDfDgQH0gHKMCYgC4gCOMFsJPcGn+Qt+yp/wQ/8Wfz0CQgBYGgDpFmD8bZBrAowBCoL9HsAg0E+BQIJx8IE90DfwS/4a/2P6LwEQAaCugCYOAD2iT0OgdkHFAARBwwCZQGKA5oAogDTA04j4TtU79D8Qfrq/3n47/LdL+CMAIgD4BiAGgARrr4X9EGAM0LVQXgmSAU/OBEgB2gCtgB8PO7Dn4Cf8lD/aP/AX/MBf54IAMKkB5NdhbALLMeDqn44hAxgEaAKoA6QAOZB4kD84EL+BH/LH+N8Lf/sC4OoR4FIAwACA/qdbgI8BqAK33of8+0pM3xtUFMQcEAUiB/JUIO4BfKIv+DeQ/4D+UQBsAJABTEoA6gFoAq4LKgbUKvA1MMAHAZqAowA4QBbkk9FP8Bv5q/0j/lP/2AArACoAoAES//J53Cn45y7IIFjKoGFA89VxlAGZgKEAOCASPJADfxkF9AP8kn+I/x7/83cEwBQAagV8JPpuH6gu6IIgyyB2gswBzgQKBxIFaAUTwM/wS/4a/6b+f2zxZwE0AVANcMoAYBeUBaQYIAaoDGYGKAigDZg6oFqYOPBhFHqCT/QFP+Rv2r/XPwug8O8KANMMQDnQDAEGQZXBfgYwCDQMIAUqA8QBHoHZh7ywT+hL/Vb+4/irACIAhgEw6b/NcEOAQXCcAQoCagOeAqUDhVkAHuSPPZsG/kJ/wk/5c/szgD8C4OwBQBNIDNjfqgK6GXQMQBCgCbAQ6MgGPAkyEwR8AJ/3vVQ/5b9vXv9stw5/LgAYAD3+YsCEFIAhYGIAy2AXA7Y3x8Az6gAogDAAEowegi/46+in+rH7M/af8UcBRACY3ADy10UZA1QFWgb8cAzgGNiiDQQK8J6gngngY/IDfshf6b/b/3+0+KsAMADgElj6n9AEsBB8CAM+1oWANgJqA+oDpMCOHOBZiz3Rh/dT/ZQ/45/Xf8X/lPA3O+BZ522KASyDdSEUPABBwJiAKEAb2DSREGcEeWIv6/fwE3/p/6Pq/yL+ZQHEAugDwLsZBsCNsI8BqAK9DPiinaCCgDEBUQA2ICKUjz0Jd4t+AR7oJ/jD+M/4swAwAMzXP5sAYwCqABiA22GWAZhAcIGbDIATxJPA19wX+lS/Fv+UP/FvHgA7/FEAEADCLeDUhWCoApEBh2oBcIHaBtQI6QK0AZ3q2eugB/iC36s/yx/27/FPBYArwLmHQ4BB0DPgm/cAmsAWJgAX0PkDCc/r5B6EHrYP7VP9Xv5bjP/D9f3/kfjfFwBn/wfaKQj2M+BgLgcVBa/D4DNcQCQwNlDNAEQIyAv7DeEH+lA/5N+t/28G/74AyAgwgQSyAARBMYBL4boROiIKBhPwLkAbIAcEYcU3fcqfAvZO/E79e8kf6rfx7/hN/e/s8ecr4HIs+vNjQD8DLoYBzgR0RQgXgA2QBKRBpQIPQPfgC32v/ix/4n/pxN8HgPmHXZBl0E8B3Q6LAdgIoA7IBBAHCwcqBcQBsYBUyL9D7Cl9wS/1C3/Kn+Pf40//ZwE0K+BEgvllMDPghWWgMEAuoDKgR8PKAuAAfGBXQVt/dpr6gh/il/o75c/69/JzDH8FwJkewCbgq8ASA/RKLAcBUQAugDAgH4AT7FZAL+VT+xK/1M/hT/n/+/VPvP9awN8UgHAJPEH9iAETGFA40JqAdwH6gI5gvBt6YQ/tC36o38kf6b/oH/h/7cH/vy6A8r1gNwO+VgacGgZkE9gbF8gcIA92QfCQvbQP9Kl+yV/wY/fP+ncawB8D4H9SgEFQ64DMAC0Fswl8DC4gDpAE5EH86AB8oM/oVw7h9+lf67+MvxYA8zcAeQiYKpAZUFZClyMZ4E2ALiAbIAfIgvHzuXwC+lQ/r/6Iv+J/Wf8k/BkA528AchPoZ0B9H2DKQGkDpQxgKQAXkA0EDnxeB76wF/qAH+pP8mf8f8X/mPCn/qePf26DRjygvBA5VwYoCmYToAs8wwbEAbAAPIjI109En+qX+Dvlf/7+iv+5vP/o1//EDUCOgc4DMgMUBZMJaA4scuAJJAANmo9FncgTfMV+iZ/4R/kr/v0i71x0lAiCKBofMRqjhgFc2Pn//zTQtsf2cLdm0ciwW2iiUWPMuY/qZnA5/j2P/9v/fQOQbwSvUwDvDKQQOLknKoBlAAmgAVRgJYywDd7soW/zR/qYX/yH2//n87/BDXB5I7hcARwG2iIAf4VAWwSCBogBiUAquHpAD/1ofvPP9qf+Wf+v4f/fjn/1UYALoayAfhhgEdg5AwgB90CSgDVwvQzse1sf89v9Sv9o/12rf9b/yN8XAIMCbpACOgrUChiOg30RuFwDvD+EBJZqIKrg63LukDd86LP3w9/4Pws/8d/rf1j/F/G/YQHko8C7JxXAcZBFQDWgEGj8nQJIAA04CayE8tVG7CN97C/3t/pP/A+PQ/1z/Fvmf/jfTgM+CtQKYBWkBjgNOATogedqQCoop4Jv+sn9H1P6M0fin/VvKX/i/0bw0cDyDLi0CrYa4FowpIAVIAlIA5LB9exNH/ymr5P/xe1v/hn/l9a/5f6/qv9vtgeMq+BYA7uB/58KkAYcAxYB00g+DzzoDd/mH/hT/tH+p+2P+Gf9W8b/ZgcAs6/3AJ4Q4TDAIkAN7IsQCOugNIAIPJ1spG7yhm/6Q/hT/n7sl+2P+Kf+Wf/78x/J/yvJ/zbeA4ICWARUAy0EDhdDYGMJMJ+sAUQgGUgLZh7YC77N7+7H/eBn+yP+Xf8/+a+8/8/w8x7w7k8FsAq6BkIIkAKFBiwCq6Aeoxd88GN+ol/uB7/t7/hn/YM/9z/2PxBuNpRAuBPkOUEtAtSAQkA9wCbA7SASUBBYBdZBTR72pm/z695H5S/7E/+qf57/g3//EDgL4M3p6yFBZUBaBYcaiCGwySnwcdgGkIBEwHSsBXeRF3u2fpn/pFLwq/6nwf5D/If1L/n/9vGvjwspA8JhwDVACPgdwq4AUuDLEANIQCKwDCwGMY/sTd/nPtPvwzt/g/0V/17/g/9XZH/WAGWAFOBV0CEwb9UDowYUA+oCpgG8cj6V9EGv8PfyP21n2V/1L/7J/7e/AVAOpAwYV0HXgELgOFkCvhYgBioR8LoGvOEbv+nb/tNxsL/iX+uf+a/pADCy1x4gBXgV1C7YQkA9oBRgGUAFUQRWAlow86fZm76rf/Nk+jf7e/sb6x/+a+9/tUCVAV4EHAKnHuA8oBTYqAisAYvAWhiBm/ly+tz52f3s/i39Zf+L9X9P/td1gDNAhwHXAJtA7wFWAQYJOAe4HWDO3K4cozd88Bfu386kP+2v+B/r3/5f1wWANBD3AI6DdQjQA14FNi6Cz8M+cCkIkMFV6Av6X0L1q/xJ/8L+Ov7Z/ys7ATBhDyhqQCFAD4wScBOgArWBpvFcCh7uAb4WP/hvhJ/0D/YP9X83/c91gL6wgBYB1wAh0JbBQQIPToHUBBaBVYASwktj+Hjf+O3+h1/4Wf6wv+Lf9e/nf96sLf7TKugLgToE6IG2CiABNKAYKFSQlODvjO95bH2bX+5/eGzlT/pjf8d/rP+bP/913VeWYBEICnAI6DwQJLCRBjgXwF8XBfXY9rJ+oh/cr91f9k/8Hf+rt//p2/JFIIQAPWAJOAacA06CSgfZ9aH14S/zC/+Q/sH+rv979b9bwApYEAKWwNES0KkglgEcP/Iy8v7SyPle+7z5C39t/3r9W9M7gEsvBFQDMQQKCXAvoEMBOaAokBL4Xv2Cr/kY6MOf2T6BX/ZP8b/665/lFwKsgjkE6IEogfnwnqEJQhd8tggM3cQNP1m/J7/mMCf8pH+2f+e/+rd/ChmwCboGHALuAUvgtFCzDDBoABWUaVBPV1Ck/x78WvyFX+kf7K/6v/3Hf66/EKAGsgIUAkECaoKwD8Q20MWhRmkf2NP7nu2+mz/gl/0H/tn+d5L/TFgEVAMKgVoC844YUBlUUSC+/lVrYJPgjzPt5gK/7B/iv3/8/z7jPywCdQiMq4AkQBN832sbKEVgznx32ps9rR/4H/bfyf4Bv8o/23/0/52tf9BfvggQAvRAkMAYA4/nKphOrywCZGAh1AN6nD/S5+/fHh8H80f8pD/2T/W/6nf/Fi4CREAOAfdA3wYHCdAELQbYCKeYBNbBpoYu8Gnjm9j7mvnJ/hF/2/2c/k/a/y7e/Vugg0IBuQeCBAYNzA/bwYqjCCQDyYGXoIdzvv667cM80A/4Q/qb/33e/l2cLl2mkMDXQgJDDJAD24ELU8igGke+/5It3h/MX+D/WuLn0x/3twB2+ohgSQhkCbQTwelqqMeANLA/TCQygJCBzooeez44v4f/dNiLfjf/6dqnbf4J/5P8h3d/767+pYTlIcAqgAT6oVAxcEQDlIFEwIAUOfDSb4rGn3rwD/Rl/n7wAz/lX9j/9v/70z/cABQCjf+ggNADSIAmIAasgcf9bgspetoa2PBD/zQVPvB3+0fRx/xkP/hD+o/839n+d70A+k6IDMg9YAmwDBADgwZGEZAElkE9Js9PmvNH+NDH/GP1G3+yf+O/qg///uVQYMNTIgoB9UCQADEQNNBE8H0+nqNgxNdf1fi3Tt34x/l7gx/oY/6AX+kv+/+aNT/3cYUGVAMKgSSBb0iAGEADSQRNBXSB+MYXQ5k09gk+9DE/+L8F/LX9V/Xx339ZA/SAQqCUQNYAIphRweP+uDtMqQ3q4J8Ou+P+EfYz8BP9Cj/29/Z3d+/9LxoOMiEE1AOSgJpg1IBFgAq6Dh5+5gETfN89/3Am3/54q/xL8Ef6zv6M3/a/n0d/r9FADoFCAiwDioGuAYIAEeznJgN0cEY5t8uavrCdyU99sWyXTPPvv7/ZvrEHPtZv9GV+qh/8Lv/R/i/i8u+JcQhYAh9KCaABcoAgkAqQQRNCPVge9GKP9U2/wn8a47f9X1QEvNF/JJF7wBJwE1zSwCCCpoImA4SAFJoehhczz4Bv6Bt74DfrK/md/cIf0v/+nvz7mwNh7oFaAkkDiAAVIIPjnpn7NNAafuexo4f9AD/Qr/C/OvsPInAIlBKgCYgBaQARoAJkcNJBmz1a8MD9J3nQwx74oo/5yf4a/2uwvz87wmQJpBiwBgiC9xMqQAYIAS1ooA74hh72DT7WF/1kfuMn/V+J/fu/yU+KLJcAMSANjEnQVIAM0MHpFaZR7+BBD/vB+aKP+Zfjf4lXf0svBp8pgaCBJAJkgBDQQp7DGTvgQR/gB/oF/pD+L+v2rwiB50qAGEgaQASooM122vY5NC2E2TLTdhL7Dj/Rx/wL8d/vY9/XayBI4G2WADFgDVgE/n/6EMIZKow9E9wn/Rdlhg99mz/hp/xf8M3fM3qAqSVgDZwmfIH28NHtqRh/7hD2wMf6pl/hp/xJ/zX8x///dzgP1BJwDFgDiAAV9Cme6tfzxICPX8w20Jf5I/63rzH9YZ9XAUvAMWANIAJU0Mcf8sgDd8iLPfBFX+Y3fsqf3f8FH/2evBMqJOAYsAaiCPz1GzQbXuGz5aDP8E3f5s/4X8QjXz/aO6PchGEgCirit/c/b1VZaLCmT4sCBkL2uX9tINLMrmNDkwdSKOA2EB1AAp7gR4p7PQi60cN+wI/0Kf4a/wm7v9sACpCkgB0IEmCB7u9ZRfcehn2AL/oZ/zVU/8ff82N9vDeIArUDNAIksAWIUAfyZg98Sr+mD/4Tr/wienUBHLAC2QEkwAI8mFMxN3nYAz/RD8V/9iv/+zcH88UAbQAHkEAWoIFNcMwd9GYPfOhT/MbvS7/zXfg73hgKCtQOWAI/4r+OwYPe8Cn9SJ8rv1Pu+u7/vgipHUCCET313Q9+VeLTZ80e+Ln2PfOD/5zbfnXCvoDaAA5kCbCAbmARHD94GvKwd99n3gf/heLX3H+82z28MMwEpHIACWyB+gE+TEP5Ab0Kv6Cv4mfZf/x/9l0VlsO5DdgBS2ALhgckPiL+B+iAH+jFHviBvoq/6d+VvCSQA2oEWGANbIJj7mZv+pdAf+tl/z70YU1QOIAFSIAGiIANDMYI3CEPethH+uN0e8v3IQuyA6UE9sAqOMZu9hl+Tb83fXfvDWyVA7YgaVDH4DN76F8m+r3oX7YowIFCAjRABFSouQ/yQi/4I5H+Ob7puSTb+IkOWIJKA/kwDyWgD/DHafXEvyBxmxgH9LERFhQmFNxL9uz0z/T7s95nNwI74NngggTEIkgHIQe8w1vdln7X/vJkB5CAAMwm1OGAUPfAD/R74l/RCKgsO+BWgAbg3BleV+ynFV/X/tKwO7AhwURCFsgDKTFGTZ4Y/V+u59br/VfEDkDF6wNNDUV8dK57+n5v9a+NK8vTAXTQAJLAdIo/NXrYd99/YbwycCswqYh5HkTgE3xOobd63xe3AlGTCkX0EsrtO/cXPN4USo46zBoYo+NDMvq/0ZX/WbEGBLL1GAnoT3Afn6MFHCK0PSV+4f6I59MCEGBNlboTe1f9wbOhgiLa6dCu+sMlAJ1H+du+yPuGzEUboSu9vvuyNMb/8wthK+NxFL06BAAAAABJRU5ErkJggg==";

  /**
   * 扩散圆组件
   */
  /** @class */ ((function (_super) {
      __extends$6(RippleCircle, _super);
      function RippleCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, color: "rgba(255,0,0,1)", height: 0, duration: 3, image: CIRCLE_WHITE_IMAGE }, options), map) || this;
      }
      Object.defineProperty(RippleCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RippleCircle.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.RIPPLE }, this.options)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RippleCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RippleCircle;
  })(Component));

  /**
   * 旋转圆组件
   */
  /** @class */ ((function (_super) {
      __extends$6(RotateCircle, _super);
      function RotateCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, duration: 3, color: "rgba(255,255,255,1)", reverse: false }, options), map) || this;
      }
      Object.defineProperty(RotateCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RotateCircle.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.ROTATE }, this.options)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RotateCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RotateCircle;
  })(Component));

  /**
   * 右键菜单组件
   */
  /** @class */ ((function (_super) {
      __extends$6(ContextMenu, _super);
      function ContextMenu(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(ContextMenu.prototype, "autoClose", {
          get: function () {
              return this._autoClose;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "theme", {
          get: function () {
              return this._theme;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "target", {
          /**
           * 绑定对象
           *
           * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
           */
          get: function () {
              return this._target;
          },
          enumerable: false,
          configurable: true
      });
      ContextMenu.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var _a = this.options, theme = _a.theme, autoClose = _a.autoClose, list = _a.list, target = _a.target;
          if (!defined$1(this._autoClose)) {
              this._autoClose = defined$1(autoClose) ? autoClose : true;
          }
          if (!defined$1(this._theme)) {
              this._theme = theme || "dark";
          }
          if (!defined$1(this.target)) {
              this._target = target;
          }
          var pickLayers;
          this._overlay = new Overlay({
              element: createContextMenuElement({ list: list || [], theme: this._theme }, function (e) {
                  _this.dispatchEvent({
                      type: BaseEventType.CLICK,
                      item: list.find(function (val) { return String(val.id) === String(e.target.getAttribute("data-id")); }),
                      layers: pickLayers
                  });
                  if (_this._autoClose) {
                      _this.hide();
                  }
              }),
              useEvent: true
          });
          this._eventKey = this.map.on([BaseEventType.CLICK, BaseEventType.RIGHT_CLICK], function (_a) {
              var coordinate = _a.coordinate, type = _a.type, pixel = _a.pixel, layers = _a.layers;
              if (!defined$1(_this.map)) {
                  return;
              }
              if (type === BaseEventType.CLICK) {
                  if (_this._overlay.visible) {
                      _this.dispatchEvent({ type: BaseEventType.HIDE });
                  }
                  _this.hide();
              }
              else {
                  pickLayers = void 0;
                  if (_this.target) {
                      if (_this.target instanceof VectorLayer && !layers.find(function (i) { return i.layer === _this.target; })) {
                          return;
                      }
                      else if (_this.target instanceof Feature &&
                          !layers.find(function (_a) {
                              var features = _a.features;
                              return features.find(function (feature) { return feature === _this.target; }) !== void 0;
                          })) {
                          return;
                      }
                      else if (typeof _this.target === "function" && !_this.target({ pixel: pixel, coordinate: coordinate, layers: layers })) {
                          return;
                      }
                      else if (Array.isArray(_this.target) &&
                          _this.target[0] instanceof VectorLayer &&
                          !layers.find(function (_a) {
                              var layer = _a.layer;
                              return _this.target.find(function (i) { return i === layer; }) !== void 0;
                          })) {
                          return;
                      }
                      else if (Array.isArray(_this.target) &&
                          _this.target[0] instanceof Feature &&
                          !layers.find(function (_a) {
                              var features = _a.features;
                              return (_this.target.find(function (i) {
                                  return features.find(function (f) { return f === i; }) !== void 0;
                              }) !== void 0);
                          })) {
                          return;
                      }
                  }
                  pickLayers = layers;
                  _this.dispatchEvent({ type: BaseEventType.SHOW, coordinate: coordinate, pixel: pixel, layers: layers });
                  _this._overlay.setPosition(coordinate);
              }
          });
      };
      ContextMenu.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addOverlay(this._overlay);
      };
      /**
       * @ignore
       */
      ContextMenu.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeOverlay(this._overlay);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      ContextMenu.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          clearContextMenuElementEvent(this._overlay.element);
          this._overlay.destroy();
          this._overlay = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 关闭菜单
       */
      ContextMenu.prototype.hide = function () {
          this._overlay.setPosition();
          return this;
      };
      /**
       * 设置右键菜单主题
       */
      ContextMenu.prototype.setTheme = function (
      /**
       * 提示框样式主题
       *
       * 可选值:'dark','light'
       */
      theme) {
          this._overlay.element.classList.replace(this._theme, theme);
          this._theme = theme;
          return this;
      };
      /**
       * 设置绑定对象
       *
       * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
       */
      ContextMenu.prototype.setTarget = function (target) {
          this._target = target;
          this.options.target = target;
          return this;
      };
      /**
       * 设置弹窗是否自动关闭
       */
      ContextMenu.prototype.setAutoClose = function (autoClose) {
          this._autoClose = autoClose;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return ContextMenu;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Atmosphere, _super);
      function Atmosphere(options, map) {
          return _super.call(this, options, map) || this;
      }
      // 重写父类方法
      Atmosphere.prototype.init = function () { };
      /**
       * 清除修改、恢复修改之前的设置
       * @memberof Atmosphere
       * @instance
       */
      Atmosphere.prototype.remove = function () { };
      return Atmosphere;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Fire, _super);
      function Fire(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Fire.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Fire.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Fire.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Fire;
  })(Component));

  /**
   * @class Fountain
   */
  /** @class */ ((function (_super) {
      __extends$6(Fountain, _super);
      function Fountain(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Fountain.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Fountain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Fountain.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Fountain;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Light, _super);
      function Light(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Light.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Light.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Light.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Light;
  })(Component));

  /**

   * @export
   * @class Rain
   */
  /** @class */ ((function (_super) {
      __extends$6(Rain, _super);
      function Rain(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Rain.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Rain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Rain.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Rain;
  })(Component));

  /** @class */ ((function (_super) {
      __extends$6(Snow, _super);
      function Snow(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Snow.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Snow.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Snow.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snow;
  })(Component));

  function translation(options) {
      return __awaiter$8(this, void 0, void 0, function () {
          var _this = this;
          return __generator$1(this, function (_a) {
              return [2 /*return*/, new Promise(function (resolve) {
                      var target = options.target, oldCoordinates = options.coordinates, map = options.map, velocity = options.velocity, _a = options.duration, duration = _a === void 0 ? 5 : _a, callback = options.callback;
                      var coordinates = Array.isArray(oldCoordinates[0])
                          ? oldCoordinates
                          : [target.coordinates, oldCoordinates];
                      if (coordinates[0][0] === coordinates[1][0] && coordinates[0][1] === coordinates[1][1]) {
                          return;
                      }
                      // 构造geojson线---
                      var lineFeature = lineString(coordinates);
                      // 计算线的长度，单位米
                      var length = Turf__namespace.length(lineFeature) * 1000;
                      // 坐标是否含有高度----
                      var hasHeight = coordinates[0].length > 2;
                      var time = 0;
                      var distance = 0;
                      var previousTime = performance.now();
                      var eventKey = map.on(BaseEventType.POST_RENDER, function () {
                          if (_this.jobScheduler.paused) {
                              previousTime = performance.now();
                              return;
                          }
                          var currentTime = performance.now();
                          // 消耗的时间
                          var timeSpan = (currentTime - previousTime) / 1000;
                          var rate;
                          // 速度是否定义，定义计算距离-----
                          if (defined$1(velocity)) {
                              distance += timeSpan * velocity;
                              rate = distance / length;
                          }
                          else {
                              time += timeSpan;
                              rate = time / duration;
                          }
                          // 计算进度
                          rate = rate >= 1 ? 1 : rate;
                          var slicedLineFeature = Turf__namespace.lineSliceAlong(lineFeature, 0, (length * rate) / 1000);
                          var slicedCoordinates = slicedLineFeature.geometry.coordinates;
                          var newPointCoordinate = slicedCoordinates[slicedCoordinates.length - 1];
                          if (hasHeight) {
                              var _a = __read(coordinates[slicedCoordinates.length - 1], 3), lng1 = _a[0], lat1 = _a[1], height1 = _a[2];
                              var _b = __read(coordinates[slicedCoordinates.length - 2], 3), lng2 = _b[0], lat2 = _b[1], height2 = _b[2];
                              var _c = __read(slicedCoordinates[slicedCoordinates.length - 1], 2), lng3 = _c[0], lat3 = _c[1];
                              var newHeight = void 0;
                              if (lng1 === lng3 && lat1 === lat3) {
                                  newHeight = height1;
                              }
                              else {
                                  newHeight =
                                      height2 -
                                          (Turf__namespace.distance([lng2, lat2], [lng3, lat3]) / Turf__namespace.distance([lng2, lat2], [lng1, lat1])) *
                                              (height2 - height1);
                              }
                              newPointCoordinate[2] = newHeight;
                          }
                          // 要素移动
                          target.setCoordinates(newPointCoordinate);
                          // 回调是否定义
                          if (defined$1(callback)) {
                              callback({
                                  feature: target,
                                  startPosition: coordinates[slicedCoordinates.length - 2],
                                  endPosition: newPointCoordinate,
                                  map: map
                              });
                          }
                          // 要素分发事件
                          target.dispatchEvent({ type: BaseEventType.MOVE, progress: rate, position: newPointCoordinate });
                          previousTime = performance.now();
                          // 要素移动完成，注销事件监听，移动完成
                          if (rate >= 1) {
                              map.unByKey(eventKey);
                              // 要素分发移动完成事件
                              target.dispatchEvent({ type: BaseEventType.MOVE_END, progress: rate, position: newPointCoordinate });
                              //
                              resolve(void 0);
                          }
                          // 要素图层
                          // target.layer.layer[0]?.changed?.();
                      });
                      // target.layer.layer[0]?.changed?.();
                  })];
          });
      });
  }
  // 要素移动任务
  var FeatureTranslationTask = /** @class */ (function () {
      function FeatureTranslationTask(options) {
          this._options = options;
      }
      FeatureTranslationTask.prototype.run = function (previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              return __generator$1(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, translation.call(this, {
                              map: this.task._options.map,
                              target: this.task._options.target,
                              coordinates: this.task._options.coordinates,
                              duration: this.task._options.duration || 5,
                              callback: this.task._options.callback
                          })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/, {}];
                  }
              });
          });
      };
      return FeatureTranslationTask;
  }());
  var FeatureTranslationOverEventTask = /** @class */ (function () {
      function FeatureTranslationOverEventTask(options) {
          this._options = options;
      }
      // 指定的方法
      FeatureTranslationOverEventTask.prototype.run = function (
      // 上一个任务调用结果
      previousTaskResult) {
          return __awaiter$8(this, void 0, void 0, function () {
              var _this = this;
              return __generator$1(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve) {
                          _this.task._options.callback.call(_this.task._options.scope);
                          resolve({});
                      })];
              });
          });
      };
      return FeatureTranslationOverEventTask;
  }());

  /**
   * 移动任务队列组件
   */
  /** @class */ ((function (_super) {
      __extends$6(TranslationQueue, _super);
      function TranslationQueue(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(TranslationQueue.prototype, "jobScheduler", {
          get: function () {
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      TranslationQueue.prototype.init = function () {
          this.initialized = true;
          this._taskIdStore = {};
          this._jobScheduler = new JobScheduler();
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.stop();
          this.clearTask();
          this._jobScheduler = void 0;
          this._taskIdStore = void 0;
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      TranslationQueue.prototype.addTask = function (taskOptions) {
          var _this = this;
          if (this.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          var target = taskOptions.target, coordinates = taskOptions.coordinates, duration = taskOptions.duration;
          var jobSchedulerId = target.id + "-scheduler";
          var styleFunction = target.sourceFeature.getStyleFunction();
          if (!defined$1(styleFunction)) {
              styleFunction = target.sourceFeature[Symbol.for("FeatureLink")].layer.layer[0].getStyleFunction();
          }
          var olStyleList = styleFunction(target.sourceFeature, this.map.map.getView().getResolution());
          if (target.sourceFeature.getStyle() !== olStyleList) {
              target.sourceFeature.setStyle(olStyleList);
          }
          var callback = function (options) {
              olStyleList.forEach(function (i) {
                  if (i.getImage() instanceof OlIcon__default["default"] && i.getImage()[ICON_ROTATED]) {
                      i.getImage().setRotation(i.getImage()[ORIGINAL_ROTATION] +
                          computeRotationRadians(options.startPosition, options.endPosition) -
                          Math.PI * 0.5);
                  }
              });
          };
          var job = new BaseJob({
              tasks: [
                  new FeatureTranslationTask({
                      map: this.map,
                      target: target,
                      duration: duration,
                      coordinates: coordinates,
                      callback: callback
                  }),
                  new FeatureTranslationOverEventTask({
                      callback: function () {
                          _this._taskIdStore[job.id] = void 0;
                      }
                  })
              ]
          });
          this._jobScheduler.add(job, jobSchedulerId);
          this._taskIdStore[job.id] = jobSchedulerId;
          return job.id;
      };
      TranslationQueue.prototype.removeTask = function (taskId) {
          this._jobScheduler.remove(taskId, this._taskIdStore[taskId]);
          return this;
      };
      TranslationQueue.prototype.clearTask = function () {
          this.start();
          this._jobScheduler.clear();
          return this;
      };
      TranslationQueue.prototype.start = function () {
          this._jobScheduler.resume();
          return this;
      };
      TranslationQueue.prototype.stop = function () {
          this._jobScheduler.pause();
          return this;
      };
      return TranslationQueue;
  })(Component));

  var compassImg$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADHUlEQVRYR61XPUwUURCeeZzAvgdyRgsNUaC08KcyVnpESxPBymgIlP7EaIk2HIU/pcYYLSFEYyWaWJIAdnZcLCghMRALjCC7e3By+8zs7SN7597uvIsvueJ25818+30z780gMJfWOu/7/kUAGNJa9yNiPwDQj9aq1noVEVcB4KOUchERNzmuMcuoXC73B0EwAQBjjbbBVi2G6MknuZkSQkw6jkOgmq6mAOiLPc+bQMQHzXZ7s+/CV2r4RlqMopTyRTNGEgFEdM8DwNk0zxt3b4avj7x6m0XkkpRyMAnEPwBc16Wg84iYyKuJRPSvnR8I/x5f/pUFALTWpNdgV1fXUty4DkBE+0pWcHJQnvsMG/dGagy8nAHn8hUWCKXUQJyJfQBc2k2Un+O3wf/0Pvwrr16Hw89eZwKIDOrk2Afguu5zRLzP9bJ2rg+C7d+1KjjYA71fU5O90e2kUqpID0MAUamtcIPH6Td7uDIYeyHEAJVoCMDzvCkAGOUCiNNv9nSP3IL8o6dcF2Q3rZQaw0j77DSOuY7Tbx7nek/AsbmSDQCQUh5Cz/OGAGCWu/PP8jf4ce1CovnRD1/gwMlTXFdkN0wArOjffPIQtmfeJAZpRQZ0XXcBEemSYa31S6ehuv490dZWBq31IjFA9dPHiZ5Gv9lvKcMSAdCc4GSTRr/xkR9/DN2jd7guwQpAe3s75HK5VOd7e3tQqVSsALAlEEJAZ2dnqvOdnR0IgoALoGSdhI7jAGJyG6G1plOVG5xuyDAJrcowTQZb+uk0tD6I0mSwpL92ELVyFEspE2n2fZ9NPxkqpWpi/g8ZWqE/vIwIgO113NbWBh0dHXVfu7u7C9Vqlc1A3XUcsUANArXfrNUogyX99Q0JRYxyYQEAznAQxKvBkv6SlLJg+sKkppQmnJ4sEHEZuPRrrbeUUjRV7U9NzdpyuiEzQRgZOPRTcAAopLbl5qu5cphEJAYyVh3tcdvU0cz3fRrLmiamuZgoB1LWpJSSOu7EYZU7nFKFsJvWCMy0EKLY8nDa+EWRLIXYeE6jm6mYEo1esfGccog1nv8FXiaP6m5KLukAAAAASUVORK5CYII=";
  var OlCompass$1 = /** @class */ (function (_super) {
      __extends$6(OlCompass, _super);
      function OlCompass(options) {
          var _this = this;
          var imgElem = document.createElement("img");
          imgElem.src = compassImg$1;
          options = Object.assign({
              duration: 1000,
              label: imgElem,
              autoHide: false,
              width: 25,
              height: 25
          }, options);
          _this = _super.call(this, options) || this;
          _this.element.style.backgroundColor = "rgba(255,255,255,0)";
          _this.element.children[0].style.backgroundColor = "rgba(255,255,255,0)";
          _this.element.children[0].style.width = options.width + "px";
          _this.element.children[0].style.height = options.height + "px";
          return _this;
      }
      return OlCompass;
  }(Rotate__default["default"]));
  /**
   * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
   * `'nautical'`, `'metric'`, `'us'`.
   * @enum {string}
   */
  var Units$1 = {
      DEGREES: "degrees",
      IMPERIAL: "imperial",
      NAUTICAL: "nautical",
      METRIC: "metric",
      US: "us"
  };
  /**
   * @type {Array<number>}
   */
  var LEADING_DIGITS$1 = [1, 2, 5];
  /**
   * @description 比例尺类,继承自ol/control/ScaleLine重写dom更新方法
   * @author changqing
   * @class ScaleLineControl
   * @extends {ol/control/ScaleLine}
   */
  var ScaleLineControl$1 = /** @class */ (function (_super) {
      __extends$6(ScaleLineControl, _super);
      function ScaleLineControl(options) {
          var _this = this;
          options = Object.assign({}, options);
          var className = (options.className =
              options.className !== undefined ? options.className : "mti-gis-ol-scale-line");
          _this = _super.call(this, options) || this;
          _this._scaleTextElement = document.createElement("div");
          _this._scaleTextElement.className = className + "-text";
          _this._scaleTextElement.innerText = "100米";
          _this.innerElement_.className = className + "-inner";
          _this.innerElement_.appendChild(_this._scaleTextElement);
          _this._scaleLineElement = document.createElement("div");
          _this._scaleLineElement.className = className + "-line";
          _this.innerElement_.appendChild(_this._scaleLineElement);
          var leftElem = document.createElement("div");
          leftElem.className = className + "-edgeleft";
          _this._scaleLineElement.appendChild(leftElem);
          var rightElem = document.createElement("div");
          rightElem.className = className + "-edgeright";
          _this._scaleLineElement.appendChild(rightElem);
          var middleElem = document.createElement("div");
          middleElem.className = className + "-middle";
          _this._scaleLineElement.appendChild(middleElem);
          return _this;
      }
      /**
       * @override
       */
      ScaleLineControl.prototype.updateElement_ = function () {
          var viewState = this.viewState_;
          if (!viewState) {
              if (this.renderedVisible_) {
                  this.element.style.display = "none";
                  this.renderedVisible_ = false;
              }
              return;
          }
          var center = viewState.center;
          var projection = viewState.projection;
          var units = this.getUnits();
          var pointResolutionUnits = units === Units$1.DEGREES ? ProjUnits__default["default"].DEGREES : ProjUnits__default["default"].METERS;
          var pointResolution = proj.getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
          if (projection.getUnits() !== ProjUnits__default["default"].DEGREES &&
              projection.getMetersPerUnit() &&
              pointResolutionUnits === ProjUnits__default["default"].METERS) {
              pointResolution *= projection.getMetersPerUnit();
          }
          var nominalCount = this.minWidth_ * pointResolution;
          var suffix = "";
          if (units === Units$1.DEGREES) {
              var metersPerDegree = proj.METERS_PER_UNIT[ProjUnits__default["default"].DEGREES];
              if (projection.getUnits() === ProjUnits__default["default"].DEGREES) {
                  nominalCount *= metersPerDegree;
              }
              else {
                  pointResolution /= metersPerDegree;
              }
              if (nominalCount < metersPerDegree / 60) {
                  suffix = "\u2033"; // seconds
                  pointResolution *= 3600;
              }
              else if (nominalCount < metersPerDegree) {
                  suffix = "\u2032"; // minutes
                  pointResolution *= 60;
              }
              else {
                  suffix = "\u00b0"; // degrees
              }
          }
          else if (units === Units$1.IMPERIAL) {
              if (nominalCount < 0.9144) {
                  suffix = "in";
                  pointResolution /= 0.0254;
              }
              else if (nominalCount < 1609.344) {
                  suffix = "ft";
                  pointResolution /= 0.3048;
              }
              else {
                  suffix = "mi";
                  pointResolution /= 1609.344;
              }
          }
          else if (units === Units$1.NAUTICAL) {
              pointResolution /= 1852;
              suffix = "nm";
          }
          else if (units === Units$1.METRIC) {
              if (nominalCount < 0.001) {
                  suffix = "μm";
                  pointResolution *= 1000000;
              }
              else if (nominalCount < 1) {
                  suffix = "mm";
                  pointResolution *= 1000;
              }
              else if (nominalCount < 1000) {
                  suffix = "m";
              }
              else {
                  suffix = "km";
                  pointResolution /= 1000;
              }
          }
          else if (units === Units$1.US) {
              if (nominalCount < 0.9144) {
                  suffix = "in";
                  pointResolution *= 39.37;
              }
              else if (nominalCount < 1609.344) {
                  suffix = "ft";
                  pointResolution /= 0.30480061;
              }
              else {
                  suffix = "mi";
                  pointResolution /= 1609.3472;
              }
          }
          else ;
          var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));
          var count, width;
          while (true) {
              count = LEADING_DIGITS$1[((i % 3) + 3) % 3] * Math.pow(10, Math.floor(i / 3));
              width = Math.round(count / pointResolution);
              if (isNaN(width)) {
                  this.element.style.display = "none";
                  this.renderedVisible_ = false;
                  return;
              }
              else if (width >= this.minWidth_) {
                  break;
              }
              ++i;
          }
          var textE = this._scaleTextElement;
          // const leftE = this._scaleLineElement.children[0];
          var rightE = this._scaleLineElement.children[1];
          var middleE = this._scaleLineElement.children[2];
          var html = count + " " + suffix;
          if (this.renderedHTML_ !== html) {
              textE.innerHTML = html;
              this.renderedHTML_ = html;
          }
          if (this.renderedWidth_ !== width) {
              middleE.style.width = width - 4 + "px";
              rightE.style.left = width - 3 + "px";
              textE.style.width = width + "px";
              this.renderedWidth_ = width;
          }
          // if (!this.renderedVisible_) {
          //   this.element.style.display = '';
          //   this.renderedVisible_ = true;
          // }
      };
      return ScaleLineControl;
  }(OLScaleLine__default["default"]));
  /**
   * 罗盘组件
   */
  /** @class */ ((function (_super) {
      __extends$6(Compass, _super);
      function Compass(options, map) {
          return _super.call(this, __assign$1({ compass: true, scaleLine: true, zoom: true }, options), map) || this;
      }
      /**
       * 初始化
       * @ignore
       */
      Compass.prototype.init = function () {
          this.initialized = true;
          var _a = this.options, compass = _a.compass, scaleLine = _a.scaleLine, zoom = _a.zoom;
          this._controls = [];
          if (compass) {
              this._controls.push(new OlCompass$1({}));
          }
          if (scaleLine) {
              this._controls.push(new ScaleLineControl$1({}));
          }
          if (zoom) {
              this._controls.push(new Zoom__default["default"]());
          }
      };
      /**
       * @ignore
       * @param map
       */
      Compass.prototype.addTo = function (map) {
          var e_1, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._controls), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var control = _c.value;
                  this.map.map.addControl(control);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * 从地球移除
       * @ignore
       */
      Compass.prototype.remove = function (destroy) {
          var e_2, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._controls), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var control = _c.value;
                  this.map.map.removeControl(control);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Compass.prototype._destroy = function () {
          this.remove();
          this._controls = void 0;
          _super.prototype._destroy.call(this);
      };
      return Compass;
  })(Component));

  /**
   * 坐标信息组件
   */
  /** @class */ ((function (_super) {
      __extends$6(Coordinate, _super);
      function Coordinate(options, map) {
          return _super.call(this, options, map) || this;
      }
      /**
       * @ignore
       */
      Coordinate.prototype.init = function () {
          var _this = this;
          var _a = this._options, className = _a.className, text = _a.text, style = _a.style;
          var globe = this.map;
          var template = text || "经度:{longitude}° 纬度:{latitude}°";
          var coordsDom = document.createElement("span");
          var tem = document.createElement("div");
          this._component = tem;
          tem.append(coordsDom);
          tem.classList.add("gis-widget-coordinate");
          className && tem.classList.add(className);
          Object.assign(tem.style, style);
          this._eventKey = globe.map.on("pointermove", function (e) {
              if (!defined$1(_this.map)) {
                  return;
              }
              var pixel = e.pixel;
              var _a = __read(transformToDataProjection(globe.map.getCoordinateFromPixel(pixel)), 2), longitude = _a[0], latitude = _a[1];
              if (longitude && latitude) {
                  coordsDom.innerText = template
                      .replace(new RegExp("{longitude}", "g"), longitude.toFixed(4))
                      .replace(new RegExp("{latitude}", "g"), latitude.toFixed(4));
              }
          });
          this.initialized = true;
      };
      /**
       * 添加到地球
       * @ignore
       */
      Coordinate.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this.map.map.getViewport().append(this._component);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Coordinate.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.getViewport().removeChild(this._component);
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Coordinate.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          this._component = void 0;
          _super.prototype._destroy.call(this);
      };
      return Coordinate;
  })(Component));

  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  // Computes the bounding box of the specified hash of GeoJSON objects.
  function bounds(objects) {
    var x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    function boundGeometry(geometry) {
      if (geometry != null && hasOwnProperty$2.call(boundGeometryType, geometry.type)) boundGeometryType[geometry.type](geometry);
    }

    var boundGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },
      Point: function(o) { boundPoint(o.coordinates); },
      MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },
      LineString: function(o) { boundLine(o.arcs); },
      MultiLineString: function(o) { o.arcs.forEach(boundLine); },
      Polygon: function(o) { o.arcs.forEach(boundLine); },
      MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }
    };

    function boundPoint(coordinates) {
      var x = coordinates[0],
          y = coordinates[1];
      if (x < x0) x0 = x;
      if (x > x1) x1 = x;
      if (y < y0) y0 = y;
      if (y > y1) y1 = y;
    }

    function boundLine(coordinates) {
      coordinates.forEach(boundPoint);
    }

    function boundMultiLine(coordinates) {
      coordinates.forEach(boundLine);
    }

    for (var key in objects) {
      boundGeometry(objects[key]);
    }

    return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;
  }

  function hashset(size, hash, equal, type, empty) {
    if (arguments.length === 3) {
      type = Array;
      empty = null;
    }

    var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
        mask = size - 1;

    for (var i = 0; i < size; ++i) {
      store[i] = empty;
    }

    function add(value) {
      var index = hash(value) & mask,
          match = store[index],
          collisions = 0;
      while (match != empty) {
        if (equal(match, value)) return true;
        if (++collisions >= size) throw new Error("full hashset");
        match = store[index = (index + 1) & mask];
      }
      store[index] = value;
      return true;
    }

    function has(value) {
      var index = hash(value) & mask,
          match = store[index],
          collisions = 0;
      while (match != empty) {
        if (equal(match, value)) return true;
        if (++collisions >= size) break;
        match = store[index = (index + 1) & mask];
      }
      return false;
    }

    function values() {
      var values = [];
      for (var i = 0, n = store.length; i < n; ++i) {
        var match = store[i];
        if (match != empty) values.push(match);
      }
      return values;
    }

    return {
      add: add,
      has: has,
      values: values
    };
  }

  function hashmap(size, hash, equal, keyType, keyEmpty, valueType) {
    if (arguments.length === 3) {
      keyType = valueType = Array;
      keyEmpty = null;
    }

    var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),
        valstore = new valueType(size),
        mask = size - 1;

    for (var i = 0; i < size; ++i) {
      keystore[i] = keyEmpty;
    }

    function set(key, value) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index] = value;
        if (++collisions >= size) throw new Error("full hashmap");
        matchKey = keystore[index = (index + 1) & mask];
      }
      keystore[index] = key;
      valstore[index] = value;
      return value;
    }

    function maybeSet(key, value) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index];
        if (++collisions >= size) throw new Error("full hashmap");
        matchKey = keystore[index = (index + 1) & mask];
      }
      keystore[index] = key;
      valstore[index] = value;
      return value;
    }

    function get(key, missingValue) {
      var index = hash(key) & mask,
          matchKey = keystore[index],
          collisions = 0;
      while (matchKey != keyEmpty) {
        if (equal(matchKey, key)) return valstore[index];
        if (++collisions >= size) break;
        matchKey = keystore[index = (index + 1) & mask];
      }
      return missingValue;
    }

    function keys() {
      var keys = [];
      for (var i = 0, n = keystore.length; i < n; ++i) {
        var matchKey = keystore[i];
        if (matchKey != keyEmpty) keys.push(matchKey);
      }
      return keys;
    }

    return {
      set: set,
      maybeSet: maybeSet, // set if unset
      get: get,
      keys: keys
    };
  }

  function equalPoint(pointA, pointB) {
    return pointA[0] === pointB[0] && pointA[1] === pointB[1];
  }

  // TODO if quantized, use simpler Int32 hashing?

  var buffer = new ArrayBuffer(16),
      floats = new Float64Array(buffer),
      uints = new Uint32Array(buffer);

  function hashPoint(point) {
    floats[0] = point[0];
    floats[1] = point[1];
    var hash = uints[0] ^ uints[1];
    hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];
    return hash & 0x7fffffff;
  }

  // Given an extracted (pre-)topology, identifies all of the junctions. These are
  // the points at which arcs (lines or rings) will need to be cut so that each
  // arc is represented uniquely.
  //
  // A junction is a point where at least one arc deviates from another arc going
  // through the same point. For example, consider the point B. If there is a arc
  // through ABC and another arc through CBA, then B is not a junction because in
  // both cases the adjacent point pairs are {A,C}. However, if there is an
  // additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.
  //
  // For a closed ring ABCA, the first point A’s adjacent points are the second
  // and last point {B,C}. For a line, the first and last point are always
  // considered junctions, even if the line is closed; this ensures that a closed
  // line is never rotated.
  function join(topology) {
    var coordinates = topology.coordinates,
        lines = topology.lines,
        rings = topology.rings,
        indexes = index(),
        visitedByIndex = new Int32Array(coordinates.length),
        leftByIndex = new Int32Array(coordinates.length),
        rightByIndex = new Int32Array(coordinates.length),
        junctionByIndex = new Int8Array(coordinates.length),
        junctionCount = 0, // upper bound on number of junctions
        i, n,
        previousIndex,
        currentIndex,
        nextIndex;

    for (i = 0, n = coordinates.length; i < n; ++i) {
      visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;
    }

    for (i = 0, n = lines.length; i < n; ++i) {
      var line = lines[i],
          lineStart = line[0],
          lineEnd = line[1];
      currentIndex = indexes[lineStart];
      nextIndex = indexes[++lineStart];
      ++junctionCount, junctionByIndex[currentIndex] = 1; // start
      while (++lineStart <= lineEnd) {
        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);
      }
      ++junctionCount, junctionByIndex[nextIndex] = 1; // end
    }

    for (i = 0, n = coordinates.length; i < n; ++i) {
      visitedByIndex[i] = -1;
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      var ring = rings[i],
          ringStart = ring[0] + 1,
          ringEnd = ring[1];
      previousIndex = indexes[ringEnd - 1];
      currentIndex = indexes[ringStart - 1];
      nextIndex = indexes[ringStart];
      sequence(i, previousIndex, currentIndex, nextIndex);
      while (++ringStart <= ringEnd) {
        sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);
      }
    }

    function sequence(i, previousIndex, currentIndex, nextIndex) {
      if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection
      visitedByIndex[currentIndex] = i;
      var leftIndex = leftByIndex[currentIndex];
      if (leftIndex >= 0) {
        var rightIndex = rightByIndex[currentIndex];
        if ((leftIndex !== previousIndex || rightIndex !== nextIndex)
          && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {
          ++junctionCount, junctionByIndex[currentIndex] = 1;
        }
      } else {
        leftByIndex[currentIndex] = previousIndex;
        rightByIndex[currentIndex] = nextIndex;
      }
    }

    function index() {
      var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),
          indexes = new Int32Array(coordinates.length);

      for (var i = 0, n = coordinates.length; i < n; ++i) {
        indexes[i] = indexByPoint.maybeSet(i, i);
      }

      return indexes;
    }

    function hashIndex(i) {
      return hashPoint(coordinates[i]);
    }

    function equalIndex(i, j) {
      return equalPoint(coordinates[i], coordinates[j]);
    }

    visitedByIndex = leftByIndex = rightByIndex = null;

    var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;

    // Convert back to a standard hashset by point for caller convenience.
    for (i = 0, n = coordinates.length; i < n; ++i) {
      if (junctionByIndex[j = indexes[i]]) {
        junctionByPoint.add(coordinates[j]);
      }
    }

    return junctionByPoint;
  }

  // Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared
  // point sequences are identified. The topology can then be subsequently deduped
  // to remove exact duplicate arcs.
  function cut(topology) {
    var junctions = join(topology),
        coordinates = topology.coordinates,
        lines = topology.lines,
        rings = topology.rings,
        next,
        i, n;

    for (i = 0, n = lines.length; i < n; ++i) {
      var line = lines[i],
          lineMid = line[0],
          lineEnd = line[1];
      while (++lineMid < lineEnd) {
        if (junctions.has(coordinates[lineMid])) {
          next = {0: lineMid, 1: line[1]};
          line[1] = lineMid;
          line = line.next = next;
        }
      }
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      var ring = rings[i],
          ringStart = ring[0],
          ringMid = ringStart,
          ringEnd = ring[1],
          ringFixed = junctions.has(coordinates[ringStart]);
      while (++ringMid < ringEnd) {
        if (junctions.has(coordinates[ringMid])) {
          if (ringFixed) {
            next = {0: ringMid, 1: ring[1]};
            ring[1] = ringMid;
            ring = ring.next = next;
          } else { // For the first junction, we can rotate rather than cut.
            rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);
            coordinates[ringEnd] = coordinates[ringStart];
            ringFixed = true;
            ringMid = ringStart; // restart; we may have skipped junctions
          }
        }
      }
    }

    return topology;
  }

  function rotateArray(array, start, end, offset) {
    reverse$1(array, start, end);
    reverse$1(array, start, start + offset);
    reverse$1(array, start + offset, end);
  }

  function reverse$1(array, start, end) {
    for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {
      t = array[start], array[start] = array[end], array[end] = t;
    }
  }

  // Given a cut topology, combines duplicate arcs.
  function dedup(topology) {
    var coordinates = topology.coordinates,
        lines = topology.lines, line,
        rings = topology.rings, ring,
        arcCount = lines.length + rings.length,
        i, n;

    delete topology.lines;
    delete topology.rings;

    // Count the number of (non-unique) arcs to initialize the hashmap safely.
    for (i = 0, n = lines.length; i < n; ++i) {
      line = lines[i]; while (line = line.next) ++arcCount;
    }
    for (i = 0, n = rings.length; i < n; ++i) {
      ring = rings[i]; while (ring = ring.next) ++arcCount;
    }

    var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),
        arcs = topology.arcs = [];

    for (i = 0, n = lines.length; i < n; ++i) {
      line = lines[i];
      do {
        dedupLine(line);
      } while (line = line.next);
    }

    for (i = 0, n = rings.length; i < n; ++i) {
      ring = rings[i];
      if (ring.next) { // arc is no longer closed
        do {
          dedupLine(ring);
        } while (ring = ring.next);
      } else {
        dedupRing(ring);
      }
    }

    function dedupLine(arc) {
      var startPoint,
          endPoint,
          startArcs, startArc,
          endArcs, endArc,
          i, n;

      // Does this arc match an existing arc in order?
      if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {
        for (i = 0, n = startArcs.length; i < n; ++i) {
          startArc = startArcs[i];
          if (equalLine(startArc, arc)) {
            arc[0] = startArc[0];
            arc[1] = startArc[1];
            return;
          }
        }
      }

      // Does this arc match an existing arc in reverse order?
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (reverseEqualLine(endArc, arc)) {
            arc[1] = endArc[0];
            arc[0] = endArc[1];
            return;
          }
        }
      }

      if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);
      if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
      arcs.push(arc);
    }

    function dedupRing(arc) {
      var endPoint,
          endArcs,
          endArc,
          i, n;

      // Does this arc match an existing line in order, or reverse order?
      // Rings are closed, so their start point and end point is the same.
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (equalRing(endArc, arc)) {
            arc[0] = endArc[0];
            arc[1] = endArc[1];
            return;
          }
          if (reverseEqualRing(endArc, arc)) {
            arc[0] = endArc[1];
            arc[1] = endArc[0];
            return;
          }
        }
      }

      // Otherwise, does this arc match an existing ring in order, or reverse order?
      if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {
        for (i = 0, n = endArcs.length; i < n; ++i) {
          endArc = endArcs[i];
          if (equalRing(endArc, arc)) {
            arc[0] = endArc[0];
            arc[1] = endArc[1];
            return;
          }
          if (reverseEqualRing(endArc, arc)) {
            arc[0] = endArc[1];
            arc[1] = endArc[0];
            return;
          }
        }
      }

      if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);
      arcs.push(arc);
    }

    function equalLine(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1];
      if (ia - ja !== ib - jb) return false;
      for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;
      return true;
    }

    function reverseEqualLine(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1];
      if (ia - ja !== ib - jb) return false;
      for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;
      return true;
    }

    function equalRing(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1],
          n = ja - ia;
      if (n !== jb - ib) return false;
      var ka = findMinimumOffset(arcA),
          kb = findMinimumOffset(arcB);
      for (var i = 0; i < n; ++i) {
        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;
      }
      return true;
    }

    function reverseEqualRing(arcA, arcB) {
      var ia = arcA[0], ib = arcB[0],
          ja = arcA[1], jb = arcB[1],
          n = ja - ia;
      if (n !== jb - ib) return false;
      var ka = findMinimumOffset(arcA),
          kb = n - findMinimumOffset(arcB);
      for (var i = 0; i < n; ++i) {
        if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;
      }
      return true;
    }

    // Rings are rotated to a consistent, but arbitrary, start point.
    // This is necessary to detect when a ring and a rotated copy are dupes.
    function findMinimumOffset(arc) {
      var start = arc[0],
          end = arc[1],
          mid = start,
          minimum = mid,
          minimumPoint = coordinates[mid];
      while (++mid < end) {
        var point = coordinates[mid];
        if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {
          minimum = mid;
          minimumPoint = point;
        }
      }
      return minimum - start;
    }

    return topology;
  }

  // Given an array of arcs in absolute (but already quantized!) coordinates,
  // converts to fixed-point delta encoding.
  // This is a destructive operation that modifies the given arcs!
  function delta(arcs) {
    var i = -1,
        n = arcs.length;

    while (++i < n) {
      var arc = arcs[i],
          j = 0,
          k = 1,
          m = arc.length,
          point = arc[0],
          x0 = point[0],
          y0 = point[1],
          x1,
          y1;

      while (++j < m) {
        point = arc[j], x1 = point[0], y1 = point[1];
        if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;
      }

      if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.

      arc.length = k;
    }

    return arcs;
  }

  // Extracts the lines and rings from the specified hash of geometry objects.
  //
  // Returns an object with three properties:
  //
  // * coordinates - shared buffer of [x, y] coordinates
  // * lines - lines extracted from the hash, of the form [start, end]
  // * rings - rings extracted from the hash, of the form [start, end]
  //
  // For each ring or line, start and end represent inclusive indexes into the
  // coordinates buffer. For rings (and closed lines), coordinates[start] equals
  // coordinates[end].
  //
  // For each line or polygon geometry in the input hash, including nested
  // geometries as in geometry collections, the `coordinates` array is replaced
  // with an equivalent `arcs` array that, for each line (for line string
  // geometries) or ring (for polygon geometries), points to one of the above
  // lines or rings.
  function extract(objects) {
    var index = -1,
        lines = [],
        rings = [],
        coordinates = [];

    function extractGeometry(geometry) {
      if (geometry && hasOwnProperty$2.call(extractGeometryType, geometry.type)) extractGeometryType[geometry.type](geometry);
    }

    var extractGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },
      LineString: function(o) { o.arcs = extractLine(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },
      Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }
    };

    function extractLine(line) {
      for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];
      var arc = {0: index - n + 1, 1: index};
      lines.push(arc);
      return arc;
    }

    function extractRing(ring) {
      for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];
      var arc = {0: index - n + 1, 1: index};
      rings.push(arc);
      return arc;
    }

    function extractMultiRing(rings) {
      return rings.map(extractRing);
    }

    for (var key in objects) {
      extractGeometry(objects[key]);
    }

    return {
      type: "Topology",
      coordinates: coordinates,
      lines: lines,
      rings: rings,
      objects: objects
    };
  }

  // Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.
  // Any null input geometry objects are represented as {type: null} in the output.
  // Any feature.{id,properties,bbox} are transferred to the output geometry object.
  // Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!
  function geometry(inputs) {
    var outputs = {}, key;
    for (key in inputs) outputs[key] = geomifyObject(inputs[key]);
    return outputs;
  }

  function geomifyObject(input) {
    return input == null ? {type: null}
        : (input.type === "FeatureCollection" ? geomifyFeatureCollection
        : input.type === "Feature" ? geomifyFeature
        : geomifyGeometry)(input);
  }

  function geomifyFeatureCollection(input) {
    var output = {type: "GeometryCollection", geometries: input.features.map(geomifyFeature)};
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  function geomifyFeature(input) {
    var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    for (key in input.properties) { output.properties = input.properties; break; }
    return output;
  }

  function geomifyGeometry(input) {
    if (input == null) return {type: null};
    var output = input.type === "GeometryCollection" ? {type: "GeometryCollection", geometries: input.geometries.map(geomifyGeometry)}
        : input.type === "Point" || input.type === "MultiPoint" ? {type: input.type, coordinates: input.coordinates}
        : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?
    if (input.bbox != null) output.bbox = input.bbox;
    return output;
  }

  function prequantize(objects, bbox, n) {
    var x0 = bbox[0],
        y0 = bbox[1],
        x1 = bbox[2],
        y1 = bbox[3],
        kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,
        ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;

    function quantizePoint(input) {
      return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];
    }

    function quantizePoints(input, m) {
      var i = -1,
          j = 0,
          n = input.length,
          output = new Array(n), // pessimistic
          pi,
          px,
          py,
          x,
          y;

      while (++i < n) {
        pi = input[i];
        x = Math.round((pi[0] - x0) * kx);
        y = Math.round((pi[1] - y0) * ky);
        if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points
      }

      output.length = j;
      while (j < m) j = output.push([output[0][0], output[0][1]]);
      return output;
    }

    function quantizeLine(input) {
      return quantizePoints(input, 2);
    }

    function quantizeRing(input) {
      return quantizePoints(input, 4);
    }

    function quantizePolygon(input) {
      return input.map(quantizeRing);
    }

    function quantizeGeometry(o) {
      if (o != null && hasOwnProperty$2.call(quantizeGeometryType, o.type)) quantizeGeometryType[o.type](o);
    }

    var quantizeGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },
      Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },
      MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },
      LineString: function(o) { o.arcs = quantizeLine(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },
      Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }
    };

    for (var key in objects) {
      quantizeGeometry(objects[key]);
    }

    return {
      scale: [1 / kx, 1 / ky],
      translate: [x0, y0]
    };
  }

  // Constructs the TopoJSON Topology for the specified hash of features.
  // Each object in the specified hash must be a GeoJSON object,
  // meaning FeatureCollection, a Feature or a geometry object.
  function topology(objects, quantization) {
    var bbox = bounds(objects = geometry(objects)),
        transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),
        topology = dedup(cut(extract(objects))),
        coordinates = topology.coordinates,
        indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);

    objects = topology.objects; // for garbage collection
    topology.bbox = bbox;
    topology.arcs = topology.arcs.map(function(arc, i) {
      indexByArc.set(arc, i);
      return coordinates.slice(arc[0], arc[1] + 1);
    });

    delete topology.coordinates;
    coordinates = null;

    function indexGeometry(geometry) {
      if (geometry && hasOwnProperty$2.call(indexGeometryType, geometry.type)) indexGeometryType[geometry.type](geometry);
    }

    var indexGeometryType = {
      GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },
      LineString: function(o) { o.arcs = indexArcs(o.arcs); },
      MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },
      Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },
      MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }
    };

    function indexArcs(arc) {
      var indexes = [];
      do {
        var index = indexByArc.get(arc);
        indexes.push(arc[0] < arc[1] ? index : ~index);
      } while (arc = arc.next);
      return indexes;
    }

    function indexMultiArcs(arcs) {
      return arcs.map(indexArcs);
    }

    for (var key in objects) {
      indexGeometry(objects[key]);
    }

    if (transform) {
      topology.transform = transform;
      topology.arcs = delta(topology.arcs);
    }

    return topology;
  }

  function hashArc(arc) {
    var i = arc[0], j = arc[1], t;
    if (j < i) t = i, i = j, j = t;
    return i + 31 * j;
  }

  function equalArc(arcA, arcB) {
    var ia = arcA[0], ja = arcA[1],
        ib = arcB[0], jb = arcB[1], t;
    if (ja < ia) t = ia, ia = ja, ja = t;
    if (jb < ib) t = ib, ib = jb, jb = t;
    return ia === ib && ja === jb;
  }

  var src$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    topology: topology
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(src$1);

  function identity(x) {
    return x;
  }

  function transform$2(transform) {
    if (transform == null) return identity;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2, n = input.length, output = new Array(n);
      output[0] = (x0 += input[0]) * kx + dx;
      output[1] = (y0 += input[1]) * ky + dy;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function bbox(topology) {
    var t = transform$2(topology.transform), key,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    function bboxPoint(p) {
      p = t(p);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }

    function bboxGeometry(o) {
      switch (o.type) {
        case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
        case "Point": bboxPoint(o.coordinates); break;
        case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
      }
    }

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length, p;
      while (++i < n) {
        p = t(arc[i], i);
        if (p[0] < x0) x0 = p[0];
        if (p[0] > x1) x1 = p[0];
        if (p[1] < y0) y0 = p[1];
        if (p[1] > y1) y1 = p[1];
      }
    });

    for (key in topology.objects) {
      bboxGeometry(topology.objects[key]);
    }

    return [x0, y0, x1, y1];
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n;
    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function feature(topology, o) {
    if (typeof o === "string") o = topology.objects[o];
    return o.type === "GeometryCollection"
        ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
        : feature$1(topology, o);
  }

  function feature$1(topology, o) {
    var id = o.id,
        bbox = o.bbox,
        properties = o.properties == null ? {} : o.properties,
        geometry = object(topology, o);
    return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
        : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
        : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
  }

  function object(topology, o) {
    var transformPoint = transform$2(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
        points.push(transformPoint(a[k], k));
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      return transformPoint(p);
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var type = o.type, coordinates;
      switch (type) {
        case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
        case "Point": coordinates = point(o.coordinates); break;
        case "MultiPoint": coordinates = o.coordinates.map(point); break;
        case "LineString": coordinates = line(o.arcs); break;
        case "MultiLineString": coordinates = o.arcs.map(line); break;
        case "Polygon": coordinates = polygon(o.arcs); break;
        case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
        default: return null;
      }
      return {type: type, coordinates: coordinates};
    }

    return geometry(o);
  }

  function stitch(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function mesh(topology) {
    return object(topology, meshArcs.apply(this, arguments));
  }

  function meshArcs(topology, object, filter) {
    var arcs, i, n;
    if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
    else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
    return {type: "MultiLineString", arcs: stitch(topology, arcs)};
  }

  function extractArcs(topology, object, filter) {
    var arcs = [],
        geomsByArc = [],
        geom;

    function extract0(i) {
      var j = i < 0 ? ~i : i;
      (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
    }

    function extract1(arcs) {
      arcs.forEach(extract0);
    }

    function extract2(arcs) {
      arcs.forEach(extract1);
    }

    function extract3(arcs) {
      arcs.forEach(extract2);
    }

    function geometry(o) {
      switch (geom = o, o.type) {
        case "GeometryCollection": o.geometries.forEach(geometry); break;
        case "LineString": extract1(o.arcs); break;
        case "MultiLineString": case "Polygon": extract2(o.arcs); break;
        case "MultiPolygon": extract3(o.arcs); break;
      }
    }

    geometry(object);

    geomsByArc.forEach(filter == null
        ? function(geoms) { arcs.push(geoms[0].i); }
        : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

    return arcs;
  }

  function planarRingArea(ring) {
    var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
    while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
    return Math.abs(area); // Note: doubled area!
  }

  function merge$2(topology) {
    return object(topology, mergeArcs.apply(this, arguments));
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        groups = [];

    objects.forEach(geometry);

    function geometry(o) {
      switch (o.type) {
        case "GeometryCollection": o.geometries.forEach(geometry); break;
        case "Polygon": extract(o.arcs); break;
        case "MultiPolygon": o.arcs.forEach(extract); break;
      }
    }

    function extract(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function area(ring) {
      return planarRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var group = [],
            neighbors = [polygon];
        polygon._ = 1;
        groups.push(group);
        while (polygon = neighbors.pop()) {
          group.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: groups.map(function(polygons) {
        var arcs = [], n;

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitch(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // choose the one with the greatest absolute area.
        if ((n = arcs.length) > 1) {
          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
            if ((ki = area(arcs[i])) > k) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
            }
          }
        }

        return arcs;
      }).filter(function(arcs) {
        return arcs.length > 0;
      })
    };
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function untransform(transform) {
    if (transform == null) return identity;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(input, i) {
      if (!i) x0 = y0 = 0;
      var j = 2,
          n = input.length,
          output = new Array(n),
          x1 = Math.round((input[0] - dx) / kx),
          y1 = Math.round((input[1] - dy) / ky);
      output[0] = x1 - x0, x0 = x1;
      output[1] = y1 - y0, y0 = y1;
      while (j < n) output[j] = input[j], ++j;
      return output;
    };
  }

  function quantize(topology, transform) {
    if (topology.transform) throw new Error("already quantized");

    if (!transform || !transform.scale) {
      if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
      box = topology.bbox || bbox(topology);
      var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
      transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
    } else {
      box = topology.bbox;
    }

    var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};

    function quantizePoint(point) {
      return t(point);
    }

    function quantizeGeometry(input) {
      var output;
      switch (input.type) {
        case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
        case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
        case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
        default: return input;
      }
      if (input.id != null) output.id = input.id;
      if (input.bbox != null) output.bbox = input.bbox;
      if (input.properties != null) output.properties = input.properties;
      return output;
    }

    function quantizeArc(input) {
      var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
      output[0] = t(input[0], 0);
      while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
      if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
      output.length = j;
      return output;
    }

    for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

    return {
      type: "Topology",
      bbox: box,
      transform: transform,
      objects: outputs,
      arcs: topology.arcs.map(quantizeArc)
    };
  }

  var src = /*#__PURE__*/Object.freeze({
    __proto__: null,
    bbox: bbox,
    feature: feature,
    mesh: mesh,
    meshArcs: meshArcs,
    merge: merge$2,
    mergeArcs: mergeArcs,
    neighbors: neighbors,
    quantize: quantize,
    transform: transform$2,
    untransform: untransform
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(src);

  var geojsonLinestringDissolve = mergeViableLineStrings;

  // [Number, Number] -> String
  function coordId (coord) {
    return coord[0].toString() + ',' + coord[1].toString()
  }

  // LineString, LineString -> LineString
  function mergeLineStrings (a, b) {
    var s1 = coordId(a.coordinates[0]);
    var e1 = coordId(a.coordinates[a.coordinates.length - 1]);
    var s2 = coordId(b.coordinates[0]);
    var e2 = coordId(b.coordinates[b.coordinates.length - 1]);

    // TODO: handle case where more than one of these is true!

    var coords;
    if (s1 === e2) {
      coords = b.coordinates.concat(a.coordinates.slice(1));
    } else if (s2 === e1) {
      coords = a.coordinates.concat(b.coordinates.slice(1));
    } else if (s1 === s2) {
      coords = a.coordinates.slice(1).reverse().concat(b.coordinates);
    } else if (e1 === e2) {
      coords = a.coordinates.concat(b.coordinates.reverse().slice(1));
    } else {
      return null
    }

    return {
      type: 'LineString',
      coordinates: coords
    }
  }

  // Merges all connected (non-forking, non-junctioning) line strings into single
  // line strings.
  // [LineString] -> LineString|MultiLineString
  function mergeViableLineStrings (geoms) {
    // TODO: assert all are linestrings

    var lineStrings = geoms.slice();
    var result = [];
    while (lineStrings.length > 0) {
      var ls = lineStrings.shift();

      // Attempt to merge this LineString with the other LineStrings, updating
      // the reference as it is merged with others and grows.
      lineStrings = lineStrings.reduce(function (accum, cur) {
        var merged = mergeLineStrings(ls, cur);
        if (merged) {
          // Accumulate the merged LineString
          ls = merged;
        } else {
          // Put the unmerged LineString back into the list
          accum.push(cur);
        }
        return accum
      }, []);

      result.push(ls);
    }

    if (result.length === 1) {
      result = result[0];
    } else {
      result = {
        type: 'MultiLineString',
        coordinates: result.map(function (ls) { return ls.coordinates })
      };
    }
    return result
  }

  var meta = {};

  /**
   * Callback for coordEach
   *
   * @private
   * @callback coordEachCallback
   * @param {[number, number]} currentCoords The current coordinates being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
   *
   * @name coordEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentCoords, currentIndex)
   * @param {boolean} [excludeWrapCoord=false] whether or not to include
   * the final coordinate of LinearRings that wraps the ring in its iteration.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.coordEach(features, function (currentCoords, currentIndex) {
   *   //=currentCoords
   *   //=currentIndex
   * });
   */
  function coordEach(layer, callback, excludeWrapCoord) {
      var i, j, k, g, l, geometry, stopG, coords,
          geometryMaybeCollection,
          wrapShrink = 0,
          currentIndex = 0,
          isGeometryCollection,
          isFeatureCollection = layer.type === 'FeatureCollection',
          isFeature = layer.type === 'Feature',
          stop = isFeatureCollection ? layer.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
      for (i = 0; i < stop; i++) {

          geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
          (isFeature ? layer.geometry : layer));
          isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (g = 0; g < stopG; g++) {
              geometry = isGeometryCollection ?
              geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
              coords = geometry.coordinates;

              wrapShrink = (excludeWrapCoord &&
                  (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                  1 : 0;

              if (geometry.type === 'Point') {
                  callback(coords, currentIndex);
                  currentIndex++;
              } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                  for (j = 0; j < coords.length; j++) {
                      callback(coords[j], currentIndex);
                      currentIndex++;
                  }
              } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                  for (j = 0; j < coords.length; j++)
                      for (k = 0; k < coords[j].length - wrapShrink; k++) {
                          callback(coords[j][k], currentIndex);
                          currentIndex++;
                      }
              } else if (geometry.type === 'MultiPolygon') {
                  for (j = 0; j < coords.length; j++)
                      for (k = 0; k < coords[j].length; k++)
                          for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                              callback(coords[j][k][l], currentIndex);
                              currentIndex++;
                          }
              } else if (geometry.type === 'GeometryCollection') {
                  for (j = 0; j < geometry.geometries.length; j++)
                      coordEach(geometry.geometries[j], callback, excludeWrapCoord);
              } else {
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }
  meta.coordEach = coordEach;

  /**
   * Callback for coordReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback coordReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {[number, number]} currentCoords The current coordinate being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
   *
   * @name coordReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentCoords, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @param {boolean} [excludeWrapCoord=false] whether or not to include
   * the final coordinate of LinearRings that wraps the ring in its iteration.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.coordReduce(features, function (previousValue, currentCoords, currentIndex) {
   *   //=previousValue
   *   //=currentCoords
   *   //=currentIndex
   *   return currentCoords;
   * });
   */
  function coordReduce(layer, callback, initialValue, excludeWrapCoord) {
      var previousValue = initialValue;
      coordEach(layer, function (currentCoords, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentCoords;
          } else {
              previousValue = callback(previousValue, currentCoords, currentIndex);
          }
      }, excludeWrapCoord);
      return previousValue;
  }
  meta.coordReduce = coordReduce;

  /**
   * Callback for propEach
   *
   * @private
   * @callback propEachCallback
   * @param {*} currentProperties The current properties being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over properties in any GeoJSON object, similar to Array.forEach()
   *
   * @name propEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentProperties, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.propEach(features, function (currentProperties, currentIndex) {
   *   //=currentProperties
   *   //=currentIndex
   * });
   */
  function propEach(layer, callback) {
      var i;
      switch (layer.type) {
      case 'FeatureCollection':
          for (i = 0; i < layer.features.length; i++) {
              callback(layer.features[i].properties, i);
          }
          break;
      case 'Feature':
          callback(layer.properties, 0);
          break;
      }
  }
  meta.propEach = propEach;


  /**
   * Callback for propReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback propReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {*} currentProperties The current properties being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce properties in any GeoJSON object into a single value,
   * similar to how Array.reduce works. However, in this case we lazily run
   * the reduction, so an array of all properties is unnecessary.
   *
   * @name propReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentProperties, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.propReduce(features, function (previousValue, currentProperties, currentIndex) {
   *   //=previousValue
   *   //=currentProperties
   *   //=currentIndex
   *   return currentProperties
   * });
   */
  function propReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      propEach(layer, function (currentProperties, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentProperties;
          } else {
              previousValue = callback(previousValue, currentProperties, currentIndex);
          }
      });
      return previousValue;
  }
  meta.propReduce = propReduce;

  /**
   * Callback for featureEach
   *
   * @private
   * @callback featureEachCallback
   * @param {Feature<any>} currentFeature The current feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Iterate over features in any GeoJSON object, similar to
   * Array.forEach.
   *
   * @name featureEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentFeature, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.featureEach(features, function (currentFeature, currentIndex) {
   *   //=currentFeature
   *   //=currentIndex
   * });
   */
  function featureEach(layer, callback) {
      if (layer.type === 'Feature') {
          callback(layer, 0);
      } else if (layer.type === 'FeatureCollection') {
          for (var i = 0; i < layer.features.length; i++) {
              callback(layer.features[i], i);
          }
      }
  }
  meta.featureEach = featureEach;

  /**
   * Callback for featureReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback featureReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {Feature<any>} currentFeature The current Feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce features in any GeoJSON object, similar to Array.reduce().
   *
   * @name featureReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentFeature, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.featureReduce(features, function (previousValue, currentFeature, currentIndex) {
   *   //=previousValue
   *   //=currentFeature
   *   //=currentIndex
   *   return currentFeature
   * });
   */
  function featureReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      featureEach(layer, function (currentFeature, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentFeature;
          } else {
              previousValue = callback(previousValue, currentFeature, currentIndex);
          }
      });
      return previousValue;
  }
  meta.featureReduce = featureReduce;

  /**
   * Get all coordinates from any GeoJSON object.
   *
   * @name coordAll
   * @param {Object} layer any GeoJSON object
   * @returns {Array<Array<number>>} coordinate position array
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * var coords = turf.coordAll(features);
   * //=coords
   */
  function coordAll(layer) {
      var coords = [];
      coordEach(layer, function (coord) {
          coords.push(coord);
      });
      return coords;
  }
  meta.coordAll = coordAll;

  /**
   * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
   *
   * @name geomEach
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (currentGeometry, currentIndex)
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.geomEach(features, function (currentGeometry, currentIndex) {
   *   //=currentGeometry
   *   //=currentIndex
   * });
   */
  function geomEach$1(layer, callback) {
      var i, j, g, geometry, stopG,
          geometryMaybeCollection,
          isGeometryCollection,
          currentIndex = 0,
          isFeatureCollection = layer.type === 'FeatureCollection',
          isFeature = layer.type === 'Feature',
          stop = isFeatureCollection ? layer.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
      for (i = 0; i < stop; i++) {

          geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
          (isFeature ? layer.geometry : layer));
          isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (g = 0; g < stopG; g++) {
              geometry = isGeometryCollection ?
              geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

              if (geometry.type === 'Point' ||
                  geometry.type === 'LineString' ||
                  geometry.type === 'MultiPoint' ||
                  geometry.type === 'Polygon' ||
                  geometry.type === 'MultiLineString' ||
                  geometry.type === 'MultiPolygon') {
                  callback(geometry, currentIndex);
                  currentIndex++;
              } else if (geometry.type === 'GeometryCollection') {
                  for (j = 0; j < geometry.geometries.length; j++) {
                      callback(geometry.geometries[j], currentIndex);
                      currentIndex++;
                  }
              } else {
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }
  meta.geomEach = geomEach$1;

  /**
   * Callback for geomReduce
   *
   * The first time the callback function is called, the values provided as arguments depend
   * on whether the reduce method has an initialValue argument.
   *
   * If an initialValue is provided to the reduce method:
   *  - The previousValue argument is initialValue.
   *  - The currentValue argument is the value of the first element present in the array.
   *
   * If an initialValue is not provided:
   *  - The previousValue argument is the value of the first element present in the array.
   *  - The currentValue argument is the value of the second element present in the array.
   *
   * @private
   * @callback geomReduceCallback
   * @param {*} previousValue The accumulated value previously returned in the last invocation
   * of the callback, or initialValue, if supplied.
   * @param {*} currentGeometry The current Feature being processed.
   * @param {number} currentIndex The index of the current element being processed in the
   * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
   */

  /**
   * Reduce geometry in any GeoJSON object, similar to Array.reduce().
   *
   * @name geomReduce
   * @param {Object} layer any GeoJSON object
   * @param {Function} callback a method that takes (previousValue, currentGeometry, currentIndex)
   * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
   * @returns {*} The value that results from the reduction.
   * @example
   * var features = {
   *   "type": "FeatureCollection",
   *   "features": [
   *     {
   *       "type": "Feature",
   *       "properties": {"foo": "bar"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [26, 37]
   *       }
   *     },
   *     {
   *       "type": "Feature",
   *       "properties": {"hello": "world"},
   *       "geometry": {
   *         "type": "Point",
   *         "coordinates": [36, 53]
   *       }
   *     }
   *   ]
   * };
   * turf.geomReduce(features, function (previousValue, currentGeometry, currentIndex) {
   *   //=previousValue
   *   //=currentGeometry
   *   //=currentIndex
   *   return currentGeometry
   * });
   */
  function geomReduce(layer, callback, initialValue) {
      var previousValue = initialValue;
      geomEach$1(layer, function (currentGeometry, currentIndex) {
          if (currentIndex === 0 && initialValue === undefined) {
              previousValue = currentGeometry;
          } else {
              previousValue = callback(previousValue, currentGeometry, currentIndex);
          }
      });
      return previousValue;
  }
  meta.geomReduce = geomReduce;

  var dist=function e(t){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.reduce(function(t,r){return t.concat(e(r))},[]),t;case"Feature":return t.geometry?e(t.geometry).map(function(e){var r={type:"Feature",properties:JSON.parse(JSON.stringify(t.properties)),geometry:e};return void 0!==t.id&&(r.id=t.id),r}):t;case"MultiPoint":return t.coordinates.map(function(e){return {type:"Point",coordinates:e}});case"MultiPolygon":return t.coordinates.map(function(e){return {type:"Polygon",coordinates:e}});case"MultiLineString":return t.coordinates.map(function(e){return {type:"LineString",coordinates:e}});case"GeometryCollection":return t.geometries.map(e).reduce(function(e,t){return e.concat(t)},[]);case"Point":case"Polygon":case"LineString":return [t]}};

  var createTopology = require$$0.topology;
  var mergeTopology = require$$1.merge;
  var dissolveLineStrings = geojsonLinestringDissolve;
  var geomEach = meta.geomEach;
  var flatten = dist;

  var geojsonDissolve = dissolve;

  function toArray$1 (args) {
    if (!args.length) return []
    return Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)
  }

  function dissolvePolygons (geoms) {
    // Topojson modifies in place, so we need to deep clone first
    var objects = {
      geoms: {
        type: 'GeometryCollection',
        geometries: JSON.parse(JSON.stringify(geoms))
      }
    };
    var topo = createTopology(objects);
    return mergeTopology(topo, topo.objects.geoms.geometries)
  }

  // [GeoJSON] -> String|Null
  function getHomogenousType (geoms) {
    var type = null;
    for (var i = 0; i < geoms.length; i++) {
      if (!type) {
        type = geoms[i].type;
      } else if (type !== geoms[i].type) {
        return null
      }
    }
    return type
  }

  // Transform function: attempts to dissolve geojson objects where possible
  // [GeoJSON] -> GeoJSON geometry
  function dissolve () {
    // accept an array of geojson objects, or an argument list
    var objects = toArray$1(arguments);
    var geoms = objects.reduce(function (acc, o) {
      // flatten any Multi-geom into features of simple types
      var flat = flatten(o);
      if (!Array.isArray(flat)) flat = [flat];
      for (var i = 0; i < flat.length; i++) {
        // get an array of all flatten geometry objects
        geomEach(flat[i], function (geom) {
          acc.push(geom);
        });
      }
      return acc
    }, []);
    // Assert homogenity
    var type = getHomogenousType(geoms);
    if (!type) {
      throw new Error('List does not contain only homoegenous GeoJSON')
    }

    switch (type) {
      case 'LineString':
        return dissolveLineStrings(geoms)
      case 'Polygon':
        return dissolvePolygons(geoms)
      default:
        return geoms
    }
  }

  /**
   * 区域面组件
   */
  /** @class */ ((function (_super) {
      __extends$6(Area, _super);
      function Area(options, map) {
          return _super.call(this, __assign$1({ contentStyle: AREA_STYLE.contentStyle, outlineStyle: AREA_STYLE.outlineStyle, contentOutlineStyle: AREA_STYLE.contentOutlineStyle, contentLabelStyle: AREA_STYLE.contentLabelStyle, topOutline: true, bottomOutline: false, contentOutline: true, contentLabel: true, visible: true }, options), map) || this;
      }
      Object.defineProperty(Area.prototype, "visible", {
          /**
           * 组件显隐状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Area.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化
       * @ignore
       */
      Area.prototype.init = function () {
          var _this = this;
          var _a;
          this.initialized = true;
          var _b = this.options, contentStyle = _b.contentStyle, outlineStyle = _b.outlineStyle, contentOutlineStyle = _b.contentOutlineStyle, contentLabelStyle = _b.contentLabelStyle, topOutline = _b.topOutline, bottomOutline = _b.bottomOutline, contentOutline = _b.contentOutline, contentLabel = _b.contentLabel, visible = _b.visible;
          if (!defined$1(this._visible)) {
              this._visible = visible;
          }
          var data = this.options.data;
          if ((data === null || data === void 0 ? void 0 : data.type) !== "FeatureCollection" || ((_a = data.features) === null || _a === void 0 ? void 0 : _a.length) === 0) {
              throw new Error("GeoJSON格式错误或内容为空");
          }
          data = JSON.parse(JSON.stringify(data));
          var contentFeatureList = read$1(data);
          var mergePolygon = geojsonDissolve(data);
          this._contentFeatureList = contentFeatureList;
          this._contentVectorLayer = new VectorLayer({
              id: this.id + "-content-vector-layer",
              data: contentFeatureList,
              style: contentStyle,
              visible: this._visible
          });
          this._outlineVectorLayer = new VectorLayer({
              id: this.id + "-outline-vector-layer",
              style: outlineStyle,
              visible: this._visible
          });
          this._contentOutlineVectorLayer = new VectorLayer({
              id: this.id + "-content-outline-vector-layer",
              style: contentOutlineStyle,
              visible: this._visible
          });
          this._labelContentVectorLayer = new VectorLayer({
              id: this.id + "-label-content-vector-layer",
              style: contentLabelStyle,
              visible: this._visible
          });
          this._contentVectorLayer.on([
              BaseEventType.MOUSE_DOWN,
              BaseEventType.MOUSE_UP,
              BaseEventType.CLICK,
              BaseEventType.RIGHT_CLICK,
              BaseEventType.DOUBLE_CLICK,
              BaseEventType.MOUSE_MOVE
          ], function (e) {
              var coordinate = e.coordinate, pixel = e.pixel, map = e.map;
              var feature;
              if (e.features.length === 1 && _this._contentFeatureList.includes(e.features[0])) {
                  feature = e.features[0];
              }
              else if (e.features[0] instanceof Point$1) {
                  //@ts-ignore
                  feature = e.features[0].contentFeature;
              }
              _this.dispatchEvent({
                  type: e.type,
                  feature: feature,
                  coordinate: coordinate,
                  pixel: pixel,
                  map: map
              });
          });
          this._contentLabelFeatureList = [];
          this._contentOutlineFeatureList = contentFeatureList.map(function (feature) {
              var temFeature = new Polyline$1({
                  coordinates: polygonToPolyline$1(feature.geoJson.geometry).coordinates,
                  properties: __assign$1({}, feature.properties)
              });
              contentOutline && _this._contentOutlineVectorLayer.addFeature(temFeature);
              var labelPoint = feature.properties.center
                  ? feature.properties.center
                  : Turf__namespace.centerOfMass(feature.geoJson.geometry, {
                      properties: __assign$1({}, feature.properties)
                  }).geometry.coordinates;
              var labelFeature = new Point$1({
                  coordinates: labelPoint,
                  properties: __assign$1({}, feature.properties)
              });
              //@ts-ignore
              labelFeature.contentFeature = feature;
              contentLabel && _this._labelContentVectorLayer.addFeature(labelFeature);
              _this._contentLabelFeatureList.push(labelFeature);
              return temFeature;
          });
          var outlineBottomGeoJSON = polygonToPolyline$1(mergePolygon);
          var outlineTopGeoJSON = polygonToPolyline$1(mergePolygon);
          var outlineBottomFeature = new Polyline$1({
              coordinates: outlineBottomGeoJSON.coordinates
          });
          this._outlineBottomFeature = outlineBottomFeature;
          bottomOutline && this._outlineVectorLayer.addFeature(outlineBottomFeature);
          var outlineTopFeature = new Polyline$1({
              coordinates: outlineTopGeoJSON.coordinates
          });
          this._outlineTopFeature = outlineTopFeature;
          topOutline && this._outlineVectorLayer.addFeature(outlineTopFeature);
      };
      /**
       * @ignore
       */
      Area.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this._contentVectorLayer.addTo(globe);
          this._outlineVectorLayer.addTo(globe);
          this._contentOutlineVectorLayer.addTo(globe);
          this._labelContentVectorLayer.addTo(globe);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Area.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._contentVectorLayer.remove();
          this._contentOutlineVectorLayer.remove();
          this._outlineVectorLayer.remove();
          this._labelContentVectorLayer.remove();
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Area.prototype._destroy = function () {
          this.remove();
          this._contentVectorLayer.destroy();
          this._contentOutlineVectorLayer.destroy();
          this._outlineVectorLayer.destroy();
          this._labelContentVectorLayer.destroy();
          this._contentVectorLayer =
              this._contentOutlineVectorLayer =
                  this._outlineVectorLayer =
                      this._labelContentVectorLayer =
                          this._outlineTopFeature =
                              this._outlineBottomFeature =
                                  this._contentFeatureList =
                                      this._contentLabelFeatureList =
                                          this._contentOutlineFeatureList =
                                              void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示行政区划
       */
      Area.prototype.show = function () {
          var _a, _b, _c, _d;
          if (this.visible) {
              return;
          }
          this._visible = true;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.show();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.show();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.show();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.show();
          return this;
      };
      /**
       * 隐藏行政区划
       */
      Area.prototype.hide = function () {
          var _a, _b, _c, _d;
          if (this.visible === false) {
              return;
          }
          this._visible = false;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.hide();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.hide();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.hide();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.hide();
          return this;
      };
      return Area;
  })(Component));
  function polygonToPolyline$1(geojson) {
      if (geojson.type === GeoJsonType.FEATURE) {
          return feature$2(polygonToPolyline$1(geojson.geometry), __assign$1({}, geojson.properties));
      }
      else if (geojson.type === GeoJsonGeometryType.MULTI_POLYGON) {
          var list_1 = [];
          geojson.coordinates.forEach(function (item) {
              list_1 = list_1.concat(polygonToPolyline$1(polygon(item).geometry).coordinates);
          });
          return multiLineString(list_1).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.POLYGON) {
          return multiLineString(geojson.coordinates).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.LINE_STRING) {
          return geojson;
      }
  }

  var CastType;
  (function (CastType) {
      CastType["CUBE"] = "cube";
      CastType["ELLIPSE"] = "ellipse";
      CastType["ELLIPSOID"] = "ellipsoid";
      CastType["CYLINDER"] = "cylinder";
      CastType["PLANE"] = "plane";
  })(CastType || (CastType = {}));

  /** @class */ ((function (_super) {
      __extends$6(VideoShed, _super);
      function VideoShed(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(VideoShed.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      VideoShed.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      VideoShed.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      VideoShed.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return VideoShed;
  })(Component));

  /* eslint-disable @typescript-eslint/ban-types */
  /**
   * merge
   * @param a
   * @param b
   * @returns {*}
   */
  var merge$1 = function (a, b) {
      Object.keys(b).forEach(function (key) {
          if (isObject$9(b[key]) && isObject$9(a[key])) {
              merge$1(a[key], b[key]);
          }
          else {
              a[key] = b[key];
          }
      });
      return a;
  };
  /**
   * bind context
   * @param func
   * @param context
   * @param args
   */
  var bind$7 = function (func, context) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
      }
      return function () {
          var innerArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
          }
          return func.apply(context, args.concat(Array.prototype.slice.call(innerArgs)));
      };
  };
  /**
   * add own item
   * @param array
   * @param item
   */
  var arrayAdd$1 = function (array, item) {
      var i = 0;
      var index;
      var length = array.length;
      for (; i < length; i++) {
          if (array[i].index === item.index) {
              index = i;
              break;
          }
      }
      if (index === undefined) {
          array.push(item);
      }
      else {
          array[index] = item;
      }
      return array;
  };
  var uuid$2 = function () {
      function rd(a) {
          // eslint-disable-next-line no-mixed-operators,no-bitwise
          return a
              ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)
              : // @ts-ignore
                  ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, rd);
      }
      return rd();
  };
  /**
   * bind function array
   * @param fns
   * @param context
   */
  function bindAll$1(fns, context) {
      fns.forEach(function (fn) {
          if (!context[fn]) {
              return;
          }
          context[fn] = context[fn].bind(context);
      });
  }
  /**
   * remove node
   * @param node
   */
  function removeNode$1(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * mock zrender mouse event
   * @param type
   * @param event
   */
  function mockEvent$1(type, event) {
      var e = new MouseEvent(type, {
          // set bubbles, so zrender can receive the mock event. ref: https://dom.spec.whatwg.org/#interface-event
          // "event.bubbles": Returns true or false depending on how event was initialized.
          // True if event goes through its target’s ancestors in reverse tree order, and false otherwise
          bubbles: true,
          cancelable: true,
          button: event.pointerEvent.button,
          buttons: event.pointerEvent.buttons,
          clientX: event.pointerEvent.clientX,
          clientY: event.pointerEvent.clientY,
          // @ts-ignore
          zrX: event.pointerEvent.offsetX,
          zrY: event.pointerEvent.offsetY,
          movementX: event.pointerEvent.movementX,
          movementY: event.pointerEvent.movementY,
          relatedTarget: event.pointerEvent.relatedTarget,
          screenX: event.pointerEvent.screenX,
          screenY: event.pointerEvent.screenY,
          view: window
      });
      e.zrX = event.pointerEvent.offsetX;
      e.zrY = event.pointerEvent.offsetY;
      e.event = e;
      return e;
  }

  /**
   * check is decoded
   * @param json
   * @returns {boolean}
   */
  var checkDecoded$1 = function (json) { return !json.UTF8Encoding; };
  /**
   * decode polygon
   * @param coordinate
   * @param encodeOffsets
   * @param encodeScale
   * @returns {null}
   */
  var decodePolygon$1 = function (coordinate, encodeOffsets, encodeScale) {
      var result = [];
      var _a = __read([encodeOffsets[0], encodeOffsets[1]], 2), prevX = _a[0], prevY = _a[1];
      for (var i = 0; i < coordinate.length; i += 2) {
          var x = coordinate.charCodeAt(i) - 64;
          var y = coordinate.charCodeAt(i + 1) - 64;
          // ZigZag decoding
          // eslint-disable-next-line no-bitwise
          x = (x >> 1) ^ -(x & 1);
          // eslint-disable-next-line no-bitwise
          y = (y >> 1) ^ -(y & 1);
          // Delta deocding
          x += prevX;
          y += prevY;
          prevX = x;
          prevY = y;
          // @ts-ignore
          result.push([x / encodeScale, y / encodeScale]);
      }
      return result;
  };
  /**
   * decode json
   * @param json
   * @returns {*}
   */
  var decode$3 = function (json) {
      if (checkDecoded$1(json)) {
          return json;
      }
      var encodeScale = json.UTF8Scale;
      if (encodeScale === null) {
          encodeScale = 1024;
      }
      var features = json.features;
      for (var f = 0; f < features.length; f++) {
          var feature = features[f];
          var geometry = feature.geometry;
          var _a = __read([geometry.coordinates, geometry.encodeOffsets], 2), coordinates = _a[0], encodeOffsets = _a[1];
          for (var c = 0; c < coordinates.length; c++) {
              var coordinate = coordinates[c];
              if (geometry.type === "Polygon") {
                  coordinates[c] = decodePolygon$1(coordinate, encodeOffsets[c], encodeScale);
              }
              else if (geometry.type === "MultiPolygon") {
                  for (var c2 = 0; c2 < coordinate.length; c2++) {
                      var polygon = coordinate[c2];
                      coordinate[c2] = decodePolygon$1(polygon, encodeOffsets[c][c2], encodeScale);
                  }
              }
          }
      }
      json.UTF8Encoding = false;
      return json;
  };
  /**
   * decode geoJson
   * @param json
   */
  function formatGeoJSON$1 (json) {
      var geoJson = decode$3(json);
      // @ts-ignore
      var _features = echarts__namespace.util.map(
      // @ts-ignore
      echarts__namespace.util.filter(geoJson.features, function (featureObj) {
          // Output of mapshaper may have geometry null
          return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
      }), function (featureObj) {
          var properties = featureObj.properties;
          var geo = featureObj.geometry;
          var coordinates = geo.coordinates;
          var geometries = [];
          if (geo.type === "Polygon") {
              geometries.push(coordinates[0]);
          }
          if (geo.type === "MultiPolygon") {
              // @ts-ignore
              echarts__namespace.util.each(coordinates, function (item) {
                  if (item[0]) {
                      geometries.push(item[0]);
                  }
              });
          }
          return {
              properties: properties,
              type: "Feature",
              geometry: {
                  type: "Polygon",
                  coordinates: geometries
              }
          };
      });
      return {
          type: "FeatureCollection",
          crs: {},
          features: _features
      };
  }

  var pie$1 = function (_options, series, coordinateSystem) {
      series.center = coordinateSystem.dataToPoint(series.coordinates);
      return series;
  };

  var bar$1 = function (options, series, coordinateSystem) {
      if (isObject$9(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coorPixel = coordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coorPixel[0] - parseFloat(gri.width) / 2;
              gri.top = coorPixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  };

  var line$1 = function (options, serie, coordinateSystem) {
      if (isObject$9(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coorPixel = coordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coorPixel[0] - parseFloat(gri.width) / 2;
              gri.top = coorPixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return serie;
  };

  var charts$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    pie: pie$1,
    bar: bar$1,
    line: line$1
  });

  // @ts-nocheck
  var _options$1 = {
      forcedRerender: false,
      forcedPrecomposeRerender: false,
      hideOnZooming: false,
      hideOnMoving: false,
      hideOnRotating: false,
      convertTypes: ["pie", "line", "bar"],
      insertFirst: false,
      stopEvent: false,
      polyfillEvents: false //semver(VERSION, "6.1.1") <= 0 // fix echarts mouse events
  };
  var EChartsLayer$1 = /** @class */ (function (_super) {
      __extends$6(EChartsLayer, _super);
      function EChartsLayer(chartOptions, options, map) {
          var _this = this;
          var opts = Object.assign(_options$1, options);
          _this = _super.call(this, opts) || this;
          /**
           * layer options
           */
          _this._options = opts;
          /**
           * chart options
           */
          _this._chartOptions = chartOptions;
          _this.set("chartOptions", chartOptions); // cache chart Options
          /**
           * chart instance
           * @type {null}
           */
          _this.$chart = null;
          /**
           * chart element
           * @type {undefined}
           */
          _this.$container = undefined;
          /**
           * Whether the relevant configuration has been registered
           * @type {boolean}
           * @private
           */
          _this._isRegistered = false;
          _this._isStopRender = false;
          /**
           * check if init
           */
          _this._initEvent = false;
          /**
           * 增量数据存放
           * @type {Array}
           * @private
           */
          _this._incremental = [];
          /**
           * coordinate system
           * @type {null}
           * @private
           */
          _this._coordinateSystem = null;
          /**
           * coordinateSystemId
           */
          _this.coordinateSystemId = "";
          _this.prevVisibleState = "";
          bindAll$1([
              "redraw",
              "onResize",
              "onZoomEnd",
              "onCenterChange",
              "onDragRotateEnd",
              "onMoveStart",
              "onMoveEnd",
              "mouseDown",
              "mouseUp",
              "onClick",
              "mouseMove"
          ], _this);
          if (map)
              _this.setMap(map);
          return _this;
      }
      /**
       * append layer to map
       * @param map
       */
      EChartsLayer.prototype.appendTo = function (map) {
          this.setMap(map);
      };
      /**
       * get ol map
       * @returns {ol.Map}
       */
      EChartsLayer.prototype.getMap = function () {
          return this._map;
      };
      /**
       * set map
       * @param map
       */
      EChartsLayer.prototype.setMap = function (map) {
          var _this = this;
          if (map && map instanceof Map__default["default"]) {
              this._map = map;
              this._map.once("postrender", function () {
                  _this.handleMapChanged();
              });
              this._map.renderSync();
          }
          else {
              throw new Error("not ol map object");
          }
      };
      /**
       * get echarts options
       */
      EChartsLayer.prototype.getChartOptions = function () {
          return this.get("chartOptions");
      };
      /**
       * set echarts options and redraw
       * @param options
       * @returns {EChartsLayer}
       */
      EChartsLayer.prototype.setChartOptions = function (options) {
          if (options === void 0) { options = {}; }
          this._chartOptions = options;
          this.set("chartOptions", options);
          this.clearAndRedraw();
          return this;
      };
      /**
       * append data
       * @param data
       * @param save
       * @returns {EChartsLayer}
       */
      EChartsLayer.prototype.appendData = function (data, save) {
          if (save === void 0) { save = true; }
          if (data) {
              if (save) {
                  this._incremental = arrayAdd$1(this._incremental, {
                      index: this._incremental.length,
                      data: data.data,
                      seriesIndex: data.seriesIndex
                  });
              }
              // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin
              this.$chart.appendData({
                  data: data.data.copyWithin(),
                  seriesIndex: data.seriesIndex
              });
          }
          return this;
      };
      /**
       * clear layer
       */
      EChartsLayer.prototype.clear = function (keep) {
          if (!keep) {
              this._incremental = [];
          }
          if (this.$chart) {
              this.$chart.clear();
          }
      };
      /**
       * remove layer
       */
      EChartsLayer.prototype.remove = function () {
          this.clear();
          if (this.$chart) {
              this.$chart.dispose();
          }
          if (this._initEvent && this.$container) {
              this.$container && removeNode$1(this.$container);
              this.unBindEvent();
          }
          delete this.$chart;
          delete this._map;
      };
      /**
       * show layer
       */
      EChartsLayer.prototype.show = function () {
          this.setVisible(true);
      };
      EChartsLayer.prototype.innerShow = function () {
          if (this.$container) {
              this.$container.style.display = this.prevVisibleState;
              this.prevVisibleState = "";
          }
      };
      /**
       * hide layer
       */
      EChartsLayer.prototype.hide = function () {
          this.setVisible(false);
      };
      EChartsLayer.prototype.innerHide = function () {
          if (this.$container) {
              this.prevVisibleState = this.$container.style.display;
              this.$container.style.display = "none";
          }
      };
      /**
       * check layer is visible
       */
      EChartsLayer.prototype.isVisible = function () {
          return this.$container && this.$container.style.display !== "none";
      };
      /**
       * show loading bar
       */
      EChartsLayer.prototype.showLoading = function () {
          if (this.$chart) {
              this.$chart.showLoading();
          }
      };
      /**
       * hide loading bar
       */
      EChartsLayer.prototype.hideLoading = function () {
          if (this.$chart) {
              this.$chart.hideLoading();
          }
      };
      /**
       * set zindex
       * @param zIndex
       */
      EChartsLayer.prototype.setZIndex = function (zIndex) {
          if (this.$container) {
              if (typeof zIndex === "number") {
                  zIndex = String(zIndex);
              }
              this.$container.style.zIndex = zIndex;
          }
      };
      /**
       * get zindex
       */
      EChartsLayer.prototype.getZIndex = function () {
          return this.$container && this.$container.style.zIndex;
      };
      /**
       * set visible
       * from: https://github.com/sakitam-fdd/ol3Echarts/blob/3929ad72f562661ba3511d4d9e360dee5ac793c2/
       * packages/ol-echarts/src/index.js
       * author: https://github.com/ChenGuanglin0924
       * @param visible
       */
      EChartsLayer.prototype.setVisible = function (visible) {
          if (visible) {
              if (this.$container) {
                  this.$container.style.display = "";
              }
              this._chartOptions = this.getChartOptions();
              this.clearAndRedraw();
          }
          else {
              if (this.$container) {
                  this.$container.style.display = "none";
              }
              this.clear(true);
              this._chartOptions = {};
              this.clearAndRedraw();
          }
      };
      /**
       * render
       */
      EChartsLayer.prototype.render = function () {
          var _this = this;
          if (!this.$chart && this.$container) {
              // @ts-ignore
              this.$chart = echarts__namespace.init(this.$container);
              this.registerMap();
              // this.$chart.on('rendered',()=>{
              //     // api.dispatchAction({
              //     //     type: "GLMapRoam"
              //     // });
              // })
              if (this._chartOptions) {
                  setTimeout(function () {
                      _this.$chart.setOption(_this.convertData(_this._chartOptions), false);
                  }, 30);
              }
              this.dispatchEvent({
                  type: "load",
                  source: this,
                  value: this.$chart
              });
          }
          else if (this.isVisible()) {
              this.redraw();
          }
      };
      /**
       * redraw echarts layer
       */
      EChartsLayer.prototype.redraw = function () {
          this.clearAndRedraw();
      };
      /**
       * update container size
       * @param size
       */
      EChartsLayer.prototype.updateViewSize = function (size) {
          if (!this.$container)
              return;
          this.$container.style.width = "".concat(size[0], "px");
          this.$container.style.height = "".concat(size[1], "px");
          this.$container.setAttribute("width", String(size[0]));
          this.$container.setAttribute("height", String(size[1]));
      };
      /**
       * handle map view resize
       */
      EChartsLayer.prototype.onResize = function (event) {
          var map = this.getMap();
          if (map) {
              var size = map.getSize();
              this.updateViewSize(size);
              this.clearAndRedraw();
              if (event) {
                  // ignore events
                  this.dispatchEvent({
                      type: "change:size",
                      source: this,
                      value: size
                  });
              }
          }
      };
      /**
       * handle zoom end events
       */
      EChartsLayer.prototype.onZoomEnd = function () {
          this._options.hideOnZooming && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "zoomend",
                  source: this,
                  value: map.getView().getZoom()
              });
          }
      };
      /**
       * handle rotate end events
       */
      EChartsLayer.prototype.onDragRotateEnd = function () {
          this._options.hideOnRotating && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "change:rotation",
                  source: this,
                  value: map.getView().getRotation()
              });
          }
      };
      /**
       * handle move start events
       */
      EChartsLayer.prototype.onMoveStart = function () {
          this._options.hideOnMoving && this.innerHide();
          var map = this.getMap();
          if (map && map.getView()) {
              this.dispatchEvent({
                  type: "movestart",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * handle move end events
       */
      EChartsLayer.prototype.onMoveEnd = function () {
          this._options.hideOnMoving && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "moveend",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * on mouse click
       * @param event
       */
      EChartsLayer.prototype.onClick = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent$1("click", event));
          }
      };
      /**
       * on mouse down
       * @param event
       */
      EChartsLayer.prototype.mouseDown = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent$1("mousedown", event));
          }
      };
      /**
       * mouse up
       * @param event
       */
      EChartsLayer.prototype.mouseUp = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent$1("mouseup", event));
          }
      };
      /**
       * mousemove 事件需要分两种情况处理:
       * 1. ol-overlaycontainer-stopevent 有高度, 则 propagation path 是 ol-viewport -> ol-overlaycontainer-stopevent.
       * 此时 ol-overlaycontainer 无法获得事件, 只能 mock 处理
       * 2. ol-overlaycontainer-stopevent 没有高度, 则 propagation path 是 ol-viewport -> ol-overlaycontainer. 无需 mock
       * @param event
       */
      EChartsLayer.prototype.mouseMove = function (event) {
          if (this.$chart) {
              var target = event.originalEvent.target;
              while (target) {
                  if (target.className === "ol-overlaycontainer-stopevent") {
                      this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent$1("mousemove", event));
                      return;
                  }
                  target = target.parentElement;
              }
          }
      };
      /**
       * handle center change
       */
      EChartsLayer.prototype.onCenterChange = function () {
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "change:center",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * handle map change
       */
      EChartsLayer.prototype.handleMapChanged = function () {
          var map = this.getMap();
          if (this._initEvent && this.$container) {
              this.$container && removeNode$1(this.$container);
              this.unBindEvent();
          }
          if (!this.$container) {
              this.createLayerContainer();
              this.onResize(false);
          }
          if (map) {
              var container = this._options.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
              if (this._options.insertFirst) {
                  container.insertBefore(this.$container, container.childNodes[0] || null);
              }
              else {
                  container.appendChild(this.$container);
              }
              this.render();
              this.bindEvent(map);
          }
      };
      /**
       * create container
       */
      EChartsLayer.prototype.createLayerContainer = function () {
          this.$container = document.createElement("div");
          this.$container.style.position = "absolute";
          this.$container.style.top = "0px";
          this.$container.style.left = "0px";
          this.$container.style.right = "0px";
          this.$container.style.bottom = "0px";
          this.$container.style.pointerEvents = "auto";
      };
      /**
       * register events
       * @private
       */
      EChartsLayer.prototype.bindEvent = function (map) {
          // https://github.com/openlayers/openlayers/issues/7284
          var view = map.getView();
          //if (this._options.forcedPrecomposeRerender) {
          map.on("precompose", this.redraw);
          //}
          map.on("change:size", this.onResize);
          view.on("change:resolution", this.onZoomEnd);
          view.on("change:center", this.onCenterChange);
          view.on("change:rotation", this.onDragRotateEnd);
          map.on("movestart", this.onMoveStart);
          map.on("moveend", this.onMoveEnd);
          if (this._options.polyfillEvents) {
              map.on("pointerdown", this.mouseDown);
              map.on("pointerup", this.mouseUp);
              map.on("pointermove", this.mouseMove);
              map.on("click", this.onClick);
          }
          this._initEvent = true;
      };
      /**
       * un register events
       * @private
       */
      EChartsLayer.prototype.unBindEvent = function () {
          var map = this.getMap();
          if (!map)
              return;
          var view = map.getView();
          if (!view)
              return;
          map.un("precompose", this.redraw);
          map.un("change:size", this.onResize);
          view.un("change:resolution", this.onZoomEnd);
          view.un("change:center", this.onCenterChange);
          view.un("change:rotation", this.onDragRotateEnd);
          map.un("movestart", this.onMoveStart);
          map.un("moveend", this.onMoveEnd);
          if (this._options.polyfillEvents) {
              map.un("pointerdown", this.mouseDown);
              map.un("pointerup", this.mouseUp);
              map.un("pointermove", this.mouseMove);
              map.un("click", this.onClick);
          }
          this._initEvent = false;
      };
      /**
       * clear chart and redraw
       * @private
       */
      EChartsLayer.prototype.clearAndRedraw = function () {
          if (!this.$chart || !this.isVisible())
              return;
          if (this._options.forcedRerender) {
              this.$chart.clear();
          }
          this.$chart.resize();
          if (this._chartOptions) {
              //this.registerMap();
              this.$chart.setOption(this.convertData(this._chartOptions), false);
              if (this._incremental && this._incremental.length > 0) {
                  for (var i = 0; i < this._incremental.length; i++) {
                      this.appendData(this._incremental[i], false);
                  }
              }
          }
          this.dispatchEvent({
              type: "redraw",
              source: this
          });
      };
      /**
       * register map coordinate system
       * @private
       */
      EChartsLayer.prototype.registerMap = function () {
          var echart = this.$chart;
          var isStopRender = this._isStopRender;
          echart.on("finished", function () {
              this._api.dispatchAction({
                  type: "GLMapRoam"
              });
          });
          if (!this._isRegistered) {
              this.coordinateSystemId = "openlayers_".concat(uuid$2());
              // @ts-ignore
              echarts__namespace.registerCoordinateSystem(this.coordinateSystemId, this.getCoordinateSystem(this._options));
              echarts__namespace.registerAction({
                  type: "GLMapRoam",
                  event: "GLMapRoam",
                  update: "updateLayout"
              }, function (e, t) { });
              echarts__namespace.extendComponentModel({
                  type: "GLMap",
                  defaultOption: {
                      roam: !1
                  }
              });
              echarts__namespace.extendComponentView({
                  type: "GLMap",
                  init: function (echartModel, api) {
                      //@ts-ignore
                      var implementation = window["requestAnimationFrame"];
                      function render() {
                          if (isStopRender) {
                              return;
                          }
                          setTimeout(function () {
                              api.dispatchAction({
                                  type: "GLMapRoam"
                              });
                          }, 0);
                          implementation(render);
                      }
                      implementation(render);
                      //(this.api = api), map.on('postrender',this.moveHandler.bind(this));
                  },
                  render: function (e, t, i) { },
                  dispose: function () {
                      isStopRender = true;
                      // @ts-ignore
                      //(this.api = api), map.un("postrender", this.moveHandler.bind(this));
                  }
              });
              this._isRegistered = true;
          }
          if (this._chartOptions) {
              // @ts-ignore
              var series = this._chartOptions.series;
              if (series && isObject$9(series)) {
                  var convertTypes = this._options.convertTypes;
                  if (convertTypes) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (!(convertTypes.indexOf(series[i].type) > -1)) {
                              series[i].coordinateSystem = this.coordinateSystemId;
                          }
                          series[i].animation = false;
                      }
                  }
              }
          }
      };
      /**
       * 重新处理数据
       * @param options
       * @returns {*}
       */
      EChartsLayer.prototype.convertData = function (options) {
          // @ts-ignore
          var series = options.series;
          if (series && series.length > 0) {
              if (!this._coordinateSystem) {
                  var Rc = this.getCoordinateSystem(this._options);
                  // @ts-ignore
                  this._coordinateSystem = new Rc(this.getMap());
              }
              if (series && isObject$9(series)) {
                  var convertTypes = this._options.convertTypes;
                  if (convertTypes) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (convertTypes.indexOf(series[i].type) > -1) {
                              if (series[i] && series[i].hasOwnProperty("coordinates")) {
                                  // @ts-ignore
                                  series[i] = charts$1[series[i].type](options, series[i], this._coordinateSystem);
                              }
                          }
                      }
                  }
              }
          }
          return options;
      };
      /**
       * register coordinateSystem
       * @param options
       */
      EChartsLayer.prototype.getCoordinateSystem = function (options) {
          var map = this.getMap();
          var coordinateSystemId = this.coordinateSystemId;
          var RegisterCoordinateSystem = function (map) {
              // @ts-ignore
              this.map = map;
              // @ts-ignore
              this._mapOffset = [0, 0];
              // @ts-ignore
              this.dimensions = ["lng", "lat"];
              // @ts-ignore
              this.projCode = RegisterCoordinateSystem.getProjectionCode(this.map);
          };
          RegisterCoordinateSystem.dimensions = RegisterCoordinateSystem.prototype.dimensions || ["lng", "lat"];
          /**
           * get zoom
           * @returns {number}
           */
          RegisterCoordinateSystem.prototype.getZoom = function () {
              return this.map.getView().getZoom();
          };
          /**
           * set zoom
           * @param zoom
           */
          RegisterCoordinateSystem.prototype.setZoom = function (zoom) {
              return this.map.getView().setZoom(zoom);
          };
          RegisterCoordinateSystem.prototype.getViewRectAfterRoam = function () {
              return this.getViewRect().clone();
          };
          /**
           * 设置地图窗口的偏移
           * @param mapOffset
           */
          RegisterCoordinateSystem.prototype.setMapOffset = function (mapOffset) {
              this._mapOffset = mapOffset;
          };
          /**
           * 跟据坐标转换成屏幕像素
           * @param data
           * @returns {}
           */
          RegisterCoordinateSystem.prototype.dataToPoint = function (data) {
              var coords;
              if (data && Array.isArray(data) && data.length > 0) {
                  coords = data.map(function (item) {
                      var res = 0;
                      if (typeof item === "string") {
                          res = Number(item);
                      }
                      else {
                          res = item;
                      }
                      return res;
                  });
                  var source = (options && options.source) || "EPSG:4326";
                  var destination = (options && options.destination) || this.projCode;
                  var pixel = this.map.getPixelFromCoordinate(proj.transform(coords, source, destination));
                  var mapOffset = this._mapOffset;
                  return [pixel[0] - mapOffset[0], pixel[1] - mapOffset[1]];
              }
              return [0, 0];
          };
          /**
           * 跟据屏幕像素转换成坐标
           * @param pixel
           * @returns {}
           */
          RegisterCoordinateSystem.prototype.pointToData = function (pixel) {
              var mapOffset = this._mapOffset;
              return this.map.getCoordinateFromPixel([pixel[0] + mapOffset[0], pixel[1] + mapOffset[1]]);
          };
          /**
           * 获取视图矩形范围
           * @returns {*}
           */
          RegisterCoordinateSystem.prototype.getViewRect = function () {
              var size = this.map.getSize();
              // @ts-ignore
              return new echarts__namespace.graphic.BoundingRect(0, 0, size[0], size[1]);
          };
          /**
           * create matrix
           */
          RegisterCoordinateSystem.prototype.getRoamTransform = function () {
              // @ts-ignore
              return echarts__namespace.matrix.create();
          };
          /**
           * 处理自定义图表类型
           * @returns {{coordSys: {type: string, x, y, width, height}, api: {coord, size}}}
           */
          RegisterCoordinateSystem.prototype.prepareCustoms = function () {
              var rect = this.getViewRect();
              return {
                  coordSys: {
                      type: coordinateSystemId,
                      x: rect.x,
                      y: rect.y,
                      width: rect.width,
                      height: rect.height
                  },
                  api: {
                      coord: bind$7(this.dataToPoint, this),
                      size: bind$7(RegisterCoordinateSystem.dataToCoordsSize, this)
                  }
              };
          };
          RegisterCoordinateSystem.create = function (echartsModel) {
              echartsModel.eachSeries(function (seriesModel) {
                  if (seriesModel.get("coordinateSystem") === coordinateSystemId) {
                      // @ts-ignore
                      seriesModel.coordinateSystem = new RegisterCoordinateSystem(map);
                  }
              });
          };
          RegisterCoordinateSystem.getProjectionCode = function (map) {
              var code = "";
              if (map) {
                  code = map.getView() && map.getView().getProjection().getCode();
              }
              else {
                  code = "EPSG:3857";
              }
              return code;
          };
          RegisterCoordinateSystem.dataToCoordsSize = function (dataSize, dataItem) {
              var _this = this;
              if (dataItem === void 0) { dataItem = [0, 0]; }
              return [0, 1].map(function (dimIdx) {
                  var val = dataItem[dimIdx];
                  var p1 = [];
                  var p2 = [];
                  var halfSize = dataSize[dimIdx] / 2;
                  p1[dimIdx] = val - halfSize;
                  p2[dimIdx] = val + halfSize;
                  p1[1 - dimIdx] = dataItem[1 - dimIdx];
                  p2[1 - dimIdx] = dataItem[1 - dimIdx];
                  // @ts-ignore
                  var offset = _this.dataToPoint(p1)[dimIdx] - _this.dataToPoint(p2)[dimIdx];
                  return Math.abs(offset);
              }, this);
          };
          return RegisterCoordinateSystem;
      };
      /**
       * dispatch event
       * @param event
       */
      EChartsLayer.prototype.dispatchEvent = function (event) {
          return _super.prototype.dispatchEvent.call(this, event);
      };
      EChartsLayer.prototype.set = function (key, value, optSilent) {
          return _super.prototype.set.call(this, key, value, optSilent);
      };
      EChartsLayer.prototype.get = function (key) {
          return _super.prototype.get.call(this, key);
      };
      EChartsLayer.prototype.unset = function (key, optSilent) {
          return _super.prototype.unset.call(this, key, optSilent);
      };
      // @ts-ignore
      EChartsLayer.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      EChartsLayer.prototype.un = function (type, listener) {
          return _super.prototype.un.call(this, type, listener);
      };
      EChartsLayer.formatGeoJSON = formatGeoJSON$1;
      EChartsLayer.bind = bind$7;
      EChartsLayer.merge = merge$1;
      EChartsLayer.uuid = uuid$2;
      EChartsLayer.bindAll = bindAll$1;
      EChartsLayer.arrayAdd = arrayAdd$1;
      EChartsLayer.removeNode = removeNode$1;
      EChartsLayer.isObject = isObject$9;
      return EChartsLayer;
  }(obj));

  var MTIEChartsLayer$1 = /** @class */ (function (_super) {
      __extends$6(MTIEChartsLayer, _super);
      function MTIEChartsLayer(chartOptions, options, map) {
          return _super.call(this, chartOptions, options, map) || this;
      }
      MTIEChartsLayer.prototype.setChartOptions = function (options) {
          var e_1, _a;
          // @ts-ignore
          this._options.forcedRerender = true;
          // @ts-ignore
          this.clear();
          try {
              // @ts-ignore
              for (var _b = __values(this.$chart.getDom().getElementsByTagName("canvas")), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var canvas = _c.value;
                  canvas.getContext("2d").clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          _super.prototype.setChartOptions.call(this, options);
          // @ts-ignore
          this._options.forcedRerender = false;
          return this;
      };
      return MTIEChartsLayer;
  }(EChartsLayer$1));
  /** @class */ ((function (_super) {
      __extends$6(Echarts, _super);
      function Echarts(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Echarts.prototype, "echarts", {
          /**
           * echarts初始化对象
           */
          get: function () {
              return this._echarts;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Echarts.prototype.init = function () {
          this.initialized = true;
          //@ts-ignore
          this._chartsLayer = new MTIEChartsLayer$1(this.options, {
              hideOnMoving: false,
              forcedRerender: false,
              forcedPrecomposeRerender: false
          });
      };
      Echarts.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this._chartsLayer.appendTo(map.map);
          this._echarts = this._chartsLayer.$chart;
      };
      /**
       * @ignore
       */
      Echarts.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.initialized = false;
          this._chartsLayer.remove();
          this._chartsLayer = void 0;
          this._echarts = void 0;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Echarts.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置图表`option`
       *
       * 参考内容:[https://echarts.apache.org/zh/api.html#echartsInstance.setOption](https://echarts.apache.org/zh/api.html#echartsInstance.setOption)
       */
      Echarts.prototype.setOption = function (option) {
          this._options = __assign$1(__assign$1({}, option), { id: this.options.id, initOptions: this.options.initOptions });
          this._chartsLayer.setChartOptions(option);
          return this;
      };
      return Echarts;
  })(Component));

  /**
   * 遮罩组件
   *
   * [cesium]
   */
  /** @class */ ((function (_super) {
      __extends$6(Mask, _super);
      function Mask(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, globe: true }, options)) || this;
          _this._visible = _this.options.visible;
          _this._layer = new VectorLayer({ id: _this.options.id, visible: _this._visible });
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Mask.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "layer", {
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Mask.prototype.init = function () {
          this.initialized = true;
          var mask = this.options.data;
          var globe = this.options.globe;
          var feature_;
          if (globe && !this.options.extent) {
              var _maskPolygon = Turf__namespace.mask(mask);
              feature_ = new Polygon$1({
                  coordinates: _maskPolygon.geometry.coordinates,
                  properties: _maskPolygon.properties
              });
          }
          else {
              var _extent = Turf__namespace.bboxPolygon(this.options.extent || [73.66, 3.86, 135.05, 53.55]);
              var _maskPolygon = Turf__namespace.mask(mask, _extent);
              feature_ = new Polygon$1({
                  coordinates: _maskPolygon.geometry.coordinates,
                  properties: _maskPolygon.properties
              });
          }
          this._layer.addFeature(feature_);
      };
      /**
       * @ignore
       * @param map
       */
      Mask.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          this.options.style && this._layer.setStyle(this.options.style);
      };
      /**
       * @ignore
       */
      Mask.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Mask.prototype._destroy = function () {
          this.remove();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 显示墙组件
       */
      Mask.prototype.show = function () {
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          this._layer.show();
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Mask.prototype.hide = function () {
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          this._layer.hide();
          return this;
      };
      return Mask;
  })(Component));

  /**
   * 绘制类
   */
  var DrawInner = /** @class */ (function (_super) {
      __extends$6(DrawInner, _super);
      function DrawInner(options, map) {
          return _super.call(this, __assign$1({ snap: true, edit: true, snapTarget: [] }, (options || {})), map) || this;
      }
      Object.defineProperty(DrawInner.prototype, "options", {
          /**
           * 构造器方法
           * @param {*} type
           * @param {*} options
           */
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(DrawInner.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(DrawInner.prototype, "drawing", {
          get: function () {
              return defined$1(this._draw);
          },
          enumerable: false,
          configurable: true
      });
      DrawInner.prototype.init = function () {
          this.initialized = true;
          this._style = this.options.polygonStyle
              ? styleToOlStyleFunction(this.options.polygonStyle)
              : styleToOlStyleFunction(this.options.polylineStyle);
      };
      /**
       * 添加绘制交互的方法------
       * @param {*} type  绘制类型
       * @param {*} active 是否激活
       */
      DrawInner.prototype.addDrawInteractions = function (type) {
          this._type = type;
          var _drawType = "Polygon";
          if (type === DrawType.POLYLINE) {
              _drawType = "LineString";
          }
          // 类型不一致转换
          this._draw = new DrawClass__default["default"](__assign$1({ style: this._style, source: new VectorSource__default["default"](), type: _drawType }, this.options));
          this._draw.setActive(true);
          var _collection = new Collection$1();
          // 添加交互组件到地图中
          this.map.map.addInteraction(this._draw);
          if (this.options.snap) {
              if (this.options.snapTarget.length) {
                  this.options.snapTarget
                      .map(function (_layer) {
                      return _layer.getFeatures();
                  })
                      .flat().forEach(function (f) {
                      _collection.push(f.sourceFeature);
                  });
                  this._snap = new SnapInteraction__default["default"]({ features: _collection });
              }
              else {
                  if (this.options.target) {
                      this._snap = new SnapInteraction__default["default"]({ source: this.options.target.layer[0].getSource() });
                  }
              }
              this._snap && this.map.map.addInteraction(this._snap);
          }
          this.drawendKey_ = this._draw.on("drawend", this.drawEndHandle.bind(this));
          this.drawstartKey_ = this._draw.on("drawstart", this.drawStartHandle.bind(this));
      };
      /**
       * 绘制完成时的回调------
       * @param event
       * @private
       */
      DrawInner.prototype.drawEndHandle = function (evt) {
          var _this = this;
          var feature = evt.feature.clone();
          var type = feature.getGeometry().getType();
          var coordinates;
          var _feature;
          if (type === "Polygon") {
              coordinates = feature.getGeometry().getCoordinates().map(function (coords) {
                  return coords.map(function (coord) {
                      return proj.transform(coord, _this.map.map.getView().getProjection(), PUBLIC_CONFIG.dataProjection);
                  });
              });
              _feature = new Polygon$1({ coordinates: coordinates });
          }
          if (type === "LineString") {
              coordinates = feature.getGeometry().getCoordinates().map(function (coord) {
                  return proj.transform(coord, _this.map.map.getView().getProjection(), PUBLIC_CONFIG.dataProjection);
              });
              _feature = new Polyline$1({ coordinates: coordinates });
          }
          // 属性一致-----
          this.options.target && this.options.target.addFeature(_feature);
          // 要素返回一致
          this.dispatchEvent({
              type: BaseEventType.DRAW_END,
              target: this,
              feature: _feature
          });
      };
      /**
       * 绘制开始时的监听处理--------
       * @param event
       * @private
       */
      DrawInner.prototype.drawStartHandle = function (event) {
          this.dispatchEvent({
              type: BaseEventType.DRAW_START
          });
      };
      /**
       * 移除上一次激活的工具
       * @private
       */
      DrawInner.prototype.deactive = function () {
          if (this._draw) {
              this.drawendKey_ && Observable$3.unByKey(this.drawendKey_);
              this.drawendKey_ = undefined;
              this.drawstartKey_ && Observable$3.unByKey(this.drawstartKey_);
              this.drawstartKey_ = undefined;
              this.map.map.removeInteraction(this._draw);
              this._draw = null;
          }
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
              this._snap = null;
          }
          return this;
      };
      /**
       * 激活或者禁用绘制控件
       * @param {*} flag
       */
      DrawInner.prototype.active = function (type) {
          this.deactive();
          this.addDrawInteractions(type);
          return this;
      };
      DrawInner.prototype.clearAll = function () {
          return this;
      };
      DrawInner.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
          this.initialized = false;
      };
      DrawInner.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy;
      };
      return DrawInner;
  }(Component));

  /**
   * 绘制类
   */
  var Draw = /** @class */ (function (_super) {
      __extends$6(Draw, _super);
      function Draw(options, map) {
          var _this = _super.call(this, __assign$1({ snap: true, edit: true, pointStyle: DRAW_STYLE.point, polygonStyle: DRAW_STYLE.polygon, polylineStyle: DRAW_STYLE.polyline }, (options || {})), map) || this;
          _this._coords = [];
          return _this;
      }
      Object.defineProperty(Draw.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Draw.prototype, "drawing", {
          get: function () {
              if (defined$1(this._draw)) {
                  return this._draw.drawing;
              }
              else {
                  return this._clickListener ? true : false;
              }
          },
          enumerable: false,
          configurable: true
      });
      Draw.prototype.init = function () {
          this.initialized = true;
          var _element = document.createElement("span");
          _element.className = "mti-measure-tool mti-measure-tool-length";
          _element.innerHTML = "单击地图绘制要素";
          this._messageTip = new Overlay({
              element: _element,
              positioning: Positioning.TOP_LEFT,
              offset: [20, 5]
          });
      };
      Draw.prototype.active = function (type) {
          var _this = this;
          this.deactive();
          this.deactivateMapTools();
          this._type = type;
          this._pointermoveListener = this.map.map.on(MapBrowserEventType.POINTERMOVE, function (event) {
              _this._messageTip.setPosition(transformToDataProjection(event.coordinate));
          });
          if (this._type === DrawType.POLYGON || this._type === DrawType.POLYLINE) {
              if (this._draw) {
                  this.map.removeComponent(this._draw, true);
                  this._draw = undefined;
              }
              var _options = __assign$1({}, this.options);
              if (this._type === DrawType.POLYGON) {
                  delete _options.polylineStyle;
              }
              if (this._type === DrawType.POLYLINE) {
                  delete _options.polygonStyle;
              }
              this._draw = new DrawInner(_options, this.map);
              this._draw.active(this._type);
              this._draw.on(BaseEventType.DRAW_END, function (event) {
                  _this._draw.deactive();
                  _this.dispatchEvent({ type: BaseEventType.DRAW_END, feature: event.feature });
                  _this._messageTip.hide();
                  _this._messageTip.element.innerHTML = "<span>单击地图绘制要素</span>";
                  Observable$3.unByKey(_this._pointermoveListener);
              });
          }
          else {
              this._clickListener = this.map.map.on(MapBrowserEventType.CLICK, this.mapFirstClickHandler.bind(this));
          }
          return this;
      };
      Draw.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this._tempLayer = this.options.target || new VectorLayer({ zIndex: 100 });
          if (!this._tempLayer.map) {
              this.map.addLayer(this._tempLayer);
          }
          this.map.addOverlay(this._messageTip);
      };
      Draw.prototype.deactive = function () {
          this.disconnectEventHandlers();
          this._coords = [];
          this._geom = null;
          this._type = null;
          this.activateMapTools();
          this._feature && this._tempLayer.removeFeature(this._feature);
          this._feature = null;
          if (this._draw) {
              this._draw.deactive();
          }
          return this;
      };
      /**
       * 清除全部标绘
       */
      Draw.prototype.clearAll = function () {
          this._tempLayer.clearFeatures();
          return this;
      };
      // 地图首次单击事件监听
      Draw.prototype.mapFirstClickHandler = function (e) {
          this._messageTip.element.innerHTML = "<span>单击继续绘制要素，双击完成要素绘制!</span>";
          this._coords.push(transformToDataProjection(e.coordinate));
          this._geom = createDraw(this.type, this._coords);
          if (this.type === DrawType.CIRCLE) {
              // @ts-ignore
              this._geom.minRadius = this.options.minRadius / 1000 || 50 / 1000;
              // @ts-ignore
              this._geom.maxRadius = this.options.maxRadius / 1000 || Number.MAX_VALUE;
          }
          this._feature = this._creatFeature();
          this._tempLayer.addFeature(this._feature);
          // 取消监听
          Observable$3.unByKey(this._clickListener);
          // 特殊类型几何体需要几个点来插值生成特殊几何体
          if (this._geom.fixPointCount === this._geom.getPointCount()) {
              this.mapDoubleClickHandler(e);
              return;
          }
          // 地图添加单击事件
          this._clicknextListener = this.map.map.on(MapBrowserEventType.CLICK, this.mapNextClickHandler.bind(this));
          // 地图双击事件----
          this._doubleListener = this.map.map.on(MapBrowserEventType.DBLCLICK, this.mapDoubleClickHandler.bind(this));
          this._moveListener = this.map.map.on(MapBrowserEventType.POINTERMOVE, this.mapMouseMoveHandler.bind(this));
      };
      Draw.prototype._creatFeature = function () {
          var _feature;
          if (this.type === DrawType.POINT) {
              var _coordinates = this._geom.coordinates;
              _feature = new Point$1({ coordinates: _coordinates });
              _feature.setStyle(this.options.pointStyle);
          }
          else if (this.type === DrawType.POLYLINE ||
              this.type === DrawType.ARC ||
              this.type === DrawType.CURVE ||
              this.type === DrawType.STRAIGHT_ARROW) {
              _feature = new Polyline$1({ coordinates: [] });
              _feature.setStyle(this.options.polylineStyle);
          }
          else if (this.type === DrawType.CIRCLE) {
              _feature = new Circle({
                  radius: this._geom.ellipsoidRaduis,
                  center: this._geom.center
              });
              _feature.setStyle(this.options.polygonStyle);
          }
          else {
              _feature = new Polygon$1({ coordinates: [] });
              _feature.setStyle(this.options.polygonStyle);
          }
          return _feature;
      };
      Draw.prototype.mapMouseMoveHandler = function (e) {
          var coordinate = transformToDataProjection(e.coordinate);
          if (distance$1(coordinate, this._coords[this._coords.length - 1]) > Constants.ZERO_TOLERANCE) {
              this._geom.setPoints(this._coords.concat([coordinate]).slice(0));
              if (this.type === DrawType.CIRCLE) {
                  this._feature.setRadius(this._geom.ellipsoidRaduis * 1000);
              }
              else {
                  this._feature.setCoordinates(this._geom.coordinates);
              }
          }
      };
      Draw.prototype.mapNextClickHandler = function (e) {
          var coordinate = transformToDataProjection(e.coordinate);
          var distance = distance$1(coordinate, this._coords[this._coords.length - 1]);
          if (distance > Constants.ZERO_TOLERANCE) {
              this._coords.push(coordinate);
              this._geom.setPoints(this._coords);
              if (this.type === DrawType.CIRCLE) {
                  this._feature.setRadius(this._geom.ellipsoidRaduis * 1000);
              }
              else {
                  this._feature.setCoordinates(this._geom.coordinates);
              }
              if (this._geom.fixPointCount === this._geom.getPointCount()) {
                  // 结束绘制----销毁资源
                  this.mapDoubleClickHandler(e);
                  return;
              }
          }
      };
      Draw.prototype.mapDoubleClickHandler = function (e) {
          if (this._geom.finishDrawing) {
              this._geom.finishDrawing();
          }
          e.preventDefault();
          this.drawEnd();
      };
      Draw.prototype.disconnectEventHandlers = function () {
          this._clickListener && Observable$3.unByKey(this._clickListener);
          this._clickListener = void 0;
          this._clicknextListener && Observable$3.unByKey(this._clicknextListener);
          this._pointermoveListener && Observable$3.unByKey(this._pointermoveListener);
          this._doubleListener && Observable$3.unByKey(this._doubleListener);
          this._moveListener && Observable$3.unByKey(this._moveListener);
          this._messageTip.hide();
          this._messageTip.element.innerHTML = "<span>单击地图绘制要素</span>";
      };
      Draw.prototype.drawEnd = function () {
          var _this = this;
          window.setTimeout(function () {
              _this.activateMapTools();
          }, 500);
          this.disconnectEventHandlers();
          if (this.type === DrawType.POLYLINE || this.type === DrawType.POLYGON || this.type === DrawType.POINT) {
              this._feature.set("isPlot", false);
              this._feature.setProperties({ isPlot: false });
          }
          else {
              this._feature.set("isPlot", true);
              this._feature.set("plot", this._coords);
              this._feature.set("plotType", this.type);
              this._feature.setProperties({ plot: this._coords, plotType: this.type, isPlot: true });
          }
          this._coords = [];
          this._geom = null;
          this._type = null;
          this.options.target === undefined && this._tempLayer.removeFeature(this._feature);
          this._feature.setStyle(undefined);
          //图层添加到图层
          this.dispatchEvent({ type: BaseEventType.DRAW_END, feature: this._feature });
          /**
           *  添加圆逻辑
           */
          this._feature = null;
      };
      Draw.prototype.deactivateMapTools = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DoubleClickZoom__default["default"]) {
                  this._dblClickZoomInteraction = item;
                  interactions.remove(item);
                  break;
              }
          }
      };
      Draw.prototype.activateMapTools = function () {
          if (defined$1(this._dblClickZoomInteraction)) {
              this.map.map.getInteractions().push(this._dblClickZoomInteraction);
              this._dblClickZoomInteraction = null;
          }
      };
      Draw.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.disconnectEventHandlers();
          this._coords = [];
          this._geom = null;
          this._type = null;
          this._feature && this._tempLayer.removeFeature(this._feature);
          this.options.target === undefined && this.map.removeLayer(this._tempLayer);
          this._tempLayer = undefined;
          this._feature = null;
          this._draw && this.map.removeComponent(this._draw);
          this._draw = undefined;
          this.map = undefined;
      };
      Draw.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `drawend`    |   左键双击，表示绘制完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Draw.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Draw;
  }(Component));

  var CircleSearch = /** @class */ (function (_super) {
      __extends$6(CircleSearch, _super);
      function CircleSearch(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(CircleSearch.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "minRadius", {
          /**
           * 可拖拽的最小半径  单位: 米
           */
          get: function () {
              return this._minRadius;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(CircleSearch.prototype, "maxRadius", {
          /**
           * 可拖拽的最大半径  单位: 米
           */
          get: function () {
              return this._maxRadius;
          },
          enumerable: false,
          configurable: true
      });
      CircleSearch.prototype.init = function () {
          var _a = this.options, infoPopup = _a.infoPopup, step = _a.step, _b = _a.minRadius, minRadius = _b === void 0 ? 5 : _b, maxRadius = _a.maxRadius;
          defined$1(this.minRadius) || this.setMinRadius(minRadius);
          defined$1(this.maxRadius) || this.setMaxRadius(maxRadius);
          this._eventKeys = [];
          this._step = step || 1;
          this._dragging = false;
          this._hovering = false;
          this.initialized = true;
          this._layer = new VectorLayer({});
          this._infoPopup = infoPopup;
      };
      CircleSearch.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          defined$1(this._infoPopup) && this.map.addOverlay(this._infoPopup);
      };
      CircleSearch.prototype.active = function (feature) {
          var _this = this;
          this.deactive();
          if (feature instanceof Circle) {
              this._active(feature);
          }
          else if (this.map) {
              this._draw = new Draw({}, this.map).active(DrawType.CIRCLE);
              this._draw.once(BaseEventType.DRAW_END, function (_a) {
                  var feature = _a.feature; _a.target;
                  _this._active(feature);
                  _this.dispatchEvent({
                      type: BaseEventType.EDIT_END,
                      radius: feature.radius,
                      center: feature.center,
                      dragPointCoordinate: _this._dragPoint.coordinates
                  });
                  window.setTimeout(function () {
                      _this._removeDraw();
                  });
              });
          }
          return this;
      };
      CircleSearch.prototype._initEvent = function () {
          var mapElement = this.map.map.getViewport();
          this._eventKeys.push(this.map.map.on("pointermove", pointerMoveHandler.bind(this)));
          this._eventKeys.push(listen$1(mapElement, "mouseup", pointerUpHandler, this));
          this._eventKeys.push(listen$1(mapElement, "mousedown", pointerDownHandler, this));
      };
      CircleSearch.prototype._clearEvent = function () {
          this.unByKey(this._eventKeys);
          this._eventKeys.length = 0;
      };
      CircleSearch.prototype._initFeatures = function (feature) {
          var _a;
          var centerCoordinates = feature.center;
          var radius = feature.radius;
          var dragPointCoordinates = transformToDataProjection(Turf__namespace.transformTranslate(feature.geoJson, radius / 1000, 90).geometry.coordinates, WGS84_PROJECTION_NAME);
          var _b = this.options, linkedLineStyle = _b.linkedLineStyle, centerPointStyle = _b.centerPointStyle, dragPointStyle = _b.dragPointStyle, circleStyle = _b.circleStyle;
          this._circle = new Circle({ center: centerCoordinates, radius: radius });
          this._circle.setStyle(circleStyle || CIRCLE_SEARCH_STYLE.circle);
          this._layer.addFeature(this._circle);
          this._centerPoint = new Point$1({ coordinates: centerCoordinates });
          this._centerPoint.setStyle(centerPointStyle || CIRCLE_SEARCH_STYLE.centerPoint);
          this._layer.addFeature(this._centerPoint);
          this._linkedLine = new Polyline$1({ coordinates: [centerCoordinates, dragPointCoordinates] });
          this._linkedLine.setStyle(linkedLineStyle || CIRCLE_SEARCH_STYLE.linkedLine);
          this._layer.addFeature(this._linkedLine);
          this._dragPoint = new Point$1({ coordinates: dragPointCoordinates });
          this._dragPoint.setStyle(dragPointStyle || CIRCLE_SEARCH_STYLE.dragPoint);
          this._layer.addFeature(this._dragPoint);
          (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(dragPointCoordinates);
      };
      CircleSearch.prototype._active = function (feature) {
          this._initEvent();
          this._initFeatures(feature);
      };
      CircleSearch.prototype._clearFeatures = function () {
          this._layer.clearFeatures();
          this._centerPoint = this._linkedLine = this._dragPoint = this._circle = void 0;
      };
      CircleSearch.prototype._removeDraw = function () {
          if (this._draw) {
              this.map.removeComponent(this._draw, true);
              this._draw = void 0;
          }
      };
      CircleSearch.prototype.deactive = function () {
          if (this._infoPopup) {
              this._infoPopup.setPosition();
          }
          this._removeDraw();
          this._clearFeatures();
          this._clearEvent();
          return this;
      };
      /**
       * 禁用地图平移交互组件
       */
      CircleSearch.prototype._disableMapDragPan = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DragPan__default["default"]) {
                  this._mapDragPan = item;
                  item.setActive(false);
                  break;
              }
          }
      };
      /**
       * 启用地图平移拖拽交互组件
       */
      CircleSearch.prototype._enableMapDragPan = function () {
          if (defined$1(this._mapDragPan)) {
              this._mapDragPan.setActive(true);
              this._mapDragPan = void 0;
          }
      };
      CircleSearch.prototype.setCircleRadius = function (radius) {
          if (typeof radius === "number" &&
              radius >= this.minRadius &&
              (!defined$1(this.maxRadius) || radius <= this.maxRadius)) {
              changeCircleRadius.call(this, radius);
          }
          return this;
      };
      CircleSearch.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map.removeOverlay(this._infoPopup);
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      CircleSearch.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          this._infoPopup = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置可拖拽的最小半径  单位: 米
       */
      CircleSearch.prototype.setMinRadius = function (radius) {
          this._minRadius = radius;
          return this;
      };
      /**
       * 设置可拖拽的最大半径  单位: 米
       */
      CircleSearch.prototype.setMaxRadius = function (radius) {
          this._maxRadius = radius;
          return this;
      };
      return CircleSearch;
  }(Component$1));
  function pointerDownHandler(e) {
      if (this._hovering) {
          this._disableMapDragPan();
          this._dragging = true;
      }
  }
  function pointerUpHandler() {
      this.map.map.getViewport().style.cursor = "";
      if (this._dragging) {
          this._hovering = false;
          this._dragging = false;
          this._enableMapDragPan();
          this.dispatchEvent({
              type: BaseEventType.EDIT_END,
              radius: this._circle.radius,
              center: this._circle.center,
              dragPointCoordinate: this._dragPoint.coordinates
          });
      }
  }
  function pointerMoveHandler(e) {
      var _this = this;
      var feature = this.map.map.forEachFeatureAtPixel(e.pixel, function (olFeature) {
          return olFeature === _this._dragPoint.sourceFeature;
      }, {
          layerFilter: function (olLayer) {
              return olLayer === _this._layer.layer[0];
          }
      });
      if (defined$1(feature)) {
          this._hovering = true;
          this.map.map.getViewport().style.cursor = "move";
      }
      else if (!this._dragging) {
          this._hovering = false;
          this.map.map.getViewport().style.cursor = "";
      }
      if (this._dragging) {
          var coordinate = transformInternal(this.map.map.getCoordinateFromPixel(e.pixel), {
              source: PUBLIC_CONFIG.projection,
              destination: WGS84_PROJECTION_NAME
          });
          var center = transformInternal(this._circle.center, {
              destination: WGS84_PROJECTION_NAME,
              source: this._circle.dataProjection
          });
          var newR = Turf__namespace.distance(center, coordinate) * 1000;
          if (this._step) {
              newR = newR - (newR % this._step);
          }
          if (!(newR >= this.minRadius && (!defined$1(this.maxRadius) || newR <= this.maxRadius))) {
              return;
          }
          changeCircleRadius.call(this, newR);
      }
  }
  function changeCircleRadius(radius) {
      var _a;
      if (this._circle.radius === radius) {
          return;
      }
      var newDragCoordinates = Turf__namespace.transformTranslate(this._circle.geoJson, radius / 1000, 90).geometry
          .coordinates;
      this._circle.setRadius(radius);
      this._dragPoint.setCoordinates(newDragCoordinates);
      this._linkedLine.setCoordinates([this._circle.center, newDragCoordinates]);
      (_a = this._infoPopup) === null || _a === void 0 ? void 0 : _a.setPosition(newDragCoordinates);
      this.dispatchEvent({
          type: BaseEventType.RADIUS_CHANGE,
          radius: radius,
          center: this._circle.center,
          dragPointCoordinate: this._dragPoint.coordinates
      });
  }

  var HistoryTrack = /** @class */ (function (_super) {
      __extends$6(HistoryTrack, _super);
      function HistoryTrack(options, map) {
          var _this = _super.call(this, options, map) || this;
          _this.setLoop(options.loop || false);
          _this.setVelocity(options.velocity || 1);
          _this.setTrack(options.track || false);
          _this._duration = options.duration;
          _this._paused = false;
          return _this;
      }
      Object.defineProperty(HistoryTrack.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "loop", {
          get: function () {
              return this._loop;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "velocity", {
          get: function () {
              return this._velocity;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(HistoryTrack.prototype, "track", {
          get: function () {
              return this._track;
          },
          enumerable: false,
          configurable: true
      });
      HistoryTrack.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({});
          var _a = this.options, pathCoordinates = _a.path, targetStyle = _a.targetStyle, pathStyle = _a.pathStyle, originStyle = _a.originStyle, destinationStyle = _a.destinationStyle;
          this._pathGeoJsonFeature = Array.isArray(pathCoordinates) ? lineString(pathCoordinates) : pathCoordinates;
          this._pathCoordinates = this._pathGeoJsonFeature.geometry.coordinates;
          this._pathDistance = Turf__namespace.length(this._pathGeoJsonFeature) * 1000;
          if (pathStyle) {
              this._path = new Polyline$1({ coordinates: this._pathCoordinates });
              this._path.setStyle(pathStyle);
              this._layer.addFeature(this._path);
          }
          if (originStyle) {
              this._origin = new Point$1({ coordinates: this._pathCoordinates[0] });
              this._origin.setStyle(originStyle);
              this._layer.addFeature(this._origin);
          }
          if (destinationStyle) {
              this._destination = new Point$1({ coordinates: this._pathCoordinates[this._pathCoordinates.length - 1] });
              this._destination.setStyle(destinationStyle);
              this._layer.addFeature(this._destination);
          }
          this._target = new Point$1({ coordinates: this._pathCoordinates[0] });
          this._target.setStyle(targetStyle);
          this._layer.addFeature(this._target);
      };
      HistoryTrack.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      HistoryTrack.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._clearEvent();
          this._reset();
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      HistoryTrack.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._pathCoordinates =
              this._target =
                  this._origin =
                      this._path =
                          this._destination =
                              this._layer =
                                  this._pathGeoJsonFeature =
                                      void 0;
          _super.prototype._destroy.call(this);
      };
      HistoryTrack.prototype._initEvent = function () {
          var _this = this;
          var previousTime = performance.now();
          var olStyleList = this._target.sourceFeature.getStyleFunction()(this._target.sourceFeature, this.map.map.getView().getResolution()).filter(function (s) { return s.getImage() instanceof OlIcon__default["default"] && s.getImage()[ICON_ROTATED]; });
          this._eventKey = this.map.map.on("postrender", function (e) {
              if (!_this._paused) {
                  var rate = void 0;
                  if (defined$1(_this._duration)) {
                      _this._time += (performance.now() - previousTime) / 1000;
                      rate = _this._time / _this._duration;
                  }
                  else {
                      _this._distance += ((performance.now() - previousTime) / 1000) * _this.velocity;
                      rate = _this._distance / _this._pathDistance;
                  }
                  rate = rate >= 1 ? 1 : rate;
                  var slicedLineFeature = Turf__namespace.lineSliceAlong(_this._pathGeoJsonFeature, 0, (_this._pathDistance * rate) / 1000);
                  var newPointCoordinate = slicedLineFeature.geometry.coordinates[slicedLineFeature.geometry.coordinates.length - 1];
                  if (_this.track) {
                      _this.map.setCenter(newPointCoordinate);
                  }
                  var rotation_1 = computeRotationRadians(slicedLineFeature.geometry.coordinates[slicedLineFeature.geometry.coordinates.length - 2], newPointCoordinate) -
                      Math.PI * 0.5;
                  olStyleList.forEach(function (i) {
                      i.getImage().setRotation(i.getImage()[ORIGINAL_ROTATION] + rotation_1);
                  });
                  _this._target.setCoordinates(newPointCoordinate);
                  _this.dispatchEvent({
                      type: BaseEventType.MOVE,
                      progress: rate,
                      position: newPointCoordinate
                  });
                  if (rate >= 1) {
                      if (!_this.loop) {
                          _this._clearEvent();
                          _this.dispatchEvent({
                              type: BaseEventType.MOVE_END,
                              progress: rate,
                              position: newPointCoordinate
                          });
                      }
                      else {
                          _this._reset();
                      }
                      return;
                  }
              }
              previousTime = performance.now();
              _this._triggerRender();
          });
      };
      HistoryTrack.prototype._triggerRender = function () {
          this._layer.layer[0].changed();
      };
      HistoryTrack.prototype._clearEvent = function () {
          if (this._eventKey) {
              this.unByKey(this._eventKey);
              this._eventKey = void 0;
          }
      };
      HistoryTrack.prototype._reset = function () {
          this._time = this._distance = 0;
          this._target.setCoordinates(this._pathCoordinates[0]);
          this.resume();
      };
      HistoryTrack.prototype.start = function () {
          if (this._eventKey) {
              return this;
          }
          this._reset();
          this._clearEvent();
          this._initEvent();
          this._triggerRender();
          return this;
      };
      HistoryTrack.prototype.pause = function () {
          this._paused = true;
          return this;
      };
      HistoryTrack.prototype.resume = function () {
          this._paused = false;
          return this;
      };
      HistoryTrack.prototype.stop = function () {
          this._reset();
          this._clearEvent();
          return this;
      };
      HistoryTrack.prototype.setLoop = function (loop) {
          this._loop = loop;
          return this;
      };
      HistoryTrack.prototype.setVelocity = function (velocity) {
          this._velocity = velocity;
          return this;
      };
      HistoryTrack.prototype.setTrack = function (track) {
          this._track = track;
          return this;
      };
      return HistoryTrack;
  }(Component$1));

  /**
   * 编辑军事组件
   */
  var PlotEdit = /** @class */ (function (_super) {
      __extends$6(PlotEdit, _super);
      function PlotEdit(map) {
          var _this = _super.call(this, {}, map) || this;
          _this._elementTable = {};
          _this._activeControlPointId = null;
          _this._mapDragPan = null;
          return _this;
      }
      Object.defineProperty(PlotEdit.prototype, "isActive", {
          get: function () {
              return defined$1(this._feature);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PlotEdit.prototype, "minRadius", {
          set: function (val) {
              this._minRadius = val / 1000;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PlotEdit.prototype, "maxRadius", {
          set: function (val) {
              this._maxRadius = val / 1000;
          },
          enumerable: false,
          configurable: true
      });
      PlotEdit.prototype.init = function () {
          this.initialized = true;
          this._mapViewport = this.map.map.getViewport();
      };
      /**
       * 地图容器所属的父容器----
       */
      PlotEdit.prototype.getMapParentElement = function () {
          var mapElement = this.map.map.getTargetElement();
          return mapElement.parentNode;
      };
      PlotEdit.prototype.initHelperDom = function () {
          if (!this.map || !this._feature) {
              return;
          }
          var parent = this.getMapParentElement();
          if (!parent) {
              return;
          }
          // 创建隐藏div
          var hiddenDiv = createHidden("div", parent, "p-helper-hidden-div");
          var cPnts = this.getControlPoints();
          for (var i = 0; i < cPnts.length; i++) {
              var id = PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i;
              create$4("div", PlotEdit.HELPER_CONTROL_POINT_DIV, hiddenDiv, id);
              this._elementTable[id] = i;
          }
      };
      /**
       * 释放资源------销毁所有的overlay覆盖物，以及释放overlay的事件监听----
       */
      PlotEdit.prototype.destroyHelperDom = function () {
          if (this._controlPoints) {
              for (var i = 0; i < this._controlPoints.length; i++) {
                  // 删除overlay 覆盖物----
                  this.map.removeOverlay(this._controlPoints[i]);
                  var element = get$1(PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i);
                  if (element) {
                      off(element, "mousedown", this._controlPointMouseDownHandler, this);
                      off(element, "mousemove", this._controlPointMouseMoveHandler, this);
                  }
              }
              this._controlPoints = [];
          }
          var parent = this.getMapParentElement();
          var hiddenDiv = get$1(PlotEdit.HELPER_CONTROL_POINT_DIV);
          if (hiddenDiv && parent) {
              parent.removeChild(hiddenDiv);
          }
      };
      // 初始化控制点-----添加overlay,并添加事件-----
      PlotEdit.prototype.initControlPoints = function () {
          if (!this.map) {
              return;
          }
          this._controlPoints = [];
          var cPnts = this.getControlPoints();
          for (var i = 0; i < cPnts.length; i++) {
              var id = PlotEdit.HELPER_CONTROL_POINT_DIV + "-" + i;
              var element = get$1(id);
              var pnt = new Overlay({
                  positioning: Positioning.CENTER_CENTER,
                  id: id,
                  position: cPnts[i],
                  element: element
              });
              this._controlPoints.push(pnt);
              this.map.addOverlay(pnt);
              on(element, "mousedown", this._controlPointMouseDownHandler, this, false);
              on(element, "mousemove", this._controlPointMouseMoveHandler, this, false);
          }
      };
      /**
       * 编辑控制点的鼠标移动
       * @param e
       */
      PlotEdit.prototype._controlPointMouseMoveHandler = function (e) {
          e.stopImmediatePropagation();
      };
      PlotEdit.prototype._controlPointMouseDownHandler = function (e) {
          var id = e.target.id;
          this._activeControlPointId = id;
          on(this._mapViewport, "mousemove", this._mapViewportMouseMoveHandler, this, false);
          on(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this, false);
          this.dispatchEvent({ type: "modifystart", feature: this._feature });
      };
      PlotEdit.prototype._mapViewportMouseMoveHandler = function (e) {
          var coordinate = transformToDataProjection(this.map.map.getCoordinateFromPixel([e.offsetX, e.offsetY]));
          if (this._activeControlPointId) {
              var index = this._elementTable[this._activeControlPointId];
              var _raduis = this._feature.get("plot").ellipsoidRaduis;
              this._feature.get("plot").updatePoint(coordinate, index);
              if (this._feature.type === FeatureType.CIRCLE) {
                  if (index === 0) {
                      var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(this._feature.get("plot").center), _raduis, 90).geometry.coordinates;
                      this._feature.get("plot").updatePoint(dragPointCoordinates, index + 1);
                      this._controlPoints[0].setPosition(this._feature.get("plot").getPoints()[0]);
                      this._controlPoints[1].setPosition(this._feature.get("plot").getPoints()[1]);
                      this._feature.setCenter(this._feature.get("plot").center);
                  }
                  else {
                      var center = this._feature.center;
                      var _radius = calculatesRadius(center, coordinate);
                      if (_radius <= this._minRadius) {
                          coordinate = Turf__namespace.transformTranslate(Turf__namespace.point(center), this._minRadius, 90).geometry
                              .coordinates;
                          this._feature.get("plot").updatePoint(coordinate, index);
                      }
                      if (_radius >= this._maxRadius) {
                          coordinate = Turf__namespace.transformTranslate(Turf__namespace.point(center), this._maxRadius, 90).geometry
                              .coordinates;
                          this._feature.get("plot").updatePoint(coordinate, index);
                      }
                      this._feature.setRadius(this._feature.get("plot").ellipsoidRaduis * 1000);
                  }
              }
              else {
                  this._feature.setCoordinates(this._feature.get("plot").coordinates);
              }
              var overlay = this.map.getOverlay(this._activeControlPointId);
              overlay.setPosition(coordinate);
          }
      };
      PlotEdit.prototype._mapViewportMouseUpHandler = function (e) {
          off(this._mapViewport, "mousemove", this._mapViewportMouseMoveHandler, this);
          off(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this);
          this.dispatchEvent({ type: "modifyend", feature: this._feature });
      };
      /**
       * 激活编辑控件------
       * @param {*} plot 军事标绘实例
       */
      PlotEdit.prototype.active = function (feature) {
          if (feature === this._feature) {
              return;
          }
          this.deactive();
          // 保存示例
          this._feature = feature;
          if (this._feature.type === FeatureType.CIRCLE) {
              var center = this._feature.center;
              var radius = this._feature.radius / 1000;
              var dragPointCoordinates = Turf__namespace.transformTranslate(Turf__namespace.point(center), radius, 90).geometry
                  .coordinates;
              this._feature.set("plot", createDraw(DrawType.CIRCLE, [center, dragPointCoordinates]));
              //在这做处理---圆可以反算
          }
          // 初始化dom元素点
          this.initHelperDom();
          // 初始化控件点
          this.initControlPoints();
          return this;
      };
      // 获取几何图形的控制点--
      PlotEdit.prototype.getControlPoints = function () {
          if (!this._feature) {
              return [];
          }
          var _coords = this._feature.get("plot").getPoints().slice();
          return _coords;
      };
      // 注销所有的事件监听器------
      PlotEdit.prototype.disconnectEventHandlers = function () {
          off(this._mapViewport, "mouseover", this._mapViewportMouseMoveHandler, this);
          off(this._mapViewport, "mouseup", this._mapViewportMouseUpHandler, this);
      };
      // 销毁并释放资源---
      PlotEdit.prototype.deactive = function () {
          this._feature = null;
          this._mouseOver = false;
          this.destroyHelperDom();
          this.disconnectEventHandlers();
          this._elementTable = {};
          this._activeControlPointId = null;
          return this;
      };
      // 禁用拖拽平移交互组件---
      PlotEdit.prototype.disableMapDragPan = function () {
          var interactions = this.map.map.getInteractions();
          var length = interactions.getLength();
          for (var i = 0; i < length; i++) {
              var item = interactions.item(i);
              if (item instanceof DragPan__default["default"]) {
                  this._mapDragPan = item;
                  item.setActive(false);
                  break;
              }
          }
      };
      // 启用地图平移拖拽交互组件-----
      PlotEdit.prototype.enableMapDragPan = function () {
          if (this._mapDragPan !== null) {
              this._mapDragPan.setActive(true);
              this._mapDragPan = null;
          }
      };
      PlotEdit.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          this.deactive();
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = undefined;
      };
      PlotEdit.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
          this._mapViewport = undefined;
      };
      PlotEdit.HELPER_HIDDEN_DIV = "p-helper-hidden-div";
      PlotEdit.HELPER_CONTROL_POINT_DIV = "p-helper-control-point-div";
      return PlotEdit;
  }(Component$1));

  /**
   * 编辑类------huhongxun
   */
  var Edit = /** @class */ (function (_super) {
      __extends$6(Edit, _super);
      function Edit(options, map) {
          var _this = this;
          var baseOptions = __assign$1({}, (options || {}));
          if (baseOptions.target) {
              if (!Array.isArray(baseOptions.target)) {
                  baseOptions.target = [baseOptions.target];
              }
          }
          _this = _super.call(this, __assign$1({ snap: true, minRadius: 50, maxRadius: Number.MAX_VALUE }, baseOptions)) || this;
          _this._collection = new Collection$1();
          options.condition && (_this._conditionFunc = options.condition);
          _this._targetEventKeys = [];
          if (map) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Edit.prototype, "edit", {
          get: function () {
              return this._edit;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Edit.prototype, "isActive", {
          get: function () {
              if (defined$1(this._edit)) {
                  if (this._edit.constructor === Modify__default["default"]) {
                      return true;
                  }
                  else {
                      return this._edit.isActive;
                  }
              }
              else {
                  return false;
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Edit.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       *
       * @param feature    * 激活编辑组件
       * 二维可选，三维必传，二维如果编辑军事要素要素必传，
       * @returns
       */
      Edit.prototype.active = function (feature) {
          if (!defined$1(this.map)) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          this.deactive();
          if (defined$1(feature)) {
              if (feature.get("isPlot")) {
                  if (Array.isArray(feature.get("plot")) && defined$1(feature.get("plotType"))) {
                      feature.set("plot", createDraw(feature.get("plotType"), feature.get("plot")));
                  }
                  this._edit = new PlotEdit(this.map);
                  this._edit.minRadius = this.options.minRadius;
                  this._edit.maxRadius = this.options.maxRadius;
                  this._edit.active(feature);
                  this._eventStartKey = this.edit.on("modifystart", this._editStartHandle.bind(this));
                  this._eventEndKey = this.edit.on("modifyend", this._editEndHandle.bind(this));
              }
              else {
                  var collection = new Collection$1([feature.sourceFeature]);
                  this._addEditInteractions(collection);
              }
          }
          else {
              this._addEditInteractions();
          }
          return this;
      };
      Edit.prototype.addFeatures = function (features) {
          var _this = this;
          features.map(function (f) {
              _this._collection.push(f.sourceFeature);
          });
      };
      Edit.prototype.removeFeatures = function (features) {
          var _this = this;
          features.map(function (f) {
              _this._collection.remove(f.sourceFeature);
          });
      };
      Edit.prototype.deactive = function () {
          if (this.isActive) {
              if (this._edit.constructor === Modify__default["default"]) {
                  this._removeLastInteraction();
              }
              else {
                  this.map.removeComponent(this._edit);
                  this._edit = void 0;
              }
              this._eventEndKey && Observable$3.unByKey(this._eventEndKey);
              this._eventStartKey && Observable$3.unByKey(this._eventStartKey);
              this._eventEndKey = undefined;
              this._eventStartKey = undefined;
          }
          return this;
      };
      Edit.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          this._style = new OlStyle__default["default"]();
          var _styles = this.options.editStyle || EDIT_STYLE;
          this._style.setImage(new CircleStyle__default["default"]({
              radius: _styles[0].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[0].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[0].strokeColor }, _styles[0]))
          }));
          this._style.setText(new Text__default["default"](__assign$1({ text: _styles[1].text }, _styles[1])));
          this._style.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[2].borderColor }, _styles[2])));
          this._style.setFill(new Fill__default["default"]({ color: _styles[3].fillColor }));
          this.options.target &&
              this.options.target
                  .map(function (_layer) {
                  var _a;
                  (_a = _this._targetEventKeys).push.apply(_a, __spreadArray$1([], __read(_layer.on([BaseEventType.ADD_FEATURE, BaseEventType.REMOVE_FEATURE], _this._updateFeature.bind(_this))), false));
                  return _layer.getFeatures();
              })
                  .flat().forEach(function (f) {
                  _this._collection.push(f.sourceFeature);
              });
      };
      Edit.prototype._updateFeature = function (event) {
          var type = event.type;
          var feature = event.feature;
          if (type === BaseEventType.ADD_FEATURE) {
              this._collection.push(feature.sourceFeature);
          }
          if (type === BaseEventType.REMOVE_FEATURE) {
              this._collection.remove(feature.sourceFeature);
          }
      };
      Edit.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
      };
      Edit.prototype._destroy = function () {
          this.remove();
          this._targetEventKeys.length && this.unByKey(this._targetEventKeys);
          this._targetEventKeys = [];
          _super.prototype._destroy.call(this);
      };
      /**
       * 编辑开始时的监听处理--------
       * @param event
       * @private
       */
      Edit.prototype._editStartHandle = function (event) {
          var feature = event.feature || event.features.item(0);
          var _feature;
          if (feature instanceof Feature) {
              _feature = feature;
          }
          else {
              _feature = feature[FEATURE_LINK];
              this._originFeatures = this._collection.getArray().map(function (f) {
                  return { id: getUid(f), version: f.getRevision() };
              });
          }
          this.dispatchEvent({ type: BaseEventType.EDIT_START, feature: _feature });
      };
      /**
       * 编辑完成时的回调------
       * @param event
       * @private
       */
      Edit.prototype._editEndHandle = function (event) {
          var _this = this;
          var feature = event.feature || event.features.item(0);
          var _feature;
          var features = [];
          var _geojson = new Geojson__default["default"]();
          if (feature instanceof Feature) {
              _feature = feature;
          }
          else {
              this._collection.forEach(function (f) {
                  _this._originFeatures.forEach(function (_f) {
                      if (getUid(f) === _f.id && f.getRevision() !== _f.version) {
                          var vector = f[FEATURE_LINK];
                          var _coordinates = _geojson.writeFeatureObject(f, {
                              dataProjection: vector.dataProjection,
                              featureProjection: vector.projection
                          }).geometry.coordinates;
                          vector.setCoordinates(_coordinates, { update: false });
                          features.push(vector);
                      }
                  });
              });
              _feature = feature[FEATURE_LINK];
          }
          this.dispatchEvent({ type: BaseEventType.EDIT_END, feature: _feature, features: features });
      };
      Edit.prototype._removeLastInteraction = function () {
          if (this._edit) {
              this.map.map.removeInteraction(this._edit);
              this._edit = null;
          }
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
              this._snap = null;
          }
      };
      Edit.prototype._addEditInteractions = function (collection) {
          if (collection) {
              this._edit = new Modify__default["default"]({
                  condition: this._conditionFunc,
                  insertVertexCondition: this._conditionFunc,
                  features: collection,
                  style: this._style
              });
          }
          else {
              this._edit = new Modify__default["default"]({
                  condition: this._conditionFunc,
                  insertVertexCondition: this._conditionFunc,
                  features: this._collection,
                  style: this._style
              });
          }
          // 添加交互组件到地图中
          this.map.map.addInteraction(this._edit);
          // 绘制组件的事件监听----
          this._eventStartKey = this.edit.on("modifystart", this._editStartHandle.bind(this));
          this._eventEndKey = this.edit.on("modifyend", this._editEndHandle.bind(this));
          // 是否捕捉----
          if (this.options.snap) {
              if (this.options.target) {
                  this._snap = new SnapInteraction__default["default"]({ features: this._collection });
                  this.map.map.addInteraction(this._snap);
              }
          }
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成 | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `editend`    |   左键弹起，表示编辑完成  | (feature: [[Feature]])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组，类型和on()相同
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Edit.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return Edit;
  }(Component$1));

  /**
   * 测量工具类
   */
  var MeasureInteraction = /** @class */ (function (_super) {
      __extends$6(MeasureInteraction, _super);
      // 构造函数---
      function MeasureInteraction(options) {
          var _this = _super.call(this) || this;
          /**
           * 是否自由绘制--
           * @type {boolean}
           */
          _this._freehand = false;
          /**
           * 当前矢量图层，绘制所在的客户端图层---
           * @type {null}
           */
          _this._layer = null;
          /**
           * 交互工具
           * @type {null}
           */
          _this._draw = null;
          /**
           * 工具是否激活
           * @type {boolean}
           */
          _this._isActive = false;
          /**
           * 点击计数器
           * @type {string}
           */
          _this._clickCount = "";
          /**
           * 双击放大交互
           * @type {*}
           */
          _this._doubleClickZoom = null;
          _this._uuids = [];
          _this._layerName = "measure-layer";
          var _styles = options.measureStyle;
          _this._drawStyle = new OlStyle__default["default"]();
          _this._drawStyle.setImage(new CircleStyle__default["default"]({
              radius: _styles[0].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[0].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[0].strokeColor }, _styles[0]))
          }));
          _this._drawStyle.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[1].borderColor }, _styles[1])));
          _this._drawStyle.setFill(new Fill__default["default"]({ color: _styles[2].fillColor }));
          _this._finishStyle = new OlStyle__default["default"]();
          _this._finishStyle.setImage(new CircleStyle__default["default"]({
              radius: _styles[3].radius || 10,
              fill: new Fill__default["default"]({ color: _styles[3].fillColor }),
              stroke: new Stroke__default["default"](__assign$1({ color: _styles[3].strokeColor }, _styles[0]))
          }));
          _this._finishStyle.setStroke(new Stroke__default["default"](__assign$1({ color: _styles[4].borderColor }, _styles[4])));
          _this._finishStyle.setFill(new Fill__default["default"]({ color: _styles[5].fillColor }));
          return _this;
      }
      MeasureInteraction.prototype.handleEvent = function (mapBrowserEvent) {
          if (this.getTool()) {
              if (!this._drawStart && !mapBrowserEvent.dragging) {
                  this.beforeDrawPointClickHandler(mapBrowserEvent);
              }
              else if (this._drawStart && !mapBrowserEvent.dragging) {
                  this.afterDrawPointClickHandler(mapBrowserEvent);
              }
              else if (this._freehand && this._drawStart && mapBrowserEvent.dragging) {
                  this.afterDragHandler_(mapBrowserEvent);
              }
          }
          return true;
      };
      /**
       * 添加绘制交互组件-----
       * @param type
       */
      MeasureInteraction.prototype.addDrawInteractions_ = function (type) {
          var _type;
          if (type === MeasureType.DISTANCE) {
              _type = "LineString";
          }
          if (type === MeasureType.AREA) {
              _type = "Polygon";
          }
          this._draw = new DrawClass__default["default"]({
              type: _type,
              style: this._drawStyle,
              freehand: this._freehand
          });
          var uniqueKey = getUid$2();
          this._draw.set("uuid", uniqueKey);
          this._uuids.push(uniqueKey);
          // 添加交互组件到地图中
          this.getMap().addInteraction(this._draw);
          // 绘制组件的事件监听----
          this._drawstartListener = this._draw.on("drawstart", this.drawStartHandle_.bind(this));
          this._drawendListener = this._draw.on("drawend", this.drawEndHandle_.bind(this));
          // 距离测量标起点
          if (_type === "LineString" && !this._freehand) {
              this._clickListener = this.getMap().on("singleclick", this.drawClickHandle_.bind(this));
          }
      };
      /**
       * 单击事件处理
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawClickHandle_ = function (event) {
          if (this._drawStart && !event.dragging) {
              if (!this._clickCount) {
                  this._clickCount = getUid$2();
                  this._draw.set("measureResult", "起点");
              }
              this.addMeasureOverlay(event.coordinate, this._draw.get("measureResult") || "0.0 平方公里");
          }
      };
      /**
       * 绘制开始时的监听处理--------
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawStartHandle_ = function (event) {
          var _this = this;
          this._drawStart = true;
          event.feature.getGeometry().on("change", function (evt) {
              var geom = evt.target;
              if (geom instanceof LineString__default["default"]) {
                  var output = _this.formatData(geom);
                  _this._draw.set("measureResult", output);
              }
              else if (geom instanceof Polygon__default["default"]) {
                  var area = _this.formatData(geom);
                  _this._draw.set("measureResult", area);
              }
              else if (geom instanceof OLCircleGeom__default["default"]) {
                  var area = _this.formatData(geom);
                  _this._draw.set("measureResult", area);
              }
          });
      };
      /**
       * 绘制完成时的回调------
       * @param event
       * @private
       */
      MeasureInteraction.prototype.drawEndHandle_ = function (event) {
          var feature = event.feature;
          feature.set("uuid", this._draw.get("uuid"));
          this._layer.getSource().addFeature(feature);
          var coordinates = feature.getGeometry().getLastCoordinate();
          if (MeasureType.DISTANCE === this._type) {
              this.addMeasureOverlay(coordinates, this._draw.get("measureResult"), "length");
          }
          if (MeasureType.AREA === this._type) {
              // const center = extent.getCenter(feature.getGeometry().getExtent());
              this.addMeasureOverlay(coordinates, this._draw.get("measureResult"), "area");
          }
          this.addMeasureRemoveButton(coordinates);
          this.removeLastInteraction_();
          this.dispatchEvent(BaseEventType.MEASURE_END);
      };
      /**
       * 点击之前的帮助信息
       * @param event
       */
      MeasureInteraction.prototype.beforeDrawPointClickHandler = function (event) {
          if (!this._measureHelpTooltip && this.getTool()) {
              var helpTooltipElement = document.createElement("span");
              if (MeasureType.DISTANCE === this._type) {
                  helpTooltipElement.className = "mti-measure-tool mti-measure-tool-length";
                  if (this._freehand) {
                      helpTooltipElement.innerHTML = "按下鼠标拖拽开始测量";
                  }
                  else {
                      helpTooltipElement.innerHTML = "单击开始测距";
                  }
              }
              if (MeasureType.AREA === this._type) {
                  helpTooltipElement.className = "mti-measure-tool mti-measure-tool-area";
                  if (this._freehand) {
                      helpTooltipElement.innerHTML = "按下鼠标拖拽开始测量";
                  }
                  else {
                      helpTooltipElement.innerHTML = "单击开始测面";
                  }
              }
              this._measureHelpTooltip = new Overlay__default["default"]({
                  element: helpTooltipElement,
                  offset: [15, 0],
                  positioning: OverlayPositioning.CENTER_LEFT
              });
              this._measureHelpTooltip.set("layerName", this._layerName);
              this.getMap().addOverlay(this._measureHelpTooltip);
          }
          else if (this._measureHelpTooltip && this._measureHelpTooltip instanceof Overlay__default["default"]) {
              this._measureHelpTooltip.setPosition(event.coordinate);
          }
      };
      /**
       * 点击一次后的提示信息
       * @param event
       */
      MeasureInteraction.prototype.afterDrawPointClickHandler = function (event) {
          var helpTooltipElement = this._measureHelpTooltip.getElement();
          if (MeasureType.DISTANCE === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-length";
              var length_1 = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总长：" +
                      "<span class='measure-result'>" +
                      length_1 +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>单击确定地点，双击结束</span>";
          }
          if (MeasureType.AREA === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-area";
              var area = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总面积：" +
                      "<span class='measure-result'>" +
                      area +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>单击确定地点，双击结束</span>";
          }
          this._measureHelpTooltip.setPosition(event.coordinate);
      };
      /**
       * 自由测量时拖拽事件
       * @param event
       * @private
       */
      MeasureInteraction.prototype.afterDragHandler_ = function (event) {
          var helpTooltipElement = this._measureHelpTooltip.getElement();
          if (MeasureType.DISTANCE === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-length";
              var length_2 = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总长：" +
                      "<span class='measure-result'>" +
                      length_2 +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>松开鼠标按键结束测量</span>";
          }
          if (MeasureType.AREA === this._type) {
              helpTooltipElement.className = "mti-measure-tool-move mti-measure-tool-area";
              var area = this._draw.get("measureResult");
              helpTooltipElement.innerHTML =
                  "<span>总面积：" +
                      "<span class='measure-result'>" +
                      area +
                      "</span>" +
                      "</span><br>" +
                      "<span class='tool-tip'>松开鼠标按键结束测量</span>";
          }
          this._measureHelpTooltip.setPosition(event.coordinate);
      };
      /**
       * 添加测量结果overlay
       * @param coordinate
       * @param length
       * @param type
       */
      MeasureInteraction.prototype.addMeasureOverlay = function (coordinate, length, type) {
          var measureResult = document.createElement("span");
          var measureOverlay = null;
          if (type === "length") {
              measureResult.className = "mti-measure-tool-end-overlay-label";
              measureResult.innerHTML = "总长：<span class='measure-end-label'>" + length + "</span>";
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  offset: [10, 10],
                  positioning: OverlayPositioning.TOP_LEFT
              });
          }
          else if (type === "area") {
              measureResult.className = "mti-measure-tool-area-overlay-label";
              measureResult.innerHTML = "<span class='measure-label'>" + length + "</span>";
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  positioning: OverlayPositioning.CENTER_CENTER
              });
          }
          else {
              measureResult.className = "mti-measure-tool-overlay-label";
              measureResult.innerHTML = length;
              measureOverlay = new Overlay__default["default"]({
                  element: measureResult,
                  position: coordinate,
                  offset: [0, -18],
                  positioning: OverlayPositioning.CENTER_CENTER
              });
          }
          measureOverlay.set("layerName", this._layerName);
          measureOverlay.set("uuid", this._draw.get("uuid"));
          this.getMap().addOverlay(measureOverlay);
          this.getMap().render();
      };
      /**
       * 添加单例清除按钮
       * @param coordinate
       */
      MeasureInteraction.prototype.addMeasureRemoveButton = function (coordinate) {
          var imageButton = document.createElement("img");
          imageButton.src =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NEYzMzc1RDY3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NEYzMzc1RDc3RDU1MTFFNUFDNDJFNjQ4NUUwMzRDRDYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0RjMzNzVENDdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0RjMzNzVENTdENTUxMUU1QUM0MkU2NDg1RTAzNENENiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsDx84AAAAC3SURBVHjavJIxDoMwDEV/ok5wDCbu0DvAdUBIwMLFSs/AxDXY6tZ2SCGVUikd+ifn20+2k5hHVd0AXJGmGQw+UyWMxY8KQGpbUNcB23aYHIsnuSgIy8dlAQ2DgwWSmD0YE5ReAq5pQOMIrKsDRByjKGC/dsxz2L7XQgU8JB7n4qDoY6SYF4J+p72T7/zeOXqr03SMx8XnsTUX7UgElKVCyDK3s8Tsae6sv/8ceceZ6jr1k99fAgwAsZy0Sa2HgDcAAAAASUVORK5CYII=";
          imageButton.style.cursor = "pointer";
          imageButton.title = "清除测量结果";
          imageButton.onclick = (function (id) {
              return function () {
                  this.removeMeasure_(id);
                  this.dispatchEvent(BaseEventType.CLEAR);
              };
          })(this._draw.get("uuid")).bind(this);
          var closeBtn = new Overlay__default["default"]({
              element: imageButton,
              offset: [-5, -10],
              position: coordinate,
              positioning: OverlayPositioning.BOTTOM_LEFT
          });
          closeBtn.set("uuid", this._draw.get("uuid"));
          closeBtn.set("layerName", this._layerName);
          this.getMap().addOverlay(closeBtn);
          //this.getMap().render();
      };
      /**
       * 移除测量结果
       * @param uuid
       * @private
       */
      MeasureInteraction.prototype.removeMeasure_ = function (uuid) {
          var overlays = this.getMap().getOverlays().getArray();
          if (overlays && Array.isArray(overlays)) {
              var length_3 = overlays.length;
              // TODO 注意地图移除Overlay时数组长度会变化
              for (var j = 0, i = 0; j < length_3; j++) {
                  i++;
                  if (overlays[length_3 - i] &&
                      overlays[length_3 - i] instanceof Overlay__default["default"] &&
                      overlays[length_3 - i].get("uuid") === uuid) {
                      this.getMap().removeOverlay(overlays[length_3 - i]);
                  }
              }
          }
          if (this._layer && this._layer.getSource()) {
              var source_1 = this._layer.getSource();
              var features = source_1.getFeatures();
              features.forEach(function (feat) {
                  if (feat.get("uuid") === uuid) {
                      source_1.removeFeature(feat);
                  }
              }, this);
          }
      };
      MeasureInteraction.prototype.clear = function () {
          var _this = this;
          if (this._isActive) {
              console.warn("绘制完成，在清除");
              return;
          }
          this._uuids.forEach(function (id) {
              _this.removeMeasure_(id);
          });
      };
      /**
       * 激活测量工具
       * @param active
       * @param key
       * @param freehand
       */
      MeasureInteraction.prototype.active = function (type, freehand) {
          if (freehand === void 0) { freehand = false; }
          this.removeLastInteraction_();
          this._isActive = true;
          this._freehand = freehand;
          this._type = type;
          if (!this._layer) {
              this._layer = new VectorLayer__default["default"]({
                  source: new VectorSource__default["default"]()
              });
              this._layer.set("layerName", this._layerName);
              this._layer.setStyle(this._finishStyle);
              this._layer.setMap(this.getMap());
          }
          this.addDrawInteractions_(type);
      };
      /**
       * 移除上一次激活的工具
       * @private
       */
      MeasureInteraction.prototype.removeLastInteraction_ = function () {
          this._isActive = false;
          this._freehand = false;
          this._drawStart = false;
          if (this._draw) {
              if (this._clickListener) {
                  Observable$3.unByKey(this._clickListener);
                  this._clickListener = undefined;
              }
              // 删除绘制开始监听
              if (this._drawstartListener) {
                  Observable$3.unByKey(this._drawstartListener);
                  this._drawstartListener = undefined;
              }
              // 删除绘制完成S监听
              if (this._drawendListener) {
                  Observable$3.unByKey(this._drawendListener);
                  this._drawendListener = undefined;
              }
              if (this._measureHelpTooltip && this._measureHelpTooltip instanceof Overlay__default["default"]) {
                  this.getMap().removeOverlay(this._measureHelpTooltip);
                  this._measureHelpTooltip = null;
              }
              this._clickCount = "";
              this.disActionInteraction();
              this.getMap().removeInteraction(this._draw);
              this._draw = null;
          }
      };
      /**
       * 判断是否激活---
       * @returns {boolean|*}
       */
      MeasureInteraction.prototype.getTool = function () {
          return this._isActive;
      };
      /**
       *
       *
       */
      MeasureInteraction.prototype.deactive = function () {
          if (this._isActive) {
              this.removeMeasure_(this._draw.get("uuid"));
              this.removeLastInteraction_();
              this._isActive = false;
          }
      };
      /**
       * 禁止交互
       */
      MeasureInteraction.prototype.disActionInteraction = function () {
          var _this = this;
          this._doubleClickZoom = this.getDoubleClickZoomInteraction();
          var active = this._doubleClickZoom.getActive();
          this._doubleClickZoom.setActive(false);
          window.setTimeout(function () {
              _this._doubleClickZoom.setActive(active);
          }, 200);
      };
      /**
       * 获取双击放大交互
       * @returns {ol.interaction.DoubleClickZoom|*}
       */
      MeasureInteraction.prototype.getDoubleClickZoomInteraction = function () {
          var _this = this;
          if (!this._doubleClickZoom) {
              var items = this.getMap().getInteractions().getArray();
              items.every(function (item) {
                  if (item && item instanceof DoubleClickZoom__default["default"]) {
                      _this._doubleClickZoom = item;
                      return false;
                  }
                  else {
                      return true;
                  }
              });
          }
          return this._doubleClickZoom;
      };
      /**
       * 测量结果格式化
       * @param geom
       * @returns {number}
       */
      MeasureInteraction.prototype.formatData = function (geom) {
          var output = "0.0";
          var sourceProj = this.getMap().getView().getProjection();
          var _transformFunc = proj__namespace.getTransform(sourceProj, WGS84_PROJECTION_NAME);
          if (geom) {
              if (this._type === MeasureType.DISTANCE) {
                  var line = /** @type {ol.geom.Polygon} */ geom.clone();
                  line.applyTransform(_transformFunc);
                  var coordinates = line.getCoordinates();
                  if (coordinates.length < 2) {
                      return output + " 米";
                  }
                  // 单位是米
                  var length_4 = Turf__namespace.length(lineString(coordinates)) * 1000;
                  if (length_4 > 100) {
                      output = (length_4 / 1000).toFixed(2) + " " + "公里";
                  }
                  else {
                      output = length_4.toFixed(2) + " " + "米";
                  }
              }
              if (this._type === MeasureType.AREA) {
                  var geometry = /** @type {ol.geom.Polygon} */ geom.clone();
                  geometry.applyTransform(_transformFunc);
                  var coordinates = geometry.getLinearRing(0).getCoordinates();
                  if (coordinates.length <= 3) {
                      return output + " " + "平方公里";
                  }
                  var polygon$1 = polygon([coordinates]);
                  // 单位平方米
                  var area = Math.abs(Turf__namespace.area(polygon$1)) / (1000 * 1000);
                  output = area.toFixed(3) + " " + "平方公里";
              }
          }
          return output;
      };
      return MeasureInteraction;
  }(Interaction__default["default"]));
  var Measure = /** @class */ (function (_super) {
      __extends$6(Measure, _super);
      function Measure(options, map) {
          return _super.call(this, options || {}, map) || this;
      }
      Object.defineProperty(Measure.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Measure.prototype, "type", {
          get: function () {
              return this._type;
          },
          enumerable: false,
          configurable: true
      });
      Measure.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var measureStyle = this.options.measureStyle || __spreadArray$1(__spreadArray$1([], __read(Measure_STYLE.draw), false), __read(Measure_STYLE.finsh), false);
          this._measure = new MeasureInteraction({ measureStyle: measureStyle });
          this._measure.on(BaseEventType.CLEAR, function () {
              _this.dispatchEvent(BaseEventType.CLEAR);
          });
          this._measure.on(BaseEventType.MEASURE_END, function () {
              _this.dispatchEvent(BaseEventType.MEASURE_END);
          });
      };
      Measure.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.map.addInteraction(this._measure);
      };
      /**
       * 测量类型---
       * @param type
       * @returns
       */
      Measure.prototype.active = function (type) {
          this._type = type;
          this._measure && this._measure.active(type);
          return this;
      };
      Measure.prototype.deactive = function () {
          this._measure && this._measure.deactive();
          return this;
      };
      Measure.prototype.clear = function () {
          this._measure && this._measure.clear();
          return this;
      };
      Measure.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._measure.removeLastInteraction_();
          this._measure.clear();
          this.map.map.removeInteraction(this._measure);
          this.map = undefined;
          this._measure = undefined;
      };
      Measure.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `measureend`     |   左键双击，表示测量完成  |
       *  `clear`     |   测量完成后单击清除按钮触发的事件  |
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Measure.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      return Measure;
  }(Component$1));

  var Wall = /** @class */ (function (_super) {
      __extends$6(Wall, _super);
      function Wall(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Wall.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Wall.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Wall.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Wall.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      Wall.prototype.show = function () {
          this._visible = true;
          return this;
      };
      Wall.prototype.hide = function () {
          this._visible = false;
          return this;
      };
      return Wall;
  }(Component$1));

  var Triangulation = /** @class */ (function (_super) {
      __extends$6(Triangulation, _super);
      function Triangulation(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Triangulation.prototype.active = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.deactive = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.clear = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Triangulation.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Triangulation.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Triangulation.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Triangulation;
  }(Component$1));

  var Snap = /** @class */ (function (_super) {
      __extends$6(Snap, _super);
      function Snap(options, map) {
          return _super.call(this, __assign$1({ pixelTolerance: 10 }, (options || {})), map) || this;
      }
      Object.defineProperty(Snap.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       *
       * @param layerId  图层的id标识数组
       * @returns
       */
      Snap.prototype.active = function () {
          if (!this.map) {
              throw new Error(ErrorNotification.NOT_ADD_MAP);
          }
          this.deactive();
          this._snap = new SnapInteraction__default["default"](__assign$1({ features: this._features }, this.options));
          this.map.map.addInteraction(this._snap);
          return this;
      };
      Snap.prototype.addFeatures = function (features) {
          var _this = this;
          if (this._snap) {
              features.forEach(function (feature) {
                  _this._snap.addFeature(feature.sourceFeature);
              });
          }
          return this;
      };
      Snap.prototype.removeFeatures = function (features) {
          var _this = this;
          if (this._snap) {
              features.forEach(function (feature) {
                  _this._snap.removeFeature(feature.sourceFeature);
              });
          }
          return this;
      };
      Snap.prototype.deactive = function () {
          if (this._snap) {
              this.map.map.removeInteraction(this._snap);
          }
          return this;
      };
      Snap.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var target = this.options.target;
          if (Array.isArray(target) && typeof target[0] === "string") {
              this._features = new Collection$1(target
                  .map(function (id) {
                  var _layer = _this.map.getLayer(id);
                  return _layer.layer[0].getSource().getFeatures();
              })
                  .flat());
          }
          if (Array.isArray(target) && target[0] instanceof VectorLayer) {
              this._features = new Collection$1(target
                  .map(function (_layer) {
                  return _layer.layer[0].getSource().getFeatures();
              })
                  .flat());
          }
          if (Array.isArray(target) && target[0] instanceof Feature) {
              this._features = new Collection$1(target.map(function (feature_) { return feature_.sourceFeature; }));
          }
      };
      Snap.prototype.remove = function (destroy) {
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.deactive();
          this.map = undefined;
          this._snap = undefined;
      };
      Snap.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snap;
  }(Component$1));

  /**
   * 扩散圆组件
   */
  var RippleCircle = /** @class */ (function (_super) {
      __extends$6(RippleCircle, _super);
      function RippleCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, color: "rgba(255,0,0,1)", height: 0, duration: 3, image: CIRCLE_WHITE_IMAGE }, options), map) || this;
      }
      Object.defineProperty(RippleCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RippleCircle.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.RIPPLE }, this.options)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      RippleCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RippleCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RippleCircle;
  }(Component$1));

  /**
   * 旋转圆组件
   */
  var RotateCircle = /** @class */ (function (_super) {
      __extends$6(RotateCircle, _super);
      function RotateCircle(options, map) {
          return _super.call(this, __assign$1({ radius: 100, duration: 3, color: "rgba(255,255,255,1)", reverse: false }, options), map) || this;
      }
      Object.defineProperty(RotateCircle.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      RotateCircle.prototype.init = function () {
          this.initialized = true;
          this._layer = new VectorLayer({
              data: [
                  new Circle({ center: this.options.center, radius: this.options.radius }).setStyle([
                      __assign$1({ type: StyleItemType.ROTATE }, this.options)
                  ])
              ]
          });
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
      };
      /**
       * @ignore
       */
      RotateCircle.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      RotateCircle.prototype._destroy = function () {
          this.remove();
          this._layer.destroy();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      return RotateCircle;
  }(Component$1));

  /**
   * 右键菜单组件
   */
  var ContextMenu = /** @class */ (function (_super) {
      __extends$6(ContextMenu, _super);
      function ContextMenu(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(ContextMenu.prototype, "autoClose", {
          get: function () {
              return this._autoClose;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "theme", {
          get: function () {
              return this._theme;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(ContextMenu.prototype, "target", {
          /**
           * 绑定对象
           *
           * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
           */
          get: function () {
              return this._target;
          },
          enumerable: false,
          configurable: true
      });
      ContextMenu.prototype.init = function () {
          var _this = this;
          this.initialized = true;
          var _a = this.options, theme = _a.theme, autoClose = _a.autoClose, list = _a.list, target = _a.target;
          if (!defined$1(this._autoClose)) {
              this._autoClose = defined$1(autoClose) ? autoClose : true;
          }
          if (!defined$1(this._theme)) {
              this._theme = theme || "dark";
          }
          if (!defined$1(this.target)) {
              this._target = target;
          }
          var pickLayers;
          this._overlay = new Overlay({
              element: createContextMenuElement({ list: list || [], theme: this._theme }, function (e) {
                  _this.dispatchEvent({
                      type: BaseEventType.CLICK,
                      item: list.find(function (val) { return String(val.id) === String(e.target.getAttribute("data-id")); }),
                      layers: pickLayers
                  });
                  if (_this._autoClose) {
                      _this.hide();
                  }
              }),
              useEvent: true
          });
          this._eventKey = this.map.on([BaseEventType.CLICK, BaseEventType.RIGHT_CLICK], function (_a) {
              var coordinate = _a.coordinate, type = _a.type, pixel = _a.pixel, layers = _a.layers;
              if (!defined$1(_this.map)) {
                  return;
              }
              if (type === BaseEventType.CLICK) {
                  if (_this._overlay.visible) {
                      _this.dispatchEvent({ type: BaseEventType.HIDE });
                  }
                  _this.hide();
              }
              else {
                  pickLayers = void 0;
                  if (_this.target) {
                      if (_this.target instanceof VectorLayer && !layers.find(function (i) { return i.layer === _this.target; })) {
                          return;
                      }
                      else if (_this.target instanceof Feature &&
                          !layers.find(function (_a) {
                              var features = _a.features;
                              return features.find(function (feature) { return feature === _this.target; }) !== void 0;
                          })) {
                          return;
                      }
                      else if (typeof _this.target === "function" && !_this.target({ pixel: pixel, coordinate: coordinate, layers: layers })) {
                          return;
                      }
                      else if (Array.isArray(_this.target) &&
                          _this.target[0] instanceof VectorLayer &&
                          !layers.find(function (_a) {
                              var layer = _a.layer;
                              return _this.target.find(function (i) { return i === layer; }) !== void 0;
                          })) {
                          return;
                      }
                      else if (Array.isArray(_this.target) &&
                          _this.target[0] instanceof Feature &&
                          !layers.find(function (_a) {
                              var features = _a.features;
                              return (_this.target.find(function (i) {
                                  return features.find(function (f) { return f === i; }) !== void 0;
                              }) !== void 0);
                          })) {
                          return;
                      }
                  }
                  pickLayers = layers;
                  _this.dispatchEvent({ type: BaseEventType.SHOW, coordinate: coordinate, pixel: pixel, layers: layers });
                  _this._overlay.setPosition(coordinate);
              }
          });
      };
      ContextMenu.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addOverlay(this._overlay);
      };
      /**
       * @ignore
       */
      ContextMenu.prototype.remove = function (destroy) {
          if (!defined$1(this.map)) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeOverlay(this._overlay);
          this.map = void 0;
      };
      /**
       * @ignore
       */
      ContextMenu.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          clearContextMenuElementEvent(this._overlay.element);
          this._overlay.destroy();
          this._overlay = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 关闭菜单
       */
      ContextMenu.prototype.hide = function () {
          this._overlay.setPosition();
          return this;
      };
      /**
       * 设置右键菜单主题
       */
      ContextMenu.prototype.setTheme = function (
      /**
       * 提示框样式主题
       *
       * 可选值:'dark','light'
       */
      theme) {
          this._overlay.element.classList.replace(this._theme, theme);
          this._theme = theme;
          return this;
      };
      /**
       * 设置绑定对象
       *
       * 当该参数未设置时,任意位置右键可显示菜单;当参数存在时,右键点到绑定对象时显示菜单;条件函数返回true时显示菜单;
       */
      ContextMenu.prototype.setTarget = function (target) {
          this._target = target;
          this.options.target = target;
          return this;
      };
      /**
       * 设置弹窗是否自动关闭
       */
      ContextMenu.prototype.setAutoClose = function (autoClose) {
          this._autoClose = autoClose;
          return this;
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |  菜单点击  | (item: [number,number])-点击的菜单项
       *  `show` |  菜单显示  | (pixel: [number,number])-屏幕坐标, (coordinate: [[PointCoordinate]])-经纬度坐标
       *  `hide` |  点击地图时菜单隐藏  |
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      ContextMenu.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      return ContextMenu;
  }(Component$1));

  var Atmosphere = /** @class */ (function (_super) {
      __extends$6(Atmosphere, _super);
      function Atmosphere(options, map) {
          return _super.call(this, options, map) || this;
      }
      // 重写父类方法
      Atmosphere.prototype.init = function () { };
      /**
       * 清除修改、恢复修改之前的设置
       * @memberof Atmosphere
       * @instance
       */
      Atmosphere.prototype.remove = function () { };
      return Atmosphere;
  }(Component$1));

  var Fire = /** @class */ (function (_super) {
      __extends$6(Fire, _super);
      function Fire(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Fire.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Fire.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Fire.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Fire;
  }(Component$1));

  /**
   * @class Fountain
   */
  var Fountain = /** @class */ (function (_super) {
      __extends$6(Fountain, _super);
      function Fountain(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Fountain.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Fountain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Fountain.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Fountain;
  }(Component$1));

  var Light = /** @class */ (function (_super) {
      __extends$6(Light, _super);
      function Light(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Light.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Light.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Light.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Light;
  }(Component$1));

  /**

   * @export
   * @class Rain
   */
  var Rain = /** @class */ (function (_super) {
      __extends$6(Rain, _super);
      function Rain(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Rain.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Rain.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Rain.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Rain;
  }(Component$1));

  var Snow = /** @class */ (function (_super) {
      __extends$6(Snow, _super);
      function Snow(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Snow.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      Snow.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      Snow.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return Snow;
  }(Component$1));

  /**
   * 移动任务队列组件
   */
  var TranslationQueue = /** @class */ (function (_super) {
      __extends$6(TranslationQueue, _super);
      function TranslationQueue(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(TranslationQueue.prototype, "jobScheduler", {
          get: function () {
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      TranslationQueue.prototype.init = function () {
          this.initialized = true;
          this._taskIdStore = {};
          this._jobScheduler = new JobScheduler();
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.stop();
          this.clearTask();
          this._jobScheduler = void 0;
          this._taskIdStore = void 0;
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      TranslationQueue.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      TranslationQueue.prototype.addTask = function (taskOptions) {
          var _this = this;
          if (this.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          var target = taskOptions.target, coordinates = taskOptions.coordinates, duration = taskOptions.duration;
          var jobSchedulerId = target.id + "-scheduler";
          var styleFunction = target.sourceFeature.getStyleFunction();
          if (!defined$1(styleFunction)) {
              styleFunction = target.sourceFeature[Symbol.for("FeatureLink")].layer.layer[0].getStyleFunction();
          }
          var olStyleList = styleFunction(target.sourceFeature, this.map.map.getView().getResolution());
          if (target.sourceFeature.getStyle() !== olStyleList) {
              target.sourceFeature.setStyle(olStyleList);
          }
          var callback = function (options) {
              olStyleList.forEach(function (i) {
                  if (i.getImage() instanceof OlIcon__default["default"] && i.getImage()[ICON_ROTATED]) {
                      i.getImage().setRotation(i.getImage()[ORIGINAL_ROTATION] +
                          computeRotationRadians(options.startPosition, options.endPosition) -
                          Math.PI * 0.5);
                  }
              });
          };
          var job = new BaseJob({
              tasks: [
                  new FeatureTranslationTask({
                      map: this.map,
                      target: target,
                      duration: duration,
                      coordinates: coordinates,
                      callback: callback
                  }),
                  new FeatureTranslationOverEventTask({
                      callback: function () {
                          _this._taskIdStore[job.id] = void 0;
                      }
                  })
              ]
          });
          this._jobScheduler.add(job, jobSchedulerId);
          this._taskIdStore[job.id] = jobSchedulerId;
          return job.id;
      };
      TranslationQueue.prototype.removeTask = function (taskId) {
          this._jobScheduler.remove(taskId, this._taskIdStore[taskId]);
          return this;
      };
      TranslationQueue.prototype.clearTask = function () {
          this.start();
          this._jobScheduler.clear();
          return this;
      };
      TranslationQueue.prototype.start = function () {
          this._jobScheduler.resume();
          return this;
      };
      TranslationQueue.prototype.stop = function () {
          this._jobScheduler.pause();
          return this;
      };
      return TranslationQueue;
  }(Component$1));

  var compassImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADHUlEQVRYR61XPUwUURCeeZzAvgdyRgsNUaC08KcyVnpESxPBymgIlP7EaIk2HIU/pcYYLSFEYyWaWJIAdnZcLCghMRALjCC7e3By+8zs7SN7597uvIsvueJ25818+30z780gMJfWOu/7/kUAGNJa9yNiPwDQj9aq1noVEVcB4KOUchERNzmuMcuoXC73B0EwAQBjjbbBVi2G6MknuZkSQkw6jkOgmq6mAOiLPc+bQMQHzXZ7s+/CV2r4RlqMopTyRTNGEgFEdM8DwNk0zxt3b4avj7x6m0XkkpRyMAnEPwBc16Wg84iYyKuJRPSvnR8I/x5f/pUFALTWpNdgV1fXUty4DkBE+0pWcHJQnvsMG/dGagy8nAHn8hUWCKXUQJyJfQBc2k2Un+O3wf/0Pvwrr16Hw89eZwKIDOrk2Afguu5zRLzP9bJ2rg+C7d+1KjjYA71fU5O90e2kUqpID0MAUamtcIPH6Td7uDIYeyHEAJVoCMDzvCkAGOUCiNNv9nSP3IL8o6dcF2Q3rZQaw0j77DSOuY7Tbx7nek/AsbmSDQCQUh5Cz/OGAGCWu/PP8jf4ce1CovnRD1/gwMlTXFdkN0wArOjffPIQtmfeJAZpRQZ0XXcBEemSYa31S6ehuv490dZWBq31IjFA9dPHiZ5Gv9lvKcMSAdCc4GSTRr/xkR9/DN2jd7guwQpAe3s75HK5VOd7e3tQqVSsALAlEEJAZ2dnqvOdnR0IgoALoGSdhI7jAGJyG6G1plOVG5xuyDAJrcowTQZb+uk0tD6I0mSwpL92ELVyFEspE2n2fZ9NPxkqpWpi/g8ZWqE/vIwIgO113NbWBh0dHXVfu7u7C9Vqlc1A3XUcsUANArXfrNUogyX99Q0JRYxyYQEAznAQxKvBkv6SlLJg+sKkppQmnJ4sEHEZuPRrrbeUUjRV7U9NzdpyuiEzQRgZOPRTcAAopLbl5qu5cphEJAYyVh3tcdvU0cz3fRrLmiamuZgoB1LWpJSSOu7EYZU7nFKFsJvWCMy0EKLY8nDa+EWRLIXYeE6jm6mYEo1esfGccog1nv8FXiaP6m5KLukAAAAASUVORK5CYII=";
  var OlCompass = /** @class */ (function (_super) {
      __extends$6(OlCompass, _super);
      function OlCompass(options) {
          var _this = this;
          var imgElem = document.createElement("img");
          imgElem.src = compassImg;
          options = Object.assign({
              duration: 1000,
              label: imgElem,
              autoHide: false,
              width: 25,
              height: 25
          }, options);
          _this = _super.call(this, options) || this;
          _this.element.style.backgroundColor = "rgba(255,255,255,0)";
          _this.element.children[0].style.backgroundColor = "rgba(255,255,255,0)";
          _this.element.children[0].style.width = options.width + "px";
          _this.element.children[0].style.height = options.height + "px";
          return _this;
      }
      return OlCompass;
  }(Rotate__default["default"]));
  /**
   * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
   * `'nautical'`, `'metric'`, `'us'`.
   * @enum {string}
   */
  var Units = {
      DEGREES: "degrees",
      IMPERIAL: "imperial",
      NAUTICAL: "nautical",
      METRIC: "metric",
      US: "us"
  };
  /**
   * @type {Array<number>}
   */
  var LEADING_DIGITS = [1, 2, 5];
  /**
   * @description 比例尺类,继承自ol/control/ScaleLine重写dom更新方法
   * @author changqing
   * @class ScaleLineControl
   * @extends {ol/control/ScaleLine}
   */
  var ScaleLineControl = /** @class */ (function (_super) {
      __extends$6(ScaleLineControl, _super);
      function ScaleLineControl(options) {
          var _this = this;
          options = Object.assign({}, options);
          var className = (options.className =
              options.className !== undefined ? options.className : "mti-gis-ol-scale-line");
          _this = _super.call(this, options) || this;
          _this._scaleTextElement = document.createElement("div");
          _this._scaleTextElement.className = className + "-text";
          _this._scaleTextElement.innerText = "100米";
          _this.innerElement_.className = className + "-inner";
          _this.innerElement_.appendChild(_this._scaleTextElement);
          _this._scaleLineElement = document.createElement("div");
          _this._scaleLineElement.className = className + "-line";
          _this.innerElement_.appendChild(_this._scaleLineElement);
          var leftElem = document.createElement("div");
          leftElem.className = className + "-edgeleft";
          _this._scaleLineElement.appendChild(leftElem);
          var rightElem = document.createElement("div");
          rightElem.className = className + "-edgeright";
          _this._scaleLineElement.appendChild(rightElem);
          var middleElem = document.createElement("div");
          middleElem.className = className + "-middle";
          _this._scaleLineElement.appendChild(middleElem);
          return _this;
      }
      /**
       * @override
       */
      ScaleLineControl.prototype.updateElement_ = function () {
          var viewState = this.viewState_;
          if (!viewState) {
              if (this.renderedVisible_) {
                  this.element.style.display = "none";
                  this.renderedVisible_ = false;
              }
              return;
          }
          var center = viewState.center;
          var projection = viewState.projection;
          var units = this.getUnits();
          var pointResolutionUnits = units === Units.DEGREES ? ProjUnits__default["default"].DEGREES : ProjUnits__default["default"].METERS;
          var pointResolution = proj.getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
          if (projection.getUnits() !== ProjUnits__default["default"].DEGREES &&
              projection.getMetersPerUnit() &&
              pointResolutionUnits === ProjUnits__default["default"].METERS) {
              pointResolution *= projection.getMetersPerUnit();
          }
          var nominalCount = this.minWidth_ * pointResolution;
          var suffix = "";
          if (units === Units.DEGREES) {
              var metersPerDegree = proj.METERS_PER_UNIT[ProjUnits__default["default"].DEGREES];
              if (projection.getUnits() === ProjUnits__default["default"].DEGREES) {
                  nominalCount *= metersPerDegree;
              }
              else {
                  pointResolution /= metersPerDegree;
              }
              if (nominalCount < metersPerDegree / 60) {
                  suffix = "\u2033"; // seconds
                  pointResolution *= 3600;
              }
              else if (nominalCount < metersPerDegree) {
                  suffix = "\u2032"; // minutes
                  pointResolution *= 60;
              }
              else {
                  suffix = "\u00b0"; // degrees
              }
          }
          else if (units === Units.IMPERIAL) {
              if (nominalCount < 0.9144) {
                  suffix = "in";
                  pointResolution /= 0.0254;
              }
              else if (nominalCount < 1609.344) {
                  suffix = "ft";
                  pointResolution /= 0.3048;
              }
              else {
                  suffix = "mi";
                  pointResolution /= 1609.344;
              }
          }
          else if (units === Units.NAUTICAL) {
              pointResolution /= 1852;
              suffix = "nm";
          }
          else if (units === Units.METRIC) {
              if (nominalCount < 0.001) {
                  suffix = "μm";
                  pointResolution *= 1000000;
              }
              else if (nominalCount < 1) {
                  suffix = "mm";
                  pointResolution *= 1000;
              }
              else if (nominalCount < 1000) {
                  suffix = "m";
              }
              else {
                  suffix = "km";
                  pointResolution /= 1000;
              }
          }
          else if (units === Units.US) {
              if (nominalCount < 0.9144) {
                  suffix = "in";
                  pointResolution *= 39.37;
              }
              else if (nominalCount < 1609.344) {
                  suffix = "ft";
                  pointResolution /= 0.30480061;
              }
              else {
                  suffix = "mi";
                  pointResolution /= 1609.3472;
              }
          }
          else ;
          var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));
          var count, width;
          while (true) {
              count = LEADING_DIGITS[((i % 3) + 3) % 3] * Math.pow(10, Math.floor(i / 3));
              width = Math.round(count / pointResolution);
              if (isNaN(width)) {
                  this.element.style.display = "none";
                  this.renderedVisible_ = false;
                  return;
              }
              else if (width >= this.minWidth_) {
                  break;
              }
              ++i;
          }
          var textE = this._scaleTextElement;
          // const leftE = this._scaleLineElement.children[0];
          var rightE = this._scaleLineElement.children[1];
          var middleE = this._scaleLineElement.children[2];
          var html = count + " " + suffix;
          if (this.renderedHTML_ !== html) {
              textE.innerHTML = html;
              this.renderedHTML_ = html;
          }
          if (this.renderedWidth_ !== width) {
              middleE.style.width = width - 4 + "px";
              rightE.style.left = width - 3 + "px";
              textE.style.width = width + "px";
              this.renderedWidth_ = width;
          }
          // if (!this.renderedVisible_) {
          //   this.element.style.display = '';
          //   this.renderedVisible_ = true;
          // }
      };
      return ScaleLineControl;
  }(OLScaleLine__default["default"]));
  /**
   * 罗盘组件
   */
  var Compass = /** @class */ (function (_super) {
      __extends$6(Compass, _super);
      function Compass(options, map) {
          return _super.call(this, __assign$1({ compass: true, scaleLine: true, zoom: true }, options), map) || this;
      }
      /**
       * 初始化
       * @ignore
       */
      Compass.prototype.init = function () {
          this.initialized = true;
          var _a = this.options, compass = _a.compass, scaleLine = _a.scaleLine, zoom = _a.zoom;
          this._controls = [];
          if (compass) {
              this._controls.push(new OlCompass({}));
          }
          if (scaleLine) {
              this._controls.push(new ScaleLineControl({}));
          }
          if (zoom) {
              this._controls.push(new Zoom__default["default"]());
          }
      };
      /**
       * @ignore
       * @param map
       */
      Compass.prototype.addTo = function (map) {
          var e_1, _a;
          _super.prototype.addTo.call(this, map);
          try {
              for (var _b = __values(this._controls), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var control = _c.value;
                  this.map.map.addControl(control);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * 从地球移除
       * @ignore
       */
      Compass.prototype.remove = function (destroy) {
          var e_2, _a;
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          try {
              for (var _b = __values(this._controls), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var control = _c.value;
                  this.map.map.removeControl(control);
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
          }
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Compass.prototype._destroy = function () {
          this.remove();
          this._controls = void 0;
          _super.prototype._destroy.call(this);
      };
      return Compass;
  }(Component$1));

  /**
   * 坐标信息组件
   */
  var Coordinate = /** @class */ (function (_super) {
      __extends$6(Coordinate, _super);
      function Coordinate(options, map) {
          return _super.call(this, options, map) || this;
      }
      /**
       * @ignore
       */
      Coordinate.prototype.init = function () {
          var _this = this;
          var _a = this._options, className = _a.className, text = _a.text, style = _a.style;
          var globe = this.map;
          var template = text || "经度:{longitude}° 纬度:{latitude}°";
          var coordsDom = document.createElement("span");
          var tem = document.createElement("div");
          this._component = tem;
          tem.append(coordsDom);
          tem.classList.add("gis-widget-coordinate");
          className && tem.classList.add(className);
          Object.assign(tem.style, style);
          this._eventKey = globe.map.on("pointermove", function (e) {
              if (!defined$1(_this.map)) {
                  return;
              }
              var pixel = e.pixel;
              var _a = __read(transformToDataProjection(globe.map.getCoordinateFromPixel(pixel)), 2), longitude = _a[0], latitude = _a[1];
              if (longitude && latitude) {
                  coordsDom.innerText = template
                      .replace(new RegExp("{longitude}", "g"), longitude.toFixed(4))
                      .replace(new RegExp("{latitude}", "g"), latitude.toFixed(4));
              }
          });
          this.initialized = true;
      };
      /**
       * 添加到地球
       * @ignore
       */
      Coordinate.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this.map.map.getViewport().append(this._component);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Coordinate.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.map.getViewport().removeChild(this._component);
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Coordinate.prototype._destroy = function () {
          this.remove();
          this.unByKey(this._eventKey);
          this._eventKey = void 0;
          this._component = void 0;
          _super.prototype._destroy.call(this);
      };
      return Coordinate;
  }(Component$1));

  /**
   * 区域面组件
   */
  var Area = /** @class */ (function (_super) {
      __extends$6(Area, _super);
      function Area(options, map) {
          return _super.call(this, __assign$1({ contentStyle: AREA_STYLE.contentStyle, outlineStyle: AREA_STYLE.outlineStyle, contentOutlineStyle: AREA_STYLE.contentOutlineStyle, contentLabelStyle: AREA_STYLE.contentLabelStyle, topOutline: true, bottomOutline: false, contentOutline: true, contentLabel: true, visible: true }, options), map) || this;
      }
      Object.defineProperty(Area.prototype, "visible", {
          /**
           * 组件显隐状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Area.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化
       * @ignore
       */
      Area.prototype.init = function () {
          var _this = this;
          var _a;
          this.initialized = true;
          var _b = this.options, contentStyle = _b.contentStyle, outlineStyle = _b.outlineStyle, contentOutlineStyle = _b.contentOutlineStyle, contentLabelStyle = _b.contentLabelStyle, topOutline = _b.topOutline, bottomOutline = _b.bottomOutline, contentOutline = _b.contentOutline, contentLabel = _b.contentLabel, visible = _b.visible;
          if (!defined$1(this._visible)) {
              this._visible = visible;
          }
          var data = this.options.data;
          if ((data === null || data === void 0 ? void 0 : data.type) !== "FeatureCollection" || ((_a = data.features) === null || _a === void 0 ? void 0 : _a.length) === 0) {
              throw new Error("GeoJSON格式错误或内容为空");
          }
          data = JSON.parse(JSON.stringify(data));
          var contentFeatureList = read$1(data);
          var mergePolygon = geojsonDissolve(data);
          this._contentFeatureList = contentFeatureList;
          this._contentVectorLayer = new VectorLayer({
              id: this.id + "-content-vector-layer",
              data: contentFeatureList,
              style: contentStyle,
              visible: this._visible
          });
          this._outlineVectorLayer = new VectorLayer({
              id: this.id + "-outline-vector-layer",
              style: outlineStyle,
              visible: this._visible
          });
          this._contentOutlineVectorLayer = new VectorLayer({
              id: this.id + "-content-outline-vector-layer",
              style: contentOutlineStyle,
              visible: this._visible
          });
          this._labelContentVectorLayer = new VectorLayer({
              id: this.id + "-label-content-vector-layer",
              style: contentLabelStyle,
              visible: this._visible
          });
          this._contentVectorLayer.on([
              BaseEventType.MOUSE_DOWN,
              BaseEventType.MOUSE_UP,
              BaseEventType.CLICK,
              BaseEventType.RIGHT_CLICK,
              BaseEventType.DOUBLE_CLICK,
              BaseEventType.MOUSE_MOVE
          ], function (e) {
              var coordinate = e.coordinate, pixel = e.pixel, map = e.map;
              var feature;
              if (e.features.length === 1 && _this._contentFeatureList.includes(e.features[0])) {
                  feature = e.features[0];
              }
              else if (e.features[0] instanceof Point$1) {
                  //@ts-ignore
                  feature = e.features[0].contentFeature;
              }
              _this.dispatchEvent({
                  type: e.type,
                  feature: feature,
                  coordinate: coordinate,
                  pixel: pixel,
                  map: map
              });
          });
          this._contentLabelFeatureList = [];
          this._contentOutlineFeatureList = contentFeatureList.map(function (feature) {
              var temFeature = new Polyline$1({
                  coordinates: polygonToPolyline(feature.geoJson.geometry).coordinates,
                  properties: __assign$1({}, feature.properties)
              });
              contentOutline && _this._contentOutlineVectorLayer.addFeature(temFeature);
              var labelPoint = feature.properties.center
                  ? feature.properties.center
                  : Turf__namespace.centerOfMass(feature.geoJson.geometry, {
                      properties: __assign$1({}, feature.properties)
                  }).geometry.coordinates;
              var labelFeature = new Point$1({
                  coordinates: labelPoint,
                  properties: __assign$1({}, feature.properties)
              });
              //@ts-ignore
              labelFeature.contentFeature = feature;
              contentLabel && _this._labelContentVectorLayer.addFeature(labelFeature);
              _this._contentLabelFeatureList.push(labelFeature);
              return temFeature;
          });
          var outlineBottomGeoJSON = polygonToPolyline(mergePolygon);
          var outlineTopGeoJSON = polygonToPolyline(mergePolygon);
          var outlineBottomFeature = new Polyline$1({
              coordinates: outlineBottomGeoJSON.coordinates
          });
          this._outlineBottomFeature = outlineBottomFeature;
          bottomOutline && this._outlineVectorLayer.addFeature(outlineBottomFeature);
          var outlineTopFeature = new Polyline$1({
              coordinates: outlineTopGeoJSON.coordinates
          });
          this._outlineTopFeature = outlineTopFeature;
          topOutline && this._outlineVectorLayer.addFeature(outlineTopFeature);
      };
      /**
       * @ignore
       */
      Area.prototype.addTo = function (globe) {
          _super.prototype.addTo.call(this, globe);
          this._contentVectorLayer.addTo(globe);
          this._outlineVectorLayer.addTo(globe);
          this._contentOutlineVectorLayer.addTo(globe);
          this._labelContentVectorLayer.addTo(globe);
      };
      /**
       * 从地球移除
       * @ignore
       */
      Area.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this._contentVectorLayer.remove();
          this._contentOutlineVectorLayer.remove();
          this._outlineVectorLayer.remove();
          this._labelContentVectorLayer.remove();
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Area.prototype._destroy = function () {
          this.remove();
          this._contentVectorLayer.destroy();
          this._contentOutlineVectorLayer.destroy();
          this._outlineVectorLayer.destroy();
          this._labelContentVectorLayer.destroy();
          this._contentVectorLayer =
              this._contentOutlineVectorLayer =
                  this._outlineVectorLayer =
                      this._labelContentVectorLayer =
                          this._outlineTopFeature =
                              this._outlineBottomFeature =
                                  this._contentFeatureList =
                                      this._contentLabelFeatureList =
                                          this._contentOutlineFeatureList =
                                              void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 注册事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      /**
       * 注册单次事件
       *
       * **事件类型**
       *
       *  事件类型   | 事件描述 |事件返回参数描述
       *  --        | --         | --
       *  `click`    |   左键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `doubleclick` |  左键双击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousedown` |  左键按下  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mouseup` |  左键抬起  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `rightclick` |  右键单击  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *  `mousemove` |  鼠标移动  | (pixel: [number,number])-屏幕坐标, (map: [[Map]])-地图对象, (coordinate: [[PointCoordinate]])-经纬度坐标, (feature: [[Feature]][])-要素对象
       *
       * @param {(string | string[])} type 事件类型或者事件类型数组
       * @param {Function} listener 事件监听器函数
       * @returns {(eventKey | eventKey[])} 返回监听器的唯一Key。如果以事件类型数组作为第一个参数调用，则返回key数组
       */
      Area.prototype.once = function (type, listener) {
          return _super.prototype.once.call(this, type, listener);
      };
      /**
       * 显示行政区划
       */
      Area.prototype.show = function () {
          var _a, _b, _c, _d;
          if (this.visible) {
              return;
          }
          this._visible = true;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.show();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.show();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.show();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.show();
          return this;
      };
      /**
       * 隐藏行政区划
       */
      Area.prototype.hide = function () {
          var _a, _b, _c, _d;
          if (this.visible === false) {
              return;
          }
          this._visible = false;
          (_a = this._contentVectorLayer) === null || _a === void 0 ? void 0 : _a.hide();
          (_b = this._outlineVectorLayer) === null || _b === void 0 ? void 0 : _b.hide();
          (_c = this._contentOutlineVectorLayer) === null || _c === void 0 ? void 0 : _c.hide();
          (_d = this._labelContentVectorLayer) === null || _d === void 0 ? void 0 : _d.hide();
          return this;
      };
      return Area;
  }(Component$1));
  function polygonToPolyline(geojson) {
      if (geojson.type === GeoJsonType.FEATURE) {
          return feature$2(polygonToPolyline(geojson.geometry), __assign$1({}, geojson.properties));
      }
      else if (geojson.type === GeoJsonGeometryType.MULTI_POLYGON) {
          var list_1 = [];
          geojson.coordinates.forEach(function (item) {
              list_1 = list_1.concat(polygonToPolyline(polygon(item).geometry).coordinates);
          });
          return multiLineString(list_1).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.POLYGON) {
          return multiLineString(geojson.coordinates).geometry;
      }
      else if (geojson.type === GeoJsonGeometryType.LINE_STRING) {
          return geojson;
      }
  }

  var VideoShed = /** @class */ (function (_super) {
      __extends$6(VideoShed, _super);
      function VideoShed(options, map) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(VideoShed.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      VideoShed.prototype.init = function () {
          this.initialized = true;
      };
      /**
       * @ignore
       */
      VideoShed.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map = void 0;
          this.initialized = false;
      };
      /**
       * @ignore
       */
      VideoShed.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      return VideoShed;
  }(Component$1));

  /* eslint-disable @typescript-eslint/ban-types */
  /**
   * merge
   * @param a
   * @param b
   * @returns {*}
   */
  var merge = function (a, b) {
      Object.keys(b).forEach(function (key) {
          if (isObject$9(b[key]) && isObject$9(a[key])) {
              merge(a[key], b[key]);
          }
          else {
              a[key] = b[key];
          }
      });
      return a;
  };
  /**
   * bind context
   * @param func
   * @param context
   * @param args
   */
  var bind$6 = function (func, context) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
      }
      return function () {
          var innerArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              innerArgs[_i] = arguments[_i];
          }
          return func.apply(context, args.concat(Array.prototype.slice.call(innerArgs)));
      };
  };
  /**
   * add own item
   * @param array
   * @param item
   */
  var arrayAdd = function (array, item) {
      var i = 0;
      var index;
      var length = array.length;
      for (; i < length; i++) {
          if (array[i].index === item.index) {
              index = i;
              break;
          }
      }
      if (index === undefined) {
          array.push(item);
      }
      else {
          array[index] = item;
      }
      return array;
  };
  var uuid$1 = function () {
      function rd(a) {
          // eslint-disable-next-line no-mixed-operators,no-bitwise
          return a
              ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)
              : // @ts-ignore
                  ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, rd);
      }
      return rd();
  };
  /**
   * bind function array
   * @param fns
   * @param context
   */
  function bindAll(fns, context) {
      fns.forEach(function (fn) {
          if (!context[fn]) {
              return;
          }
          context[fn] = context[fn].bind(context);
      });
  }
  /**
   * remove node
   * @param node
   */
  function removeNode(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * mock zrender mouse event
   * @param type
   * @param event
   */
  function mockEvent(type, event) {
      var e = new MouseEvent(type, {
          // set bubbles, so zrender can receive the mock event. ref: https://dom.spec.whatwg.org/#interface-event
          // "event.bubbles": Returns true or false depending on how event was initialized.
          // True if event goes through its target’s ancestors in reverse tree order, and false otherwise
          bubbles: true,
          cancelable: true,
          button: event.pointerEvent.button,
          buttons: event.pointerEvent.buttons,
          clientX: event.pointerEvent.clientX,
          clientY: event.pointerEvent.clientY,
          // @ts-ignore
          zrX: event.pointerEvent.offsetX,
          zrY: event.pointerEvent.offsetY,
          movementX: event.pointerEvent.movementX,
          movementY: event.pointerEvent.movementY,
          relatedTarget: event.pointerEvent.relatedTarget,
          screenX: event.pointerEvent.screenX,
          screenY: event.pointerEvent.screenY,
          view: window
      });
      e.zrX = event.pointerEvent.offsetX;
      e.zrY = event.pointerEvent.offsetY;
      e.event = e;
      return e;
  }

  /**
   * check is decoded
   * @param json
   * @returns {boolean}
   */
  var checkDecoded = function (json) { return !json.UTF8Encoding; };
  /**
   * decode polygon
   * @param coordinate
   * @param encodeOffsets
   * @param encodeScale
   * @returns {null}
   */
  var decodePolygon = function (coordinate, encodeOffsets, encodeScale) {
      var result = [];
      var _a = __read([encodeOffsets[0], encodeOffsets[1]], 2), prevX = _a[0], prevY = _a[1];
      for (var i = 0; i < coordinate.length; i += 2) {
          var x = coordinate.charCodeAt(i) - 64;
          var y = coordinate.charCodeAt(i + 1) - 64;
          // ZigZag decoding
          // eslint-disable-next-line no-bitwise
          x = (x >> 1) ^ -(x & 1);
          // eslint-disable-next-line no-bitwise
          y = (y >> 1) ^ -(y & 1);
          // Delta deocding
          x += prevX;
          y += prevY;
          prevX = x;
          prevY = y;
          // @ts-ignore
          result.push([x / encodeScale, y / encodeScale]);
      }
      return result;
  };
  /**
   * decode json
   * @param json
   * @returns {*}
   */
  var decode$2 = function (json) {
      if (checkDecoded(json)) {
          return json;
      }
      var encodeScale = json.UTF8Scale;
      if (encodeScale === null) {
          encodeScale = 1024;
      }
      var features = json.features;
      for (var f = 0; f < features.length; f++) {
          var feature = features[f];
          var geometry = feature.geometry;
          var _a = __read([geometry.coordinates, geometry.encodeOffsets], 2), coordinates = _a[0], encodeOffsets = _a[1];
          for (var c = 0; c < coordinates.length; c++) {
              var coordinate = coordinates[c];
              if (geometry.type === "Polygon") {
                  coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
              }
              else if (geometry.type === "MultiPolygon") {
                  for (var c2 = 0; c2 < coordinate.length; c2++) {
                      var polygon = coordinate[c2];
                      coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
                  }
              }
          }
      }
      json.UTF8Encoding = false;
      return json;
  };
  /**
   * decode geoJson
   * @param json
   */
  function formatGeoJSON (json) {
      var geoJson = decode$2(json);
      // @ts-ignore
      var _features = echarts__namespace.util.map(
      // @ts-ignore
      echarts__namespace.util.filter(geoJson.features, function (featureObj) {
          // Output of mapshaper may have geometry null
          return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
      }), function (featureObj) {
          var properties = featureObj.properties;
          var geo = featureObj.geometry;
          var coordinates = geo.coordinates;
          var geometries = [];
          if (geo.type === "Polygon") {
              geometries.push(coordinates[0]);
          }
          if (geo.type === "MultiPolygon") {
              // @ts-ignore
              echarts__namespace.util.each(coordinates, function (item) {
                  if (item[0]) {
                      geometries.push(item[0]);
                  }
              });
          }
          return {
              properties: properties,
              type: "Feature",
              geometry: {
                  type: "Polygon",
                  coordinates: geometries
              }
          };
      });
      return {
          type: "FeatureCollection",
          crs: {},
          features: _features
      };
  }

  var pie = function (_options, series, coordinateSystem) {
      series.center = coordinateSystem.dataToPoint(series.coordinates);
      return series;
  };

  var bar = function (options, series, coordinateSystem) {
      if (isObject$9(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coorPixel = coordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coorPixel[0] - parseFloat(gri.width) / 2;
              gri.top = coorPixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return series;
  };

  var line = function (options, serie, coordinateSystem) {
      if (isObject$9(options.grid) && !Array.isArray(options.grid)) ;
      else if (Array.isArray(options.grid)) {
          options.grid = options.grid.map(function (gri, index) {
              var coorPixel = coordinateSystem.dataToPoint(options.series[index].coordinates);
              gri.left = coorPixel[0] - parseFloat(gri.width) / 2;
              gri.top = coorPixel[1] - parseFloat(gri.height) / 2;
              return gri;
          });
      }
      return serie;
  };

  var charts = /*#__PURE__*/Object.freeze({
    __proto__: null,
    pie: pie,
    bar: bar,
    line: line
  });

  // @ts-nocheck
  var _options = {
      forcedRerender: false,
      forcedPrecomposeRerender: false,
      hideOnZooming: false,
      hideOnMoving: false,
      hideOnRotating: false,
      convertTypes: ["pie", "line", "bar"],
      insertFirst: false,
      stopEvent: false,
      polyfillEvents: false //semver(VERSION, "6.1.1") <= 0 // fix echarts mouse events
  };
  var EChartsLayer = /** @class */ (function (_super) {
      __extends$6(EChartsLayer, _super);
      function EChartsLayer(chartOptions, options, map) {
          var _this = this;
          var opts = Object.assign(_options, options);
          _this = _super.call(this, opts) || this;
          /**
           * layer options
           */
          _this._options = opts;
          /**
           * chart options
           */
          _this._chartOptions = chartOptions;
          _this.set("chartOptions", chartOptions); // cache chart Options
          /**
           * chart instance
           * @type {null}
           */
          _this.$chart = null;
          /**
           * chart element
           * @type {undefined}
           */
          _this.$container = undefined;
          /**
           * Whether the relevant configuration has been registered
           * @type {boolean}
           * @private
           */
          _this._isRegistered = false;
          _this._isStopRender = false;
          /**
           * check if init
           */
          _this._initEvent = false;
          /**
           * 增量数据存放
           * @type {Array}
           * @private
           */
          _this._incremental = [];
          /**
           * coordinate system
           * @type {null}
           * @private
           */
          _this._coordinateSystem = null;
          /**
           * coordinateSystemId
           */
          _this.coordinateSystemId = "";
          _this.prevVisibleState = "";
          bindAll([
              "redraw",
              "onResize",
              "onZoomEnd",
              "onCenterChange",
              "onDragRotateEnd",
              "onMoveStart",
              "onMoveEnd",
              "mouseDown",
              "mouseUp",
              "onClick",
              "mouseMove"
          ], _this);
          if (map)
              _this.setMap(map);
          return _this;
      }
      /**
       * append layer to map
       * @param map
       */
      EChartsLayer.prototype.appendTo = function (map) {
          this.setMap(map);
      };
      /**
       * get ol map
       * @returns {ol.Map}
       */
      EChartsLayer.prototype.getMap = function () {
          return this._map;
      };
      /**
       * set map
       * @param map
       */
      EChartsLayer.prototype.setMap = function (map) {
          var _this = this;
          if (map && map instanceof Map__default["default"]) {
              this._map = map;
              this._map.once("postrender", function () {
                  _this.handleMapChanged();
              });
              this._map.renderSync();
          }
          else {
              throw new Error("not ol map object");
          }
      };
      /**
       * get echarts options
       */
      EChartsLayer.prototype.getChartOptions = function () {
          return this.get("chartOptions");
      };
      /**
       * set echarts options and redraw
       * @param options
       * @returns {EChartsLayer}
       */
      EChartsLayer.prototype.setChartOptions = function (options) {
          if (options === void 0) { options = {}; }
          this._chartOptions = options;
          this.set("chartOptions", options);
          this.clearAndRedraw();
          return this;
      };
      /**
       * append data
       * @param data
       * @param save
       * @returns {EChartsLayer}
       */
      EChartsLayer.prototype.appendData = function (data, save) {
          if (save === void 0) { save = true; }
          if (data) {
              if (save) {
                  this._incremental = arrayAdd(this._incremental, {
                      index: this._incremental.length,
                      data: data.data,
                      seriesIndex: data.seriesIndex
                  });
              }
              // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin
              this.$chart.appendData({
                  data: data.data.copyWithin(),
                  seriesIndex: data.seriesIndex
              });
          }
          return this;
      };
      /**
       * clear layer
       */
      EChartsLayer.prototype.clear = function (keep) {
          if (!keep) {
              this._incremental = [];
          }
          if (this.$chart) {
              this.$chart.clear();
          }
      };
      /**
       * remove layer
       */
      EChartsLayer.prototype.remove = function () {
          this.clear();
          if (this.$chart) {
              this.$chart.dispose();
          }
          if (this._initEvent && this.$container) {
              this.$container && removeNode(this.$container);
              this.unBindEvent();
          }
          delete this.$chart;
          delete this._map;
      };
      /**
       * show layer
       */
      EChartsLayer.prototype.show = function () {
          this.setVisible(true);
      };
      EChartsLayer.prototype.innerShow = function () {
          if (this.$container) {
              this.$container.style.display = this.prevVisibleState;
              this.prevVisibleState = "";
          }
      };
      /**
       * hide layer
       */
      EChartsLayer.prototype.hide = function () {
          this.setVisible(false);
      };
      EChartsLayer.prototype.innerHide = function () {
          if (this.$container) {
              this.prevVisibleState = this.$container.style.display;
              this.$container.style.display = "none";
          }
      };
      /**
       * check layer is visible
       */
      EChartsLayer.prototype.isVisible = function () {
          return this.$container && this.$container.style.display !== "none";
      };
      /**
       * show loading bar
       */
      EChartsLayer.prototype.showLoading = function () {
          if (this.$chart) {
              this.$chart.showLoading();
          }
      };
      /**
       * hide loading bar
       */
      EChartsLayer.prototype.hideLoading = function () {
          if (this.$chart) {
              this.$chart.hideLoading();
          }
      };
      /**
       * set zindex
       * @param zIndex
       */
      EChartsLayer.prototype.setZIndex = function (zIndex) {
          if (this.$container) {
              if (typeof zIndex === "number") {
                  zIndex = String(zIndex);
              }
              this.$container.style.zIndex = zIndex;
          }
      };
      /**
       * get zindex
       */
      EChartsLayer.prototype.getZIndex = function () {
          return this.$container && this.$container.style.zIndex;
      };
      /**
       * set visible
       * from: https://github.com/sakitam-fdd/ol3Echarts/blob/3929ad72f562661ba3511d4d9e360dee5ac793c2/
       * packages/ol-echarts/src/index.js
       * author: https://github.com/ChenGuanglin0924
       * @param visible
       */
      EChartsLayer.prototype.setVisible = function (visible) {
          if (visible) {
              if (this.$container) {
                  this.$container.style.display = "";
              }
              this._chartOptions = this.getChartOptions();
              this.clearAndRedraw();
          }
          else {
              if (this.$container) {
                  this.$container.style.display = "none";
              }
              this.clear(true);
              this._chartOptions = {};
              this.clearAndRedraw();
          }
      };
      /**
       * render
       */
      EChartsLayer.prototype.render = function () {
          var _this = this;
          if (!this.$chart && this.$container) {
              // @ts-ignore
              this.$chart = echarts__namespace.init(this.$container);
              this.registerMap();
              // this.$chart.on('rendered',()=>{
              //     // api.dispatchAction({
              //     //     type: "GLMapRoam"
              //     // });
              // })
              if (this._chartOptions) {
                  setTimeout(function () {
                      _this.$chart.setOption(_this.convertData(_this._chartOptions), false);
                  }, 30);
              }
              this.dispatchEvent({
                  type: "load",
                  source: this,
                  value: this.$chart
              });
          }
          else if (this.isVisible()) {
              this.redraw();
          }
      };
      /**
       * redraw echarts layer
       */
      EChartsLayer.prototype.redraw = function () {
          this.clearAndRedraw();
      };
      /**
       * update container size
       * @param size
       */
      EChartsLayer.prototype.updateViewSize = function (size) {
          if (!this.$container)
              return;
          this.$container.style.width = "".concat(size[0], "px");
          this.$container.style.height = "".concat(size[1], "px");
          this.$container.setAttribute("width", String(size[0]));
          this.$container.setAttribute("height", String(size[1]));
      };
      /**
       * handle map view resize
       */
      EChartsLayer.prototype.onResize = function (event) {
          var map = this.getMap();
          if (map) {
              var size = map.getSize();
              this.updateViewSize(size);
              this.clearAndRedraw();
              if (event) {
                  // ignore events
                  this.dispatchEvent({
                      type: "change:size",
                      source: this,
                      value: size
                  });
              }
          }
      };
      /**
       * handle zoom end events
       */
      EChartsLayer.prototype.onZoomEnd = function () {
          this._options.hideOnZooming && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "zoomend",
                  source: this,
                  value: map.getView().getZoom()
              });
          }
      };
      /**
       * handle rotate end events
       */
      EChartsLayer.prototype.onDragRotateEnd = function () {
          this._options.hideOnRotating && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "change:rotation",
                  source: this,
                  value: map.getView().getRotation()
              });
          }
      };
      /**
       * handle move start events
       */
      EChartsLayer.prototype.onMoveStart = function () {
          this._options.hideOnMoving && this.innerHide();
          var map = this.getMap();
          if (map && map.getView()) {
              this.dispatchEvent({
                  type: "movestart",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * handle move end events
       */
      EChartsLayer.prototype.onMoveEnd = function () {
          this._options.hideOnMoving && this.innerShow();
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "moveend",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * on mouse click
       * @param event
       */
      EChartsLayer.prototype.onClick = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent("click", event));
          }
      };
      /**
       * on mouse down
       * @param event
       */
      EChartsLayer.prototype.mouseDown = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent("mousedown", event));
          }
      };
      /**
       * mouse up
       * @param event
       */
      EChartsLayer.prototype.mouseUp = function (event) {
          if (this.$chart) {
              this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent("mouseup", event));
          }
      };
      /**
       * mousemove 事件需要分两种情况处理:
       * 1. ol-overlaycontainer-stopevent 有高度, 则 propagation path 是 ol-viewport -> ol-overlaycontainer-stopevent.
       * 此时 ol-overlaycontainer 无法获得事件, 只能 mock 处理
       * 2. ol-overlaycontainer-stopevent 没有高度, 则 propagation path 是 ol-viewport -> ol-overlaycontainer. 无需 mock
       * @param event
       */
      EChartsLayer.prototype.mouseMove = function (event) {
          if (this.$chart) {
              var target = event.originalEvent.target;
              while (target) {
                  if (target.className === "ol-overlaycontainer-stopevent") {
                      this.$chart.getZr().painter.getViewportRoot().dispatchEvent(mockEvent("mousemove", event));
                      return;
                  }
                  target = target.parentElement;
              }
          }
      };
      /**
       * handle center change
       */
      EChartsLayer.prototype.onCenterChange = function () {
          var map = this.getMap();
          if (map && map.getView()) {
              this.clearAndRedraw();
              this.dispatchEvent({
                  type: "change:center",
                  source: this,
                  value: map.getView().getCenter()
              });
          }
      };
      /**
       * handle map change
       */
      EChartsLayer.prototype.handleMapChanged = function () {
          var map = this.getMap();
          if (this._initEvent && this.$container) {
              this.$container && removeNode(this.$container);
              this.unBindEvent();
          }
          if (!this.$container) {
              this.createLayerContainer();
              this.onResize(false);
          }
          if (map) {
              var container = this._options.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
              if (this._options.insertFirst) {
                  container.insertBefore(this.$container, container.childNodes[0] || null);
              }
              else {
                  container.appendChild(this.$container);
              }
              this.render();
              this.bindEvent(map);
          }
      };
      /**
       * create container
       */
      EChartsLayer.prototype.createLayerContainer = function () {
          this.$container = document.createElement("div");
          this.$container.style.position = "absolute";
          this.$container.style.top = "0px";
          this.$container.style.left = "0px";
          this.$container.style.right = "0px";
          this.$container.style.bottom = "0px";
          this.$container.style.pointerEvents = "auto";
      };
      /**
       * register events
       * @private
       */
      EChartsLayer.prototype.bindEvent = function (map) {
          // https://github.com/openlayers/openlayers/issues/7284
          var view = map.getView();
          //if (this._options.forcedPrecomposeRerender) {
          map.on("precompose", this.redraw);
          //}
          map.on("change:size", this.onResize);
          view.on("change:resolution", this.onZoomEnd);
          view.on("change:center", this.onCenterChange);
          view.on("change:rotation", this.onDragRotateEnd);
          map.on("movestart", this.onMoveStart);
          map.on("moveend", this.onMoveEnd);
          if (this._options.polyfillEvents) {
              map.on("pointerdown", this.mouseDown);
              map.on("pointerup", this.mouseUp);
              map.on("pointermove", this.mouseMove);
              map.on("click", this.onClick);
          }
          this._initEvent = true;
      };
      /**
       * un register events
       * @private
       */
      EChartsLayer.prototype.unBindEvent = function () {
          var map = this.getMap();
          if (!map)
              return;
          var view = map.getView();
          if (!view)
              return;
          map.un("precompose", this.redraw);
          map.un("change:size", this.onResize);
          view.un("change:resolution", this.onZoomEnd);
          view.un("change:center", this.onCenterChange);
          view.un("change:rotation", this.onDragRotateEnd);
          map.un("movestart", this.onMoveStart);
          map.un("moveend", this.onMoveEnd);
          if (this._options.polyfillEvents) {
              map.un("pointerdown", this.mouseDown);
              map.un("pointerup", this.mouseUp);
              map.un("pointermove", this.mouseMove);
              map.un("click", this.onClick);
          }
          this._initEvent = false;
      };
      /**
       * clear chart and redraw
       * @private
       */
      EChartsLayer.prototype.clearAndRedraw = function () {
          if (!this.$chart || !this.isVisible())
              return;
          if (this._options.forcedRerender) {
              this.$chart.clear();
          }
          this.$chart.resize();
          if (this._chartOptions) {
              //this.registerMap();
              this.$chart.setOption(this.convertData(this._chartOptions), false);
              if (this._incremental && this._incremental.length > 0) {
                  for (var i = 0; i < this._incremental.length; i++) {
                      this.appendData(this._incremental[i], false);
                  }
              }
          }
          this.dispatchEvent({
              type: "redraw",
              source: this
          });
      };
      /**
       * register map coordinate system
       * @private
       */
      EChartsLayer.prototype.registerMap = function () {
          var echart = this.$chart;
          var isStopRender = this._isStopRender;
          echart.on("finished", function () {
              this._api.dispatchAction({
                  type: "GLMapRoam"
              });
          });
          if (!this._isRegistered) {
              this.coordinateSystemId = "openlayers_".concat(uuid$1());
              // @ts-ignore
              echarts__namespace.registerCoordinateSystem(this.coordinateSystemId, this.getCoordinateSystem(this._options));
              echarts__namespace.registerAction({
                  type: "GLMapRoam",
                  event: "GLMapRoam",
                  update: "updateLayout"
              }, function (e, t) { });
              echarts__namespace.extendComponentModel({
                  type: "GLMap",
                  defaultOption: {
                      roam: !1
                  }
              });
              echarts__namespace.extendComponentView({
                  type: "GLMap",
                  init: function (echartModel, api) {
                      //@ts-ignore
                      var implementation = window["requestAnimationFrame"];
                      function render() {
                          if (isStopRender) {
                              return;
                          }
                          setTimeout(function () {
                              api.dispatchAction({
                                  type: "GLMapRoam"
                              });
                          }, 0);
                          implementation(render);
                      }
                      implementation(render);
                      //(this.api = api), map.on('postrender',this.moveHandler.bind(this));
                  },
                  render: function (e, t, i) { },
                  dispose: function () {
                      isStopRender = true;
                      // @ts-ignore
                      //(this.api = api), map.un("postrender", this.moveHandler.bind(this));
                  }
              });
              this._isRegistered = true;
          }
          if (this._chartOptions) {
              // @ts-ignore
              var series = this._chartOptions.series;
              if (series && isObject$9(series)) {
                  var convertTypes = this._options.convertTypes;
                  if (convertTypes) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (!(convertTypes.indexOf(series[i].type) > -1)) {
                              series[i].coordinateSystem = this.coordinateSystemId;
                          }
                          series[i].animation = false;
                      }
                  }
              }
          }
      };
      /**
       * 重新处理数据
       * @param options
       * @returns {*}
       */
      EChartsLayer.prototype.convertData = function (options) {
          // @ts-ignore
          var series = options.series;
          if (series && series.length > 0) {
              if (!this._coordinateSystem) {
                  var Rc = this.getCoordinateSystem(this._options);
                  // @ts-ignore
                  this._coordinateSystem = new Rc(this.getMap());
              }
              if (series && isObject$9(series)) {
                  var convertTypes = this._options.convertTypes;
                  if (convertTypes) {
                      for (var i = series.length - 1; i >= 0; i--) {
                          if (convertTypes.indexOf(series[i].type) > -1) {
                              if (series[i] && series[i].hasOwnProperty("coordinates")) {
                                  // @ts-ignore
                                  series[i] = charts[series[i].type](options, series[i], this._coordinateSystem);
                              }
                          }
                      }
                  }
              }
          }
          return options;
      };
      /**
       * register coordinateSystem
       * @param options
       */
      EChartsLayer.prototype.getCoordinateSystem = function (options) {
          var map = this.getMap();
          var coordinateSystemId = this.coordinateSystemId;
          var RegisterCoordinateSystem = function (map) {
              // @ts-ignore
              this.map = map;
              // @ts-ignore
              this._mapOffset = [0, 0];
              // @ts-ignore
              this.dimensions = ["lng", "lat"];
              // @ts-ignore
              this.projCode = RegisterCoordinateSystem.getProjectionCode(this.map);
          };
          RegisterCoordinateSystem.dimensions = RegisterCoordinateSystem.prototype.dimensions || ["lng", "lat"];
          /**
           * get zoom
           * @returns {number}
           */
          RegisterCoordinateSystem.prototype.getZoom = function () {
              return this.map.getView().getZoom();
          };
          /**
           * set zoom
           * @param zoom
           */
          RegisterCoordinateSystem.prototype.setZoom = function (zoom) {
              return this.map.getView().setZoom(zoom);
          };
          RegisterCoordinateSystem.prototype.getViewRectAfterRoam = function () {
              return this.getViewRect().clone();
          };
          /**
           * 设置地图窗口的偏移
           * @param mapOffset
           */
          RegisterCoordinateSystem.prototype.setMapOffset = function (mapOffset) {
              this._mapOffset = mapOffset;
          };
          /**
           * 跟据坐标转换成屏幕像素
           * @param data
           * @returns {}
           */
          RegisterCoordinateSystem.prototype.dataToPoint = function (data) {
              var coords;
              if (data && Array.isArray(data) && data.length > 0) {
                  coords = data.map(function (item) {
                      var res = 0;
                      if (typeof item === "string") {
                          res = Number(item);
                      }
                      else {
                          res = item;
                      }
                      return res;
                  });
                  var source = (options && options.source) || "EPSG:4326";
                  var destination = (options && options.destination) || this.projCode;
                  var pixel = this.map.getPixelFromCoordinate(proj.transform(coords, source, destination));
                  var mapOffset = this._mapOffset;
                  return [pixel[0] - mapOffset[0], pixel[1] - mapOffset[1]];
              }
              return [0, 0];
          };
          /**
           * 跟据屏幕像素转换成坐标
           * @param pixel
           * @returns {}
           */
          RegisterCoordinateSystem.prototype.pointToData = function (pixel) {
              var mapOffset = this._mapOffset;
              return this.map.getCoordinateFromPixel([pixel[0] + mapOffset[0], pixel[1] + mapOffset[1]]);
          };
          /**
           * 获取视图矩形范围
           * @returns {*}
           */
          RegisterCoordinateSystem.prototype.getViewRect = function () {
              var size = this.map.getSize();
              // @ts-ignore
              return new echarts__namespace.graphic.BoundingRect(0, 0, size[0], size[1]);
          };
          /**
           * create matrix
           */
          RegisterCoordinateSystem.prototype.getRoamTransform = function () {
              // @ts-ignore
              return echarts__namespace.matrix.create();
          };
          /**
           * 处理自定义图表类型
           * @returns {{coordSys: {type: string, x, y, width, height}, api: {coord, size}}}
           */
          RegisterCoordinateSystem.prototype.prepareCustoms = function () {
              var rect = this.getViewRect();
              return {
                  coordSys: {
                      type: coordinateSystemId,
                      x: rect.x,
                      y: rect.y,
                      width: rect.width,
                      height: rect.height
                  },
                  api: {
                      coord: bind$6(this.dataToPoint, this),
                      size: bind$6(RegisterCoordinateSystem.dataToCoordsSize, this)
                  }
              };
          };
          RegisterCoordinateSystem.create = function (echartsModel) {
              echartsModel.eachSeries(function (seriesModel) {
                  if (seriesModel.get("coordinateSystem") === coordinateSystemId) {
                      // @ts-ignore
                      seriesModel.coordinateSystem = new RegisterCoordinateSystem(map);
                  }
              });
          };
          RegisterCoordinateSystem.getProjectionCode = function (map) {
              var code = "";
              if (map) {
                  code = map.getView() && map.getView().getProjection().getCode();
              }
              else {
                  code = "EPSG:3857";
              }
              return code;
          };
          RegisterCoordinateSystem.dataToCoordsSize = function (dataSize, dataItem) {
              var _this = this;
              if (dataItem === void 0) { dataItem = [0, 0]; }
              return [0, 1].map(function (dimIdx) {
                  var val = dataItem[dimIdx];
                  var p1 = [];
                  var p2 = [];
                  var halfSize = dataSize[dimIdx] / 2;
                  p1[dimIdx] = val - halfSize;
                  p2[dimIdx] = val + halfSize;
                  p1[1 - dimIdx] = dataItem[1 - dimIdx];
                  p2[1 - dimIdx] = dataItem[1 - dimIdx];
                  // @ts-ignore
                  var offset = _this.dataToPoint(p1)[dimIdx] - _this.dataToPoint(p2)[dimIdx];
                  return Math.abs(offset);
              }, this);
          };
          return RegisterCoordinateSystem;
      };
      /**
       * dispatch event
       * @param event
       */
      EChartsLayer.prototype.dispatchEvent = function (event) {
          return _super.prototype.dispatchEvent.call(this, event);
      };
      EChartsLayer.prototype.set = function (key, value, optSilent) {
          return _super.prototype.set.call(this, key, value, optSilent);
      };
      EChartsLayer.prototype.get = function (key) {
          return _super.prototype.get.call(this, key);
      };
      EChartsLayer.prototype.unset = function (key, optSilent) {
          return _super.prototype.unset.call(this, key, optSilent);
      };
      // @ts-ignore
      EChartsLayer.prototype.on = function (type, listener) {
          return _super.prototype.on.call(this, type, listener);
      };
      EChartsLayer.prototype.un = function (type, listener) {
          return _super.prototype.un.call(this, type, listener);
      };
      EChartsLayer.formatGeoJSON = formatGeoJSON;
      EChartsLayer.bind = bind$6;
      EChartsLayer.merge = merge;
      EChartsLayer.uuid = uuid$1;
      EChartsLayer.bindAll = bindAll;
      EChartsLayer.arrayAdd = arrayAdd;
      EChartsLayer.removeNode = removeNode;
      EChartsLayer.isObject = isObject$9;
      return EChartsLayer;
  }(obj));

  var MTIEChartsLayer = /** @class */ (function (_super) {
      __extends$6(MTIEChartsLayer, _super);
      function MTIEChartsLayer(chartOptions, options, map) {
          return _super.call(this, chartOptions, options, map) || this;
      }
      MTIEChartsLayer.prototype.setChartOptions = function (options) {
          var e_1, _a;
          // @ts-ignore
          this._options.forcedRerender = true;
          // @ts-ignore
          this.clear();
          try {
              // @ts-ignore
              for (var _b = __values(this.$chart.getDom().getElementsByTagName("canvas")), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var canvas = _c.value;
                  canvas.getContext("2d").clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          _super.prototype.setChartOptions.call(this, options);
          // @ts-ignore
          this._options.forcedRerender = false;
          return this;
      };
      return MTIEChartsLayer;
  }(EChartsLayer));
  var Echarts = /** @class */ (function (_super) {
      __extends$6(Echarts, _super);
      function Echarts(options, map) {
          return _super.call(this, options, map) || this;
      }
      Object.defineProperty(Echarts.prototype, "echarts", {
          /**
           * echarts初始化对象
           */
          get: function () {
              return this._echarts;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Echarts.prototype.init = function () {
          this.initialized = true;
          //@ts-ignore
          this._chartsLayer = new MTIEChartsLayer(this.options, {
              hideOnMoving: false,
              forcedRerender: false,
              forcedPrecomposeRerender: false
          });
      };
      Echarts.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this._chartsLayer.appendTo(map.map);
          this._echarts = this._chartsLayer.$chart;
      };
      /**
       * @ignore
       */
      Echarts.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.initialized = false;
          this._chartsLayer.remove();
          this._chartsLayer = void 0;
          this._echarts = void 0;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Echarts.prototype._destroy = function () {
          this.remove();
          _super.prototype._destroy.call(this);
      };
      /**
       * 设置图表`option`
       *
       * 参考内容:[https://echarts.apache.org/zh/api.html#echartsInstance.setOption](https://echarts.apache.org/zh/api.html#echartsInstance.setOption)
       */
      Echarts.prototype.setOption = function (option) {
          this._options = __assign$1(__assign$1({}, option), { id: this.options.id, initOptions: this.options.initOptions });
          this._chartsLayer.setChartOptions(option);
          return this;
      };
      return Echarts;
  }(Component$1));

  /**
   * 遮罩组件
   *
   * [cesium]
   */
  var Mask = /** @class */ (function (_super) {
      __extends$6(Mask, _super);
      function Mask(options, map) {
          var _this = _super.call(this, __assign$1({ visible: true, globe: true }, options)) || this;
          _this._visible = _this.options.visible;
          _this._layer = new VectorLayer({ id: _this.options.id, visible: _this._visible });
          if (defined$1(map)) {
              map.addComponent(_this);
          }
          return _this;
      }
      Object.defineProperty(Mask.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "visible", {
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Mask.prototype, "layer", {
          get: function () {
              return this._layer;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Mask.prototype.init = function () {
          this.initialized = true;
          var mask = this.options.data;
          var globe = this.options.globe;
          var feature_;
          if (globe && !this.options.extent) {
              var _maskPolygon = Turf__namespace.mask(mask);
              feature_ = new Polygon$1({
                  coordinates: _maskPolygon.geometry.coordinates,
                  properties: _maskPolygon.properties
              });
          }
          else {
              var _extent = Turf__namespace.bboxPolygon(this.options.extent || [73.66, 3.86, 135.05, 53.55]);
              var _maskPolygon = Turf__namespace.mask(mask, _extent);
              feature_ = new Polygon$1({
                  coordinates: _maskPolygon.geometry.coordinates,
                  properties: _maskPolygon.properties
              });
          }
          this._layer.addFeature(feature_);
      };
      /**
       * @ignore
       * @param map
       */
      Mask.prototype.addTo = function (map) {
          _super.prototype.addTo.call(this, map);
          this.map.addLayer(this._layer);
          this.options.style && this._layer.setStyle(this.options.style);
      };
      /**
       * @ignore
       */
      Mask.prototype.remove = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          if (!this.map) {
              return;
          }
          if (destroy) {
              this.destroy();
              return;
          }
          this.map.removeLayer(this._layer);
          this.initialized = false;
          this.map = void 0;
      };
      /**
       * @ignore
       */
      Mask.prototype._destroy = function () {
          this.remove();
          this._layer = void 0;
          _super.prototype._destroy.call(this);
      };
      /**
       * 显示墙组件
       */
      Mask.prototype.show = function () {
          if (this.visible === true) {
              return this;
          }
          this._visible = true;
          this._layer.show();
          return this;
      };
      /**
       * 隐藏墙组件
       */
      Mask.prototype.hide = function () {
          if (this.visible === false) {
              return this;
          }
          this._visible = false;
          this._layer.hide();
          return this;
      };
      return Mask;
  }(Component$1));

  /**
   * Code
   */

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Component: Component$1,
    CircleSearch: CircleSearch,
    HistoryTrack: HistoryTrack,
    Draw: Draw,
    get DrawType () { return DrawType; },
    Edit: Edit,
    Measure: Measure,
    get MeasureType () { return MeasureType; },
    Wall: Wall,
    Triangulation: Triangulation,
    Snap: Snap,
    RippleCircle: RippleCircle,
    RotateCircle: RotateCircle,
    ContextMenu: ContextMenu,
    Atmosphere: Atmosphere,
    Fire: Fire,
    Fountain: Fountain,
    Light: Light,
    Rain: Rain,
    Snow: Snow,
    TranslationQueue: TranslationQueue,
    Compass: Compass,
    Coordinate: Coordinate,
    Area: Area,
    VideoShed: VideoShed,
    get CastType () { return CastType; },
    Echarts: Echarts,
    Mask: Mask
  });

  var ModelType;
  (function (ModelType) {
      ModelType["MODEL"] = "model";
      ModelType["MODEL_ENTITY"] = "modelEntity";
  })(ModelType || (ModelType = {}));
  var DirectionType;
  (function (DirectionType) {
      DirectionType["MOVE_UP"] = "moveup";
      DirectionType["MOVE_DOWN"] = "movedown";
      DirectionType["MOVE_LEFT"] = "moveleft";
      DirectionType["MOVE_RIGHT"] = "moveright";
      DirectionType["MOVE_FORWARD"] = "moveforward";
      DirectionType["MOVE_BACKWARD"] = "movebackward";
  })(DirectionType || (DirectionType = {}));

  /**
   * 模型基础类
   *
   * 此为基类,不可实例化
   */
  var Model = /** @class */ (function (_super) {
      __extends$6(Model, _super);
      function Model(options, map) {
          var _this = _super.call(this, options) || this;
          /**
           * @ignore
           */
          _this._visible = true;
          /**
           * @ignore
           */
          _this._initialized = false;
          console.warn(ErrorNotification.NOT_SUPPORTED);
          if (defined$1(map)) {
              map.addModel(_this);
          }
          return _this;
      }
      Object.defineProperty(Model.prototype, "visible", {
          /**
           * 模型显示状态
           */
          get: function () {
              return this._visible;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Model.prototype, "model", {
          /**
           * 内部模型对象
           */
          get: function () {
              return this._model;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Model.prototype, "initialized", {
          /**
           * 初始化状态
           */
          get: function () {
              return this._initialized;
          },
          /**
           * @ignore
           */
          set: function (flag) {
              this._initialized = flag;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * 初始化模型
       *
       * 配置参数在this.options
       *
       * @ignore
       */
      Model.prototype.init = function () { };
      // addTo(map: IMap): void {}
      /**
       * 添加到地球
       *
       * @ignore
       */
      Model.prototype.addTo = function (map) {
          this.map = map;
          // 是否初始化
          this.initialized || this.init();
      };
      /**
       * 从地球上移除
       *
       * @ignore
       */
      Model.prototype.remove = function (destroy) {
      };
      /**
       * 显示模型
       */
      Model.prototype.show = function () {
          this._visible = true;
          return this;
      };
      /**
       * 隐藏模型
       */
      Model.prototype.hide = function () {
          this._visible = false;
          return this;
      };
      Model.prototype.setTranslation = function (translation) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Object.defineProperty(Model.prototype, "rotate", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return null;
          },
          enumerable: false,
          configurable: true
      });
      Model.prototype.setRotate = function (rotate) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      return Model;
  }(BaseObject$1));

  /**
   * glTF模型封装类
   *
   * @class GlTFModel
   * @extends {Model}
   *
   */
  var GLTF = /** @class */ (function (_super) {
      __extends$6(GLTF, _super);
      function GLTF() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      GLTF.prototype.setScale = function (scale) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      GLTF.prototype.setColor = function (color) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      GLTF.prototype.setPlanClip = function (axis) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      GLTF.prototype.autoRotate = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      GLTF.prototype.setPosition = function (position) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      GLTF.prototype.setOrientation = function (orientation) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      return GLTF;
  }(Model));

  /**
   * Cesium 3D Tile 模型实现类
   */
  var Cesium3DTile = /** @class */ (function (_super) {
      __extends$6(Cesium3DTile, _super);
      function Cesium3DTile() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Cesium3DTile.prototype.setStyle = function (style, styleField) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Object.defineProperty(Cesium3DTile.prototype, "translation", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return null;
          },
          enumerable: false,
          configurable: true
      });
      return Cesium3DTile;
  }(Model));

  /**
   * Code
   */

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Model: Model,
    get ModelType () { return ModelType; },
    get DirectionType () { return DirectionType; },
    GLTF: GLTF,
    Cesium3DTile: Cesium3DTile
  });

  function olBrowserEventToBaseEvent(type) {
      switch (type) {
          case MapBrowserEventType.SINGLECLICK:
              return BaseEventType.CLICK;
          case MapBrowserEventType.DBLCLICK:
              return BaseEventType.DOUBLE_CLICK;
          case MapBrowserEventType.POINTERDOWN:
              return BaseEventType.MOUSE_DOWN;
          case MapBrowserEventType.POINTERUP:
              return BaseEventType.MOUSE_UP;
          case "contextmenu":
              return BaseEventType.RIGHT_CLICK;
          case MapBrowserEventType.POINTERMOVE:
              return BaseEventType.MOUSE_MOVE;
          default:
              return type;
      }
  }
  function baseEventToOlBrowserEvent(type) {
      switch (type) {
          case BaseEventType.CLICK:
              return MapBrowserEventType.SINGLECLICK;
          case BaseEventType.DOUBLE_CLICK:
              return MapBrowserEventType.DBLCLICK;
          case BaseEventType.MOUSE_DOWN:
              return MapBrowserEventType.POINTERDOWN;
          case BaseEventType.MOUSE_UP:
              return MapBrowserEventType.POINTERUP;
          case BaseEventType.RIGHT_CLICK:
              return "contextmenu";
          case BaseEventType.MOUSE_MOVE:
              return MapBrowserEventType.POINTERMOVE;
          default:
              return type;
      }
  }

  /**
   * 图层与要素触发点击与移动事件
   */
  var PointClickAndMove = /** @class */ (function (_super) {
      __extends$6(PointClickAndMove, _super);
      function PointClickAndMove(options, map) {
          var _this = _super.call(this, { handleEvent: handleEvent }) || this;
          _this.mtiMap = map;
          _this.options_ = options || {};
          _this.eventsStore_ = (_this.options_.events || ["click"]).map(function (e) { return baseEventToOlBrowserEvent(e); });
          _this.events_ = _this.eventsStore_;
          return _this;
      }
      Object.defineProperty(PointClickAndMove.prototype, "type", {
          get: function () {
              return "PointClickAndMove";
          },
          enumerable: false,
          configurable: true
      });
      PointClickAndMove.prototype.setEvents = function (events) {
          this.eventsStore_ = events.map(function (e) { return baseEventToOlBrowserEvent(e); });
          this.enable();
      };
      PointClickAndMove.prototype.setOverEventAble = function (flag) {
          if (!flag) {
              this.events_ = this.events_.filter(function (val) {
                  return val !== "pointermove";
              });
          }
          else {
              this.events_.push("pointermove");
          }
      };
      PointClickAndMove.prototype.enable = function () {
          this.events_ = this.eventsStore_;
      };
      PointClickAndMove.prototype.disenable = function () {
          this.events_ = [];
      };
      return PointClickAndMove;
  }(Interaction__default["default"]));
  function handleEvent(mapBrowserEvent) {
      var e_1, _a;
      var _this = this;
      var stopEvent = false;
      if (mapBrowserEvent.type === "contextmenu") {
          mapBrowserEvent.preventDefault();
      }
      if (this.events_.includes(mapBrowserEvent.type) && this.map_) {
          if (mapBrowserEvent.type === "pointermove" && mapBrowserEvent.dragging === true) {
              return !stopEvent;
          }
          var coordinate_1 = transformToDataProjection(mapBrowserEvent.coordinate);
          var layers_1 = [];
          var layerMap = new Map();
          // const olFeatures = this.map_.getFeaturesAtPixel(mapBrowserEvent.pixel, {
          //   layerFilter: (layer) => {
          //     return layer[LAYER_LINK] && layer[LAYER_LINK].cluster === false;
          //   }
          // });
          var olFeatures = this.map_.getFeaturesAtPixel(mapBrowserEvent.pixel);
          var type_1 = olBrowserEventToBaseEvent(mapBrowserEvent.type);
          try {
              for (var olFeatures_1 = __values(olFeatures), olFeatures_1_1 = olFeatures_1.next(); !olFeatures_1_1.done; olFeatures_1_1 = olFeatures_1.next()) {
                  var olFeature = olFeatures_1_1.value;
                  var feature = olFeature[FEATURE_LINK];
                  if (!feature) {
                      continue;
                  }
                  if (!layerMap.has(feature === null || feature === void 0 ? void 0 : feature.layer)) {
                      layerMap.set(feature.layer, []);
                  }
                  layerMap.get(feature.layer).push(feature);
                  feature.dispatchEvent({
                      type: type_1,
                      pixel: mapBrowserEvent.pixel,
                      map: this.mtiMap,
                      coordinate: coordinate_1,
                      layer: feature.layer,
                      feature: feature
                  });
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (olFeatures_1_1 && !olFeatures_1_1.done && (_a = olFeatures_1.return)) _a.call(olFeatures_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          var pickType_1 = toPickEventType(type_1);
          var fired_1 = !pickType_1;
          layerMap.forEach(function (features, layer) {
              if (!fired_1) {
                  fired_1 = true;
                  var fs = [features[0]];
                  features[0].dispatchEvent({
                      type: pickType_1,
                      pixel: mapBrowserEvent.pixel,
                      map: _this.mtiMap,
                      coordinate: coordinate_1,
                      layer: features[0].layer,
                      feature: features[0]
                  });
                  layer.dispatchEvent({
                      type: pickType_1,
                      pixel: mapBrowserEvent.pixel,
                      map: _this.mtiMap,
                      layer: layer,
                      coordinate: coordinate_1,
                      features: fs
                  });
              }
              layer.dispatchEvent({
                  type: type_1,
                  pixel: mapBrowserEvent.pixel,
                  map: _this.mtiMap,
                  layer: layer,
                  coordinate: coordinate_1,
                  features: features
              });
              layers_1.push({
                  layer: layer,
                  features: features
              });
          });
          // this.map_.forEachFeatureAtPixel(
          //   mapBrowserEvent.pixel,
          //   (feature, layer) => {
          //     if (layer) {
          //       layer[LAYER_LINK].dispatchEvent({
          //         type,
          //         pixel: mapBrowserEvent.pixel,
          //         map: this.mtiMap,
          //         layer,
          //         coordinate,
          //         clusters: feature.get("features")
          //       });
          //     }
          //   },
          //   {
          //     layerFilter: (layer) => {
          //       return layer[LAYER_LINK] && layer[LAYER_LINK].cluster;
          //     }
          //   }
          // );
          this.mtiMap.dispatchEvent({
              type: type_1,
              pixel: mapBrowserEvent.pixel,
              coordinate: coordinate_1,
              layers: layers_1
          });
      }
      return !stopEvent;
  }

  var Select = /** @class */ (function (_super) {
      __extends$6(Select, _super);
      function Select(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, /** @type {import("./Interaction.js").InteractionOptions} */ options) || this;
          /**
           * 拾取方式，单击、鼠标移动
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this._condition = options.condition ? options.condition : condition.singleClick;
          // 只能拾取聚合要素，即含有子元素大于1的要素
          _this._filter = function (feature, layer) {
              return ((layer && feature.get("features") && feature.get("features").length > 1) || (layer && feature.get("cluster")));
          };
          /**命中检测容差---
           * @private
           * @type {number}
           */
          _this._hitTolerance = options.hitTolerance ? options.hitTolerance : 0;
          _this._featureOverlay = new VectorLayer__default["default"]({
              source: new VectorSource__default["default"]({}),
              updateWhileAnimating: true,
              updateWhileInteracting: true
          });
          // 聚合展开的以像素为单位的半径
          _this._pointRadius = options.pointRadius || 15;
          // 聚合展开时的最大属性，避免因展开数量过大而导致混乱的问题
          _this._maxObjects = options.pointRadius || 10;
          // 动画持续时间
          _this._animationDuration = options.animationDuration || 500;
          _this._linkLineStyle = options.linkLineStyle;
          return _this;
      }
      /**
       * Returns the Hit-detection tolerance.
       * 获取命中检测容差---
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Select.prototype.getHitTolerance = function () {
          return this._hitTolerance;
      };
      /**
       * 返回该交互组件渲染渲染选中要素所在的覆盖图层--
       * Get the overlay layer that this interaction renders selected features to.
       * @return {VectorLayer} Overlay layer.
       * @api
       */
      Select.prototype.getOverlay = function () {
          return this._featureOverlay;
      };
      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Select.prototype.setHitTolerance = function (hitTolerance) {
          this._hitTolerance = hitTolerance;
      };
      Select.prototype.setMap = function (map) {
          var _this = this;
          _super.prototype.setMap.call(this, map);
          this._featureOverlay.setMap(map);
          if (map === null) {
              // 注销监听-------开始
              if (this._zoomlistener)
                  Observable$3.unByKey(this._zoomlistener);
              this._zoomlistener = null;
          }
          // 地图对象添加监听，当地图缩放级别发生变化时调用----
          if (map && map.getView()) {
              this._zoomlistener = map.getView().on("change:resolution", function () {
                  _this._featureOverlay.getSource().clear();
              });
          }
      };
      // 圆形展开的要素数组
      Select.prototype.cirleTypeExpand = function (center, count, features) {
          var max = count;
          var vectors = [];
          var pix = 0;
          if (this.getMap()) {
              pix = this.getMap().getView().getResolution();
          }
          // 获取点位的地图单位半径--
          var r = pix * this._pointRadius * 2.5;
          for (var i = 0; i < max; i++) {
              var angle = (2 * Math.PI * i) / max;
              if (max === 2 || max === 4)
                  angle += Math.PI / 4;
              var cood = [center[0] + r * Math.sin(angle), center[1] + r * Math.cos(angle)];
              // 添加点并设置样式---开始
              var spreadFeature = new OlFeature__default["default"](__assign$1({ selectclusterfeature: true, features: [features[i]], geometry: new Point__default["default"](cood) }, features[i].properties));
              // 添加点并设置样式---结束
              vectors.push(spreadFeature);
              // 连接线要素
              var linkFeature = new OlFeature__default["default"]({
                  geometry: new LineString__default["default"]([center, cood])
              });
              // 连接线要素样式----
              // linkFeature.setStyle(styleUtil.creatNormalStyle(this.linkLineStyle));
              vectors.push(linkFeature);
          }
          return vectors;
      };
      // 螺旋形展开要素数组
      Select.prototype.spiralTypeExpand = function (center, count, features) {
          // 开始角度-----
          var d = 2 * this._pointRadius;
          var max = count;
          var pix = 0;
          var angle = 0;
          var vectors = [];
          if (this.getMap()) {
              pix = this.getMap().getView().getResolution();
          }
          for (var i = 0; i < max; i++) {
              var r = d / 2 + (d * angle) / (2 * Math.PI);
              angle = angle + (d + 0.1) / r;
              var dx = pix * r * Math.sin(angle);
              var dy = pix * r * Math.cos(angle);
              var cood = [center[0] + dx, center[1] + dy];
              var spreadFeature = new OlFeature__default["default"](__assign$1({ selectclusterfeature: true, features: [features[i]], geometry: new Point__default["default"](cood) }, features[i].properties));
              vectors.push(spreadFeature);
              // 连接线要素
              var linkFeature = new OlFeature__default["default"]({
                  geometry: new LineString__default["default"]([center, cood])
              });
              // 连接线样式
              // linkFeature.setStyle(styleUtil.creatNormalStyle(this.linkLineStyle));
              vectors.push(linkFeature);
          }
          return vectors;
      };
      Select.prototype.expandClusterFeature = function (feature, layer) {
          var source = this._featureOverlay.getSource();
          // 要素过滤
          if (this._filter(feature, layer)) {
              // 聚合要素的子要素
              var features = feature.get("features") || layer.getSource().getClusterFeatues(feature.get("cluster_id"));
              // 是否展开
              var expand = layer.get("expand");
              // 是否动画
              var animation = layer.get("animation") || false;
              if (expand) {
                  var expandType = layer.get("expandType") || "spiral";
                  var center = feature.getGeometry().getCoordinates();
                  var max = Math.min(this._maxObjects, features.length);
                  var vectors = [];
                  // 展开类型，螺旋排列
                  if (expandType === "spiral") {
                      vectors = this.spiralTypeExpand(center, max, features);
                  }
                  // 圆形排列
                  if (expandType === "circle") {
                      vectors = this.cirleTypeExpand(center, max, features);
                  }
                  source.clear();
                  if (animation) {
                      // 是否设置动画添加要素
                      this.animateCluster(center, vectors);
                  }
                  else {
                      // 覆盖图层添加要素----
                      source.addFeatures(vectors);
                  }
              }
          }
      };
      // 重写父类方法----，
      Select.prototype.handleEvent = function (mapBrowserEvent) {
          var _this = this;
          if (!this._condition(mapBrowserEvent)) {
              return true;
          }
          var map = mapBrowserEvent.map;
          map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function (feature, layer) {
              // 判断是不是聚合要素----
              if (feature.get("features") || feature.get("cluster")) {
                  if (layer) {
                      if (layer.get("expandedStyle")) {
                          var _style = layer.get("expandedStyle");
                          _this._featureOverlay.setStyle(_style);
                      }
                      if (layer.get("linkeLineStyle")) {
                          var _style = layer.get("linkeLineStyle");
                          _this._linkLineStyle = _style;
                      }
                      _this.expandClusterFeature(feature, layer);
                  }
              }
          }, {
              hitTolerance: this._hitTolerance
          });
          return true;
      };
      // 动画聚合
      Select.prototype.animateCluster = function (center, features) {
          // 注销事件监听-----
          if (this._postListenter) {
              Observable$3.unByKey(this._postListenter);
          }
          var stylefn = this._featureOverlay.getStyleFunction();
          var duration = this._animationDuration;
          // 获取当前时间-----
          var start = new Date().getTime();
          // 动画函数----开始---
          function _animate(event) {
              var vectorContext = render.getVectorContext(event);
              // 获取当前地图视图分辨率---
              var res = this.getMap().getView().getResolution();
              //  动画的放松函数，开始加速然后减速----
              var e = easing.easeOut((event.frameState.time - start) / duration); // 执行动画时设置的放松函数-----参数为0到1，表示动画持续的一部分，返回值为0到1，表示朝向目标状态的进度
              for (var i = 0; i < features.length; i++) {
                  var feature_1 = features[i];
                  if (feature_1.getGeometry() instanceof Point__default["default"]) {
                      var pt = feature_1.getGeometry().getCoordinates();
                      pt[0] = center[0] + e * (pt[0] - center[0]);
                      pt[1] = center[1] + e * (pt[1] - center[1]);
                      var geo = new Point__default["default"](pt);
                      var st = stylefn(feature_1, res);
                      st = Array.isArray(st) ? st : [st];
                      for (var s = 0; s < st.length; s++) {
                          if (vectorContext.setStyle) {
                              vectorContext.setStyle(st[s]);
                              vectorContext.drawGeometry(geo);
                          }
                      }
                  }
              }
              // 停止动画并还原群集可见性
              if (e >= 1.0) {
                  Observable$3.unByKey(this.listenerKey_);
                  this.featureOverlay_.getSource().addFeatures(features);
                  this.featureOverlay_.changed();
                  return;
              }
              this.featureOverlay_.changed();
          }
          // 动画函数结束--------------------------
          // 图层添加渲染后监听
          this._postListenter = this._featureOverlay.on("postrender", _animate.bind(this));
          var feature = new OlFeature__default["default"](new Point__default["default"](this.getMap().getView().getCenter()));
          feature.setStyle(new OlStyle__default["default"]({ image: new CircleStyle__default["default"]() }));
          this._featureOverlay.getSource().addFeature(feature);
          // 触发图层的渲染事件
          this._featureOverlay.changed();
      };
      return Select;
  }(Interaction__default["default"]));

  var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const WOFF = 'application/font-woff';
  const JPEG = 'image/jpeg';
  const mimes = {
      woff: WOFF,
      woff2: WOFF,
      ttf: 'application/font-truetype',
      eot: 'application/vnd.ms-fontobject',
      png: 'image/png',
      jpg: JPEG,
      jpeg: JPEG,
      gif: 'image/gif',
      tiff: 'image/tiff',
      svg: 'image/svg+xml',
  };
  function getExtension(url) {
      const match = /\.([^./]*?)$/g.exec(url);
      return match ? match[1] : '';
  }
  function getMimeType(url) {
      const extension = getExtension(url).toLowerCase();
      return mimes[extension] || '';
  }
  function resolveUrl(url, baseUrl) {
      // url is absolute already
      if (url.match(/^[a-z]+:\/\//i)) {
          return url;
      }
      // url is absolute already, without protocol
      if (url.match(/^\/\//)) {
          return window.location.protocol + url;
      }
      // dataURI, mailto:, tel:, etc.
      if (url.match(/^[a-z]+:/i)) {
          return url;
      }
      const doc = document.implementation.createHTMLDocument();
      const base = doc.createElement('base');
      const a = doc.createElement('a');
      doc.head.appendChild(base);
      doc.body.appendChild(a);
      if (baseUrl) {
          base.href = baseUrl;
      }
      a.href = url;
      return a.href;
  }
  function isDataUrl(url) {
      return url.search(/^(data:)/) !== -1;
  }
  function makeDataUrl(content, mimeType) {
      return `data:${mimeType};base64,${content}`;
  }
  function parseDataUrlContent(dataURL) {
      return dataURL.split(/,/)[1];
  }
  const uuid = (function uuid() {
      // generate uuid for className of pseudo elements.
      // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
      let counter = 0;
      // ref: http://stackoverflow.com/a/6248722/2519373
      const random = () => 
      // eslint-disable-next-line no-bitwise
      `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);
      return () => {
          counter += 1;
          return `u${random()}${counter}`;
      };
  })();
  function toArray(arrayLike) {
      const arr = [];
      for (let i = 0, l = arrayLike.length; i < l; i += 1) {
          arr.push(arrayLike[i]);
      }
      return arr;
  }
  function px(node, styleProperty) {
      const val = window.getComputedStyle(node).getPropertyValue(styleProperty);
      return parseFloat(val.replace('px', ''));
  }
  function getNodeWidth(node) {
      const leftBorder = px(node, 'border-left-width');
      const rightBorder = px(node, 'border-right-width');
      return node.clientWidth + leftBorder + rightBorder;
  }
  function getNodeHeight(node) {
      const topBorder = px(node, 'border-top-width');
      const bottomBorder = px(node, 'border-bottom-width');
      return node.clientHeight + topBorder + bottomBorder;
  }
  function getPixelRatio() {
      let ratio;
      let FINAL_PROCESS;
      try {
          FINAL_PROCESS = process;
      }
      catch (e) {
          // pass
      }
      const val = FINAL_PROCESS && FINAL_PROCESS.env
          ? FINAL_PROCESS.env.devicePixelRatio
          : null;
      if (val) {
          ratio = parseInt(val, 10);
          if (Number.isNaN(ratio)) {
              ratio = 1;
          }
      }
      return ratio || window.devicePixelRatio || 1;
  }
  function createImage$1(url) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.crossOrigin = 'anonymous';
          img.decoding = 'sync';
          img.src = url;
      });
  }
  function svgToDataURL(svg) {
      return __awaiter$6(this, void 0, void 0, function* () {
          return Promise.resolve()
              .then(() => new XMLSerializer().serializeToString(svg))
              .then(encodeURIComponent)
              .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
      });
  }
  function nodeToDataURL(node, width, height) {
      return __awaiter$6(this, void 0, void 0, function* () {
          const xmlns = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(xmlns, 'svg');
          const foreignObject = document.createElementNS(xmlns, 'foreignObject');
          svg.setAttribute('width', `${width}`);
          svg.setAttribute('height', `${height}`);
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          foreignObject.setAttribute('width', '100%');
          foreignObject.setAttribute('height', '100%');
          foreignObject.setAttribute('x', '0');
          foreignObject.setAttribute('y', '0');
          foreignObject.setAttribute('externalResourcesRequired', 'true');
          svg.appendChild(foreignObject);
          foreignObject.appendChild(node);
          return svgToDataURL(svg);
      });
  }

  const cache = {};
  function getCacheKey(url) {
      let key = url.replace(/\?.*/, '');
      // font resourse
      if (/ttf|otf|eot|woff2?/i.test(key)) {
          key = key.replace(/.*\//, '');
      }
      return key;
  }
  function getBlobFromURL(url, options) {
      const cacheKey = getCacheKey(url);
      if (cache[cacheKey] != null) {
          return cache[cacheKey];
      }
      // cache bypass so we dont have CORS issues with cached images
      // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
      if (options.cacheBust) {
          // eslint-disable-next-line no-param-reassign
          url += (/\?/.test(url) ? '&' : '?') + new Date().getTime();
      }
      const failed = (reason) => {
          let placeholder = '';
          if (options.imagePlaceholder) {
              const parts = options.imagePlaceholder.split(/,/);
              if (parts && parts[1]) {
                  placeholder = parts[1];
              }
          }
          let msg = `Failed to fetch resource: ${url}`;
          if (reason) {
              msg = typeof reason === 'string' ? reason : reason.message;
          }
          if (msg) {
              console.error(msg);
          }
          return {
              blob: placeholder,
              contentType: '',
          };
      };
      const deferred = window
          .fetch(url)
          .then((res) => 
      // eslint-disable-next-line promise/no-nesting
      res.blob().then((blob) => ({
          blob,
          contentType: res.headers.get('Content-Type') || '',
      })))
          .then(({ blob, contentType }) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve({
              contentType,
              blob: reader.result,
          });
          reader.onerror = reject;
          reader.readAsDataURL(blob);
      }))
          .then(({ blob, contentType }) => ({
          contentType,
          blob: parseDataUrlContent(blob),
      }))
          // on failed
          .catch(failed);
      // cache result
      cache[cacheKey] = deferred;
      return deferred;
  }

  function formatCSSText(style) {
      const content = style.getPropertyValue('content');
      return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`;
  }
  function formatCSSProperties(style) {
      return toArray(style)
          .map((name) => {
          const value = style.getPropertyValue(name);
          const priority = style.getPropertyPriority(name);
          return `${name}: ${value}${priority ? ' !important' : ''};`;
      })
          .join(' ');
  }
  function getPseudoElementStyle(className, pseudo, style) {
      const selector = `.${className}:${pseudo}`;
      const cssText = style.cssText
          ? formatCSSText(style)
          : formatCSSProperties(style);
      return document.createTextNode(`${selector}{${cssText}}`);
  }
  function clonePseudoElement(nativeNode, clonedNode, pseudo) {
      const style = window.getComputedStyle(nativeNode, pseudo);
      const content = style.getPropertyValue('content');
      if (content === '' || content === 'none') {
          return;
      }
      const className = uuid();
      try {
          clonedNode.className = `${clonedNode.className} ${className}`;
      }
      catch (err) {
          return;
      }
      const styleElement = document.createElement('style');
      styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
      clonedNode.appendChild(styleElement);
  }
  function clonePseudoElements(nativeNode, clonedNode) {
      clonePseudoElement(nativeNode, clonedNode, ':before');
      clonePseudoElement(nativeNode, clonedNode, ':after');
  }

  var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function cloneCanvasElement(node) {
      return __awaiter$5(this, void 0, void 0, function* () {
          const dataURL = node.toDataURL();
          if (dataURL === 'data:,') {
              return Promise.resolve(node.cloneNode(false));
          }
          return createImage$1(dataURL);
      });
  }
  function cloneVideoElement(node, options) {
      return __awaiter$5(this, void 0, void 0, function* () {
          return Promise.resolve(node.poster)
              .then((url) => getBlobFromURL(url, options))
              .then((data) => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType))
              .then((dataURL) => createImage$1(dataURL));
      });
  }
  function cloneSingleNode(node, options) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (node instanceof HTMLCanvasElement) {
              return cloneCanvasElement(node);
          }
          if (node instanceof HTMLVideoElement && node.poster) {
              return cloneVideoElement(node, options);
          }
          return Promise.resolve(node.cloneNode(false));
      });
  }
  const isSlotElement$1 = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';
  function cloneChildren(nativeNode, clonedNode, options) {
      var _a;
      return __awaiter$5(this, void 0, void 0, function* () {
          const children = isSlotElement$1(nativeNode) && nativeNode.assignedNodes
              ? toArray(nativeNode.assignedNodes())
              : toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);
          if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {
              return Promise.resolve(clonedNode);
          }
          return children
              .reduce((deferred, child) => deferred
              // eslint-disable-next-line no-use-before-define
              .then(() => cloneNode(child, options))
              .then((clonedChild) => {
              // eslint-disable-next-line promise/always-return
              if (clonedChild) {
                  clonedNode.appendChild(clonedChild);
              }
          }), Promise.resolve())
              .then(() => clonedNode);
      });
  }
  function cloneCSSStyle(nativeNode, clonedNode) {
      const source = window.getComputedStyle(nativeNode);
      const target = clonedNode.style;
      if (!target) {
          return;
      }
      if (source.cssText) {
          target.cssText = source.cssText;
      }
      else {
          toArray(source).forEach((name) => {
              target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));
          });
      }
  }
  function cloneInputValue(nativeNode, clonedNode) {
      if (nativeNode instanceof HTMLTextAreaElement) {
          clonedNode.innerHTML = nativeNode.value;
      }
      if (nativeNode instanceof HTMLInputElement) {
          clonedNode.setAttribute('value', nativeNode.value);
      }
  }
  function decorate(nativeNode, clonedNode) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof Element)) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve()
              .then(() => cloneCSSStyle(nativeNode, clonedNode))
              .then(() => clonePseudoElements(nativeNode, clonedNode))
              .then(() => cloneInputValue(nativeNode, clonedNode))
              .then(() => clonedNode);
      });
  }
  function cloneNode(node, options, isRoot) {
      return __awaiter$5(this, void 0, void 0, function* () {
          if (!isRoot && options.filter && !options.filter(node)) {
              return Promise.resolve(null);
          }
          return Promise.resolve(node)
              .then((clonedNode) => cloneSingleNode(clonedNode, options))
              .then((clonedNode) => cloneChildren(node, clonedNode, options))
              .then((clonedNode) => decorate(node, clonedNode));
      });
  }

  var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
  const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["'])([^"']+)\1\)/g;
  const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  function toRegex(url) {
      // eslint-disable-next-line no-useless-escape
      const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
      return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g');
  }
  function parseURLs(cssText) {
      const result = [];
      cssText.replace(URL_REGEX, (raw, quotation, url) => {
          result.push(url);
          return raw;
      });
      return result.filter((url) => !isDataUrl(url));
  }
  function embed(cssText, resourceURL, baseURL, options, get) {
      const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
      return Promise.resolve(resolvedURL)
          .then((url) => get ? get(url) : getBlobFromURL(url, options))
          .then((data) => {
          if (typeof data === 'string') {
              return makeDataUrl(data, getMimeType(resourceURL));
          }
          return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);
      })
          .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))
          .then((content) => content, () => resolvedURL);
  }
  function filterPreferredFontFormat(str, { preferredFontFormat }) {
      return !preferredFontFormat
          ? str
          : str.replace(FONT_SRC_REGEX, (match) => {
              // eslint-disable-next-line no-constant-condition
              while (true) {
                  const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
                  if (!format) {
                      return '';
                  }
                  if (format === preferredFontFormat) {
                      return `src: ${src};`;
                  }
              }
          });
  }
  function shouldEmbed(url) {
      return url.search(URL_REGEX) !== -1;
  }
  function embedResources(cssText, baseUrl, options) {
      return __awaiter$4(this, void 0, void 0, function* () {
          if (!shouldEmbed(cssText)) {
              return Promise.resolve(cssText);
          }
          const filteredCSSText = filterPreferredFontFormat(cssText, options);
          return Promise.resolve(filteredCSSText)
              .then(parseURLs)
              .then((urls) => urls.reduce((deferred, url) => 
          // eslint-disable-next-line promise/no-nesting
          deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));
      });
  }

  var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function embedBackground(clonedNode, options) {
      var _a;
      return __awaiter$3(this, void 0, void 0, function* () {
          const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');
          if (!background) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve(background)
              .then((cssString) => embedResources(cssString, null, options))
              .then((cssString) => {
              clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));
              return clonedNode;
          });
      });
  }
  function embedImageNode(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof HTMLImageElement && !isDataUrl(clonedNode.src)) &&
              !(clonedNode instanceof SVGImageElement &&
                  !isDataUrl(clonedNode.href.baseVal))) {
              return Promise.resolve(clonedNode);
          }
          const src = clonedNode instanceof HTMLImageElement
              ? clonedNode.src
              : clonedNode.href.baseVal;
          return Promise.resolve(src)
              .then((url) => getBlobFromURL(url, options))
              .then((data) => makeDataUrl(data.blob, getMimeType(src) || data.contentType))
              .then((dataURL) => new Promise((resolve, reject) => {
              clonedNode.onload = resolve;
              clonedNode.onerror = reject;
              if (clonedNode instanceof HTMLImageElement) {
                  clonedNode.srcset = '';
                  clonedNode.src = dataURL;
              }
              else {
                  clonedNode.href.baseVal = dataURL;
              }
          }))
              .then(() => clonedNode, () => clonedNode);
      });
  }
  function embedChildren(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          const children = toArray(clonedNode.childNodes);
          // eslint-disable-next-line no-use-before-define
          const deferreds = children.map((child) => embedImages(child, options));
          return Promise.all(deferreds).then(() => clonedNode);
      });
  }
  function embedImages(clonedNode, options) {
      return __awaiter$3(this, void 0, void 0, function* () {
          if (!(clonedNode instanceof Element)) {
              return Promise.resolve(clonedNode);
          }
          return Promise.resolve(clonedNode)
              .then((node) => embedBackground(node, options))
              .then((node) => embedImageNode(node, options))
              .then((node) => embedChildren(node, options));
      });
  }

  function applyStyleWithOptions(node, options) {
      const { style } = node;
      if (options.backgroundColor) {
          style.backgroundColor = options.backgroundColor;
      }
      if (options.width) {
          style.width = `${options.width}px`;
      }
      if (options.height) {
          style.height = `${options.height}px`;
      }
      const manual = options.style;
      if (manual != null) {
          Object.keys(manual).forEach((key) => {
              style[key] = manual[key];
          });
      }
      return node;
  }

  var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const cssFetchCache = {};
  function fetchCSS(url) {
      const cache = cssFetchCache[url];
      if (cache != null) {
          return cache;
      }
      const deferred = window.fetch(url).then((res) => ({
          url,
          cssText: res.text(),
      }));
      cssFetchCache[url] = deferred;
      return deferred;
  }
  function embedFonts(meta) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return meta.cssText.then((raw) => {
              let cssText = raw;
              const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
              const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
              const loadFonts = fontLocs.map((location) => {
                  let url = location.replace(regexUrl, '$1');
                  if (!url.startsWith('https://')) {
                      url = new URL(url, meta.url).href;
                  }
                  // eslint-disable-next-line promise/no-nesting
                  return window
                      .fetch(url)
                      .then((res) => res.blob())
                      .then((blob) => new Promise((resolve, reject) => {
                      const reader = new FileReader();
                      reader.onloadend = () => {
                          // Side Effect
                          cssText = cssText.replace(location, `url(${reader.result})`);
                          resolve([location, reader.result]);
                      };
                      reader.onerror = reject;
                      reader.readAsDataURL(blob);
                  }));
              });
              // eslint-disable-next-line promise/no-nesting
              return Promise.all(loadFonts).then(() => cssText);
          });
      });
  }
  function parseCSS(source) {
      if (source == null) {
          return [];
      }
      const result = [];
      const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
      // strip out comments
      let cssText = source.replace(commentsRegex, '');
      const keyframesRegex = new RegExp('((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})', 'gi');
      // eslint-disable-next-line no-constant-condition
      while (true) {
          const matches = keyframesRegex.exec(cssText);
          if (matches === null) {
              break;
          }
          result.push(matches[0]);
      }
      cssText = cssText.replace(keyframesRegex, '');
      const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
      // to match css & media queries together
      const combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
          '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})';
      // unified regex
      const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');
      // eslint-disable-next-line no-constant-condition
      while (true) {
          let matches = importRegex.exec(cssText);
          if (matches === null) {
              matches = unifiedRegex.exec(cssText);
              if (matches === null) {
                  break;
              }
              else {
                  importRegex.lastIndex = unifiedRegex.lastIndex;
              }
          }
          else {
              unifiedRegex.lastIndex = importRegex.lastIndex;
          }
          result.push(matches[0]);
      }
      return result;
  }
  function getCSSRules(styleSheets) {
      return __awaiter$2(this, void 0, void 0, function* () {
          const ret = [];
          const deferreds = [];
          // First loop inlines imports
          styleSheets.forEach((sheet) => {
              if ('cssRules' in sheet) {
                  try {
                      toArray(sheet.cssRules).forEach((item, index) => {
                          if (item.type === CSSRule.IMPORT_RULE) {
                              let importIndex = index + 1;
                              const url = item.href;
                              const deferred = fetchCSS(url)
                                  .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                                  .then((cssText) => parseCSS(cssText).forEach((rule) => {
                                  try {
                                      sheet.insertRule(rule, rule.startsWith('@import')
                                          ? (importIndex += 1)
                                          : sheet.cssRules.length);
                                  }
                                  catch (error) {
                                      console.error('Error inserting rule from remote css', {
                                          rule,
                                          error,
                                      });
                                  }
                              }))
                                  .catch((e) => {
                                  console.error('Error loading remote css', e.toString());
                              });
                              deferreds.push(deferred);
                          }
                      });
                  }
                  catch (e) {
                      const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
                      if (sheet.href != null) {
                          deferreds.push(fetchCSS(sheet.href)
                              .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                              .then((cssText) => parseCSS(cssText).forEach((rule) => {
                              inline.insertRule(rule, sheet.cssRules.length);
                          }))
                              .catch((err) => {
                              console.error('Error loading remote stylesheet', err.toString());
                          }));
                      }
                      console.error('Error inlining remote css file', e.toString());
                  }
              }
          });
          return Promise.all(deferreds).then(() => {
              // Second loop parses rules
              styleSheets.forEach((sheet) => {
                  if ('cssRules' in sheet) {
                      try {
                          toArray(sheet.cssRules).forEach((item) => {
                              ret.push(item);
                          });
                      }
                      catch (e) {
                          console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());
                      }
                  }
              });
              return ret;
          });
      });
  }
  function getWebFontRules(cssRules) {
      return cssRules
          .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
          .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));
  }
  function parseWebFontRules(node) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
              if (node.ownerDocument == null) {
                  reject(new Error('Provided element is not within a Document'));
              }
              resolve(toArray(node.ownerDocument.styleSheets));
          })
              .then((styleSheets) => getCSSRules(styleSheets))
              .then(getWebFontRules);
      });
  }
  function getWebFontCSS(node, options) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return parseWebFontRules(node)
              .then((rules) => Promise.all(rules.map((rule) => {
              const baseUrl = rule.parentStyleSheet
                  ? rule.parentStyleSheet.href
                  : null;
              return embedResources(rule.cssText, baseUrl, options);
          })))
              .then((cssTexts) => cssTexts.join('\n'));
      });
  }
  function embedWebFonts(clonedNode, options) {
      return __awaiter$2(this, void 0, void 0, function* () {
          return (options.fontEmbedCSS != null
              ? Promise.resolve(options.fontEmbedCSS)
              : getWebFontCSS(clonedNode, options)).then((cssText) => {
              const styleNode = document.createElement('style');
              const sytleContent = document.createTextNode(cssText);
              styleNode.appendChild(sytleContent);
              if (clonedNode.firstChild) {
                  clonedNode.insertBefore(styleNode, clonedNode.firstChild);
              }
              else {
                  clonedNode.appendChild(styleNode);
              }
              return clonedNode;
          });
      });
  }

  var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function getImageSize(node, options = {}) {
      const width = options.width || getNodeWidth(node);
      const height = options.height || getNodeHeight(node);
      return { width, height };
  }
  function toSvg(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          const { width, height } = getImageSize(node, options);
          return Promise.resolve(node)
              .then((nativeNode) => cloneNode(nativeNode, options, true))
              .then((clonedNode) => embedWebFonts(clonedNode, options))
              .then((clonedNode) => embedImages(clonedNode, options))
              .then((clonedNode) => applyStyleWithOptions(clonedNode, options))
              .then((clonedNode) => nodeToDataURL(clonedNode, width, height));
      });
  }
  const dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
  function checkCanvasDimensions(canvas) {
      if (canvas.width > dimensionCanvasLimit ||
          canvas.height > dimensionCanvasLimit) {
          if (canvas.width > dimensionCanvasLimit &&
              canvas.height > dimensionCanvasLimit) {
              if (canvas.width > canvas.height) {
                  canvas.height *= dimensionCanvasLimit / canvas.width;
                  canvas.width = dimensionCanvasLimit;
              }
              else {
                  canvas.width *= dimensionCanvasLimit / canvas.height;
                  canvas.height = dimensionCanvasLimit;
              }
          }
          else if (canvas.width > dimensionCanvasLimit) {
              canvas.height *= dimensionCanvasLimit / canvas.width;
              canvas.width = dimensionCanvasLimit;
          }
          else {
              canvas.width *= dimensionCanvasLimit / canvas.height;
              canvas.height = dimensionCanvasLimit;
          }
      }
  }
  function toCanvas(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toSvg(node, options)
              .then(createImage$1)
              .then((img) => {
              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              const ratio = options.pixelRatio || getPixelRatio();
              const { width, height } = getImageSize(node, options);
              const canvasWidth = options.canvasWidth || width;
              const canvasHeight = options.canvasHeight || height;
              canvas.width = canvasWidth * ratio;
              canvas.height = canvasHeight * ratio;
              if (!options.skipAutoScale) {
                  checkCanvasDimensions(canvas);
              }
              canvas.style.width = `${canvasWidth}`;
              canvas.style.height = `${canvasHeight}`;
              if (options.backgroundColor) {
                  context.fillStyle = options.backgroundColor;
                  context.fillRect(0, 0, canvas.width, canvas.height);
              }
              context.drawImage(img, 0, 0, canvas.width, canvas.height);
              return canvas;
          });
      });
  }
  function toPng(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toCanvas(node, options).then((canvas) => canvas.toDataURL());
      });
  }
  function toJpeg(node, options = {}) {
      return __awaiter$1(this, void 0, void 0, function* () {
          return toCanvas(node, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));
      });
  }

  function _typeof$2(obj) {
    "@babel/helpers - typeof";

    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$2(obj);
  }

  // DEFLATE is a complex format; to read this code, you should probably check the RFC first:
  // https://tools.ietf.org/html/rfc1951
  // You may also wish to take a look at the guide I made about this program:
  // https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
  // Much of the following code is similar to that of UZIP.js:
  // https://github.com/photopea/UZIP.js
  // Many optimizations have been made, so the bundle size is ultimately smaller but performance is similar.
  // Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
  // is better for memory in most engines (I *think*).
  // Mediocre shim
  var Worker;
  try {
      Worker = require('worker_threads').Worker;
  }
  catch (e) {
  }

  // aliases for shorter compressed code (most minifers don't do this)
  var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
  // fixed length extra bits
  var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
  // fixed distance extra bits
  // see fleb note
  var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
  // code length index map
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  // get base, reverse index map from extra bits
  var freb = function (eb, start) {
      var b = new u16(31);
      for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
      }
      // numbers here are at max 18 bits
      var r = new u32(b[30]);
      for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
              r[j] = ((j - b[i]) << 5) | i;
          }
      }
      return [b, r];
  };
  var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
  // we can ignore the fact that the other numbers are wrong; they never happen anyway
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
  // map of value to reverse (assuming 16 bits)
  var rev = new u16(32768);
  for (var i$6 = 0; i$6 < 32768; ++i$6) {
      // reverse table algorithm from SO
      var x$1 = ((i$6 & 0xAAAA) >>> 1) | ((i$6 & 0x5555) << 1);
      x$1 = ((x$1 & 0xCCCC) >>> 2) | ((x$1 & 0x3333) << 2);
      x$1 = ((x$1 & 0xF0F0) >>> 4) | ((x$1 & 0x0F0F) << 4);
      rev[i$6] = (((x$1 & 0xFF00) >>> 8) | ((x$1 & 0x00FF) << 8)) >>> 1;
  }
  // create huffman tree from u8 "map": index -> code length for code index
  // mb (max bits) must be at most 15
  // TODO: optimize/split up?
  var hMap = (function (cd, mb, r) {
      var s = cd.length;
      // index
      var i = 0;
      // u16 "map": index -> # of codes with bit length = index
      var l = new u16(mb);
      // length of cd must be 288 (total # of codes)
      for (; i < s; ++i)
          ++l[cd[i] - 1];
      // u16 "map": index -> minimum code for bit length = index
      var le = new u16(mb);
      for (i = 0; i < mb; ++i) {
          le[i] = (le[i - 1] + l[i - 1]) << 1;
      }
      var co;
      if (r) {
          // u16 "map": index -> number of actual bits, symbol for code
          co = new u16(1 << mb);
          // bits to remove for reverser
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
              // ignore 0 lengths
              if (cd[i]) {
                  // num encoding both symbol and bits read
                  var sv = (i << 4) | cd[i];
                  // free bits
                  var r_1 = mb - cd[i];
                  // start value
                  var v = le[cd[i] - 1]++ << r_1;
                  // m is end value
                  for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                      // every 16 bit value starting with the code yields the same result
                      co[rev[v] >>> rvb] = sv;
                  }
              }
          }
      }
      else {
          co = new u16(s);
          for (i = 0; i < s; ++i)
              co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
      }
      return co;
  });
  // fixed length tree
  var flt = new u8(288);
  for (var i$6 = 0; i$6 < 144; ++i$6)
      flt[i$6] = 8;
  for (var i$6 = 144; i$6 < 256; ++i$6)
      flt[i$6] = 9;
  for (var i$6 = 256; i$6 < 280; ++i$6)
      flt[i$6] = 7;
  for (var i$6 = 280; i$6 < 288; ++i$6)
      flt[i$6] = 8;
  // fixed distance tree
  var fdt = new u8(32);
  for (var i$6 = 0; i$6 < 32; ++i$6)
      fdt[i$6] = 5;
  // fixed length map
  var flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);
  // fixed distance map
  var fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
  // find max of array
  var max$3 = function (a) {
      var m = a[0];
      for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
              m = a[i];
      }
      return m;
  };
  // read d, starting at bit p and mask with m
  var bits = function (d, p, m) {
      var o = (p / 8) >> 0;
      return ((d[o] | (d[o + 1] << 8)) >>> (p & 7)) & m;
  };
  // read d, starting at bit p continuing for at least 16 bits
  var bits16 = function (d, p) {
      var o = (p / 8) >> 0;
      return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >>> (p & 7));
  };
  // get end of byte
  var shft = function (p) { return ((p / 8) >> 0) + (p & 7 && 1); };
  // typed array slice - allows garbage collector to free original reference,
  // while being more compatible than .slice
  var slc = function (v, s, e) {
      if (s == null || s < 0)
          s = 0;
      if (e == null || e > v.length)
          e = v.length;
      // can't use .constructor in case user-supplied
      var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
      n.set(v.subarray(s, e));
      return n;
  };
  // expands raw DEFLATE data
  var inflt = function (dat, buf, st) {
      // source length
      var sl = dat.length;
      // have to estimate size
      var noBuf = !buf || st;
      // no state
      var noSt = !st || st.i;
      if (!st)
          st = {};
      // Assumes roughly 33% compression ratio average
      if (!buf)
          buf = new u8(sl * 3);
      // ensure buffer can fit at least l elements
      var cbuf = function (l) {
          var bl = buf.length;
          // need to increase size to fit
          if (l > bl) {
              // Double or set to necessary, whichever is greater
              var nbuf = new u8(Math.max(bl * 2, l));
              nbuf.set(buf);
              buf = nbuf;
          }
      };
      //  last chunk         bitpos           bytes
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      // total bits
      var tbts = sl * 8;
      do {
          if (!lm) {
              // BFINAL - this is only 1 when last chunk is next
              st.f = final = bits(dat, pos, 1);
              // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
              var type = bits(dat, pos + 1, 3);
              pos += 3;
              if (!type) {
                  // go to end of byte boundary
                  var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                  if (t > sl) {
                      if (noSt)
                          throw 'unexpected EOF';
                      break;
                  }
                  // ensure size
                  if (noBuf)
                      cbuf(bt + l);
                  // Copy over uncompressed data
                  buf.set(dat.subarray(s, t), bt);
                  // Get new bitpos, update byte count
                  st.b = bt += l, st.p = pos = t * 8;
                  continue;
              }
              else if (type == 1)
                  lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
              else if (type == 2) {
                  //  literal                            lengths
                  var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                  var tl = hLit + bits(dat, pos + 5, 31) + 1;
                  pos += 14;
                  // length+distance tree
                  var ldt = new u8(tl);
                  // code length tree
                  var clt = new u8(19);
                  for (var i = 0; i < hcLen; ++i) {
                      // use index map to get real code
                      clt[clim[i]] = bits(dat, pos + i * 3, 7);
                  }
                  pos += hcLen * 3;
                  // code lengths bits
                  var clb = max$3(clt), clbmsk = (1 << clb) - 1;
                  if (!noSt && pos + tl * (clb + 7) > tbts)
                      break;
                  // code lengths map
                  var clm = hMap(clt, clb, 1);
                  for (var i = 0; i < tl;) {
                      var r = clm[bits(dat, pos, clbmsk)];
                      // bits read
                      pos += r & 15;
                      // symbol
                      var s = r >>> 4;
                      // code length to copy
                      if (s < 16) {
                          ldt[i++] = s;
                      }
                      else {
                          //  copy   count
                          var c = 0, n = 0;
                          if (s == 16)
                              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                          else if (s == 17)
                              n = 3 + bits(dat, pos, 7), pos += 3;
                          else if (s == 18)
                              n = 11 + bits(dat, pos, 127), pos += 7;
                          while (n--)
                              ldt[i++] = c;
                      }
                  }
                  //    length tree                 distance tree
                  var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                  // max length bits
                  lbt = max$3(lt);
                  // max dist bits
                  dbt = max$3(dt);
                  lm = hMap(lt, lbt, 1);
                  dm = hMap(dt, dbt, 1);
              }
              else
                  throw 'invalid block type';
              if (pos > tbts)
                  throw 'unexpected EOF';
          }
          // Make sure the buffer can hold this + the largest possible addition
          // Maximum chunk size (practically, theoretically infinite) is 2^17;
          if (noBuf)
              cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var mxa = lbt + dbt + 18;
          while (noSt || pos + mxa < tbts) {
              // bits read, code
              var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
              pos += c & 15;
              if (pos > tbts)
                  throw 'unexpected EOF';
              if (!c)
                  throw 'invalid length/literal';
              if (sym < 256)
                  buf[bt++] = sym;
              else if (sym == 256) {
                  lm = null;
                  break;
              }
              else {
                  var add = sym - 254;
                  // no extra bits needed if less
                  if (sym > 264) {
                      // index
                      var i = sym - 257, b = fleb[i];
                      add = bits(dat, pos, (1 << b) - 1) + fl[i];
                      pos += b;
                  }
                  // dist
                  var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                  if (!d)
                      throw 'invalid distance';
                  pos += d & 15;
                  var dt = fd[dsym];
                  if (dsym > 3) {
                      var b = fdeb[dsym];
                      dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                  }
                  if (pos > tbts)
                      throw 'unexpected EOF';
                  if (noBuf)
                      cbuf(bt + 131072);
                  var end = bt + add;
                  for (; bt < end; bt += 4) {
                      buf[bt] = buf[bt - dt];
                      buf[bt + 1] = buf[bt + 1 - dt];
                      buf[bt + 2] = buf[bt + 2 - dt];
                      buf[bt + 3] = buf[bt + 3 - dt];
                  }
                  bt = end;
              }
          }
          st.l = lm, st.p = pos, st.b = bt;
          if (lm)
              final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  // starting at p, write the minimum number of bits that can hold v to d
  var wbits = function (d, p, v) {
      v <<= p & 7;
      var o = (p / 8) >> 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
  };
  // starting at p, write the minimum number of bits (>8) that can hold v to d
  var wbits16 = function (d, p, v) {
      v <<= p & 7;
      var o = (p / 8) >> 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
      d[o + 2] |= v >>> 16;
  };
  // creates code lengths from a frequency table
  var hTree = function (d, mb) {
      // Need extra info to make a tree
      var t = [];
      for (var i = 0; i < d.length; ++i) {
          if (d[i])
              t.push({ s: i, f: d[i] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
          return [new u8(0), 0];
      if (s == 1) {
          var v = new u8(t[0].s + 1);
          v[t[0].s] = 1;
          return [v, 1];
      }
      t.sort(function (a, b) { return a.f - b.f; });
      // after i2 reaches last ind, will be stopped
      // freq must be greater than largest possible number of symbols
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
      t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
      // efficient algorithm from UZIP.js
      // i0 is lookbehind, i2 is lookahead - after processing two low-freq
      // symbols that combined have high freq, will start processing i2 (high-freq,
      // non-composite) symbols instead
      // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
      while (i1 != s - 1) {
          l = t[t[i0].f < t[i2].f ? i0++ : i2++];
          r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
          t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
      }
      var maxSym = t2[0].s;
      for (var i = 1; i < s; ++i) {
          if (t2[i].s > maxSym)
              maxSym = t2[i].s;
      }
      // code lengths
      var tr = new u16(maxSym + 1);
      // max bits in tree
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
          // more algorithms from UZIP.js
          // TODO: find out how this code works (debt)
          //  ind    debt
          var i = 0, dt = 0;
          //    left            cost
          var lft = mbt - mb, cst = 1 << lft;
          t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
          for (; i < s; ++i) {
              var i2_1 = t2[i].s;
              if (tr[i2_1] > mb) {
                  dt += cst - (1 << (mbt - tr[i2_1]));
                  tr[i2_1] = mb;
              }
              else
                  break;
          }
          dt >>>= lft;
          while (dt > 0) {
              var i2_2 = t2[i].s;
              if (tr[i2_2] < mb)
                  dt -= 1 << (mb - tr[i2_2]++ - 1);
              else
                  ++i;
          }
          for (; i >= 0 && dt; --i) {
              var i2_3 = t2[i].s;
              if (tr[i2_3] == mb) {
                  --tr[i2_3];
                  ++dt;
              }
          }
          mbt = mb;
      }
      return [new u8(tr), mbt];
  };
  // get the max length and assign length codes
  var ln = function (n, l, d) {
      return n.s == -1
          ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
          : (l[n.s] = d);
  };
  // length codes generation
  var lc = function (c) {
      var s = c.length;
      // Note that the semicolon was intentional
      while (s && !c[--s])
          ;
      var cl = new u16(++s);
      //  ind      num         streak
      var cli = 0, cln = c[0], cls = 1;
      var w = function (v) { cl[cli++] = v; };
      for (var i = 1; i <= s; ++i) {
          if (c[i] == cln && i != s)
              ++cls;
          else {
              if (!cln && cls > 2) {
                  for (; cls > 138; cls -= 138)
                      w(32754);
                  if (cls > 2) {
                      w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                      cls = 0;
                  }
              }
              else if (cls > 3) {
                  w(cln), --cls;
                  for (; cls > 6; cls -= 6)
                      w(8304);
                  if (cls > 2)
                      w(((cls - 3) << 5) | 8208), cls = 0;
              }
              while (cls--)
                  w(cln);
              cls = 1;
              cln = c[i];
          }
      }
      return [cl.subarray(0, cli), s];
  };
  // calculate the length of output from tree, code lengths
  var clen = function (cf, cl) {
      var l = 0;
      for (var i = 0; i < cl.length; ++i)
          l += cf[i] * cl[i];
      return l;
  };
  // writes a fixed block
  // returns the new bit pos
  var wfblk = function (out, pos, dat) {
      // no need to write 00 as type: TypedArray defaults to 0
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >>> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i = 0; i < s; ++i)
          out[o + i + 4] = dat[i];
      return (o + 4 + s) * 8;
  };
  // writes a block
  var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];
      var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];
      var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
      var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
      var lcfreq = new u16(19);
      for (var i = 0; i < lclt.length; ++i)
          lcfreq[lclt[i] & 31]++;
      for (var i = 0; i < lcdt.length; ++i)
          lcfreq[lcdt[i] & 31]++;
      var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
          ;
      var flen = (bl + 5) << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
      if (flen <= ftlen && flen <= dtlen)
          return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
          lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
          var llm = hMap(lct, mlcb, 0);
          wbits(out, p, nlc - 257);
          wbits(out, p + 5, ndc - 1);
          wbits(out, p + 10, nlcc - 4);
          p += 14;
          for (var i = 0; i < nlcc; ++i)
              wbits(out, p + 3 * i, lct[clim[i]]);
          p += 3 * nlcc;
          var lcts = [lclt, lcdt];
          for (var it = 0; it < 2; ++it) {
              var clct = lcts[it];
              for (var i = 0; i < clct.length; ++i) {
                  var len = clct[i] & 31;
                  wbits(out, p, llm[len]), p += lct[len];
                  if (len > 15)
                      wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;
              }
          }
      }
      else {
          lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i = 0; i < li; ++i) {
          if (syms[i] > 255) {
              var len = (syms[i] >>> 18) & 31;
              wbits16(out, p, lm[len + 257]), p += ll[len + 257];
              if (len > 7)
                  wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];
              var dst = syms[i] & 31;
              wbits16(out, p, dm[dst]), p += dl[dst];
              if (dst > 3)
                  wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];
          }
          else {
              wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
          }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
  };
  // deflate options (nice << 13) | chain
  var deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  // empty
  var et$1 = /*#__PURE__*/ new u8(0);
  // compresses data into a raw DEFLATE buffer
  var dflt = function (dat, lvl, plvl, pre, post, lst) {
      var s = dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.floor(s / 7000)) + post);
      // writing to this writes to the output buffer
      var w = o.subarray(pre, o.length - post);
      var pos = 0;
      if (!lvl || s < 8) {
          for (var i = 0; i <= s; i += 65535) {
              // end
              var e = i + 65535;
              if (e < s) {
                  // write full block
                  pos = wfblk(w, pos, dat.subarray(i, e));
              }
              else {
                  // write final block
                  w[i] = lst;
                  pos = wfblk(w, pos, dat.subarray(i, s));
              }
          }
      }
      else {
          var opt = deo[lvl - 1];
          var n = opt >>> 13, c = opt & 8191;
          var msk_1 = (1 << plvl) - 1;
          //    prev 2-byte val map    curr 2-byte val map
          var prev = new u16(32768), head = new u16(msk_1 + 1);
          var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
          var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
          // 24576 is an arbitrary number of maximum symbols per block
          // 424 buffer for last block
          var syms = new u32(25000);
          // length/literal freq   distance freq
          var lf = new u16(288), df = new u16(32);
          //  l/lcnt  exbits  index  l/lind  waitdx  bitpos
          var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;
          for (; i < s; ++i) {
              // hash value
              var hv = hsh(i);
              // index mod 32768
              var imod = i & 32767;
              // previous index with this value
              var pimod = head[hv];
              prev[imod] = pimod;
              head[hv] = imod;
              // We always should modify head and prev, but only add symbols if
              // this data is not yet processed ("wait" for wait index)
              if (wi <= i) {
                  // bytes remaining
                  var rem = s - i;
                  if ((lc_1 > 7000 || li > 24576) && rem > 423) {
                      pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                      li = lc_1 = eb = 0, bs = i;
                      for (var j = 0; j < 286; ++j)
                          lf[j] = 0;
                      for (var j = 0; j < 30; ++j)
                          df[j] = 0;
                  }
                  //  len    dist   chain
                  var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;
                  if (rem > 2 && hv == hsh(i - dif)) {
                      var maxn = Math.min(n, rem) - 1;
                      var maxd = Math.min(32767, i);
                      // max possible length
                      // not capped at dif because decompressors implement "rolling" index population
                      var ml = Math.min(258, rem);
                      while (dif <= maxd && --ch_1 && imod != pimod) {
                          if (dat[i + l] == dat[i + l - dif]) {
                              var nl = 0;
                              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                  ;
                              if (nl > l) {
                                  l = nl, d = dif;
                                  // break out early when we reach "nice" (we are satisfied enough)
                                  if (nl > maxn)
                                      break;
                                  // now, find the rarest 2-byte sequence within this
                                  // length of literals and search for that instead.
                                  // Much faster than just using the start
                                  var mmd = Math.min(dif, nl - 2);
                                  var md = 0;
                                  for (var j = 0; j < mmd; ++j) {
                                      var ti = (i - dif + j + 32768) & 32767;
                                      var pti = prev[ti];
                                      var cd = (ti - pti + 32768) & 32767;
                                      if (cd > md)
                                          md = cd, pimod = ti;
                                  }
                              }
                          }
                          // check the previous match
                          imod = pimod, pimod = prev[imod];
                          dif += (imod - pimod + 32768) & 32767;
                      }
                  }
                  // d will be nonzero only when a match was found
                  if (d) {
                      // store both dist and len data in one Uint32
                      // Make sure this is recognized as a len/dist with 28th bit (2^28)
                      syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                      var lin = revfl[l] & 31, din = revfd[d] & 31;
                      eb += fleb[lin] + fdeb[din];
                      ++lf[257 + lin];
                      ++df[din];
                      wi = i + l;
                      ++lc_1;
                  }
                  else {
                      syms[li++] = dat[i];
                      ++lf[dat[i]];
                  }
              }
          }
          pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
          // this is the easiest way to avoid needing to maintain state
          if (!lst)
              pos = wfblk(w, pos, et$1);
      }
      return slc(o, 0, pre + shft(pos) + post);
  };
  // Alder32
  var adler = function () {
      var a = 1, b = 0;
      return {
          p: function (d) {
              // closures have awful performance
              var n = a, m = b;
              var l = d.length;
              for (var i = 0; i != l;) {
                  var e = Math.min(i + 5552, l);
                  for (; i < e; ++i)
                      n += d[i], m += n;
                  n %= 65521, m %= 65521;
              }
              a = n, b = m;
          },
          d: function () { return ((a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8)) + ((a & 255) << 23) * 2; }
      };
  };
  // deflate with opts
  var dopt = function (dat, opt, pre, post, st) {
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);
  };
  // write bytes
  var wbytes = function (d, b, v) {
      for (; v; ++b)
          d[b] = v, v >>>= 8;
  };
  // zlib header
  var zlh = function (c, o) {
      var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);
  };
  // zlib valid
  var zlv = function (d) {
      if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
          throw 'invalid zlib data';
      if (d[1] & 32)
          throw 'invalid zlib data: preset dictionaries not supported';
  };
  /**
   * Compress data with Zlib
   * @param data The data to compress
   * @param opts The compression options
   * @returns The zlib-compressed version of the data
   */
  function zlibSync(data, opts) {
      if (opts === void 0) { opts = {}; }
      var a = adler();
      a.p(data);
      var d = dopt(data, opts, 2, 4);
      return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
  }
  /**
   * Expands Zlib data
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */
  function unzlibSync(data, out) {
      return inflt((zlv(data), data.subarray(2, -4)), out);
  }

  /** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2021 yWorks GmbH, http://www.yworks.com
   *               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   */
  var n$1=function(){return "undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this}();function i$5(){n$1.console&&"function"==typeof n$1.console.log&&n$1.console.log.apply(n$1.console,arguments);}var a$2={log:i$5,warn:function(t){n$1.console&&("function"==typeof n$1.console.warn?n$1.console.warn.apply(n$1.console,arguments):i$5.call(null,arguments));},error:function(t){n$1.console&&("function"==typeof n$1.console.error?n$1.console.error.apply(n$1.console,arguments):i$5(t));}};function o$1(t,e,r){var n=new XMLHttpRequest;n.open("GET",t),n.responseType="blob",n.onload=function(){l$1(n.response,e,r);},n.onerror=function(){a$2.error("could not download file");},n.send();}function s$1(t){var e=new XMLHttpRequest;e.open("HEAD",t,!1);try{e.send();}catch(t){}return e.status>=200&&e.status<=299}function c$2(t){try{t.dispatchEvent(new MouseEvent("click"));}catch(r){var e=document.createEvent("MouseEvents");e.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),t.dispatchEvent(e);}}var u$2,h$1,l$1=n$1.saveAs||("object"!==("undefined"==typeof window?"undefined":_typeof$2(window))||window!==n$1?function(){}:"undefined"!=typeof HTMLAnchorElement&&"download"in HTMLAnchorElement.prototype?function(t,e,r){var i=n$1.URL||n$1.webkitURL,a=document.createElement("a");e=e||t.name||"download",a.download=e,a.rel="noopener","string"==typeof t?(a.href=t,a.origin!==location.origin?s$1(a.href)?o$1(t,e,r):c$2(a,a.target="_blank"):c$2(a)):(a.href=i.createObjectURL(t),setTimeout((function(){i.revokeObjectURL(a.href);}),4e4),setTimeout((function(){c$2(a);}),0));}:"msSaveOrOpenBlob"in navigator?function(e,r,n){if(r=r||e.name||"download","string"==typeof e)if(s$1(e))o$1(e,r,n);else {var i=document.createElement("a");i.href=e,i.target="_blank",setTimeout((function(){c$2(i);}));}else navigator.msSaveOrOpenBlob(function(e,r){return void 0===r?r={autoBom:!1}:"object"!==_typeof$2(r)&&(a$2.warn("Deprecated: Expected third argument to be a object"),r={autoBom:!r}),r.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob([String.fromCharCode(65279),e],{type:e.type}):e}(e,n),r);}:function(e,r,i,a){if((a=a||open("","_blank"))&&(a.document.title=a.document.body.innerText="downloading..."),"string"==typeof e)return o$1(e,r,i);var s="application/octet-stream"===e.type,c=/constructor/i.test(n$1.HTMLElement)||n$1.safari,u=/CriOS\/[\d]+/.test(navigator.userAgent);if((u||s&&c)&&"object"===("undefined"==typeof FileReader?"undefined":_typeof$2(FileReader))){var h=new FileReader;h.onloadend=function(){var t=h.result;t=u?t:t.replace(/^data:[^;]*;/,"data:attachment/file;"),a?a.location.href=t:location=t,a=null;},h.readAsDataURL(e);}else {var l=n$1.URL||n$1.webkitURL,f=l.createObjectURL(e);a?a.location=f:location.href=f,a=null,setTimeout((function(){l.revokeObjectURL(f);}),4e4);}});
  /**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   */function f$2(t){var e;t=t||"",this.ok=!1,"#"==t.charAt(0)&&(t=t.substr(1,6));t={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"}[t=(t=t.replace(/ /g,"")).toLowerCase()]||t;for(var r=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example:["rgb(123, 234, 45)","rgb(255,234,245)"],process:function(t){return [parseInt(t[1]),parseInt(t[2]),parseInt(t[3])]}},{re:/^(\w{2})(\w{2})(\w{2})$/,example:["#00ff00","336699"],process:function(t){return [parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,example:["#fb0","f0f"],process:function(t){return [parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}}],n=0;n<r.length;n++){var i=r[n].re,a=r[n].process,o=i.exec(t);o&&(e=a(o),this.r=e[0],this.g=e[1],this.b=e[2],this.ok=!0);}this.r=this.r<0||isNaN(this.r)?0:this.r>255?255:this.r,this.g=this.g<0||isNaN(this.g)?0:this.g>255?255:this.g,this.b=this.b<0||isNaN(this.b)?0:this.b>255?255:this.b,this.toRGB=function(){return "rgb("+this.r+", "+this.g+", "+this.b+")"},this.toHex=function(){var t=this.r.toString(16),e=this.g.toString(16),r=this.b.toString(16);return 1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==r.length&&(r="0"+r),"#"+t+e+r};}
  /**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   */
  function d(t,e){var r=t[0],n=t[1],i=t[2],a=t[3];r=g(r,n,i,a,e[0],7,-680876936),a=g(a,r,n,i,e[1],12,-389564586),i=g(i,a,r,n,e[2],17,606105819),n=g(n,i,a,r,e[3],22,-1044525330),r=g(r,n,i,a,e[4],7,-176418897),a=g(a,r,n,i,e[5],12,1200080426),i=g(i,a,r,n,e[6],17,-1473231341),n=g(n,i,a,r,e[7],22,-45705983),r=g(r,n,i,a,e[8],7,1770035416),a=g(a,r,n,i,e[9],12,-1958414417),i=g(i,a,r,n,e[10],17,-42063),n=g(n,i,a,r,e[11],22,-1990404162),r=g(r,n,i,a,e[12],7,1804603682),a=g(a,r,n,i,e[13],12,-40341101),i=g(i,a,r,n,e[14],17,-1502002290),r=m$2(r,n=g(n,i,a,r,e[15],22,1236535329),i,a,e[1],5,-165796510),a=m$2(a,r,n,i,e[6],9,-1069501632),i=m$2(i,a,r,n,e[11],14,643717713),n=m$2(n,i,a,r,e[0],20,-373897302),r=m$2(r,n,i,a,e[5],5,-701558691),a=m$2(a,r,n,i,e[10],9,38016083),i=m$2(i,a,r,n,e[15],14,-660478335),n=m$2(n,i,a,r,e[4],20,-405537848),r=m$2(r,n,i,a,e[9],5,568446438),a=m$2(a,r,n,i,e[14],9,-1019803690),i=m$2(i,a,r,n,e[3],14,-187363961),n=m$2(n,i,a,r,e[8],20,1163531501),r=m$2(r,n,i,a,e[13],5,-1444681467),a=m$2(a,r,n,i,e[2],9,-51403784),i=m$2(i,a,r,n,e[7],14,1735328473),r=v$1(r,n=m$2(n,i,a,r,e[12],20,-1926607734),i,a,e[5],4,-378558),a=v$1(a,r,n,i,e[8],11,-2022574463),i=v$1(i,a,r,n,e[11],16,1839030562),n=v$1(n,i,a,r,e[14],23,-35309556),r=v$1(r,n,i,a,e[1],4,-1530992060),a=v$1(a,r,n,i,e[4],11,1272893353),i=v$1(i,a,r,n,e[7],16,-155497632),n=v$1(n,i,a,r,e[10],23,-1094730640),r=v$1(r,n,i,a,e[13],4,681279174),a=v$1(a,r,n,i,e[0],11,-358537222),i=v$1(i,a,r,n,e[3],16,-722521979),n=v$1(n,i,a,r,e[6],23,76029189),r=v$1(r,n,i,a,e[9],4,-640364487),a=v$1(a,r,n,i,e[12],11,-421815835),i=v$1(i,a,r,n,e[15],16,530742520),r=b(r,n=v$1(n,i,a,r,e[2],23,-995338651),i,a,e[0],6,-198630844),a=b(a,r,n,i,e[7],10,1126891415),i=b(i,a,r,n,e[14],15,-1416354905),n=b(n,i,a,r,e[5],21,-57434055),r=b(r,n,i,a,e[12],6,1700485571),a=b(a,r,n,i,e[3],10,-1894986606),i=b(i,a,r,n,e[10],15,-1051523),n=b(n,i,a,r,e[1],21,-2054922799),r=b(r,n,i,a,e[8],6,1873313359),a=b(a,r,n,i,e[15],10,-30611744),i=b(i,a,r,n,e[6],15,-1560198380),n=b(n,i,a,r,e[13],21,1309151649),r=b(r,n,i,a,e[4],6,-145523070),a=b(a,r,n,i,e[11],10,-1120210379),i=b(i,a,r,n,e[2],15,718787259),n=b(n,i,a,r,e[9],21,-343485551),t[0]=_$1(r,t[0]),t[1]=_$1(n,t[1]),t[2]=_$1(i,t[2]),t[3]=_$1(a,t[3]);}function p$1(t,e,r,n,i,a){return e=_$1(_$1(e,t),_$1(n,a)),_$1(e<<i|e>>>32-i,r)}function g(t,e,r,n,i,a,o){return p$1(e&r|~e&n,t,e,i,a,o)}function m$2(t,e,r,n,i,a,o){return p$1(e&n|r&~n,t,e,i,a,o)}function v$1(t,e,r,n,i,a,o){return p$1(e^r^n,t,e,i,a,o)}function b(t,e,r,n,i,a,o){return p$1(r^(e|~n),t,e,i,a,o)}function y$1(t){var e,r=t.length,n=[1732584193,-271733879,-1732584194,271733878];for(e=64;e<=t.length;e+=64)d(n,w(t.substring(e-64,e)));t=t.substring(e-64);var i=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(e=0;e<t.length;e++)i[e>>2]|=t.charCodeAt(e)<<(e%4<<3);if(i[e>>2]|=128<<(e%4<<3),e>55)for(d(n,i),e=0;e<16;e++)i[e]=0;return i[14]=8*r,d(n,i),n}function w(t){var e,r=[];for(e=0;e<64;e+=4)r[e>>2]=t.charCodeAt(e)+(t.charCodeAt(e+1)<<8)+(t.charCodeAt(e+2)<<16)+(t.charCodeAt(e+3)<<24);return r}u$2=n$1.atob.bind(n$1),h$1=n$1.btoa.bind(n$1);var N$1="0123456789abcdef".split("");function L$1(t){for(var e="",r=0;r<4;r++)e+=N$1[t>>8*r+4&15]+N$1[t>>8*r&15];return e}function A$1(t){return String.fromCharCode((255&t)>>0,(65280&t)>>8,(16711680&t)>>16,(4278190080&t)>>24)}function x(t){return y$1(t).map(A$1).join("")}var S="5d41402abc4b2a76b9719d911017c592"!=function(t){for(var e=0;e<t.length;e++)t[e]=L$1(t[e]);return t.join("")}(y$1("hello"));function _$1(t,e){if(S){var r=(65535&t)+(65535&e);return (t>>16)+(e>>16)+(r>>16)<<16|65535&r}return t+e&4294967295}
  /**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   */function P(t,e){var r,n,i,a;if(t!==r){for(var o=(i=t,a=1+(256/t.length>>0),new Array(a+1).join(i)),s=[],c=0;c<256;c++)s[c]=c;var u=0;for(c=0;c<256;c++){var h=s[c];u=(u+h+o.charCodeAt(c))%256,s[c]=s[u],s[u]=h;}r=t,n=s;}else s=n;var l=e.length,f=0,d=0,p="";for(c=0;c<l;c++)d=(d+(h=s[f=(f+1)%256]))%256,s[f]=s[d],s[d]=h,o=s[(s[f]+s[d])%256],p+=String.fromCharCode(e.charCodeAt(c)^o);return p}
  /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   */var k={print:4,modify:8,copy:16,"annot-forms":32};function I(t,e,r,n){this.v=1,this.r=2;var i=192;t.forEach((function(t){i+=k[t];})),this.padding="(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";var a=(e+this.padding).substr(0,32),o=(r+this.padding).substr(0,32);this.O=this.processOwnerPassword(a,o),this.P=-(1+(255^i)),this.encryptionKey=x(a+this.O+this.lsbFirstWord(this.P)+this.hexToBytes(n)).substr(0,5),this.U=P(this.encryptionKey,this.padding);}function F$1(t){if(/[^\u0000-\u00ff]/.test(t))throw new Error("Invalid PDF Name Object: "+t+", Only accept ASCII characters.");for(var e="",r=t.length,n=0;n<r;n++){var i=t.charCodeAt(n);if(i<33||35===i||37===i||40===i||41===i||47===i||60===i||62===i||91===i||93===i||123===i||125===i||i>126)e+="#"+("0"+i.toString(16)).slice(-2);else e+=t[n];}return e}function C(e){if("object"!==_typeof$2(e))throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");var r={};this.subscribe=function(t,e,n){if(n=n||!1,"string"!=typeof t||"function"!=typeof e||"boolean"!=typeof n)throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");r.hasOwnProperty(t)||(r[t]={});var i=Math.random().toString(35);return r[t][i]=[e,!!n],i},this.unsubscribe=function(t){for(var e in r)if(r[e][t])return delete r[e][t],0===Object.keys(r[e]).length&&delete r[e],!0;return !1},this.publish=function(t){if(r.hasOwnProperty(t)){var i=Array.prototype.slice.call(arguments,1),o=[];for(var s in r[t]){var c=r[t][s];try{c[0].apply(e,i);}catch(t){n$1.console&&a$2.error("jsPDF PubSub Error",t.message,t);}c[1]&&o.push(s);}o.length&&o.forEach(this.unsubscribe);}},this.getTopics=function(){return r};}function j(t){if(!(this instanceof j))return new j(t);var e="opacity,stroke-opacity".split(",");for(var r in t)t.hasOwnProperty(r)&&e.indexOf(r)>=0&&(this[r]=t[r]);this.id="",this.objectNumber=-1;}function O$1(t,e){this.gState=t,this.matrix=e,this.id="",this.objectNumber=-1;}function B(t,e,r,n,i){if(!(this instanceof B))return new B(t,e,r,n,i);this.type="axial"===t?2:3,this.coords=e,this.colors=r,O$1.call(this,n,i);}function M(t,e,r,n,i){if(!(this instanceof M))return new M(t,e,r,n,i);this.boundingBox=t,this.xStep=e,this.yStep=r,this.stream="",this.cloneIndex=0,O$1.call(this,n,i);}function E$1(e){var r,i="string"==typeof arguments[0]?arguments[0]:"p",o=arguments[1],s=arguments[2],c=arguments[3],u=[],d=1,p=16,g="S",m=null;"object"===_typeof$2(e=e||{})&&(i=e.orientation,o=e.unit||o,s=e.format||s,c=e.compress||e.compressPdf||c,null!==(m=e.encryption||null)&&(m.userPassword=m.userPassword||"",m.ownerPassword=m.ownerPassword||"",m.userPermissions=m.userPermissions||[]),d="number"==typeof e.userUnit?Math.abs(e.userUnit):1,void 0!==e.precision&&(r=e.precision),void 0!==e.floatPrecision&&(p=e.floatPrecision),g=e.defaultPathOperation||"S"),u=e.filters||(!0===c?["FlateEncode"]:u),o=o||"mm",i=(""+(i||"P")).toLowerCase();var v=e.putOnlyUsedFonts||!1,b={},y={internal:{},__private__:{}};y.__private__.PubSub=C;var w="1.3",N=y.__private__.getPdfVersion=function(){return w};y.__private__.setPdfVersion=function(t){w=t;};var L={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};y.__private__.getPageFormats=function(){return L};var A=y.__private__.getPageFormat=function(t){return L[t]};s=s||"a4";var x={COMPAT:"compat",ADVANCED:"advanced"},S=x.COMPAT;function _(){this.saveGraphicsState(),lt(new Vt(_t,0,0,-_t,0,Rr()*_t).toString()+" cm"),this.setFontSize(this.getFontSize()/_t),g="n",S=x.ADVANCED;}function P(){this.restoreGraphicsState(),g="S",S=x.COMPAT;}var k=y.__private__.combineFontStyleAndFontWeight=function(t,e){if("bold"==t&&"normal"==e||"bold"==t&&400==e||"normal"==t&&"italic"==e||"bold"==t&&"italic"==e)throw new Error("Invalid Combination of fontweight and fontstyle");return e&&(t=400==e||"normal"===e?"italic"===t?"italic":"normal":700!=e&&"bold"!==e||"normal"!==t?(700==e?"bold":e)+""+t:"bold"),t};y.advancedAPI=function(t){var e=S===x.COMPAT;return e&&_.call(this),"function"!=typeof t||(t(this),e&&P.call(this)),this},y.compatAPI=function(t){var e=S===x.ADVANCED;return e&&P.call(this),"function"!=typeof t||(t(this),e&&_.call(this)),this},y.isAdvancedAPI=function(){return S===x.ADVANCED};var O,q=function(t){if(S!==x.ADVANCED)throw new Error(t+" is only available in 'advanced' API mode. You need to call advancedAPI() first.")},D=y.roundToPrecision=y.__private__.roundToPrecision=function(t,e){var n=r||e;if(isNaN(t)||isNaN(n))throw new Error("Invalid argument passed to jsPDF.roundToPrecision");return t.toFixed(n).replace(/0+$/,"")};O=y.hpf=y.__private__.hpf="number"==typeof p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,p)}:"smart"===p?function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,t>-1&&t<1?16:5)}:function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.hpf");return D(t,16)};var R=y.f2=y.__private__.f2=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f2");return D(t,2)},T=y.__private__.f3=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.f3");return D(t,3)},U=y.scale=y.__private__.scale=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.scale");return S===x.COMPAT?t*_t:S===x.ADVANCED?t:void 0},z=function(t){return S===x.COMPAT?Rr()-t:S===x.ADVANCED?t:void 0},H=function(t){return U(z(t))};y.__private__.setPrecision=y.setPrecision=function(t){"number"==typeof parseInt(t,10)&&(r=parseInt(t,10));};var W,V="00000000000000000000000000000000",G=y.__private__.getFileId=function(){return V},Y=y.__private__.setFileId=function(t){return V=void 0!==t&&/^[a-fA-F0-9]{32}$/.test(t)?t.toUpperCase():V.split("").map((function(){return "ABCDEF0123456789".charAt(Math.floor(16*Math.random()))})).join(""),null!==m&&(Ye=new I(m.userPermissions,m.userPassword,m.ownerPassword,V)),V};y.setFileId=function(t){return Y(t),this},y.getFileId=function(){return G()};var J=y.__private__.convertDateToPDFDate=function(t){var e=t.getTimezoneOffset(),r=e<0?"+":"-",n=Math.floor(Math.abs(e/60)),i=Math.abs(e%60),a=[r,Q(n),"'",Q(i),"'"].join("");return ["D:",t.getFullYear(),Q(t.getMonth()+1),Q(t.getDate()),Q(t.getHours()),Q(t.getMinutes()),Q(t.getSeconds()),a].join("")},X=y.__private__.convertPDFDateToDate=function(t){var e=parseInt(t.substr(2,4),10),r=parseInt(t.substr(6,2),10)-1,n=parseInt(t.substr(8,2),10),i=parseInt(t.substr(10,2),10),a=parseInt(t.substr(12,2),10),o=parseInt(t.substr(14,2),10);return new Date(e,r,n,i,a,o,0)},K=y.__private__.setCreationDate=function(t){var e;if(void 0===t&&(t=new Date),t instanceof Date)e=J(t);else {if(!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t))throw new Error("Invalid argument passed to jsPDF.setCreationDate");e=t;}return W=e},Z=y.__private__.getCreationDate=function(t){var e=W;return "jsDate"===t&&(e=X(W)),e};y.setCreationDate=function(t){return K(t),this},y.getCreationDate=function(t){return Z(t)};var $,Q=y.__private__.padd2=function(t){return ("0"+parseInt(t)).slice(-2)},tt=y.__private__.padd2Hex=function(t){return ("00"+(t=t.toString())).substr(t.length)},et=0,rt=[],nt=[],it=0,at=[],ot=[],st=!1,ct=nt,ut=function(){et=0,it=0,nt=[],rt=[],at=[],Qt=Kt(),te=Kt();};y.__private__.setCustomOutputDestination=function(t){st=!0,ct=t;};var ht=function(t){st||(ct=t);};y.__private__.resetCustomOutputDestination=function(){st=!1,ct=nt;};var lt=y.__private__.out=function(t){return t=t.toString(),it+=t.length+1,ct.push(t),ct},ft=y.__private__.write=function(t){return lt(1===arguments.length?t.toString():Array.prototype.join.call(arguments," "))},dt=y.__private__.getArrayBuffer=function(t){for(var e=t.length,r=new ArrayBuffer(e),n=new Uint8Array(r);e--;)n[e]=t.charCodeAt(e);return r},pt=[["Helvetica","helvetica","normal","WinAnsiEncoding"],["Helvetica-Bold","helvetica","bold","WinAnsiEncoding"],["Helvetica-Oblique","helvetica","italic","WinAnsiEncoding"],["Helvetica-BoldOblique","helvetica","bolditalic","WinAnsiEncoding"],["Courier","courier","normal","WinAnsiEncoding"],["Courier-Bold","courier","bold","WinAnsiEncoding"],["Courier-Oblique","courier","italic","WinAnsiEncoding"],["Courier-BoldOblique","courier","bolditalic","WinAnsiEncoding"],["Times-Roman","times","normal","WinAnsiEncoding"],["Times-Bold","times","bold","WinAnsiEncoding"],["Times-Italic","times","italic","WinAnsiEncoding"],["Times-BoldItalic","times","bolditalic","WinAnsiEncoding"],["ZapfDingbats","zapfdingbats","normal",null],["Symbol","symbol","normal",null]];y.__private__.getStandardFonts=function(){return pt};var gt=e.fontSize||16;y.__private__.setFontSize=y.setFontSize=function(t){return gt=S===x.ADVANCED?t/_t:t,this};var mt,vt=y.__private__.getFontSize=y.getFontSize=function(){return S===x.COMPAT?gt:gt*_t},bt=e.R2L||!1;y.__private__.setR2L=y.setR2L=function(t){return bt=t,this},y.__private__.getR2L=y.getR2L=function(){return bt};var yt,wt=y.__private__.setZoomMode=function(t){var e=[void 0,null,"fullwidth","fullheight","fullpage","original"];if(/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t))mt=t;else if(isNaN(t)){if(-1===e.indexOf(t))throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "'+t+'" is not recognized.');mt=t;}else mt=parseInt(t,10);};y.__private__.getZoomMode=function(){return mt};var Nt,Lt=y.__private__.setPageMode=function(t){if(-1==[void 0,null,"UseNone","UseOutlines","UseThumbs","FullScreen"].indexOf(t))throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "'+t+'" is not recognized.');yt=t;};y.__private__.getPageMode=function(){return yt};var At=y.__private__.setLayoutMode=function(t){if(-1==[void 0,null,"continuous","single","twoleft","tworight","two"].indexOf(t))throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "'+t+'" is not recognized.');Nt=t;};y.__private__.getLayoutMode=function(){return Nt},y.__private__.setDisplayMode=y.setDisplayMode=function(t,e,r){return wt(t),At(e),Lt(r),this};var xt={title:"",subject:"",author:"",keywords:"",creator:""};y.__private__.getDocumentProperty=function(t){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");return xt[t]},y.__private__.getDocumentProperties=function(){return xt},y.__private__.setDocumentProperties=y.setProperties=y.setDocumentProperties=function(t){for(var e in xt)xt.hasOwnProperty(e)&&t[e]&&(xt[e]=t[e]);return this},y.__private__.setDocumentProperty=function(t,e){if(-1===Object.keys(xt).indexOf(t))throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");return xt[t]=e};var St,_t,Pt,kt,It,Ft={},Ct={},jt=[],Ot={},Bt={},Mt={},Et={},qt=null,Dt=0,Rt=[],Tt=new C(y),Ut=e.hotfixes||[],zt={},Ht={},Wt=[],Vt=function t(e,r,n,i,a,o){if(!(this instanceof t))return new t(e,r,n,i,a,o);isNaN(e)&&(e=1),isNaN(r)&&(r=0),isNaN(n)&&(n=0),isNaN(i)&&(i=1),isNaN(a)&&(a=0),isNaN(o)&&(o=0),this._matrix=[e,r,n,i,a,o];};Object.defineProperty(Vt.prototype,"sx",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Vt.prototype,"shy",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Vt.prototype,"shx",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Vt.prototype,"sy",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Vt.prototype,"tx",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Vt.prototype,"ty",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Vt.prototype,"a",{get:function(){return this._matrix[0]},set:function(t){this._matrix[0]=t;}}),Object.defineProperty(Vt.prototype,"b",{get:function(){return this._matrix[1]},set:function(t){this._matrix[1]=t;}}),Object.defineProperty(Vt.prototype,"c",{get:function(){return this._matrix[2]},set:function(t){this._matrix[2]=t;}}),Object.defineProperty(Vt.prototype,"d",{get:function(){return this._matrix[3]},set:function(t){this._matrix[3]=t;}}),Object.defineProperty(Vt.prototype,"e",{get:function(){return this._matrix[4]},set:function(t){this._matrix[4]=t;}}),Object.defineProperty(Vt.prototype,"f",{get:function(){return this._matrix[5]},set:function(t){this._matrix[5]=t;}}),Object.defineProperty(Vt.prototype,"rotation",{get:function(){return Math.atan2(this.shx,this.sx)}}),Object.defineProperty(Vt.prototype,"scaleX",{get:function(){return this.decompose().scale.sx}}),Object.defineProperty(Vt.prototype,"scaleY",{get:function(){return this.decompose().scale.sy}}),Object.defineProperty(Vt.prototype,"isIdentity",{get:function(){return 1===this.sx&&(0===this.shy&&(0===this.shx&&(1===this.sy&&(0===this.tx&&0===this.ty))))}}),Vt.prototype.join=function(t){return [this.sx,this.shy,this.shx,this.sy,this.tx,this.ty].map(O).join(t)},Vt.prototype.multiply=function(t){var e=t.sx*this.sx+t.shy*this.shx,r=t.sx*this.shy+t.shy*this.sy,n=t.shx*this.sx+t.sy*this.shx,i=t.shx*this.shy+t.sy*this.sy,a=t.tx*this.sx+t.ty*this.shx+this.tx,o=t.tx*this.shy+t.ty*this.sy+this.ty;return new Vt(e,r,n,i,a,o)},Vt.prototype.decompose=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty,o=Math.sqrt(t*t+e*e),s=(t/=o)*r+(e/=o)*n;r-=t*s,n-=e*s;var c=Math.sqrt(r*r+n*n);return s/=c,t*(n/=c)<e*(r/=c)&&(t=-t,e=-e,s=-s,o=-o),{scale:new Vt(o,0,0,c,0,0),translate:new Vt(1,0,0,1,i,a),rotate:new Vt(t,e,-e,t,0,0),skew:new Vt(1,0,s,1,0,0)}},Vt.prototype.toString=function(t){return this.join(" ")},Vt.prototype.inversed=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty,o=1/(t*n-e*r),s=n*o,c=-e*o,u=-r*o,h=t*o;return new Vt(s,c,u,h,-s*i-u*a,-c*i-h*a)},Vt.prototype.applyToPoint=function(t){var e=t.x*this.sx+t.y*this.shx+this.tx,r=t.x*this.shy+t.y*this.sy+this.ty;return new Cr(e,r)},Vt.prototype.applyToRectangle=function(t){var e=this.applyToPoint(t),r=this.applyToPoint(new Cr(t.x+t.w,t.y+t.h));return new jr(e.x,e.y,r.x-e.x,r.y-e.y)},Vt.prototype.clone=function(){var t=this.sx,e=this.shy,r=this.shx,n=this.sy,i=this.tx,a=this.ty;return new Vt(t,e,r,n,i,a)},y.Matrix=Vt;var Gt=y.matrixMult=function(t,e){return e.multiply(t)},Yt=new Vt(1,0,0,1,0,0);y.unitMatrix=y.identityMatrix=Yt;var Jt=function(t,e){if(!Bt[t]){var r=(e instanceof B?"Sh":"P")+(Object.keys(Ot).length+1).toString(10);e.id=r,Bt[t]=r,Ot[r]=e,Tt.publish("addPattern",e);}};y.ShadingPattern=B,y.TilingPattern=M,y.addShadingPattern=function(t,e){return q("addShadingPattern()"),Jt(t,e),this},y.beginTilingPattern=function(t){q("beginTilingPattern()"),Br(t.boundingBox[0],t.boundingBox[1],t.boundingBox[2]-t.boundingBox[0],t.boundingBox[3]-t.boundingBox[1],t.matrix);},y.endTilingPattern=function(t,e){q("endTilingPattern()"),e.stream=ot[$].join("\n"),Jt(t,e),Tt.publish("endTilingPattern",e),Wt.pop().restore();};var Xt=y.__private__.newObject=function(){var t=Kt();return Zt(t,!0),t},Kt=y.__private__.newObjectDeferred=function(){return et++,rt[et]=function(){return it},et},Zt=function(t,e){return e="boolean"==typeof e&&e,rt[t]=it,e&&lt(t+" 0 obj"),t},$t=y.__private__.newAdditionalObject=function(){var t={objId:Kt(),content:""};return at.push(t),t},Qt=Kt(),te=Kt(),ee=y.__private__.decodeColorString=function(t){var e=t.split(" ");if(2!==e.length||"g"!==e[1]&&"G"!==e[1]){if(5===e.length&&("k"===e[4]||"K"===e[4])){e=[(1-e[0])*(1-e[3]),(1-e[1])*(1-e[3]),(1-e[2])*(1-e[3]),"r"];}}else {var r=parseFloat(e[0]);e=[r,r,r,"r"];}for(var n="#",i=0;i<3;i++)n+=("0"+Math.floor(255*parseFloat(e[i])).toString(16)).slice(-2);return n},re=y.__private__.encodeColorString=function(e){var r;"string"==typeof e&&(e={ch1:e});var n=e.ch1,i=e.ch2,a=e.ch3,o=e.ch4,s="draw"===e.pdfColorType?["G","RG","K"]:["g","rg","k"];if("string"==typeof n&&"#"!==n.charAt(0)){var c=new f$2(n);if(c.ok)n=c.toHex();else if(!/^\d*\.?\d*$/.test(n))throw new Error('Invalid color "'+n+'" passed to jsPDF.encodeColorString.')}if("string"==typeof n&&/^#[0-9A-Fa-f]{3}$/.test(n)&&(n="#"+n[1]+n[1]+n[2]+n[2]+n[3]+n[3]),"string"==typeof n&&/^#[0-9A-Fa-f]{6}$/.test(n)){var u=parseInt(n.substr(1),16);n=u>>16&255,i=u>>8&255,a=255&u;}if(void 0===i||void 0===o&&n===i&&i===a)if("string"==typeof n)r=n+" "+s[0];else switch(e.precision){case 2:r=R(n/255)+" "+s[0];break;case 3:default:r=T(n/255)+" "+s[0];}else if(void 0===o||"object"===_typeof$2(o)){if(o&&!isNaN(o.a)&&0===o.a)return r=["1.","1.","1.",s[1]].join(" ");if("string"==typeof n)r=[n,i,a,s[1]].join(" ");else switch(e.precision){case 2:r=[R(n/255),R(i/255),R(a/255),s[1]].join(" ");break;default:case 3:r=[T(n/255),T(i/255),T(a/255),s[1]].join(" ");}}else if("string"==typeof n)r=[n,i,a,o,s[2]].join(" ");else switch(e.precision){case 2:r=[R(n),R(i),R(a),R(o),s[2]].join(" ");break;case 3:default:r=[T(n),T(i),T(a),T(o),s[2]].join(" ");}return r},ne=y.__private__.getFilters=function(){return u},ie=y.__private__.putStream=function(t){var e=(t=t||{}).data||"",r=t.filters||ne(),n=t.alreadyAppliedFilters||[],i=t.addLength1||!1,a=e.length,o=t.objectId,s=function(t){return t};if(null!==m&&void 0===o)throw new Error("ObjectId must be passed to putStream for file encryption");null!==m&&(s=Ye.encryptor(o,0));var c={};!0===r&&(r=["FlateEncode"]);var u=t.additionalKeyValues||[],h=(c=void 0!==E$1.API.processDataByFilters?E$1.API.processDataByFilters(e,r):{data:e,reverseChain:[]}).reverseChain+(Array.isArray(n)?n.join(" "):n.toString());if(0!==c.data.length&&(u.push({key:"Length",value:c.data.length}),!0===i&&u.push({key:"Length1",value:a})),0!=h.length)if(h.split("/").length-1==1)u.push({key:"Filter",value:h});else {u.push({key:"Filter",value:"["+h+"]"});for(var l=0;l<u.length;l+=1)if("DecodeParms"===u[l].key){for(var f=[],d=0;d<c.reverseChain.split("/").length-1;d+=1)f.push("null");f.push(u[l].value),u[l].value="["+f.join(" ")+"]";}}lt("<<");for(var p=0;p<u.length;p++)lt("/"+u[p].key+" "+u[p].value);lt(">>"),0!==c.data.length&&(lt("stream"),lt(s(c.data)),lt("endstream"));},ae=y.__private__.putPage=function(t){var e=t.number,r=t.data,n=t.objId,i=t.contentsObjId;Zt(n,!0),lt("<</Type /Page"),lt("/Parent "+t.rootDictionaryObjId+" 0 R"),lt("/Resources "+t.resourceDictionaryObjId+" 0 R"),lt("/MediaBox ["+parseFloat(O(t.mediaBox.bottomLeftX))+" "+parseFloat(O(t.mediaBox.bottomLeftY))+" "+O(t.mediaBox.topRightX)+" "+O(t.mediaBox.topRightY)+"]"),null!==t.cropBox&&lt("/CropBox ["+O(t.cropBox.bottomLeftX)+" "+O(t.cropBox.bottomLeftY)+" "+O(t.cropBox.topRightX)+" "+O(t.cropBox.topRightY)+"]"),null!==t.bleedBox&&lt("/BleedBox ["+O(t.bleedBox.bottomLeftX)+" "+O(t.bleedBox.bottomLeftY)+" "+O(t.bleedBox.topRightX)+" "+O(t.bleedBox.topRightY)+"]"),null!==t.trimBox&&lt("/TrimBox ["+O(t.trimBox.bottomLeftX)+" "+O(t.trimBox.bottomLeftY)+" "+O(t.trimBox.topRightX)+" "+O(t.trimBox.topRightY)+"]"),null!==t.artBox&&lt("/ArtBox ["+O(t.artBox.bottomLeftX)+" "+O(t.artBox.bottomLeftY)+" "+O(t.artBox.topRightX)+" "+O(t.artBox.topRightY)+"]"),"number"==typeof t.userUnit&&1!==t.userUnit&&lt("/UserUnit "+t.userUnit),Tt.publish("putPage",{objId:n,pageContext:Rt[e],pageNumber:e,page:r}),lt("/Contents "+i+" 0 R"),lt(">>"),lt("endobj");var a=r.join("\n");return S===x.ADVANCED&&(a+="\nQ"),Zt(i,!0),ie({data:a,filters:ne(),objectId:i}),lt("endobj"),n},oe=y.__private__.putPages=function(){var t,e,r=[];for(t=1;t<=Dt;t++)Rt[t].objId=Kt(),Rt[t].contentsObjId=Kt();for(t=1;t<=Dt;t++)r.push(ae({number:t,data:ot[t],objId:Rt[t].objId,contentsObjId:Rt[t].contentsObjId,mediaBox:Rt[t].mediaBox,cropBox:Rt[t].cropBox,bleedBox:Rt[t].bleedBox,trimBox:Rt[t].trimBox,artBox:Rt[t].artBox,userUnit:Rt[t].userUnit,rootDictionaryObjId:Qt,resourceDictionaryObjId:te}));Zt(Qt,!0),lt("<</Type /Pages");var n="/Kids [";for(e=0;e<Dt;e++)n+=r[e]+" 0 R ";lt(n+"]"),lt("/Count "+Dt),lt(">>"),lt("endobj"),Tt.publish("postPutPages");},se=function(t){Tt.publish("putFont",{font:t,out:lt,newObject:Xt,putStream:ie}),!0!==t.isAlreadyPutted&&(t.objectNumber=Xt(),lt("<<"),lt("/Type /Font"),lt("/BaseFont /"+F$1(t.postScriptName)),lt("/Subtype /Type1"),"string"==typeof t.encoding&&lt("/Encoding /"+t.encoding),lt("/FirstChar 32"),lt("/LastChar 255"),lt(">>"),lt("endobj"));},ce=function(){for(var t in Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&se(Ft[t]);},ue=function(t){t.objectNumber=Xt();var e=[];e.push({key:"Type",value:"/XObject"}),e.push({key:"Subtype",value:"/Form"}),e.push({key:"BBox",value:"["+[O(t.x),O(t.y),O(t.x+t.width),O(t.y+t.height)].join(" ")+"]"}),e.push({key:"Matrix",value:"["+t.matrix.toString()+"]"});var r=t.pages[1].join("\n");ie({data:r,additionalKeyValues:e,objectId:t.objectNumber}),lt("endobj");},he=function(){for(var t in zt)zt.hasOwnProperty(t)&&ue(zt[t]);},le=function(t,e){var r,n=[],i=1/(e-1);for(r=0;r<1;r+=i)n.push(r);if(n.push(1),0!=t[0].offset){var a={offset:0,color:t[0].color};t.unshift(a);}if(1!=t[t.length-1].offset){var o={offset:1,color:t[t.length-1].color};t.push(o);}for(var s="",c=0,u=0;u<n.length;u++){for(r=n[u];r>t[c+1].offset;)c++;var h=t[c].offset,l=(r-h)/(t[c+1].offset-h),f=t[c].color,d=t[c+1].color;s+=tt(Math.round((1-l)*f[0]+l*d[0]).toString(16))+tt(Math.round((1-l)*f[1]+l*d[1]).toString(16))+tt(Math.round((1-l)*f[2]+l*d[2]).toString(16));}return s.trim()},fe=function(t,e){e||(e=21);var r=Xt(),n=le(t.colors,e),i=[];i.push({key:"FunctionType",value:"0"}),i.push({key:"Domain",value:"[0.0 1.0]"}),i.push({key:"Size",value:"["+e+"]"}),i.push({key:"BitsPerSample",value:"8"}),i.push({key:"Range",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),i.push({key:"Decode",value:"[0.0 1.0 0.0 1.0 0.0 1.0]"}),ie({data:n,additionalKeyValues:i,alreadyAppliedFilters:["/ASCIIHexDecode"],objectId:r}),lt("endobj"),t.objectNumber=Xt(),lt("<< /ShadingType "+t.type),lt("/ColorSpace /DeviceRGB");var a="/Coords ["+O(parseFloat(t.coords[0]))+" "+O(parseFloat(t.coords[1]))+" ";2===t.type?a+=O(parseFloat(t.coords[2]))+" "+O(parseFloat(t.coords[3])):a+=O(parseFloat(t.coords[2]))+" "+O(parseFloat(t.coords[3]))+" "+O(parseFloat(t.coords[4]))+" "+O(parseFloat(t.coords[5])),lt(a+="]"),t.matrix&&lt("/Matrix ["+t.matrix.toString()+"]"),lt("/Function "+r+" 0 R"),lt("/Extend [true true]"),lt(">>"),lt("endobj");},de=function(t,e){var r=Kt(),n=Xt();e.push({resourcesOid:r,objectOid:n}),t.objectNumber=n;var i=[];i.push({key:"Type",value:"/Pattern"}),i.push({key:"PatternType",value:"1"}),i.push({key:"PaintType",value:"1"}),i.push({key:"TilingType",value:"1"}),i.push({key:"BBox",value:"["+t.boundingBox.map(O).join(" ")+"]"}),i.push({key:"XStep",value:O(t.xStep)}),i.push({key:"YStep",value:O(t.yStep)}),i.push({key:"Resources",value:r+" 0 R"}),t.matrix&&i.push({key:"Matrix",value:"["+t.matrix.toString()+"]"}),ie({data:t.stream,additionalKeyValues:i,objectId:t.objectNumber}),lt("endobj");},pe=function(t){var e;for(e in Ot)Ot.hasOwnProperty(e)&&(Ot[e]instanceof B?fe(Ot[e]):Ot[e]instanceof M&&de(Ot[e],t));},ge=function(t){for(var e in t.objectNumber=Xt(),lt("<<"),t)switch(e){case"opacity":lt("/ca "+R(t[e]));break;case"stroke-opacity":lt("/CA "+R(t[e]));}lt(">>"),lt("endobj");},me=function(){var t;for(t in Mt)Mt.hasOwnProperty(t)&&ge(Mt[t]);},ve=function(){for(var t in lt("/XObject <<"),zt)zt.hasOwnProperty(t)&&zt[t].objectNumber>=0&&lt("/"+t+" "+zt[t].objectNumber+" 0 R");Tt.publish("putXobjectDict"),lt(">>");},be=function(){Ye.oid=Xt(),lt("<<"),lt("/Filter /Standard"),lt("/V "+Ye.v),lt("/R "+Ye.r),lt("/U <"+Ye.toHexString(Ye.U)+">"),lt("/O <"+Ye.toHexString(Ye.O)+">"),lt("/P "+Ye.P),lt(">>"),lt("endobj");},ye=function(){for(var t in lt("/Font <<"),Ft)Ft.hasOwnProperty(t)&&(!1===v||!0===v&&b.hasOwnProperty(t))&&lt("/"+t+" "+Ft[t].objectNumber+" 0 R");lt(">>");},we=function(){if(Object.keys(Ot).length>0){for(var t in lt("/Shading <<"),Ot)Ot.hasOwnProperty(t)&&Ot[t]instanceof B&&Ot[t].objectNumber>=0&&lt("/"+t+" "+Ot[t].objectNumber+" 0 R");Tt.publish("putShadingPatternDict"),lt(">>");}},Ne=function(t){if(Object.keys(Ot).length>0){for(var e in lt("/Pattern <<"),Ot)Ot.hasOwnProperty(e)&&Ot[e]instanceof y.TilingPattern&&Ot[e].objectNumber>=0&&Ot[e].objectNumber<t&&lt("/"+e+" "+Ot[e].objectNumber+" 0 R");Tt.publish("putTilingPatternDict"),lt(">>");}},Le=function(){if(Object.keys(Mt).length>0){var t;for(t in lt("/ExtGState <<"),Mt)Mt.hasOwnProperty(t)&&Mt[t].objectNumber>=0&&lt("/"+t+" "+Mt[t].objectNumber+" 0 R");Tt.publish("putGStateDict"),lt(">>");}},Ae=function(t){Zt(t.resourcesOid,!0),lt("<<"),lt("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"),ye(),we(),Ne(t.objectOid),Le(),ve(),lt(">>"),lt("endobj");},xe=function(){var t=[];ce(),me(),he(),pe(t),Tt.publish("putResources"),t.forEach(Ae),Ae({resourcesOid:te,objectOid:Number.MAX_SAFE_INTEGER}),Tt.publish("postPutResources");},Se=function(){Tt.publish("putAdditionalObjects");for(var t=0;t<at.length;t++){var e=at[t];Zt(e.objId,!0),lt(e.content),lt("endobj");}Tt.publish("postPutAdditionalObjects");},_e=function(t){Ct[t.fontName]=Ct[t.fontName]||{},Ct[t.fontName][t.fontStyle]=t.id;},Pe=function(t,e,r,n,i){var a={id:"F"+(Object.keys(Ft).length+1).toString(10),postScriptName:t,fontName:e,fontStyle:r,encoding:n,isStandardFont:i||!1,metadata:{}};return Tt.publish("addFont",{font:a,instance:this}),Ft[a.id]=a,_e(a),a.id},ke=function(t){for(var e=0,r=pt.length;e<r;e++){var n=Pe.call(this,t[e][0],t[e][1],t[e][2],pt[e][3],!0);!1===v&&(b[n]=!0);var i=t[e][0].split("-");_e({id:n,fontName:i[0],fontStyle:i[1]||""});}Tt.publish("addFonts",{fonts:Ft,dictionary:Ct});},Ie=function(t){return t.foo=function(){try{return t.apply(this,arguments)}catch(t){var e=t.stack||"";~e.indexOf(" at ")&&(e=e.split(" at ")[1]);var r="Error in function "+e.split("\n")[0].split("<")[0]+": "+t.message;if(!n$1.console)throw new Error(r);n$1.console.error(r,t),n$1.alert&&alert(r);}},t.foo.bar=t,t.foo},Fe=function(t,e){var r,n,i,a,o,s,c,u,h;if(i=(e=e||{}).sourceEncoding||"Unicode",o=e.outputEncoding,(e.autoencode||o)&&Ft[St].metadata&&Ft[St].metadata[i]&&Ft[St].metadata[i].encoding&&(a=Ft[St].metadata[i].encoding,!o&&Ft[St].encoding&&(o=Ft[St].encoding),!o&&a.codePages&&(o=a.codePages[0]),"string"==typeof o&&(o=a[o]),o)){for(c=!1,s=[],r=0,n=t.length;r<n;r++)(u=o[t.charCodeAt(r)])?s.push(String.fromCharCode(u)):s.push(t[r]),s[r].charCodeAt(0)>>8&&(c=!0);t=s.join("");}for(r=t.length;void 0===c&&0!==r;)t.charCodeAt(r-1)>>8&&(c=!0),r--;if(!c)return t;for(s=e.noBOM?[]:[254,255],r=0,n=t.length;r<n;r++){if((h=(u=t.charCodeAt(r))>>8)>>8)throw new Error("Character at position "+r+" of string '"+t+"' exceeds 16bits. Cannot be encoded into UCS-2 BE");s.push(h),s.push(u-(h<<8));}return String.fromCharCode.apply(void 0,s)},Ce=y.__private__.pdfEscape=y.pdfEscape=function(t,e){return Fe(t,e).replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},je=y.__private__.beginPage=function(t){ot[++Dt]=[],Rt[Dt]={objId:0,contentsObjId:0,userUnit:Number(d),artBox:null,bleedBox:null,cropBox:null,trimBox:null,mediaBox:{bottomLeftX:0,bottomLeftY:0,topRightX:Number(t[0]),topRightY:Number(t[1])}},Me(Dt),ht(ot[$]);},Oe=function(t,e){var r,n,o;switch(i=e||i,"string"==typeof t&&(r=A(t.toLowerCase()),Array.isArray(r)&&(n=r[0],o=r[1])),Array.isArray(t)&&(n=t[0]*_t,o=t[1]*_t),isNaN(n)&&(n=s[0],o=s[1]),(n>14400||o>14400)&&(a$2.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"),n=Math.min(14400,n),o=Math.min(14400,o)),s=[n,o],i.substr(0,1)){case"l":o>n&&(s=[o,n]);break;case"p":n>o&&(s=[o,n]);}je(s),pr(fr),lt(Lr),0!==kr&&lt(kr+" J"),0!==Ir&&lt(Ir+" j"),Tt.publish("addPage",{pageNumber:Dt});},Be=function(t){t>0&&t<=Dt&&(ot.splice(t,1),Rt.splice(t,1),Dt--,$>Dt&&($=Dt),this.setPage($));},Me=function(t){t>0&&t<=Dt&&($=t);},Ee=y.__private__.getNumberOfPages=y.getNumberOfPages=function(){return ot.length-1},qe=function(t,e,r){var n,i=void 0;return r=r||{},t=void 0!==t?t:Ft[St].fontName,e=void 0!==e?e:Ft[St].fontStyle,n=t.toLowerCase(),void 0!==Ct[n]&&void 0!==Ct[n][e]?i=Ct[n][e]:void 0!==Ct[t]&&void 0!==Ct[t][e]?i=Ct[t][e]:!1===r.disableWarning&&a$2.warn("Unable to look up font label for font '"+t+"', '"+e+"'. Refer to getFontList() for available fonts."),i||r.noFallback||null==(i=Ct.times[e])&&(i=Ct.times.normal),i},De=y.__private__.putInfo=function(){var t=Xt(),e=function(t){return t};for(var r in null!==m&&(e=Ye.encryptor(t,0)),lt("<<"),lt("/Producer ("+Ce(e("jsPDF "+E$1.version))+")"),xt)xt.hasOwnProperty(r)&&xt[r]&&lt("/"+r.substr(0,1).toUpperCase()+r.substr(1)+" ("+Ce(e(xt[r]))+")");lt("/CreationDate ("+Ce(e(W))+")"),lt(">>"),lt("endobj");},Re=y.__private__.putCatalog=function(t){var e=(t=t||{}).rootDictionaryObjId||Qt;switch(Xt(),lt("<<"),lt("/Type /Catalog"),lt("/Pages "+e+" 0 R"),mt||(mt="fullwidth"),mt){case"fullwidth":lt("/OpenAction [3 0 R /FitH null]");break;case"fullheight":lt("/OpenAction [3 0 R /FitV null]");break;case"fullpage":lt("/OpenAction [3 0 R /Fit]");break;case"original":lt("/OpenAction [3 0 R /XYZ null null 1]");break;default:var r=""+mt;"%"===r.substr(r.length-1)&&(mt=parseInt(mt)/100),"number"==typeof mt&&lt("/OpenAction [3 0 R /XYZ null null "+R(mt)+"]");}switch(Nt||(Nt="continuous"),Nt){case"continuous":lt("/PageLayout /OneColumn");break;case"single":lt("/PageLayout /SinglePage");break;case"two":case"twoleft":lt("/PageLayout /TwoColumnLeft");break;case"tworight":lt("/PageLayout /TwoColumnRight");}yt&&lt("/PageMode /"+yt),Tt.publish("putCatalog"),lt(">>"),lt("endobj");},Te=y.__private__.putTrailer=function(){lt("trailer"),lt("<<"),lt("/Size "+(et+1)),lt("/Root "+et+" 0 R"),lt("/Info "+(et-1)+" 0 R"),null!==m&&lt("/Encrypt "+Ye.oid+" 0 R"),lt("/ID [ <"+V+"> <"+V+"> ]"),lt(">>");},Ue=y.__private__.putHeader=function(){lt("%PDF-"+w),lt("%ºß¬à");},ze=y.__private__.putXRef=function(){var t="0000000000";lt("xref"),lt("0 "+(et+1)),lt("0000000000 65535 f ");for(var e=1;e<=et;e++){"function"==typeof rt[e]?lt((t+rt[e]()).slice(-10)+" 00000 n "):void 0!==rt[e]?lt((t+rt[e]).slice(-10)+" 00000 n "):lt("0000000000 00000 n ");}},He=y.__private__.buildDocument=function(){ut(),ht(nt),Tt.publish("buildDocument"),Ue(),oe(),Se(),xe(),null!==m&&be(),De(),Re();var t=it;return ze(),Te(),lt("startxref"),lt(""+t),lt("%%EOF"),ht(ot[$]),nt.join("\n")},We=y.__private__.getBlob=function(t){return new Blob([dt(t)],{type:"application/pdf"})},Ve=y.output=y.__private__.output=Ie((function(t,e){switch("string"==typeof(e=e||{})?e={filename:e}:e.filename=e.filename||"generated.pdf",t){case void 0:return He();case"save":y.save(e.filename);break;case"arraybuffer":return dt(He());case"blob":return We(He());case"bloburi":case"bloburl":if(void 0!==n$1.URL&&"function"==typeof n$1.URL.createObjectURL)return n$1.URL&&n$1.URL.createObjectURL(We(He()))||void 0;a$2.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");break;case"datauristring":case"dataurlstring":var r="",i=He();try{r=h$1(i);}catch(t){r=h$1(unescape(encodeURIComponent(i)));}return "data:application/pdf;filename="+e.filename+";base64,"+r;case"pdfobjectnewwindow":if("[object Window]"===Object.prototype.toString.call(n$1)){var o="https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js",s=' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';e.pdfObjectUrl&&(o=e.pdfObjectUrl,s="");var c='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="'+o+'"'+s+'><\/script><script >PDFObject.embed("'+this.output("dataurlstring")+'", '+JSON.stringify(e)+");<\/script></body></html>",u=n$1.open();return null!==u&&u.document.write(c),u}throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");case"pdfjsnewwindow":if("[object Window]"===Object.prototype.toString.call(n$1)){var l='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="'+(e.pdfJsUrl||"examples/PDF.js/web/viewer.html")+"?file=&downloadName="+e.filename+'" width="500px" height="400px" /></body></html>',f=n$1.open();if(null!==f){f.document.write(l);var d=this;f.document.documentElement.querySelector("#pdfViewer").onload=function(){f.document.title=e.filename,f.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d.output("bloburl"));};}return f}throw new Error("The option pdfjsnewwindow just works in a browser-environment.");case"dataurlnewwindow":if("[object Window]"!==Object.prototype.toString.call(n$1))throw new Error("The option dataurlnewwindow just works in a browser-environment.");var p='<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="'+this.output("datauristring",e)+'"></iframe></body></html>',g=n$1.open();if(null!==g&&(g.document.write(p),g.document.title=e.filename),g||"undefined"==typeof safari)return g;break;case"datauri":case"dataurl":return n$1.document.location.href=this.output("datauristring",e);default:return null}})),Ge=function(t){return !0===Array.isArray(Ut)&&Ut.indexOf(t)>-1};switch(o){case"pt":_t=1;break;case"mm":_t=72/25.4;break;case"cm":_t=72/2.54;break;case"in":_t=72;break;case"px":_t=1==Ge("px_scaling")?.75:96/72;break;case"pc":case"em":_t=12;break;case"ex":_t=6;break;default:if("number"!=typeof o)throw new Error("Invalid unit: "+o);_t=o;}var Ye=null;K(),Y();var Je=function(t){return null!==m?Ye.encryptor(t,0):function(t){return t}},Xe=y.__private__.getPageInfo=y.getPageInfo=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfo");return {objId:Rt[t].objId,pageNumber:t,pageContext:Rt[t]}},Ke=y.__private__.getPageInfoByObjId=function(t){if(isNaN(t)||t%1!=0)throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");for(var e in Rt)if(Rt[e].objId===t)break;return Xe(e)},Ze=y.__private__.getCurrentPageInfo=y.getCurrentPageInfo=function(){return {objId:Rt[$].objId,pageNumber:$,pageContext:Rt[$]}};y.addPage=function(){return Oe.apply(this,arguments),this},y.setPage=function(){return Me.apply(this,arguments),ht.call(this,ot[$]),this},y.insertPage=function(t){return this.addPage(),this.movePage($,t),this},y.movePage=function(t,e){var r,n;if(t>e){r=ot[t],n=Rt[t];for(var i=t;i>e;i--)ot[i]=ot[i-1],Rt[i]=Rt[i-1];ot[e]=r,Rt[e]=n,this.setPage(e);}else if(t<e){r=ot[t],n=Rt[t];for(var a=t;a<e;a++)ot[a]=ot[a+1],Rt[a]=Rt[a+1];ot[e]=r,Rt[e]=n,this.setPage(e);}return this},y.deletePage=function(){return Be.apply(this,arguments),this},y.__private__.text=y.text=function(e,r,n,i,a){var o,s,c,u,h,l,f,d,p,g=(i=i||{}).scope||this;if("number"==typeof e&&"number"==typeof r&&("string"==typeof n||Array.isArray(n))){var m=n;n=r,r=e,e=m;}if(arguments[3]instanceof Vt==!1?(c=arguments[4],u=arguments[5],"object"===_typeof$2(f=arguments[3])&&null!==f||("string"==typeof c&&(u=c,c=null),"string"==typeof f&&(u=f,f=null),"number"==typeof f&&(c=f,f=null),i={flags:f,angle:c,align:u})):(q("The transform parameter of text() with a Matrix value"),p=a),isNaN(r)||isNaN(n)||null==e)throw new Error("Invalid arguments passed to jsPDF.text");if(0===e.length)return g;var v="",y=!1,w="number"==typeof i.lineHeightFactor?i.lineHeightFactor:lr,N=g.internal.scaleFactor;function L(t){return t=t.split("\t").join(Array(i.TabLen||9).join(" ")),Ce(t,f)}function A(t){for(var e,r=t.concat(),n=[],i=r.length;i--;)"string"==typeof(e=r.shift())?n.push(e):Array.isArray(t)&&(1===e.length||void 0===e[1]&&void 0===e[2])?n.push(e[0]):n.push([e[0],e[1],e[2]]);return n}function _(t,e){var r;if("string"==typeof t)r=e(t)[0];else if(Array.isArray(t)){for(var n,i,a=t.concat(),o=[],s=a.length;s--;)"string"==typeof(n=a.shift())?o.push(e(n)[0]):Array.isArray(n)&&"string"==typeof n[0]&&(i=e(n[0],n[1],n[2]),o.push([i[0],i[1],i[2]]));r=o;}return r}var P=!1,k=!0;if("string"==typeof e)P=!0;else if(Array.isArray(e)){var I=e.concat();s=[];for(var F,C=I.length;C--;)("string"!=typeof(F=I.shift())||Array.isArray(F)&&"string"!=typeof F[0])&&(k=!1);P=k;}if(!1===P)throw new Error('Type of text must be string or Array. "'+e+'" is not recognized.');"string"==typeof e&&(e=e.match(/[\r?\n]/)?e.split(/\r\n|\r|\n/g):[e]);var j=gt/g.internal.scaleFactor,B=j*(w-1);switch(i.baseline){case"bottom":n-=B;break;case"top":n+=j-B;break;case"hanging":n+=j-2*B;break;case"middle":n+=j/2-B;}if((l=i.maxWidth||0)>0&&("string"==typeof e?e=g.splitTextToSize(e,l):"[object Array]"===Object.prototype.toString.call(e)&&(e=e.reduce((function(t,e){return t.concat(g.splitTextToSize(e,l))}),[]))),o={text:e,x:r,y:n,options:i,mutex:{pdfEscape:Ce,activeFontKey:St,fonts:Ft,activeFontSize:gt}},Tt.publish("preProcessText",o),e=o.text,c=(i=o.options).angle,p instanceof Vt==!1&&c&&"number"==typeof c){c*=Math.PI/180,0===i.rotationDirection&&(c=-c),S===x.ADVANCED&&(c=-c);var M=Math.cos(c),E=Math.sin(c);p=new Vt(M,E,-E,M,0,0);}else c&&c instanceof Vt&&(p=c);S!==x.ADVANCED||p||(p=Yt),void 0!==(h=i.charSpace||_r)&&(v+=O(U(h))+" Tc\n",this.setCharSpace(this.getCharSpace()||0)),void 0!==(d=i.horizontalScale)&&(v+=O(100*d)+" Tz\n");i.lang;var D=-1,R=void 0!==i.renderingMode?i.renderingMode:i.stroke,T=g.internal.getCurrentPageInfo().pageContext;switch(R){case 0:case!1:case"fill":D=0;break;case 1:case!0:case"stroke":D=1;break;case 2:case"fillThenStroke":D=2;break;case 3:case"invisible":D=3;break;case 4:case"fillAndAddForClipping":D=4;break;case 5:case"strokeAndAddPathForClipping":D=5;break;case 6:case"fillThenStrokeAndAddToPathForClipping":D=6;break;case 7:case"addToPathForClipping":D=7;}var z=void 0!==T.usedRenderingMode?T.usedRenderingMode:-1;-1!==D?v+=D+" Tr\n":-1!==z&&(v+="0 Tr\n"),-1!==D&&(T.usedRenderingMode=D),u=i.align||"left";var H,W=gt*w,V=g.internal.pageSize.getWidth(),G=Ft[St];h=i.charSpace||_r,l=i.maxWidth||0,f=Object.assign({autoencode:!0,noBOM:!0},i.flags);var Y=[];if("[object Array]"===Object.prototype.toString.call(e)){var J;s=A(e),"left"!==u&&(H=s.map((function(t){return g.getStringUnitWidth(t,{font:G,charSpace:h,fontSize:gt,doKerning:!1})*gt/N})));var X,K=0;if("right"===u){r-=H[0],e=[],C=s.length;for(var Z=0;Z<C;Z++)0===Z?(X=br(r),J=yr(n)):(X=U(K-H[Z]),J=-W),e.push([s[Z],X,J]),K=H[Z];}else if("center"===u){r-=H[0]/2,e=[],C=s.length;for(var $=0;$<C;$++)0===$?(X=br(r),J=yr(n)):(X=U((K-H[$])/2),J=-W),e.push([s[$],X,J]),K=H[$];}else if("left"===u){e=[],C=s.length;for(var Q=0;Q<C;Q++)e.push(s[Q]);}else {if("justify"!==u)throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');e=[],C=s.length,l=0!==l?l:V;for(var tt=0;tt<C;tt++)J=0===tt?yr(n):-W,X=0===tt?br(r):0,tt<C-1?Y.push(O(U((l-H[tt])/(s[tt].split(" ").length-1)))):Y.push(0),e.push([s[tt],X,J]);}}var et="boolean"==typeof i.R2L?i.R2L:bt;!0===et&&(e=_(e,(function(t,e,r){return [t.split("").reverse().join(""),e,r]}))),o={text:e,x:r,y:n,options:i,mutex:{pdfEscape:Ce,activeFontKey:St,fonts:Ft,activeFontSize:gt}},Tt.publish("postProcessText",o),e=o.text,y=o.mutex.isHex||!1;var rt=Ft[St].encoding;"WinAnsiEncoding"!==rt&&"StandardEncoding"!==rt||(e=_(e,(function(t,e,r){return [L(t),e,r]}))),s=A(e),e=[];for(var nt,it,at,ot=0,st=1,ct=Array.isArray(s[0])?st:ot,ut="",ht=function(t,e,r){var n="";return r instanceof Vt?(r="number"==typeof i.angle?Gt(r,new Vt(1,0,0,1,t,e)):Gt(new Vt(1,0,0,1,t,e),r),S===x.ADVANCED&&(r=Gt(new Vt(1,0,0,-1,0,0),r)),n=r.join(" ")+" Tm\n"):n=O(t)+" "+O(e)+" Td\n",n},ft=0;ft<s.length;ft++){switch(ut="",ct){case st:at=(y?"<":"(")+s[ft][0]+(y?">":")"),nt=parseFloat(s[ft][1]),it=parseFloat(s[ft][2]);break;case ot:at=(y?"<":"(")+s[ft]+(y?">":")"),nt=br(r),it=yr(n);}void 0!==Y&&void 0!==Y[ft]&&(ut=Y[ft]+" Tw\n"),0===ft?e.push(ut+ht(nt,it,p)+at):ct===ot?e.push(ut+at):ct===st&&e.push(ut+ht(nt,it,p)+at);}e=ct===ot?e.join(" Tj\nT* "):e.join(" Tj\n"),e+=" Tj\n";var dt="BT\n/";return dt+=St+" "+gt+" Tf\n",dt+=O(gt*w)+" TL\n",dt+=xr+"\n",dt+=v,dt+=e,lt(dt+="ET"),b[St]=!0,g};var $e=y.__private__.clip=y.clip=function(t){return lt("evenodd"===t?"W*":"W"),this};y.clipEvenOdd=function(){return $e("evenodd")},y.__private__.discardPath=y.discardPath=function(){return lt("n"),this};var Qe=y.__private__.isValidStyle=function(t){var e=!1;return -1!==[void 0,null,"S","D","F","DF","FD","f","f*","B","B*","n"].indexOf(t)&&(e=!0),e};y.__private__.setDefaultPathOperation=y.setDefaultPathOperation=function(t){return Qe(t)&&(g=t),this};var tr=y.__private__.getStyle=y.getStyle=function(t){var e=g;switch(t){case"D":case"S":e="S";break;case"F":e="f";break;case"FD":case"DF":e="B";break;case"f":case"f*":case"B":case"B*":e=t;}return e},er=y.close=function(){return lt("h"),this};y.stroke=function(){return lt("S"),this},y.fill=function(t){return rr("f",t),this},y.fillEvenOdd=function(t){return rr("f*",t),this},y.fillStroke=function(t){return rr("B",t),this},y.fillStrokeEvenOdd=function(t){return rr("B*",t),this};var rr=function(e,r){"object"===_typeof$2(r)?ar(r,e):lt(e);},nr=function(t){null===t||S===x.ADVANCED&&void 0===t||(t=tr(t),lt(t));};function ir(t,e,r,n,i){var a=new M(e||this.boundingBox,r||this.xStep,n||this.yStep,this.gState,i||this.matrix);a.stream=this.stream;var o=t+"$$"+this.cloneIndex+++"$$";return Jt(o,a),a}var ar=function(t,e){var r=Bt[t.key],n=Ot[r];if(n instanceof B)lt("q"),lt(or(e)),n.gState&&y.setGState(n.gState),lt(t.matrix.toString()+" cm"),lt("/"+r+" sh"),lt("Q");else if(n instanceof M){var i=new Vt(1,0,0,-1,0,Rr());t.matrix&&(i=i.multiply(t.matrix||Yt),r=ir.call(n,t.key,t.boundingBox,t.xStep,t.yStep,i).id),lt("q"),lt("/Pattern cs"),lt("/"+r+" scn"),n.gState&&y.setGState(n.gState),lt(e),lt("Q");}},or=function(t){switch(t){case"f":case"F":return "W n";case"f*":return "W* n";case"B":return "W S";case"B*":return "W* S";case"S":return "W S";case"n":return "W n"}},sr=y.moveTo=function(t,e){return lt(O(U(t))+" "+O(H(e))+" m"),this},cr=y.lineTo=function(t,e){return lt(O(U(t))+" "+O(H(e))+" l"),this},ur=y.curveTo=function(t,e,r,n,i,a){return lt([O(U(t)),O(H(e)),O(U(r)),O(H(n)),O(U(i)),O(H(a)),"c"].join(" ")),this};y.__private__.line=y.line=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.line");return S===x.COMPAT?this.lines([[r-t,n-e]],t,e,[1,1],i||"S"):this.lines([[r-t,n-e]],t,e,[1,1]).stroke()},y.__private__.lines=y.lines=function(t,e,r,n,i,a){var o,s,c,u,h,l,f,d,p,g,m,v;if("number"==typeof t&&(v=r,r=e,e=t,t=v),n=n||[1,1],a=a||!1,isNaN(e)||isNaN(r)||!Array.isArray(t)||!Array.isArray(n)||!Qe(i)||"boolean"!=typeof a)throw new Error("Invalid arguments passed to jsPDF.lines");for(sr(e,r),o=n[0],s=n[1],u=t.length,g=e,m=r,c=0;c<u;c++)2===(h=t[c]).length?(g=h[0]*o+g,m=h[1]*s+m,cr(g,m)):(l=h[0]*o+g,f=h[1]*s+m,d=h[2]*o+g,p=h[3]*s+m,g=h[4]*o+g,m=h[5]*s+m,ur(l,f,d,p,g,m));return a&&er(),nr(i),this},y.path=function(t){for(var e=0;e<t.length;e++){var r=t[e],n=r.c;switch(r.op){case"m":sr(n[0],n[1]);break;case"l":cr(n[0],n[1]);break;case"c":ur.apply(this,n);break;case"h":er();}}return this},y.__private__.rect=y.rect=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.rect");return S===x.COMPAT&&(n=-n),lt([O(U(t)),O(H(e)),O(U(r)),O(U(n)),"re"].join(" ")),nr(i),this},y.__private__.triangle=y.triangle=function(t,e,r,n,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(a)||!Qe(o))throw new Error("Invalid arguments passed to jsPDF.triangle");return this.lines([[r-t,n-e],[i-r,a-n],[t-i,e-a]],t,e,[1,1],o,!0),this},y.__private__.roundedRect=y.roundedRect=function(t,e,r,n,i,a,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(a)||!Qe(o))throw new Error("Invalid arguments passed to jsPDF.roundedRect");var s=4/3*(Math.SQRT2-1);return i=Math.min(i,.5*r),a=Math.min(a,.5*n),this.lines([[r-2*i,0],[i*s,0,i,a-a*s,i,a],[0,n-2*a],[0,a*s,-i*s,a,-i,a],[2*i-r,0],[-i*s,0,-i,-a*s,-i,-a],[0,2*a-n],[0,-a*s,i*s,-a,i,-a]],t+i,e,[1,1],o,!0),this},y.__private__.ellipse=y.ellipse=function(t,e,r,n,i){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||!Qe(i))throw new Error("Invalid arguments passed to jsPDF.ellipse");var a=4/3*(Math.SQRT2-1)*r,o=4/3*(Math.SQRT2-1)*n;return sr(t+r,e),ur(t+r,e-o,t+a,e-n,t,e-n),ur(t-a,e-n,t-r,e-o,t-r,e),ur(t-r,e+o,t-a,e+n,t,e+n),ur(t+a,e+n,t+r,e+o,t+r,e),nr(i),this},y.__private__.circle=y.circle=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||!Qe(n))throw new Error("Invalid arguments passed to jsPDF.circle");return this.ellipse(t,e,r,r,n)},y.setFont=function(t,e,r){return r&&(e=k(e,r)),St=qe(t,e,{disableWarning:!1}),this};var hr=y.__private__.getFont=y.getFont=function(){return Ft[qe.apply(y,arguments)]};y.__private__.getFontList=y.getFontList=function(){var t,e,r={};for(t in Ct)if(Ct.hasOwnProperty(t))for(e in r[t]=[],Ct[t])Ct[t].hasOwnProperty(e)&&r[t].push(e);return r},y.addFont=function(t,e,r,n,i){var a=["StandardEncoding","MacRomanEncoding","Identity-H","WinAnsiEncoding"];return arguments[3]&&-1!==a.indexOf(arguments[3])?i=arguments[3]:arguments[3]&&-1==a.indexOf(arguments[3])&&(r=k(r,n)),i=i||"Identity-H",Pe.call(this,t,e,r,i)};var lr,fr=e.lineWidth||.200025,dr=y.__private__.getLineWidth=y.getLineWidth=function(){return fr},pr=y.__private__.setLineWidth=y.setLineWidth=function(t){return fr=t,lt(O(U(t))+" w"),this};y.__private__.setLineDash=E$1.API.setLineDash=E$1.API.setLineDashPattern=function(t,e){if(t=t||[],e=e||0,isNaN(e)||!Array.isArray(t))throw new Error("Invalid arguments passed to jsPDF.setLineDash");return t=t.map((function(t){return O(U(t))})).join(" "),e=O(U(e)),lt("["+t+"] "+e+" d"),this};var gr=y.__private__.getLineHeight=y.getLineHeight=function(){return gt*lr};y.__private__.getLineHeight=y.getLineHeight=function(){return gt*lr};var mr=y.__private__.setLineHeightFactor=y.setLineHeightFactor=function(t){return "number"==typeof(t=t||1.15)&&(lr=t),this},vr=y.__private__.getLineHeightFactor=y.getLineHeightFactor=function(){return lr};mr(e.lineHeight);var br=y.__private__.getHorizontalCoordinate=function(t){return U(t)},yr=y.__private__.getVerticalCoordinate=function(t){return S===x.ADVANCED?t:Rt[$].mediaBox.topRightY-Rt[$].mediaBox.bottomLeftY-U(t)},wr=y.__private__.getHorizontalCoordinateString=y.getHorizontalCoordinateString=function(t){return O(br(t))},Nr=y.__private__.getVerticalCoordinateString=y.getVerticalCoordinateString=function(t){return O(yr(t))},Lr=e.strokeColor||"0 G";y.__private__.getStrokeColor=y.getDrawColor=function(){return ee(Lr)},y.__private__.setStrokeColor=y.setDrawColor=function(t,e,r,n){return Lr=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"draw",precision:2}),lt(Lr),this};var Ar=e.fillColor||"0 g";y.__private__.getFillColor=y.getFillColor=function(){return ee(Ar)},y.__private__.setFillColor=y.setFillColor=function(t,e,r,n){return Ar=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"fill",precision:2}),lt(Ar),this};var xr=e.textColor||"0 g",Sr=y.__private__.getTextColor=y.getTextColor=function(){return ee(xr)};y.__private__.setTextColor=y.setTextColor=function(t,e,r,n){return xr=re({ch1:t,ch2:e,ch3:r,ch4:n,pdfColorType:"text",precision:3}),this};var _r=e.charSpace,Pr=y.__private__.getCharSpace=y.getCharSpace=function(){return parseFloat(_r||0)};y.__private__.setCharSpace=y.setCharSpace=function(t){if(isNaN(t))throw new Error("Invalid argument passed to jsPDF.setCharSpace");return _r=t,this};var kr=0;y.CapJoinStyles={0:0,butt:0,but:0,miter:0,1:1,round:1,rounded:1,circle:1,2:2,projecting:2,project:2,square:2,bevel:2},y.__private__.setLineCap=y.setLineCap=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line cap style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return kr=e,lt(e+" J"),this};var Ir=0;y.__private__.setLineJoin=y.setLineJoin=function(t){var e=y.CapJoinStyles[t];if(void 0===e)throw new Error("Line join style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return Ir=e,lt(e+" j"),this},y.__private__.setLineMiterLimit=y.__private__.setMiterLimit=y.setLineMiterLimit=y.setMiterLimit=function(t){if(t=t||0,isNaN(t))throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");return lt(O(U(t))+" M"),this},y.GState=j,y.setGState=function(t){(t="string"==typeof t?Mt[Et[t]]:Fr(null,t)).equals(qt)||(lt("/"+t.id+" gs"),qt=t);};var Fr=function(t,e){if(!t||!Et[t]){var r=!1;for(var n in Mt)if(Mt.hasOwnProperty(n)&&Mt[n].equals(e)){r=!0;break}if(r)e=Mt[n];else {var i="GS"+(Object.keys(Mt).length+1).toString(10);Mt[i]=e,e.id=i;}return t&&(Et[t]=e.id),Tt.publish("addGState",e),e}};y.addGState=function(t,e){return Fr(t,e),this},y.saveGraphicsState=function(){return lt("q"),jt.push({key:St,size:gt,color:xr}),this},y.restoreGraphicsState=function(){lt("Q");var t=jt.pop();return St=t.key,gt=t.size,xr=t.color,qt=null,this},y.setCurrentTransformationMatrix=function(t){return lt(t.toString()+" cm"),this},y.comment=function(t){return lt("#"+t),this};var Cr=function(t,e){var r=t||0;Object.defineProperty(this,"x",{enumerable:!0,get:function(){return r},set:function(t){isNaN(t)||(r=parseFloat(t));}});var n=e||0;Object.defineProperty(this,"y",{enumerable:!0,get:function(){return n},set:function(t){isNaN(t)||(n=parseFloat(t));}});var i="pt";return Object.defineProperty(this,"type",{enumerable:!0,get:function(){return i},set:function(t){i=t.toString();}}),this},jr=function(t,e,r,n){Cr.call(this,t,e),this.type="rect";var i=r||0;Object.defineProperty(this,"w",{enumerable:!0,get:function(){return i},set:function(t){isNaN(t)||(i=parseFloat(t));}});var a=n||0;return Object.defineProperty(this,"h",{enumerable:!0,get:function(){return a},set:function(t){isNaN(t)||(a=parseFloat(t));}}),this},Or=function(){this.page=Dt,this.currentPage=$,this.pages=ot.slice(0),this.pagesContext=Rt.slice(0),this.x=Pt,this.y=kt,this.matrix=It,this.width=qr($),this.height=Rr($),this.outputDestination=ct,this.id="",this.objectNumber=-1;};Or.prototype.restore=function(){Dt=this.page,$=this.currentPage,Rt=this.pagesContext,ot=this.pages,Pt=this.x,kt=this.y,It=this.matrix,Dr($,this.width),Tr($,this.height),ct=this.outputDestination;};var Br=function(t,e,r,n,i){Wt.push(new Or),Dt=$=0,ot=[],Pt=t,kt=e,It=i,je([r,n]);},Mr=function(t){if(Ht[t])Wt.pop().restore();else {var e=new Or,r="Xo"+(Object.keys(zt).length+1).toString(10);e.id=r,Ht[t]=r,zt[r]=e,Tt.publish("addFormObject",e),Wt.pop().restore();}};for(var Er in y.beginFormObject=function(t,e,r,n,i){return Br(t,e,r,n,i),this},y.endFormObject=function(t){return Mr(t),this},y.doFormObject=function(t,e){var r=zt[Ht[t]];return lt("q"),lt(e.toString()+" cm"),lt("/"+r.id+" Do"),lt("Q"),this},y.getFormObject=function(t){var e=zt[Ht[t]];return {x:e.x,y:e.y,width:e.width,height:e.height,matrix:e.matrix}},y.save=function(t,e){return t=t||"generated.pdf",(e=e||{}).returnPromise=e.returnPromise||!1,!1===e.returnPromise?(l$1(We(He()),t),"function"==typeof l$1.unload&&n$1.setTimeout&&setTimeout(l$1.unload,911),this):new Promise((function(e,r){try{var i=l$1(We(He()),t);"function"==typeof l$1.unload&&n$1.setTimeout&&setTimeout(l$1.unload,911),e(i);}catch(t){r(t.message);}}))},E$1.API)E$1.API.hasOwnProperty(Er)&&("events"===Er&&E$1.API.events.length?function(t,e){var r,n,i;for(i=e.length-1;-1!==i;i--)r=e[i][0],n=e[i][1],t.subscribe.apply(t,[r].concat("function"==typeof n?[n]:n));}(Tt,E$1.API.events):y[Er]=E$1.API[Er]);var qr=y.getPageWidth=function(t){return (Rt[t=t||$].mediaBox.topRightX-Rt[t].mediaBox.bottomLeftX)/_t},Dr=y.setPageWidth=function(t,e){Rt[t].mediaBox.topRightX=e*_t+Rt[t].mediaBox.bottomLeftX;},Rr=y.getPageHeight=function(t){return (Rt[t=t||$].mediaBox.topRightY-Rt[t].mediaBox.bottomLeftY)/_t},Tr=y.setPageHeight=function(t,e){Rt[t].mediaBox.topRightY=e*_t+Rt[t].mediaBox.bottomLeftY;};return y.internal={pdfEscape:Ce,getStyle:tr,getFont:hr,getFontSize:vt,getCharSpace:Pr,getTextColor:Sr,getLineHeight:gr,getLineHeightFactor:vr,getLineWidth:dr,write:ft,getHorizontalCoordinate:br,getVerticalCoordinate:yr,getCoordinateString:wr,getVerticalCoordinateString:Nr,collections:{},newObject:Xt,newAdditionalObject:$t,newObjectDeferred:Kt,newObjectDeferredBegin:Zt,getFilters:ne,putStream:ie,events:Tt,scaleFactor:_t,pageSize:{getWidth:function(){return qr($)},setWidth:function(t){Dr($,t);},getHeight:function(){return Rr($)},setHeight:function(t){Tr($,t);}},encryptionOptions:m,encryption:Ye,getEncryptor:Je,output:Ve,getNumberOfPages:Ee,pages:ot,out:lt,f2:R,f3:T,getPageInfo:Xe,getPageInfoByObjId:Ke,getCurrentPageInfo:Ze,getPDFVersion:N,Point:Cr,Rectangle:jr,Matrix:Vt,hasHotfix:Ge},Object.defineProperty(y.internal.pageSize,"width",{get:function(){return qr($)},set:function(t){Dr($,t);},enumerable:!0,configurable:!0}),Object.defineProperty(y.internal.pageSize,"height",{get:function(){return Rr($)},set:function(t){Tr($,t);},enumerable:!0,configurable:!0}),ke.call(y,pt),St="F1",Oe(s,i),Tt.publish("initialized"),y}I.prototype.lsbFirstWord=function(t){return String.fromCharCode(t>>0&255,t>>8&255,t>>16&255,t>>24&255)},I.prototype.toHexString=function(t){return t.split("").map((function(t){return ("0"+(255&t.charCodeAt(0)).toString(16)).slice(-2)})).join("")},I.prototype.hexToBytes=function(t){for(var e=[],r=0;r<t.length;r+=2)e.push(String.fromCharCode(parseInt(t.substr(r,2),16)));return e.join("")},I.prototype.processOwnerPassword=function(t,e){return P(x(e).substr(0,5),t)},I.prototype.encryptor=function(t,e){var r=x(this.encryptionKey+String.fromCharCode(255&t,t>>8&255,t>>16&255,255&e,e>>8&255)).substr(0,10);return function(t){return P(r,t)}},j.prototype.equals=function(e){var r,n="id,objectNumber,equals";if(!e||_typeof$2(e)!==_typeof$2(this))return !1;var i=0;for(r in this)if(!(n.indexOf(r)>=0)){if(this.hasOwnProperty(r)&&!e.hasOwnProperty(r))return !1;if(this[r]!==e[r])return !1;i++;}for(r in e)e.hasOwnProperty(r)&&n.indexOf(r)<0&&i--;return 0===i},E$1.API={events:[]},E$1.version="2.5.1";var q=E$1.API,D=1,R=function(t){return t.replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},T$2=function(t){return t.replace(/\\\\/g,"\\").replace(/\\\(/g,"(").replace(/\\\)/g,")")},U$1=function(t){return t.toFixed(2)},z$1=function(t){return t.toFixed(5)};q.__acroform__={};var H=function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t;},W=function(t){return t*D},V$1=function(t){var e=new ut,r=At.internal.getHeight(t)||0,n=At.internal.getWidth(t)||0;return e.BBox=[0,0,Number(U$1(n)),Number(U$1(r))],e},G=q.__acroform__.setBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");return t|=1<<e},Y=q.__acroform__.clearBit=function(t,e){if(t=t||0,e=e||0,isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");return t&=~(1<<e)},J=q.__acroform__.getBit=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");return 0==(t&1<<e)?0:1},X=q.__acroform__.getBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");return J(t,e-1)},K=q.__acroform__.setBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");return G(t,e-1)},Z$1=q.__acroform__.clearBitForPdf=function(t,e){if(isNaN(t)||isNaN(e))throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");return Y(t,e-1)},$$a=q.__acroform__.calculateCoordinates=function(t,e){var r=e.internal.getHorizontalCoordinate,n=e.internal.getVerticalCoordinate,i=t[0],a=t[1],o=t[2],s=t[3],c={};return c.lowerLeft_X=r(i)||0,c.lowerLeft_Y=n(a+s)||0,c.upperRight_X=r(i+o)||0,c.upperRight_Y=n(a)||0,[Number(U$1(c.lowerLeft_X)),Number(U$1(c.lowerLeft_Y)),Number(U$1(c.upperRight_X)),Number(U$1(c.upperRight_Y))]},Q=function(t){if(t.appearanceStreamContent)return t.appearanceStreamContent;if(t.V||t.DV){var e=[],r=t._V||t.DV,n=tt(t,r),i=t.scope.internal.getFont(t.fontName,t.fontStyle).id;e.push("/Tx BMC"),e.push("q"),e.push("BT"),e.push(t.scope.__private__.encodeColorString(t.color)),e.push("/"+i+" "+U$1(n.fontSize)+" Tf"),e.push("1 0 0 1 0 0 Tm"),e.push(n.text),e.push("ET"),e.push("Q"),e.push("EMC");var a=V$1(t);return a.scope=t.scope,a.stream=e.join("\n"),a}},tt=function(t,e){var r=0===t.fontSize?t.maxFontSize:t.fontSize,n={text:"",fontSize:""},i=(e=")"==(e="("==e.substr(0,1)?e.substr(1):e).substr(e.length-1)?e.substr(0,e.length-1):e).split(" ");i=t.multiline?i.map((function(t){return t.split("\n")})):i.map((function(t){return [t]}));var a=r,o=At.internal.getHeight(t)||0;o=o<0?-o:o;var s=At.internal.getWidth(t)||0;s=s<0?-s:s;var c=function(e,r,n){if(e+1<i.length){var a=r+" "+i[e+1][0];return et(a,t,n).width<=s-4}return !1};a++;t:for(;a>0;){e="",a--;var u,h,l=et("3",t,a).height,f=t.multiline?o-a:(o-l)/2,d=f+=2,p=0,g=0,m=0;if(a<=0){e="(...) Tj\n",e+="% Width of Text: "+et(e,t,a=12).width+", FieldWidth:"+s+"\n";break}for(var v="",b=0,y=0;y<i.length;y++)if(i.hasOwnProperty(y)){var w=!1;if(1!==i[y].length&&m!==i[y].length-1){if((l+2)*(b+2)+2>o)continue t;v+=i[y][m],w=!0,g=y,y--;}else {v=" "==(v+=i[y][m]+" ").substr(v.length-1)?v.substr(0,v.length-1):v;var N=parseInt(y),L=c(N,v,a),A=y>=i.length-1;if(L&&!A){v+=" ",m=0;continue}if(L||A){if(A)g=N;else if(t.multiline&&(l+2)*(b+2)+2>o)continue t}else {if(!t.multiline)continue t;if((l+2)*(b+2)+2>o)continue t;g=N;}}for(var x="",S=p;S<=g;S++){var _=i[S];if(t.multiline){if(S===g){x+=_[m]+" ",m=(m+1)%_.length;continue}if(S===p){x+=_[_.length-1]+" ";continue}}x+=_[0]+" ";}switch(x=" "==x.substr(x.length-1)?x.substr(0,x.length-1):x,h=et(x,t,a).width,t.textAlign){case"right":u=s-h-2;break;case"center":u=(s-h)/2;break;case"left":default:u=2;}e+=U$1(u)+" "+U$1(d)+" Td\n",e+="("+R(x)+") Tj\n",e+=-U$1(u)+" 0 Td\n",d=-(a+2),h=0,p=w?g:g+1,b++,v="";}break}return n.text=e,n.fontSize=a,n},et=function(t,e,r){var n=e.scope.internal.getFont(e.fontName,e.fontStyle),i=e.scope.getStringUnitWidth(t,{font:n,fontSize:parseFloat(r),charSpace:0})*parseFloat(r);return {height:e.scope.getStringUnitWidth("3",{font:n,fontSize:parseFloat(r),charSpace:0})*parseFloat(r)*1.5,width:i}},rt={fields:[],xForms:[],acroFormDictionaryRoot:null,printedOut:!1,internal:null,isInitialized:!1},nt=function(t,e){var r={type:"reference",object:t};void 0===e.internal.getPageInfo(t.page).pageContext.annotations.find((function(t){return t.type===r.type&&t.object===r.object}))&&e.internal.getPageInfo(t.page).pageContext.annotations.push(r);},it=function(e,r){for(var n in e)if(e.hasOwnProperty(n)){var i=n,a=e[n];r.internal.newObjectDeferredBegin(a.objId,!0),"object"===_typeof$2(a)&&"function"==typeof a.putStream&&a.putStream(),delete e[i];}},at=function(e,r){if(r.scope=e,void 0!==e.internal&&(void 0===e.internal.acroformPlugin||!1===e.internal.acroformPlugin.isInitialized)){if(lt.FieldNum=0,e.internal.acroformPlugin=JSON.parse(JSON.stringify(rt)),e.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("Exception while creating AcroformDictionary");D=e.internal.scaleFactor,e.internal.acroformPlugin.acroFormDictionaryRoot=new ht,e.internal.acroformPlugin.acroFormDictionaryRoot.scope=e,e.internal.acroformPlugin.acroFormDictionaryRoot._eventID=e.internal.events.subscribe("postPutResources",(function(){!function(t){t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID),delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID,t.internal.acroformPlugin.printedOut=!0;}(e);})),e.internal.events.subscribe("buildDocument",(function(){!function(t){t.internal.acroformPlugin.acroFormDictionaryRoot.objId=void 0;var e=t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];n.objId=void 0,n.hasAnnotation&&nt(n,t);}}(e);})),e.internal.events.subscribe("putCatalog",(function(){!function(t){if(void 0===t.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("putCatalogCallback: Root missing.");t.internal.write("/AcroForm "+t.internal.acroformPlugin.acroFormDictionaryRoot.objId+" 0 R");}(e);})),e.internal.events.subscribe("postPutPages",(function(r){!function(e,r){var n=!e;for(var i in e||(r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId,!0),r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()),e=e||r.internal.acroformPlugin.acroFormDictionaryRoot.Kids)if(e.hasOwnProperty(i)){var a=e[i],o=[],s=a.Rect;if(a.Rect&&(a.Rect=$$a(a.Rect,r)),r.internal.newObjectDeferredBegin(a.objId,!0),a.DA=At.createDefaultAppearanceStream(a),"object"===_typeof$2(a)&&"function"==typeof a.getKeyValueListForStream&&(o=a.getKeyValueListForStream()),a.Rect=s,a.hasAppearanceStream&&!a.appearanceStreamContent){var c=Q(a);o.push({key:"AP",value:"<</N "+c+">>"}),r.internal.acroformPlugin.xForms.push(c);}if(a.appearanceStreamContent){var u="";for(var h in a.appearanceStreamContent)if(a.appearanceStreamContent.hasOwnProperty(h)){var l=a.appearanceStreamContent[h];if(u+="/"+h+" ",u+="<<",Object.keys(l).length>=1||Array.isArray(l)){for(var i in l)if(l.hasOwnProperty(i)){var f=l[i];"function"==typeof f&&(f=f.call(r,a)),u+="/"+i+" "+f+" ",r.internal.acroformPlugin.xForms.indexOf(f)>=0||r.internal.acroformPlugin.xForms.push(f);}}else "function"==typeof(f=l)&&(f=f.call(r,a)),u+="/"+i+" "+f,r.internal.acroformPlugin.xForms.indexOf(f)>=0||r.internal.acroformPlugin.xForms.push(f);u+=">>";}o.push({key:"AP",value:"<<\n"+u+">>"});}r.internal.putStream({additionalKeyValues:o,objectId:a.objId}),r.internal.out("endobj");}n&&it(r.internal.acroformPlugin.xForms,r);}(r,e);})),e.internal.acroformPlugin.isInitialized=!0;}},ot=q.__acroform__.arrayToPdfArray=function(e,r,n){var i=function(t){return t};if(Array.isArray(e)){for(var a="[",o=0;o<e.length;o++)switch(0!==o&&(a+=" "),_typeof$2(e[o])){case"boolean":case"number":case"object":a+=e[o].toString();break;case"string":"/"!==e[o].substr(0,1)?(void 0!==r&&n&&(i=n.internal.getEncryptor(r)),a+="("+R(i(e[o].toString()))+")"):a+=e[o].toString();}return a+="]"}throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray")};var st=function(t,e,r){var n=function(t){return t};return void 0!==e&&r&&(n=r.internal.getEncryptor(e)),(t=t||"").toString(),t="("+R(n(t))+")"},ct=function(){this._objId=void 0,this._scope=void 0,Object.defineProperty(this,"objId",{get:function(){if(void 0===this._objId){if(void 0===this.scope)return;this._objId=this.scope.internal.newObjectDeferred();}return this._objId},set:function(t){this._objId=t;}}),Object.defineProperty(this,"scope",{value:this._scope,writable:!0});};ct.prototype.toString=function(){return this.objId+" 0 R"},ct.prototype.putStream=function(){var t=this.getKeyValueListForStream();this.scope.internal.putStream({data:this.stream,additionalKeyValues:t,objectId:this.objId}),this.scope.internal.out("endobj");},ct.prototype.getKeyValueListForStream=function(){var t=[],e=Object.getOwnPropertyNames(this).filter((function(t){return "content"!=t&&"appearanceStreamContent"!=t&&"scope"!=t&&"objId"!=t&&"_"!=t.substring(0,1)}));for(var r in e)if(!1===Object.getOwnPropertyDescriptor(this,e[r]).configurable){var n=e[r],i=this[n];i&&(Array.isArray(i)?t.push({key:n,value:ot(i,this.objId,this.scope)}):i instanceof ct?(i.scope=this.scope,t.push({key:n,value:i.objId+" 0 R"})):"function"!=typeof i&&t.push({key:n,value:i}));}return t};var ut=function(){ct.call(this),Object.defineProperty(this,"Type",{value:"/XObject",configurable:!1,writable:!0}),Object.defineProperty(this,"Subtype",{value:"/Form",configurable:!1,writable:!0}),Object.defineProperty(this,"FormType",{value:1,configurable:!1,writable:!0});var t,e=[];Object.defineProperty(this,"BBox",{configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"Resources",{value:"2 0 R",configurable:!1,writable:!0}),Object.defineProperty(this,"stream",{enumerable:!1,configurable:!0,set:function(e){t=e.trim();},get:function(){return t||null}});};H(ut,ct);var ht=function(){ct.call(this);var t,e=[];Object.defineProperty(this,"Kids",{enumerable:!1,configurable:!0,get:function(){return e.length>0?e:void 0}}),Object.defineProperty(this,"Fields",{enumerable:!1,configurable:!1,get:function(){return e}}),Object.defineProperty(this,"DA",{enumerable:!1,configurable:!1,get:function(){if(t){var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+R(e(t))+")"}},set:function(e){t=e;}});};H(ht,ct);var lt=function t(){ct.call(this);var e=4;Object.defineProperty(this,"F",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute F supplied.');e=t;}}),Object.defineProperty(this,"showWhenPrinted",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(e,3))},set:function(t){!0===Boolean(t)?this.F=K(e,3):this.F=Z$1(e,3);}});var r=0;Object.defineProperty(this,"Ff",{enumerable:!1,configurable:!1,get:function(){return r},set:function(t){if(isNaN(t))throw new Error('Invalid value "'+t+'" for attribute Ff supplied.');r=t;}});var n=[];Object.defineProperty(this,"Rect",{enumerable:!1,configurable:!1,get:function(){if(0!==n.length)return n},set:function(t){n=void 0!==t?t:[];}}),Object.defineProperty(this,"x",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[0])?0:n[0]},set:function(t){n[0]=t;}}),Object.defineProperty(this,"y",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[1])?0:n[1]},set:function(t){n[1]=t;}}),Object.defineProperty(this,"width",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[2])?0:n[2]},set:function(t){n[2]=t;}}),Object.defineProperty(this,"height",{enumerable:!0,configurable:!0,get:function(){return !n||isNaN(n[3])?0:n[3]},set:function(t){n[3]=t;}});var i="";Object.defineProperty(this,"FT",{enumerable:!0,configurable:!1,get:function(){return i},set:function(t){switch(t){case"/Btn":case"/Tx":case"/Ch":case"/Sig":i=t;break;default:throw new Error('Invalid value "'+t+'" for attribute FT supplied.')}}});var a=null;Object.defineProperty(this,"T",{enumerable:!0,configurable:!1,get:function(){if(!a||a.length<1){if(this instanceof yt)return;a="FieldObject"+t.FieldNum++;}var e=function(t){return t};return this.scope&&(e=this.scope.internal.getEncryptor(this.objId)),"("+R(e(a))+")"},set:function(t){a=t.toString();}}),Object.defineProperty(this,"fieldName",{configurable:!0,enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o="helvetica";Object.defineProperty(this,"fontName",{enumerable:!0,configurable:!0,get:function(){return o},set:function(t){o=t;}});var s="normal";Object.defineProperty(this,"fontStyle",{enumerable:!0,configurable:!0,get:function(){return s},set:function(t){s=t;}});var c=0;Object.defineProperty(this,"fontSize",{enumerable:!0,configurable:!0,get:function(){return c},set:function(t){c=t;}});var u=void 0;Object.defineProperty(this,"maxFontSize",{enumerable:!0,configurable:!0,get:function(){return void 0===u?50/D:u},set:function(t){u=t;}});var h="black";Object.defineProperty(this,"color",{enumerable:!0,configurable:!0,get:function(){return h},set:function(t){h=t;}});var l="/F1 0 Tf 0 g";Object.defineProperty(this,"DA",{enumerable:!0,configurable:!1,get:function(){if(!(!l||this instanceof yt||this instanceof Nt))return st(l,this.objId,this.scope)},set:function(t){t=t.toString(),l=t;}});var f=null;Object.defineProperty(this,"DV",{enumerable:!1,configurable:!1,get:function(){if(f)return this instanceof mt==!1?st(f,this.objId,this.scope):f},set:function(t){t=t.toString(),f=this instanceof mt==!1?"("===t.substr(0,1)?T$2(t.substr(1,t.length-2)):T$2(t):t;}}),Object.defineProperty(this,"defaultValue",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt==!0?T$2(f.substr(1,f.length-1)):f},set:function(t){t=t.toString(),f=this instanceof mt==!0?"/"+t:t;}});var d=null;Object.defineProperty(this,"_V",{enumerable:!1,configurable:!1,get:function(){if(d)return d},set:function(t){this.V=t;}}),Object.defineProperty(this,"V",{enumerable:!1,configurable:!1,get:function(){if(d)return this instanceof mt==!1?st(d,this.objId,this.scope):d},set:function(t){t=t.toString(),d=this instanceof mt==!1?"("===t.substr(0,1)?T$2(t.substr(1,t.length-2)):T$2(t):t;}}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,get:function(){return this instanceof mt==!0?T$2(d.substr(1,d.length-1)):d},set:function(t){t=t.toString(),d=this instanceof mt==!0?"/"+t:t;}}),Object.defineProperty(this,"hasAnnotation",{enumerable:!0,configurable:!0,get:function(){return this.Rect}}),Object.defineProperty(this,"Type",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Annot":null}}),Object.defineProperty(this,"Subtype",{enumerable:!0,configurable:!1,get:function(){return this.hasAnnotation?"/Widget":null}});var p,g=!1;Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return g},set:function(t){t=Boolean(t),g=t;}}),Object.defineProperty(this,"page",{enumerable:!0,configurable:!0,get:function(){if(p)return p},set:function(t){p=t;}}),Object.defineProperty(this,"readOnly",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,1))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,1):this.Ff=Z$1(this.Ff,1);}}),Object.defineProperty(this,"required",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,2))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,2):this.Ff=Z$1(this.Ff,2);}}),Object.defineProperty(this,"noExport",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,3))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,3):this.Ff=Z$1(this.Ff,3);}});var m=null;Object.defineProperty(this,"Q",{enumerable:!0,configurable:!1,get:function(){if(null!==m)return m},set:function(t){if(-1===[0,1,2].indexOf(t))throw new Error('Invalid value "'+t+'" for attribute Q supplied.');m=t;}}),Object.defineProperty(this,"textAlign",{get:function(){var t;switch(m){case 0:default:t="left";break;case 1:t="center";break;case 2:t="right";}return t},configurable:!0,enumerable:!0,set:function(t){switch(t){case"right":case 2:m=2;break;case"center":case 1:m=1;break;case"left":case 0:default:m=0;}}});};H(lt,ct);var ft=function(){lt.call(this),this.FT="/Ch",this.V="()",this.fontName="zapfdingbats";var t=0;Object.defineProperty(this,"TI",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"topIndex",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){t=e;}});var e=[];Object.defineProperty(this,"Opt",{enumerable:!0,configurable:!1,get:function(){return ot(e,this.objId,this.scope)},set:function(t){var r,n;n=[],"string"==typeof(r=t)&&(n=function(t,e,r){r||(r=1);for(var n,i=[];n=e.exec(t);)i.push(n[r]);return i}(r,/\((.*?)\)/g)),e=n;}}),this.getOptions=function(){return e},this.setOptions=function(t){e=t,this.sort&&e.sort();},this.addOption=function(t){t=(t=t||"").toString(),e.push(t),this.sort&&e.sort();},this.removeOption=function(t,r){for(r=r||!1,t=(t=t||"").toString();-1!==e.indexOf(t)&&(e.splice(e.indexOf(t),1),!1!==r););},Object.defineProperty(this,"combo",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,18))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,18):this.Ff=Z$1(this.Ff,18);}}),Object.defineProperty(this,"edit",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,19))},set:function(t){!0===this.combo&&(!0===Boolean(t)?this.Ff=K(this.Ff,19):this.Ff=Z$1(this.Ff,19));}}),Object.defineProperty(this,"sort",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,20))},set:function(t){!0===Boolean(t)?(this.Ff=K(this.Ff,20),e.sort()):this.Ff=Z$1(this.Ff,20);}}),Object.defineProperty(this,"multiSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,22))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,22):this.Ff=Z$1(this.Ff,22);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,23):this.Ff=Z$1(this.Ff,23);}}),Object.defineProperty(this,"commitOnSelChange",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,27))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,27):this.Ff=Z$1(this.Ff,27);}}),this.hasAppearanceStream=!1;};H(ft,lt);var dt=function(){ft.call(this),this.fontName="helvetica",this.combo=!1;};H(dt,ft);var pt=function(){dt.call(this),this.combo=!0;};H(pt,dt);var gt=function(){pt.call(this),this.edit=!0;};H(gt,pt);var mt=function(){lt.call(this),this.FT="/Btn",Object.defineProperty(this,"noToggleToOff",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,15))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,15):this.Ff=Z$1(this.Ff,15);}}),Object.defineProperty(this,"radio",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,16))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,16):this.Ff=Z$1(this.Ff,16);}}),Object.defineProperty(this,"pushButton",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,17))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,17):this.Ff=Z$1(this.Ff,17);}}),Object.defineProperty(this,"radioIsUnison",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,26):this.Ff=Z$1(this.Ff,26);}});var e,r={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};if(this.scope&&(t=this.scope.internal.getEncryptor(this.objId)),0!==Object.keys(r).length){var e,n=[];for(e in n.push("<<"),r)n.push("/"+e+" ("+R(t(r[e]))+")");return n.push(">>"),n.join("\n")}},set:function(e){"object"===_typeof$2(e)&&(r=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return r.CA||""},set:function(t){"string"==typeof t&&(r.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return e.substr(1,e.length-1)},set:function(t){e="/"+t;}});};H(mt,lt);var vt=function(){mt.call(this),this.pushButton=!0;};H(vt,mt);var bt=function(){mt.call(this),this.radio=!0,this.pushButton=!1;var t=[];Object.defineProperty(this,"Kids",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=void 0!==e?e:[];}});};H(bt,mt);var yt=function(){var e,r;lt.call(this),Object.defineProperty(this,"Parent",{enumerable:!1,configurable:!1,get:function(){return e},set:function(t){e=t;}}),Object.defineProperty(this,"optionName",{enumerable:!1,configurable:!0,get:function(){return r},set:function(t){r=t;}});var n,i={};Object.defineProperty(this,"MK",{enumerable:!1,configurable:!1,get:function(){var t=function(t){return t};this.scope&&(t=this.scope.internal.getEncryptor(this.objId));var e,r=[];for(e in r.push("<<"),i)r.push("/"+e+" ("+R(t(i[e]))+")");return r.push(">>"),r.join("\n")},set:function(e){"object"===_typeof$2(e)&&(i=e);}}),Object.defineProperty(this,"caption",{enumerable:!0,configurable:!0,get:function(){return i.CA||""},set:function(t){"string"==typeof t&&(i.CA=t);}}),Object.defineProperty(this,"AS",{enumerable:!1,configurable:!1,get:function(){return n},set:function(t){n=t;}}),Object.defineProperty(this,"appearanceState",{enumerable:!0,configurable:!0,get:function(){return n.substr(1,n.length-1)},set:function(t){n="/"+t;}}),this.caption="l",this.appearanceState="Off",this._AppearanceType=At.RadioButton.Circle,this.appearanceStreamContent=this._AppearanceType.createAppearanceStream(this.optionName);};H(yt,lt),bt.prototype.setAppearance=function(t){if(!("createAppearanceStream"in t)||!("getCA"in t))throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");for(var e in this.Kids)if(this.Kids.hasOwnProperty(e)){var r=this.Kids[e];r.appearanceStreamContent=t.createAppearanceStream(r.optionName),r.caption=t.getCA();}},bt.prototype.createOption=function(t){var e=new yt;return e.Parent=this,e.optionName=t,this.Kids.push(e),xt.call(this.scope,e),e};var wt=function(){mt.call(this),this.fontName="zapfdingbats",this.caption="3",this.appearanceState="On",this.value="On",this.textAlign="center",this.appearanceStreamContent=At.CheckBox.createAppearanceStream();};H(wt,mt);var Nt=function(){lt.call(this),this.FT="/Tx",Object.defineProperty(this,"multiline",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,13))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,13):this.Ff=Z$1(this.Ff,13);}}),Object.defineProperty(this,"fileSelect",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,21))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,21):this.Ff=Z$1(this.Ff,21);}}),Object.defineProperty(this,"doNotSpellCheck",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,23))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,23):this.Ff=Z$1(this.Ff,23);}}),Object.defineProperty(this,"doNotScroll",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,24))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,24):this.Ff=Z$1(this.Ff,24);}}),Object.defineProperty(this,"comb",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,25))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,25):this.Ff=Z$1(this.Ff,25);}}),Object.defineProperty(this,"richText",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,26))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,26):this.Ff=Z$1(this.Ff,26);}});var t=null;Object.defineProperty(this,"MaxLen",{enumerable:!0,configurable:!1,get:function(){return t},set:function(e){t=e;}}),Object.defineProperty(this,"maxLength",{enumerable:!0,configurable:!0,get:function(){return t},set:function(e){Number.isInteger(e)&&(t=e);}}),Object.defineProperty(this,"hasAppearanceStream",{enumerable:!0,configurable:!0,get:function(){return this.V||this.DV}});};H(Nt,lt);var Lt=function(){Nt.call(this),Object.defineProperty(this,"password",{enumerable:!0,configurable:!0,get:function(){return Boolean(X(this.Ff,14))},set:function(t){!0===Boolean(t)?this.Ff=K(this.Ff,14):this.Ff=Z$1(this.Ff,14);}}),this.password=!0;};H(Lt,Nt);var At={CheckBox:{createAppearanceStream:function(){return {N:{On:At.CheckBox.YesNormal},D:{On:At.CheckBox.YesPushDown,Off:At.CheckBox.OffPushDown}}},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=t.scope.internal.getFont(t.fontName,t.fontStyle).id,i=t.scope.__private__.encodeColorString(t.color),a=tt(t,t.caption);return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),r.push("BMC"),r.push("q"),r.push("0 0 1 rg"),r.push("/"+n+" "+U$1(a.fontSize)+" Tf "+i),r.push("BT"),r.push(a.text),r.push("ET"),r.push("Q"),r.push("EMC"),e.stream=r.join("\n"),e},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=t.scope.internal.getFont(t.fontName,t.fontStyle).id,n=t.scope.__private__.encodeColorString(t.color),i=[],a=At.internal.getHeight(t),o=At.internal.getWidth(t),s=tt(t,t.caption);return i.push("1 g"),i.push("0 0 "+U$1(o)+" "+U$1(a)+" re"),i.push("f"),i.push("q"),i.push("0 0 1 rg"),i.push("0 0 "+U$1(o-1)+" "+U$1(a-1)+" re"),i.push("W"),i.push("n"),i.push("0 g"),i.push("BT"),i.push("/"+r+" "+U$1(s.fontSize)+" Tf "+n),i.push(s.text),i.push("ET"),i.push("Q"),e.stream=i.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[];return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),e.stream=r.join("\n"),e}},RadioButton:{Circle:{createAppearanceStream:function(t){var e={D:{Off:At.RadioButton.Circle.OffPushDown},N:{}};return e.N[t]=At.RadioButton.Circle.YesNormal,e.D[t]=At.RadioButton.Circle.YesPushDown,e},getCA:function(){return "l"},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=At.internal.Bezier_C,a=Number((n*i).toFixed(5));return r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(n+" 0 m"),r.push(n+" "+a+" "+a+" "+n+" 0 "+n+" c"),r.push("-"+a+" "+n+" -"+n+" "+a+" -"+n+" 0 c"),r.push("-"+n+" -"+a+" -"+a+" -"+n+" 0 -"+n+" c"),r.push(a+" -"+n+" "+n+" -"+a+" "+n+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=Number((2*n).toFixed(5)),a=Number((i*At.internal.Bezier_C).toFixed(5)),o=Number((n*At.internal.Bezier_C).toFixed(5));return r.push("0.749023 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(i+" 0 m"),r.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),r.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),r.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),r.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),r.push("f"),r.push("Q"),r.push("0 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(n+" 0 m"),r.push(n+" "+o+" "+o+" "+n+" 0 "+n+" c"),r.push("-"+o+" "+n+" -"+n+" "+o+" -"+n+" 0 c"),r.push("-"+n+" -"+o+" -"+o+" -"+n+" 0 -"+n+" c"),r.push(o+" -"+n+" "+n+" -"+o+" "+n+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.getWidth(t)<=At.internal.getHeight(t)?At.internal.getWidth(t)/4:At.internal.getHeight(t)/4;n=Number((.9*n).toFixed(5));var i=Number((2*n).toFixed(5)),a=Number((i*At.internal.Bezier_C).toFixed(5));return r.push("0.749023 g"),r.push("q"),r.push("1 0 0 1 "+z$1(At.internal.getWidth(t)/2)+" "+z$1(At.internal.getHeight(t)/2)+" cm"),r.push(i+" 0 m"),r.push(i+" "+a+" "+a+" "+i+" 0 "+i+" c"),r.push("-"+a+" "+i+" -"+i+" "+a+" -"+i+" 0 c"),r.push("-"+i+" -"+a+" -"+a+" -"+i+" 0 -"+i+" c"),r.push(a+" -"+i+" "+i+" -"+a+" "+i+" 0 c"),r.push("f"),r.push("Q"),e.stream=r.join("\n"),e}},Cross:{createAppearanceStream:function(t){var e={D:{Off:At.RadioButton.Cross.OffPushDown},N:{}};return e.N[t]=At.RadioButton.Cross.YesNormal,e.D[t]=At.RadioButton.Cross.YesPushDown,e},getCA:function(){return "8"},YesNormal:function(t){var e=V$1(t);e.scope=t.scope;var r=[],n=At.internal.calculateCross(t);return r.push("q"),r.push("1 1 "+U$1(At.internal.getWidth(t)-2)+" "+U$1(At.internal.getHeight(t)-2)+" re"),r.push("W"),r.push("n"),r.push(U$1(n.x1.x)+" "+U$1(n.x1.y)+" m"),r.push(U$1(n.x2.x)+" "+U$1(n.x2.y)+" l"),r.push(U$1(n.x4.x)+" "+U$1(n.x4.y)+" m"),r.push(U$1(n.x3.x)+" "+U$1(n.x3.y)+" l"),r.push("s"),r.push("Q"),e.stream=r.join("\n"),e},YesPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=At.internal.calculateCross(t),n=[];return n.push("0.749023 g"),n.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),n.push("f"),n.push("q"),n.push("1 1 "+U$1(At.internal.getWidth(t)-2)+" "+U$1(At.internal.getHeight(t)-2)+" re"),n.push("W"),n.push("n"),n.push(U$1(r.x1.x)+" "+U$1(r.x1.y)+" m"),n.push(U$1(r.x2.x)+" "+U$1(r.x2.y)+" l"),n.push(U$1(r.x4.x)+" "+U$1(r.x4.y)+" m"),n.push(U$1(r.x3.x)+" "+U$1(r.x3.y)+" l"),n.push("s"),n.push("Q"),e.stream=n.join("\n"),e},OffPushDown:function(t){var e=V$1(t);e.scope=t.scope;var r=[];return r.push("0.749023 g"),r.push("0 0 "+U$1(At.internal.getWidth(t))+" "+U$1(At.internal.getHeight(t))+" re"),r.push("f"),e.stream=r.join("\n"),e}}},createDefaultAppearanceStream:function(t){var e=t.scope.internal.getFont(t.fontName,t.fontStyle).id,r=t.scope.__private__.encodeColorString(t.color);return "/"+e+" "+t.fontSize+" Tf "+r}};At.internal={Bezier_C:.551915024494,calculateCross:function(t){var e=At.internal.getWidth(t),r=At.internal.getHeight(t),n=Math.min(e,r);return {x1:{x:(e-n)/2,y:(r-n)/2+n},x2:{x:(e-n)/2+n,y:(r-n)/2},x3:{x:(e-n)/2,y:(r-n)/2},x4:{x:(e-n)/2+n,y:(r-n)/2+n}}}},At.internal.getWidth=function(e){var r=0;return "object"===_typeof$2(e)&&(r=W(e.Rect[2])),r},At.internal.getHeight=function(e){var r=0;return "object"===_typeof$2(e)&&(r=W(e.Rect[3])),r};var xt=q.addField=function(t){if(at(this,t),!(t instanceof lt))throw new Error("Invalid argument passed to jsPDF.addField.");var e;return (e=t).scope.internal.acroformPlugin.printedOut&&(e.scope.internal.acroformPlugin.printedOut=!1,e.scope.internal.acroformPlugin.acroFormDictionaryRoot=null),e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e),t.page=t.scope.internal.getCurrentPageInfo().pageNumber,this};q.AcroFormChoiceField=ft,q.AcroFormListBox=dt,q.AcroFormComboBox=pt,q.AcroFormEditBox=gt,q.AcroFormButton=mt,q.AcroFormPushButton=vt,q.AcroFormRadioButton=bt,q.AcroFormCheckBox=wt,q.AcroFormTextField=Nt,q.AcroFormPasswordField=Lt,q.AcroFormAppearance=At,q.AcroForm={ChoiceField:ft,ListBox:dt,ComboBox:pt,EditBox:gt,Button:mt,PushButton:vt,RadioButton:bt,CheckBox:wt,TextField:Nt,PasswordField:Lt,Appearance:At},E$1.AcroForm={ChoiceField:ft,ListBox:dt,ComboBox:pt,EditBox:gt,Button:mt,PushButton:vt,RadioButton:bt,CheckBox:wt,TextField:Nt,PasswordField:Lt,Appearance:At};function _t(t){return t.reduce((function(t,e,r){return t[e]=r,t}),{})}!function(e){e.__addimage__={};var r="UNKNOWN",n={PNG:[[137,80,78,71]],TIFF:[[77,77,0,42],[73,73,42,0]],JPEG:[[255,216,255,224,void 0,void 0,74,70,73,70,0],[255,216,255,225,void 0,void 0,69,120,105,102,0,0],[255,216,255,219],[255,216,255,238]],JPEG2000:[[0,0,0,12,106,80,32,32]],GIF87a:[[71,73,70,56,55,97]],GIF89a:[[71,73,70,56,57,97]],WEBP:[[82,73,70,70,void 0,void 0,void 0,void 0,87,69,66,80]],BMP:[[66,77],[66,65],[67,73],[67,80],[73,67],[80,84]]},i=e.__addimage__.getImageFileTypeByImageData=function(t,e){var i,a,o,s,c,u=r;if("RGBA"===(e=e||r)||void 0!==t.data&&t.data instanceof Uint8ClampedArray&&"height"in t&&"width"in t)return "RGBA";if(x(t))for(c in n)for(o=n[c],i=0;i<o.length;i+=1){for(s=!0,a=0;a<o[i].length;a+=1)if(void 0!==o[i][a]&&o[i][a]!==t[a]){s=!1;break}if(!0===s){u=c;break}}else for(c in n)for(o=n[c],i=0;i<o.length;i+=1){for(s=!0,a=0;a<o[i].length;a+=1)if(void 0!==o[i][a]&&o[i][a]!==t.charCodeAt(a)){s=!1;break}if(!0===s){u=c;break}}return u===r&&e!==r&&(u=e),u},a=function t(e){for(var r=this.internal.write,n=this.internal.putStream,i=(0, this.internal.getFilters)();-1!==i.indexOf("FlateEncode");)i.splice(i.indexOf("FlateEncode"),1);e.objectId=this.internal.newObject();var a=[];if(a.push({key:"Type",value:"/XObject"}),a.push({key:"Subtype",value:"/Image"}),a.push({key:"Width",value:e.width}),a.push({key:"Height",value:e.height}),e.colorSpace===b.INDEXED?a.push({key:"ColorSpace",value:"[/Indexed /DeviceRGB "+(e.palette.length/3-1)+" "+("sMask"in e&&void 0!==e.sMask?e.objectId+2:e.objectId+1)+" 0 R]"}):(a.push({key:"ColorSpace",value:"/"+e.colorSpace}),e.colorSpace===b.DEVICE_CMYK&&a.push({key:"Decode",value:"[1 0 1 0 1 0 1 0]"})),a.push({key:"BitsPerComponent",value:e.bitsPerComponent}),"decodeParameters"in e&&void 0!==e.decodeParameters&&a.push({key:"DecodeParms",value:"<<"+e.decodeParameters+">>"}),"transparency"in e&&Array.isArray(e.transparency)){for(var o="",s=0,c=e.transparency.length;s<c;s++)o+=e.transparency[s]+" "+e.transparency[s]+" ";a.push({key:"Mask",value:"["+o+"]"});}void 0!==e.sMask&&a.push({key:"SMask",value:e.objectId+1+" 0 R"});var u=void 0!==e.filter?["/"+e.filter]:void 0;if(n({data:e.data,additionalKeyValues:a,alreadyAppliedFilters:u,objectId:e.objectId}),r("endobj"),"sMask"in e&&void 0!==e.sMask){var h="/Predictor "+e.predictor+" /Colors 1 /BitsPerComponent "+e.bitsPerComponent+" /Columns "+e.width,l={width:e.width,height:e.height,colorSpace:"DeviceGray",bitsPerComponent:e.bitsPerComponent,decodeParameters:h,data:e.sMask};"filter"in e&&(l.filter=e.filter),t.call(this,l);}if(e.colorSpace===b.INDEXED){var f=this.internal.newObject();n({data:_(new Uint8Array(e.palette)),objectId:f}),r("endobj");}},o=function(){var t=this.internal.collections.addImage_images;for(var e in t)a.call(this,t[e]);},s=function(){var t,e=this.internal.collections.addImage_images,r=this.internal.write;for(var n in e)r("/I"+(t=e[n]).index,t.objectId,"0","R");},c=function(){this.internal.collections.addImage_images||(this.internal.collections.addImage_images={},this.internal.events.subscribe("putResources",o),this.internal.events.subscribe("putXobjectDict",s));},h=function(){var t=this.internal.collections.addImage_images;return c.call(this),t},l=function(){return Object.keys(this.internal.collections.addImage_images).length},f=function(t){return "function"==typeof e["process"+t.toUpperCase()]},d=function(e){return "object"===_typeof$2(e)&&1===e.nodeType},p=function(t,r){if("IMG"===t.nodeName&&t.hasAttribute("src")){var n=""+t.getAttribute("src");if(0===n.indexOf("data:image/"))return u$2(unescape(n).split("base64,").pop());var i=e.loadFile(n,!0);if(void 0!==i)return i}if("CANVAS"===t.nodeName){if(0===t.width||0===t.height)throw new Error("Given canvas must have data. Canvas width: "+t.width+", height: "+t.height);var a;switch(r){case"PNG":a="image/png";break;case"WEBP":a="image/webp";break;case"JPEG":case"JPG":default:a="image/jpeg";}return u$2(t.toDataURL(a,1).split("base64,").pop())}},g=function(t){var e=this.internal.collections.addImage_images;if(e)for(var r in e)if(t===e[r].alias)return e[r]},m=function(t,e,r){return t||e||(t=-96,e=-96),t<0&&(t=-1*r.width*72/t/this.internal.scaleFactor),e<0&&(e=-1*r.height*72/e/this.internal.scaleFactor),0===t&&(t=e*r.width/r.height),0===e&&(e=t*r.height/r.width),[t,e]},v=function(t,e,r,n,i,a){var o=m.call(this,r,n,i),s=this.internal.getCoordinateString,c=this.internal.getVerticalCoordinateString,u=h.call(this);if(r=o[0],n=o[1],u[i.index]=i,a){a*=Math.PI/180;var l=Math.cos(a),f=Math.sin(a),d=function(t){return t.toFixed(4)},p=[d(l),d(f),d(-1*f),d(l),0,0,"cm"];}this.internal.write("q"),a?(this.internal.write([1,"0","0",1,s(t),c(e+n),"cm"].join(" ")),this.internal.write(p.join(" ")),this.internal.write([s(r),"0","0",s(n),"0","0","cm"].join(" "))):this.internal.write([s(r),"0","0",s(n),s(t),c(e+n),"cm"].join(" ")),this.isAdvancedAPI()&&this.internal.write([1,0,0,-1,0,0,"cm"].join(" ")),this.internal.write("/I"+i.index+" Do"),this.internal.write("Q");},b=e.color_spaces={DEVICE_RGB:"DeviceRGB",DEVICE_GRAY:"DeviceGray",DEVICE_CMYK:"DeviceCMYK",CAL_GREY:"CalGray",CAL_RGB:"CalRGB",LAB:"Lab",ICC_BASED:"ICCBased",INDEXED:"Indexed",PATTERN:"Pattern",SEPARATION:"Separation",DEVICE_N:"DeviceN"};e.decode={DCT_DECODE:"DCTDecode",FLATE_DECODE:"FlateDecode",LZW_DECODE:"LZWDecode",JPX_DECODE:"JPXDecode",JBIG2_DECODE:"JBIG2Decode",ASCII85_DECODE:"ASCII85Decode",ASCII_HEX_DECODE:"ASCIIHexDecode",RUN_LENGTH_DECODE:"RunLengthDecode",CCITT_FAX_DECODE:"CCITTFaxDecode"};var y=e.image_compression={NONE:"NONE",FAST:"FAST",MEDIUM:"MEDIUM",SLOW:"SLOW"},w=e.__addimage__.sHashCode=function(t){var e,r,n=0;if("string"==typeof t)for(r=t.length,e=0;e<r;e++)n=(n<<5)-n+t.charCodeAt(e),n|=0;else if(x(t))for(r=t.byteLength/2,e=0;e<r;e++)n=(n<<5)-n+t[e],n|=0;return n},N=e.__addimage__.validateStringAsBase64=function(t){(t=t||"").toString().trim();var e=!0;return 0===t.length&&(e=!1),t.length%4!=0&&(e=!1),!1===/^[A-Za-z0-9+/]+$/.test(t.substr(0,t.length-2))&&(e=!1),!1===/^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t.substr(-2))&&(e=!1),e},L=e.__addimage__.extractImageFromDataUrl=function(t){var e=(t=t||"").split("base64,"),r=null;if(2===e.length){var n=/^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e[0]);Array.isArray(n)&&(r={mimeType:n[1],charset:n[2],data:e[1]});}return r},A=e.__addimage__.supportsArrayBuffer=function(){return "undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array};e.__addimage__.isArrayBuffer=function(t){return A()&&t instanceof ArrayBuffer};var x=e.__addimage__.isArrayBufferView=function(t){return A()&&"undefined"!=typeof Uint32Array&&(t instanceof Int8Array||t instanceof Uint8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array)},S=e.__addimage__.binaryStringToUint8Array=function(t){for(var e=t.length,r=new Uint8Array(e),n=0;n<e;n++)r[n]=t.charCodeAt(n);return r},_=e.__addimage__.arrayBufferToBinaryString=function(t){for(var e="",r=x(t)?t:new Uint8Array(t),n=0;n<r.length;n+=8192)e+=String.fromCharCode.apply(null,r.subarray(n,n+8192));return e};e.addImage=function(){var e,n,i,a,o,s,u,h,l;if("number"==typeof arguments[1]?(n=r,i=arguments[1],a=arguments[2],o=arguments[3],s=arguments[4],u=arguments[5],h=arguments[6],l=arguments[7]):(n=arguments[1],i=arguments[2],a=arguments[3],o=arguments[4],s=arguments[5],u=arguments[6],h=arguments[7],l=arguments[8]),"object"===_typeof$2(e=arguments[0])&&!d(e)&&"imageData"in e){var f=e;e=f.imageData,n=f.format||n||r,i=f.x||i||0,a=f.y||a||0,o=f.w||f.width||o,s=f.h||f.height||s,u=f.alias||u,h=f.compression||h,l=f.rotation||f.angle||l;}var p=this.internal.getFilters();if(void 0===h&&-1!==p.indexOf("FlateEncode")&&(h="SLOW"),isNaN(i)||isNaN(a))throw new Error("Invalid coordinates passed to jsPDF.addImage");c.call(this);var g=P.call(this,e,n,u,h);return v.call(this,i,a,o,s,g,l),this};var P=function(t,n,a,o){var s,c,u;if("string"==typeof t&&i(t)===r){t=unescape(t);var h=k(t,!1);(""!==h||void 0!==(h=e.loadFile(t,!0)))&&(t=h);}if(d(t)&&(t=p(t,n)),n=i(t,n),!f(n))throw new Error("addImage does not support files of type '"+n+"', please ensure that a plugin for '"+n+"' support is added.");if((null==(u=a)||0===u.length)&&(a=function(t){return "string"==typeof t||x(t)?w(t):x(t.data)?w(t.data):null}(t)),(s=g.call(this,a))||(A()&&(t instanceof Uint8Array||"RGBA"===n||(c=t,t=S(t))),s=this["process"+n.toUpperCase()](t,l.call(this),a,function(t){return t&&"string"==typeof t&&(t=t.toUpperCase()),t in e.image_compression?t:y.NONE}(o),c)),!s)throw new Error("An unknown error occurred whilst processing the image.");return s},k=e.__addimage__.convertBase64ToBinaryString=function(t,e){var r;e="boolean"!=typeof e||e;var n,i="";if("string"==typeof t){n=null!==(r=L(t))?r.data:t;try{i=u$2(n);}catch(t){if(e)throw N(n)?new Error("atob-Error in jsPDF.convertBase64ToBinaryString "+t.message):new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ")}}return i};e.getImageProperties=function(t){var n,a,o="";if(d(t)&&(t=p(t)),"string"==typeof t&&i(t)===r&&(""===(o=k(t,!1))&&(o=e.loadFile(t)||""),t=o),a=i(t),!f(a))throw new Error("addImage does not support files of type '"+a+"', please ensure that a plugin for '"+a+"' support is added.");if(!A()||t instanceof Uint8Array||(t=S(t)),!(n=this["process"+a.toUpperCase()](t)))throw new Error("An unknown error occurred whilst processing the image");return n.fileType=a,n};}(E$1.API),
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(t){if(void 0!==t&&""!=t)return !0};E$1.API.events.push(["addPage",function(t){this.internal.getPageInfo(t.pageNumber).pageContext.annotations=[];}]),t.events.push(["putPage",function(t){for(var r,n,i,a=this.internal.getCoordinateString,o=this.internal.getVerticalCoordinateString,s=this.internal.getPageInfoByObjId(t.objId),c=t.pageContext.annotations,u=!1,h=0;h<c.length&&!u;h++)switch((r=c[h]).type){case"link":(e(r.options.url)||e(r.options.pageNumber))&&(u=!0);break;case"reference":case"text":case"freetext":u=!0;}if(0!=u){this.internal.write("/Annots [");for(var l=0;l<c.length;l++){r=c[l];var f=this.internal.pdfEscape,d=this.internal.getEncryptor(t.objId);switch(r.type){case"reference":this.internal.write(" "+r.object.objId+" 0 R ");break;case"text":var p=this.internal.newAdditionalObject(),g=this.internal.newAdditionalObject(),m=this.internal.getEncryptor(p.objId),v=r.title||"Note";i="<</Type /Annot /Subtype /Text "+(n="/Rect ["+a(r.bounds.x)+" "+o(r.bounds.y+r.bounds.h)+" "+a(r.bounds.x+r.bounds.w)+" "+o(r.bounds.y)+"] ")+"/Contents ("+f(m(r.contents))+")",i+=" /Popup "+g.objId+" 0 R",i+=" /P "+s.objId+" 0 R",i+=" /T ("+f(m(v))+") >>",p.content=i;var b=p.objId+" 0 R";i="<</Type /Annot /Subtype /Popup "+(n="/Rect ["+a(r.bounds.x+30)+" "+o(r.bounds.y+r.bounds.h)+" "+a(r.bounds.x+r.bounds.w+30)+" "+o(r.bounds.y)+"] ")+" /Parent "+b,r.open&&(i+=" /Open true"),i+=" >>",g.content=i,this.internal.write(p.objId,"0 R",g.objId,"0 R");break;case"freetext":n="/Rect ["+a(r.bounds.x)+" "+o(r.bounds.y)+" "+a(r.bounds.x+r.bounds.w)+" "+o(r.bounds.y+r.bounds.h)+"] ";var y=r.color||"#000000";i="<</Type /Annot /Subtype /FreeText "+n+"/Contents ("+f(d(r.contents))+")",i+=" /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#"+y+")",i+=" /Border [0 0 0]",i+=" >>",this.internal.write(i);break;case"link":if(r.options.name){var w=this.annotations._nameMap[r.options.name];r.options.pageNumber=w.page,r.options.top=w.y;}else r.options.top||(r.options.top=0);if(n="/Rect ["+r.finalBounds.x+" "+r.finalBounds.y+" "+r.finalBounds.w+" "+r.finalBounds.h+"] ",i="",r.options.url)i="<</Type /Annot /Subtype /Link "+n+"/Border [0 0 0] /A <</S /URI /URI ("+f(d(r.options.url))+") >>";else if(r.options.pageNumber){switch(i="<</Type /Annot /Subtype /Link "+n+"/Border [0 0 0] /Dest ["+this.internal.getPageInfo(r.options.pageNumber).objId+" 0 R",r.options.magFactor=r.options.magFactor||"XYZ",r.options.magFactor){case"Fit":i+=" /Fit]";break;case"FitH":i+=" /FitH "+r.options.top+"]";break;case"FitV":r.options.left=r.options.left||0,i+=" /FitV "+r.options.left+"]";break;case"XYZ":default:var N=o(r.options.top);r.options.left=r.options.left||0,void 0===r.options.zoom&&(r.options.zoom=0),i+=" /XYZ "+r.options.left+" "+N+" "+r.options.zoom+"]";}}""!=i&&(i+=" >>",this.internal.write(i));}}this.internal.write("]");}}]),t.createAnnotation=function(t){var e=this.internal.getCurrentPageInfo();switch(t.type){case"link":this.link(t.bounds.x,t.bounds.y,t.bounds.w,t.bounds.h,t);break;case"text":case"freetext":e.pageContext.annotations.push(t);}},t.link=function(t,e,r,n,i){var a=this.internal.getCurrentPageInfo(),o=this.internal.getCoordinateString,s=this.internal.getVerticalCoordinateString;a.pageContext.annotations.push({finalBounds:{x:o(t),y:s(e),w:o(t+r),h:s(e+n)},options:i,type:"link"});},t.textWithLink=function(t,e,r,n){var i,a,o=this.getTextWidth(t),s=this.internal.getLineHeight()/this.internal.scaleFactor;if(void 0!==n.maxWidth){a=n.maxWidth;var c=this.splitTextToSize(t,a).length;i=Math.ceil(s*c);}else a=o,i=s;return this.text(t,e,r,n),r+=.2*s,"center"===n.align&&(e-=o/2),"right"===n.align&&(e-=o),this.link(e,r-s,a,i,n),o},t.getTextWidth=function(t){var e=this.internal.getFontSize();return this.getStringUnitWidth(t)*e/this.internal.scaleFactor};}(E$1.API),
  /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e={1569:[65152],1570:[65153,65154],1571:[65155,65156],1572:[65157,65158],1573:[65159,65160],1574:[65161,65162,65163,65164],1575:[65165,65166],1576:[65167,65168,65169,65170],1577:[65171,65172],1578:[65173,65174,65175,65176],1579:[65177,65178,65179,65180],1580:[65181,65182,65183,65184],1581:[65185,65186,65187,65188],1582:[65189,65190,65191,65192],1583:[65193,65194],1584:[65195,65196],1585:[65197,65198],1586:[65199,65200],1587:[65201,65202,65203,65204],1588:[65205,65206,65207,65208],1589:[65209,65210,65211,65212],1590:[65213,65214,65215,65216],1591:[65217,65218,65219,65220],1592:[65221,65222,65223,65224],1593:[65225,65226,65227,65228],1594:[65229,65230,65231,65232],1601:[65233,65234,65235,65236],1602:[65237,65238,65239,65240],1603:[65241,65242,65243,65244],1604:[65245,65246,65247,65248],1605:[65249,65250,65251,65252],1606:[65253,65254,65255,65256],1607:[65257,65258,65259,65260],1608:[65261,65262],1609:[65263,65264,64488,64489],1610:[65265,65266,65267,65268],1649:[64336,64337],1655:[64477],1657:[64358,64359,64360,64361],1658:[64350,64351,64352,64353],1659:[64338,64339,64340,64341],1662:[64342,64343,64344,64345],1663:[64354,64355,64356,64357],1664:[64346,64347,64348,64349],1667:[64374,64375,64376,64377],1668:[64370,64371,64372,64373],1670:[64378,64379,64380,64381],1671:[64382,64383,64384,64385],1672:[64392,64393],1676:[64388,64389],1677:[64386,64387],1678:[64390,64391],1681:[64396,64397],1688:[64394,64395],1700:[64362,64363,64364,64365],1702:[64366,64367,64368,64369],1705:[64398,64399,64400,64401],1709:[64467,64468,64469,64470],1711:[64402,64403,64404,64405],1713:[64410,64411,64412,64413],1715:[64406,64407,64408,64409],1722:[64414,64415],1723:[64416,64417,64418,64419],1726:[64426,64427,64428,64429],1728:[64420,64421],1729:[64422,64423,64424,64425],1733:[64480,64481],1734:[64473,64474],1735:[64471,64472],1736:[64475,64476],1737:[64482,64483],1739:[64478,64479],1740:[64508,64509,64510,64511],1744:[64484,64485,64486,64487],1746:[64430,64431],1747:[64432,64433]},r={65247:{65154:65269,65156:65271,65160:65273,65166:65275},65248:{65154:65270,65156:65272,65160:65274,65166:65276},65165:{65247:{65248:{65258:65010}}},1617:{1612:64606,1613:64607,1614:64608,1615:64609,1616:64610}},n={1612:64606,1613:64607,1614:64608,1615:64609,1616:64610},i=[1570,1571,1573,1575];t.__arabicParser__={};var a=t.__arabicParser__.isInArabicSubstitutionA=function(t){return void 0!==e[t.charCodeAt(0)]},o=t.__arabicParser__.isArabicLetter=function(t){return "string"==typeof t&&/^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t)},s=t.__arabicParser__.isArabicEndLetter=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length<=2},c=t.__arabicParser__.isArabicAlfLetter=function(t){return o(t)&&i.indexOf(t.charCodeAt(0))>=0};t.__arabicParser__.arabicLetterHasIsolatedForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=1};var u=t.__arabicParser__.arabicLetterHasFinalForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=2};t.__arabicParser__.arabicLetterHasInitialForm=function(t){return o(t)&&a(t)&&e[t.charCodeAt(0)].length>=3};var h=t.__arabicParser__.arabicLetterHasMedialForm=function(t){return o(t)&&a(t)&&4==e[t.charCodeAt(0)].length},l=t.__arabicParser__.resolveLigatures=function(t){var e=0,n=r,i="",a=0;for(e=0;e<t.length;e+=1)void 0!==n[t.charCodeAt(e)]?(a++,"number"==typeof(n=n[t.charCodeAt(e)])&&(i+=String.fromCharCode(n),n=r,a=0),e===t.length-1&&(n=r,i+=t.charAt(e-(a-1)),e-=a-1,a=0)):(n=r,i+=t.charAt(e-a),e-=a,a=0);return i};t.__arabicParser__.isArabicDiacritic=function(t){return void 0!==t&&void 0!==n[t.charCodeAt(0)]};var f=t.__arabicParser__.getCorrectForm=function(t,e,r){return o(t)?!1===a(t)?-1:!u(t)||!o(e)&&!o(r)||!o(r)&&s(e)||s(t)&&!o(e)||s(t)&&c(e)||s(t)&&s(e)?0:h(t)&&o(e)&&!s(e)&&o(r)&&u(r)?3:s(t)||!o(r)?1:2:-1},d=function(t){var r=0,n=0,i=0,a="",s="",c="",u=(t=t||"").split("\\s+"),h=[];for(r=0;r<u.length;r+=1){for(h.push(""),n=0;n<u[r].length;n+=1)a=u[r][n],s=u[r][n-1],c=u[r][n+1],o(a)?(i=f(a,s,c),h[r]+=-1!==i?String.fromCharCode(e[a.charCodeAt(0)][i]):a):h[r]+=a;h[r]=l(h[r]);}return h.join(" ")},p=t.__arabicParser__.processArabic=t.processArabic=function(){var t,e="string"==typeof arguments[0]?arguments[0]:arguments[0].text,r=[];if(Array.isArray(e)){var n=0;for(r=[],n=0;n<e.length;n+=1)Array.isArray(e[n])?r.push([d(e[n][0]),e[n][1],e[n][2]]):r.push([d(e[n])]);t=r;}else t=d(e);return "string"==typeof arguments[0]?t:(arguments[0].text=t,arguments[0])};t.events.push(["preProcessText",p]);}(E$1.API),E$1.API.autoPrint=function(t){var e;switch((t=t||{}).variant=t.variant||"non-conform",t.variant){case"javascript":this.addJS("print({});");break;case"non-conform":default:this.internal.events.subscribe("postPutResources",(function(){e=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /Named"),this.internal.out("/Type /Action"),this.internal.out("/N /Print"),this.internal.out(">>"),this.internal.out("endobj");})),this.internal.events.subscribe("putCatalog",(function(){this.internal.out("/OpenAction "+e+" 0 R");}));}return this},
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(){var t=void 0;Object.defineProperty(this,"pdf",{get:function(){return t},set:function(e){t=e;}});var e=150;Object.defineProperty(this,"width",{get:function(){return e},set:function(t){e=isNaN(t)||!1===Number.isInteger(t)||t<0?150:t,this.getContext("2d").pageWrapXEnabled&&(this.getContext("2d").pageWrapX=e+1);}});var r=300;Object.defineProperty(this,"height",{get:function(){return r},set:function(t){r=isNaN(t)||!1===Number.isInteger(t)||t<0?300:t,this.getContext("2d").pageWrapYEnabled&&(this.getContext("2d").pageWrapY=r+1);}});var n=[];Object.defineProperty(this,"childNodes",{get:function(){return n},set:function(t){n=t;}});var i={};Object.defineProperty(this,"style",{get:function(){return i},set:function(t){i=t;}}),Object.defineProperty(this,"parentNode",{});};e.prototype.getContext=function(t,e){var r;if("2d"!==(t=t||"2d"))return null;for(r in e)this.pdf.context2d.hasOwnProperty(r)&&(this.pdf.context2d[r]=e[r]);return this.pdf.context2d._canvas=this,this.pdf.context2d},e.prototype.toDataURL=function(){throw new Error("toDataURL is not implemented.")},t.events.push(["initialized",function(){this.canvas=new e,this.canvas.pdf=this;}]);}(E$1.API),function(e){var r={left:0,top:0,bottom:0,right:0},n=!1,i=function(){void 0===this.internal.__cell__&&(this.internal.__cell__={},this.internal.__cell__.padding=3,this.internal.__cell__.headerFunction=void 0,this.internal.__cell__.margins=Object.assign({},r),this.internal.__cell__.margins.width=this.getPageWidth(),a.call(this));},a=function(){this.internal.__cell__.lastCell=new o,this.internal.__cell__.pages=1;},o=function(){var t=arguments[0];Object.defineProperty(this,"x",{enumerable:!0,get:function(){return t},set:function(e){t=e;}});var e=arguments[1];Object.defineProperty(this,"y",{enumerable:!0,get:function(){return e},set:function(t){e=t;}});var r=arguments[2];Object.defineProperty(this,"width",{enumerable:!0,get:function(){return r},set:function(t){r=t;}});var n=arguments[3];Object.defineProperty(this,"height",{enumerable:!0,get:function(){return n},set:function(t){n=t;}});var i=arguments[4];Object.defineProperty(this,"text",{enumerable:!0,get:function(){return i},set:function(t){i=t;}});var a=arguments[5];Object.defineProperty(this,"lineNumber",{enumerable:!0,get:function(){return a},set:function(t){a=t;}});var o=arguments[6];return Object.defineProperty(this,"align",{enumerable:!0,get:function(){return o},set:function(t){o=t;}}),this};o.prototype.clone=function(){return new o(this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align)},o.prototype.toArray=function(){return [this.x,this.y,this.width,this.height,this.text,this.lineNumber,this.align]},e.setHeaderFunction=function(t){return i.call(this),this.internal.__cell__.headerFunction="function"==typeof t?t:void 0,this},e.getTextDimensions=function(t,e){i.call(this);var r=(e=e||{}).fontSize||this.getFontSize(),n=e.font||this.getFont(),a=e.scaleFactor||this.internal.scaleFactor,o=0,s=0,c=0,u=this;if(!Array.isArray(t)&&"string"!=typeof t){if("number"!=typeof t)throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");t=String(t);}var h=e.maxWidth;h>0?"string"==typeof t?t=this.splitTextToSize(t,h):"[object Array]"===Object.prototype.toString.call(t)&&(t=t.reduce((function(t,e){return t.concat(u.splitTextToSize(e,h))}),[])):t=Array.isArray(t)?t:[t];for(var l=0;l<t.length;l++)o<(c=this.getStringUnitWidth(t[l],{font:n})*r)&&(o=c);return 0!==o&&(s=t.length),{w:o/=a,h:Math.max((s*r*this.getLineHeightFactor()-r*(this.getLineHeightFactor()-1))/a,0)}},e.cellAddPage=function(){i.call(this),this.addPage();var t=this.internal.__cell__.margins||r;return this.internal.__cell__.lastCell=new o(t.left,t.top,void 0,void 0),this.internal.__cell__.pages+=1,this};var s=e.cell=function(){var t;t=arguments[0]instanceof o?arguments[0]:new o(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5]),i.call(this);var e=this.internal.__cell__.lastCell,a=this.internal.__cell__.padding,s=this.internal.__cell__.margins||r,c=this.internal.__cell__.tableHeaderRow,u=this.internal.__cell__.printHeaders;return void 0!==e.lineNumber&&(e.lineNumber===t.lineNumber?(t.x=(e.x||0)+(e.width||0),t.y=e.y||0):e.y+e.height+t.height+s.bottom>this.getPageHeight()?(this.cellAddPage(),t.y=s.top,u&&c&&(this.printHeaderRow(t.lineNumber,!0),t.y+=c[0].height)):t.y=e.y+e.height||t.y),void 0!==t.text[0]&&(this.rect(t.x,t.y,t.width,t.height,!0===n?"FD":void 0),"right"===t.align?this.text(t.text,t.x+t.width-a,t.y+a,{align:"right",baseline:"top"}):"center"===t.align?this.text(t.text,t.x+t.width/2,t.y+a,{align:"center",baseline:"top",maxWidth:t.width-a-a}):this.text(t.text,t.x+a,t.y+a,{align:"left",baseline:"top",maxWidth:t.width-a-a})),this.internal.__cell__.lastCell=t,this};e.table=function(e,n,u,h,l){if(i.call(this),!u)throw new Error("No data for PDF table.");var f,d,p,g,m=[],v=[],b=[],y={},w={},N=[],L=[],A=(l=l||{}).autoSize||!1,x=!1!==l.printHeaders,S=l.css&&void 0!==l.css["font-size"]?16*l.css["font-size"]:l.fontSize||12,_=l.margins||Object.assign({width:this.getPageWidth()},r),P="number"==typeof l.padding?l.padding:3,k=l.headerBackgroundColor||"#c8c8c8",I=l.headerTextColor||"#000";if(a.call(this),this.internal.__cell__.printHeaders=x,this.internal.__cell__.margins=_,this.internal.__cell__.table_font_size=S,this.internal.__cell__.padding=P,this.internal.__cell__.headerBackgroundColor=k,this.internal.__cell__.headerTextColor=I,this.setFontSize(S),null==h)v=m=Object.keys(u[0]),b=m.map((function(){return "left"}));else if(Array.isArray(h)&&"object"===_typeof$2(h[0]))for(m=h.map((function(t){return t.name})),v=h.map((function(t){return t.prompt||t.name||""})),b=h.map((function(t){return t.align||"left"})),f=0;f<h.length;f+=1)w[h[f].name]=h[f].width*(19.049976/25.4);else Array.isArray(h)&&"string"==typeof h[0]&&(v=m=h,b=m.map((function(){return "left"})));if(A||Array.isArray(h)&&"string"==typeof h[0])for(f=0;f<m.length;f+=1){for(y[g=m[f]]=u.map((function(t){return t[g]})),this.setFont(void 0,"bold"),N.push(this.getTextDimensions(v[f],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w),d=y[g],this.setFont(void 0,"normal"),p=0;p<d.length;p+=1)N.push(this.getTextDimensions(d[p],{fontSize:this.internal.__cell__.table_font_size,scaleFactor:this.internal.scaleFactor}).w);w[g]=Math.max.apply(null,N)+P+P,N=[];}if(x){var F={};for(f=0;f<m.length;f+=1)F[m[f]]={},F[m[f]].text=v[f],F[m[f]].align=b[f];var C=c.call(this,F,w);L=m.map((function(t){return new o(e,n,w[t],C,F[t].text,void 0,F[t].align)})),this.setTableHeaderRow(L),this.printHeaderRow(1,!1);}var j=h.reduce((function(t,e){return t[e.name]=e.align,t}),{});for(f=0;f<u.length;f+=1){"rowStart"in l&&l.rowStart instanceof Function&&l.rowStart({row:f,data:u[f]},this);var O=c.call(this,u[f],w);for(p=0;p<m.length;p+=1){var B=u[f][m[p]];"cellStart"in l&&l.cellStart instanceof Function&&l.cellStart({row:f,col:p,data:B},this),s.call(this,new o(e,n,w[m[p]],O,B,f+2,j[m[p]]));}}return this.internal.__cell__.table_x=e,this.internal.__cell__.table_y=n,this};var c=function(t,e){var r=this.internal.__cell__.padding,n=this.internal.__cell__.table_font_size,i=this.internal.scaleFactor;return Object.keys(t).map((function(n){var i=t[n];return this.splitTextToSize(i.hasOwnProperty("text")?i.text:i,e[n]-r-r)}),this).map((function(t){return this.getLineHeightFactor()*t.length*n/i+r+r}),this).reduce((function(t,e){return Math.max(t,e)}),0)};e.setTableHeaderRow=function(t){i.call(this),this.internal.__cell__.tableHeaderRow=t;},e.printHeaderRow=function(t,e){if(i.call(this),!this.internal.__cell__.tableHeaderRow)throw new Error("Property tableHeaderRow does not exist.");var r;if(n=!0,"function"==typeof this.internal.__cell__.headerFunction){var a=this.internal.__cell__.headerFunction(this,this.internal.__cell__.pages);this.internal.__cell__.lastCell=new o(a[0],a[1],a[2],a[3],void 0,-1);}this.setFont(void 0,"bold");for(var c=[],u=0;u<this.internal.__cell__.tableHeaderRow.length;u+=1){r=this.internal.__cell__.tableHeaderRow[u].clone(),e&&(r.y=this.internal.__cell__.margins.top||0,c.push(r)),r.lineNumber=t;var h=this.getTextColor();this.setTextColor(this.internal.__cell__.headerTextColor),this.setFillColor(this.internal.__cell__.headerBackgroundColor),s.call(this,r),this.setTextColor(h);}c.length>0&&this.setTableHeaderRow(c),this.setFont(void 0,"normal"),n=!1;};}(E$1.API);var Pt={italic:["italic","oblique","normal"],oblique:["oblique","italic","normal"],normal:["normal","oblique","italic"]},kt=["ultra-condensed","extra-condensed","condensed","semi-condensed","normal","semi-expanded","expanded","extra-expanded","ultra-expanded"],It=_t(kt),Ft=[100,200,300,400,500,600,700,800,900],Ct=_t(Ft);function jt(t){var e=t.family.replace(/"|'/g,"").toLowerCase(),r=function(t){return Pt[t=t||"normal"]?t:"normal"}(t.style),n=function(t){if(!t)return 400;if("number"==typeof t)return t>=100&&t<=900&&t%100==0?t:400;if(/^\d00$/.test(t))return parseInt(t);switch(t){case"bold":return 700;case"normal":default:return 400}}(t.weight),i=function(t){return "number"==typeof It[t=t||"normal"]?t:"normal"}(t.stretch);return {family:e,style:r,weight:n,stretch:i,src:t.src||[],ref:t.ref||{name:e,style:[i,r,n].join(" ")}}}function Ot(t,e,r,n){var i;for(i=r;i>=0&&i<e.length;i+=n)if(t[e[i]])return t[e[i]];for(i=r;i>=0&&i<e.length;i-=n)if(t[e[i]])return t[e[i]]}var Bt={"sans-serif":"helvetica",fixed:"courier",monospace:"courier",terminal:"courier",cursive:"times",fantasy:"times",serif:"times"},Mt={caption:"times",icon:"times",menu:"times","message-box":"times","small-caption":"times","status-bar":"times"};function Et(t){return [t.stretch,t.style,t.weight,t.family].join(" ")}function qt(t,e,r){for(var n=(r=r||{}).defaultFontFamily||"times",i=Object.assign({},Bt,r.genericFontFamilies||{}),a=null,o=null,s=0;s<e.length;++s)if(i[(a=jt(e[s])).family]&&(a.family=i[a.family]),t.hasOwnProperty(a.family)){o=t[a.family];break}if(!(o=o||t[n]))throw new Error("Could not find a font-family for the rule '"+Et(a)+"' and default family '"+n+"'.");if(o=function(t,e){if(e[t])return e[t];var r=It[t],n=r<=It.normal?-1:1,i=Ot(e,kt,r,n);if(!i)throw new Error("Could not find a matching font-stretch value for "+t);return i}(a.stretch,o),o=function(t,e){if(e[t])return e[t];for(var r=Pt[t],n=0;n<r.length;++n)if(e[r[n]])return e[r[n]];throw new Error("Could not find a matching font-style for "+t)}(a.style,o),!(o=function(t,e){if(e[t])return e[t];if(400===t&&e[500])return e[500];if(500===t&&e[400])return e[400];var r=Ct[t],n=Ot(e,Ft,r,t<400?-1:1);if(!n)throw new Error("Could not find a matching font-weight for value "+t);return n}(a.weight,o)))throw new Error("Failed to resolve a font for the rule '"+Et(a)+"'.");return o}function Dt(t){return t.trimLeft()}function Rt(t,e){for(var r=0;r<t.length;){if(t.charAt(r)===e)return [t.substring(0,r),t.substring(r+1)];r+=1;}return null}function Tt(t){var e=t.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);return null===e?null:[e[0],t.substring(e[0].length)]}var Ut,zt,Ht,Wt=["times"];!function(e){var r,n,i,o,s,c,u,h,l,d=function(t){return t=t||{},this.isStrokeTransparent=t.isStrokeTransparent||!1,this.strokeOpacity=t.strokeOpacity||1,this.strokeStyle=t.strokeStyle||"#000000",this.fillStyle=t.fillStyle||"#000000",this.isFillTransparent=t.isFillTransparent||!1,this.fillOpacity=t.fillOpacity||1,this.font=t.font||"10px sans-serif",this.textBaseline=t.textBaseline||"alphabetic",this.textAlign=t.textAlign||"left",this.lineWidth=t.lineWidth||1,this.lineJoin=t.lineJoin||"miter",this.lineCap=t.lineCap||"butt",this.path=t.path||[],this.transform=void 0!==t.transform?t.transform.clone():new h,this.globalCompositeOperation=t.globalCompositeOperation||"normal",this.globalAlpha=t.globalAlpha||1,this.clip_path=t.clip_path||[],this.currentPoint=t.currentPoint||new c,this.miterLimit=t.miterLimit||10,this.lastPoint=t.lastPoint||new c,this.lineDashOffset=t.lineDashOffset||0,this.lineDash=t.lineDash||[],this.margin=t.margin||[0,0,0,0],this.prevPageLastElemOffset=t.prevPageLastElemOffset||0,this.ignoreClearRect="boolean"!=typeof t.ignoreClearRect||t.ignoreClearRect,this};e.events.push(["initialized",function(){this.context2d=new p(this),r=this.internal.f2,n=this.internal.getCoordinateString,i=this.internal.getVerticalCoordinateString,o=this.internal.getHorizontalCoordinate,s=this.internal.getVerticalCoordinate,c=this.internal.Point,u=this.internal.Rectangle,h=this.internal.Matrix,l=new d;}]);var p=function(t){Object.defineProperty(this,"canvas",{get:function(){return {parentNode:!1,style:!1}}});var e=t;Object.defineProperty(this,"pdf",{get:function(){return e}});var r=!1;Object.defineProperty(this,"pageWrapXEnabled",{get:function(){return r},set:function(t){r=Boolean(t);}});var n=!1;Object.defineProperty(this,"pageWrapYEnabled",{get:function(){return n},set:function(t){n=Boolean(t);}});var i=0;Object.defineProperty(this,"posX",{get:function(){return i},set:function(t){isNaN(t)||(i=t);}});var a=0;Object.defineProperty(this,"posY",{get:function(){return a},set:function(t){isNaN(t)||(a=t);}}),Object.defineProperty(this,"margin",{get:function(){return l.margin},set:function(t){var e;"number"==typeof t?e=[t,t,t,t]:((e=new Array(4))[0]=t[0],e[1]=t.length>=2?t[1]:e[0],e[2]=t.length>=3?t[2]:e[0],e[3]=t.length>=4?t[3]:e[1]),l.margin=e;}});var o=!1;Object.defineProperty(this,"autoPaging",{get:function(){return o},set:function(t){o=t;}});var s=0;Object.defineProperty(this,"lastBreak",{get:function(){return s},set:function(t){s=t;}});var c=[];Object.defineProperty(this,"pageBreaks",{get:function(){return c},set:function(t){c=t;}}),Object.defineProperty(this,"ctx",{get:function(){return l},set:function(t){t instanceof d&&(l=t);}}),Object.defineProperty(this,"path",{get:function(){return l.path},set:function(t){l.path=t;}});var u=[];Object.defineProperty(this,"ctxStack",{get:function(){return u},set:function(t){u=t;}}),Object.defineProperty(this,"fillStyle",{get:function(){return this.ctx.fillStyle},set:function(t){var e;e=g(t),this.ctx.fillStyle=e.style,this.ctx.isFillTransparent=0===e.a,this.ctx.fillOpacity=e.a,this.pdf.setFillColor(e.r,e.g,e.b,{a:e.a}),this.pdf.setTextColor(e.r,e.g,e.b,{a:e.a});}}),Object.defineProperty(this,"strokeStyle",{get:function(){return this.ctx.strokeStyle},set:function(t){var e=g(t);this.ctx.strokeStyle=e.style,this.ctx.isStrokeTransparent=0===e.a,this.ctx.strokeOpacity=e.a,0===e.a?this.pdf.setDrawColor(255,255,255):(e.a,this.pdf.setDrawColor(e.r,e.g,e.b));}}),Object.defineProperty(this,"lineCap",{get:function(){return this.ctx.lineCap},set:function(t){-1!==["butt","round","square"].indexOf(t)&&(this.ctx.lineCap=t,this.pdf.setLineCap(t));}}),Object.defineProperty(this,"lineWidth",{get:function(){return this.ctx.lineWidth},set:function(t){isNaN(t)||(this.ctx.lineWidth=t,this.pdf.setLineWidth(t));}}),Object.defineProperty(this,"lineJoin",{get:function(){return this.ctx.lineJoin},set:function(t){-1!==["bevel","round","miter"].indexOf(t)&&(this.ctx.lineJoin=t,this.pdf.setLineJoin(t));}}),Object.defineProperty(this,"miterLimit",{get:function(){return this.ctx.miterLimit},set:function(t){isNaN(t)||(this.ctx.miterLimit=t,this.pdf.setMiterLimit(t));}}),Object.defineProperty(this,"textBaseline",{get:function(){return this.ctx.textBaseline},set:function(t){this.ctx.textBaseline=t;}}),Object.defineProperty(this,"textAlign",{get:function(){return this.ctx.textAlign},set:function(t){-1!==["right","end","center","left","start"].indexOf(t)&&(this.ctx.textAlign=t);}});var h=null;function f(t,e){if(null===h){var r=function(t){var e=[];return Object.keys(t).forEach((function(r){t[r].forEach((function(t){var n=null;switch(t){case"bold":n={family:r,weight:"bold"};break;case"italic":n={family:r,style:"italic"};break;case"bolditalic":n={family:r,weight:"bold",style:"italic"};break;case"":case"normal":n={family:r};}null!==n&&(n.ref={name:r,style:t},e.push(n));}));})),e}(t.getFontList());h=function(t){for(var e={},r=0;r<t.length;++r){var n=jt(t[r]),i=n.family,a=n.stretch,o=n.style,s=n.weight;e[i]=e[i]||{},e[i][a]=e[i][a]||{},e[i][a][o]=e[i][a][o]||{},e[i][a][o][s]=n;}return e}(r.concat(e));}return h}var p=null;Object.defineProperty(this,"fontFaces",{get:function(){return p},set:function(t){h=null,p=t;}}),Object.defineProperty(this,"font",{get:function(){return this.ctx.font},set:function(t){var e;if(this.ctx.font=t,null!==(e=/^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t))){var r=e[1],n=(e[2],e[3]),i=e[4],a=(e[5],e[6]),o=/^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i)[2];i="px"===o?Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor):"em"===o?Math.floor(parseFloat(i)*this.pdf.getFontSize()):Math.floor(parseFloat(i)*this.pdf.internal.scaleFactor),this.pdf.setFontSize(i);var s=function(t){var e,r,n=[],i=t.trim();if(""===i)return Wt;if(i in Mt)return [Mt[i]];for(;""!==i;){switch(r=null,e=(i=Dt(i)).charAt(0)){case'"':case"'":r=Rt(i.substring(1),e);break;default:r=Tt(i);}if(null===r)return Wt;if(n.push(r[0]),""!==(i=Dt(r[1]))&&","!==i.charAt(0))return Wt;i=i.replace(/^,/,"");}return n}(a);if(this.fontFaces){var c=qt(f(this.pdf,this.fontFaces),s.map((function(t){return {family:t,stretch:"normal",weight:n,style:r}})));this.pdf.setFont(c.ref.name,c.ref.style);}else {var u="";("bold"===n||parseInt(n,10)>=700||"bold"===r)&&(u="bold"),"italic"===r&&(u+="italic"),0===u.length&&(u="normal");for(var h="",l={arial:"Helvetica",Arial:"Helvetica",verdana:"Helvetica",Verdana:"Helvetica",helvetica:"Helvetica",Helvetica:"Helvetica","sans-serif":"Helvetica",fixed:"Courier",monospace:"Courier",terminal:"Courier",cursive:"Times",fantasy:"Times",serif:"Times"},d=0;d<s.length;d++){if(void 0!==this.pdf.internal.getFont(s[d],u,{noFallback:!0,disableWarning:!0})){h=s[d];break}if("bolditalic"===u&&void 0!==this.pdf.internal.getFont(s[d],"bold",{noFallback:!0,disableWarning:!0}))h=s[d],u="bold";else if(void 0!==this.pdf.internal.getFont(s[d],"normal",{noFallback:!0,disableWarning:!0})){h=s[d],u="normal";break}}if(""===h)for(var p=0;p<s.length;p++)if(l[s[p]]){h=l[s[p]];break}h=""===h?"Times":h,this.pdf.setFont(h,u);}}}}),Object.defineProperty(this,"globalCompositeOperation",{get:function(){return this.ctx.globalCompositeOperation},set:function(t){this.ctx.globalCompositeOperation=t;}}),Object.defineProperty(this,"globalAlpha",{get:function(){return this.ctx.globalAlpha},set:function(t){this.ctx.globalAlpha=t;}}),Object.defineProperty(this,"lineDashOffset",{get:function(){return this.ctx.lineDashOffset},set:function(t){this.ctx.lineDashOffset=t,T.call(this);}}),Object.defineProperty(this,"lineDash",{get:function(){return this.ctx.lineDash},set:function(t){this.ctx.lineDash=t,T.call(this);}}),Object.defineProperty(this,"ignoreClearRect",{get:function(){return this.ctx.ignoreClearRect},set:function(t){this.ctx.ignoreClearRect=Boolean(t);}});};p.prototype.setLineDash=function(t){this.lineDash=t;},p.prototype.getLineDash=function(){return this.lineDash.length%2?this.lineDash.concat(this.lineDash):this.lineDash.slice()},p.prototype.fill=function(){A.call(this,"fill",!1);},p.prototype.stroke=function(){A.call(this,"stroke",!1);},p.prototype.beginPath=function(){this.path=[{type:"begin"}];},p.prototype.moveTo=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.moveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.moveTo");var r=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"mt",x:r.x,y:r.y}),this.ctx.lastPoint=new c(t,e);},p.prototype.closePath=function(){var e=new c(0,0),r=0;for(r=this.path.length-1;-1!==r;r--)if("begin"===this.path[r].type&&"object"===_typeof$2(this.path[r+1])&&"number"==typeof this.path[r+1].x){e=new c(this.path[r+1].x,this.path[r+1].y);break}this.path.push({type:"close"}),this.ctx.lastPoint=new c(e.x,e.y);},p.prototype.lineTo=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.lineTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.lineTo");var r=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"lt",x:r.x,y:r.y}),this.ctx.lastPoint=new c(r.x,r.y);},p.prototype.clip=function(){this.ctx.clip_path=JSON.parse(JSON.stringify(this.path)),A.call(this,null,!0);},p.prototype.quadraticCurveTo=function(t,e,r,n){if(isNaN(r)||isNaN(n)||isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");var i=this.ctx.transform.applyToPoint(new c(r,n)),o=this.ctx.transform.applyToPoint(new c(t,e));this.path.push({type:"qct",x1:o.x,y1:o.y,x:i.x,y:i.y}),this.ctx.lastPoint=new c(i.x,i.y);},p.prototype.bezierCurveTo=function(t,e,r,n,i,o){if(isNaN(i)||isNaN(o)||isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.bezierCurveTo: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");var s=this.ctx.transform.applyToPoint(new c(i,o)),u=this.ctx.transform.applyToPoint(new c(t,e)),h=this.ctx.transform.applyToPoint(new c(r,n));this.path.push({type:"bct",x1:u.x,y1:u.y,x2:h.x,y2:h.y,x:s.x,y:s.y}),this.ctx.lastPoint=new c(s.x,s.y);},p.prototype.arc=function(t,e,r,n,i,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i))throw a$2.error("jsPDF.context2d.arc: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.arc");if(o=Boolean(o),!this.ctx.transform.isIdentity){var s=this.ctx.transform.applyToPoint(new c(t,e));t=s.x,e=s.y;var u=this.ctx.transform.applyToPoint(new c(0,r)),h=this.ctx.transform.applyToPoint(new c(0,0));r=Math.sqrt(Math.pow(u.x-h.x,2)+Math.pow(u.y-h.y,2));}Math.abs(i-n)>=2*Math.PI&&(n=0,i=2*Math.PI),this.path.push({type:"arc",x:t,y:e,radius:r,startAngle:n,endAngle:i,counterclockwise:o});},p.prototype.arcTo=function(t,e,r,n,i){throw new Error("arcTo not implemented.")},p.prototype.rect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.rect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rect");this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+n),this.lineTo(t,e+n),this.lineTo(t,e),this.lineTo(t+r,e),this.lineTo(t,e);},p.prototype.fillRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.fillRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillRect");if(!m.call(this)){var i={};"butt"!==this.lineCap&&(i.lineCap=this.lineCap,this.lineCap="butt"),"miter"!==this.lineJoin&&(i.lineJoin=this.lineJoin,this.lineJoin="miter"),this.beginPath(),this.rect(t,e,r,n),this.fill(),i.hasOwnProperty("lineCap")&&(this.lineCap=i.lineCap),i.hasOwnProperty("lineJoin")&&(this.lineJoin=i.lineJoin);}},p.prototype.strokeRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.strokeRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");v.call(this)||(this.beginPath(),this.rect(t,e,r,n),this.stroke());},p.prototype.clearRect=function(t,e,r,n){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n))throw a$2.error("jsPDF.context2d.clearRect: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.clearRect");this.ignoreClearRect||(this.fillStyle="#ffffff",this.fillRect(t,e,r,n));},p.prototype.save=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,r=0;r<this.pdf.internal.getNumberOfPages();r++)this.pdf.setPage(r+1),this.pdf.internal.out("q");if(this.pdf.setPage(e),t){this.ctx.fontSize=this.pdf.internal.getFontSize();var n=new d(this.ctx);this.ctxStack.push(this.ctx),this.ctx=n;}},p.prototype.restore=function(t){t="boolean"!=typeof t||t;for(var e=this.pdf.internal.getCurrentPageInfo().pageNumber,r=0;r<this.pdf.internal.getNumberOfPages();r++)this.pdf.setPage(r+1),this.pdf.internal.out("Q");this.pdf.setPage(e),t&&0!==this.ctxStack.length&&(this.ctx=this.ctxStack.pop(),this.fillStyle=this.ctx.fillStyle,this.strokeStyle=this.ctx.strokeStyle,this.font=this.ctx.font,this.lineCap=this.ctx.lineCap,this.lineWidth=this.ctx.lineWidth,this.lineJoin=this.ctx.lineJoin,this.lineDash=this.ctx.lineDash,this.lineDashOffset=this.ctx.lineDashOffset);},p.prototype.toDataURL=function(){throw new Error("toDataUrl not implemented.")};var g=function(t){var e,r,n,i;if(!0===t.isCanvasGradient&&(t=t.getColor()),!t)return {r:0,g:0,b:0,a:0,style:t};if(/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t))e=0,r=0,n=0,i=0;else {var a=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t);if(null!==a)e=parseInt(a[1]),r=parseInt(a[2]),n=parseInt(a[3]),i=1;else if(null!==(a=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t)))e=parseInt(a[1]),r=parseInt(a[2]),n=parseInt(a[3]),i=parseFloat(a[4]);else {if(i=1,"string"==typeof t&&"#"!==t.charAt(0)){var o=new f$2(t);t=o.ok?o.toHex():"#000000";}4===t.length?(e=t.substring(1,2),e+=e,r=t.substring(2,3),r+=r,n=t.substring(3,4),n+=n):(e=t.substring(1,3),r=t.substring(3,5),n=t.substring(5,7)),e=parseInt(e,16),r=parseInt(r,16),n=parseInt(n,16);}}return {r:e,g:r,b:n,a:i,style:t}},m=function(){return this.ctx.isFillTransparent||0==this.globalAlpha},v=function(){return Boolean(this.ctx.isStrokeTransparent||0==this.globalAlpha)};p.prototype.fillText=function(t,e,r,n){if(isNaN(e)||isNaN(r)||"string"!=typeof t)throw a$2.error("jsPDF.context2d.fillText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.fillText");if(n=isNaN(n)?void 0:n,!m.call(this)){var i=q(this.ctx.transform.rotation),o=this.ctx.transform.scaleX;C.call(this,{text:t,x:e,y:r,scale:o,angle:i,align:this.textAlign,maxWidth:n});}},p.prototype.strokeText=function(t,e,r,n){if(isNaN(e)||isNaN(r)||"string"!=typeof t)throw a$2.error("jsPDF.context2d.strokeText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.strokeText");if(!v.call(this)){n=isNaN(n)?void 0:n;var i=q(this.ctx.transform.rotation),o=this.ctx.transform.scaleX;C.call(this,{text:t,x:e,y:r,scale:o,renderingMode:"stroke",angle:i,align:this.textAlign,maxWidth:n});}},p.prototype.measureText=function(t){if("string"!=typeof t)throw a$2.error("jsPDF.context2d.measureText: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.measureText");var e=this.pdf,r=this.pdf.internal.scaleFactor,n=e.internal.getFontSize(),i=e.getStringUnitWidth(t)*n/e.internal.scaleFactor,o=function(t){var e=(t=t||{}).width||0;return Object.defineProperty(this,"width",{get:function(){return e}}),this};return new o({width:i*=Math.round(96*r/72*1e4)/1e4})},p.prototype.scale=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.scale: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.scale");var r=new h(t,0,0,e,0,0);this.ctx.transform=this.ctx.transform.multiply(r);},p.prototype.rotate=function(t){if(isNaN(t))throw a$2.error("jsPDF.context2d.rotate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.rotate");var e=new h(Math.cos(t),Math.sin(t),-Math.sin(t),Math.cos(t),0,0);this.ctx.transform=this.ctx.transform.multiply(e);},p.prototype.translate=function(t,e){if(isNaN(t)||isNaN(e))throw a$2.error("jsPDF.context2d.translate: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.translate");var r=new h(1,0,0,1,t,e);this.ctx.transform=this.ctx.transform.multiply(r);},p.prototype.transform=function(t,e,r,n,i,o){if(isNaN(t)||isNaN(e)||isNaN(r)||isNaN(n)||isNaN(i)||isNaN(o))throw a$2.error("jsPDF.context2d.transform: Invalid arguments",arguments),new Error("Invalid arguments passed to jsPDF.context2d.transform");var s=new h(t,e,r,n,i,o);this.ctx.transform=this.ctx.transform.multiply(s);},p.prototype.setTransform=function(t,e,r,n,i,a){t=isNaN(t)?1:t,e=isNaN(e)?0:e,r=isNaN(r)?0:r,n=isNaN(n)?1:n,i=isNaN(i)?0:i,a=isNaN(a)?0:a,this.ctx.transform=new h(t,e,r,n,i,a);};var b=function(){return this.margin[0]>0||this.margin[1]>0||this.margin[2]>0||this.margin[3]>0};p.prototype.drawImage=function(t,e,r,n,i,a,o,s,c){var l=this.pdf.getImageProperties(t),f=1,d=1,p=1,g=1;void 0!==n&&void 0!==s&&(p=s/n,g=c/i,f=l.width/n*s/n,d=l.height/i*c/i),void 0===a&&(a=e,o=r,e=0,r=0),void 0!==n&&void 0===s&&(s=n,c=i),void 0===n&&void 0===s&&(s=l.width,c=l.height);for(var m,v=this.ctx.transform.decompose(),w=q(v.rotate.shx),A=new h,S=(A=(A=(A=A.multiply(v.translate)).multiply(v.skew)).multiply(v.scale)).applyToRectangle(new u(a-e*p,o-r*g,n*f,i*d)),_=y.call(this,S),P=[],k=0;k<_.length;k+=1)-1===P.indexOf(_[k])&&P.push(_[k]);if(L(P),this.autoPaging)for(var I=P[0],F=P[P.length-1],C=I;C<F+1;C++){this.pdf.setPage(C);var j=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],O=1===C?this.posY+this.margin[0]:this.margin[0],B=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],M=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],E=1===C?0:B+(C-2)*M;if(0!==this.ctx.clip_path.length){var D=this.path;m=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(m,this.posX+this.margin[3],-E+O+this.ctx.prevPageLastElemOffset),x.call(this,"fill",!0),this.path=D;}var R=JSON.parse(JSON.stringify(S));R=N([R],this.posX+this.margin[3],-E+O+this.ctx.prevPageLastElemOffset)[0];var T=(C>I||C<F)&&b.call(this);T&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],j,M,null).clip().discardPath()),this.pdf.addImage(t,"JPEG",R.x,R.y,R.w,R.h,null,null,w),T&&this.pdf.restoreGraphicsState();}else this.pdf.addImage(t,"JPEG",S.x,S.y,S.w,S.h,null,null,w);};var y=function(t,e,r){var n=[];e=e||this.pdf.internal.pageSize.width,r=r||this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2];var i=this.posY+this.ctx.prevPageLastElemOffset;switch(t.type){default:case"mt":case"lt":n.push(Math.floor((t.y+i)/r)+1);break;case"arc":n.push(Math.floor((t.y+i-t.radius)/r)+1),n.push(Math.floor((t.y+i+t.radius)/r)+1);break;case"qct":var a=D(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x,t.y);n.push(Math.floor((a.y+i)/r)+1),n.push(Math.floor((a.y+a.h+i)/r)+1);break;case"bct":var o=R(this.ctx.lastPoint.x,this.ctx.lastPoint.y,t.x1,t.y1,t.x2,t.y2,t.x,t.y);n.push(Math.floor((o.y+i)/r)+1),n.push(Math.floor((o.y+o.h+i)/r)+1);break;case"rect":n.push(Math.floor((t.y+i)/r)+1),n.push(Math.floor((t.y+t.h+i)/r)+1);}for(var s=0;s<n.length;s+=1)for(;this.pdf.internal.getNumberOfPages()<n[s];)w.call(this);return n},w=function(){var t=this.fillStyle,e=this.strokeStyle,r=this.font,n=this.lineCap,i=this.lineWidth,a=this.lineJoin;this.pdf.addPage(),this.fillStyle=t,this.strokeStyle=e,this.font=r,this.lineCap=n,this.lineWidth=i,this.lineJoin=a;},N=function(t,e,r){for(var n=0;n<t.length;n++)switch(t[n].type){case"bct":t[n].x2+=e,t[n].y2+=r;case"qct":t[n].x1+=e,t[n].y1+=r;case"mt":case"lt":case"arc":default:t[n].x+=e,t[n].y+=r;}return t},L=function(t){return t.sort((function(t,e){return t-e}))},A=function(t,e){for(var r,n,i=this.fillStyle,a=this.strokeStyle,o=this.lineCap,s=this.lineWidth,c=Math.abs(s*this.ctx.transform.scaleX),u=this.lineJoin,h=JSON.parse(JSON.stringify(this.path)),l=JSON.parse(JSON.stringify(this.path)),f=[],d=0;d<l.length;d++)if(void 0!==l[d].x)for(var p=y.call(this,l[d]),g=0;g<p.length;g+=1)-1===f.indexOf(p[g])&&f.push(p[g]);for(var m=0;m<f.length;m++)for(;this.pdf.internal.getNumberOfPages()<f[m];)w.call(this);if(L(f),this.autoPaging)for(var v=f[0],A=f[f.length-1],S=v;S<A+1;S++){this.pdf.setPage(S),this.fillStyle=i,this.strokeStyle=a,this.lineCap=o,this.lineWidth=c,this.lineJoin=u;var _=this.pdf.internal.pageSize.width-this.margin[3]-this.margin[1],P=1===S?this.posY+this.margin[0]:this.margin[0],k=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],I=this.pdf.internal.pageSize.height-this.margin[0]-this.margin[2],F=1===S?0:k+(S-2)*I;if(0!==this.ctx.clip_path.length){var C=this.path;r=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(r,this.posX+this.margin[3],-F+P+this.ctx.prevPageLastElemOffset),x.call(this,t,!0),this.path=C;}if(n=JSON.parse(JSON.stringify(h)),this.path=N(n,this.posX+this.margin[3],-F+P+this.ctx.prevPageLastElemOffset),!1===e||0===S){var j=(S>v||S<A)&&b.call(this);j&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],_,I,null).clip().discardPath()),x.call(this,t,e),j&&this.pdf.restoreGraphicsState();}this.lineWidth=s;}else this.lineWidth=c,x.call(this,t,e),this.lineWidth=s;this.path=h;},x=function(t,e){if(("stroke"!==t||e||!v.call(this))&&("stroke"===t||e||!m.call(this))){for(var r,n,i=[],a=this.path,o=0;o<a.length;o++){var s=a[o];switch(s.type){case"begin":i.push({begin:!0});break;case"close":i.push({close:!0});break;case"mt":i.push({start:s,deltas:[],abs:[]});break;case"lt":var c=i.length;if(a[o-1]&&!isNaN(a[o-1].x)&&(r=[s.x-a[o-1].x,s.y-a[o-1].y],c>0))for(;c>=0;c--)if(!0!==i[c-1].close&&!0!==i[c-1].begin){i[c-1].deltas.push(r),i[c-1].abs.push(s);break}break;case"bct":r=[s.x1-a[o-1].x,s.y1-a[o-1].y,s.x2-a[o-1].x,s.y2-a[o-1].y,s.x-a[o-1].x,s.y-a[o-1].y],i[i.length-1].deltas.push(r);break;case"qct":var u=a[o-1].x+2/3*(s.x1-a[o-1].x),h=a[o-1].y+2/3*(s.y1-a[o-1].y),l=s.x+2/3*(s.x1-s.x),f=s.y+2/3*(s.y1-s.y),d=s.x,p=s.y;r=[u-a[o-1].x,h-a[o-1].y,l-a[o-1].x,f-a[o-1].y,d-a[o-1].x,p-a[o-1].y],i[i.length-1].deltas.push(r);break;case"arc":i.push({deltas:[],abs:[],arc:!0}),Array.isArray(i[i.length-1].abs)&&i[i.length-1].abs.push(s);}}n=e?null:"stroke"===t?"stroke":"fill";for(var g=!1,b=0;b<i.length;b++)if(i[b].arc)for(var y=i[b].abs,w=0;w<y.length;w++){var N=y[w];"arc"===N.type?P.call(this,N.x,N.y,N.radius,N.startAngle,N.endAngle,N.counterclockwise,void 0,e,!g):j.call(this,N.x,N.y),g=!0;}else if(!0===i[b].close)this.pdf.internal.out("h"),g=!1;else if(!0!==i[b].begin){var L=i[b].start.x,A=i[b].start.y;O.call(this,i[b].deltas,L,A),g=!0;}n&&k.call(this,n),e&&I.call(this);}},S=function(t){var e=this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor,r=e*(this.pdf.internal.getLineHeightFactor()-1);switch(this.ctx.textBaseline){case"bottom":return t-r;case"top":return t+e-r;case"hanging":return t+e-2*r;case"middle":return t+e/2-r;case"ideographic":return t;case"alphabetic":default:return t}},_=function(t){return t+this.pdf.internal.getFontSize()/this.pdf.internal.scaleFactor*(this.pdf.internal.getLineHeightFactor()-1)};p.prototype.createLinearGradient=function(){var t=function(){};return t.colorStops=[],t.addColorStop=function(t,e){this.colorStops.push([t,e]);},t.getColor=function(){return 0===this.colorStops.length?"#000000":this.colorStops[0][1]},t.isCanvasGradient=!0,t},p.prototype.createPattern=function(){return this.createLinearGradient()},p.prototype.createRadialGradient=function(){return this.createLinearGradient()};var P=function(t,e,r,n,i,a,o,s,c){for(var u=M.call(this,r,n,i,a),h=0;h<u.length;h++){var l=u[h];0===h&&(c?F.call(this,l.x1+t,l.y1+e):j.call(this,l.x1+t,l.y1+e)),B.call(this,t,e,l.x2,l.y2,l.x3,l.y3,l.x4,l.y4);}s?I.call(this):k.call(this,o);},k=function(t){switch(t){case"stroke":this.pdf.internal.out("S");break;case"fill":this.pdf.internal.out("f");}},I=function(){this.pdf.clip(),this.pdf.discardPath();},F=function(t,e){this.pdf.internal.out(n(t)+" "+i(e)+" m");},C=function(t){var e;switch(t.align){case"right":case"end":e="right";break;case"center":e="center";break;case"left":case"start":default:e="left";}var r=this.pdf.getTextDimensions(t.text),n=S.call(this,t.y),i=_.call(this,n)-r.h,a=this.ctx.transform.applyToPoint(new c(t.x,n)),o=this.ctx.transform.decompose(),s=new h;s=(s=(s=s.multiply(o.translate)).multiply(o.skew)).multiply(o.scale);for(var l,f,d,p=this.ctx.transform.applyToRectangle(new u(t.x,n,r.w,r.h)),g=s.applyToRectangle(new u(t.x,i,r.w,r.h)),m=y.call(this,g),v=[],w=0;w<m.length;w+=1)-1===v.indexOf(m[w])&&v.push(m[w]);if(L(v),this.autoPaging)for(var A=v[0],P=v[v.length-1],k=A;k<P+1;k++){this.pdf.setPage(k);var I=1===k?this.posY+this.margin[0]:this.margin[0],F=this.pdf.internal.pageSize.height-this.posY-this.margin[0]-this.margin[2],C=this.pdf.internal.pageSize.height-this.margin[2],j=C-this.margin[0],O=this.pdf.internal.pageSize.width-this.margin[1],B=O-this.margin[3],M=1===k?0:F+(k-2)*j;if(0!==this.ctx.clip_path.length){var E=this.path;l=JSON.parse(JSON.stringify(this.ctx.clip_path)),this.path=N(l,this.posX+this.margin[3],-1*M+I),x.call(this,"fill",!0),this.path=E;}var q=N([JSON.parse(JSON.stringify(g))],this.posX+this.margin[3],-M+I+this.ctx.prevPageLastElemOffset)[0];t.scale>=.01&&(f=this.pdf.internal.getFontSize(),this.pdf.setFontSize(f*t.scale),d=this.lineWidth,this.lineWidth=d*t.scale);var D="text"!==this.autoPaging;if(D||q.y+q.h<=C){if(D||q.y>=I&&q.x<=O){var R=D?t.text:this.pdf.splitTextToSize(t.text,t.maxWidth||O-q.x)[0],T=N([JSON.parse(JSON.stringify(p))],this.posX+this.margin[3],-M+I+this.ctx.prevPageLastElemOffset)[0],U=D&&(k>A||k<P)&&b.call(this);U&&(this.pdf.saveGraphicsState(),this.pdf.rect(this.margin[3],this.margin[0],B,j,null).clip().discardPath()),this.pdf.text(R,T.x,T.y,{angle:t.angle,align:e,renderingMode:t.renderingMode}),U&&this.pdf.restoreGraphicsState();}}else q.y<C&&(this.ctx.prevPageLastElemOffset+=C-q.y);t.scale>=.01&&(this.pdf.setFontSize(f),this.lineWidth=d);}else t.scale>=.01&&(f=this.pdf.internal.getFontSize(),this.pdf.setFontSize(f*t.scale),d=this.lineWidth,this.lineWidth=d*t.scale),this.pdf.text(t.text,a.x+this.posX,a.y+this.posY,{angle:t.angle,align:e,renderingMode:t.renderingMode,maxWidth:t.maxWidth}),t.scale>=.01&&(this.pdf.setFontSize(f),this.lineWidth=d);},j=function(t,e,r,a){r=r||0,a=a||0,this.pdf.internal.out(n(t+r)+" "+i(e+a)+" l");},O=function(t,e,r){return this.pdf.lines(t,e,r,null,null)},B=function(t,e,n,i,a,c,u,h){this.pdf.internal.out([r(o(n+t)),r(s(i+e)),r(o(a+t)),r(s(c+e)),r(o(u+t)),r(s(h+e)),"c"].join(" "));},M=function(t,e,r,n){for(var i=2*Math.PI,a=Math.PI/2;e>r;)e-=i;var o=Math.abs(r-e);o<i&&n&&(o=i-o);for(var s=[],c=n?-1:1,u=e;o>1e-5;){var h=u+c*Math.min(o,a);s.push(E.call(this,t,u,h)),o-=Math.abs(h-u),u=h;}return s},E=function(t,e,r){var n=(r-e)/2,i=t*Math.cos(n),a=t*Math.sin(n),o=i,s=-a,c=o*o+s*s,u=c+o*i+s*a,h=4/3*(Math.sqrt(2*c*u)-u)/(o*a-s*i),l=o-h*s,f=s+h*o,d=l,p=-f,g=n+e,m=Math.cos(g),v=Math.sin(g);return {x1:t*Math.cos(e),y1:t*Math.sin(e),x2:l*m-f*v,y2:l*v+f*m,x3:d*m-p*v,y3:d*v+p*m,x4:t*Math.cos(r),y4:t*Math.sin(r)}},q=function(t){return 180*t/Math.PI},D=function(t,e,r,n,i,a){var o=t+.5*(r-t),s=e+.5*(n-e),c=i+.5*(r-i),h=a+.5*(n-a),l=Math.min(t,i,o,c),f=Math.max(t,i,o,c),d=Math.min(e,a,s,h),p=Math.max(e,a,s,h);return new u(l,d,f-l,p-d)},R=function(t,e,r,n,i,a,o,s){var c,h,l,f,d,p,g,m,v,b,y,w,N,L,A=r-t,x=n-e,S=i-r,_=a-n,P=o-i,k=s-a;for(h=0;h<41;h++)v=(g=(l=t+(c=h/40)*A)+c*((d=r+c*S)-l))+c*(d+c*(i+c*P-d)-g),b=(m=(f=e+c*x)+c*((p=n+c*_)-f))+c*(p+c*(a+c*k-p)-m),0==h?(y=v,w=b,N=v,L=b):(y=Math.min(y,v),w=Math.min(w,b),N=Math.max(N,v),L=Math.max(L,b));return new u(Math.round(y),Math.round(w),Math.round(N-y),Math.round(L-w))},T=function(){if(this.prevLineDash||this.ctx.lineDash.length||this.ctx.lineDashOffset){var t,e,r=(t=this.ctx.lineDash,e=this.ctx.lineDashOffset,JSON.stringify({lineDash:t,lineDashOffset:e}));this.prevLineDash!==r&&(this.pdf.setLineDash(this.ctx.lineDash,this.ctx.lineDashOffset),this.prevLineDash=r);}};}(E$1.API),
  /**
   * @license
   * jsPDF filters PlugIn
   * Copyright (c) 2014 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var r=function(t){var e,r,n,i,a,o,s,c,u,h;for(/[^\x00-\xFF]/.test(t),r=[],n=0,i=(t+=e="\0\0\0\0".slice(t.length%4||4)).length;i>n;n+=4)0!==(a=(t.charCodeAt(n)<<24)+(t.charCodeAt(n+1)<<16)+(t.charCodeAt(n+2)<<8)+t.charCodeAt(n+3))?(o=(a=((a=((a=((a=(a-(h=a%85))/85)-(u=a%85))/85)-(c=a%85))/85)-(s=a%85))/85)%85,r.push(o+33,s+33,c+33,u+33,h+33)):r.push(122);return function(t,e){for(var r=e;r>0;r--)t.pop();}(r,e.length),String.fromCharCode.apply(String,r)+"~>"},n=function(t){var e,r,n,i,a,o=String,s="length",c=255,u="charCodeAt",h="slice",l="replace";for(t[h](-2),t=t[h](0,-2)[l](/\s/g,"")[l]("z","!!!!!"),n=[],i=0,a=(t+=e="uuuuu"[h](t[s]%5||5))[s];a>i;i+=5)r=52200625*(t[u](i)-33)+614125*(t[u](i+1)-33)+7225*(t[u](i+2)-33)+85*(t[u](i+3)-33)+(t[u](i+4)-33),n.push(c&r>>24,c&r>>16,c&r>>8,c&r);return function(t,e){for(var r=e;r>0;r--)t.pop();}(n,e[s]),o.fromCharCode.apply(o,n)},i=function(t){var e=new RegExp(/^([0-9A-Fa-f]{2})+$/);if(-1!==(t=t.replace(/\s/g,"")).indexOf(">")&&(t=t.substr(0,t.indexOf(">"))),t.length%2&&(t+="0"),!1===e.test(t))return "";for(var r="",n=0;n<t.length;n+=2)r+=String.fromCharCode("0x"+(t[n]+t[n+1]));return r},a=function(t){for(var r=new Uint8Array(t.length),n=t.length;n--;)r[n]=t.charCodeAt(n);return t=(r=zlibSync(r)).reduce((function(t,e){return t+String.fromCharCode(e)}),"")};t.processDataByFilters=function(t,e){var o=0,s=t||"",c=[];for("string"==typeof(e=e||[])&&(e=[e]),o=0;o<e.length;o+=1)switch(e[o]){case"ASCII85Decode":case"/ASCII85Decode":s=n(s),c.push("/ASCII85Encode");break;case"ASCII85Encode":case"/ASCII85Encode":s=r(s),c.push("/ASCII85Decode");break;case"ASCIIHexDecode":case"/ASCIIHexDecode":s=i(s),c.push("/ASCIIHexEncode");break;case"ASCIIHexEncode":case"/ASCIIHexEncode":s=s.split("").map((function(t){return ("0"+t.charCodeAt().toString(16)).slice(-2)})).join("")+">",c.push("/ASCIIHexDecode");break;case"FlateEncode":case"/FlateEncode":s=a(s),c.push("/FlateDecode");break;default:throw new Error('The filter: "'+e[o]+'" is not implemented')}return {data:s,reverseChain:c.reverse().join(" ")}};}(E$1.API),
  /**
   * @license
   * jsPDF fileloading PlugIn
   * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.loadFile=function(t,e,r){return function(t,e,r){e=!1!==e,r="function"==typeof r?r:function(){};var n=void 0;try{n=function(t,e,r){var n=new XMLHttpRequest,i=0,a=function(t){var e=t.length,r=[],n=String.fromCharCode;for(i=0;i<e;i+=1)r.push(n(255&t.charCodeAt(i)));return r.join("")};if(n.open("GET",t,!e),n.overrideMimeType("text/plain; charset=x-user-defined"),!1===e&&(n.onload=function(){200===n.status?r(a(this.responseText)):r(void 0);}),n.send(null),e&&200===n.status)return a(n.responseText)}(t,e,r);}catch(t){}return n}(t,e,r)},t.loadImageFile=t.loadFile;}(E$1.API),function(e){function r(){return (n$1.html2canvas?Promise.resolve(n$1.html2canvas):Promise.resolve().then(function () { return html2canvas_esm; })).catch((function(t){return Promise.reject(new Error("Could not load html2canvas: "+t))})).then((function(t){return t.default?t.default:t}))}function i(){return (n$1.DOMPurify?Promise.resolve(n$1.DOMPurify):Promise.resolve().then(function () { return purify_es; })).catch((function(t){return Promise.reject(new Error("Could not load dompurify: "+t))})).then((function(t){return t.default?t.default:t}))}var a=function(e){var r=_typeof$2(e);return "undefined"===r?"undefined":"string"===r||e instanceof String?"string":"number"===r||e instanceof Number?"number":"function"===r||e instanceof Function?"function":e&&e.constructor===Array?"array":e&&1===e.nodeType?"element":"object"===r?"object":"unknown"},o=function(t,e){var r=document.createElement(t);for(var n in e.className&&(r.className=e.className),e.innerHTML&&e.dompurify&&(r.innerHTML=e.dompurify.sanitize(e.innerHTML)),e.style)r.style[n]=e.style[n];return r},s=function t(e){var r=Object.assign(t.convert(Promise.resolve()),JSON.parse(JSON.stringify(t.template))),n=t.convert(Promise.resolve(),r);return n=(n=n.setProgress(1,t,1,[t])).set(e)};(s.prototype=Object.create(Promise.prototype)).constructor=s,s.convert=function(t,e){return t.__proto__=e||s.prototype,t},s.template={prop:{src:null,container:null,overlay:null,canvas:null,img:null,pdf:null,pageSize:null,callback:function(){}},progress:{val:0,state:null,n:0,stack:[]},opt:{filename:"file.pdf",margin:[0,0,0,0],enableLinks:!0,x:0,y:0,html2canvas:{},jsPDF:{},backgroundColor:"transparent"}},s.prototype.from=function(t,e){return this.then((function(){switch(e=e||function(t){switch(a(t)){case"string":return "string";case"element":return "canvas"===t.nodeName.toLowerCase()?"canvas":"element";default:return "unknown"}}(t)){case"string":return this.then(i).then((function(e){return this.set({src:o("div",{innerHTML:t,dompurify:e})})}));case"element":return this.set({src:t});case"canvas":return this.set({canvas:t});case"img":return this.set({img:t});default:return this.error("Unknown source type.")}}))},s.prototype.to=function(t){switch(t){case"container":return this.toContainer();case"canvas":return this.toCanvas();case"img":return this.toImg();case"pdf":return this.toPdf();default:return this.error("Invalid target.")}},s.prototype.toContainer=function(){return this.thenList([function(){return this.prop.src||this.error("Cannot duplicate - no source HTML.")},function(){return this.prop.pageSize||this.setPageSize()}]).then((function(){var t={position:"relative",display:"inline-block",width:("number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?Math.max(this.prop.src.clientWidth,this.prop.src.scrollWidth,this.prop.src.offsetWidth):this.opt.windowWidth)+"px",left:0,right:0,top:0,margin:"auto",backgroundColor:this.opt.backgroundColor},e=function t(e,r){for(var n=3===e.nodeType?document.createTextNode(e.nodeValue):e.cloneNode(!1),i=e.firstChild;i;i=i.nextSibling)!0!==r&&1===i.nodeType&&"SCRIPT"===i.nodeName||n.appendChild(t(i,r));return 1===e.nodeType&&("CANVAS"===e.nodeName?(n.width=e.width,n.height=e.height,n.getContext("2d").drawImage(e,0,0)):"TEXTAREA"!==e.nodeName&&"SELECT"!==e.nodeName||(n.value=e.value),n.addEventListener("load",(function(){n.scrollTop=e.scrollTop,n.scrollLeft=e.scrollLeft;}),!0)),n}(this.prop.src,this.opt.html2canvas.javascriptEnabled);"BODY"===e.tagName&&(t.height=Math.max(document.body.scrollHeight,document.body.offsetHeight,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight)+"px"),this.prop.overlay=o("div",{className:"html2pdf__overlay",style:{position:"fixed",overflow:"hidden",zIndex:1e3,left:"-100000px",right:0,bottom:0,top:0}}),this.prop.container=o("div",{className:"html2pdf__container",style:t}),this.prop.container.appendChild(e),this.prop.container.firstChild.appendChild(o("div",{style:{clear:"both",border:"0 none transparent",margin:0,padding:0,height:0}})),this.prop.container.style.float="none",this.prop.overlay.appendChild(this.prop.container),document.body.appendChild(this.prop.overlay),this.prop.container.firstChild.style.position="relative",this.prop.container.height=Math.max(this.prop.container.firstChild.clientHeight,this.prop.container.firstChild.scrollHeight,this.prop.container.firstChild.offsetHeight)+"px";}))},s.prototype.toCanvas=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(r).then((function(t){var e=Object.assign({},this.opt.html2canvas);return delete e.onrendered,t(this.prop.container,e)})).then((function(t){(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);}))},s.prototype.toContext2d=function(){var t=[function(){return document.body.contains(this.prop.container)||this.toContainer()}];return this.thenList(t).then(r).then((function(t){var e=this.opt.jsPDF,r=this.opt.fontFaces,n="number"!=typeof this.opt.width||isNaN(this.opt.width)||"number"!=typeof this.opt.windowWidth||isNaN(this.opt.windowWidth)?1:this.opt.width/this.opt.windowWidth,i=Object.assign({async:!0,allowTaint:!0,scale:n,scrollX:this.opt.scrollX||0,scrollY:this.opt.scrollY||0,backgroundColor:"#ffffff",imageTimeout:15e3,logging:!0,proxy:null,removeContainer:!0,foreignObjectRendering:!1,useCORS:!1},this.opt.html2canvas);if(delete i.onrendered,e.context2d.autoPaging=void 0===this.opt.autoPaging||this.opt.autoPaging,e.context2d.posX=this.opt.x,e.context2d.posY=this.opt.y,e.context2d.margin=this.opt.margin,e.context2d.fontFaces=r,r)for(var a=0;a<r.length;++a){var o=r[a],s=o.src.find((function(t){return "truetype"===t.format}));s&&e.addFont(s.url,o.ref.name,o.ref.style);}return i.windowHeight=i.windowHeight||0,i.windowHeight=0==i.windowHeight?Math.max(this.prop.container.clientHeight,this.prop.container.scrollHeight,this.prop.container.offsetHeight):i.windowHeight,e.context2d.save(!0),t(this.prop.container,i)})).then((function(t){this.opt.jsPDF.context2d.restore(!0),(this.opt.html2canvas.onrendered||function(){})(t),this.prop.canvas=t,document.body.removeChild(this.prop.overlay);}))},s.prototype.toImg=function(){return this.thenList([function(){return this.prop.canvas||this.toCanvas()}]).then((function(){var t=this.prop.canvas.toDataURL("image/"+this.opt.image.type,this.opt.image.quality);this.prop.img=document.createElement("img"),this.prop.img.src=t;}))},s.prototype.toPdf=function(){return this.thenList([function(){return this.toContext2d()}]).then((function(){this.prop.pdf=this.prop.pdf||this.opt.jsPDF;}))},s.prototype.output=function(t,e,r){return "img"===(r=r||"pdf").toLowerCase()||"image"===r.toLowerCase()?this.outputImg(t,e):this.outputPdf(t,e)},s.prototype.outputPdf=function(t,e){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then((function(){return this.prop.pdf.output(t,e)}))},s.prototype.outputImg=function(t){return this.thenList([function(){return this.prop.img||this.toImg()}]).then((function(){switch(t){case void 0:case"img":return this.prop.img;case"datauristring":case"dataurlstring":return this.prop.img.src;case"datauri":case"dataurl":return document.location.href=this.prop.img.src;default:throw 'Image output type "'+t+'" is not supported.'}}))},s.prototype.save=function(t){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).set(t?{filename:t}:null).then((function(){this.prop.pdf.save(this.opt.filename);}))},s.prototype.doCallback=function(){return this.thenList([function(){return this.prop.pdf||this.toPdf()}]).then((function(){this.prop.callback(this.prop.pdf);}))},s.prototype.set=function(t){if("object"!==a(t))return this;var e=Object.keys(t||{}).map((function(e){if(e in s.template.prop)return function(){this.prop[e]=t[e];};switch(e){case"margin":return this.setMargin.bind(this,t.margin);case"jsPDF":return function(){return this.opt.jsPDF=t.jsPDF,this.setPageSize()};case"pageSize":return this.setPageSize.bind(this,t.pageSize);default:return function(){this.opt[e]=t[e];}}}),this);return this.then((function(){return this.thenList(e)}))},s.prototype.get=function(t,e){return this.then((function(){var r=t in s.template.prop?this.prop[t]:this.opt[t];return e?e(r):r}))},s.prototype.setMargin=function(t){return this.then((function(){switch(a(t)){case"number":t=[t,t,t,t];case"array":if(2===t.length&&(t=[t[0],t[1],t[0],t[1]]),4===t.length)break;default:return this.error("Invalid margin array.")}this.opt.margin=t;})).then(this.setPageSize)},s.prototype.setPageSize=function(t){function e(t,e){return Math.floor(t*e/72*96)}return this.then((function(){(t=t||E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner")||(t.inner={width:t.width-this.opt.margin[1]-this.opt.margin[3],height:t.height-this.opt.margin[0]-this.opt.margin[2]},t.inner.px={width:e(t.inner.width,t.k),height:e(t.inner.height,t.k)},t.inner.ratio=t.inner.height/t.inner.width),this.prop.pageSize=t;}))},s.prototype.setProgress=function(t,e,r,n){return null!=t&&(this.progress.val=t),null!=e&&(this.progress.state=e),null!=r&&(this.progress.n=r),null!=n&&(this.progress.stack=n),this.progress.ratio=this.progress.val/this.progress.state,this},s.prototype.updateProgress=function(t,e,r,n){return this.setProgress(t?this.progress.val+t:null,e||null,r?this.progress.n+r:null,n?this.progress.stack.concat(n):null)},s.prototype.then=function(t,e){var r=this;return this.thenCore(t,e,(function(t,e){return r.updateProgress(null,null,1,[t]),Promise.prototype.then.call(this,(function(e){return r.updateProgress(null,t),e})).then(t,e).then((function(t){return r.updateProgress(1),t}))}))},s.prototype.thenCore=function(t,e,r){r=r||Promise.prototype.then;t&&(t=t.bind(this)),e&&(e=e.bind(this));var n=-1!==Promise.toString().indexOf("[native code]")&&"Promise"===Promise.name?this:s.convert(Object.assign({},this),Promise.prototype),i=r.call(n,t,e);return s.convert(i,this.__proto__)},s.prototype.thenExternal=function(t,e){return Promise.prototype.then.call(this,t,e)},s.prototype.thenList=function(t){var e=this;return t.forEach((function(t){e=e.thenCore(t);})),e},s.prototype.catch=function(t){t&&(t=t.bind(this));var e=Promise.prototype.catch.call(this,t);return s.convert(e,this)},s.prototype.catchExternal=function(t){return Promise.prototype.catch.call(this,t)},s.prototype.error=function(t){return this.then((function(){throw new Error(t)}))},s.prototype.using=s.prototype.set,s.prototype.saveAs=s.prototype.save,s.prototype.export=s.prototype.output,s.prototype.run=s.prototype.then,E$1.getPageSize=function(e,r,n){if("object"===_typeof$2(e)){var i=e;e=i.orientation,r=i.unit||r,n=i.format||n;}r=r||"mm",n=n||"a4",e=(""+(e||"P")).toLowerCase();var a,o=(""+n).toLowerCase(),s={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};switch(r){case"pt":a=1;break;case"mm":a=72/25.4;break;case"cm":a=72/2.54;break;case"in":a=72;break;case"px":a=.75;break;case"pc":case"em":a=12;break;case"ex":a=6;break;default:throw "Invalid unit: "+r}var c,u=0,h=0;if(s.hasOwnProperty(o))u=s[o][1]/a,h=s[o][0]/a;else try{u=n[1],h=n[0];}catch(t){throw new Error("Invalid format: "+n)}if("p"===e||"portrait"===e)e="p",h>u&&(c=h,h=u,u=c);else {if("l"!==e&&"landscape"!==e)throw "Invalid orientation: "+e;e="l",u>h&&(c=h,h=u,u=c);}return {width:h,height:u,unit:r,k:a,orientation:e}},e.html=function(t,e){(e=e||{}).callback=e.callback||function(){},e.html2canvas=e.html2canvas||{},e.html2canvas.canvas=e.html2canvas.canvas||this.canvas,e.jsPDF=e.jsPDF||this,e.fontFaces=e.fontFaces?e.fontFaces.map(jt):null;var r=new s(e);return e.worker?r:r.from(t).doCallback()};}(E$1.API),E$1.API.addJS=function(t){return Ht=t,this.internal.events.subscribe("postPutResources",(function(){Ut=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/Names [(EmbeddedJS) "+(Ut+1)+" 0 R]"),this.internal.out(">>"),this.internal.out("endobj"),zt=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /JavaScript"),this.internal.out("/JS ("+Ht+")"),this.internal.out(">>"),this.internal.out("endobj");})),this.internal.events.subscribe("putCatalog",(function(){void 0!==Ut&&void 0!==zt&&this.internal.out("/Names <</JavaScript "+Ut+" 0 R>>");})),this},
  /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e;t.events.push(["postPutResources",function(){var t=this,r=/^(\d+) 0 obj$/;if(this.outline.root.children.length>0)for(var n=t.outline.render().split(/\r\n/),i=0;i<n.length;i++){var a=n[i],o=r.exec(a);if(null!=o){var s=o[1];t.internal.newObjectDeferredBegin(s,!1);}t.internal.write(a);}if(this.outline.createNamedDestinations){var c=this.internal.pages.length,u=[];for(i=0;i<c;i++){var h=t.internal.newObject();u.push(h);var l=t.internal.getPageInfo(i+1);t.internal.write("<< /D["+l.objId+" 0 R /XYZ null null null]>> endobj");}var f=t.internal.newObject();t.internal.write("<< /Names [ ");for(i=0;i<u.length;i++)t.internal.write("(page_"+(i+1)+")"+u[i]+" 0 R");t.internal.write(" ] >>","endobj"),e=t.internal.newObject(),t.internal.write("<< /Dests "+f+" 0 R"),t.internal.write(">>","endobj");}}]),t.events.push(["putCatalog",function(){this.outline.root.children.length>0&&(this.internal.write("/Outlines",this.outline.makeRef(this.outline.root)),this.outline.createNamedDestinations&&this.internal.write("/Names "+e+" 0 R"));}]),t.events.push(["initialized",function(){var t=this;t.outline={createNamedDestinations:!1,root:{children:[]}},t.outline.add=function(t,e,r){var n={title:e,options:r,children:[]};return null==t&&(t=this.root),t.children.push(n),n},t.outline.render=function(){return this.ctx={},this.ctx.val="",this.ctx.pdf=t,this.genIds_r(this.root),this.renderRoot(this.root),this.renderItems(this.root),this.ctx.val},t.outline.genIds_r=function(e){e.id=t.internal.newObjectDeferred();for(var r=0;r<e.children.length;r++)this.genIds_r(e.children[r]);},t.outline.renderRoot=function(t){this.objStart(t),this.line("/Type /Outlines"),t.children.length>0&&(this.line("/First "+this.makeRef(t.children[0])),this.line("/Last "+this.makeRef(t.children[t.children.length-1]))),this.line("/Count "+this.count_r({count:0},t)),this.objEnd();},t.outline.renderItems=function(e){for(var r=this.ctx.pdf.internal.getVerticalCoordinateString,n=0;n<e.children.length;n++){var i=e.children[n];this.objStart(i),this.line("/Title "+this.makeString(i.title)),this.line("/Parent "+this.makeRef(e)),n>0&&this.line("/Prev "+this.makeRef(e.children[n-1])),n<e.children.length-1&&this.line("/Next "+this.makeRef(e.children[n+1])),i.children.length>0&&(this.line("/First "+this.makeRef(i.children[0])),this.line("/Last "+this.makeRef(i.children[i.children.length-1])));var a=this.count=this.count_r({count:0},i);if(a>0&&this.line("/Count "+a),i.options&&i.options.pageNumber){var o=t.internal.getPageInfo(i.options.pageNumber);this.line("/Dest ["+o.objId+" 0 R /XYZ 0 "+r(0)+" 0]");}this.objEnd();}for(var s=0;s<e.children.length;s++)this.renderItems(e.children[s]);},t.outline.line=function(t){this.ctx.val+=t+"\r\n";},t.outline.makeRef=function(t){return t.id+" 0 R"},t.outline.makeString=function(e){return "("+t.internal.pdfEscape(e)+")"},t.outline.objStart=function(t){this.ctx.val+="\r\n"+t.id+" 0 obj\r\n<<\r\n";},t.outline.objEnd=function(){this.ctx.val+=">> \r\nendobj\r\n";},t.outline.count_r=function(t,e){for(var r=0;r<e.children.length;r++)t.count++,this.count_r(t,e.children[r]);return t.count};}]);}(E$1.API),
  /**
   * @license
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=[192,193,194,195,196,197,198,199];t.processJPEG=function(t,r,n,i,a,o){var s,c=this.decode.DCT_DECODE,u=null;if("string"==typeof t||this.__addimage__.isArrayBuffer(t)||this.__addimage__.isArrayBufferView(t)){switch(t=a||t,t=this.__addimage__.isArrayBuffer(t)?new Uint8Array(t):t,(s=function(t){for(var r,n=256*t.charCodeAt(4)+t.charCodeAt(5),i=t.length,a={width:0,height:0,numcomponents:1},o=4;o<i;o+=2){if(o+=n,-1!==e.indexOf(t.charCodeAt(o+1))){r=256*t.charCodeAt(o+5)+t.charCodeAt(o+6),a={width:256*t.charCodeAt(o+7)+t.charCodeAt(o+8),height:r,numcomponents:t.charCodeAt(o+9)};break}n=256*t.charCodeAt(o+2)+t.charCodeAt(o+3);}return a}(t=this.__addimage__.isArrayBufferView(t)?this.__addimage__.arrayBufferToBinaryString(t):t)).numcomponents){case 1:o=this.color_spaces.DEVICE_GRAY;break;case 4:o=this.color_spaces.DEVICE_CMYK;break;case 3:o=this.color_spaces.DEVICE_RGB;}u={data:t,width:s.width,height:s.height,colorSpace:o,bitsPerComponent:8,filter:c,index:r,alias:n};}return u};}(E$1.API);var Vt,Gt,Yt,Jt,Xt,Kt=function(){var t,e,i;function a(t){var e,r,n,i,a,o,s,c,u,h,l,f,d,p;for(this.data=t,this.pos=8,this.palette=[],this.imgData=[],this.transparency={},this.animation=null,this.text={},o=null;;){switch(e=this.readUInt32(),u=function(){var t,e;for(e=[],t=0;t<4;++t)e.push(String.fromCharCode(this.data[this.pos++]));return e}.call(this).join("")){case"IHDR":this.width=this.readUInt32(),this.height=this.readUInt32(),this.bits=this.data[this.pos++],this.colorType=this.data[this.pos++],this.compressionMethod=this.data[this.pos++],this.filterMethod=this.data[this.pos++],this.interlaceMethod=this.data[this.pos++];break;case"acTL":this.animation={numFrames:this.readUInt32(),numPlays:this.readUInt32()||1/0,frames:[]};break;case"PLTE":this.palette=this.read(e);break;case"fcTL":o&&this.animation.frames.push(o),this.pos+=4,o={width:this.readUInt32(),height:this.readUInt32(),xOffset:this.readUInt32(),yOffset:this.readUInt32()},a=this.readUInt16(),i=this.readUInt16()||100,o.delay=1e3*a/i,o.disposeOp=this.data[this.pos++],o.blendOp=this.data[this.pos++],o.data=[];break;case"IDAT":case"fdAT":for("fdAT"===u&&(this.pos+=4,e-=4),t=(null!=o?o.data:void 0)||this.imgData,f=0;0<=e?f<e:f>e;0<=e?++f:--f)t.push(this.data[this.pos++]);break;case"tRNS":switch(this.transparency={},this.colorType){case 3:if(n=this.palette.length/3,this.transparency.indexed=this.read(e),this.transparency.indexed.length>n)throw new Error("More transparent colors than palette size");if((h=n-this.transparency.indexed.length)>0)for(d=0;0<=h?d<h:d>h;0<=h?++d:--d)this.transparency.indexed.push(255);break;case 0:this.transparency.grayscale=this.read(e)[0];break;case 2:this.transparency.rgb=this.read(e);}break;case"tEXt":s=(l=this.read(e)).indexOf(0),c=String.fromCharCode.apply(String,l.slice(0,s)),this.text[c]=String.fromCharCode.apply(String,l.slice(s+1));break;case"IEND":return o&&this.animation.frames.push(o),this.colors=function(){switch(this.colorType){case 0:case 3:case 4:return 1;case 2:case 6:return 3}}.call(this),this.hasAlphaChannel=4===(p=this.colorType)||6===p,r=this.colors+(this.hasAlphaChannel?1:0),this.pixelBitlength=this.bits*r,this.colorSpace=function(){switch(this.colors){case 1:return "DeviceGray";case 3:return "DeviceRGB"}}.call(this),void(this.imgData=new Uint8Array(this.imgData));default:this.pos+=e;}if(this.pos+=4,this.pos>this.data.length)throw new Error("Incomplete or corrupt PNG file")}}a.prototype.read=function(t){var e,r;for(r=[],e=0;0<=t?e<t:e>t;0<=t?++e:--e)r.push(this.data[this.pos++]);return r},a.prototype.readUInt32=function(){return this.data[this.pos++]<<24|this.data[this.pos++]<<16|this.data[this.pos++]<<8|this.data[this.pos++]},a.prototype.readUInt16=function(){return this.data[this.pos++]<<8|this.data[this.pos++]},a.prototype.decodePixels=function(t){var e=this.pixelBitlength/8,n=new Uint8Array(this.width*this.height*e),i=0,a=this;if(null==t&&(t=this.imgData),0===t.length)return new Uint8Array(0);function o(r,o,s,c){var u,h,l,f,d,p,g,m,v,b,y,w,N,L,A,x,S,_,P,k,I,F=Math.ceil((a.width-r)/s),C=Math.ceil((a.height-o)/c),j=a.width==F&&a.height==C;for(L=e*F,w=j?n:new Uint8Array(L*C),p=t.length,N=0,h=0;N<C&&i<p;){switch(t[i++]){case 0:for(f=S=0;S<L;f=S+=1)w[h++]=t[i++];break;case 1:for(f=_=0;_<L;f=_+=1)u=t[i++],d=f<e?0:w[h-e],w[h++]=(u+d)%256;break;case 2:for(f=P=0;P<L;f=P+=1)u=t[i++],l=(f-f%e)/e,A=N&&w[(N-1)*L+l*e+f%e],w[h++]=(A+u)%256;break;case 3:for(f=k=0;k<L;f=k+=1)u=t[i++],l=(f-f%e)/e,d=f<e?0:w[h-e],A=N&&w[(N-1)*L+l*e+f%e],w[h++]=(u+Math.floor((d+A)/2))%256;break;case 4:for(f=I=0;I<L;f=I+=1)u=t[i++],l=(f-f%e)/e,d=f<e?0:w[h-e],0===N?A=x=0:(A=w[(N-1)*L+l*e+f%e],x=l&&w[(N-1)*L+(l-1)*e+f%e]),g=d+A-x,m=Math.abs(g-d),b=Math.abs(g-A),y=Math.abs(g-x),v=m<=b&&m<=y?d:b<=y?A:x,w[h++]=(u+v)%256;break;default:throw new Error("Invalid filter algorithm: "+t[i-1])}if(!j){var O=((o+N*c)*a.width+r)*e,B=N*L;for(f=0;f<F;f+=1){for(var M=0;M<e;M+=1)n[O++]=w[B++];O+=(s-1)*e;}}N++;}}return t=unzlibSync(t),1==a.interlaceMethod?(o(0,0,8,8),o(4,0,8,8),o(0,4,4,8),o(2,0,4,4),o(0,2,2,4),o(1,0,2,2),o(0,1,1,2)):o(0,0,1,1),n},a.prototype.decodePalette=function(){var t,e,r,n,i,a,o,s,c;for(r=this.palette,a=this.transparency.indexed||[],i=new Uint8Array((a.length||0)+r.length),n=0,t=0,e=o=0,s=r.length;o<s;e=o+=3)i[n++]=r[e],i[n++]=r[e+1],i[n++]=r[e+2],i[n++]=null!=(c=a[t++])?c:255;return i},a.prototype.copyToImageData=function(t,e){var r,n,i,a,o,s,c,u,h,l,f;if(n=this.colors,h=null,r=this.hasAlphaChannel,this.palette.length&&(h=null!=(f=this._decodedPalette)?f:this._decodedPalette=this.decodePalette(),n=4,r=!0),u=(i=t.data||t).length,o=h||e,a=s=0,1===n)for(;a<u;)c=h?4*e[a/4]:s,l=o[c++],i[a++]=l,i[a++]=l,i[a++]=l,i[a++]=r?o[c++]:255,s=c;else for(;a<u;)c=h?4*e[a/4]:s,i[a++]=o[c++],i[a++]=o[c++],i[a++]=o[c++],i[a++]=r?o[c++]:255,s=c;},a.prototype.decode=function(){var t;return t=new Uint8Array(this.width*this.height*4),this.copyToImageData(t,this.decodePixels()),t};var o=function(){if("[object Window]"===Object.prototype.toString.call(n$1)){try{e=n$1.document.createElement("canvas"),i=e.getContext("2d");}catch(t){return !1}return !0}return !1};return o(),t=function(t){var r;if(!0===o())return i.width=t.width,i.height=t.height,i.clearRect(0,0,t.width,t.height),i.putImageData(t,0,0),(r=new Image).src=e.toDataURL(),r;throw new Error("This method requires a Browser with Canvas-capability.")},a.prototype.decodeFrames=function(e){var r,n,i,a,o,s,c,u;if(this.animation){for(u=[],n=o=0,s=(c=this.animation.frames).length;o<s;n=++o)r=c[n],i=e.createImageData(r.width,r.height),a=this.decodePixels(new Uint8Array(r.data)),this.copyToImageData(i,a),r.imageData=i,u.push(r.image=t(i));return u}},a.prototype.renderFrame=function(t,e){var r,n,i;return r=(n=this.animation.frames)[e],i=n[e-1],0===e&&t.clearRect(0,0,this.width,this.height),1===(null!=i?i.disposeOp:void 0)?t.clearRect(i.xOffset,i.yOffset,i.width,i.height):2===(null!=i?i.disposeOp:void 0)&&t.putImageData(i.imageData,i.xOffset,i.yOffset),0===r.blendOp&&t.clearRect(r.xOffset,r.yOffset,r.width,r.height),t.drawImage(r.image,r.xOffset,r.yOffset)},a.prototype.animate=function(t){var e,r,n,i,a,o,s=this;return r=0,o=this.animation,i=o.numFrames,n=o.frames,a=o.numPlays,(e=function(){var o,c;if(o=r++%i,c=n[o],s.renderFrame(t,o),i>1&&r/i<a)return s.animation._timeout=setTimeout(e,c.delay)})()},a.prototype.stopAnimation=function(){var t;return clearTimeout(null!=(t=this.animation)?t._timeout:void 0)},a.prototype.render=function(t){var e,r;return t._png&&t._png.stopAnimation(),t._png=this,t.width=this.width,t.height=this.height,e=t.getContext("2d"),this.animation?(this.decodeFrames(e),this.animate(e)):(r=e.createImageData(this.width,this.height),this.copyToImageData(r,this.decodePixels()),e.putImageData(r,0,0))},a}();
  /**
   * @license
   *
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  /**
   * @license
   * (c) Dean McNamee <dean@gmail.com>, 2013.
   *
   * https://github.com/deanm/omggif
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
   * including animation and compression.  It does not rely on any specific
   * underlying system, so should run in the browser, Node, or Plask.
   */
  function Zt(t){var e=0;if(71!==t[e++]||73!==t[e++]||70!==t[e++]||56!==t[e++]||56!=(t[e++]+1&253)||97!==t[e++])throw new Error("Invalid GIF 87a/89a header.");var r=t[e++]|t[e++]<<8,n=t[e++]|t[e++]<<8,i=t[e++],a=i>>7,o=1<<(7&i)+1;t[e++];t[e++];var s=null,c=null;a&&(s=e,c=o,e+=3*o);var u=!0,h=[],l=0,f=null,d=0,p=null;for(this.width=r,this.height=n;u&&e<t.length;)switch(t[e++]){case 33:switch(t[e++]){case 255:if(11!==t[e]||78==t[e+1]&&69==t[e+2]&&84==t[e+3]&&83==t[e+4]&&67==t[e+5]&&65==t[e+6]&&80==t[e+7]&&69==t[e+8]&&50==t[e+9]&&46==t[e+10]&&48==t[e+11]&&3==t[e+12]&&1==t[e+13]&&0==t[e+16])e+=14,p=t[e++]|t[e++]<<8,e++;else for(e+=12;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;case 249:if(4!==t[e++]||0!==t[e+4])throw new Error("Invalid graphics extension block.");var g=t[e++];l=t[e++]|t[e++]<<8,f=t[e++],0==(1&g)&&(f=null),d=g>>2&7,e++;break;case 254:for(;;){if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}break;default:throw new Error("Unknown graphic control label: 0x"+t[e-1].toString(16))}break;case 44:var m=t[e++]|t[e++]<<8,v=t[e++]|t[e++]<<8,b=t[e++]|t[e++]<<8,y=t[e++]|t[e++]<<8,w=t[e++],N=w>>6&1,L=1<<(7&w)+1,A=s,x=c,S=!1;if(w>>7){S=!0;A=e,x=L,e+=3*L;}var _=e;for(e++;;){var P;if(!((P=t[e++])>=0))throw Error("Invalid block size");if(0===P)break;e+=P;}h.push({x:m,y:v,width:b,height:y,has_local_palette:S,palette_offset:A,palette_size:x,data_offset:_,data_length:e-_,transparent_index:f,interlaced:!!N,delay:l,disposal:d});break;case 59:u=!1;break;default:throw new Error("Unknown gif block: 0x"+t[e-1].toString(16))}this.numFrames=function(){return h.length},this.loopCount=function(){return p},this.frameInfo=function(t){if(t<0||t>=h.length)throw new Error("Frame index out of range.");return h[t]},this.decodeAndBlitFrameBGRA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);$t(t,i.data_offset,o,a);var s=i.palette_offset,c=i.transparent_index;null===c&&(c=256);var u=i.width,h=r-u,l=u,f=4*(i.y*r+i.x),d=4*((i.y+i.height)*r+i.x),p=f,g=4*h;!0===i.interlaced&&(g+=4*r*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===l&&(l=u,(p+=g)>=d&&(g=4*h+4*r*(m-1),p=f+(u+h)*(m<<1),m>>=1)),y===c)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];n[p++]=L,n[p++]=N,n[p++]=w,n[p++]=255;}--l;}},this.decodeAndBlitFrameRGBA=function(e,n){var i=this.frameInfo(e),a=i.width*i.height,o=new Uint8Array(a);$t(t,i.data_offset,o,a);var s=i.palette_offset,c=i.transparent_index;null===c&&(c=256);var u=i.width,h=r-u,l=u,f=4*(i.y*r+i.x),d=4*((i.y+i.height)*r+i.x),p=f,g=4*h;!0===i.interlaced&&(g+=4*r*7);for(var m=8,v=0,b=o.length;v<b;++v){var y=o[v];if(0===l&&(l=u,(p+=g)>=d&&(g=4*h+4*r*(m-1),p=f+(u+h)*(m<<1),m>>=1)),y===c)p+=4;else {var w=t[s+3*y],N=t[s+3*y+1],L=t[s+3*y+2];n[p++]=w,n[p++]=N,n[p++]=L,n[p++]=255;}--l;}};}function $t(t,e,r,n){for(var i=t[e++],o=1<<i,s=o+1,c=s+1,u=i+1,h=(1<<u)-1,l=0,f=0,d=0,p=t[e++],g=new Int32Array(4096),m=null;;){for(;l<16&&0!==p;)f|=t[e++]<<l,l+=8,1===p?p=t[e++]:--p;if(l<u)break;var v=f&h;if(f>>=u,l-=u,v!==o){if(v===s)break;for(var b=v<c?v:m,y=0,w=b;w>o;)w=g[w]>>8,++y;var N=w;if(d+y+(b!==v?1:0)>n)return void a$2.log("Warning, gif stream longer than expected.");r[d++]=N;var L=d+=y;for(b!==v&&(r[d++]=N),w=b;y--;)w=g[w],r[--L]=255&w,w>>=8;null!==m&&c<4096&&(g[c++]=m<<8|N,c>=h+1&&u<12&&(++u,h=h<<1|1)),m=v;}else c=s+1,h=(1<<(u=i+1))-1,m=null;}return d!==n&&a$2.log("Warning, gif stream shorter than expected."),r}
  /**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */function Qt(t){var e,r,n,i,a,o=Math.floor,s=new Array(64),c=new Array(64),u=new Array(64),h=new Array(64),l=new Array(65535),f=new Array(65535),d=new Array(64),p=new Array(64),g=[],m=0,v=7,b=new Array(64),y=new Array(64),w=new Array(64),N=new Array(256),L=new Array(2048),A=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],x=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],S=[0,1,2,3,4,5,6,7,8,9,10,11],_=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],P=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],k=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],I=[0,1,2,3,4,5,6,7,8,9,10,11],F=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],C=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function j(t,e){for(var r=0,n=0,i=new Array,a=1;a<=16;a++){for(var o=1;o<=t[a];o++)i[e[n]]=[],i[e[n]][0]=r,i[e[n]][1]=a,n++,r++;r*=2;}return i}function O(t){for(var e=t[0],r=t[1]-1;r>=0;)e&1<<r&&(m|=1<<v),r--,--v<0&&(255==m?(B(255),B(0)):B(m),v=7,m=0);}function B(t){g.push(t);}function M(t){B(t>>8&255),B(255&t);}function E(t,e,r,n,i){for(var a,o=i[0],s=i[240],c=function(t,e){var r,n,i,a,o,s,c,u,h,l,f=0;for(h=0;h<8;++h){r=t[f],n=t[f+1],i=t[f+2],a=t[f+3],o=t[f+4],s=t[f+5],c=t[f+6];var p=r+(u=t[f+7]),g=r-u,m=n+c,v=n-c,b=i+s,y=i-s,w=a+o,N=a-o,L=p+w,A=p-w,x=m+b,S=m-b;t[f]=L+x,t[f+4]=L-x;var _=.707106781*(S+A);t[f+2]=A+_,t[f+6]=A-_;var P=.382683433*((L=N+y)-(S=v+g)),k=.5411961*L+P,I=1.306562965*S+P,F=.707106781*(x=y+v),C=g+F,j=g-F;t[f+5]=j+k,t[f+3]=j-k,t[f+1]=C+I,t[f+7]=C-I,f+=8;}for(f=0,h=0;h<8;++h){r=t[f],n=t[f+8],i=t[f+16],a=t[f+24],o=t[f+32],s=t[f+40],c=t[f+48];var O=r+(u=t[f+56]),B=r-u,M=n+c,E=n-c,q=i+s,D=i-s,R=a+o,T=a-o,U=O+R,z=O-R,H=M+q,W=M-q;t[f]=U+H,t[f+32]=U-H;var V=.707106781*(W+z);t[f+16]=z+V,t[f+48]=z-V;var G=.382683433*((U=T+D)-(W=E+B)),Y=.5411961*U+G,J=1.306562965*W+G,X=.707106781*(H=D+E),K=B+X,Z=B-X;t[f+40]=Z+Y,t[f+24]=Z-Y,t[f+8]=K+J,t[f+56]=K-J,f++;}for(h=0;h<64;++h)l=t[h]*e[h],d[h]=l>0?l+.5|0:l-.5|0;return d}(t,e),u=0;u<64;++u)p[A[u]]=c[u];var h=p[0]-r;r=p[0],0==h?O(n[0]):(O(n[f[a=32767+h]]),O(l[a]));for(var g=63;g>0&&0==p[g];)g--;if(0==g)return O(o),r;for(var m,v=1;v<=g;){for(var b=v;0==p[v]&&v<=g;)++v;var y=v-b;if(y>=16){m=y>>4;for(var w=1;w<=m;++w)O(s);y&=15;}a=32767+p[v],O(i[(y<<4)+f[a]]),O(l[a]),v++;}return 63!=g&&O(o),r}function q(t){(t=Math.min(Math.max(t,1),100),a!=t)&&(!function(t){for(var e=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],r=0;r<64;r++){var n=o((e[r]*t+50)/100);n=Math.min(Math.max(n,1),255),s[A[r]]=n;}for(var i=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],a=0;a<64;a++){var l=o((i[a]*t+50)/100);l=Math.min(Math.max(l,1),255),c[A[a]]=l;}for(var f=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],d=0,p=0;p<8;p++)for(var g=0;g<8;g++)u[d]=1/(s[A[d]]*f[p]*f[g]*8),h[d]=1/(c[A[d]]*f[p]*f[g]*8),d++;}(t<50?Math.floor(5e3/t):Math.floor(200-2*t)),a=t);}this.encode=function(t,a){a&&q(a),g=new Array,m=0,v=7,M(65496),M(65504),M(16),B(74),B(70),B(73),B(70),B(0),B(1),B(1),B(0),M(1),M(1),B(0),B(0),function(){M(65499),M(132),B(0);for(var t=0;t<64;t++)B(s[t]);B(1);for(var e=0;e<64;e++)B(c[e]);}(),function(t,e){M(65472),M(17),B(8),M(e),M(t),B(3),B(1),B(17),B(0),B(2),B(17),B(1),B(3),B(17),B(1);}(t.width,t.height),function(){M(65476),M(418),B(0);for(var t=0;t<16;t++)B(x[t+1]);for(var e=0;e<=11;e++)B(S[e]);B(16);for(var r=0;r<16;r++)B(_[r+1]);for(var n=0;n<=161;n++)B(P[n]);B(1);for(var i=0;i<16;i++)B(k[i+1]);for(var a=0;a<=11;a++)B(I[a]);B(17);for(var o=0;o<16;o++)B(F[o+1]);for(var s=0;s<=161;s++)B(C[s]);}(),M(65498),M(12),B(3),B(1),B(0),B(2),B(17),B(3),B(17),B(0),B(63),B(0);var o=0,l=0,f=0;m=0,v=7,this.encode.displayName="_encode_";for(var d,p,N,A,j,D,R,T,U,z=t.data,H=t.width,W=t.height,V=4*H,G=0;G<W;){for(d=0;d<V;){for(j=V*G+d,R=-1,T=0,U=0;U<64;U++)D=j+(T=U>>3)*V+(R=4*(7&U)),G+T>=W&&(D-=V*(G+1+T-W)),d+R>=V&&(D-=d+R-V+4),p=z[D++],N=z[D++],A=z[D++],b[U]=(L[p]+L[N+256>>0]+L[A+512>>0]>>16)-128,y[U]=(L[p+768>>0]+L[N+1024>>0]+L[A+1280>>0]>>16)-128,w[U]=(L[p+1280>>0]+L[N+1536>>0]+L[A+1792>>0]>>16)-128;o=E(b,u,o,e,n),l=E(y,h,l,r,i),f=E(w,h,f,r,i),d+=32;}G+=8;}if(v>=0){var Y=[];Y[1]=v+1,Y[0]=(1<<v+1)-1,O(Y);}return M(65497),new Uint8Array(g)},t=t||50,function(){for(var t=String.fromCharCode,e=0;e<256;e++)N[e]=t(e);}(),e=j(x,S),r=j(k,I),n=j(_,P),i=j(F,C),function(){for(var t=1,e=2,r=1;r<=15;r++){for(var n=t;n<e;n++)f[32767+n]=r,l[32767+n]=[],l[32767+n][1]=r,l[32767+n][0]=n;for(var i=-(e-1);i<=-t;i++)f[32767+i]=r,l[32767+i]=[],l[32767+i][1]=r,l[32767+i][0]=e-1+i;t<<=1,e<<=1;}}(),function(){for(var t=0;t<256;t++)L[t]=19595*t,L[t+256>>0]=38470*t,L[t+512>>0]=7471*t+32768,L[t+768>>0]=-11059*t,L[t+1024>>0]=-21709*t,L[t+1280>>0]=32768*t+8421375,L[t+1536>>0]=-27439*t,L[t+1792>>0]=-5329*t;}(),q(t);}
  /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */function te(t,e){if(this.pos=0,this.buffer=t,this.datav=new DataView(t.buffer),this.is_with_alpha=!!e,this.bottom_up=!0,this.flag=String.fromCharCode(this.buffer[0])+String.fromCharCode(this.buffer[1]),this.pos+=2,-1===["BM","BA","CI","CP","IC","PT"].indexOf(this.flag))throw new Error("Invalid BMP File");this.parseHeader(),this.parseBGR();}function ee(t){function e(t){if(!t)throw Error("assert :P")}function r(t,e,r){for(var n=0;4>n;n++)if(t[e+n]!=r.charCodeAt(n))return !0;return !1}function n(t,e,r,n,i){for(var a=0;a<i;a++)t[e+a]=r[n+a];}function i(t,e,r,n){for(var i=0;i<n;i++)t[e+i]=r;}function a(t){return new Int32Array(t)}function o(t,e){for(var r=[],n=0;n<t;n++)r.push(new e);return r}function s(t,e){var r=[];return function t(r,n,i){for(var a=i[n],o=0;o<a&&(r.push(i.length>n+1?[]:new e),!(i.length<n+1));o++)t(r[o],n+1,i);}(r,0,t),r}var c=function(){var t=this;function c(t,e){for(var r=1<<e-1>>>0;t&r;)r>>>=1;return r?(t&r-1)+r:t}function u(t,r,n,i,a){e(!(i%n));do{t[r+(i-=n)]=a;}while(0<i)}function h(t,r,n,i,o){if(e(2328>=o),512>=o)var s=a(512);else if(null==(s=a(o)))return 0;return function(t,r,n,i,o,s){var h,f,d=r,p=1<<n,g=a(16),m=a(16);for(e(0!=o),e(null!=i),e(null!=t),e(0<n),f=0;f<o;++f){if(15<i[f])return 0;++g[i[f]];}if(g[0]==o)return 0;for(m[1]=0,h=1;15>h;++h){if(g[h]>1<<h)return 0;m[h+1]=m[h]+g[h];}for(f=0;f<o;++f)h=i[f],0<i[f]&&(s[m[h]++]=f);if(1==m[15])return (i=new l).g=0,i.value=s[0],u(t,d,1,p,i),p;var v,b=-1,y=p-1,w=0,N=1,L=1,A=1<<n;for(f=0,h=1,o=2;h<=n;++h,o<<=1){if(N+=L<<=1,0>(L-=g[h]))return 0;for(;0<g[h];--g[h])(i=new l).g=h,i.value=s[f++],u(t,d+w,o,A,i),w=c(w,h);}for(h=n+1,o=2;15>=h;++h,o<<=1){if(N+=L<<=1,0>(L-=g[h]))return 0;for(;0<g[h];--g[h]){if(i=new l,(w&y)!=b){for(d+=A,v=1<<(b=h)-n;15>b&&!(0>=(v-=g[b]));)++b,v<<=1;p+=A=1<<(v=b-n),t[r+(b=w&y)].g=v+n,t[r+b].value=d-r-b;}i.g=h-n,i.value=s[f++],u(t,d+(w>>n),o,A,i),w=c(w,h);}}return N!=2*m[15]-1?0:p}(t,r,n,i,o,s)}function l(){this.value=this.g=0;}function f(){this.value=this.g=0;}function d(){this.G=o(5,l),this.H=a(5),this.jc=this.Qb=this.qb=this.nd=0,this.pd=o(Dr,f);}function p(t,r,n,i){e(null!=t),e(null!=r),e(2147483648>i),t.Ca=254,t.I=0,t.b=-8,t.Ka=0,t.oa=r,t.pa=n,t.Jd=r,t.Yc=n+i,t.Zc=4<=i?n+i-4+1:n,_(t);}function g(t,e){for(var r=0;0<e--;)r|=k(t,128)<<e;return r}function m(t,e){var r=g(t,e);return P(t)?-r:r}function v(t,r,n,i){var a,o=0;for(e(null!=t),e(null!=r),e(4294967288>i),t.Sb=i,t.Ra=0,t.u=0,t.h=0,4<i&&(i=4),a=0;a<i;++a)o+=r[n+a]<<8*a;t.Ra=o,t.bb=i,t.oa=r,t.pa=n;}function b(t){for(;8<=t.u&&t.bb<t.Sb;)t.Ra>>>=8,t.Ra+=t.oa[t.pa+t.bb]<<Ur-8>>>0,++t.bb,t.u-=8;A(t)&&(t.h=1,t.u=0);}function y(t,r){if(e(0<=r),!t.h&&r<=Tr){var n=L(t)&Rr[r];return t.u+=r,b(t),n}return t.h=1,t.u=0}function w(){this.b=this.Ca=this.I=0,this.oa=[],this.pa=0,this.Jd=[],this.Yc=0,this.Zc=[],this.Ka=0;}function N(){this.Ra=0,this.oa=[],this.h=this.u=this.bb=this.Sb=this.pa=0;}function L(t){return t.Ra>>>(t.u&Ur-1)>>>0}function A(t){return e(t.bb<=t.Sb),t.h||t.bb==t.Sb&&t.u>Ur}function x(t,e){t.u=e,t.h=A(t);}function S(t){t.u>=zr&&(e(t.u>=zr),b(t));}function _(t){e(null!=t&&null!=t.oa),t.pa<t.Zc?(t.I=(t.oa[t.pa++]|t.I<<8)>>>0,t.b+=8):(e(null!=t&&null!=t.oa),t.pa<t.Yc?(t.b+=8,t.I=t.oa[t.pa++]|t.I<<8):t.Ka?t.b=0:(t.I<<=8,t.b+=8,t.Ka=1));}function P(t){return g(t,1)}function k(t,e){var r=t.Ca;0>t.b&&_(t);var n=t.b,i=r*e>>>8,a=(t.I>>>n>i)+0;for(a?(r-=i,t.I-=i+1<<n>>>0):r=i+1,n=r,i=0;256<=n;)i+=8,n>>=8;return n=7^i+Hr[n],t.b-=n,t.Ca=(r<<n)-1,a}function I(t,e,r){t[e+0]=r>>24&255,t[e+1]=r>>16&255,t[e+2]=r>>8&255,t[e+3]=r>>0&255;}function F(t,e){return t[e+0]<<0|t[e+1]<<8}function C(t,e){return F(t,e)|t[e+2]<<16}function j(t,e){return F(t,e)|F(t,e+2)<<16}function O(t,r){var n=1<<r;return e(null!=t),e(0<r),t.X=a(n),null==t.X?0:(t.Mb=32-r,t.Xa=r,1)}function B(t,r){e(null!=t),e(null!=r),e(t.Xa==r.Xa),n(r.X,0,t.X,0,1<<r.Xa);}function M(){this.X=[],this.Xa=this.Mb=0;}function E(t,r,n,i){e(null!=n),e(null!=i);var a=n[0],o=i[0];return 0==a&&(a=(t*o+r/2)/r),0==o&&(o=(r*a+t/2)/t),0>=a||0>=o?0:(n[0]=a,i[0]=o,1)}function q(t,e){return t+(1<<e)-1>>>e}function D(t,e){return ((4278255360&t)+(4278255360&e)>>>0&4278255360)+((16711935&t)+(16711935&e)>>>0&16711935)>>>0}function R(e,r){t[r]=function(r,n,i,a,o,s,c){var u;for(u=0;u<o;++u){var h=t[e](s[c+u-1],i,a+u);s[c+u]=D(r[n+u],h);}};}function T(){this.ud=this.hd=this.jd=0;}function U(t,e){return ((4278124286&(t^e))>>>1)+(t&e)>>>0}function z(t){return 0<=t&&256>t?t:0>t?0:255<t?255:void 0}function H(t,e){return z(t+(t-e+.5>>1))}function W(t,e,r){return Math.abs(e-r)-Math.abs(t-r)}function V(t,e,r,n,i,a,o){for(n=a[o-1],r=0;r<i;++r)a[o+r]=n=D(t[e+r],n);}function G(t,e,r,n,i){var a;for(a=0;a<r;++a){var o=t[e+a],s=o>>8&255,c=16711935&(c=(c=16711935&o)+((s<<16)+s));n[i+a]=(4278255360&o)+c>>>0;}}function Y(t,e){e.jd=t>>0&255,e.hd=t>>8&255,e.ud=t>>16&255;}function J(t,e,r,n,i,a){var o;for(o=0;o<n;++o){var s=e[r+o],c=s>>>8,u=s,h=255&(h=(h=s>>>16)+((t.jd<<24>>24)*(c<<24>>24)>>>5));u=255&(u=(u=u+((t.hd<<24>>24)*(c<<24>>24)>>>5))+((t.ud<<24>>24)*(h<<24>>24)>>>5));i[a+o]=(4278255360&s)+(h<<16)+u;}}function X(e,r,n,i,a){t[r]=function(t,e,r,n,o,s,c,u,h){for(n=c;n<u;++n)for(c=0;c<h;++c)o[s++]=a(r[i(t[e++])]);},t[e]=function(e,r,o,s,c,u,h){var l=8>>e.b,f=e.Ea,d=e.K[0],p=e.w;if(8>l)for(e=(1<<e.b)-1,p=(1<<l)-1;r<o;++r){var g,m=0;for(g=0;g<f;++g)g&e||(m=i(s[c++])),u[h++]=a(d[m&p]),m>>=l;}else t["VP8LMapColor"+n](s,c,d,p,u,h,r,o,f);};}function K(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>16&255,n[i++]=a>>8&255,n[i++]=a>>0&255;}}function Z(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>16&255,n[i++]=a>>8&255,n[i++]=a>>0&255,n[i++]=a>>24&255;}}function $(t,e,r,n,i){for(r=e+r;e<r;){var a=(o=t[e++])>>16&240|o>>12&15,o=o>>0&240|o>>28&15;n[i++]=a,n[i++]=o;}}function Q(t,e,r,n,i){for(r=e+r;e<r;){var a=(o=t[e++])>>16&248|o>>13&7,o=o>>5&224|o>>3&31;n[i++]=a,n[i++]=o;}}function tt(t,e,r,n,i){for(r=e+r;e<r;){var a=t[e++];n[i++]=a>>0&255,n[i++]=a>>8&255,n[i++]=a>>16&255;}}function et(t,e,r,i,a,o){if(0==o)for(r=e+r;e<r;)I(i,((o=t[e++])[0]>>24|o[1]>>8&65280|o[2]<<8&16711680|o[3]<<24)>>>0),a+=32;else n(i,a,t,e,r);}function rt(e,r){t[r][0]=t[e+"0"],t[r][1]=t[e+"1"],t[r][2]=t[e+"2"],t[r][3]=t[e+"3"],t[r][4]=t[e+"4"],t[r][5]=t[e+"5"],t[r][6]=t[e+"6"],t[r][7]=t[e+"7"],t[r][8]=t[e+"8"],t[r][9]=t[e+"9"],t[r][10]=t[e+"10"],t[r][11]=t[e+"11"],t[r][12]=t[e+"12"],t[r][13]=t[e+"13"],t[r][14]=t[e+"0"],t[r][15]=t[e+"0"];}function nt(t){return t==Hn||t==Wn||t==Vn||t==Gn}function it(){this.eb=[],this.size=this.A=this.fb=0;}function at(){this.y=[],this.f=[],this.ea=[],this.F=[],this.Tc=this.Ed=this.Cd=this.Fd=this.lb=this.Db=this.Ab=this.fa=this.J=this.W=this.N=this.O=0;}function ot(){this.Rd=this.height=this.width=this.S=0,this.f={},this.f.RGBA=new it,this.f.kb=new at,this.sd=null;}function st(){this.width=[0],this.height=[0],this.Pd=[0],this.Qd=[0],this.format=[0];}function ct(){this.Id=this.fd=this.Md=this.hb=this.ib=this.da=this.bd=this.cd=this.j=this.v=this.Da=this.Sd=this.ob=0;}function ut(t){return alert("todo:WebPSamplerProcessPlane"),t.T}function ht(t,e){var r=t.T,i=e.ba.f.RGBA,a=i.eb,o=i.fb+t.ka*i.A,s=vi[e.ba.S],c=t.y,u=t.O,h=t.f,l=t.N,f=t.ea,d=t.W,p=e.cc,g=e.dc,m=e.Mc,v=e.Nc,b=t.ka,y=t.ka+t.T,w=t.U,N=w+1>>1;for(0==b?s(c,u,null,null,h,l,f,d,h,l,f,d,a,o,null,null,w):(s(e.ec,e.fc,c,u,p,g,m,v,h,l,f,d,a,o-i.A,a,o,w),++r);b+2<y;b+=2)p=h,g=l,m=f,v=d,l+=t.Rc,d+=t.Rc,o+=2*i.A,s(c,(u+=2*t.fa)-t.fa,c,u,p,g,m,v,h,l,f,d,a,o-i.A,a,o,w);return u+=t.fa,t.j+y<t.o?(n(e.ec,e.fc,c,u,w),n(e.cc,e.dc,h,l,N),n(e.Mc,e.Nc,f,d,N),r--):1&y||s(c,u,null,null,h,l,f,d,h,l,f,d,a,o+i.A,null,null,w),r}function lt(t,r,n){var i=t.F,a=[t.J];if(null!=i){var o=t.U,s=r.ba.S,c=s==Tn||s==Vn;r=r.ba.f.RGBA;var u=[0],h=t.ka;u[0]=t.T,t.Kb&&(0==h?--u[0]:(--h,a[0]-=t.width),t.j+t.ka+t.T==t.o&&(u[0]=t.o-t.j-h));var l=r.eb;h=r.fb+h*r.A;t=Sn(i,a[0],t.width,o,u,l,h+(c?0:3),r.A),e(n==u),t&&nt(s)&&An(l,h,c,o,u,r.A);}return 0}function ft(t){var e=t.ma,r=e.ba.S,n=11>r,i=r==qn||r==Rn||r==Tn||r==Un||12==r||nt(r);if(e.memory=null,e.Ib=null,e.Jb=null,e.Nd=null,!Mr(e.Oa,t,i?11:12))return 0;if(i&&nt(r)&&br(),t.da)alert("todo:use_scaling");else {if(n){if(e.Ib=ut,t.Kb){if(r=t.U+1>>1,e.memory=a(t.U+2*r),null==e.memory)return 0;e.ec=e.memory,e.fc=0,e.cc=e.ec,e.dc=e.fc+t.U,e.Mc=e.cc,e.Nc=e.dc+r,e.Ib=ht,br();}}else alert("todo:EmitYUV");i&&(e.Jb=lt,n&&mr());}if(n&&!Ci){for(t=0;256>t;++t)ji[t]=89858*(t-128)+_i>>Si,Mi[t]=-22014*(t-128)+_i,Bi[t]=-45773*(t-128),Oi[t]=113618*(t-128)+_i>>Si;for(t=Pi;t<ki;++t)e=76283*(t-16)+_i>>Si,Ei[t-Pi]=Vt(e,255),qi[t-Pi]=Vt(e+8>>4,15);Ci=1;}return 1}function dt(t){var r=t.ma,n=t.U,i=t.T;return e(!(1&t.ka)),0>=n||0>=i?0:(n=r.Ib(t,r),null!=r.Jb&&r.Jb(t,r,n),r.Dc+=n,1)}function pt(t){t.ma.memory=null;}function gt(t,e,r,n){return 47!=y(t,8)?0:(e[0]=y(t,14)+1,r[0]=y(t,14)+1,n[0]=y(t,1),0!=y(t,3)?0:!t.h)}function mt(t,e){if(4>t)return t+1;var r=t-2>>1;return (2+(1&t)<<r)+y(e,r)+1}function vt(t,e){return 120<e?e-120:1<=(r=((r=$n[e-1])>>4)*t+(8-(15&r)))?r:1;var r;}function bt(t,e,r){var n=L(r),i=t[e+=255&n].g-8;return 0<i&&(x(r,r.u+8),n=L(r),e+=t[e].value,e+=n&(1<<i)-1),x(r,r.u+t[e].g),t[e].value}function yt(t,r,n){return n.g+=t.g,n.value+=t.value<<r>>>0,e(8>=n.g),t.g}function wt(t,r,n){var i=t.xc;return e((r=0==i?0:t.vc[t.md*(n>>i)+(r>>i)])<t.Wb),t.Ya[r]}function Nt(t,r,i,a){var o=t.ab,s=t.c*r,c=t.C;r=c+r;var u=i,h=a;for(a=t.Ta,i=t.Ua;0<o--;){var l=t.gc[o],f=c,d=r,p=u,g=h,m=(h=a,u=i,l.Ea);switch(e(f<d),e(d<=l.nc),l.hc){case 2:Gr(p,g,(d-f)*m,h,u);break;case 0:var v=f,b=d,y=h,w=u,N=(_=l).Ea;0==v&&(Wr(p,g,null,null,1,y,w),V(p,g+1,0,0,N-1,y,w+1),g+=N,w+=N,++v);for(var L=1<<_.b,A=L-1,x=q(N,_.b),S=_.K,_=_.w+(v>>_.b)*x;v<b;){var P=S,k=_,I=1;for(Vr(p,g,y,w-N,1,y,w);I<N;){var F=(I&~A)+L;F>N&&(F=N),(0, Zr[P[k++]>>8&15])(p,g+ +I,y,w+I-N,F-I,y,w+I),I=F;}g+=N,w+=N,++v&A||(_+=x);}d!=l.nc&&n(h,u-m,h,u+(d-f-1)*m,m);break;case 1:for(m=p,b=g,N=(p=l.Ea)-(w=p&~(y=(g=1<<l.b)-1)),v=q(p,l.b),L=l.K,l=l.w+(f>>l.b)*v;f<d;){for(A=L,x=l,S=new T,_=b+w,P=b+p;b<_;)Y(A[x++],S),$r(S,m,b,g,h,u),b+=g,u+=g;b<P&&(Y(A[x++],S),$r(S,m,b,N,h,u),b+=N,u+=N),++f&y||(l+=v);}break;case 3:if(p==h&&g==u&&0<l.b){for(b=h,p=m=u+(d-f)*m-(w=(d-f)*q(l.Ea,l.b)),g=h,y=u,v=[],w=(N=w)-1;0<=w;--w)v[w]=g[y+w];for(w=N-1;0<=w;--w)b[p+w]=v[w];Yr(l,f,d,h,m,h,u);}else Yr(l,f,d,p,g,h,u);}u=a,h=i;}h!=i&&n(a,i,u,h,s);}function Lt(t,r){var n=t.V,i=t.Ba+t.c*t.C,a=r-t.C;if(e(r<=t.l.o),e(16>=a),0<a){var o=t.l,s=t.Ta,c=t.Ua,u=o.width;if(Nt(t,a,n,i),a=c=[c],e((n=t.C)<(i=r)),e(o.v<o.va),i>o.o&&(i=o.o),n<o.j){var h=o.j-n;n=o.j;a[0]+=h*u;}if(n>=i?n=0:(a[0]+=4*o.v,o.ka=n-o.j,o.U=o.va-o.v,o.T=i-n,n=1),n){if(c=c[0],11>(n=t.ca).S){var l=n.f.RGBA,f=(i=n.S,a=o.U,o=o.T,h=l.eb,l.A),d=o;for(l=l.fb+t.Ma*l.A;0<d--;){var p=s,g=c,m=a,v=h,b=l;switch(i){case En:Qr(p,g,m,v,b);break;case qn:tn(p,g,m,v,b);break;case Hn:tn(p,g,m,v,b),An(v,b,0,m,1,0);break;case Dn:nn(p,g,m,v,b);break;case Rn:et(p,g,m,v,b,1);break;case Wn:et(p,g,m,v,b,1),An(v,b,0,m,1,0);break;case Tn:et(p,g,m,v,b,0);break;case Vn:et(p,g,m,v,b,0),An(v,b,1,m,1,0);break;case Un:en(p,g,m,v,b);break;case Gn:en(p,g,m,v,b),xn(v,b,m,1,0);break;case zn:rn(p,g,m,v,b);break;default:e(0);}c+=u,l+=f;}t.Ma+=o;}else alert("todo:EmitRescaledRowsYUVA");e(t.Ma<=n.height);}}t.C=r,e(t.C<=t.i);}function At(t){var e;if(0<t.ua)return 0;for(e=0;e<t.Wb;++e){var r=t.Ya[e].G,n=t.Ya[e].H;if(0<r[1][n[1]+0].g||0<r[2][n[2]+0].g||0<r[3][n[3]+0].g)return 0}return 1}function xt(t,r,n,i,a,o){if(0!=t.Z){var s=t.qd,c=t.rd;for(e(null!=mi[t.Z]);r<n;++r)mi[t.Z](s,c,i,a,i,a,o),s=i,c=a,a+=o;t.qd=s,t.rd=c;}}function St(t,r){var n=t.l.ma,i=0==n.Z||1==n.Z?t.l.j:t.C;i=t.C<i?i:t.C;if(e(r<=t.l.o),r>i){var a=t.l.width,o=n.ca,s=n.tb+a*i,c=t.V,u=t.Ba+t.c*i,h=t.gc;e(1==t.ab),e(3==h[0].hc),Xr(h[0],i,r,c,u,o,s),xt(n,i,r,o,s,a);}t.C=t.Ma=r;}function _t(t,r,n,i,a,o,s){var c=t.$/i,u=t.$%i,h=t.m,l=t.s,f=n+t.$,d=f;a=n+i*a;var p=n+i*o,g=280+l.ua,m=t.Pb?c:16777216,v=0<l.ua?l.Wa:null,b=l.wc,y=f<p?wt(l,u,c):null;e(t.C<o),e(p<=a);var w=!1;t:for(;;){for(;w||f<p;){var N=0;if(c>=m){var _=f-n;e((m=t).Pb),m.wd=m.m,m.xd=_,0<m.s.ua&&B(m.s.Wa,m.s.vb),m=c+ti;}if(u&b||(y=wt(l,u,c)),e(null!=y),y.Qb&&(r[f]=y.qb,w=!0),!w)if(S(h),y.jc){N=h,_=r;var P=f,k=y.pd[L(N)&Dr-1];e(y.jc),256>k.g?(x(N,N.u+k.g),_[P]=k.value,N=0):(x(N,N.u+k.g-256),e(256<=k.value),N=k.value),0==N&&(w=!0);}else N=bt(y.G[0],y.H[0],h);if(h.h)break;if(w||256>N){if(!w)if(y.nd)r[f]=(y.qb|N<<8)>>>0;else {if(S(h),w=bt(y.G[1],y.H[1],h),S(h),_=bt(y.G[2],y.H[2],h),P=bt(y.G[3],y.H[3],h),h.h)break;r[f]=(P<<24|w<<16|N<<8|_)>>>0;}if(w=!1,++f,++u>=i&&(u=0,++c,null!=s&&c<=o&&!(c%16)&&s(t,c),null!=v))for(;d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else if(280>N){if(N=mt(N-256,h),_=bt(y.G[4],y.H[4],h),S(h),_=vt(i,_=mt(_,h)),h.h)break;if(f-n<_||a-f<N)break t;for(P=0;P<N;++P)r[f+P]=r[f+P-_];for(f+=N,u+=N;u>=i;)u-=i,++c,null!=s&&c<=o&&!(c%16)&&s(t,c);if(e(f<=a),u&b&&(y=wt(l,u,c)),null!=v)for(;d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;}else {if(!(N<g))break t;for(w=N-280,e(null!=v);d<f;)N=r[d++],v.X[(506832829*N&4294967295)>>>v.Mb]=N;N=f,e(!(w>>>(_=v).Xa)),r[N]=_.X[w],w=!0;}w||e(h.h==A(h));}if(t.Pb&&h.h&&f<a)e(t.m.h),t.a=5,t.m=t.wd,t.$=t.xd,0<t.s.ua&&B(t.s.vb,t.s.Wa);else {if(h.h)break t;null!=s&&s(t,c>o?o:c),t.a=0,t.$=f-n;}return 1}return t.a=3,0}function Pt(t){e(null!=t),t.vc=null,t.yc=null,t.Ya=null;var r=t.Wa;null!=r&&(r.X=null),t.vb=null,e(null!=t);}function kt(){var e=new or;return null==e?null:(e.a=0,e.xb=gi,rt("Predictor","VP8LPredictors"),rt("Predictor","VP8LPredictors_C"),rt("PredictorAdd","VP8LPredictorsAdd"),rt("PredictorAdd","VP8LPredictorsAdd_C"),Gr=G,$r=J,Qr=K,tn=Z,en=$,rn=Q,nn=tt,t.VP8LMapColor32b=Jr,t.VP8LMapColor8b=Kr,e)}function It(t,r,n,s,c){var u=1,f=[t],p=[r],g=s.m,m=s.s,v=null,b=0;t:for(;;){if(n)for(;u&&y(g,1);){var w=f,N=p,A=s,_=1,P=A.m,k=A.gc[A.ab],I=y(P,2);if(A.Oc&1<<I)u=0;else {switch(A.Oc|=1<<I,k.hc=I,k.Ea=w[0],k.nc=N[0],k.K=[null],++A.ab,e(4>=A.ab),I){case 0:case 1:k.b=y(P,3)+2,_=It(q(k.Ea,k.b),q(k.nc,k.b),0,A,k.K),k.K=k.K[0];break;case 3:var F,C=y(P,8)+1,j=16<C?0:4<C?1:2<C?2:3;if(w[0]=q(k.Ea,j),k.b=j,F=_=It(C,1,0,A,k.K)){var B,M=C,E=k,R=1<<(8>>E.b),T=a(R);if(null==T)F=0;else {var U=E.K[0],z=E.w;for(T[0]=E.K[0][0],B=1;B<1*M;++B)T[B]=D(U[z+B],T[B-1]);for(;B<4*R;++B)T[B]=0;E.K[0]=null,E.K[0]=T,F=1;}}_=F;break;case 2:break;default:e(0);}u=_;}}if(f=f[0],p=p[0],u&&y(g,1)&&!(u=1<=(b=y(g,4))&&11>=b)){s.a=3;break t}var H;if(H=u)e:{var W,V,G,Y=s,J=f,X=p,K=b,Z=n,$=Y.m,Q=Y.s,tt=[null],et=1,rt=0,nt=Qn[K];r:for(;;){if(Z&&y($,1)){var it=y($,3)+2,at=q(J,it),ot=q(X,it),st=at*ot;if(!It(at,ot,0,Y,tt))break r;for(tt=tt[0],Q.xc=it,W=0;W<st;++W){var ct=tt[W]>>8&65535;tt[W]=ct,ct>=et&&(et=ct+1);}}if($.h)break r;for(V=0;5>V;++V){var ut=Xn[V];!V&&0<K&&(ut+=1<<K),rt<ut&&(rt=ut);}var ht=o(et*nt,l),lt=et,ft=o(lt,d);if(null==ft)var dt=null;else e(65536>=lt),dt=ft;var pt=a(rt);if(null==dt||null==pt||null==ht){Y.a=1;break r}var gt=ht;for(W=G=0;W<et;++W){var mt=dt[W],vt=mt.G,bt=mt.H,wt=0,Nt=1,Lt=0;for(V=0;5>V;++V){ut=Xn[V],vt[V]=gt,bt[V]=G,!V&&0<K&&(ut+=1<<K);n:{var At,xt=ut,St=Y,kt=pt,Ft=gt,Ct=G,jt=0,Ot=St.m,Bt=y(Ot,1);if(i(kt,0,0,xt),Bt){var Mt=y(Ot,1)+1,Et=y(Ot,1),qt=y(Ot,0==Et?1:8);kt[qt]=1,2==Mt&&(kt[qt=y(Ot,8)]=1);var Dt=1;}else {var Rt=a(19),Tt=y(Ot,4)+4;if(19<Tt){St.a=3;var Ut=0;break n}for(At=0;At<Tt;++At)Rt[Zn[At]]=y(Ot,3);var zt=void 0,Ht=void 0,Wt=St,Vt=Rt,Gt=xt,Yt=kt,Jt=0,Xt=Wt.m,Kt=8,Zt=o(128,l);i:for(;h(Zt,0,7,Vt,19);){if(y(Xt,1)){var $t=2+2*y(Xt,3);if((zt=2+y(Xt,$t))>Gt)break i}else zt=Gt;for(Ht=0;Ht<Gt&&zt--;){S(Xt);var Qt=Zt[0+(127&L(Xt))];x(Xt,Xt.u+Qt.g);var te=Qt.value;if(16>te)Yt[Ht++]=te,0!=te&&(Kt=te);else {var ee=16==te,re=te-16,ne=Jn[re],ie=y(Xt,Yn[re])+ne;if(Ht+ie>Gt)break i;for(var ae=ee?Kt:0;0<ie--;)Yt[Ht++]=ae;}}Jt=1;break i}Jt||(Wt.a=3),Dt=Jt;}(Dt=Dt&&!Ot.h)&&(jt=h(Ft,Ct,8,kt,xt)),Dt&&0!=jt?Ut=jt:(St.a=3,Ut=0);}if(0==Ut)break r;if(Nt&&1==Kn[V]&&(Nt=0==gt[G].g),wt+=gt[G].g,G+=Ut,3>=V){var oe,se=pt[0];for(oe=1;oe<ut;++oe)pt[oe]>se&&(se=pt[oe]);Lt+=se;}}if(mt.nd=Nt,mt.Qb=0,Nt&&(mt.qb=(vt[3][bt[3]+0].value<<24|vt[1][bt[1]+0].value<<16|vt[2][bt[2]+0].value)>>>0,0==wt&&256>vt[0][bt[0]+0].value&&(mt.Qb=1,mt.qb+=vt[0][bt[0]+0].value<<8)),mt.jc=!mt.Qb&&6>Lt,mt.jc){var ce,ue=mt;for(ce=0;ce<Dr;++ce){var he=ce,le=ue.pd[he],fe=ue.G[0][ue.H[0]+he];256<=fe.value?(le.g=fe.g+256,le.value=fe.value):(le.g=0,le.value=0,he>>=yt(fe,8,le),he>>=yt(ue.G[1][ue.H[1]+he],16,le),he>>=yt(ue.G[2][ue.H[2]+he],0,le),yt(ue.G[3][ue.H[3]+he],24,le));}}}Q.vc=tt,Q.Wb=et,Q.Ya=dt,Q.yc=ht,H=1;break e}H=0;}if(!(u=H)){s.a=3;break t}if(0<b){if(m.ua=1<<b,!O(m.Wa,b)){s.a=1,u=0;break t}}else m.ua=0;var de=s,pe=f,ge=p,me=de.s,ve=me.xc;if(de.c=pe,de.i=ge,me.md=q(pe,ve),me.wc=0==ve?-1:(1<<ve)-1,n){s.xb=pi;break t}if(null==(v=a(f*p))){s.a=1,u=0;break t}u=(u=_t(s,v,0,f,p,p,null))&&!g.h;break t}return u?(null!=c?c[0]=v:(e(null==v),e(n)),s.$=0,n||Pt(m)):Pt(m),u}function Ft(t,r){var n=t.c*t.i,i=n+r+16*r;return e(t.c<=r),t.V=a(i),null==t.V?(t.Ta=null,t.Ua=0,t.a=1,0):(t.Ta=t.V,t.Ua=t.Ba+n+r,1)}function Ct(t,r){var n=t.C,i=r-n,a=t.V,o=t.Ba+t.c*n;for(e(r<=t.l.o);0<i;){var s=16<i?16:i,c=t.l.ma,u=t.l.width,h=u*s,l=c.ca,f=c.tb+u*n,d=t.Ta,p=t.Ua;Nt(t,s,a,o),_n(d,p,l,f,h),xt(c,n,n+s,l,f,u),i-=s,a+=s*t.c,n+=s;}e(n==r),t.C=t.Ma=r;}function jt(){this.ub=this.yd=this.td=this.Rb=0;}function Ot(){this.Kd=this.Ld=this.Ud=this.Td=this.i=this.c=0;}function Bt(){this.Fb=this.Bb=this.Cb=0,this.Zb=a(4),this.Lb=a(4);}function Mt(){this.Yb=function(){var t=[];return function t(e,r,n){for(var i=n[r],a=0;a<i&&(e.push(n.length>r+1?[]:0),!(n.length<r+1));a++)t(e[a],r+1,n);}(t,0,[3,11]),t}();}function Et(){this.jb=a(3),this.Wc=s([4,8],Mt),this.Xc=s([4,17],Mt);}function qt(){this.Pc=this.wb=this.Tb=this.zd=0,this.vd=new a(4),this.od=new a(4);}function Dt(){this.ld=this.La=this.dd=this.tc=0;}function Rt(){this.Na=this.la=0;}function Tt(){this.Sc=[0,0],this.Eb=[0,0],this.Qc=[0,0],this.ia=this.lc=0;}function Ut(){this.ad=a(384),this.Za=0,this.Ob=a(16),this.$b=this.Ad=this.ia=this.Gc=this.Hc=this.Dd=0;}function zt(){this.uc=this.M=this.Nb=0,this.wa=Array(new Dt),this.Y=0,this.ya=Array(new Ut),this.aa=0,this.l=new Gt;}function Ht(){this.y=a(16),this.f=a(8),this.ea=a(8);}function Wt(){this.cb=this.a=0,this.sc="",this.m=new w,this.Od=new jt,this.Kc=new Ot,this.ed=new qt,this.Qa=new Bt,this.Ic=this.$c=this.Aa=0,this.D=new zt,this.Xb=this.Va=this.Hb=this.zb=this.yb=this.Ub=this.za=0,this.Jc=o(8,w),this.ia=0,this.pb=o(4,Tt),this.Pa=new Et,this.Bd=this.kc=0,this.Ac=[],this.Bc=0,this.zc=[0,0,0,0],this.Gd=Array(new Ht),this.Hd=0,this.rb=Array(new Rt),this.sb=0,this.wa=Array(new Dt),this.Y=0,this.oc=[],this.pc=0,this.sa=[],this.ta=0,this.qa=[],this.ra=0,this.Ha=[],this.B=this.R=this.Ia=0,this.Ec=[],this.M=this.ja=this.Vb=this.Fc=0,this.ya=Array(new Ut),this.L=this.aa=0,this.gd=s([4,2],Dt),this.ga=null,this.Fa=[],this.Cc=this.qc=this.P=0,this.Gb=[],this.Uc=0,this.mb=[],this.nb=0,this.rc=[],this.Ga=this.Vc=0;}function Vt(t,e){return 0>t?0:t>e?e:t}function Gt(){this.T=this.U=this.ka=this.height=this.width=0,this.y=[],this.f=[],this.ea=[],this.Rc=this.fa=this.W=this.N=this.O=0,this.ma="void",this.put="VP8IoPutHook",this.ac="VP8IoSetupHook",this.bc="VP8IoTeardownHook",this.ha=this.Kb=0,this.data=[],this.hb=this.ib=this.da=this.o=this.j=this.va=this.v=this.Da=this.ob=this.w=0,this.F=[],this.J=0;}function Yt(){var t=new Wt;return null!=t&&(t.a=0,t.sc="OK",t.cb=0,t.Xb=0,ni||(ni=Zt)),t}function Jt(t,e,r){return 0==t.a&&(t.a=e,t.sc=r,t.cb=0),0}function Xt(t,e,r){return 3<=r&&157==t[e+0]&&1==t[e+1]&&42==t[e+2]}function Kt(t,r){if(null==t)return 0;if(t.a=0,t.sc="OK",null==r)return Jt(t,2,"null VP8Io passed to VP8GetHeaders()");var n=r.data,a=r.w,o=r.ha;if(4>o)return Jt(t,7,"Truncated header.");var s=n[a+0]|n[a+1]<<8|n[a+2]<<16,c=t.Od;if(c.Rb=!(1&s),c.td=s>>1&7,c.yd=s>>4&1,c.ub=s>>5,3<c.td)return Jt(t,3,"Incorrect keyframe parameters.");if(!c.yd)return Jt(t,4,"Frame not displayable.");a+=3,o-=3;var u=t.Kc;if(c.Rb){if(7>o)return Jt(t,7,"cannot parse picture header");if(!Xt(n,a,o))return Jt(t,3,"Bad code word");u.c=16383&(n[a+4]<<8|n[a+3]),u.Td=n[a+4]>>6,u.i=16383&(n[a+6]<<8|n[a+5]),u.Ud=n[a+6]>>6,a+=7,o-=7,t.za=u.c+15>>4,t.Ub=u.i+15>>4,r.width=u.c,r.height=u.i,r.Da=0,r.j=0,r.v=0,r.va=r.width,r.o=r.height,r.da=0,r.ib=r.width,r.hb=r.height,r.U=r.width,r.T=r.height,i((s=t.Pa).jb,0,255,s.jb.length),e(null!=(s=t.Qa)),s.Cb=0,s.Bb=0,s.Fb=1,i(s.Zb,0,0,s.Zb.length),i(s.Lb,0,0,s.Lb);}if(c.ub>o)return Jt(t,7,"bad partition length");p(s=t.m,n,a,c.ub),a+=c.ub,o-=c.ub,c.Rb&&(u.Ld=P(s),u.Kd=P(s)),u=t.Qa;var h,l=t.Pa;if(e(null!=s),e(null!=u),u.Cb=P(s),u.Cb){if(u.Bb=P(s),P(s)){for(u.Fb=P(s),h=0;4>h;++h)u.Zb[h]=P(s)?m(s,7):0;for(h=0;4>h;++h)u.Lb[h]=P(s)?m(s,6):0;}if(u.Bb)for(h=0;3>h;++h)l.jb[h]=P(s)?g(s,8):255;}else u.Bb=0;if(s.Ka)return Jt(t,3,"cannot parse segment header");if((u=t.ed).zd=P(s),u.Tb=g(s,6),u.wb=g(s,3),u.Pc=P(s),u.Pc&&P(s)){for(l=0;4>l;++l)P(s)&&(u.vd[l]=m(s,6));for(l=0;4>l;++l)P(s)&&(u.od[l]=m(s,6));}if(t.L=0==u.Tb?0:u.zd?1:2,s.Ka)return Jt(t,3,"cannot parse filter header");var f=o;if(o=h=a,a=h+f,u=f,t.Xb=(1<<g(t.m,2))-1,f<3*(l=t.Xb))n=7;else {for(h+=3*l,u-=3*l,f=0;f<l;++f){var d=n[o+0]|n[o+1]<<8|n[o+2]<<16;d>u&&(d=u),p(t.Jc[+f],n,h,d),h+=d,u-=d,o+=3;}p(t.Jc[+l],n,h,u),n=h<a?0:5;}if(0!=n)return Jt(t,n,"cannot parse partitions");for(n=g(h=t.m,7),o=P(h)?m(h,4):0,a=P(h)?m(h,4):0,u=P(h)?m(h,4):0,l=P(h)?m(h,4):0,h=P(h)?m(h,4):0,f=t.Qa,d=0;4>d;++d){if(f.Cb){var v=f.Zb[d];f.Fb||(v+=n);}else {if(0<d){t.pb[d]=t.pb[0];continue}v=n;}var b=t.pb[d];b.Sc[0]=ei[Vt(v+o,127)],b.Sc[1]=ri[Vt(v+0,127)],b.Eb[0]=2*ei[Vt(v+a,127)],b.Eb[1]=101581*ri[Vt(v+u,127)]>>16,8>b.Eb[1]&&(b.Eb[1]=8),b.Qc[0]=ei[Vt(v+l,117)],b.Qc[1]=ri[Vt(v+h,127)],b.lc=v+h;}if(!c.Rb)return Jt(t,4,"Not a key frame.");for(P(s),c=t.Pa,n=0;4>n;++n){for(o=0;8>o;++o)for(a=0;3>a;++a)for(u=0;11>u;++u)l=k(s,ui[n][o][a][u])?g(s,8):si[n][o][a][u],c.Wc[n][o].Yb[a][u]=l;for(o=0;17>o;++o)c.Xc[n][o]=c.Wc[n][hi[o]];}return t.kc=P(s),t.kc&&(t.Bd=g(s,8)),t.cb=1}function Zt(t,e,r,n,i,a,o){var s=e[i].Yb[r];for(r=0;16>i;++i){if(!k(t,s[r+0]))return i;for(;!k(t,s[r+1]);)if(s=e[++i].Yb[0],r=0,16==i)return 16;var c=e[i+1].Yb;if(k(t,s[r+2])){var u=t,h=0;if(k(u,(f=s)[(l=r)+3]))if(k(u,f[l+6])){for(s=0,l=2*(h=k(u,f[l+8]))+(f=k(u,f[l+9+h])),h=0,f=ii[l];f[s];++s)h+=h+k(u,f[s]);h+=3+(8<<l);}else k(u,f[l+7])?(h=7+2*k(u,165),h+=k(u,145)):h=5+k(u,159);else h=k(u,f[l+4])?3+k(u,f[l+5]):2;s=c[2];}else h=1,s=c[1];c=o+ai[i],0>(u=t).b&&_(u);var l,f=u.b,d=(l=u.Ca>>1)-(u.I>>f)>>31;--u.b,u.Ca+=d,u.Ca|=1,u.I-=(l+1&d)<<f,a[c]=((h^d)-d)*n[(0<i)+0];}return 16}function $t(t){var e=t.rb[t.sb-1];e.la=0,e.Na=0,i(t.zc,0,0,t.zc.length),t.ja=0;}function Qt(t,r){if(null==t)return 0;if(null==r)return Jt(t,2,"NULL VP8Io parameter in VP8Decode().");if(!t.cb&&!Kt(t,r))return 0;if(e(t.cb),null==r.ac||r.ac(r)){r.ob&&(t.L=0);var s=Ri[t.L];if(2==t.L?(t.yb=0,t.zb=0):(t.yb=r.v-s>>4,t.zb=r.j-s>>4,0>t.yb&&(t.yb=0),0>t.zb&&(t.zb=0)),t.Va=r.o+15+s>>4,t.Hb=r.va+15+s>>4,t.Hb>t.za&&(t.Hb=t.za),t.Va>t.Ub&&(t.Va=t.Ub),0<t.L){var c=t.ed;for(s=0;4>s;++s){var u;if(t.Qa.Cb){var h=t.Qa.Lb[s];t.Qa.Fb||(h+=c.Tb);}else h=c.Tb;for(u=0;1>=u;++u){var l=t.gd[s][u],f=h;if(c.Pc&&(f+=c.vd[0],u&&(f+=c.od[0])),0<(f=0>f?0:63<f?63:f)){var d=f;0<c.wb&&((d=4<c.wb?d>>2:d>>1)>9-c.wb&&(d=9-c.wb)),1>d&&(d=1),l.dd=d,l.tc=2*f+d,l.ld=40<=f?2:15<=f?1:0;}else l.tc=0;l.La=u;}}}s=0;}else Jt(t,6,"Frame setup failed"),s=t.a;if(s=0==s){if(s){t.$c=0,0<t.Aa||(t.Ic=Ui);t:{s=t.Ic;c=4*(d=t.za);var p=32*d,g=d+1,m=0<t.L?d*(0<t.Aa?2:1):0,v=(2==t.Aa?2:1)*d;if((l=c+832+(u=3*(16*s+Ri[t.L])/2*p)+(h=null!=t.Fa&&0<t.Fa.length?t.Kc.c*t.Kc.i:0))!=l)s=0;else {if(l>t.Vb){if(t.Vb=0,t.Ec=a(l),t.Fc=0,null==t.Ec){s=Jt(t,1,"no memory during frame initialization.");break t}t.Vb=l;}l=t.Ec,f=t.Fc,t.Ac=l,t.Bc=f,f+=c,t.Gd=o(p,Ht),t.Hd=0,t.rb=o(g+1,Rt),t.sb=1,t.wa=m?o(m,Dt):null,t.Y=0,t.D.Nb=0,t.D.wa=t.wa,t.D.Y=t.Y,0<t.Aa&&(t.D.Y+=d),e(!0),t.oc=l,t.pc=f,f+=832,t.ya=o(v,Ut),t.aa=0,t.D.ya=t.ya,t.D.aa=t.aa,2==t.Aa&&(t.D.aa+=d),t.R=16*d,t.B=8*d,d=(p=Ri[t.L])*t.R,p=p/2*t.B,t.sa=l,t.ta=f+d,t.qa=t.sa,t.ra=t.ta+16*s*t.R+p,t.Ha=t.qa,t.Ia=t.ra+8*s*t.B+p,t.$c=0,f+=u,t.mb=h?l:null,t.nb=h?f:null,e(f+h<=t.Fc+t.Vb),$t(t),i(t.Ac,t.Bc,0,c),s=1;}}if(s){if(r.ka=0,r.y=t.sa,r.O=t.ta,r.f=t.qa,r.N=t.ra,r.ea=t.Ha,r.Vd=t.Ia,r.fa=t.R,r.Rc=t.B,r.F=null,r.J=0,!Cn){for(s=-255;255>=s;++s)Pn[255+s]=0>s?-s:s;for(s=-1020;1020>=s;++s)kn[1020+s]=-128>s?-128:127<s?127:s;for(s=-112;112>=s;++s)In[112+s]=-16>s?-16:15<s?15:s;for(s=-255;510>=s;++s)Fn[255+s]=0>s?0:255<s?255:s;Cn=1;}an=ue,on=ae,cn=oe,un=se,hn=ce,sn=ie,ln=Je,fn=Xe,dn=$e,pn=Qe,gn=Ke,mn=Ze,vn=tr,bn=er,yn=ze,wn=He,Nn=We,Ln=Ve,fi[0]=xe,fi[1]=le,fi[2]=Le,fi[3]=Ae,fi[4]=Se,fi[5]=Pe,fi[6]=_e,fi[7]=ke,fi[8]=Fe,fi[9]=Ie,li[0]=ve,li[1]=de,li[2]=pe,li[3]=ge,li[4]=be,li[5]=ye,li[6]=we,di[0]=Be,di[1]=fe,di[2]=Ce,di[3]=je,di[4]=Ee,di[5]=Me,di[6]=qe,s=1;}else s=0;}s&&(s=function(t,r){for(t.M=0;t.M<t.Va;++t.M){var o,s=t.Jc[t.M&t.Xb],c=t.m,u=t;for(o=0;o<u.za;++o){var h=c,l=u,f=l.Ac,d=l.Bc+4*o,p=l.zc,g=l.ya[l.aa+o];if(l.Qa.Bb?g.$b=k(h,l.Pa.jb[0])?2+k(h,l.Pa.jb[2]):k(h,l.Pa.jb[1]):g.$b=0,l.kc&&(g.Ad=k(h,l.Bd)),g.Za=!k(h,145)+0,g.Za){var m=g.Ob,v=0;for(l=0;4>l;++l){var b,y=p[0+l];for(b=0;4>b;++b){y=ci[f[d+b]][y];for(var w=oi[k(h,y[0])];0<w;)w=oi[2*w+k(h,y[w])];y=-w,f[d+b]=y;}n(m,v,f,d,4),v+=4,p[0+l]=y;}}else y=k(h,156)?k(h,128)?1:3:k(h,163)?2:0,g.Ob[0]=y,i(f,d,y,4),i(p,0,y,4);g.Dd=k(h,142)?k(h,114)?k(h,183)?1:3:2:0;}if(u.m.Ka)return Jt(t,7,"Premature end-of-partition0 encountered.");for(;t.ja<t.za;++t.ja){if(u=s,h=(c=t).rb[c.sb-1],f=c.rb[c.sb+c.ja],o=c.ya[c.aa+c.ja],d=c.kc?o.Ad:0)h.la=f.la=0,o.Za||(h.Na=f.Na=0),o.Hc=0,o.Gc=0,o.ia=0;else {var N,L;h=f,f=u,d=c.Pa.Xc,p=c.ya[c.aa+c.ja],g=c.pb[p.$b];if(l=p.ad,m=0,v=c.rb[c.sb-1],y=b=0,i(l,m,0,384),p.Za)var A=0,x=d[3];else {w=a(16);var S=h.Na+v.Na;if(S=ni(f,d[1],S,g.Eb,0,w,0),h.Na=v.Na=(0<S)+0,1<S)an(w,0,l,m);else {var _=w[0]+3>>3;for(w=0;256>w;w+=16)l[m+w]=_;}A=1,x=d[0];}var P=15&h.la,I=15&v.la;for(w=0;4>w;++w){var F=1&I;for(_=L=0;4>_;++_)P=P>>1|(F=(S=ni(f,x,S=F+(1&P),g.Sc,A,l,m))>A)<<7,L=L<<2|(3<S?3:1<S?2:0!=l[m+0]),m+=16;P>>=4,I=I>>1|F<<7,b=(b<<8|L)>>>0;}for(x=P,A=I>>4,N=0;4>N;N+=2){for(L=0,P=h.la>>4+N,I=v.la>>4+N,w=0;2>w;++w){for(F=1&I,_=0;2>_;++_)S=F+(1&P),P=P>>1|(F=0<(S=ni(f,d[2],S,g.Qc,0,l,m)))<<3,L=L<<2|(3<S?3:1<S?2:0!=l[m+0]),m+=16;P>>=2,I=I>>1|F<<5;}y|=L<<4*N,x|=P<<4<<N,A|=(240&I)<<N;}h.la=x,v.la=A,p.Hc=b,p.Gc=y,p.ia=43690&y?0:g.ia,d=!(b|y);}if(0<c.L&&(c.wa[c.Y+c.ja]=c.gd[o.$b][o.Za],c.wa[c.Y+c.ja].La|=!d),u.Ka)return Jt(t,7,"Premature end-of-file encountered.")}if($t(t),c=r,u=1,o=(s=t).D,h=0<s.L&&s.M>=s.zb&&s.M<=s.Va,0==s.Aa)t:{if(o.M=s.M,o.uc=h,Or(s,o),u=1,o=(L=s.D).Nb,h=(y=Ri[s.L])*s.R,f=y/2*s.B,w=16*o*s.R,_=8*o*s.B,d=s.sa,p=s.ta-h+w,g=s.qa,l=s.ra-f+_,m=s.Ha,v=s.Ia-f+_,I=0==(P=L.M),b=P>=s.Va-1,2==s.Aa&&Or(s,L),L.uc)for(F=(S=s).D.M,e(S.D.uc),L=S.yb;L<S.Hb;++L){A=L,x=F;var C=(j=(U=S).D).Nb;N=U.R;var j=j.wa[j.Y+A],O=U.sa,B=U.ta+16*C*N+16*A,M=j.dd,E=j.tc;if(0!=E)if(e(3<=E),1==U.L)0<A&&wn(O,B,N,E+4),j.La&&Ln(O,B,N,E),0<x&&yn(O,B,N,E+4),j.La&&Nn(O,B,N,E);else {var q=U.B,D=U.qa,R=U.ra+8*C*q+8*A,T=U.Ha,U=U.Ia+8*C*q+8*A;C=j.ld;0<A&&(fn(O,B,N,E+4,M,C),pn(D,R,T,U,q,E+4,M,C)),j.La&&(mn(O,B,N,E,M,C),bn(D,R,T,U,q,E,M,C)),0<x&&(ln(O,B,N,E+4,M,C),dn(D,R,T,U,q,E+4,M,C)),j.La&&(gn(O,B,N,E,M,C),vn(D,R,T,U,q,E,M,C));}}if(s.ia&&alert("todo:DitherRow"),null!=c.put){if(L=16*P,P=16*(P+1),I?(c.y=s.sa,c.O=s.ta+w,c.f=s.qa,c.N=s.ra+_,c.ea=s.Ha,c.W=s.Ia+_):(L-=y,c.y=d,c.O=p,c.f=g,c.N=l,c.ea=m,c.W=v),b||(P-=y),P>c.o&&(P=c.o),c.F=null,c.J=null,null!=s.Fa&&0<s.Fa.length&&L<P&&(c.J=lr(s,c,L,P-L),c.F=s.mb,null==c.F&&0==c.F.length)){u=Jt(s,3,"Could not decode alpha data.");break t}L<c.j&&(y=c.j-L,L=c.j,e(!(1&y)),c.O+=s.R*y,c.N+=s.B*(y>>1),c.W+=s.B*(y>>1),null!=c.F&&(c.J+=c.width*y)),L<P&&(c.O+=c.v,c.N+=c.v>>1,c.W+=c.v>>1,null!=c.F&&(c.J+=c.v),c.ka=L-c.j,c.U=c.va-c.v,c.T=P-L,u=c.put(c));}o+1!=s.Ic||b||(n(s.sa,s.ta-h,d,p+16*s.R,h),n(s.qa,s.ra-f,g,l+8*s.B,f),n(s.Ha,s.Ia-f,m,v+8*s.B,f));}if(!u)return Jt(t,6,"Output aborted.")}return 1}(t,r)),null!=r.bc&&r.bc(r),s&=1;}return s?(t.cb=0,s):0}function te(t,e,r,n,i){i=t[e+r+32*n]+(i>>3),t[e+r+32*n]=-256&i?0>i?0:255:i;}function ee(t,e,r,n,i,a){te(t,e,0,r,n+i),te(t,e,1,r,n+a),te(t,e,2,r,n-a),te(t,e,3,r,n-i);}function re(t){return (20091*t>>16)+t}function ne(t,e,r,n){var i,o=0,s=a(16);for(i=0;4>i;++i){var c=t[e+0]+t[e+8],u=t[e+0]-t[e+8],h=(35468*t[e+4]>>16)-re(t[e+12]),l=re(t[e+4])+(35468*t[e+12]>>16);s[o+0]=c+l,s[o+1]=u+h,s[o+2]=u-h,s[o+3]=c-l,o+=4,e++;}for(i=o=0;4>i;++i)c=(t=s[o+0]+4)+s[o+8],u=t-s[o+8],h=(35468*s[o+4]>>16)-re(s[o+12]),te(r,n,0,0,c+(l=re(s[o+4])+(35468*s[o+12]>>16))),te(r,n,1,0,u+h),te(r,n,2,0,u-h),te(r,n,3,0,c-l),o++,n+=32;}function ie(t,e,r,n){var i=t[e+0]+4,a=35468*t[e+4]>>16,o=re(t[e+4]),s=35468*t[e+1]>>16;ee(r,n,0,i+o,t=re(t[e+1]),s),ee(r,n,1,i+a,t,s),ee(r,n,2,i-a,t,s),ee(r,n,3,i-o,t,s);}function ae(t,e,r,n,i){ne(t,e,r,n),i&&ne(t,e+16,r,n+4);}function oe(t,e,r,n){on(t,e+0,r,n,1),on(t,e+32,r,n+128,1);}function se(t,e,r,n){var i;for(t=t[e+0]+4,i=0;4>i;++i)for(e=0;4>e;++e)te(r,n,e,i,t);}function ce(t,e,r,n){t[e+0]&&un(t,e+0,r,n),t[e+16]&&un(t,e+16,r,n+4),t[e+32]&&un(t,e+32,r,n+128),t[e+48]&&un(t,e+48,r,n+128+4);}function ue(t,e,r,n){var i,o=a(16);for(i=0;4>i;++i){var s=t[e+0+i]+t[e+12+i],c=t[e+4+i]+t[e+8+i],u=t[e+4+i]-t[e+8+i],h=t[e+0+i]-t[e+12+i];o[0+i]=s+c,o[8+i]=s-c,o[4+i]=h+u,o[12+i]=h-u;}for(i=0;4>i;++i)s=(t=o[0+4*i]+3)+o[3+4*i],c=o[1+4*i]+o[2+4*i],u=o[1+4*i]-o[2+4*i],h=t-o[3+4*i],r[n+0]=s+c>>3,r[n+16]=h+u>>3,r[n+32]=s-c>>3,r[n+48]=h-u>>3,n+=64;}function he(t,e,r){var n,i=e-32,a=Bn,o=255-t[i-1];for(n=0;n<r;++n){var s,c=a,u=o+t[e-1];for(s=0;s<r;++s)t[e+s]=c[u+t[i+s]];e+=32;}}function le(t,e){he(t,e,4);}function fe(t,e){he(t,e,8);}function de(t,e){he(t,e,16);}function pe(t,e){var r;for(r=0;16>r;++r)n(t,e+32*r,t,e-32,16);}function ge(t,e){var r;for(r=16;0<r;--r)i(t,e,t[e-1],16),e+=32;}function me(t,e,r){var n;for(n=0;16>n;++n)i(e,r+32*n,t,16);}function ve(t,e){var r,n=16;for(r=0;16>r;++r)n+=t[e-1+32*r]+t[e+r-32];me(n>>5,t,e);}function be(t,e){var r,n=8;for(r=0;16>r;++r)n+=t[e-1+32*r];me(n>>4,t,e);}function ye(t,e){var r,n=8;for(r=0;16>r;++r)n+=t[e+r-32];me(n>>4,t,e);}function we(t,e){me(128,t,e);}function Ne(t,e,r){return t+2*e+r+2>>2}function Le(t,e){var r,i=e-32;i=new Uint8Array([Ne(t[i-1],t[i+0],t[i+1]),Ne(t[i+0],t[i+1],t[i+2]),Ne(t[i+1],t[i+2],t[i+3]),Ne(t[i+2],t[i+3],t[i+4])]);for(r=0;4>r;++r)n(t,e+32*r,i,0,i.length);}function Ae(t,e){var r=t[e-1],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96];I(t,e+0,16843009*Ne(t[e-1-32],r,n)),I(t,e+32,16843009*Ne(r,n,i)),I(t,e+64,16843009*Ne(n,i,a)),I(t,e+96,16843009*Ne(i,a,a));}function xe(t,e){var r,n=4;for(r=0;4>r;++r)n+=t[e+r-32]+t[e-1+32*r];for(n>>=3,r=0;4>r;++r)i(t,e+32*r,n,4);}function Se(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],c=t[e+2-32],u=t[e+3-32];t[e+0+96]=Ne(n,i,t[e-1+96]),t[e+1+96]=t[e+0+64]=Ne(r,n,i),t[e+2+96]=t[e+1+64]=t[e+0+32]=Ne(a,r,n),t[e+3+96]=t[e+2+64]=t[e+1+32]=t[e+0+0]=Ne(o,a,r),t[e+3+64]=t[e+2+32]=t[e+1+0]=Ne(s,o,a),t[e+3+32]=t[e+2+0]=Ne(c,s,o),t[e+3+0]=Ne(u,c,s);}function _e(t,e){var r=t[e+1-32],n=t[e+2-32],i=t[e+3-32],a=t[e+4-32],o=t[e+5-32],s=t[e+6-32],c=t[e+7-32];t[e+0+0]=Ne(t[e+0-32],r,n),t[e+1+0]=t[e+0+32]=Ne(r,n,i),t[e+2+0]=t[e+1+32]=t[e+0+64]=Ne(n,i,a),t[e+3+0]=t[e+2+32]=t[e+1+64]=t[e+0+96]=Ne(i,a,o),t[e+3+32]=t[e+2+64]=t[e+1+96]=Ne(a,o,s),t[e+3+64]=t[e+2+96]=Ne(o,s,c),t[e+3+96]=Ne(s,c,c);}function Pe(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1-32],o=t[e+0-32],s=t[e+1-32],c=t[e+2-32],u=t[e+3-32];t[e+0+0]=t[e+1+64]=a+o+1>>1,t[e+1+0]=t[e+2+64]=o+s+1>>1,t[e+2+0]=t[e+3+64]=s+c+1>>1,t[e+3+0]=c+u+1>>1,t[e+0+96]=Ne(i,n,r),t[e+0+64]=Ne(n,r,a),t[e+0+32]=t[e+1+96]=Ne(r,a,o),t[e+1+32]=t[e+2+96]=Ne(a,o,s),t[e+2+32]=t[e+3+96]=Ne(o,s,c),t[e+3+32]=Ne(s,c,u);}function ke(t,e){var r=t[e+0-32],n=t[e+1-32],i=t[e+2-32],a=t[e+3-32],o=t[e+4-32],s=t[e+5-32],c=t[e+6-32],u=t[e+7-32];t[e+0+0]=r+n+1>>1,t[e+1+0]=t[e+0+64]=n+i+1>>1,t[e+2+0]=t[e+1+64]=i+a+1>>1,t[e+3+0]=t[e+2+64]=a+o+1>>1,t[e+0+32]=Ne(r,n,i),t[e+1+32]=t[e+0+96]=Ne(n,i,a),t[e+2+32]=t[e+1+96]=Ne(i,a,o),t[e+3+32]=t[e+2+96]=Ne(a,o,s),t[e+3+64]=Ne(o,s,c),t[e+3+96]=Ne(s,c,u);}function Ie(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96];t[e+0+0]=r+n+1>>1,t[e+2+0]=t[e+0+32]=n+i+1>>1,t[e+2+32]=t[e+0+64]=i+a+1>>1,t[e+1+0]=Ne(r,n,i),t[e+3+0]=t[e+1+32]=Ne(n,i,a),t[e+3+32]=t[e+1+64]=Ne(i,a,a),t[e+3+64]=t[e+2+64]=t[e+0+96]=t[e+1+96]=t[e+2+96]=t[e+3+96]=a;}function Fe(t,e){var r=t[e-1+0],n=t[e-1+32],i=t[e-1+64],a=t[e-1+96],o=t[e-1-32],s=t[e+0-32],c=t[e+1-32],u=t[e+2-32];t[e+0+0]=t[e+2+32]=r+o+1>>1,t[e+0+32]=t[e+2+64]=n+r+1>>1,t[e+0+64]=t[e+2+96]=i+n+1>>1,t[e+0+96]=a+i+1>>1,t[e+3+0]=Ne(s,c,u),t[e+2+0]=Ne(o,s,c),t[e+1+0]=t[e+3+32]=Ne(r,o,s),t[e+1+32]=t[e+3+64]=Ne(n,r,o),t[e+1+64]=t[e+3+96]=Ne(i,n,r),t[e+1+96]=Ne(a,i,n);}function Ce(t,e){var r;for(r=0;8>r;++r)n(t,e+32*r,t,e-32,8);}function je(t,e){var r;for(r=0;8>r;++r)i(t,e,t[e-1],8),e+=32;}function Oe(t,e,r){var n;for(n=0;8>n;++n)i(e,r+32*n,t,8);}function Be(t,e){var r,n=8;for(r=0;8>r;++r)n+=t[e+r-32]+t[e-1+32*r];Oe(n>>4,t,e);}function Me(t,e){var r,n=4;for(r=0;8>r;++r)n+=t[e+r-32];Oe(n>>3,t,e);}function Ee(t,e){var r,n=4;for(r=0;8>r;++r)n+=t[e-1+32*r];Oe(n>>3,t,e);}function qe(t,e){Oe(128,t,e);}function De(t,e,r){var n=t[e-r],i=t[e+0],a=3*(i-n)+jn[1020+t[e-2*r]-t[e+r]],o=On[112+(a+4>>3)];t[e-r]=Bn[255+n+On[112+(a+3>>3)]],t[e+0]=Bn[255+i-o];}function Re(t,e,r,n){var i=t[e+0],a=t[e+r];return Mn[255+t[e-2*r]-t[e-r]]>n||Mn[255+a-i]>n}function Te(t,e,r,n){return 4*Mn[255+t[e-r]-t[e+0]]+Mn[255+t[e-2*r]-t[e+r]]<=n}function Ue(t,e,r,n,i){var a=t[e-3*r],o=t[e-2*r],s=t[e-r],c=t[e+0],u=t[e+r],h=t[e+2*r],l=t[e+3*r];return 4*Mn[255+s-c]+Mn[255+o-u]>n?0:Mn[255+t[e-4*r]-a]<=i&&Mn[255+a-o]<=i&&Mn[255+o-s]<=i&&Mn[255+l-h]<=i&&Mn[255+h-u]<=i&&Mn[255+u-c]<=i}function ze(t,e,r,n){var i=2*n+1;for(n=0;16>n;++n)Te(t,e+n,r,i)&&De(t,e+n,r);}function He(t,e,r,n){var i=2*n+1;for(n=0;16>n;++n)Te(t,e+n*r,1,i)&&De(t,e+n*r,1);}function We(t,e,r,n){var i;for(i=3;0<i;--i)ze(t,e+=4*r,r,n);}function Ve(t,e,r,n){var i;for(i=3;0<i;--i)He(t,e+=4,r,n);}function Ge(t,e,r,n,i,a,o,s){for(a=2*a+1;0<i--;){if(Ue(t,e,r,a,o))if(Re(t,e,r,s))De(t,e,r);else {var c=t,u=e,h=r,l=c[u-2*h],f=c[u-h],d=c[u+0],p=c[u+h],g=c[u+2*h],m=27*(b=jn[1020+3*(d-f)+jn[1020+l-p]])+63>>7,v=18*b+63>>7,b=9*b+63>>7;c[u-3*h]=Bn[255+c[u-3*h]+b],c[u-2*h]=Bn[255+l+v],c[u-h]=Bn[255+f+m],c[u+0]=Bn[255+d-m],c[u+h]=Bn[255+p-v],c[u+2*h]=Bn[255+g-b];}e+=n;}}function Ye(t,e,r,n,i,a,o,s){for(a=2*a+1;0<i--;){if(Ue(t,e,r,a,o))if(Re(t,e,r,s))De(t,e,r);else {var c=t,u=e,h=r,l=c[u-h],f=c[u+0],d=c[u+h],p=On[112+((g=3*(f-l))+4>>3)],g=On[112+(g+3>>3)],m=p+1>>1;c[u-2*h]=Bn[255+c[u-2*h]+m],c[u-h]=Bn[255+l+g],c[u+0]=Bn[255+f-p],c[u+h]=Bn[255+d-m];}e+=n;}}function Je(t,e,r,n,i,a){Ge(t,e,r,1,16,n,i,a);}function Xe(t,e,r,n,i,a){Ge(t,e,1,r,16,n,i,a);}function Ke(t,e,r,n,i,a){var o;for(o=3;0<o;--o)Ye(t,e+=4*r,r,1,16,n,i,a);}function Ze(t,e,r,n,i,a){var o;for(o=3;0<o;--o)Ye(t,e+=4,1,r,16,n,i,a);}function $e(t,e,r,n,i,a,o,s){Ge(t,e,i,1,8,a,o,s),Ge(r,n,i,1,8,a,o,s);}function Qe(t,e,r,n,i,a,o,s){Ge(t,e,1,i,8,a,o,s),Ge(r,n,1,i,8,a,o,s);}function tr(t,e,r,n,i,a,o,s){Ye(t,e+4*i,i,1,8,a,o,s),Ye(r,n+4*i,i,1,8,a,o,s);}function er(t,e,r,n,i,a,o,s){Ye(t,e+4,1,i,8,a,o,s),Ye(r,n+4,1,i,8,a,o,s);}function rr(){this.ba=new ot,this.ec=[],this.cc=[],this.Mc=[],this.Dc=this.Nc=this.dc=this.fc=0,this.Oa=new ct,this.memory=0,this.Ib="OutputFunc",this.Jb="OutputAlphaFunc",this.Nd="OutputRowFunc";}function nr(){this.data=[],this.offset=this.kd=this.ha=this.w=0,this.na=[],this.xa=this.gb=this.Ja=this.Sa=this.P=0;}function ir(){this.nc=this.Ea=this.b=this.hc=0,this.K=[],this.w=0;}function ar(){this.ua=0,this.Wa=new M,this.vb=new M,this.md=this.xc=this.wc=0,this.vc=[],this.Wb=0,this.Ya=new d,this.yc=new l;}function or(){this.xb=this.a=0,this.l=new Gt,this.ca=new ot,this.V=[],this.Ba=0,this.Ta=[],this.Ua=0,this.m=new N,this.Pb=0,this.wd=new N,this.Ma=this.$=this.C=this.i=this.c=this.xd=0,this.s=new ar,this.ab=0,this.gc=o(4,ir),this.Oc=0;}function sr(){this.Lc=this.Z=this.$a=this.i=this.c=0,this.l=new Gt,this.ic=0,this.ca=[],this.tb=0,this.qd=null,this.rd=0;}function cr(t,e,r,n,i,a,o){for(t=null==t?0:t[e+0],e=0;e<o;++e)i[a+e]=t+r[n+e]&255,t=i[a+e];}function ur(t,e,r,n,i,a,o){var s;if(null==t)cr(null,null,r,n,i,a,o);else for(s=0;s<o;++s)i[a+s]=t[e+s]+r[n+s]&255;}function hr(t,e,r,n,i,a,o){if(null==t)cr(null,null,r,n,i,a,o);else {var s,c=t[e+0],u=c,h=c;for(s=0;s<o;++s)u=h+(c=t[e+s])-u,h=r[n+s]+(-256&u?0>u?0:255:u)&255,u=c,i[a+s]=h;}}function lr(t,r,i,o){var s=r.width,c=r.o;if(e(null!=t&&null!=r),0>i||0>=o||i+o>c)return null;if(!t.Cc){if(null==t.ga){var u;if(t.ga=new sr,(u=null==t.ga)||(u=r.width*r.o,e(0==t.Gb.length),t.Gb=a(u),t.Uc=0,null==t.Gb?u=0:(t.mb=t.Gb,t.nb=t.Uc,t.rc=null,u=1),u=!u),!u){u=t.ga;var h=t.Fa,l=t.P,f=t.qc,d=t.mb,p=t.nb,g=l+1,m=f-1,b=u.l;if(e(null!=h&&null!=d&&null!=r),mi[0]=null,mi[1]=cr,mi[2]=ur,mi[3]=hr,u.ca=d,u.tb=p,u.c=r.width,u.i=r.height,e(0<u.c&&0<u.i),1>=f)r=0;else if(u.$a=h[l+0]>>0&3,u.Z=h[l+0]>>2&3,u.Lc=h[l+0]>>4&3,l=h[l+0]>>6&3,0>u.$a||1<u.$a||4<=u.Z||1<u.Lc||l)r=0;else if(b.put=dt,b.ac=ft,b.bc=pt,b.ma=u,b.width=r.width,b.height=r.height,b.Da=r.Da,b.v=r.v,b.va=r.va,b.j=r.j,b.o=r.o,u.$a)t:{e(1==u.$a),r=kt();e:for(;;){if(null==r){r=0;break t}if(e(null!=u),u.mc=r,r.c=u.c,r.i=u.i,r.l=u.l,r.l.ma=u,r.l.width=u.c,r.l.height=u.i,r.a=0,v(r.m,h,g,m),!It(u.c,u.i,1,r,null))break e;if(1==r.ab&&3==r.gc[0].hc&&At(r.s)?(u.ic=1,h=r.c*r.i,r.Ta=null,r.Ua=0,r.V=a(h),r.Ba=0,null==r.V?(r.a=1,r=0):r=1):(u.ic=0,r=Ft(r,u.c)),!r)break e;r=1;break t}u.mc=null,r=0;}else r=m>=u.c*u.i;u=!r;}if(u)return null;1!=t.ga.Lc?t.Ga=0:o=c-i;}e(null!=t.ga),e(i+o<=c);t:{if(r=(h=t.ga).c,c=h.l.o,0==h.$a){if(g=t.rc,m=t.Vc,b=t.Fa,l=t.P+1+i*r,f=t.mb,d=t.nb+i*r,e(l<=t.P+t.qc),0!=h.Z)for(e(null!=mi[h.Z]),u=0;u<o;++u)mi[h.Z](g,m,b,l,f,d,r),g=f,m=d,d+=r,l+=r;else for(u=0;u<o;++u)n(f,d,b,l,r),g=f,m=d,d+=r,l+=r;t.rc=g,t.Vc=m;}else {if(e(null!=h.mc),r=i+o,e(null!=(u=h.mc)),e(r<=u.i),u.C>=r)r=1;else if(h.ic||mr(),h.ic){h=u.V,g=u.Ba,m=u.c;var y=u.i,w=(b=1,l=u.$/m,f=u.$%m,d=u.m,p=u.s,u.$),N=m*y,L=m*r,x=p.wc,_=w<L?wt(p,f,l):null;e(w<=N),e(r<=y),e(At(p));e:for(;;){for(;!d.h&&w<L;){if(f&x||(_=wt(p,f,l)),e(null!=_),S(d),256>(y=bt(_.G[0],_.H[0],d)))h[g+w]=y,++w,++f>=m&&(f=0,++l<=r&&!(l%16)&&St(u,l));else {if(!(280>y)){b=0;break e}y=mt(y-256,d);var P,k=bt(_.G[4],_.H[4],d);if(S(d),!(w>=(k=vt(m,k=mt(k,d)))&&N-w>=y)){b=0;break e}for(P=0;P<y;++P)h[g+w+P]=h[g+w+P-k];for(w+=y,f+=y;f>=m;)f-=m,++l<=r&&!(l%16)&&St(u,l);w<L&&f&x&&(_=wt(p,f,l));}e(d.h==A(d));}St(u,l>r?r:l);break e}!b||d.h&&w<N?(b=0,u.a=d.h?5:3):u.$=w,r=b;}else r=_t(u,u.V,u.Ba,u.c,u.i,r,Ct);if(!r){o=0;break t}}i+o>=c&&(t.Cc=1),o=1;}if(!o)return null;if(t.Cc&&(null!=(o=t.ga)&&(o.mc=null),t.ga=null,0<t.Ga))return alert("todo:WebPDequantizeLevels"),null}return t.nb+i*s}function fr(t,e,r,n,i,a){for(;0<i--;){var o,s=t,c=e+(r?1:0),u=t,h=e+(r?0:3);for(o=0;o<n;++o){var l=u[h+4*o];255!=l&&(l*=32897,s[c+4*o+0]=s[c+4*o+0]*l>>23,s[c+4*o+1]=s[c+4*o+1]*l>>23,s[c+4*o+2]=s[c+4*o+2]*l>>23);}e+=a;}}function dr(t,e,r,n,i){for(;0<n--;){var a;for(a=0;a<r;++a){var o=t[e+2*a+0],s=15&(u=t[e+2*a+1]),c=4369*s,u=(240&u|u>>4)*c>>16;t[e+2*a+0]=(240&o|o>>4)*c>>16&240|(15&o|o<<4)*c>>16>>4&15,t[e+2*a+1]=240&u|s;}e+=i;}}function pr(t,e,r,n,i,a,o,s){var c,u,h=255;for(u=0;u<i;++u){for(c=0;c<n;++c){var l=t[e+c];a[o+4*c]=l,h&=l;}e+=r,o+=s;}return 255!=h}function gr(t,e,r,n,i){var a;for(a=0;a<i;++a)r[n+a]=t[e+a]>>8;}function mr(){An=fr,xn=dr,Sn=pr,_n=gr;}function vr(r,n,i){t[r]=function(t,r,a,o,s,c,u,h,l,f,d,p,g,m,v,b,y){var w,N=y-1>>1,L=s[c+0]|u[h+0]<<16,A=l[f+0]|d[p+0]<<16;e(null!=t);var x=3*L+A+131074>>2;for(n(t[r+0],255&x,x>>16,g,m),null!=a&&(x=3*A+L+131074>>2,n(a[o+0],255&x,x>>16,v,b)),w=1;w<=N;++w){var S=s[c+w]|u[h+w]<<16,_=l[f+w]|d[p+w]<<16,P=L+S+A+_+524296,k=P+2*(S+A)>>3;x=k+L>>1,L=(P=P+2*(L+_)>>3)+S>>1,n(t[r+2*w-1],255&x,x>>16,g,m+(2*w-1)*i),n(t[r+2*w-0],255&L,L>>16,g,m+(2*w-0)*i),null!=a&&(x=P+A>>1,L=k+_>>1,n(a[o+2*w-1],255&x,x>>16,v,b+(2*w-1)*i),n(a[o+2*w+0],255&L,L>>16,v,b+(2*w+0)*i)),L=S,A=_;}1&y||(x=3*L+A+131074>>2,n(t[r+y-1],255&x,x>>16,g,m+(y-1)*i),null!=a&&(x=3*A+L+131074>>2,n(a[o+y-1],255&x,x>>16,v,b+(y-1)*i)));};}function br(){vi[En]=bi,vi[qn]=wi,vi[Dn]=yi,vi[Rn]=Ni,vi[Tn]=Li,vi[Un]=Ai,vi[zn]=xi,vi[Hn]=wi,vi[Wn]=Ni,vi[Vn]=Li,vi[Gn]=Ai;}function yr(t){return t&~Fi?0>t?0:255:t>>Ii}function wr(t,e){return yr((19077*t>>8)+(26149*e>>8)-14234)}function Nr(t,e,r){return yr((19077*t>>8)-(6419*e>>8)-(13320*r>>8)+8708)}function Lr(t,e){return yr((19077*t>>8)+(33050*e>>8)-17685)}function Ar(t,e,r,n,i){n[i+0]=wr(t,r),n[i+1]=Nr(t,e,r),n[i+2]=Lr(t,e);}function xr(t,e,r,n,i){n[i+0]=Lr(t,e),n[i+1]=Nr(t,e,r),n[i+2]=wr(t,r);}function Sr(t,e,r,n,i){var a=Nr(t,e,r);e=a<<3&224|Lr(t,e)>>3,n[i+0]=248&wr(t,r)|a>>5,n[i+1]=e;}function _r(t,e,r,n,i){var a=240&Lr(t,e)|15;n[i+0]=240&wr(t,r)|Nr(t,e,r)>>4,n[i+1]=a;}function Pr(t,e,r,n,i){n[i+0]=255,Ar(t,e,r,n,i+1);}function kr(t,e,r,n,i){xr(t,e,r,n,i),n[i+3]=255;}function Ir(t,e,r,n,i){Ar(t,e,r,n,i),n[i+3]=255;}function Vt(t,e){return 0>t?0:t>e?e:t}function Fr(e,r,n){t[e]=function(t,e,i,a,o,s,c,u,h){for(var l=u+(-2&h)*n;u!=l;)r(t[e+0],i[a+0],o[s+0],c,u),r(t[e+1],i[a+0],o[s+0],c,u+n),e+=2,++a,++s,u+=2*n;1&h&&r(t[e+0],i[a+0],o[s+0],c,u);};}function Cr(t,e,r){return 0==r?0==t?0==e?6:5:0==e?4:0:r}function jr(t,e,r,n,i){switch(t>>>30){case 3:on(e,r,n,i,0);break;case 2:sn(e,r,n,i);break;case 1:un(e,r,n,i);}}function Or(t,e){var r,a,o=e.M,s=e.Nb,c=t.oc,u=t.pc+40,h=t.oc,l=t.pc+584,f=t.oc,d=t.pc+600;for(r=0;16>r;++r)c[u+32*r-1]=129;for(r=0;8>r;++r)h[l+32*r-1]=129,f[d+32*r-1]=129;for(0<o?c[u-1-32]=h[l-1-32]=f[d-1-32]=129:(i(c,u-32-1,127,21),i(h,l-32-1,127,9),i(f,d-32-1,127,9)),a=0;a<t.za;++a){var p=e.ya[e.aa+a];if(0<a){for(r=-1;16>r;++r)n(c,u+32*r-4,c,u+32*r+12,4);for(r=-1;8>r;++r)n(h,l+32*r-4,h,l+32*r+4,4),n(f,d+32*r-4,f,d+32*r+4,4);}var g=t.Gd,m=t.Hd+a,v=p.ad,b=p.Hc;if(0<o&&(n(c,u-32,g[m].y,0,16),n(h,l-32,g[m].f,0,8),n(f,d-32,g[m].ea,0,8)),p.Za){var y=c,w=u-32+16;for(0<o&&(a>=t.za-1?i(y,w,g[m].y[15],4):n(y,w,g[m+1].y,0,4)),r=0;4>r;r++)y[w+128+r]=y[w+256+r]=y[w+384+r]=y[w+0+r];for(r=0;16>r;++r,b<<=2)y=c,w=u+Di[r],fi[p.Ob[r]](y,w),jr(b,v,16*+r,y,w);}else if(y=Cr(a,o,p.Ob[0]),li[y](c,u),0!=b)for(r=0;16>r;++r,b<<=2)jr(b,v,16*+r,c,u+Di[r]);for(r=p.Gc,y=Cr(a,o,p.Dd),di[y](h,l),di[y](f,d),b=v,y=h,w=l,255&(p=r>>0)&&(170&p?cn(b,256,y,w):hn(b,256,y,w)),p=f,b=d,255&(r>>=8)&&(170&r?cn(v,320,p,b):hn(v,320,p,b)),o<t.Ub-1&&(n(g[m].y,0,c,u+480,16),n(g[m].f,0,h,l+224,8),n(g[m].ea,0,f,d+224,8)),r=8*s*t.B,g=t.sa,m=t.ta+16*a+16*s*t.R,v=t.qa,p=t.ra+8*a+r,b=t.Ha,y=t.Ia+8*a+r,r=0;16>r;++r)n(g,m+r*t.R,c,u+32*r,16);for(r=0;8>r;++r)n(v,p+r*t.B,h,l+32*r,8),n(b,y+r*t.B,f,d+32*r,8);}}function Br(t,n,i,a,o,s,c,u,h){var l=[0],f=[0],d=0,p=null!=h?h.kd:0,g=null!=h?h:new nr;if(null==t||12>i)return 7;g.data=t,g.w=n,g.ha=i,n=[n],i=[i],g.gb=[g.gb];t:{var m=n,b=i,y=g.gb;if(e(null!=t),e(null!=b),e(null!=y),y[0]=0,12<=b[0]&&!r(t,m[0],"RIFF")){if(r(t,m[0]+8,"WEBP")){y=3;break t}var w=j(t,m[0]+4);if(12>w||4294967286<w){y=3;break t}if(p&&w>b[0]-8){y=7;break t}y[0]=w,m[0]+=12,b[0]-=12;}y=0;}if(0!=y)return y;for(w=0<g.gb[0],i=i[0];;){t:{var L=t;b=n,y=i;var A=l,x=f,S=m=[0];if((k=d=[d])[0]=0,8>y[0])y=7;else {if(!r(L,b[0],"VP8X")){if(10!=j(L,b[0]+4)){y=3;break t}if(18>y[0]){y=7;break t}var _=j(L,b[0]+8),P=1+C(L,b[0]+12);if(2147483648<=P*(L=1+C(L,b[0]+15))){y=3;break t}null!=S&&(S[0]=_),null!=A&&(A[0]=P),null!=x&&(x[0]=L),b[0]+=18,y[0]-=18,k[0]=1;}y=0;}}if(d=d[0],m=m[0],0!=y)return y;if(b=!!(2&m),!w&&d)return 3;if(null!=s&&(s[0]=!!(16&m)),null!=c&&(c[0]=b),null!=u&&(u[0]=0),c=l[0],m=f[0],d&&b&&null==h){y=0;break}if(4>i){y=7;break}if(w&&d||!w&&!d&&!r(t,n[0],"ALPH")){i=[i],g.na=[g.na],g.P=[g.P],g.Sa=[g.Sa];t:{_=t,y=n,w=i;var k=g.gb;A=g.na,x=g.P,S=g.Sa;P=22,e(null!=_),e(null!=w),L=y[0];var I=w[0];for(e(null!=A),e(null!=S),A[0]=null,x[0]=null,S[0]=0;;){if(y[0]=L,w[0]=I,8>I){y=7;break t}var F=j(_,L+4);if(4294967286<F){y=3;break t}var O=8+F+1&-2;if(P+=O,0<k&&P>k){y=3;break t}if(!r(_,L,"VP8 ")||!r(_,L,"VP8L")){y=0;break t}if(I[0]<O){y=7;break t}r(_,L,"ALPH")||(A[0]=_,x[0]=L+8,S[0]=F),L+=O,I-=O;}}if(i=i[0],g.na=g.na[0],g.P=g.P[0],g.Sa=g.Sa[0],0!=y)break}i=[i],g.Ja=[g.Ja],g.xa=[g.xa];t:if(k=t,y=n,w=i,A=g.gb[0],x=g.Ja,S=g.xa,_=y[0],L=!r(k,_,"VP8 "),P=!r(k,_,"VP8L"),e(null!=k),e(null!=w),e(null!=x),e(null!=S),8>w[0])y=7;else {if(L||P){if(k=j(k,_+4),12<=A&&k>A-12){y=3;break t}if(p&&k>w[0]-8){y=7;break t}x[0]=k,y[0]+=8,w[0]-=8,S[0]=P;}else S[0]=5<=w[0]&&47==k[_+0]&&!(k[_+4]>>5),x[0]=w[0];y=0;}if(i=i[0],g.Ja=g.Ja[0],g.xa=g.xa[0],n=n[0],0!=y)break;if(4294967286<g.Ja)return 3;if(null==u||b||(u[0]=g.xa?2:1),c=[c],m=[m],g.xa){if(5>i){y=7;break}u=c,p=m,b=s,null==t||5>i?t=0:5<=i&&47==t[n+0]&&!(t[n+4]>>5)?(w=[0],k=[0],A=[0],v(x=new N,t,n,i),gt(x,w,k,A)?(null!=u&&(u[0]=w[0]),null!=p&&(p[0]=k[0]),null!=b&&(b[0]=A[0]),t=1):t=0):t=0;}else {if(10>i){y=7;break}u=m,null==t||10>i||!Xt(t,n+3,i-3)?t=0:(p=t[n+0]|t[n+1]<<8|t[n+2]<<16,b=16383&(t[n+7]<<8|t[n+6]),t=16383&(t[n+9]<<8|t[n+8]),1&p||3<(p>>1&7)||!(p>>4&1)||p>>5>=g.Ja||!b||!t?t=0:(c&&(c[0]=b),u&&(u[0]=t),t=1));}if(!t)return 3;if(c=c[0],m=m[0],d&&(l[0]!=c||f[0]!=m))return 3;null!=h&&(h[0]=g,h.offset=n-h.w,e(4294967286>n-h.w),e(h.offset==h.ha-i));break}return 0==y||7==y&&d&&null==h?(null!=s&&(s[0]|=null!=g.na&&0<g.na.length),null!=a&&(a[0]=c),null!=o&&(o[0]=m),0):y}function Mr(t,e,r){var n=e.width,i=e.height,a=0,o=0,s=n,c=i;if(e.Da=null!=t&&0<t.Da,e.Da&&(s=t.cd,c=t.bd,a=t.v,o=t.j,11>r||(a&=-2,o&=-2),0>a||0>o||0>=s||0>=c||a+s>n||o+c>i))return 0;if(e.v=a,e.j=o,e.va=a+s,e.o=o+c,e.U=s,e.T=c,e.da=null!=t&&0<t.da,e.da){if(!E(s,c,r=[t.ib],a=[t.hb]))return 0;e.ib=r[0],e.hb=a[0];}return e.ob=null!=t&&t.ob,e.Kb=null==t||!t.Sd,e.da&&(e.ob=e.ib<3*n/4&&e.hb<3*i/4,e.Kb=0),1}function Er(t){if(null==t)return 2;if(11>t.S){var e=t.f.RGBA;e.fb+=(t.height-1)*e.A,e.A=-e.A;}else e=t.f.kb,t=t.height,e.O+=(t-1)*e.fa,e.fa=-e.fa,e.N+=(t-1>>1)*e.Ab,e.Ab=-e.Ab,e.W+=(t-1>>1)*e.Db,e.Db=-e.Db,null!=e.F&&(e.J+=(t-1)*e.lb,e.lb=-e.lb);return 0}function qr(t,e,r,n){if(null==n||0>=t||0>=e)return 2;if(null!=r){if(r.Da){var i=r.cd,o=r.bd,s=-2&r.v,c=-2&r.j;if(0>s||0>c||0>=i||0>=o||s+i>t||c+o>e)return 2;t=i,e=o;}if(r.da){if(!E(t,e,i=[r.ib],o=[r.hb]))return 2;t=i[0],e=o[0];}}n.width=t,n.height=e;t:{var u=n.width,h=n.height;if(t=n.S,0>=u||0>=h||!(t>=En&&13>t))t=2;else {if(0>=n.Rd&&null==n.sd){s=o=i=e=0;var l=(c=u*zi[t])*h;if(11>t||(o=(h+1)/2*(e=(u+1)/2),12==t&&(s=(i=u)*h)),null==(h=a(l+2*o+s))){t=1;break t}n.sd=h,11>t?((u=n.f.RGBA).eb=h,u.fb=0,u.A=c,u.size=l):((u=n.f.kb).y=h,u.O=0,u.fa=c,u.Fd=l,u.f=h,u.N=0+l,u.Ab=e,u.Cd=o,u.ea=h,u.W=0+l+o,u.Db=e,u.Ed=o,12==t&&(u.F=h,u.J=0+l+2*o),u.Tc=s,u.lb=i);}if(e=1,i=n.S,o=n.width,s=n.height,i>=En&&13>i)if(11>i)t=n.f.RGBA,e&=(c=Math.abs(t.A))*(s-1)+o<=t.size,e&=c>=o*zi[i],e&=null!=t.eb;else {t=n.f.kb,c=(o+1)/2,l=(s+1)/2,u=Math.abs(t.fa);h=Math.abs(t.Ab);var f=Math.abs(t.Db),d=Math.abs(t.lb),p=d*(s-1)+o;e&=u*(s-1)+o<=t.Fd,e&=h*(l-1)+c<=t.Cd,e=(e&=f*(l-1)+c<=t.Ed)&u>=o&h>=c&f>=c,e&=null!=t.y,e&=null!=t.f,e&=null!=t.ea,12==i&&(e&=d>=o,e&=p<=t.Tc,e&=null!=t.F);}else e=0;t=e?0:2;}}return 0!=t||null!=r&&r.fd&&(t=Er(n)),t}var Dr=64,Rr=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215],Tr=24,Ur=32,zr=8,Hr=[0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7];R("Predictor0","PredictorAdd0"),t.Predictor0=function(){return 4278190080},t.Predictor1=function(t){return t},t.Predictor2=function(t,e,r){return e[r+0]},t.Predictor3=function(t,e,r){return e[r+1]},t.Predictor4=function(t,e,r){return e[r-1]},t.Predictor5=function(t,e,r){return U(U(t,e[r+1]),e[r+0])},t.Predictor6=function(t,e,r){return U(t,e[r-1])},t.Predictor7=function(t,e,r){return U(t,e[r+0])},t.Predictor8=function(t,e,r){return U(e[r-1],e[r+0])},t.Predictor9=function(t,e,r){return U(e[r+0],e[r+1])},t.Predictor10=function(t,e,r){return U(U(t,e[r-1]),U(e[r+0],e[r+1]))},t.Predictor11=function(t,e,r){var n=e[r+0];return 0>=W(n>>24&255,t>>24&255,(e=e[r-1])>>24&255)+W(n>>16&255,t>>16&255,e>>16&255)+W(n>>8&255,t>>8&255,e>>8&255)+W(255&n,255&t,255&e)?n:t},t.Predictor12=function(t,e,r){var n=e[r+0];return (z((t>>24&255)+(n>>24&255)-((e=e[r-1])>>24&255))<<24|z((t>>16&255)+(n>>16&255)-(e>>16&255))<<16|z((t>>8&255)+(n>>8&255)-(e>>8&255))<<8|z((255&t)+(255&n)-(255&e)))>>>0},t.Predictor13=function(t,e,r){var n=e[r-1];return (H((t=U(t,e[r+0]))>>24&255,n>>24&255)<<24|H(t>>16&255,n>>16&255)<<16|H(t>>8&255,n>>8&255)<<8|H(t>>0&255,n>>0&255))>>>0};var Wr=t.PredictorAdd0;t.PredictorAdd1=V,R("Predictor2","PredictorAdd2"),R("Predictor3","PredictorAdd3"),R("Predictor4","PredictorAdd4"),R("Predictor5","PredictorAdd5"),R("Predictor6","PredictorAdd6"),R("Predictor7","PredictorAdd7"),R("Predictor8","PredictorAdd8"),R("Predictor9","PredictorAdd9"),R("Predictor10","PredictorAdd10"),R("Predictor11","PredictorAdd11"),R("Predictor12","PredictorAdd12"),R("Predictor13","PredictorAdd13");var Vr=t.PredictorAdd2;X("ColorIndexInverseTransform","MapARGB","32b",(function(t){return t>>8&255}),(function(t){return t})),X("VP8LColorIndexInverseTransformAlpha","MapAlpha","8b",(function(t){return t}),(function(t){return t>>8&255}));var Gr,Yr=t.ColorIndexInverseTransform,Jr=t.MapARGB,Xr=t.VP8LColorIndexInverseTransformAlpha,Kr=t.MapAlpha,Zr=t.VP8LPredictorsAdd=[];Zr.length=16,(t.VP8LPredictors=[]).length=16,(t.VP8LPredictorsAdd_C=[]).length=16,(t.VP8LPredictors_C=[]).length=16;var $r,Qr,tn,en,rn,nn,an,on,sn,cn,un,hn,ln,fn,dn,pn,gn,mn,vn,bn,yn,wn,Nn,Ln,An,xn,Sn,_n,Pn=a(511),kn=a(2041),In=a(225),Fn=a(767),Cn=0,jn=kn,On=In,Bn=Fn,Mn=Pn,En=0,qn=1,Dn=2,Rn=3,Tn=4,Un=5,zn=6,Hn=7,Wn=8,Vn=9,Gn=10,Yn=[2,3,7],Jn=[3,3,11],Xn=[280,256,256,256,40],Kn=[0,1,1,1,0],Zn=[17,18,0,1,2,3,4,5,16,6,7,8,9,10,11,12,13,14,15],$n=[24,7,23,25,40,6,39,41,22,26,38,42,56,5,55,57,21,27,54,58,37,43,72,4,71,73,20,28,53,59,70,74,36,44,88,69,75,52,60,3,87,89,19,29,86,90,35,45,68,76,85,91,51,61,104,2,103,105,18,30,102,106,34,46,84,92,67,77,101,107,50,62,120,1,119,121,83,93,17,31,100,108,66,78,118,122,33,47,117,123,49,63,99,109,82,94,0,116,124,65,79,16,32,98,110,48,115,125,81,95,64,114,126,97,111,80,113,127,96,112],Qn=[2954,2956,2958,2962,2970,2986,3018,3082,3212,3468,3980,5004],ti=8,ei=[4,5,6,7,8,9,10,10,11,12,13,14,15,16,17,17,18,19,20,20,21,21,22,22,23,23,24,25,25,26,27,28,29,30,31,32,33,34,35,36,37,37,38,39,40,41,42,43,44,45,46,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,76,77,78,79,80,81,82,83,84,85,86,87,88,89,91,93,95,96,98,100,101,102,104,106,108,110,112,114,116,118,122,124,126,128,130,132,134,136,138,140,143,145,148,151,154,157],ri=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,119,122,125,128,131,134,137,140,143,146,149,152,155,158,161,164,167,170,173,177,181,185,189,193,197,201,205,209,213,217,221,225,229,234,239,245,249,254,259,264,269,274,279,284],ni=null,ii=[[173,148,140,0],[176,155,140,135,0],[180,157,141,134,130,0],[254,254,243,230,196,177,153,140,133,130,129,0]],ai=[0,1,4,8,5,2,3,6,9,12,13,10,7,11,14,15],oi=[-0,1,-1,2,-2,3,4,6,-3,5,-4,-5,-6,7,-7,8,-8,-9],si=[[[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]],[[253,136,254,255,228,219,128,128,128,128,128],[189,129,242,255,227,213,255,219,128,128,128],[106,126,227,252,214,209,255,255,128,128,128]],[[1,98,248,255,236,226,255,255,128,128,128],[181,133,238,254,221,234,255,154,128,128,128],[78,134,202,247,198,180,255,219,128,128,128]],[[1,185,249,255,243,255,128,128,128,128,128],[184,150,247,255,236,224,128,128,128,128,128],[77,110,216,255,236,230,128,128,128,128,128]],[[1,101,251,255,241,255,128,128,128,128,128],[170,139,241,252,236,209,255,255,128,128,128],[37,116,196,243,228,255,255,255,128,128,128]],[[1,204,254,255,245,255,128,128,128,128,128],[207,160,250,255,238,128,128,128,128,128,128],[102,103,231,255,211,171,128,128,128,128,128]],[[1,152,252,255,240,255,128,128,128,128,128],[177,135,243,255,234,225,128,128,128,128,128],[80,129,211,255,194,224,128,128,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[246,1,255,128,128,128,128,128,128,128,128],[255,128,128,128,128,128,128,128,128,128,128]]],[[[198,35,237,223,193,187,162,160,145,155,62],[131,45,198,221,172,176,220,157,252,221,1],[68,47,146,208,149,167,221,162,255,223,128]],[[1,149,241,255,221,224,255,255,128,128,128],[184,141,234,253,222,220,255,199,128,128,128],[81,99,181,242,176,190,249,202,255,255,128]],[[1,129,232,253,214,197,242,196,255,255,128],[99,121,210,250,201,198,255,202,128,128,128],[23,91,163,242,170,187,247,210,255,255,128]],[[1,200,246,255,234,255,128,128,128,128,128],[109,178,241,255,231,245,255,255,128,128,128],[44,130,201,253,205,192,255,255,128,128,128]],[[1,132,239,251,219,209,255,165,128,128,128],[94,136,225,251,218,190,255,255,128,128,128],[22,100,174,245,186,161,255,199,128,128,128]],[[1,182,249,255,232,235,128,128,128,128,128],[124,143,241,255,227,234,128,128,128,128,128],[35,77,181,251,193,211,255,205,128,128,128]],[[1,157,247,255,236,231,255,255,128,128,128],[121,141,235,255,225,227,255,255,128,128,128],[45,99,188,251,195,217,255,224,128,128,128]],[[1,1,251,255,213,255,128,128,128,128,128],[203,1,248,255,255,128,128,128,128,128,128],[137,1,177,255,224,255,128,128,128,128,128]]],[[[253,9,248,251,207,208,255,192,128,128,128],[175,13,224,243,193,185,249,198,255,255,128],[73,17,171,221,161,179,236,167,255,234,128]],[[1,95,247,253,212,183,255,255,128,128,128],[239,90,244,250,211,209,255,255,128,128,128],[155,77,195,248,188,195,255,255,128,128,128]],[[1,24,239,251,218,219,255,205,128,128,128],[201,51,219,255,196,186,128,128,128,128,128],[69,46,190,239,201,218,255,228,128,128,128]],[[1,191,251,255,255,128,128,128,128,128,128],[223,165,249,255,213,255,128,128,128,128,128],[141,124,248,255,255,128,128,128,128,128,128]],[[1,16,248,255,255,128,128,128,128,128,128],[190,36,230,255,236,255,128,128,128,128,128],[149,1,255,128,128,128,128,128,128,128,128]],[[1,226,255,128,128,128,128,128,128,128,128],[247,192,255,128,128,128,128,128,128,128,128],[240,128,255,128,128,128,128,128,128,128,128]],[[1,134,252,255,255,128,128,128,128,128,128],[213,62,250,255,255,128,128,128,128,128,128],[55,93,255,128,128,128,128,128,128,128,128]],[[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128],[128,128,128,128,128,128,128,128,128,128,128]]],[[[202,24,213,235,186,191,220,160,240,175,255],[126,38,182,232,169,184,228,174,255,187,128],[61,46,138,219,151,178,240,170,255,216,128]],[[1,112,230,250,199,191,247,159,255,255,128],[166,109,228,252,211,215,255,174,128,128,128],[39,77,162,232,172,180,245,178,255,255,128]],[[1,52,220,246,198,199,249,220,255,255,128],[124,74,191,243,183,193,250,221,255,255,128],[24,71,130,219,154,170,243,182,255,255,128]],[[1,182,225,249,219,240,255,224,128,128,128],[149,150,226,252,216,205,255,171,128,128,128],[28,108,170,242,183,194,254,223,255,255,128]],[[1,81,230,252,204,203,255,192,128,128,128],[123,102,209,247,188,196,255,233,128,128,128],[20,95,153,243,164,173,255,203,128,128,128]],[[1,222,248,255,216,213,128,128,128,128,128],[168,175,246,252,235,205,255,255,128,128,128],[47,116,215,255,211,212,255,255,128,128,128]],[[1,121,236,253,212,214,255,255,128,128,128],[141,84,213,252,201,202,255,219,128,128,128],[42,80,160,240,162,185,255,205,128,128,128]],[[1,1,255,128,128,128,128,128,128,128,128],[244,1,255,128,128,128,128,128,128,128,128],[238,1,255,128,128,128,128,128,128,128,128]]]],ci=[[[231,120,48,89,115,113,120,152,112],[152,179,64,126,170,118,46,70,95],[175,69,143,80,85,82,72,155,103],[56,58,10,171,218,189,17,13,152],[114,26,17,163,44,195,21,10,173],[121,24,80,195,26,62,44,64,85],[144,71,10,38,171,213,144,34,26],[170,46,55,19,136,160,33,206,71],[63,20,8,114,114,208,12,9,226],[81,40,11,96,182,84,29,16,36]],[[134,183,89,137,98,101,106,165,148],[72,187,100,130,157,111,32,75,80],[66,102,167,99,74,62,40,234,128],[41,53,9,178,241,141,26,8,107],[74,43,26,146,73,166,49,23,157],[65,38,105,160,51,52,31,115,128],[104,79,12,27,217,255,87,17,7],[87,68,71,44,114,51,15,186,23],[47,41,14,110,182,183,21,17,194],[66,45,25,102,197,189,23,18,22]],[[88,88,147,150,42,46,45,196,205],[43,97,183,117,85,38,35,179,61],[39,53,200,87,26,21,43,232,171],[56,34,51,104,114,102,29,93,77],[39,28,85,171,58,165,90,98,64],[34,22,116,206,23,34,43,166,73],[107,54,32,26,51,1,81,43,31],[68,25,106,22,64,171,36,225,114],[34,19,21,102,132,188,16,76,124],[62,18,78,95,85,57,50,48,51]],[[193,101,35,159,215,111,89,46,111],[60,148,31,172,219,228,21,18,111],[112,113,77,85,179,255,38,120,114],[40,42,1,196,245,209,10,25,109],[88,43,29,140,166,213,37,43,154],[61,63,30,155,67,45,68,1,209],[100,80,8,43,154,1,51,26,71],[142,78,78,16,255,128,34,197,171],[41,40,5,102,211,183,4,1,221],[51,50,17,168,209,192,23,25,82]],[[138,31,36,171,27,166,38,44,229],[67,87,58,169,82,115,26,59,179],[63,59,90,180,59,166,93,73,154],[40,40,21,116,143,209,34,39,175],[47,15,16,183,34,223,49,45,183],[46,17,33,183,6,98,15,32,183],[57,46,22,24,128,1,54,17,37],[65,32,73,115,28,128,23,128,205],[40,3,9,115,51,192,18,6,223],[87,37,9,115,59,77,64,21,47]],[[104,55,44,218,9,54,53,130,226],[64,90,70,205,40,41,23,26,57],[54,57,112,184,5,41,38,166,213],[30,34,26,133,152,116,10,32,134],[39,19,53,221,26,114,32,73,255],[31,9,65,234,2,15,1,118,73],[75,32,12,51,192,255,160,43,51],[88,31,35,67,102,85,55,186,85],[56,21,23,111,59,205,45,37,192],[55,38,70,124,73,102,1,34,98]],[[125,98,42,88,104,85,117,175,82],[95,84,53,89,128,100,113,101,45],[75,79,123,47,51,128,81,171,1],[57,17,5,71,102,57,53,41,49],[38,33,13,121,57,73,26,1,85],[41,10,67,138,77,110,90,47,114],[115,21,2,10,102,255,166,23,6],[101,29,16,10,85,128,101,196,26],[57,18,10,102,102,213,34,20,43],[117,20,15,36,163,128,68,1,26]],[[102,61,71,37,34,53,31,243,192],[69,60,71,38,73,119,28,222,37],[68,45,128,34,1,47,11,245,171],[62,17,19,70,146,85,55,62,70],[37,43,37,154,100,163,85,160,1],[63,9,92,136,28,64,32,201,85],[75,15,9,9,64,255,184,119,16],[86,6,28,5,64,255,25,248,1],[56,8,17,132,137,255,55,116,128],[58,15,20,82,135,57,26,121,40]],[[164,50,31,137,154,133,25,35,218],[51,103,44,131,131,123,31,6,158],[86,40,64,135,148,224,45,183,128],[22,26,17,131,240,154,14,1,209],[45,16,21,91,64,222,7,1,197],[56,21,39,155,60,138,23,102,213],[83,12,13,54,192,255,68,47,28],[85,26,85,85,128,128,32,146,171],[18,11,7,63,144,171,4,4,246],[35,27,10,146,174,171,12,26,128]],[[190,80,35,99,180,80,126,54,45],[85,126,47,87,176,51,41,20,32],[101,75,128,139,118,146,116,128,85],[56,41,15,176,236,85,37,9,62],[71,30,17,119,118,255,17,18,138],[101,38,60,138,55,70,43,26,142],[146,36,19,30,171,255,97,27,20],[138,45,61,62,219,1,81,188,64],[32,41,20,117,151,142,20,21,163],[112,19,12,61,195,128,48,4,24]]],ui=[[[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[176,246,255,255,255,255,255,255,255,255,255],[223,241,252,255,255,255,255,255,255,255,255],[249,253,253,255,255,255,255,255,255,255,255]],[[255,244,252,255,255,255,255,255,255,255,255],[234,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255]],[[255,246,254,255,255,255,255,255,255,255,255],[239,253,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[251,255,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[251,254,254,255,255,255,255,255,255,255,255],[254,255,254,255,255,255,255,255,255,255,255]],[[255,254,253,255,254,255,255,255,255,255,255],[250,255,254,255,254,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[217,255,255,255,255,255,255,255,255,255,255],[225,252,241,253,255,255,254,255,255,255,255],[234,250,241,250,253,255,253,254,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[223,254,254,255,255,255,255,255,255,255,255],[238,253,254,254,255,255,255,255,255,255,255]],[[255,248,254,255,255,255,255,255,255,255,255],[249,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,255,255,255,255,255,255,255,255,255],[247,254,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[252,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[253,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[186,251,250,255,255,255,255,255,255,255,255],[234,251,244,254,255,255,255,255,255,255,255],[251,251,243,253,254,255,254,255,255,255,255]],[[255,253,254,255,255,255,255,255,255,255,255],[236,253,254,255,255,255,255,255,255,255,255],[251,253,253,254,254,255,255,255,255,255,255]],[[255,254,254,255,255,255,255,255,255,255,255],[254,254,254,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,254,255,255,255,255,255,255,255,255,255],[254,254,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]],[[[248,255,255,255,255,255,255,255,255,255,255],[250,254,252,254,255,255,255,255,255,255,255],[248,254,249,253,255,255,255,255,255,255,255]],[[255,253,253,255,255,255,255,255,255,255,255],[246,253,253,255,255,255,255,255,255,255,255],[252,254,251,254,254,255,255,255,255,255,255]],[[255,254,252,255,255,255,255,255,255,255,255],[248,254,253,255,255,255,255,255,255,255,255],[253,255,254,254,255,255,255,255,255,255,255]],[[255,251,254,255,255,255,255,255,255,255,255],[245,251,254,255,255,255,255,255,255,255,255],[253,253,254,255,255,255,255,255,255,255,255]],[[255,251,253,255,255,255,255,255,255,255,255],[252,253,254,255,255,255,255,255,255,255,255],[255,254,255,255,255,255,255,255,255,255,255]],[[255,252,255,255,255,255,255,255,255,255,255],[249,255,254,255,255,255,255,255,255,255,255],[255,255,254,255,255,255,255,255,255,255,255]],[[255,255,253,255,255,255,255,255,255,255,255],[250,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]],[[255,255,255,255,255,255,255,255,255,255,255],[254,255,255,255,255,255,255,255,255,255,255],[255,255,255,255,255,255,255,255,255,255,255]]]],hi=[0,1,2,3,6,4,5,6,6,6,6,6,6,6,6,7,0],li=[],fi=[],di=[],pi=1,gi=2,mi=[],vi=[];vr("UpsampleRgbLinePair",Ar,3),vr("UpsampleBgrLinePair",xr,3),vr("UpsampleRgbaLinePair",Ir,4),vr("UpsampleBgraLinePair",kr,4),vr("UpsampleArgbLinePair",Pr,4),vr("UpsampleRgba4444LinePair",_r,2),vr("UpsampleRgb565LinePair",Sr,2);var bi=t.UpsampleRgbLinePair,yi=t.UpsampleBgrLinePair,wi=t.UpsampleRgbaLinePair,Ni=t.UpsampleBgraLinePair,Li=t.UpsampleArgbLinePair,Ai=t.UpsampleRgba4444LinePair,xi=t.UpsampleRgb565LinePair,Si=16,_i=1<<Si-1,Pi=-227,ki=482,Ii=6,Fi=(256<<Ii)-1,Ci=0,ji=a(256),Oi=a(256),Bi=a(256),Mi=a(256),Ei=a(ki-Pi),qi=a(ki-Pi);Fr("YuvToRgbRow",Ar,3),Fr("YuvToBgrRow",xr,3),Fr("YuvToRgbaRow",Ir,4),Fr("YuvToBgraRow",kr,4),Fr("YuvToArgbRow",Pr,4),Fr("YuvToRgba4444Row",_r,2),Fr("YuvToRgb565Row",Sr,2);var Di=[0,4,8,12,128,132,136,140,256,260,264,268,384,388,392,396],Ri=[0,2,8],Ti=[8,7,6,4,4,2,2,2,1,1,1,1],Ui=1;this.WebPDecodeRGBA=function(t,r,n,i,a){var o=qn,s=new rr,c=new ot;s.ba=c,c.S=o,c.width=[c.width],c.height=[c.height];var u=c.width,h=c.height,l=new st;if(null==l||null==t)var f=2;else e(null!=l),f=Br(t,r,n,l.width,l.height,l.Pd,l.Qd,l.format,null);if(0!=f?u=0:(null!=u&&(u[0]=l.width[0]),null!=h&&(h[0]=l.height[0]),u=1),u){c.width=c.width[0],c.height=c.height[0],null!=i&&(i[0]=c.width),null!=a&&(a[0]=c.height);t:{if(i=new Gt,(a=new nr).data=t,a.w=r,a.ha=n,a.kd=1,r=[0],e(null!=a),(0==(t=Br(a.data,a.w,a.ha,null,null,null,r,null,a))||7==t)&&r[0]&&(t=4),0==(r=t)){if(e(null!=s),i.data=a.data,i.w=a.w+a.offset,i.ha=a.ha-a.offset,i.put=dt,i.ac=ft,i.bc=pt,i.ma=s,a.xa){if(null==(t=kt())){s=1;break t}if(function(t,r){var n=[0],i=[0],a=[0];e:for(;;){if(null==t)return 0;if(null==r)return t.a=2,0;if(t.l=r,t.a=0,v(t.m,r.data,r.w,r.ha),!gt(t.m,n,i,a)){t.a=3;break e}if(t.xb=gi,r.width=n[0],r.height=i[0],!It(n[0],i[0],1,t,null))break e;return 1}return e(0!=t.a),0}(t,i)){if(i=0==(r=qr(i.width,i.height,s.Oa,s.ba))){e:{i=t;r:for(;;){if(null==i){i=0;break e}if(e(null!=i.s.yc),e(null!=i.s.Ya),e(0<i.s.Wb),e(null!=(n=i.l)),e(null!=(a=n.ma)),0!=i.xb){if(i.ca=a.ba,i.tb=a.tb,e(null!=i.ca),!Mr(a.Oa,n,Rn)){i.a=2;break r}if(!Ft(i,n.width))break r;if(n.da)break r;if((n.da||nt(i.ca.S))&&mr(),11>i.ca.S||(alert("todo:WebPInitConvertARGBToYUV"),null!=i.ca.f.kb.F&&mr()),i.Pb&&0<i.s.ua&&null==i.s.vb.X&&!O(i.s.vb,i.s.Wa.Xa)){i.a=1;break r}i.xb=0;}if(!_t(i,i.V,i.Ba,i.c,i.i,n.o,Lt))break r;a.Dc=i.Ma,i=1;break e}e(0!=i.a),i=0;}i=!i;}i&&(r=t.a);}else r=t.a;}else {if(null==(t=new Yt)){s=1;break t}if(t.Fa=a.na,t.P=a.P,t.qc=a.Sa,Kt(t,i)){if(0==(r=qr(i.width,i.height,s.Oa,s.ba))){if(t.Aa=0,n=s.Oa,e(null!=(a=t)),null!=n){if(0<(u=0>(u=n.Md)?0:100<u?255:255*u/100)){for(h=l=0;4>h;++h)12>(f=a.pb[h]).lc&&(f.ia=u*Ti[0>f.lc?0:f.lc]>>3),l|=f.ia;l&&(alert("todo:VP8InitRandom"),a.ia=1);}a.Ga=n.Id,100<a.Ga?a.Ga=100:0>a.Ga&&(a.Ga=0);}Qt(t,i)||(r=t.a);}}else r=t.a;}0==r&&null!=s.Oa&&s.Oa.fd&&(r=Er(s.ba));}s=r;}o=0!=s?null:11>o?c.f.RGBA.eb:c.f.kb.y;}else o=null;return o};var zi=[3,4,3,4,4,2,2,4,4,4,2,1,1];};function u(t,e){for(var r="",n=0;n<4;n++)r+=String.fromCharCode(t[e++]);return r}function h(t,e){return (t[e+0]<<0|t[e+1]<<8|t[e+2]<<16)>>>0}function l(t,e){return (t[e+0]<<0|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}new c;var f=[0],d=[0],p=[],g=new c,m=t,v=function(t,e){var r={},n=0,i=!1,a=0,o=0;if(r.frames=[],!
  /** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
  function(t,e,r,n){for(var i=0;i<n;i++)if(t[e+i]!=r.charCodeAt(i))return !0;return !1}(t,e,"RIFF",4)){var s,c;l(t,e+=4);for(e+=8;e<t.length;){var f=u(t,e),d=l(t,e+=4);e+=4;var p=d+(1&d);switch(f){case"VP8 ":case"VP8L":void 0===r.frames[n]&&(r.frames[n]={});(v=r.frames[n]).src_off=i?o:e-8,v.src_size=a+d+8,n++,i&&(i=!1,a=0,o=0);break;case"VP8X":(v=r.header={}).feature_flags=t[e];var g=e+4;v.canvas_width=1+h(t,g);g+=3;v.canvas_height=1+h(t,g);g+=3;break;case"ALPH":i=!0,a=p+8,o=e-8;break;case"ANIM":(v=r.header).bgcolor=l(t,e);g=e+4;v.loop_count=(s=t)[(c=g)+0]<<0|s[c+1]<<8;g+=2;break;case"ANMF":var m,v;(v=r.frames[n]={}).offset_x=2*h(t,e),e+=3,v.offset_y=2*h(t,e),e+=3,v.width=1+h(t,e),e+=3,v.height=1+h(t,e),e+=3,v.duration=h(t,e),e+=3,m=t[e++],v.dispose=1&m,v.blend=m>>1&1;}"ANMF"!=f&&(e+=p);}return r}}(m,0);v.response=m,v.rgbaoutput=!0,v.dataurl=!1;var b=v.header?v.header:null,y=v.frames?v.frames:null;if(b){b.loop_counter=b.loop_count,f=[b.canvas_height],d=[b.canvas_width];for(var w=0;w<y.length&&0!=y[w].blend;w++);}var N=y[0],L=g.WebPDecodeRGBA(m,N.src_off,N.src_size,d,f);N.rgba=L,N.imgwidth=d[0],N.imgheight=f[0];for(var A=0;A<d[0]*f[0]*4;A++)p[A]=L[A];return this.width=d,this.height=f,this.data=p,this}!function(t){var r=function(){return "function"==typeof zlibSync},n=function(r,n,a,h){var l=4,f=s;switch(h){case t.image_compression.FAST:l=1,f=o;break;case t.image_compression.MEDIUM:l=6,f=c;break;case t.image_compression.SLOW:l=9,f=u;}r=i(r,n,a,f);var d=zlibSync(r,{level:l});return t.__addimage__.arrayBufferToBinaryString(d)},i=function(t,e,r,n){for(var i,a,o,s=t.length/e,c=new Uint8Array(t.length+s),u=l(),h=0;h<s;h+=1){if(o=h*e,i=t.subarray(o,o+e),n)c.set(n(i,r,a),o+h);else {for(var d,p=u.length,g=[];d<p;d+=1)g[d]=u[d](i,r,a);var m=f(g.concat());c.set(g[m],o+h);}a=i;}return c},a=function(t){var e=Array.apply([],t);return e.unshift(0),e},o=function(t,e){var r,n=[],i=t.length;n[0]=1;for(var a=0;a<i;a+=1)r=t[a-e]||0,n[a+1]=t[a]-r+256&255;return n},s=function(t,e,r){var n,i=[],a=t.length;i[0]=2;for(var o=0;o<a;o+=1)n=r&&r[o]||0,i[o+1]=t[o]-n+256&255;return i},c=function(t,e,r){var n,i,a=[],o=t.length;a[0]=3;for(var s=0;s<o;s+=1)n=t[s-e]||0,i=r&&r[s]||0,a[s+1]=t[s]+256-(n+i>>>1)&255;return a},u=function(t,e,r){var n,i,a,o,s=[],c=t.length;s[0]=4;for(var u=0;u<c;u+=1)n=t[u-e]||0,i=r&&r[u]||0,a=r&&r[u-e]||0,o=h(n,i,a),s[u+1]=t[u]-o+256&255;return s},h=function(t,e,r){if(t===e&&e===r)return t;var n=Math.abs(e-r),i=Math.abs(t-r),a=Math.abs(t+e-r-r);return n<=i&&n<=a?t:i<=a?e:r},l=function(){return [a,o,s,c,u]},f=function(t){var e=t.map((function(t){return t.reduce((function(t,e){return t+Math.abs(e)}),0)}));return e.indexOf(Math.min.apply(null,e))};t.processPNG=function(e,i,a,o){var s,c,u,h,l,f,d,p,g,m,v,b,y,w,N,L=this.decode.FLATE_DECODE,A="";if(this.__addimage__.isArrayBuffer(e)&&(e=new Uint8Array(e)),this.__addimage__.isArrayBufferView(e)){if(e=(u=new Kt(e)).imgData,c=u.bits,s=u.colorSpace,l=u.colors,-1!==[4,6].indexOf(u.colorType)){if(8===u.bits){g=(p=32==u.pixelBitlength?new Uint32Array(u.decodePixels().buffer):16==u.pixelBitlength?new Uint16Array(u.decodePixels().buffer):new Uint8Array(u.decodePixels().buffer)).length,v=new Uint8Array(g*u.colors),m=new Uint8Array(g);var x,S=u.pixelBitlength-u.bits;for(w=0,N=0;w<g;w++){for(y=p[w],x=0;x<S;)v[N++]=y>>>x&255,x+=u.bits;m[w]=y>>>x&255;}}if(16===u.bits){g=(p=new Uint32Array(u.decodePixels().buffer)).length,v=new Uint8Array(g*(32/u.pixelBitlength)*u.colors),m=new Uint8Array(g*(32/u.pixelBitlength)),b=u.colors>1,w=0,N=0;for(var _=0;w<g;)y=p[w++],v[N++]=y>>>0&255,b&&(v[N++]=y>>>16&255,y=p[w++],v[N++]=y>>>0&255),m[_++]=y>>>16&255;c=8;}o!==t.image_compression.NONE&&r()?(e=n(v,u.width*u.colors,u.colors,o),d=n(m,u.width,1,o)):(e=v,d=m,L=void 0);}if(3===u.colorType&&(s=this.color_spaces.INDEXED,f=u.palette,u.transparency.indexed)){var P=u.transparency.indexed,k=0;for(w=0,g=P.length;w<g;++w)k+=P[w];if((k/=255)===g-1&&-1!==P.indexOf(0))h=[P.indexOf(0)];else if(k!==g){for(p=u.decodePixels(),m=new Uint8Array(p.length),w=0,g=p.length;w<g;w++)m[w]=P[p[w]];d=n(m,u.width,1);}}var I=function(e){var r;switch(e){case t.image_compression.FAST:r=11;break;case t.image_compression.MEDIUM:r=13;break;case t.image_compression.SLOW:r=14;break;default:r=12;}return r}(o);return L===this.decode.FLATE_DECODE&&(A="/Predictor "+I+" "),A+="/Colors "+l+" /BitsPerComponent "+c+" /Columns "+u.width,(this.__addimage__.isArrayBuffer(e)||this.__addimage__.isArrayBufferView(e))&&(e=this.__addimage__.arrayBufferToBinaryString(e)),(d&&this.__addimage__.isArrayBuffer(d)||this.__addimage__.isArrayBufferView(d))&&(d=this.__addimage__.arrayBufferToBinaryString(d)),{alias:a,data:e,index:i,filter:L,decodeParameters:A,transparency:h,palette:f,sMask:d,predictor:I,width:u.width,height:u.height,bitsPerComponent:c,colorSpace:s}}};}(E$1.API),function(t){t.processGIF89A=function(e,r,n,i){var a=new Zt(e),o=a.width,s=a.height,c=[];a.decodeAndBlitFrameRGBA(0,c);var u={data:c,width:o,height:s},h=new Qt(100).encode(u,100);return t.processJPEG.call(this,h,r,n,i)},t.processGIF87A=t.processGIF89A;}(E$1.API),te.prototype.parseHeader=function(){if(this.fileSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.reserved=this.datav.getUint32(this.pos,!0),this.pos+=4,this.offset=this.datav.getUint32(this.pos,!0),this.pos+=4,this.headerSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.width=this.datav.getUint32(this.pos,!0),this.pos+=4,this.height=this.datav.getInt32(this.pos,!0),this.pos+=4,this.planes=this.datav.getUint16(this.pos,!0),this.pos+=2,this.bitPP=this.datav.getUint16(this.pos,!0),this.pos+=2,this.compress=this.datav.getUint32(this.pos,!0),this.pos+=4,this.rawSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.hr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.vr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.colors=this.datav.getUint32(this.pos,!0),this.pos+=4,this.importantColors=this.datav.getUint32(this.pos,!0),this.pos+=4,16===this.bitPP&&this.is_with_alpha&&(this.bitPP=15),this.bitPP<15){var t=0===this.colors?1<<this.bitPP:this.colors;this.palette=new Array(t);for(var e=0;e<t;e++){var r=this.datav.getUint8(this.pos++,!0),n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0);this.palette[e]={red:i,green:n,blue:r,quad:a};}}this.height<0&&(this.height*=-1,this.bottom_up=!1);},te.prototype.parseBGR=function(){this.pos=this.offset;try{var t="bit"+this.bitPP,e=this.width*this.height*4;this.data=new Uint8Array(e),this[t]();}catch(t){a$2.log("bit decode error:"+t);}},te.prototype.bit1=function(){var t,e=Math.ceil(this.width/8),r=e%4;for(t=this.height-1;t>=0;t--){for(var n=this.bottom_up?t:this.height-1-t,i=0;i<e;i++)for(var a=this.datav.getUint8(this.pos++,!0),o=n*this.width*4+8*i*4,s=0;s<8&&8*i+s<this.width;s++){var c=this.palette[a>>7-s&1];this.data[o+4*s]=c.blue,this.data[o+4*s+1]=c.green,this.data[o+4*s+2]=c.red,this.data[o+4*s+3]=255;}0!==r&&(this.pos+=4-r);}},te.prototype.bit4=function(){for(var t=Math.ceil(this.width/2),e=t%4,r=this.height-1;r>=0;r--){for(var n=this.bottom_up?r:this.height-1-r,i=0;i<t;i++){var a=this.datav.getUint8(this.pos++,!0),o=n*this.width*4+2*i*4,s=a>>4,c=15&a,u=this.palette[s];if(this.data[o]=u.blue,this.data[o+1]=u.green,this.data[o+2]=u.red,this.data[o+3]=255,2*i+1>=this.width)break;u=this.palette[c],this.data[o+4]=u.blue,this.data[o+4+1]=u.green,this.data[o+4+2]=u.red,this.data[o+4+3]=255;}0!==e&&(this.pos+=4-e);}},te.prototype.bit8=function(){for(var t=this.width%4,e=this.height-1;e>=0;e--){for(var r=this.bottom_up?e:this.height-1-e,n=0;n<this.width;n++){var i=this.datav.getUint8(this.pos++,!0),a=r*this.width*4+4*n;if(i<this.palette.length){var o=this.palette[i];this.data[a]=o.red,this.data[a+1]=o.green,this.data[a+2]=o.blue,this.data[a+3]=255;}else this.data[a]=255,this.data[a+1]=255,this.data[a+2]=255,this.data[a+3]=255;}0!==t&&(this.pos+=4-t);}},te.prototype.bit15=function(){for(var t=this.width%3,e=parseInt("11111",2),r=this.height-1;r>=0;r--){for(var n=this.bottom_up?r:this.height-1-r,i=0;i<this.width;i++){var a=this.datav.getUint16(this.pos,!0);this.pos+=2;var o=(a&e)/e*255|0,s=(a>>5&e)/e*255|0,c=(a>>10&e)/e*255|0,u=a>>15?255:0,h=n*this.width*4+4*i;this.data[h]=c,this.data[h+1]=s,this.data[h+2]=o,this.data[h+3]=u;}this.pos+=t;}},te.prototype.bit16=function(){for(var t=this.width%3,e=parseInt("11111",2),r=parseInt("111111",2),n=this.height-1;n>=0;n--){for(var i=this.bottom_up?n:this.height-1-n,a=0;a<this.width;a++){var o=this.datav.getUint16(this.pos,!0);this.pos+=2;var s=(o&e)/e*255|0,c=(o>>5&r)/r*255|0,u=(o>>11)/e*255|0,h=i*this.width*4+4*a;this.data[h]=u,this.data[h+1]=c,this.data[h+2]=s,this.data[h+3]=255;}this.pos+=t;}},te.prototype.bit24=function(){for(var t=this.height-1;t>=0;t--){for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=e*this.width*4+4*r;this.data[o]=a,this.data[o+1]=i,this.data[o+2]=n,this.data[o+3]=255;}this.pos+=this.width%4;}},te.prototype.bit32=function(){for(var t=this.height-1;t>=0;t--)for(var e=this.bottom_up?t:this.height-1-t,r=0;r<this.width;r++){var n=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0),s=e*this.width*4+4*r;this.data[s]=a,this.data[s+1]=i,this.data[s+2]=n,this.data[s+3]=o;}},te.prototype.getData=function(){return this.data},
  /**
   * @license
   * Copyright (c) 2018 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.processBMP=function(e,r,n,i){var a=new te(e,!1),o=a.width,s=a.height,c={data:a.getData(),width:o,height:s},u=new Qt(100).encode(c,100);return t.processJPEG.call(this,u,r,n,i)};}(E$1.API),ee.prototype.getData=function(){return this.data},
  /**
   * @license
   * Copyright (c) 2019 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){t.processWEBP=function(e,r,n,i){var a=new ee(e,!1),o=a.width,s=a.height,c={data:a.getData(),width:o,height:s},u=new Qt(100).encode(c,100);return t.processJPEG.call(this,u,r,n,i)};}(E$1.API),E$1.API.processRGBA=function(t,e,r){for(var n=t.data,i=n.length,a=new Uint8Array(i/4*3),o=new Uint8Array(i/4),s=0,c=0,u=0;u<i;u+=4){var h=n[u],l=n[u+1],f=n[u+2],d=n[u+3];a[s++]=h,a[s++]=l,a[s++]=f,o[c++]=d;}var p=this.__addimage__.arrayBufferToBinaryString(a);return {alpha:this.__addimage__.arrayBufferToBinaryString(o),data:p,index:e,alias:r,colorSpace:"DeviceRGB",bitsPerComponent:8,width:t.width,height:t.height}},E$1.API.setLanguage=function(t){return void 0===this.internal.languageSettings&&(this.internal.languageSettings={},this.internal.languageSettings.isSubscribed=!1),void 0!=={af:"Afrikaans",sq:"Albanian",ar:"Arabic (Standard)","ar-DZ":"Arabic (Algeria)","ar-BH":"Arabic (Bahrain)","ar-EG":"Arabic (Egypt)","ar-IQ":"Arabic (Iraq)","ar-JO":"Arabic (Jordan)","ar-KW":"Arabic (Kuwait)","ar-LB":"Arabic (Lebanon)","ar-LY":"Arabic (Libya)","ar-MA":"Arabic (Morocco)","ar-OM":"Arabic (Oman)","ar-QA":"Arabic (Qatar)","ar-SA":"Arabic (Saudi Arabia)","ar-SY":"Arabic (Syria)","ar-TN":"Arabic (Tunisia)","ar-AE":"Arabic (U.A.E.)","ar-YE":"Arabic (Yemen)",an:"Aragonese",hy:"Armenian",as:"Assamese",ast:"Asturian",az:"Azerbaijani",eu:"Basque",be:"Belarusian",bn:"Bengali",bs:"Bosnian",br:"Breton",bg:"Bulgarian",my:"Burmese",ca:"Catalan",ch:"Chamorro",ce:"Chechen",zh:"Chinese","zh-HK":"Chinese (Hong Kong)","zh-CN":"Chinese (PRC)","zh-SG":"Chinese (Singapore)","zh-TW":"Chinese (Taiwan)",cv:"Chuvash",co:"Corsican",cr:"Cree",hr:"Croatian",cs:"Czech",da:"Danish",nl:"Dutch (Standard)","nl-BE":"Dutch (Belgian)",en:"English","en-AU":"English (Australia)","en-BZ":"English (Belize)","en-CA":"English (Canada)","en-IE":"English (Ireland)","en-JM":"English (Jamaica)","en-NZ":"English (New Zealand)","en-PH":"English (Philippines)","en-ZA":"English (South Africa)","en-TT":"English (Trinidad & Tobago)","en-GB":"English (United Kingdom)","en-US":"English (United States)","en-ZW":"English (Zimbabwe)",eo:"Esperanto",et:"Estonian",fo:"Faeroese",fj:"Fijian",fi:"Finnish",fr:"French (Standard)","fr-BE":"French (Belgium)","fr-CA":"French (Canada)","fr-FR":"French (France)","fr-LU":"French (Luxembourg)","fr-MC":"French (Monaco)","fr-CH":"French (Switzerland)",fy:"Frisian",fur:"Friulian",gd:"Gaelic (Scots)","gd-IE":"Gaelic (Irish)",gl:"Galacian",ka:"Georgian",de:"German (Standard)","de-AT":"German (Austria)","de-DE":"German (Germany)","de-LI":"German (Liechtenstein)","de-LU":"German (Luxembourg)","de-CH":"German (Switzerland)",el:"Greek",gu:"Gujurati",ht:"Haitian",he:"Hebrew",hi:"Hindi",hu:"Hungarian",is:"Icelandic",id:"Indonesian",iu:"Inuktitut",ga:"Irish",it:"Italian (Standard)","it-CH":"Italian (Switzerland)",ja:"Japanese",kn:"Kannada",ks:"Kashmiri",kk:"Kazakh",km:"Khmer",ky:"Kirghiz",tlh:"Klingon",ko:"Korean","ko-KP":"Korean (North Korea)","ko-KR":"Korean (South Korea)",la:"Latin",lv:"Latvian",lt:"Lithuanian",lb:"Luxembourgish",mk:"North Macedonia",ms:"Malay",ml:"Malayalam",mt:"Maltese",mi:"Maori",mr:"Marathi",mo:"Moldavian",nv:"Navajo",ng:"Ndonga",ne:"Nepali",no:"Norwegian",nb:"Norwegian (Bokmal)",nn:"Norwegian (Nynorsk)",oc:"Occitan",or:"Oriya",om:"Oromo",fa:"Persian","fa-IR":"Persian/Iran",pl:"Polish",pt:"Portuguese","pt-BR":"Portuguese (Brazil)",pa:"Punjabi","pa-IN":"Punjabi (India)","pa-PK":"Punjabi (Pakistan)",qu:"Quechua",rm:"Rhaeto-Romanic",ro:"Romanian","ro-MO":"Romanian (Moldavia)",ru:"Russian","ru-MO":"Russian (Moldavia)",sz:"Sami (Lappish)",sg:"Sango",sa:"Sanskrit",sc:"Sardinian",sd:"Sindhi",si:"Singhalese",sr:"Serbian",sk:"Slovak",sl:"Slovenian",so:"Somani",sb:"Sorbian",es:"Spanish","es-AR":"Spanish (Argentina)","es-BO":"Spanish (Bolivia)","es-CL":"Spanish (Chile)","es-CO":"Spanish (Colombia)","es-CR":"Spanish (Costa Rica)","es-DO":"Spanish (Dominican Republic)","es-EC":"Spanish (Ecuador)","es-SV":"Spanish (El Salvador)","es-GT":"Spanish (Guatemala)","es-HN":"Spanish (Honduras)","es-MX":"Spanish (Mexico)","es-NI":"Spanish (Nicaragua)","es-PA":"Spanish (Panama)","es-PY":"Spanish (Paraguay)","es-PE":"Spanish (Peru)","es-PR":"Spanish (Puerto Rico)","es-ES":"Spanish (Spain)","es-UY":"Spanish (Uruguay)","es-VE":"Spanish (Venezuela)",sx:"Sutu",sw:"Swahili",sv:"Swedish","sv-FI":"Swedish (Finland)","sv-SV":"Swedish (Sweden)",ta:"Tamil",tt:"Tatar",te:"Teluga",th:"Thai",tig:"Tigre",ts:"Tsonga",tn:"Tswana",tr:"Turkish",tk:"Turkmen",uk:"Ukrainian",hsb:"Upper Sorbian",ur:"Urdu",ve:"Venda",vi:"Vietnamese",vo:"Volapuk",wa:"Walloon",cy:"Welsh",xh:"Xhosa",ji:"Yiddish",zu:"Zulu"}[t]&&(this.internal.languageSettings.languageCode=t,!1===this.internal.languageSettings.isSubscribed&&(this.internal.events.subscribe("putCatalog",(function(){this.internal.write("/Lang ("+this.internal.languageSettings.languageCode+")");})),this.internal.languageSettings.isSubscribed=!0)),this},Vt=E$1.API,Gt=Vt.getCharWidthsArray=function(e,r){var n,i,a=(r=r||{}).font||this.internal.getFont(),o=r.fontSize||this.internal.getFontSize(),s=r.charSpace||this.internal.getCharSpace(),c=r.widths?r.widths:a.metadata.Unicode.widths,u=c.fof?c.fof:1,h=r.kerning?r.kerning:a.metadata.Unicode.kerning,l=h.fof?h.fof:1,f=!1!==r.doKerning,d=0,p=e.length,g=0,m=c[0]||u,v=[];for(n=0;n<p;n++)i=e.charCodeAt(n),"function"==typeof a.metadata.widthOfString?v.push((a.metadata.widthOfGlyph(a.metadata.characterToGlyph(i))+s*(1e3/o)||0)/1e3):(d=f&&"object"===_typeof$2(h[i])&&!isNaN(parseInt(h[i][g],10))?h[i][g]/l:0,v.push((c[i]||m)/u+d)),g=i;return v},Yt=Vt.getStringUnitWidth=function(t,e){var r=(e=e||{}).fontSize||this.internal.getFontSize(),n=e.font||this.internal.getFont(),i=e.charSpace||this.internal.getCharSpace();return Vt.processArabic&&(t=Vt.processArabic(t)),"function"==typeof n.metadata.widthOfString?n.metadata.widthOfString(t,r,i)/r:Gt.apply(this,arguments).reduce((function(t,e){return t+e}),0)},Jt=function(t,e,r,n){for(var i=[],a=0,o=t.length,s=0;a!==o&&s+e[a]<r;)s+=e[a],a++;i.push(t.slice(0,a));var c=a;for(s=0;a!==o;)s+e[a]>n&&(i.push(t.slice(c,a)),s=0,c=a),s+=e[a],a++;return c!==a&&i.push(t.slice(c,a)),i},Xt=function(t,e,r){r||(r={});var n,i,a,o,s,c,u,h=[],l=[h],f=r.textIndent||0,d=0,p=0,g=t.split(" "),m=Gt.apply(this,[" ",r])[0];if(c=-1===r.lineIndent?g[0].length+2:r.lineIndent||0){var v=Array(c).join(" "),b=[];g.map((function(t){(t=t.split(/\s*\n/)).length>1?b=b.concat(t.map((function(t,e){return (e&&t.length?"\n":"")+t}))):b.push(t[0]);})),g=b,c=Yt.apply(this,[v,r]);}for(a=0,o=g.length;a<o;a++){var y=0;if(n=g[a],c&&"\n"==n[0]&&(n=n.substr(1),y=1),f+d+(p=(i=Gt.apply(this,[n,r])).reduce((function(t,e){return t+e}),0))>e||y){if(p>e){for(s=Jt.apply(this,[n,i,e-(f+d),e]),h.push(s.shift()),h=[s.pop()];s.length;)l.push([s.shift()]);p=i.slice(n.length-(h[0]?h[0].length:0)).reduce((function(t,e){return t+e}),0);}else h=[n];l.push(h),f=p+c,d=m;}else h.push(n),f+=d+p,d=m;}return u=c?function(t,e){return (e?v:"")+t.join(" ")}:function(t){return t.join(" ")},l.map(u)},Vt.splitTextToSize=function(t,e,r){var n,i=(r=r||{}).fontSize||this.internal.getFontSize(),a=function(t){if(t.widths&&t.kerning)return {widths:t.widths,kerning:t.kerning};var e=this.internal.getFont(t.fontName,t.fontStyle);return e.metadata.Unicode?{widths:e.metadata.Unicode.widths||{0:1},kerning:e.metadata.Unicode.kerning||{}}:{font:e.metadata,fontSize:this.internal.getFontSize(),charSpace:this.internal.getCharSpace()}}.call(this,r);n=Array.isArray(t)?t:String(t).split(/\r?\n/);var o=1*this.internal.scaleFactor*e/i;a.textIndent=r.textIndent?1*r.textIndent*this.internal.scaleFactor/i:0,a.lineIndent=r.lineIndent;var s,c,u=[];for(s=0,c=n.length;s<c;s++)u=u.concat(Xt.apply(this,[n[s],o,a]));return u},function(e){e.__fontmetrics__=e.__fontmetrics__||{};for(var r="klmnopqrstuvwxyz",n={},i={},a=0;a<r.length;a++)n[r[a]]="0123456789abcdef"[a],i["0123456789abcdef"[a]]=r[a];var o=function(t){return "0x"+parseInt(t,10).toString(16)},s=e.__fontmetrics__.compress=function(e){var r,n,a,c,u=["{"];for(var h in e){if(r=e[h],isNaN(parseInt(h,10))?n="'"+h+"'":(h=parseInt(h,10),n=(n=o(h).slice(2)).slice(0,-1)+i[n.slice(-1)]),"number"==typeof r)r<0?(a=o(r).slice(3),c="-"):(a=o(r).slice(2),c=""),a=c+a.slice(0,-1)+i[a.slice(-1)];else {if("object"!==_typeof$2(r))throw new Error("Don't know what to do with value type "+_typeof$2(r)+".");a=s(r);}u.push(n+a);}return u.push("}"),u.join("")},c=e.__fontmetrics__.uncompress=function(t){if("string"!=typeof t)throw new Error("Invalid argument passed to uncompress.");for(var e,r,i,a,o={},s=1,c=o,u=[],h="",l="",f=t.length-1,d=1;d<f;d+=1)"'"==(a=t[d])?e?(i=e.join(""),e=void 0):e=[]:e?e.push(a):"{"==a?(u.push([c,i]),c={},i=void 0):"}"==a?((r=u.pop())[0][r[1]]=c,i=void 0,c=r[0]):"-"==a?s=-1:void 0===i?n.hasOwnProperty(a)?(h+=n[a],i=parseInt(h,16)*s,s=1,h=""):h+=a:n.hasOwnProperty(a)?(l+=n[a],c[i]=parseInt(l,16)*s,s=1,i=void 0,l=""):l+=a;return o},u={codePages:["WinAnsiEncoding"],WinAnsiEncoding:c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")},h={Unicode:{Courier:u,"Courier-Bold":u,"Courier-BoldOblique":u,"Courier-Oblique":u,Helvetica:u,"Helvetica-Bold":u,"Helvetica-BoldOblique":u,"Helvetica-Oblique":u,"Times-Roman":u,"Times-Bold":u,"Times-BoldItalic":u,"Times-Italic":u}},l={Unicode:{"Courier-Oblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-BoldItalic":c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),"Helvetica-Bold":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),Courier:c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-BoldOblique":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Bold":c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),Symbol:c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),Helvetica:c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),"Helvetica-BoldOblique":c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),ZapfDingbats:c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-Bold":c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Italic":c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),"Times-Roman":c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),"Helvetica-Oblique":c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}};e.events.push(["addFont",function(t){var e=t.font,r=l.Unicode[e.postScriptName];r&&(e.metadata.Unicode={},e.metadata.Unicode.widths=r.widths,e.metadata.Unicode.kerning=r.kerning);var n=h.Unicode[e.postScriptName];n&&(e.metadata.Unicode.encoding=n,e.encoding=n.codePages[0]);}]);}(E$1.API),
  /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(t){for(var e=t.length,r=new Uint8Array(e),n=0;n<e;n++)r[n]=t.charCodeAt(n);return r};t.API.events.push(["addFont",function(r){var n=void 0,i=r.font,a=r.instance;if(!i.isStandardFont){if(void 0===a)throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");if("string"!=typeof(n=!1===a.existsFileInVFS(i.postScriptName)?a.loadFile(i.postScriptName):a.getFileFromVFS(i.postScriptName)))throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('"+i.postScriptName+"').");!function(r,n){n=/^\x00\x01\x00\x00/.test(n)?e(n):e(u$2(n)),r.metadata=t.API.TTFFont.open(n),r.metadata.Unicode=r.metadata.Unicode||{encoding:{},kerning:{},widths:[]},r.metadata.glyIdsUsed=[0];}(i,n);}}]);}(E$1),
  /** @license
   * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  function(t){function e(){return (n$1.canvg?Promise.resolve(n$1.canvg):Promise.resolve().then(function () { return index_es; })).catch((function(t){return Promise.reject(new Error("Could not load canvg: "+t))})).then((function(t){return t.default?t.default:t}))}E$1.API.addSvgAsImage=function(t,r,n,i,o,s,c,u){if(isNaN(r)||isNaN(n))throw a$2.error("jsPDF.addSvgAsImage: Invalid coordinates",arguments),new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");if(isNaN(i)||isNaN(o))throw a$2.error("jsPDF.addSvgAsImage: Invalid measurements",arguments),new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");var h=document.createElement("canvas");h.width=i,h.height=o;var l=h.getContext("2d");l.fillStyle="#fff",l.fillRect(0,0,h.width,h.height);var f={ignoreMouse:!0,ignoreAnimation:!0,ignoreDimensions:!0},d=this;return e().then((function(e){return e.fromString(l,t,f)}),(function(){return Promise.reject(new Error("Could not load canvg."))})).then((function(t){return t.render(f)})).then((function(){d.addImage(h.toDataURL("image/jpeg",1),r,n,i,o,c,u);}))};}(),E$1.API.putTotalPages=function(t){var e,r=0;parseInt(this.internal.getFont().id.substr(1),10)<15?(e=new RegExp(t,"g"),r=this.internal.getNumberOfPages()):(e=new RegExp(this.pdfEscape16(t,this.internal.getFont()),"g"),r=this.pdfEscape16(this.internal.getNumberOfPages()+"",this.internal.getFont()));for(var n=1;n<=this.internal.getNumberOfPages();n++)for(var i=0;i<this.internal.pages[n].length;i++)this.internal.pages[n][i]=this.internal.pages[n][i].replace(e,r);return this},E$1.API.viewerPreferences=function(e,r){var n;e=e||{},r=r||!1;var i,a,o,s={HideToolbar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideMenubar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideWindowUI:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},FitWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},CenterWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},DisplayDocTitle:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.4},NonFullScreenPageMode:{defaultValue:"UseNone",value:"UseNone",type:"name",explicitSet:!1,valueSet:["UseNone","UseOutlines","UseThumbs","UseOC"],pdfVersion:1.3},Direction:{defaultValue:"L2R",value:"L2R",type:"name",explicitSet:!1,valueSet:["L2R","R2L"],pdfVersion:1.3},ViewArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},ViewClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintScaling:{defaultValue:"AppDefault",value:"AppDefault",type:"name",explicitSet:!1,valueSet:["AppDefault","None"],pdfVersion:1.6},Duplex:{defaultValue:"",value:"none",type:"name",explicitSet:!1,valueSet:["Simplex","DuplexFlipShortEdge","DuplexFlipLongEdge","none"],pdfVersion:1.7},PickTrayByPDFSize:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.7},PrintPageRange:{defaultValue:"",value:"",type:"array",explicitSet:!1,valueSet:null,pdfVersion:1.7},NumCopies:{defaultValue:1,value:1,type:"integer",explicitSet:!1,valueSet:null,pdfVersion:1.7}},c=Object.keys(s),u=[],h=0,l=0,f=0;function d(t,e){var r,n=!1;for(r=0;r<t.length;r+=1)t[r]===e&&(n=!0);return n}if(void 0===this.internal.viewerpreferences&&(this.internal.viewerpreferences={},this.internal.viewerpreferences.configuration=JSON.parse(JSON.stringify(s)),this.internal.viewerpreferences.isSubscribed=!1),n=this.internal.viewerpreferences.configuration,"reset"===e||!0===r){var p=c.length;for(f=0;f<p;f+=1)n[c[f]].value=n[c[f]].defaultValue,n[c[f]].explicitSet=!1;}if("object"===_typeof$2(e))for(a in e)if(o=e[a],d(c,a)&&void 0!==o){if("boolean"===n[a].type&&"boolean"==typeof o)n[a].value=o;else if("name"===n[a].type&&d(n[a].valueSet,o))n[a].value=o;else if("integer"===n[a].type&&Number.isInteger(o))n[a].value=o;else if("array"===n[a].type){for(h=0;h<o.length;h+=1)if(i=!0,1===o[h].length&&"number"==typeof o[h][0])u.push(String(o[h]-1));else if(o[h].length>1){for(l=0;l<o[h].length;l+=1)"number"!=typeof o[h][l]&&(i=!1);!0===i&&u.push([o[h][0]-1,o[h][1]-1].join(" "));}n[a].value="["+u.join(" ")+"]";}else n[a].value=n[a].defaultValue;n[a].explicitSet=!0;}return !1===this.internal.viewerpreferences.isSubscribed&&(this.internal.events.subscribe("putCatalog",(function(){var t,e=[];for(t in n)!0===n[t].explicitSet&&("name"===n[t].type?e.push("/"+t+" /"+n[t].value):e.push("/"+t+" "+n[t].value));0!==e.length&&this.internal.write("/ViewerPreferences\n<<\n"+e.join("\n")+"\n>>");})),this.internal.viewerpreferences.isSubscribed=!0),this.internal.viewerpreferences.configuration=n,this},
  /** ====================================================================
   * @license
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  function(t){var e=function(){var t='<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="'+this.internal.__metadata__.namespaceuri+'"><jspdf:metadata>',e=unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')),r=unescape(encodeURIComponent(t)),n=unescape(encodeURIComponent(this.internal.__metadata__.metadata)),i=unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")),a=unescape(encodeURIComponent("</x:xmpmeta>")),o=r.length+n.length+i.length+e.length+a.length;this.internal.__metadata__.metadata_object_number=this.internal.newObject(),this.internal.write("<< /Type /Metadata /Subtype /XML /Length "+o+" >>"),this.internal.write("stream"),this.internal.write(e+r+n+i+a),this.internal.write("endstream"),this.internal.write("endobj");},r=function(){this.internal.__metadata__.metadata_object_number&&this.internal.write("/Metadata "+this.internal.__metadata__.metadata_object_number+" 0 R");};t.addMetadata=function(t,n){return void 0===this.internal.__metadata__&&(this.internal.__metadata__={metadata:t,namespaceuri:n||"http://jspdf.default.namespaceuri/"},this.internal.events.subscribe("putCatalog",r),this.internal.events.subscribe("postPutResources",e)),this};}(E$1.API),function(t){var e=t.API,r=e.pdfEscape16=function(t,e){for(var r,n=e.metadata.Unicode.widths,i=["","0","00","000","0000"],a=[""],o=0,s=t.length;o<s;++o){if(r=e.metadata.characterToGlyph(t.charCodeAt(o)),e.metadata.glyIdsUsed.push(r),e.metadata.toUnicode[r]=t.charCodeAt(o),-1==n.indexOf(r)&&(n.push(r),n.push([parseInt(e.metadata.widthOfGlyph(r),10)])),"0"==r)return a.join("");r=r.toString(16),a.push(i[4-r.length],r);}return a.join("")},n=function(t){var e,r,n,i,a,o,s;for(a="/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange",n=[],o=0,s=(r=Object.keys(t).sort((function(t,e){return t-e}))).length;o<s;o++)e=r[o],n.length>=100&&(a+="\n"+n.length+" beginbfchar\n"+n.join("\n")+"\nendbfchar",n=[]),void 0!==t[e]&&null!==t[e]&&"function"==typeof t[e].toString&&(i=("0000"+t[e].toString(16)).slice(-4),e=("0000"+(+e).toString(16)).slice(-4),n.push("<"+e+"><"+i+">"));return n.length&&(a+="\n"+n.length+" beginbfchar\n"+n.join("\n")+"\nendbfchar\n"),a+="endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"};e.events.push(["putFont",function(e){!function(e){var r=e.font,i=e.out,a=e.newObject,o=e.putStream;if(r.metadata instanceof t.API.TTFFont&&"Identity-H"===r.encoding){for(var s=r.metadata.Unicode.widths,c=r.metadata.subset.encode(r.metadata.glyIdsUsed,1),u="",h=0;h<c.length;h++)u+=String.fromCharCode(c[h]);var l=a();o({data:u,addLength1:!0,objectId:l}),i("endobj");var f=a();o({data:n(r.metadata.toUnicode),addLength1:!0,objectId:f}),i("endobj");var d=a();i("<<"),i("/Type /FontDescriptor"),i("/FontName /"+F$1(r.fontName)),i("/FontFile2 "+l+" 0 R"),i("/FontBBox "+t.API.PDFObject.convert(r.metadata.bbox)),i("/Flags "+r.metadata.flags),i("/StemV "+r.metadata.stemV),i("/ItalicAngle "+r.metadata.italicAngle),i("/Ascent "+r.metadata.ascender),i("/Descent "+r.metadata.decender),i("/CapHeight "+r.metadata.capHeight),i(">>"),i("endobj");var p=a();i("<<"),i("/Type /Font"),i("/BaseFont /"+F$1(r.fontName)),i("/FontDescriptor "+d+" 0 R"),i("/W "+t.API.PDFObject.convert(s)),i("/CIDToGIDMap /Identity"),i("/DW 1000"),i("/Subtype /CIDFontType2"),i("/CIDSystemInfo"),i("<<"),i("/Supplement 0"),i("/Registry (Adobe)"),i("/Ordering ("+r.encoding+")"),i(">>"),i(">>"),i("endobj"),r.objectNumber=a(),i("<<"),i("/Type /Font"),i("/Subtype /Type0"),i("/ToUnicode "+f+" 0 R"),i("/BaseFont /"+F$1(r.fontName)),i("/Encoding /"+r.encoding),i("/DescendantFonts ["+p+" 0 R]"),i(">>"),i("endobj"),r.isAlreadyPutted=!0;}}(e);}]);e.events.push(["putFont",function(e){!function(e){var r=e.font,i=e.out,a=e.newObject,o=e.putStream;if(r.metadata instanceof t.API.TTFFont&&"WinAnsiEncoding"===r.encoding){for(var s=r.metadata.rawData,c="",u=0;u<s.length;u++)c+=String.fromCharCode(s[u]);var h=a();o({data:c,addLength1:!0,objectId:h}),i("endobj");var l=a();o({data:n(r.metadata.toUnicode),addLength1:!0,objectId:l}),i("endobj");var f=a();i("<<"),i("/Descent "+r.metadata.decender),i("/CapHeight "+r.metadata.capHeight),i("/StemV "+r.metadata.stemV),i("/Type /FontDescriptor"),i("/FontFile2 "+h+" 0 R"),i("/Flags 96"),i("/FontBBox "+t.API.PDFObject.convert(r.metadata.bbox)),i("/FontName /"+F$1(r.fontName)),i("/ItalicAngle "+r.metadata.italicAngle),i("/Ascent "+r.metadata.ascender),i(">>"),i("endobj"),r.objectNumber=a();for(var d=0;d<r.metadata.hmtx.widths.length;d++)r.metadata.hmtx.widths[d]=parseInt(r.metadata.hmtx.widths[d]*(1e3/r.metadata.head.unitsPerEm));i("<</Subtype/TrueType/Type/Font/ToUnicode "+l+" 0 R/BaseFont/"+F$1(r.fontName)+"/FontDescriptor "+f+" 0 R/Encoding/"+r.encoding+" /FirstChar 29 /LastChar 255 /Widths "+t.API.PDFObject.convert(r.metadata.hmtx.widths)+">>"),i("endobj"),r.isAlreadyPutted=!0;}}(e);}]);var i=function(t){var e,n=t.text||"",i=t.x,a=t.y,o=t.options||{},s=t.mutex||{},c=s.pdfEscape,u=s.activeFontKey,h=s.fonts,l=u,f="",d=0,p="",g=h[l].encoding;if("Identity-H"!==h[l].encoding)return {text:n,x:i,y:a,options:o,mutex:s};for(p=n,l=u,Array.isArray(n)&&(p=n[0]),d=0;d<p.length;d+=1)h[l].metadata.hasOwnProperty("cmap")&&(e=h[l].metadata.cmap.unicode.codeMap[p[d].charCodeAt(0)]),e||p[d].charCodeAt(0)<256&&h[l].metadata.hasOwnProperty("Unicode")?f+=p[d]:f+="";var m="";return parseInt(l.slice(1))<14||"WinAnsiEncoding"===g?m=c(f,l).split("").map((function(t){return t.charCodeAt(0).toString(16)})).join(""):"Identity-H"===g&&(m=r(f,h[l])),s.isHex=!0,{text:m,x:i,y:a,options:o,mutex:s}};e.events.push(["postProcessText",function(t){var e=t.text||"",r=[],n={text:e,x:t.x,y:t.y,options:t.options,mutex:t.mutex};if(Array.isArray(e)){var a=0;for(a=0;a<e.length;a+=1)Array.isArray(e[a])&&3===e[a].length?r.push([i(Object.assign({},n,{text:e[a][0]})).text,e[a][1],e[a][2]]):r.push(i(Object.assign({},n,{text:e[a]})).text);t.text=r;}else t.text=i(Object.assign({},n,{text:e})).text;}]);}(E$1),
  /**
   * @license
   * jsPDF virtual FileSystem functionality
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function(t){var e=function(){return void 0===this.internal.vFS&&(this.internal.vFS={}),!0};t.existsFileInVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]},t.addFileToVFS=function(t,r){return e.call(this),this.internal.vFS[t]=r,this},t.getFileFromVFS=function(t){return e.call(this),void 0!==this.internal.vFS[t]?this.internal.vFS[t]:null};}(E$1.API),
  /**
   * @license
   * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
   * MIT License
   */
  function(t){t.__bidiEngine__=t.prototype.__bidiEngine__=function(t){var r,n,i,a,o,s,c,u=e,h=[[0,3,0,1,0,0,0],[0,3,0,1,2,2,0],[0,3,0,17,2,0,1],[0,3,5,5,4,1,0],[0,3,21,21,4,0,1],[0,3,5,5,4,2,0]],l=[[2,0,1,1,0,1,0],[2,0,1,1,0,2,0],[2,0,2,1,3,2,0],[2,0,2,33,3,1,1]],f={L:0,R:1,EN:2,AN:3,N:4,B:5,S:6},d={0:0,5:1,6:2,7:3,32:4,251:5,254:6,255:7},p=["(",")","(","<",">","<","[","]","[","{","}","{","«","»","«","‹","›","‹","⁅","⁆","⁅","⁽","⁾","⁽","₍","₎","₍","≤","≥","≤","〈","〉","〈","﹙","﹚","﹙","﹛","﹜","﹛","﹝","﹞","﹝","﹤","﹥","﹤"],g=new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/),m=!1,v=0;this.__bidiEngine__={};var b=function(t){var e=t.charCodeAt(),r=e>>8,n=d[r];return void 0!==n?u[256*n+(255&e)]:252===r||253===r?"AL":g.test(r)?"L":8===r?"R":"N"},y=function(t){for(var e,r=0;r<t.length;r++){if("L"===(e=b(t.charAt(r))))return !1;if("R"===e)return !0}return !1},w=function(t,e,o,s){var c,u,h,l,f=e[s];switch(f){case"L":case"R":m=!1;break;case"N":case"AN":break;case"EN":m&&(f="AN");break;case"AL":m=!0,f="R";break;case"WS":f="N";break;case"CS":s<1||s+1>=e.length||"EN"!==(c=o[s-1])&&"AN"!==c||"EN"!==(u=e[s+1])&&"AN"!==u?f="N":m&&(u="AN"),f=u===c?u:"N";break;case"ES":f="EN"===(c=s>0?o[s-1]:"B")&&s+1<e.length&&"EN"===e[s+1]?"EN":"N";break;case"ET":if(s>0&&"EN"===o[s-1]){f="EN";break}if(m){f="N";break}for(h=s+1,l=e.length;h<l&&"ET"===e[h];)h++;f=h<l&&"EN"===e[h]?"EN":"N";break;case"NSM":if(i&&!a){for(l=e.length,h=s+1;h<l&&"NSM"===e[h];)h++;if(h<l){var d=t[s],p=d>=1425&&d<=2303||64286===d;if(c=e[h],p&&("R"===c||"AL"===c)){f="R";break}}}f=s<1||"B"===(c=e[s-1])?"N":o[s-1];break;case"B":m=!1,r=!0,f=v;break;case"S":n=!0,f="N";break;case"LRE":case"RLE":case"LRO":case"RLO":case"PDF":m=!1;break;case"BN":f="N";}return f},N=function(t,e,r){var n=t.split("");return r&&L(n,r,{hiLevel:v}),n.reverse(),e&&e.reverse(),n.join("")},L=function(t,e,i){var a,o,s,c,u,d=-1,p=t.length,g=0,y=[],N=v?l:h,L=[];for(m=!1,r=!1,n=!1,o=0;o<p;o++)L[o]=b(t[o]);for(s=0;s<p;s++){if(u=g,y[s]=w(t,L,y,s),a=240&(g=N[u][f[y[s]]]),g&=15,e[s]=c=N[g][5],a>0)if(16===a){for(o=d;o<s;o++)e[o]=1;d=-1;}else d=-1;if(N[g][6])-1===d&&(d=s);else if(d>-1){for(o=d;o<s;o++)e[o]=c;d=-1;}"B"===L[s]&&(e[s]=0),i.hiLevel|=c;}n&&function(t,e,r){for(var n=0;n<r;n++)if("S"===t[n]){e[n]=v;for(var i=n-1;i>=0&&"WS"===t[i];i--)e[i]=v;}}(L,e,p);},A=function(t,e,n,i,a){if(!(a.hiLevel<t)){if(1===t&&1===v&&!r)return e.reverse(),void(n&&n.reverse());for(var o,s,c,u,h=e.length,l=0;l<h;){if(i[l]>=t){for(c=l+1;c<h&&i[c]>=t;)c++;for(u=l,s=c-1;u<s;u++,s--)o=e[u],e[u]=e[s],e[s]=o,n&&(o=n[u],n[u]=n[s],n[s]=o);l=c;}l++;}}},x=function(t,e,r){var n=t.split(""),i={hiLevel:v};return r||(r=[]),L(n,r,i),function(t,e,r){if(0!==r.hiLevel&&c)for(var n,i=0;i<t.length;i++)1===e[i]&&(n=p.indexOf(t[i]))>=0&&(t[i]=p[n+1]);}(n,r,i),A(2,n,e,r,i),A(1,n,e,r,i),n.join("")};return this.__bidiEngine__.doBidiReorder=function(t,e,r){if(function(t,e){if(e)for(var r=0;r<t.length;r++)e[r]=r;void 0===a&&(a=y(t)),void 0===s&&(s=y(t));}(t,e),i||!o||s)if(i&&o&&a^s)v=a?1:0,t=N(t,e,r);else if(!i&&o&&s)v=a?1:0,t=x(t,e,r),t=N(t,e);else if(!i||a||o||s){if(i&&!o&&a^s)t=N(t,e),a?(v=0,t=x(t,e,r)):(v=1,t=x(t,e,r),t=N(t,e));else if(i&&a&&!o&&s)v=1,t=x(t,e,r),t=N(t,e);else if(!i&&!o&&a^s){var n=c;a?(v=1,t=x(t,e,r),v=0,c=!1,t=x(t,e,r),c=n):(v=0,t=x(t,e,r),t=N(t,e),v=1,c=!1,t=x(t,e,r),c=n,t=N(t,e));}}else v=0,t=x(t,e,r);else v=a?1:0,t=x(t,e,r);return t},this.__bidiEngine__.setOptions=function(t){t&&(i=t.isInputVisual,o=t.isOutputVisual,a=t.isInputRtl,s=t.isOutputRtl,c=t.isSymmetricSwapping);},this.__bidiEngine__.setOptions(t),this.__bidiEngine__};var e=["BN","BN","BN","BN","BN","BN","BN","BN","BN","S","B","S","WS","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","B","B","B","S","WS","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","BN","BN","BN","BN","BN","BN","B","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","BN","CS","N","ET","ET","ET","ET","N","N","N","N","L","N","N","BN","N","N","ET","ET","EN","EN","N","L","N","N","N","EN","L","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","L","L","L","L","L","L","L","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","L","N","N","N","N","N","ET","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","NSM","R","NSM","NSM","R","NSM","NSM","R","NSM","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","N","N","N","N","N","R","R","R","R","R","N","N","N","N","N","N","N","N","N","N","N","AN","AN","AN","AN","AN","AN","N","N","AL","ET","ET","AL","CS","AL","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","AN","AN","AN","AN","AN","AN","AN","AN","AN","ET","AN","AN","AL","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AN","N","NSM","NSM","NSM","NSM","NSM","NSM","AL","AL","NSM","NSM","N","NSM","NSM","NSM","NSM","AL","AL","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","AL","AL","NSM","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","R","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","R","R","N","N","N","N","R","N","N","N","N","N","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","WS","BN","BN","BN","L","R","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","B","LRE","RLE","PDF","LRO","RLO","CS","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","WS","BN","BN","BN","BN","BN","N","LRI","RLI","FSI","PDI","BN","BN","BN","BN","BN","BN","EN","L","N","N","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","L","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","ES","ES","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","N","N","N","N","N","R","NSM","R","R","R","R","R","R","R","R","R","R","ES","R","R","R","R","R","R","R","R","R","R","R","R","R","N","R","R","R","R","R","N","R","N","R","R","N","R","R","N","R","R","R","R","R","R","R","R","R","R","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","NSM","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","CS","N","CS","N","N","CS","N","N","N","N","N","N","N","N","N","ET","N","N","ES","ES","N","N","N","N","N","ET","ET","N","N","N","N","N","AL","AL","AL","AL","AL","N","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","AL","N","N","BN","N","N","N","ET","ET","ET","N","N","N","N","N","ES","CS","ES","CS","CS","EN","EN","EN","EN","EN","EN","EN","EN","EN","EN","CS","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","N","N","N","N","N","N","N","N","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","L","N","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","L","L","L","N","N","L","L","L","N","N","N","ET","ET","N","N","N","ET","ET","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N","N"],r=new t.__bidiEngine__({isInputVisual:!0});t.API.events.push(["postProcessText",function(t){var e=t.text,n=(t.x,t.y,t.options||{}),i=(t.mutex,n.lang,[]);if(n.isInputVisual="boolean"!=typeof n.isInputVisual||n.isInputVisual,r.setOptions(n),"[object Array]"===Object.prototype.toString.call(e)){var a=0;for(i=[],a=0;a<e.length;a+=1)"[object Array]"===Object.prototype.toString.call(e[a])?i.push([r.doBidiReorder(e[a][0]),e[a][1],e[a][2]]):i.push([r.doBidiReorder(e[a])]);t.text=i;}else t.text=r.doBidiReorder(e);r.setOptions({isInputVisual:!0});}]);}(E$1),E$1.API.TTFFont=function(){function t(t){var e;if(this.rawData=t,e=this.contents=new ne(t),this.contents.pos=4,"ttcf"===e.readString(4))throw new Error("TTCF not supported.");e.pos=0,this.parse(),this.subset=new Le(this),this.registerTTF();}return t.open=function(e){return new t(e)},t.prototype.parse=function(){return this.directory=new ie(this.contents),this.head=new se(this),this.name=new pe(this),this.cmap=new ue(this),this.toUnicode={},this.hhea=new he(this),this.maxp=new ge(this),this.hmtx=new me(this),this.post=new fe(this),this.os2=new le(this),this.loca=new Ne(this),this.glyf=new be(this),this.ascender=this.os2.exists&&this.os2.ascender||this.hhea.ascender,this.decender=this.os2.exists&&this.os2.decender||this.hhea.decender,this.lineGap=this.os2.exists&&this.os2.lineGap||this.hhea.lineGap,this.bbox=[this.head.xMin,this.head.yMin,this.head.xMax,this.head.yMax]},t.prototype.registerTTF=function(){var t,e,r,n,i;if(this.scaleFactor=1e3/this.head.unitsPerEm,this.bbox=function(){var e,r,n,i;for(i=[],e=0,r=(n=this.bbox).length;e<r;e++)t=n[e],i.push(Math.round(t*this.scaleFactor));return i}.call(this),this.stemV=0,this.post.exists?(r=255&(n=this.post.italic_angle),0!=(32768&(e=n>>16))&&(e=-(1+(65535^e))),this.italicAngle=+(e+"."+r)):this.italicAngle=0,this.ascender=Math.round(this.ascender*this.scaleFactor),this.decender=Math.round(this.decender*this.scaleFactor),this.lineGap=Math.round(this.lineGap*this.scaleFactor),this.capHeight=this.os2.exists&&this.os2.capHeight||this.ascender,this.xHeight=this.os2.exists&&this.os2.xHeight||0,this.familyClass=(this.os2.exists&&this.os2.familyClass||0)>>8,this.isSerif=1===(i=this.familyClass)||2===i||3===i||4===i||5===i||7===i,this.isScript=10===this.familyClass,this.flags=0,this.post.isFixedPitch&&(this.flags|=1),this.isSerif&&(this.flags|=2),this.isScript&&(this.flags|=8),0!==this.italicAngle&&(this.flags|=64),this.flags|=32,!this.cmap.unicode)throw new Error("No unicode cmap for font")},t.prototype.characterToGlyph=function(t){var e;return (null!=(e=this.cmap.unicode)?e.codeMap[t]:void 0)||0},t.prototype.widthOfGlyph=function(t){var e;return e=1e3/this.head.unitsPerEm,this.hmtx.forGlyph(t).advance*e},t.prototype.widthOfString=function(t,e,r){var n,i,a,o;for(a=0,i=0,o=(t=""+t).length;0<=o?i<o:i>o;i=0<=o?++i:--i)n=t.charCodeAt(i),a+=this.widthOfGlyph(this.characterToGlyph(n))+r*(1e3/e)||0;return a*(e/1e3)},t.prototype.lineHeight=function(t,e){var r;return null==e&&(e=!1),r=e?this.lineGap:0,(this.ascender+r-this.decender)/1e3*t},t}();var re,ne=function(){function t(t){this.data=null!=t?t:[],this.pos=0,this.length=this.data.length;}return t.prototype.readByte=function(){return this.data[this.pos++]},t.prototype.writeByte=function(t){return this.data[this.pos++]=t},t.prototype.readUInt32=function(){return 16777216*this.readByte()+(this.readByte()<<16)+(this.readByte()<<8)+this.readByte()},t.prototype.writeUInt32=function(t){return this.writeByte(t>>>24&255),this.writeByte(t>>16&255),this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt32=function(){var t;return (t=this.readUInt32())>=2147483648?t-4294967296:t},t.prototype.writeInt32=function(t){return t<0&&(t+=4294967296),this.writeUInt32(t)},t.prototype.readUInt16=function(){return this.readByte()<<8|this.readByte()},t.prototype.writeUInt16=function(t){return this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt16=function(){var t;return (t=this.readUInt16())>=32768?t-65536:t},t.prototype.writeInt16=function(t){return t<0&&(t+=65536),this.writeUInt16(t)},t.prototype.readString=function(t){var e,r;for(r=[],e=0;0<=t?e<t:e>t;e=0<=t?++e:--e)r[e]=String.fromCharCode(this.readByte());return r.join("")},t.prototype.writeString=function(t){var e,r,n;for(n=[],e=0,r=t.length;0<=r?e<r:e>r;e=0<=r?++e:--e)n.push(this.writeByte(t.charCodeAt(e)));return n},t.prototype.readShort=function(){return this.readInt16()},t.prototype.writeShort=function(t){return this.writeInt16(t)},t.prototype.readLongLong=function(){var t,e,r,n,i,a,o,s;return t=this.readByte(),e=this.readByte(),r=this.readByte(),n=this.readByte(),i=this.readByte(),a=this.readByte(),o=this.readByte(),s=this.readByte(),128&t?-1*(72057594037927940*(255^t)+281474976710656*(255^e)+1099511627776*(255^r)+4294967296*(255^n)+16777216*(255^i)+65536*(255^a)+256*(255^o)+(255^s)+1):72057594037927940*t+281474976710656*e+1099511627776*r+4294967296*n+16777216*i+65536*a+256*o+s},t.prototype.writeLongLong=function(t){var e,r;return e=Math.floor(t/4294967296),r=4294967295&t,this.writeByte(e>>24&255),this.writeByte(e>>16&255),this.writeByte(e>>8&255),this.writeByte(255&e),this.writeByte(r>>24&255),this.writeByte(r>>16&255),this.writeByte(r>>8&255),this.writeByte(255&r)},t.prototype.readInt=function(){return this.readInt32()},t.prototype.writeInt=function(t){return this.writeInt32(t)},t.prototype.read=function(t){var e,r;for(e=[],r=0;0<=t?r<t:r>t;r=0<=t?++r:--r)e.push(this.readByte());return e},t.prototype.write=function(t){var e,r,n,i;for(i=[],r=0,n=t.length;r<n;r++)e=t[r],i.push(this.writeByte(e));return i},t}(),ie=function(){var t;function e(t){var e,r,n;for(this.scalarType=t.readInt(),this.tableCount=t.readShort(),this.searchRange=t.readShort(),this.entrySelector=t.readShort(),this.rangeShift=t.readShort(),this.tables={},r=0,n=this.tableCount;0<=n?r<n:r>n;r=0<=n?++r:--r)e={tag:t.readString(4),checksum:t.readInt(),offset:t.readInt(),length:t.readInt()},this.tables[e.tag]=e;}return e.prototype.encode=function(e){var r,n,i,a,o,s,c,u,h,l,f,d,p;for(p in f=Object.keys(e).length,s=Math.log(2),h=16*Math.floor(Math.log(f)/s),a=Math.floor(h/s),u=16*f-h,(n=new ne).writeInt(this.scalarType),n.writeShort(f),n.writeShort(h),n.writeShort(a),n.writeShort(u),i=16*f,c=n.pos+i,o=null,d=[],e)for(l=e[p],n.writeString(p),n.writeInt(t(l)),n.writeInt(c),n.writeInt(l.length),d=d.concat(l),"head"===p&&(o=c),c+=l.length;c%4;)d.push(0),c++;return n.write(d),r=2981146554-t(n.data),n.pos=o+8,n.writeUInt32(r),n.data},t=function(t){var e,r,n,i;for(t=ve.call(t);t.length%4;)t.push(0);for(n=new ne(t),r=0,e=0,i=t.length;e<i;e=e+=4)r+=n.readUInt32();return 4294967295&r},e}(),ae={}.hasOwnProperty,oe=function(t,e){for(var r in e)ae.call(e,r)&&(t[r]=e[r]);function n(){this.constructor=t;}return n.prototype=e.prototype,t.prototype=new n,t.__super__=e.prototype,t};re=function(){function t(t){var e;this.file=t,e=this.file.directory.tables[this.tag],this.exists=!!e,e&&(this.offset=e.offset,this.length=e.length,this.parse(this.file.contents));}return t.prototype.parse=function(){},t.prototype.encode=function(){},t.prototype.raw=function(){return this.exists?(this.file.contents.pos=this.offset,this.file.contents.read(this.length)):null},t}();var se=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="head",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.revision=t.readInt(),this.checkSumAdjustment=t.readInt(),this.magicNumber=t.readInt(),this.flags=t.readShort(),this.unitsPerEm=t.readShort(),this.created=t.readLongLong(),this.modified=t.readLongLong(),this.xMin=t.readShort(),this.yMin=t.readShort(),this.xMax=t.readShort(),this.yMax=t.readShort(),this.macStyle=t.readShort(),this.lowestRecPPEM=t.readShort(),this.fontDirectionHint=t.readShort(),this.indexToLocFormat=t.readShort(),this.glyphDataFormat=t.readShort()},e.prototype.encode=function(t){var e;return (e=new ne).writeInt(this.version),e.writeInt(this.revision),e.writeInt(this.checkSumAdjustment),e.writeInt(this.magicNumber),e.writeShort(this.flags),e.writeShort(this.unitsPerEm),e.writeLongLong(this.created),e.writeLongLong(this.modified),e.writeShort(this.xMin),e.writeShort(this.yMin),e.writeShort(this.xMax),e.writeShort(this.yMax),e.writeShort(this.macStyle),e.writeShort(this.lowestRecPPEM),e.writeShort(this.fontDirectionHint),e.writeShort(t),e.writeShort(this.glyphDataFormat),e.data},e}(),ce=function(){function t(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m,v,b;switch(this.platformID=t.readUInt16(),this.encodingID=t.readShort(),this.offset=e+t.readInt(),h=t.pos,t.pos=this.offset,this.format=t.readUInt16(),this.length=t.readUInt16(),this.language=t.readUInt16(),this.isUnicode=3===this.platformID&&1===this.encodingID&&4===this.format||0===this.platformID&&4===this.format,this.codeMap={},this.format){case 0:for(s=0;s<256;++s)this.codeMap[s]=t.readByte();break;case 4:for(f=t.readUInt16(),l=f/2,t.pos+=6,i=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),t.pos+=2,p=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),c=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),u=function(){var e,r;for(r=[],s=e=0;0<=l?e<l:e>l;s=0<=l?++e:--e)r.push(t.readUInt16());return r}(),n=(this.length-t.pos+this.offset)/2,o=function(){var e,r;for(r=[],s=e=0;0<=n?e<n:e>n;s=0<=n?++e:--e)r.push(t.readUInt16());return r}(),s=m=0,b=i.length;m<b;s=++m)for(g=i[s],r=v=d=p[s];d<=g?v<=g:v>=g;r=d<=g?++v:--v)0===u[s]?a=r+c[s]:0!==(a=o[u[s]/2+(r-d)-(l-s)]||0)&&(a+=c[s]),this.codeMap[r]=65535&a;}t.pos=h;}return t.encode=function(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m,v,b,y,w,N,L,A,x,S,_,P,k,I,F,C,j,O,B,M,E,q,D,R,T,U,z,H,W,V,G,Y;switch(I=new ne,a=Object.keys(t).sort((function(t,e){return t-e})),e){case"macroman":for(p=0,g=function(){var t=[];for(d=0;d<256;++d)t.push(0);return t}(),v={0:0},i={},F=0,B=a.length;F<B;F++)null==v[W=t[n=a[F]]]&&(v[W]=++p),i[n]={old:t[n],new:v[t[n]]},g[n]=v[t[n]];return I.writeUInt16(1),I.writeUInt16(0),I.writeUInt32(12),I.writeUInt16(0),I.writeUInt16(262),I.writeUInt16(0),I.write(g),{charMap:i,subtable:I.data,maxGlyphID:p+1};case"unicode":for(P=[],h=[],b=0,v={},r={},m=c=null,C=0,M=a.length;C<M;C++)null==v[w=t[n=a[C]]]&&(v[w]=++b),r[n]={old:w,new:v[w]},o=v[w]-n,null!=m&&o===c||(m&&h.push(m),P.push(n),c=o),m=n;for(m&&h.push(m),h.push(65535),P.push(65535),S=2*(x=P.length),A=2*Math.pow(Math.log(x)/Math.LN2,2),l=Math.log(A/2)/Math.LN2,L=2*x-A,s=[],N=[],f=[],d=j=0,E=P.length;j<E;d=++j){if(_=P[d],u=h[d],65535===_){s.push(0),N.push(0);break}if(_-(k=r[_].new)>=32768)for(s.push(0),N.push(2*(f.length+x-d)),n=O=_;_<=u?O<=u:O>=u;n=_<=u?++O:--O)f.push(r[n].new);else s.push(k-_),N.push(0);}for(I.writeUInt16(3),I.writeUInt16(1),I.writeUInt32(12),I.writeUInt16(4),I.writeUInt16(16+8*x+2*f.length),I.writeUInt16(0),I.writeUInt16(S),I.writeUInt16(A),I.writeUInt16(l),I.writeUInt16(L),z=0,q=h.length;z<q;z++)n=h[z],I.writeUInt16(n);for(I.writeUInt16(0),H=0,D=P.length;H<D;H++)n=P[H],I.writeUInt16(n);for(V=0,R=s.length;V<R;V++)o=s[V],I.writeUInt16(o);for(G=0,T=N.length;G<T;G++)y=N[G],I.writeUInt16(y);for(Y=0,U=f.length;Y<U;Y++)p=f[Y],I.writeUInt16(p);return {charMap:r,subtable:I.data,maxGlyphID:b+1}}},t}(),ue=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="cmap",e.prototype.parse=function(t){var e,r,n;for(t.pos=this.offset,this.version=t.readUInt16(),n=t.readUInt16(),this.tables=[],this.unicode=null,r=0;0<=n?r<n:r>n;r=0<=n?++r:--r)e=new ce(t,this.offset),this.tables.push(e),e.isUnicode&&null==this.unicode&&(this.unicode=e);return !0},e.encode=function(t,e){var r,n;return null==e&&(e="macroman"),r=ce.encode(t,e),(n=new ne).writeUInt16(0),n.writeUInt16(1),r.table=n.data.concat(r.subtable),r},e}(),he=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="hhea",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.ascender=t.readShort(),this.decender=t.readShort(),this.lineGap=t.readShort(),this.advanceWidthMax=t.readShort(),this.minLeftSideBearing=t.readShort(),this.minRightSideBearing=t.readShort(),this.xMaxExtent=t.readShort(),this.caretSlopeRise=t.readShort(),this.caretSlopeRun=t.readShort(),this.caretOffset=t.readShort(),t.pos+=8,this.metricDataFormat=t.readShort(),this.numberOfMetrics=t.readUInt16()},e}(),le=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="OS/2",e.prototype.parse=function(t){if(t.pos=this.offset,this.version=t.readUInt16(),this.averageCharWidth=t.readShort(),this.weightClass=t.readUInt16(),this.widthClass=t.readUInt16(),this.type=t.readShort(),this.ySubscriptXSize=t.readShort(),this.ySubscriptYSize=t.readShort(),this.ySubscriptXOffset=t.readShort(),this.ySubscriptYOffset=t.readShort(),this.ySuperscriptXSize=t.readShort(),this.ySuperscriptYSize=t.readShort(),this.ySuperscriptXOffset=t.readShort(),this.ySuperscriptYOffset=t.readShort(),this.yStrikeoutSize=t.readShort(),this.yStrikeoutPosition=t.readShort(),this.familyClass=t.readShort(),this.panose=function(){var e,r;for(r=[],e=0;e<10;++e)r.push(t.readByte());return r}(),this.charRange=function(){var e,r;for(r=[],e=0;e<4;++e)r.push(t.readInt());return r}(),this.vendorID=t.readString(4),this.selection=t.readShort(),this.firstCharIndex=t.readShort(),this.lastCharIndex=t.readShort(),this.version>0&&(this.ascent=t.readShort(),this.descent=t.readShort(),this.lineGap=t.readShort(),this.winAscent=t.readShort(),this.winDescent=t.readShort(),this.codePageRange=function(){var e,r;for(r=[],e=0;e<2;e=++e)r.push(t.readInt());return r}(),this.version>1))return this.xHeight=t.readShort(),this.capHeight=t.readShort(),this.defaultChar=t.readShort(),this.breakChar=t.readShort(),this.maxContext=t.readShort()},e}(),fe=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="post",e.prototype.parse=function(t){var e,r,n;switch(t.pos=this.offset,this.format=t.readInt(),this.italicAngle=t.readInt(),this.underlinePosition=t.readShort(),this.underlineThickness=t.readShort(),this.isFixedPitch=t.readInt(),this.minMemType42=t.readInt(),this.maxMemType42=t.readInt(),this.minMemType1=t.readInt(),this.maxMemType1=t.readInt(),this.format){case 65536:break;case 131072:var i;for(r=t.readUInt16(),this.glyphNameIndex=[],i=0;0<=r?i<r:i>r;i=0<=r?++i:--i)this.glyphNameIndex.push(t.readUInt16());for(this.names=[],n=[];t.pos<this.offset+this.length;)e=t.readByte(),n.push(this.names.push(t.readString(e)));return n;case 151552:return r=t.readUInt16(),this.offsets=t.read(r);case 196608:break;case 262144:return this.map=function(){var e,r,n;for(n=[],i=e=0,r=this.file.maxp.numGlyphs;0<=r?e<r:e>r;i=0<=r?++e:--e)n.push(t.readUInt32());return n}.call(this)}},e}(),de=function(t,e){this.raw=t,this.length=t.length,this.platformID=e.platformID,this.encodingID=e.encodingID,this.languageID=e.languageID;},pe=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="name",e.prototype.parse=function(t){var e,r,n,i,a,o,s,c,u,h,l;for(t.pos=this.offset,t.readShort(),e=t.readShort(),o=t.readShort(),r=[],i=0;0<=e?i<e:i>e;i=0<=e?++i:--i)r.push({platformID:t.readShort(),encodingID:t.readShort(),languageID:t.readShort(),nameID:t.readShort(),length:t.readShort(),offset:this.offset+o+t.readShort()});for(s={},i=u=0,h=r.length;u<h;i=++u)n=r[i],t.pos=n.offset,c=t.readString(n.length),a=new de(c,n),null==s[l=n.nameID]&&(s[l]=[]),s[n.nameID].push(a);this.strings=s,this.copyright=s[0],this.fontFamily=s[1],this.fontSubfamily=s[2],this.uniqueSubfamily=s[3],this.fontName=s[4],this.version=s[5];try{this.postscriptName=s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}catch(t){this.postscriptName=s[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g,"");}return this.trademark=s[7],this.manufacturer=s[8],this.designer=s[9],this.description=s[10],this.vendorUrl=s[11],this.designerUrl=s[12],this.license=s[13],this.licenseUrl=s[14],this.preferredFamily=s[15],this.preferredSubfamily=s[17],this.compatibleFull=s[18],this.sampleText=s[19]},e}(),ge=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="maxp",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.numGlyphs=t.readUInt16(),this.maxPoints=t.readUInt16(),this.maxContours=t.readUInt16(),this.maxCompositePoints=t.readUInt16(),this.maxComponentContours=t.readUInt16(),this.maxZones=t.readUInt16(),this.maxTwilightPoints=t.readUInt16(),this.maxStorage=t.readUInt16(),this.maxFunctionDefs=t.readUInt16(),this.maxInstructionDefs=t.readUInt16(),this.maxStackElements=t.readUInt16(),this.maxSizeOfInstructions=t.readUInt16(),this.maxComponentElements=t.readUInt16(),this.maxComponentDepth=t.readUInt16()},e}(),me=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="hmtx",e.prototype.parse=function(t){var e,r,n,i,a,o,s;for(t.pos=this.offset,this.metrics=[],e=0,o=this.file.hhea.numberOfMetrics;0<=o?e<o:e>o;e=0<=o?++e:--e)this.metrics.push({advance:t.readUInt16(),lsb:t.readInt16()});for(n=this.file.maxp.numGlyphs-this.file.hhea.numberOfMetrics,this.leftSideBearings=function(){var r,i;for(i=[],e=r=0;0<=n?r<n:r>n;e=0<=n?++r:--r)i.push(t.readInt16());return i}(),this.widths=function(){var t,e,r,n;for(n=[],t=0,e=(r=this.metrics).length;t<e;t++)i=r[t],n.push(i.advance);return n}.call(this),r=this.widths[this.widths.length-1],s=[],e=a=0;0<=n?a<n:a>n;e=0<=n?++a:--a)s.push(this.widths.push(r));return s},e.prototype.forGlyph=function(t){return t in this.metrics?this.metrics[t]:{advance:this.metrics[this.metrics.length-1].advance,lsb:this.leftSideBearings[t-this.metrics.length]}},e}(),ve=[].slice,be=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="glyf",e.prototype.parse=function(){return this.cache={}},e.prototype.glyphFor=function(t){var e,r,n,i,a,o,s,c,u,h;return t in this.cache?this.cache[t]:(i=this.file.loca,e=this.file.contents,r=i.indexOf(t),0===(n=i.lengthOf(t))?this.cache[t]=null:(e.pos=this.offset+r,a=(o=new ne(e.read(n))).readShort(),c=o.readShort(),h=o.readShort(),s=o.readShort(),u=o.readShort(),this.cache[t]=-1===a?new we(o,c,h,s,u):new ye(o,a,c,h,s,u),this.cache[t]))},e.prototype.encode=function(t,e,r){var n,i,a,o,s;for(a=[],i=[],o=0,s=e.length;o<s;o++)n=t[e[o]],i.push(a.length),n&&(a=a.concat(n.encode(r)));return i.push(a.length),{table:a,offsets:i}},e}(),ye=function(){function t(t,e,r,n,i,a){this.raw=t,this.numberOfContours=e,this.xMin=r,this.yMin=n,this.xMax=i,this.yMax=a,this.compound=!1;}return t.prototype.encode=function(){return this.raw.data},t}(),we=function(){function t(t,e,r,n,i){var a,o;for(this.raw=t,this.xMin=e,this.yMin=r,this.xMax=n,this.yMax=i,this.compound=!0,this.glyphIDs=[],this.glyphOffsets=[],a=this.raw;o=a.readShort(),this.glyphOffsets.push(a.pos),this.glyphIDs.push(a.readUInt16()),32&o;)a.pos+=1&o?4:2,128&o?a.pos+=8:64&o?a.pos+=4:8&o&&(a.pos+=2);}return t.prototype.encode=function(){var t,e,r;for(e=new ne(ve.call(this.raw.data)),t=0,r=this.glyphIDs.length;t<r;++t)e.pos=this.glyphOffsets[t];return e.data},t}(),Ne=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return oe(e,re),e.prototype.tag="loca",e.prototype.parse=function(t){var e,r;return t.pos=this.offset,e=this.file.head.indexToLocFormat,this.offsets=0===e?function(){var e,n;for(n=[],r=0,e=this.length;r<e;r+=2)n.push(2*t.readUInt16());return n}.call(this):function(){var e,n;for(n=[],r=0,e=this.length;r<e;r+=4)n.push(t.readUInt32());return n}.call(this)},e.prototype.indexOf=function(t){return this.offsets[t]},e.prototype.lengthOf=function(t){return this.offsets[t+1]-this.offsets[t]},e.prototype.encode=function(t,e){for(var r=new Uint32Array(this.offsets.length),n=0,i=0,a=0;a<r.length;++a)if(r[a]=n,i<e.length&&e[i]==a){++i,r[a]=n;var o=this.offsets[a],s=this.offsets[a+1]-o;s>0&&(n+=s);}for(var c=new Array(4*r.length),u=0;u<r.length;++u)c[4*u+3]=255&r[u],c[4*u+2]=(65280&r[u])>>8,c[4*u+1]=(16711680&r[u])>>16,c[4*u]=(4278190080&r[u])>>24;return c},e}(),Le=function(){function t(t){this.font=t,this.subset={},this.unicodes={},this.next=33;}return t.prototype.generateCmap=function(){var t,e,r,n,i;for(e in n=this.font.cmap.tables[0].codeMap,t={},i=this.subset)r=i[e],t[e]=n[r];return t},t.prototype.glyphsFor=function(t){var e,r,n,i,a,o,s;for(n={},a=0,o=t.length;a<o;a++)n[i=t[a]]=this.font.glyf.glyphFor(i);for(i in e=[],n)(null!=(r=n[i])?r.compound:void 0)&&e.push.apply(e,r.glyphIDs);if(e.length>0)for(i in s=this.glyphsFor(e))r=s[i],n[i]=r;return n},t.prototype.encode=function(t,e){var r,n,i,a,o,s,c,u,h,l,f,d,p,g,m;for(n in r=ue.encode(this.generateCmap(),"unicode"),a=this.glyphsFor(t),f={0:0},m=r.charMap)f[(s=m[n]).old]=s.new;for(d in l=r.maxGlyphID,a)d in f||(f[d]=l++);return u=function(t){var e,r;for(e in r={},t)r[t[e]]=e;return r}(f),h=Object.keys(u).sort((function(t,e){return t-e})),p=function(){var t,e,r;for(r=[],t=0,e=h.length;t<e;t++)o=h[t],r.push(u[o]);return r}(),i=this.font.glyf.encode(a,p,f),c=this.font.loca.encode(i.offsets,p),g={cmap:this.font.cmap.raw(),glyf:i.table,loca:c,hmtx:this.font.hmtx.raw(),hhea:this.font.hhea.raw(),maxp:this.font.maxp.raw(),post:this.font.post.raw(),name:this.font.name.raw(),head:this.font.head.encode(e)},this.font.os2.exists&&(g["OS/2"]=this.font.os2.raw()),this.font.directory.encode(g)},t}();E$1.API.PDFObject=function(){var t;function e(){}return t=function(t,e){return (Array(e+1).join("0")+t).slice(-e)},e.convert=function(r){var n,i,a,o;if(Array.isArray(r))return "["+function(){var t,i,a;for(a=[],t=0,i=r.length;t<i;t++)n=r[t],a.push(e.convert(n));return a}().join(" ")+"]";if("string"==typeof r)return "/"+r;if(null!=r?r.isString:void 0)return "("+r+")";if(r instanceof Date)return "(D:"+t(r.getUTCFullYear(),4)+t(r.getUTCMonth(),2)+t(r.getUTCDate(),2)+t(r.getUTCHours(),2)+t(r.getUTCMinutes(),2)+t(r.getUTCSeconds(),2)+"Z)";if("[object Object]"==={}.toString.call(r)){for(i in a=["<<"],r)o=r[i],a.push("/"+i+" "+e.convert(o));return a.push(">>"),a.join("\n")}return ""+r},e}();

  var Map$1 = /** @class */ (function (_super) {
      __extends$6(Map, _super);
      function Map(options) {
          var _this = _super.call(this) || this;
          _this._layerCollection = new BaseCollection({ id: "layer-collection" });
          _this._overlayCollection = new BaseCollection({ id: "overlay-collection" });
          _this._componentCollection = new BaseCollection({
              id: "component-collection"
          });
          vertifyParam(options, ["target", "center"]);
          _this._options = options;
          if (defined$1(options.extent)) {
              _this._extent = options.extent;
          }
          var mapConfig = __assign$1({ controls: [], view: new OlView__default["default"](__assign$1(__assign$1(__assign$1(__assign$1({ projection: PUBLIC_CONFIG.projection, zoom: PUBLIC_CONFIG.zoom, multiWorld: false }, options), { center: transformToProjection(options.center) }), (defined$1(options.orientation) ? { rotation: toRadians(options.orientation[0]) } : {})), (defined$1(options.extent)
                  ? {
                      extent: transformInternal(options.extent, {
                          destination: PUBLIC_CONFIG.projection,
                          source: PUBLIC_CONFIG.dataProjection
                      })
                  }
                  : {}))), interactions: interaction.defaults() }, options);
          _this._map = new Map__default["default"](mapConfig);
          // 禁用双击缩放交互器
          _this._map.getInteractions().forEach(function (i) {
              if (i instanceof DoubleClickZoom__default["default"]) {
                  i.setActive(false);
              }
              else if (i instanceof interaction.DragRotate) {
                  i.setActive(false);
              }
          });
          _this._mouseEventHandler = new PointClickAndMove({ events: [] }, _this);
          _this._map.addInteraction(_this._mouseEventHandler);
          // 聚合动画交互器
          _this._map.addInteraction(new Select({}));
          _this.map.on("postrender", function () {
              _this.dispatchEvent({
                  type: BaseEventType.POST_RENDER
              });
          });
          _this.map.getView().on("change:center", function () {
              _this.dispatchEvent({
                  type: BaseEventType.CENTER_CHANGED,
                  center: _this.center
              });
          });
          _this.map.getView().on("change:resolution", function () {
              _this.dispatchEvent({
                  type: BaseEventType.ZOOM_CHANGED,
                  zoom: _this.zoom
              });
          });
          _this.map.on("movestart", function () {
              _this.dispatchEvent({
                  type: BaseEventType.MOVE_START
              });
          });
          _this.map.on("moveend", function () {
              _this.dispatchEvent({
                  type: BaseEventType.MOVE_END
              });
          });
          return _this;
      }
      Object.defineProperty(Map.prototype, "position", {
          /**
           * 地图定位参数
           */
          get: function () {
              return {
                  center: this.center,
                  zoom: this.zoom,
                  orientation: this.orientation
              };
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "zoom", {
          get: function () {
              return this.map.getView().getZoom();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "center", {
          get: function () {
              return transformToDataProjection(this.map.getView().getCenter());
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "orientation", {
          get: function () {
              return [parseFloat(((toDegrees(this.map.getView().getRotation()) + 360) % 360).toFixed(3)), -90, 0];
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "depthAgainstTerrain", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "fxaa", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return false;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "defaultTextureVisibility", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return true;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "brightness", {
          get: function () {
              console.warn(ErrorNotification.NOT_SUPPORTED);
              return 1;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "layers", {
          get: function () {
              return this._layerCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "overlays", {
          get: function () {
              return this._overlayCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "components", {
          get: function () {
              return this._componentCollection.getArray();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "models", {
          get: function () {
              console.warn(ErrorNotification.NOT_IMPLEMENTED);
              return [];
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "eventOverlayContainer", {
          get: function () {
              return this.map.getOverlayContainer();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "stopEventOverlayContainer", {
          get: function () {
              return this.map.getOverlayContainerStopEvent();
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "map", {
          get: function () {
              return this._map;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "options", {
          get: function () {
              return this._options;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "currentExtent", {
          get: function () {
              return transformInternal(this.map.getView().calculateExtent(this.map.getSize()), {
                  source: PUBLIC_CONFIG.projection,
                  destination: PUBLIC_CONFIG.dataProjection
              });
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "extent", {
          get: function () {
              return this._extent;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "jobScheduler", {
          get: function () {
              this._jobScheduler || (this._jobScheduler = new JobScheduler());
              return this._jobScheduler;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "maxPitch", {
          get: function () {
              return void 0;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Map.prototype, "minPitch", {
          get: function () {
              return void 0;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * @ignore
       */
      Map.prototype._add = function (type, item) {
          if (item.destroyed) {
              throw new Error(ErrorNotification.DESTROYED);
          }
          this["_".concat(type, "Collection")].add(item);
          item.addTo(this);
          var eventType;
          switch (type) {
              case "model":
                  eventType = BaseEventType.ADD_MODEL;
                  break;
              case "layer":
                  eventType = BaseEventType.ADD_LAYER;
                  break;
              case "overlay":
                  eventType = BaseEventType.ADD_OVERLAY;
                  break;
              case "component":
                  eventType = BaseEventType.ADD_COMPONENT;
                  break;
          }
          this.dispatchEvent({
              type: eventType,
              item: item
          });
      };
      /**
       * @ignore
       */
      Map.prototype._remove = function (type, item, destroy) {
          var temItem = typeof item === "string" ? this["_".concat(type, "Collection")].getItem(item) : item;
          if (temItem) {
              temItem.remove(destroy);
              this["_".concat(type, "Collection")].remove(temItem);
              var event_1;
              switch (type) {
                  case "model":
                      event_1 = {
                          type: BaseEventType.REMOVE_MODEL,
                          model: item
                      };
                      break;
                  case "layer":
                      event_1 = {
                          type: BaseEventType.REMOVE_LAYER,
                          layer: item
                      };
                      break;
                  case "overlay":
                      event_1 = {
                          type: BaseEventType.REMOVE_OVERLAY,
                          overlay: item
                      };
                      break;
                  case "component":
                      event_1 = {
                          type: BaseEventType.REMOVE_COMPONENT,
                          component: item
                      };
                      break;
              }
              this.dispatchEvent(event_1);
          }
      };
      /**
       * @ignore
       */
      Map.prototype._get = function (type, id) {
          return this["_".concat(type, "Collection")].getItem(id);
      };
      /**
       * @ignore
       */
      Map.prototype._has = function (type, id) {
          return this["_".concat(type, "Collection")].include(id);
      };
      /**
       * @ignore
       */
      Map.prototype._clearAll = function (type, destroy, filter) {
          var e_1, _a;
          try {
              for (var _b = __values(this["_".concat(type, "Collection")]), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var i = _c.value;
                  if (defined$1(filter) && !filter(i)) {
                      continue;
                  }
                  this["remove".concat(upperCaseFirstWord(type))](i, destroy);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /**
       * @ignore
       */
      Map.prototype._getAll = function (type) {
          return this["_".concat(type, "Collection")].getArray();
      };
      // /**
      //  *
      //  * @param data
      //  * @param options
      //  */
      // addData(data, options) {}
      /**
       * 获取图层
       *
       * @param id 图层id
       * @return {*}
       */
      Map.prototype.getLayer = function (id) {
          return this._get("layer", id);
      };
      /**
       * 获取全部图层
       *
       * @return {*}
       */
      Map.prototype.getLayers = function () {
          return this._getAll("layer");
      };
      /**
       * 图层是否存在
       *
       * @param {string} id 图层id
       * @return {*}
       */
      Map.prototype.hasLayer = function (id) {
          return this._has("layer", id);
      };
      /**
       * 图层添加到地图
       *
       * @param {Layer} layer 图层对象
       * @return {*}
       */
      Map.prototype.addLayer = function (layer) {
          this._add("layer", layer);
          return this;
      };
      /**
       * 移除图层
       *
       * @param {(string | Layer)} layer 图层对象或id
       * @param {boolean} [destroy=false] 是否销毁
       * @return {*}
       */
      Map.prototype.removeLayer = function (layer, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("layer", layer, destroy);
          return this;
      };
      /**
       * 显示图层
       *
       * @param {(string | Layer)} layer 图层对象或id
       * @return {*}
       */
      Map.prototype.showLayer = function (layer) {
          if (typeof layer === "string") {
              layer = this.getLayer(layer);
          }
          if (defined$1(layer)) {
              layer.show();
          }
          return this;
      };
      /**
       * 隐藏图层
       *
       * @param {(string | Layer)} layer
       * @return {*}
       */
      Map.prototype.hideLayer = function (layer) {
          if (typeof layer === "string") {
              layer = this.getLayer(layer);
          }
          if (defined$1(layer)) {
              layer.hide();
          }
          return this;
      };
      /**
       * 清空图层
       *
       * @param destroy 是否销毁清除的图层
       * @param clearBasemap 是否清除basemap为true的图层
       * @return {*}
       */
      Map.prototype.clearLayers = function (destroy, clearBasemap) {
          if (destroy === void 0) { destroy = false; }
          if (clearBasemap === void 0) { clearBasemap = false; }
          this._clearAll("layer", destroy, clearBasemap ? void 0 : function (item) { return item.basemap === false; });
          return this;
      };
      /**
       * 获取覆盖物
       *
       * @param id 覆盖物id
       * @return {*}
       */
      Map.prototype.getOverlay = function (id) {
          return this._get("overlay", id);
      };
      /**
       * 获取全部覆盖物
       *
       * @return {*}
       */
      Map.prototype.getOverlays = function () {
          return this._getAll("overlay");
      };
      /**
       * 覆盖物是否存在
       *
       * @param {string} id 覆盖物id
       * @return {*}
       */
      Map.prototype.hasOverlay = function (id) {
          return this._has("overlay", id);
      };
      /**
       * 覆盖物添加到地图
       *
       * @param {Overlay} overlay 覆盖物对象
       * @return {*}
       */
      Map.prototype.addOverlay = function (overlay) {
          this._add("overlay", overlay);
          return this;
      };
      /**
       * 移除覆盖物
       *
       * @param {(string | Overlay)} overlay 覆盖物对象或id
       * @param {boolean} [destroy=false] 是否销毁
       * @return {*}
       */
      Map.prototype.removeOverlay = function (overlay, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("overlay", overlay, destroy);
          return this;
      };
      /**
       * 清空全部覆盖物
       *
       * @param [destroy=false]
       * @return {*}
       */
      Map.prototype.clearOverlays = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this._clearAll("overlay", destroy);
          return this;
      };
      /**
       * 获取组件
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.getComponent = function (id) {
          return this._get("component", id);
      };
      /**
       * 获取全部组件
       *
       * @return {*}
       */
      Map.prototype.getComponents = function () {
          return this._getAll("component");
      };
      /**
       * 组件是否存在
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.hasComponent = function (id) {
          return this._has("component", id);
      };
      /**
       * 组件添加到地图
       *
       * @param {Component} component
       * @return {*}
       */
      Map.prototype.addComponent = function (component) {
          this._add("component", component);
          return this;
      };
      /**
       * 移除组件
       *
       * @param {(string | Component)} component
       * @param {boolean} [destroy=false]
       * @return {*}
       */
      Map.prototype.removeComponent = function (component, destroy) {
          if (destroy === void 0) { destroy = false; }
          this._remove("component", component, destroy);
          return this;
      };
      /**
       * 清空组件
       *
       * @return {*}
       */
      Map.prototype.clearComponents = function (destroy) {
          if (destroy === void 0) { destroy = false; }
          this._clearAll("component", destroy);
          return this;
      };
      /**
       * 获取模型
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.getModel = function (id) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return void 0;
      };
      /**
       * 获取全部模型
       *
       * @return {*}
       */
      Map.prototype.getModels = function () {
          console.warn(ErrorNotification.NOT_IMPLEMENTED);
          return [];
      };
      /**
       * 模型是否存在
       *
       * @param {string} id
       * @return {*}
       */
      Map.prototype.hasModel = function (id) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return false;
      };
      /**
       * 添加模型到地图
       *
       * @param {Model} model
       * @return {*}
       */
      Map.prototype.addModel = function (model) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      /**
       * 移除模型
       *
       * @param {(string | Model)} model
       * @param {boolean} [destroy=false]
       * @return {*}
       */
      Map.prototype.removeModel = function (model, destroy) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      /**
       * 清空模型
       *
       * @return {*}
       */
      Map.prototype.clearModels = function () {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.switchTo2D = function (duration) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.switchTo3D = function (duration) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.aroundTarget = function (options) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.aroundCamera = function (options) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.lookAt = function (options) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.dragRotate = function (flag) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.dragPan = function (flag) {
          if (flag === void 0) { flag = true; }
          var items = this.map.getInteractions().getArray();
          var interaction = null;
          items.every(function (item) {
              if (item && item instanceof DragPan__default["default"]) {
                  interaction = item;
                  return false;
              }
              else {
                  return true;
              }
          });
          if (interaction) {
              interaction.setActive(flag);
          }
          return this;
      };
      Map.prototype.wheelZoom = function (flag) {
          var items = this.map.getInteractions().getArray();
          var interaction = null;
          items.every(function (item) {
              if (item && item instanceof MouseWheelZoom__default["default"]) {
                  interaction = item;
                  return false;
              }
              else {
                  return true;
              }
          });
          if (interaction) {
              interaction.setActive(flag);
          }
          return this;
      };
      Map.prototype.print = function (options) {
          var _options = Object.assign({
              fileName: "map",
              fileType: "png"
          }, options || {});
          var mapElement = null;
          if (_options.target) {
              mapElement = document.getElementById(_options.target);
          }
          else {
              mapElement = this.map.getTargetElement();
          }
          if (!mapElement) {
              throw new Error(ErrorNotification.OPTIONS_UNDEFINED);
          }
          this.map.once("rendercomplete", function () {
              var exportOptions = {};
              if (_options.fileType === "pdf") {
                  toJpeg(mapElement, __assign$1({ quality: 0.92 }, exportOptions)).then(function (dataUrl) {
                      var offsetHeight = mapElement.offsetHeight, offsetWidth = mapElement.offsetWidth;
                      var doc = new E$1({
                          orientation: "l",
                          unit: "pt",
                          format: [offsetWidth + 20, offsetHeight + 20]
                      });
                      doc.addImage(dataUrl, "JPEG", 10, 10, offsetWidth, offsetHeight);
                      doc.save("".concat(_options.fileName, ".").concat(_options.fileType));
                  });
              }
              else {
                  var f = void 0;
                  if (_options.fileType === "png") {
                      f = toPng;
                  }
                  else if (_options.fileType === "jpg" || _options.fileType === "jpeg") {
                      f = toJpeg;
                      exportOptions = __assign$1({ quality: 0.92 }, exportOptions);
                  }
                  f(mapElement, exportOptions).then(function (dataUrl) {
                      saveDataURL("".concat(_options.fileName, ".").concat(_options.fileType), dataUrl, _options.fileType === "png" ? "image/png" : "image/jpg");
                  });
              }
          });
          this.map.renderSync();
          return this;
      };
      Map.prototype.flyTo = function (options) {
          var _this = this;
          return new Promise(function (resolve) {
              var center, fitParam;
              if (defined$1(options.center)) {
                  if (Array.isArray(options.center)) {
                      if (options.center.length === 0) {
                          throw new Error(ErrorNotification.UNSUPPORTED_PARAM);
                      }
                      else if (typeof options.center[0] === "number") {
                          center = options.center;
                      }
                      else {
                          var fc = featureCollection(options.center.map(function (i) {
                              return transformInternal(i.geoJson, {
                                  source: i.dataProjection,
                                  destination: WGS84_PROJECTION_NAME,
                                  offset: i.offset
                              });
                          }));
                          if (defined$1(options.zoom)) {
                              center = transformInternal(Turf__namespace.center(fc).geometry.coordinates, {
                                  source: WGS84_PROJECTION_NAME,
                                  destination: PUBLIC_CONFIG.dataProjection
                              });
                          }
                          else {
                              fitParam = transformToProjection(Turf__namespace.bbox(fc), WGS84_PROJECTION_NAME);
                          }
                      }
                  }
                  else if (options.center instanceof VectorLayer) {
                      if (defined$1(options.zoom)) {
                          center = transformInternal(Turf__namespace.center(featureCollection(options.center.cluster
                              ? options.center._data.features
                              : options.center.features.map(function (i) {
                                  return transformInternal(i.geoJson, {
                                      source: i.dataProjection,
                                      destination: WGS84_PROJECTION_NAME,
                                      offset: i.offset
                                  });
                              }))).geometry.coordinates, {
                              source: WGS84_PROJECTION_NAME,
                              destination: PUBLIC_CONFIG.dataProjection
                          });
                      }
                      else {
                          fitParam = options.center.cluster
                              ? transformToProjection(Turf__namespace.bbox(options.center._data))
                              : transformToProjection(options.center.extent);
                      }
                  }
                  else if (options.center instanceof Feature) {
                      var fc = featureCollection([
                          transformInternal(options.center.geoJson, {
                              source: options.center.dataProjection,
                              destination: WGS84_PROJECTION_NAME,
                              offset: options.center.offset
                          })
                      ]);
                      if (defined$1(options.zoom)) {
                          center = transformInternal(Turf__namespace.center(fc).geometry.coordinates, {
                              source: WGS84_PROJECTION_NAME,
                              destination: PUBLIC_CONFIG.dataProjection
                          });
                      }
                      else {
                          fitParam = transformToProjection(Turf__namespace.bbox(fc), WGS84_PROJECTION_NAME);
                      }
                  }
              }
              if (defined$1(fitParam)) {
                  _this.map.getView().fit(fitParam, __assign$1(__assign$1({}, options), { duration: (defined$1(options.duration) ? options.duration : 0) * 1000, maxZoom: options.zoom, callback: function (f) {
                          resolve(f);
                      } }));
              }
              else {
                  _this.map.getView().animate(__assign$1(__assign$1(__assign$1(__assign$1({}, (defined$1(center) ? { center: transformToProjection(center) } : {})), (defined$1(options.zoom) ? { zoom: options.zoom } : {})), (defined$1(options.orientation) ? { rotation: toRadians(options.orientation[0]) } : {})), { duration: (defined$1(options.duration) ? options.duration : 0) * 1000 }), function (f) {
                      resolve(f);
                  });
              }
          });
      };
      Map.prototype.setZoom = function (zoom) {
          this.map.getView().setZoom(zoom);
          return this;
      };
      Map.prototype.setCenter = function (center) {
          this.map.getView().setCenter(transformToProjection(center));
          return this;
      };
      Map.prototype.setOrientation = function (orientation) {
          this.map.getView().setRotation(toRadians(orientation[0]));
          return this;
      };
      Map.prototype.setDepthAgainstTerrain = function (status) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.setFxaa = function (status) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.setDefaultTextureVisibility = function (visible) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      Map.prototype.setBrightness = function (brightness) {
          console.warn(ErrorNotification.NOT_SUPPORTED);
          return this;
      };
      /**
       * @ignore
       */
      Map.prototype.registerEventEnable = function (type) {
          type = pickEventTypeToClickType(type);
          if (!isMapMouseEventType(type))
              return;
          this._registeredEventNumberStore || (this._registeredEventNumberStore = {});
          if (defined$1(this._registeredEventNumberStore[type])) {
              this._registeredEventNumberStore[type] += 1;
          }
          else {
              this._registeredEventNumberStore[type] = 1;
          }
          if (!this._mouseEventHandler.eventsStore_.includes(type)) {
              this._mouseEventHandler.eventsStore_.push(type);
              this._mouseEventHandler.setEvents(this._mouseEventHandler.eventsStore_);
          }
          return;
      };
      /**
       * @ignore
       */
      Map.prototype.unregisterEventEnable = function (type) {
          type = pickEventTypeToClickType(type);
          if (!isMapMouseEventType(type))
              return;
          this._registeredEventNumberStore || (this._registeredEventNumberStore = {});
          if (defined$1(this._registeredEventNumberStore[type])) {
              this._registeredEventNumberStore[type] -= 1;
          }
          else {
              this._registeredEventNumberStore[type] = 0;
          }
          if (this._mouseEventHandler.eventsStore_.includes(type) && this._registeredEventNumberStore[type] === 0) {
              this._mouseEventHandler.eventsStore_ = this._mouseEventHandler.eventsStore_.filter(function (i) { return i !== type; });
              this._mouseEventHandler.setEvents(this._mouseEventHandler.eventsStore_);
          }
          return;
      };
      /**
       * 屏幕像素坐标转为经纬度坐标
       *
       * @param pixel
       * @returns
       */
      Map.prototype.pixelToCoordinate = function (pixel) {
          return transformToDataProjection(this.map.getCoordinateFromPixel(pixel), this.map.getView().getProjection().getCode());
      };
      /**
       * 经纬度坐标转为屏幕像素坐标
       *
       * @param coordinate
       * @returns
       */
      Map.prototype.coordinateToPixel = function (coordinate) {
          return this.map.getPixelFromCoordinate(transform$3(coordinate, { destination: this.map.getView().getProjection().getCode() }));
      };
      /**
       * 销毁地图
       */
      Map.prototype.destroy = function () {
          _super.prototype.destroy.call(this);
          clearProperty(this);
      };
      /**
       * @ignore
       */
      Map.prototype._destroy = function () {
          var _this = this;
          _super.prototype._destroy.call(this);
          ["component", "layer", "overlay"].forEach(function (name) {
              _this["clear".concat(upperCaseFirstWord(name), "s")](true);
          });
          this.map.dispose();
          this._map = void 0;
      };
      /**
       * 设置最大地图俯仰角
       *
       * [cesium]
       */
      Map.prototype.setMaxPitch = function (maxPitch) {
          return this;
      };
      /**
       * 设置最小地图俯仰角
       *
       * [cesium]
       */
      Map.prototype.setMinPitch = function (minPitch) {
          return this;
      };
      return Map;
  }(Observable$2));

  /**
   * 将WKT字符串数组转为Feature对象数组
   *
   * **WKT格式**
   *
   * - 点
   * ```
   * 'POINT(35.12 19.12)'
   * ```
   * - 线
   * ```
   * 'LINESTRING (30 10, 10 30, 40 40)'
   * ```
   * - 面 (首尾坐标必须相同)
   * ```
   * // 简单面
   * 'POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))'
   * // 中心有孔的面
   * `POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10),(20 30, 35 35, 30 20, 20 30))`
   * ```
   *
   * - 多点
   * ```
   * 'MULTIPOINT (10 40, 40 30, 20 20, 30 10)'
   * ```
   * - 多线
   * ```
   * 'MULTILINESTRING ((10 10, 20 20, 10 40),(40 40, 30 30, 40 20, 30 10))'
   * ```
   * - 多面 (首尾坐标必须相同)
   * ```
   * // 简单面
   * 'MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),((15 5, 40 10, 10 20, 5 10, 15 5)))'
   * // 中心有孔的面
   * `MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)),((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))`
   * ```
   *
   * @param wkts WKT字符串数组
   * @returns
   *
   */
  function read(wkts, options) {
      return wktsToFeatures(wkts, { Point: Point$1, Polyline: Polyline$1, Polygon: Polygon$1 }, options);
  }
  /**
   * 将Feature对象数组转为wkt字符串数组
   *
   * @param features 要素数组
   * @returns
   */
  function write(features, options) {
      return featuresToWkts(features, options);
  }

  var WKT = /*#__PURE__*/Object.freeze({
    __proto__: null,
    read: read,
    write: write
  });

  /**
   * core
   */
  var version$1 = "".concat(gitVersion, "(").concat(gitDate, ")");
  /**
   * @ignore
   */
  var name = "mti-gis-ol";

  /*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || from);
  }

  var Bounds = /** @class */ (function () {
      function Bounds(left, top, width, height) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
      }
      Bounds.prototype.add = function (x, y, w, h) {
          return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
      };
      Bounds.fromClientRect = function (context, clientRect) {
          return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
      };
      Bounds.fromDOMRectList = function (context, domRectList) {
          var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
          return domRect
              ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
              : Bounds.EMPTY;
      };
      Bounds.EMPTY = new Bounds(0, 0, 0, 0);
      return Bounds;
  }());
  var parseBounds = function (context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
  };
  var parseDocumentSize = function (document) {
      var body = document.body;
      var documentElement = document.documentElement;
      if (!body || !documentElement) {
          throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
  };

  /*
   * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var toCodePoints$1 = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint$1 = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
  }

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
  }
  var decode$1 = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1$1[base64.charCodeAt(i)];
          encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2$1 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1$1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT$1 = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
  var slice16$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64$1 = function (base64, _byteLength) {
      var buffer = decode$1(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16$1(view16, (headerLength + view32[4]) / 2)
          : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie$1 = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
  }

  var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

  var LETTER_NUMBER_MODIFIER = 50;
  // Non-tailorable Line Breaking Classes
  var BK = 1; //  Cause a line break (after)
  var CR$1 = 2; //  Cause a line break (after), except between CR and LF
  var LF$1 = 3; //  Cause a line break (after)
  var CM = 4; //  Prohibit a line break between the character and the preceding character
  var NL = 5; //  Cause a line break (after)
  var WJ = 7; //  Prohibit line breaks before and after
  var ZW = 8; //  Provide a break opportunity
  var GL = 9; //  Prohibit line breaks before and after
  var SP = 10; // Enable indirect line breaks
  var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
  // Break Opportunities
  var B2 = 12; //  Provide a line break opportunity before and after the character
  var BA = 13; //  Generally provide a line break opportunity after the character
  var BB = 14; //  Generally provide a line break opportunity before the character
  var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
  var CB = 16; //   Provide a line break opportunity contingent on additional information
  // Characters Prohibiting Certain Breaks
  var CL = 17; //  Prohibit line breaks before
  var CP = 18; //  Prohibit line breaks before
  var EX = 19; //  Prohibit line breaks before
  var IN = 20; //  Allow only indirect line breaks between pairs
  var NS = 21; //  Allow only indirect line breaks before
  var OP = 22; //  Prohibit line breaks after
  var QU = 23; //  Act like they are both opening and closing
  // Numeric Context
  var IS = 24; //  Prevent breaks after any and before numeric
  var NU = 25; //  Form numeric expressions for line breaking purposes
  var PO = 26; //  Do not break following a numeric expression
  var PR = 27; //  Do not break in front of a numeric expression
  var SY = 28; //  Prevent a break before; and allow a break after
  // Other Characters
  var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
  var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
  var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
  var EB = 32; //  Do not break from following Emoji Modifier
  var EM = 33; //  Do not break from preceding Emoji Base
  var H2 = 34; //  Form Korean syllable blocks
  var H3 = 35; //  Form Korean syllable blocks
  var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
  var ID = 37; //  Break before or after; except in some numeric context
  var JL = 38; //  Form Korean syllable blocks
  var JV = 39; //  Form Korean syllable blocks
  var JT = 40; //  Form Korean syllable blocks
  var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
  var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
  var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
  var ea_OP = [0x2329, 0xff08];
  var BREAK_MANDATORY = '!';
  var BREAK_NOT_ALLOWED$1 = '×';
  var BREAK_ALLOWED$1 = '÷';
  var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
  var ALPHABETICS = [AL, HL];
  var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
  var SPACE$1 = [SP, ZW];
  var PREFIX_POSTFIX = [PR, PO];
  var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  var HYPHEN = [HY, BA];
  var codePointsToCharacterClasses = function (codePoints, lineBreak) {
      if (lineBreak === void 0) { lineBreak = 'strict'; }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function (codePoint, index) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
          }
          else {
              categories.push(false);
          }
          if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
              // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
              if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                  indices.push(index);
                  return types.push(CB);
              }
          }
          if (classType === CM || classType === ZWJ$1) {
              // LB10 Treat any remaining combining mark or ZWJ as AL.
              if (index === 0) {
                  indices.push(index);
                  return types.push(AL);
              }
              // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
              // the base character in all of the following rules. Treat ZWJ as if it were CM.
              var prev = types[index - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                  indices.push(indices[index - 1]);
                  return types.push(prev);
              }
              indices.push(index);
              return types.push(AL);
          }
          indices.push(index);
          if (classType === CJ) {
              return types.push(lineBreak === 'strict' ? NS : ID);
          }
          if (classType === SA) {
              return types.push(AL);
          }
          if (classType === AI) {
              return types.push(AL);
          }
          // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
          // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
          // to take into account the actual line breaking properties for these characters.
          if (classType === XX) {
              if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
                  return types.push(ID);
              }
              else {
                  return types.push(AL);
              }
          }
          types.push(classType);
      });
      return [indices, types, categories];
  };
  var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
          var i = currentIndex;
          while (i <= classTypes.length) {
              i++;
              var next = classTypes[i];
              if (next === b) {
                  return true;
              }
              if (next !== SP) {
                  break;
              }
          }
      }
      if (current === SP) {
          var i = currentIndex;
          while (i > 0) {
              i--;
              var prev = classTypes[i];
              if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                  var n = currentIndex;
                  while (n <= classTypes.length) {
                      n++;
                      var next = classTypes[n];
                      if (next === b) {
                          return true;
                      }
                      if (next !== SP) {
                          break;
                      }
                  }
              }
              if (prev !== SP) {
                  break;
              }
          }
      }
      return false;
  };
  var previousNonSpaceClassType = function (currentIndex, classTypes) {
      var i = currentIndex;
      while (i >= 0) {
          var type = classTypes[i];
          if (type === SP) {
              i--;
          }
          else {
              return type;
          }
      }
      return 0;
  };
  var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
      if (indicies[index] === 0) {
          return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      // LB4 Always break after hard line breaks.
      // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
      }
      // LB6 Do not break before hard line breaks.
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB7 Do not break before spaces or zero width space.
      if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
      }
      // LB8a Do not break after a zero width joiner.
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // zwj emojis
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB11 Do not break before or after Word joiner and related characters.
      if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12 Do not break after NBSP and related characters.
      if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB14 Do not break after ‘[’, even after spaces.
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB15 Do not break within ‘”[’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB17 Do not break within ‘——’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB18 Break after spaces.
      if (current === SP) {
          return BREAK_ALLOWED$1;
      }
      // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
      if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB20 Break before and after unresolved CB.
      if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
      }
      // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21a Don't break after Hebrew + Hyphen.
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21b Don’t break between Solidus and Hebrew letters.
      if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB22 Do not break before ellipsis.
      if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23 Do not break between digits and letters.
      if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
      if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
          ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
      if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
          (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB25 Do not break between the following pairs of classes relevant to numbers:
      if (
      // (PR | PO) × ( OP | HY )? NU
      ([PR, PO].indexOf(current) !== -1 &&
          (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
          // ( OP | HY ) × NU
          ([OP, HY].indexOf(current) !== -1 && next === NU) ||
          // NU ×	(NU | SY | IS)
          (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
      if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // LB26 Do not break a Korean syllable.
      if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
          ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
          ([JT, H3].indexOf(current) !== -1 && next === JT)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB27 Treat a Korean Syllable Block the same as ID.
      if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
          (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB28 Do not break between alphabetics (“at”).
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
      if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
          next === OP &&
          ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
          (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
      // indicators preceding the position of the break.
      if (current === RI$1 && next === RI$1) {
          var i = indicies[currentIndex];
          var count = 1;
          while (i > 0) {
              i--;
              if (classTypes[i] === RI$1) {
                  count++;
              }
              else {
                  break;
              }
          }
          if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
          }
      }
      // LB30b Do not break between an emoji base and an emoji modifier.
      if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
  };
  var cssFormattedClasses = function (codePoints, options) {
      if (!options) {
          options = { lineBreak: 'normal', wordBreak: 'normal' };
      }
      var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
      if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
          classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
      }
      var forbiddenBreakpoints = options.wordBreak === 'keep-all'
          ? isLetterNumber.map(function (letterNumber, i) {
              return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
          })
          : undefined;
      return [indicies, classTypes, forbiddenBreakpoints];
  };
  var Break = /** @class */ (function () {
      function Break(codePoints, lineBreak, start, end) {
          this.codePoints = codePoints;
          this.required = lineBreak === BREAK_MANDATORY;
          this.start = start;
          this.end = end;
      }
      Break.prototype.slice = function () {
          return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
      };
      return Break;
  }());
  var LineBreaker = function (str, options) {
      var codePoints = toCodePoints$1(str);
      var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
          next: function () {
              if (nextIndex >= length) {
                  return { done: true, value: null };
              }
              var lineBreak = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length &&
                  (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
                      BREAK_NOT_ALLOWED$1) { }
              if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                  var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                  lastEnd = nextIndex;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };

  // https://www.w3.org/TR/css-syntax-3
  var FLAG_UNRESTRICTED = 1 << 0;
  var FLAG_ID = 1 << 1;
  var FLAG_INTEGER = 1 << 2;
  var FLAG_NUMBER = 1 << 3;
  var LINE_FEED = 0x000a;
  var SOLIDUS = 0x002f;
  var REVERSE_SOLIDUS = 0x005c;
  var CHARACTER_TABULATION = 0x0009;
  var SPACE = 0x0020;
  var QUOTATION_MARK = 0x0022;
  var EQUALS_SIGN = 0x003d;
  var NUMBER_SIGN = 0x0023;
  var DOLLAR_SIGN = 0x0024;
  var PERCENTAGE_SIGN = 0x0025;
  var APOSTROPHE = 0x0027;
  var LEFT_PARENTHESIS = 0x0028;
  var RIGHT_PARENTHESIS = 0x0029;
  var LOW_LINE = 0x005f;
  var HYPHEN_MINUS = 0x002d;
  var EXCLAMATION_MARK = 0x0021;
  var LESS_THAN_SIGN = 0x003c;
  var GREATER_THAN_SIGN = 0x003e;
  var COMMERCIAL_AT = 0x0040;
  var LEFT_SQUARE_BRACKET = 0x005b;
  var RIGHT_SQUARE_BRACKET = 0x005d;
  var CIRCUMFLEX_ACCENT = 0x003d;
  var LEFT_CURLY_BRACKET = 0x007b;
  var QUESTION_MARK = 0x003f;
  var RIGHT_CURLY_BRACKET = 0x007d;
  var VERTICAL_LINE = 0x007c;
  var TILDE = 0x007e;
  var CONTROL = 0x0080;
  var REPLACEMENT_CHARACTER = 0xfffd;
  var ASTERISK = 0x002a;
  var PLUS_SIGN = 0x002b;
  var COMMA = 0x002c;
  var COLON = 0x003a;
  var SEMICOLON = 0x003b;
  var FULL_STOP = 0x002e;
  var NULL = 0x0000;
  var BACKSPACE = 0x0008;
  var LINE_TABULATION = 0x000b;
  var SHIFT_OUT = 0x000e;
  var INFORMATION_SEPARATOR_ONE = 0x001f;
  var DELETE = 0x007f;
  var EOF = -1;
  var ZERO = 0x0030;
  var a$1 = 0x0061;
  var e$1 = 0x0065;
  var f$1 = 0x0066;
  var u$1 = 0x0075;
  var z = 0x007a;
  var A = 0x0041;
  var E = 0x0045;
  var F = 0x0046;
  var U = 0x0055;
  var Z = 0x005a;
  var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
  var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
  var isHex = function (codePoint) {
      return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a$1 && codePoint <= f$1);
  };
  var isLowerCaseLetter = function (codePoint) { return codePoint >= a$1 && codePoint <= z; };
  var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
  var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
  var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
  var isWhiteSpace = function (codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  };
  var isNameStartCodePoint = function (codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  };
  var isNameCodePoint = function (codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  };
  var isNonPrintableCodePoint = function (codePoint) {
      return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
          codePoint === LINE_TABULATION ||
          (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
          codePoint === DELETE);
  };
  var isValidEscape = function (c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
          return false;
      }
      return c2 !== LINE_FEED;
  };
  var isIdentifierStart = function (c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      }
      else if (isNameStartCodePoint(c1)) {
          return true;
      }
      else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
          return true;
      }
      return false;
  };
  var isNumberStart = function (c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c2)) {
              return true;
          }
          return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
          return isDigit(c2);
      }
      return isDigit(c1);
  };
  var stringToNumber = function (codePoints) {
      var c = 0;
      var sign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              sign = -1;
          }
          c++;
      }
      var integers = [];
      while (isDigit(codePoints[c])) {
          integers.push(codePoints[c++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
      if (codePoints[c] === FULL_STOP) {
          c++;
      }
      var fraction = [];
      while (isDigit(codePoints[c])) {
          fraction.push(codePoints[c++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
      if (codePoints[c] === E || codePoints[c] === e$1) {
          c++;
      }
      var expsign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              expsign = -1;
          }
          c++;
      }
      var exponent = [];
      while (isDigit(codePoints[c])) {
          exponent.push(codePoints[c++]);
      }
      var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  };
  var LEFT_PARENTHESIS_TOKEN = {
      type: 2 /* LEFT_PARENTHESIS_TOKEN */
  };
  var RIGHT_PARENTHESIS_TOKEN = {
      type: 3 /* RIGHT_PARENTHESIS_TOKEN */
  };
  var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
  var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
  var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
  var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
  var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
  var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
  var LEFT_CURLY_BRACKET_TOKEN = {
      type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
  };
  var RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
  };
  var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
  var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
  var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
  var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
  var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
  var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
  var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
  var LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
  };
  var RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
  };
  var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
  var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
  var Tokenizer = /** @class */ (function () {
      function Tokenizer() {
          this._value = [];
      }
      Tokenizer.prototype.write = function (chunk) {
          this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer.prototype.read = function () {
          var tokens = [];
          var token = this.consumeToken();
          while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
          }
          return tokens;
      };
      Tokenizer.prototype.consumeToken = function () {
          var codePoint = this.consumeCodePoint();
          switch (codePoint) {
              case QUOTATION_MARK:
                  return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                  var c1 = this.peekCodePoint(0);
                  var c2 = this.peekCodePoint(1);
                  var c3 = this.peekCodePoint(2);
                  if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                      var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                      var value = this.consumeName();
                      return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
                  }
                  break;
              case DOLLAR_SIGN:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUFFIX_MATCH_TOKEN;
                  }
                  break;
              case APOSTROPHE:
                  return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                  return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                  return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUBSTRING_MATCH_TOKEN;
                  }
                  break;
              case PLUS_SIGN:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case COMMA:
                  return COMMA_TOKEN;
              case HYPHEN_MINUS:
                  var e1 = codePoint;
                  var e2 = this.peekCodePoint(0);
                  var e3 = this.peekCodePoint(1);
                  if (isNumberStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  if (isIdentifierStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDC_TOKEN;
                  }
                  break;
              case FULL_STOP:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case SOLIDUS:
                  if (this.peekCodePoint(0) === ASTERISK) {
                      this.consumeCodePoint();
                      while (true) {
                          var c = this.consumeCodePoint();
                          if (c === ASTERISK) {
                              c = this.consumeCodePoint();
                              if (c === SOLIDUS) {
                                  return this.consumeToken();
                              }
                          }
                          if (c === EOF) {
                              return this.consumeToken();
                          }
                      }
                  }
                  break;
              case COLON:
                  return COLON_TOKEN;
              case SEMICOLON:
                  return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                  if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
                      this.peekCodePoint(1) === HYPHEN_MINUS &&
                      this.peekCodePoint(2) === HYPHEN_MINUS) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDO_TOKEN;
                  }
                  break;
              case COMMERCIAL_AT:
                  var a1 = this.peekCodePoint(0);
                  var a2 = this.peekCodePoint(1);
                  var a3 = this.peekCodePoint(2);
                  if (isIdentifierStart(a1, a2, a3)) {
                      var value = this.consumeName();
                      return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
                  }
                  break;
              case LEFT_SQUARE_BRACKET:
                  return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  break;
              case RIGHT_SQUARE_BRACKET:
                  return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return PREFIX_MATCH_TOKEN;
                  }
                  break;
              case LEFT_CURLY_BRACKET:
                  return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                  return RIGHT_CURLY_BRACKET_TOKEN;
              case u$1:
              case U:
                  var u1 = this.peekCodePoint(0);
                  var u2 = this.peekCodePoint(1);
                  if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                      this.consumeCodePoint();
                      this.consumeUnicodeRangeToken();
                  }
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return DASH_MATCH_TOKEN;
                  }
                  if (this.peekCodePoint(0) === VERTICAL_LINE) {
                      this.consumeCodePoint();
                      return COLUMN_TOKEN;
                  }
                  break;
              case TILDE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return INCLUDE_MATCH_TOKEN;
                  }
                  break;
              case EOF:
                  return EOF_TOKEN;
          }
          if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
          }
          if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
          }
          if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
          }
          return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer.prototype.consumeCodePoint = function () {
          var value = this._value.shift();
          return typeof value === 'undefined' ? -1 : value;
      };
      Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
          this._value.unshift(codePoint);
      };
      Tokenizer.prototype.peekCodePoint = function (delta) {
          if (delta >= this._value.length) {
              return -1;
          }
          return this._value[delta];
      };
      Tokenizer.prototype.consumeUnicodeRangeToken = function () {
          var digits = [];
          var codePoint = this.consumeCodePoint();
          while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
          }
          var questionMarks = false;
          while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
          }
          if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
          }
          var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
          if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                  endDigits.push(codePoint);
                  codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
          }
          else {
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
          }
      };
      Tokenizer.prototype.consumeIdentLikeToken = function () {
          var value = this.consumeName();
          if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
          }
          else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19 /* FUNCTION_TOKEN */, value: value };
          }
          return { type: 20 /* IDENT_TOKEN */, value: value };
      };
      Tokenizer.prototype.consumeUrlToken = function () {
          var value = [];
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF) {
              return { type: 22 /* URL_TOKEN */, value: '' };
          }
          var next = this.peekCodePoint(0);
          if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0 /* STRING_TOKEN */) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: stringToken.value };
                  }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
          }
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                  return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
              }
              else if (isWhiteSpace(codePoint)) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
                  }
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === QUOTATION_MARK ||
                  codePoint === APOSTROPHE ||
                  codePoint === LEFT_PARENTHESIS ||
                  isNonPrintableCodePoint(codePoint)) {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === REVERSE_SOLIDUS) {
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      value.push(this.consumeEscapedCodePoint());
                  }
                  else {
                      this.consumeBadUrlRemnants();
                      return BAD_URL_TOKEN;
                  }
              }
              else {
                  value.push(codePoint);
              }
          }
      };
      Tokenizer.prototype.consumeWhiteSpace = function () {
          while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
          }
      };
      Tokenizer.prototype.consumeBadUrlRemnants = function () {
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                  return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.consumeEscapedCodePoint();
              }
          }
      };
      Tokenizer.prototype.consumeStringSlice = function (count) {
          var SLICE_STACK_SIZE = 50000;
          var value = '';
          while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
          }
          this._value.shift();
          return value;
      };
      Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
          var value = '';
          var i = 0;
          do {
              var codePoint = this._value[i];
              if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
                  value += this.consumeStringSlice(i);
                  return { type: 0 /* STRING_TOKEN */, value: value };
              }
              if (codePoint === LINE_FEED) {
                  this._value.splice(0, i);
                  return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                  var next = this._value[i + 1];
                  if (next !== EOF && next !== undefined) {
                      if (next === LINE_FEED) {
                          value += this.consumeStringSlice(i);
                          i = -1;
                          this._value.shift();
                      }
                      else if (isValidEscape(codePoint, next)) {
                          value += this.consumeStringSlice(i);
                          value += fromCodePoint$1(this.consumeEscapedCodePoint());
                          i = -1;
                      }
                  }
              }
              i++;
          } while (true);
      };
      Tokenizer.prototype.consumeNumber = function () {
          var repr = [];
          var type = FLAG_INTEGER;
          var c1 = this.peekCodePoint(0);
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
          }
          while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
          }
          c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          c1 = this.peekCodePoint(0);
          c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if ((c1 === E || c1 === e$1) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          return [stringToNumber(repr), type];
      };
      Tokenizer.prototype.consumeNumericToken = function () {
          var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
          }
          if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
          }
          return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
      };
      Tokenizer.prototype.consumeEscapedCodePoint = function () {
          var codePoint = this.consumeCodePoint();
          if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                  hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                  this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
                  return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
          }
          if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
          }
          return codePoint;
      };
      Tokenizer.prototype.consumeName = function () {
          var result = '';
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                  result += fromCodePoint$1(codePoint);
              }
              else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  result += fromCodePoint$1(this.consumeEscapedCodePoint());
              }
              else {
                  this.reconsumeCodePoint(codePoint);
                  return result;
              }
          }
      };
      return Tokenizer;
  }());

  var Parser$1 = /** @class */ (function () {
      function Parser(tokens) {
          this._tokens = tokens;
      }
      Parser.create = function (value) {
          var tokenizer = new Tokenizer();
          tokenizer.write(value);
          return new Parser(tokenizer.read());
      };
      Parser.parseValue = function (value) {
          return Parser.create(value).parseComponentValue();
      };
      Parser.parseValues = function (value) {
          return Parser.create(value).parseComponentValues();
      };
      Parser.prototype.parseComponentValue = function () {
          var token = this.consumeToken();
          while (token.type === 31 /* WHITESPACE_TOKEN */) {
              token = this.consumeToken();
          }
          if (token.type === 32 /* EOF_TOKEN */) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
          }
          this.reconsumeToken(token);
          var value = this.consumeComponentValue();
          do {
              token = this.consumeToken();
          } while (token.type === 31 /* WHITESPACE_TOKEN */);
          if (token.type === 32 /* EOF_TOKEN */) {
              return value;
          }
          throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser.prototype.parseComponentValues = function () {
          var values = [];
          while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32 /* EOF_TOKEN */) {
                  return values;
              }
              values.push(value);
              values.push();
          }
      };
      Parser.prototype.consumeComponentValue = function () {
          var token = this.consumeToken();
          switch (token.type) {
              case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
              case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
              case 2 /* LEFT_PARENTHESIS_TOKEN */:
                  return this.consumeSimpleBlock(token.type);
              case 19 /* FUNCTION_TOKEN */:
                  return this.consumeFunction(token);
          }
          return token;
      };
      Parser.prototype.consumeSimpleBlock = function (type) {
          var block = { type: type, values: [] };
          var token = this.consumeToken();
          while (true) {
              if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
                  return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
          }
      };
      Parser.prototype.consumeFunction = function (functionToken) {
          var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18 /* FUNCTION */
          };
          while (true) {
              var token = this.consumeToken();
              if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
                  return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
          }
      };
      Parser.prototype.consumeToken = function () {
          var token = this._tokens.shift();
          return typeof token === 'undefined' ? EOF_TOKEN : token;
      };
      Parser.prototype.reconsumeToken = function (token) {
          this._tokens.unshift(token);
      };
      return Parser;
  }());
  var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
  var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
  var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
  var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
  var isIdentWithValue = function (token, value) {
      return isIdentToken(token) && token.value === value;
  };
  var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
  var nonFunctionArgSeparator = function (token) {
      return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
  };
  var parseFunctionArgs = function (tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function (token) {
          if (token.type === 4 /* COMMA_TOKEN */) {
              if (arg.length === 0) {
                  throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
          }
          if (token.type !== 31 /* WHITESPACE_TOKEN */) {
              arg.push(token);
          }
      });
      if (arg.length) {
          args.push(arg);
      }
      return args;
  };
  var isEndingTokenFor = function (token, type) {
      if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
          return true;
      }
      if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
          return true;
      }
      return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
  };

  var isLength = function (token) {
      return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
  };

  var isLengthPercentage = function (token) {
      return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
  };
  var parseLengthPercentageTuple = function (tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  };
  var ZERO_LENGTH = {
      type: 17 /* NUMBER_TOKEN */,
      number: 0,
      flags: FLAG_INTEGER
  };
  var FIFTY_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var HUNDRED_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 100,
      flags: FLAG_INTEGER
  };
  var getAbsoluteValueForTuple = function (tuple, width, height) {
      var x = tuple[0], y = tuple[1];
      return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
  };
  var getAbsoluteValue = function (token, parent) {
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          return (token.number / 100) * parent;
      }
      if (isDimensionToken(token)) {
          switch (token.unit) {
              case 'rem':
              case 'em':
                  return 16 * token.number; // TODO use correct font-size
              case 'px':
              default:
                  return token.number;
          }
      }
      return token.number;
  };

  var DEG = 'deg';
  var GRAD = 'grad';
  var RAD = 'rad';
  var TURN = 'turn';
  var angle = {
      name: 'angle',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit) {
                  case DEG:
                      return (Math.PI * value.number) / 180;
                  case GRAD:
                      return (Math.PI / 200) * value.number;
                  case RAD:
                      return value.number;
                  case TURN:
                      return Math.PI * 2 * value.number;
              }
          }
          throw new Error("Unsupported angle type");
      }
  };
  var isAngle = function (value) {
      if (value.type === 15 /* DIMENSION_TOKEN */) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
          }
      }
      return false;
  };
  var parseNamedSide = function (tokens) {
      var sideOrCorner = tokens
          .filter(isIdentToken)
          .map(function (ident) { return ident.value; })
          .join(' ');
      switch (sideOrCorner) {
          case 'to bottom right':
          case 'to right bottom':
          case 'left top':
          case 'top left':
              return [ZERO_LENGTH, ZERO_LENGTH];
          case 'to top':
          case 'bottom':
              return deg(0);
          case 'to bottom left':
          case 'to left bottom':
          case 'right top':
          case 'top right':
              return [ZERO_LENGTH, HUNDRED_PERCENT];
          case 'to right':
          case 'left':
              return deg(90);
          case 'to top left':
          case 'to left top':
          case 'right bottom':
          case 'bottom right':
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case 'to bottom':
          case 'top':
              return deg(180);
          case 'to top right':
          case 'to right top':
          case 'left bottom':
          case 'bottom left':
              return [HUNDRED_PERCENT, ZERO_LENGTH];
          case 'to left':
          case 'right':
              return deg(270);
      }
      return 0;
  };
  var deg = function (deg) { return (Math.PI * deg) / 180; };

  var color$1 = {
      name: 'color',
      parse: function (context, value) {
          if (value.type === 18 /* FUNCTION */) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
              }
              return colorFunction(context, value.values);
          }
          if (value.type === 5 /* HASH_TOKEN */) {
              if (value.value.length === 3) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
              }
              if (value.value.length === 4) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  var a = value.value.substring(3, 4);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
              }
              if (value.value.length === 6) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
              }
              if (value.value.length === 8) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  var a = value.value.substring(6, 8);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
              }
          }
          if (value.type === 20 /* IDENT_TOKEN */) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== 'undefined') {
                  return namedColor;
              }
          }
          return COLORS.TRANSPARENT;
      }
  };
  var isTransparent = function (color) { return (0xff & color) === 0; };
  var asString = function (color) {
      var alpha = 0xff & color;
      var blue = 0xff & (color >> 8);
      var green = 0xff & (color >> 16);
      var red = 0xff & (color >> 24);
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  };
  var pack = function (r, g, b, a) {
      return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
  };
  var getTokenColorValue = function (token, i) {
      if (token.type === 17 /* NUMBER_TOKEN */) {
          return token.number;
      }
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          var max = i === 3 ? 1 : 255;
          return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
      }
      return 0;
  };
  var rgb = function (_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
          var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
          return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
          var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
          return pack(r, g, b, a);
      }
      return 0;
  };
  function hue2rgb(t1, t2, hue) {
      if (hue < 0) {
          hue += 1;
      }
      if (hue >= 1) {
          hue -= 1;
      }
      if (hue < 1 / 6) {
          return (t2 - t1) * hue * 6 + t1;
      }
      else if (hue < 1 / 2) {
          return t2;
      }
      else if (hue < 2 / 3) {
          return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
      }
      else {
          return t1;
      }
  }
  var hsl = function (context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
          return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h + 1 / 3);
      var g = hue2rgb(t1, t2, h);
      var b = hue2rgb(t1, t2, h - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a);
  };
  var SUPPORTED_COLOR_FUNCTIONS = {
      hsl: hsl,
      hsla: hsl,
      rgb: rgb,
      rgba: rgb
  };
  var parseColor = function (context, value) {
      return color$1.parse(context, Parser$1.create(value).parseComponentValue());
  };
  var COLORS = {
      ALICEBLUE: 0xf0f8ffff,
      ANTIQUEWHITE: 0xfaebd7ff,
      AQUA: 0x00ffffff,
      AQUAMARINE: 0x7fffd4ff,
      AZURE: 0xf0ffffff,
      BEIGE: 0xf5f5dcff,
      BISQUE: 0xffe4c4ff,
      BLACK: 0x000000ff,
      BLANCHEDALMOND: 0xffebcdff,
      BLUE: 0x0000ffff,
      BLUEVIOLET: 0x8a2be2ff,
      BROWN: 0xa52a2aff,
      BURLYWOOD: 0xdeb887ff,
      CADETBLUE: 0x5f9ea0ff,
      CHARTREUSE: 0x7fff00ff,
      CHOCOLATE: 0xd2691eff,
      CORAL: 0xff7f50ff,
      CORNFLOWERBLUE: 0x6495edff,
      CORNSILK: 0xfff8dcff,
      CRIMSON: 0xdc143cff,
      CYAN: 0x00ffffff,
      DARKBLUE: 0x00008bff,
      DARKCYAN: 0x008b8bff,
      DARKGOLDENROD: 0xb886bbff,
      DARKGRAY: 0xa9a9a9ff,
      DARKGREEN: 0x006400ff,
      DARKGREY: 0xa9a9a9ff,
      DARKKHAKI: 0xbdb76bff,
      DARKMAGENTA: 0x8b008bff,
      DARKOLIVEGREEN: 0x556b2fff,
      DARKORANGE: 0xff8c00ff,
      DARKORCHID: 0x9932ccff,
      DARKRED: 0x8b0000ff,
      DARKSALMON: 0xe9967aff,
      DARKSEAGREEN: 0x8fbc8fff,
      DARKSLATEBLUE: 0x483d8bff,
      DARKSLATEGRAY: 0x2f4f4fff,
      DARKSLATEGREY: 0x2f4f4fff,
      DARKTURQUOISE: 0x00ced1ff,
      DARKVIOLET: 0x9400d3ff,
      DEEPPINK: 0xff1493ff,
      DEEPSKYBLUE: 0x00bfffff,
      DIMGRAY: 0x696969ff,
      DIMGREY: 0x696969ff,
      DODGERBLUE: 0x1e90ffff,
      FIREBRICK: 0xb22222ff,
      FLORALWHITE: 0xfffaf0ff,
      FORESTGREEN: 0x228b22ff,
      FUCHSIA: 0xff00ffff,
      GAINSBORO: 0xdcdcdcff,
      GHOSTWHITE: 0xf8f8ffff,
      GOLD: 0xffd700ff,
      GOLDENROD: 0xdaa520ff,
      GRAY: 0x808080ff,
      GREEN: 0x008000ff,
      GREENYELLOW: 0xadff2fff,
      GREY: 0x808080ff,
      HONEYDEW: 0xf0fff0ff,
      HOTPINK: 0xff69b4ff,
      INDIANRED: 0xcd5c5cff,
      INDIGO: 0x4b0082ff,
      IVORY: 0xfffff0ff,
      KHAKI: 0xf0e68cff,
      LAVENDER: 0xe6e6faff,
      LAVENDERBLUSH: 0xfff0f5ff,
      LAWNGREEN: 0x7cfc00ff,
      LEMONCHIFFON: 0xfffacdff,
      LIGHTBLUE: 0xadd8e6ff,
      LIGHTCORAL: 0xf08080ff,
      LIGHTCYAN: 0xe0ffffff,
      LIGHTGOLDENRODYELLOW: 0xfafad2ff,
      LIGHTGRAY: 0xd3d3d3ff,
      LIGHTGREEN: 0x90ee90ff,
      LIGHTGREY: 0xd3d3d3ff,
      LIGHTPINK: 0xffb6c1ff,
      LIGHTSALMON: 0xffa07aff,
      LIGHTSEAGREEN: 0x20b2aaff,
      LIGHTSKYBLUE: 0x87cefaff,
      LIGHTSLATEGRAY: 0x778899ff,
      LIGHTSLATEGREY: 0x778899ff,
      LIGHTSTEELBLUE: 0xb0c4deff,
      LIGHTYELLOW: 0xffffe0ff,
      LIME: 0x00ff00ff,
      LIMEGREEN: 0x32cd32ff,
      LINEN: 0xfaf0e6ff,
      MAGENTA: 0xff00ffff,
      MAROON: 0x800000ff,
      MEDIUMAQUAMARINE: 0x66cdaaff,
      MEDIUMBLUE: 0x0000cdff,
      MEDIUMORCHID: 0xba55d3ff,
      MEDIUMPURPLE: 0x9370dbff,
      MEDIUMSEAGREEN: 0x3cb371ff,
      MEDIUMSLATEBLUE: 0x7b68eeff,
      MEDIUMSPRINGGREEN: 0x00fa9aff,
      MEDIUMTURQUOISE: 0x48d1ccff,
      MEDIUMVIOLETRED: 0xc71585ff,
      MIDNIGHTBLUE: 0x191970ff,
      MINTCREAM: 0xf5fffaff,
      MISTYROSE: 0xffe4e1ff,
      MOCCASIN: 0xffe4b5ff,
      NAVAJOWHITE: 0xffdeadff,
      NAVY: 0x000080ff,
      OLDLACE: 0xfdf5e6ff,
      OLIVE: 0x808000ff,
      OLIVEDRAB: 0x6b8e23ff,
      ORANGE: 0xffa500ff,
      ORANGERED: 0xff4500ff,
      ORCHID: 0xda70d6ff,
      PALEGOLDENROD: 0xeee8aaff,
      PALEGREEN: 0x98fb98ff,
      PALETURQUOISE: 0xafeeeeff,
      PALEVIOLETRED: 0xdb7093ff,
      PAPAYAWHIP: 0xffefd5ff,
      PEACHPUFF: 0xffdab9ff,
      PERU: 0xcd853fff,
      PINK: 0xffc0cbff,
      PLUM: 0xdda0ddff,
      POWDERBLUE: 0xb0e0e6ff,
      PURPLE: 0x800080ff,
      REBECCAPURPLE: 0x663399ff,
      RED: 0xff0000ff,
      ROSYBROWN: 0xbc8f8fff,
      ROYALBLUE: 0x4169e1ff,
      SADDLEBROWN: 0x8b4513ff,
      SALMON: 0xfa8072ff,
      SANDYBROWN: 0xf4a460ff,
      SEAGREEN: 0x2e8b57ff,
      SEASHELL: 0xfff5eeff,
      SIENNA: 0xa0522dff,
      SILVER: 0xc0c0c0ff,
      SKYBLUE: 0x87ceebff,
      SLATEBLUE: 0x6a5acdff,
      SLATEGRAY: 0x708090ff,
      SLATEGREY: 0x708090ff,
      SNOW: 0xfffafaff,
      SPRINGGREEN: 0x00ff7fff,
      STEELBLUE: 0x4682b4ff,
      TAN: 0xd2b48cff,
      TEAL: 0x008080ff,
      THISTLE: 0xd8bfd8ff,
      TOMATO: 0xff6347ff,
      TRANSPARENT: 0x00000000,
      TURQUOISE: 0x40e0d0ff,
      VIOLET: 0xee82eeff,
      WHEAT: 0xf5deb3ff,
      WHITE: 0xffffffff,
      WHITESMOKE: 0xf5f5f5ff,
      YELLOW: 0xffff00ff,
      YELLOWGREEN: 0x9acd32ff
  };

  var backgroundClip = {
      name: 'background-clip',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundColor = {
      name: "background-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var parseColorStop = function (context, args) {
      var color = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
  };
  var processColorStops = function (stops, lineLength) {
      var first = stops[0];
      var last = stops[stops.length - 1];
      if (first.stop === null) {
          first.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i = 0; i < stops.length; i++) {
          var stop_1 = stops[i].stop;
          if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                  processStops.push(absoluteValue);
              }
              else {
                  processStops.push(previous);
              }
              previous = absoluteValue;
          }
          else {
              processStops.push(null);
          }
      }
      var gapBegin = null;
      for (var i = 0; i < processStops.length; i++) {
          var stop_2 = processStops[i];
          if (stop_2 === null) {
              if (gapBegin === null) {
                  gapBegin = i;
              }
          }
          else if (gapBegin !== null) {
              var gapLength = i - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g = 1; g <= gapLength; g++) {
                  processStops[gapBegin + g - 1] = gapValue * g;
              }
              gapBegin = null;
          }
      }
      return stops.map(function (_a, i) {
          var color = _a.color;
          return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
      });
  };
  var getAngleFromCorner = function (corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x = getAbsoluteValue(corner[0], width) - centerX;
      var y = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
  };
  var calculateGradientDirection = function (angle, width, height) {
      var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  };
  var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
  var findCorner = function (width, height, x, y, closest) {
      var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
      ];
      return corners.reduce(function (stat, corner) {
          var cx = corner[0], cy = corner[1];
          var d = distance(x - cx, y - cy);
          if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
              return {
                  optimumCorner: corner,
                  optimumDistance: d
              };
          }
          return stat;
      }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
      }).optimumCorner;
  };
  var calculateRadius = function (gradient, x, y, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
          case 0 /* CLOSEST_SIDE */:
              // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, it exactly meets the closest side in each dimension.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.min(Math.abs(x), Math.abs(x - width));
                  ry = Math.min(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 2 /* CLOSEST_CORNER */:
              // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                  var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                  var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
          case 1 /* FARTHEST_SIDE */:
              // Same as closest-side, except the ending shape is sized based on the farthest side(s)
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.max(Math.abs(x), Math.abs(x - width));
                  ry = Math.max(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 3 /* FARTHEST_CORNER */:
              // Same as closest-corner, except the ending shape is sized based on the farthest corner.
              // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                  var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                  var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
      }
      if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
  };

  var linearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = angle.parse(context, firstToken);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
  };

  var prefixLinearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ &&
                  ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return {
          angle: angle$1,
          stops: stops,
          type: 1 /* LINEAR_GRADIENT */
      };
  };

  var webkitGradient = function (context, tokens) {
      var angle = deg(180);
      var stops = [];
      var type = 1 /* LINEAR_GRADIENT */;
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var firstToken = arg[0];
          if (i === 0) {
              if (isIdentToken(firstToken) && firstToken.value === 'linear') {
                  type = 1 /* LINEAR_GRADIENT */;
                  return;
              }
              else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
                  type = 2 /* RADIAL_GRADIENT */;
                  return;
              }
          }
          if (firstToken.type === 18 /* FUNCTION */) {
              if (firstToken.name === 'from') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: ZERO_LENGTH, color: color });
              }
              else if (firstToken.name === 'to') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: HUNDRED_PERCENT, color: color });
              }
              else if (firstToken.name === 'color-stop') {
                  var values = firstToken.values.filter(nonFunctionArgSeparator);
                  if (values.length === 2) {
                      var color = color$1.parse(context, values[1]);
                      var stop_1 = values[0];
                      if (isNumberToken(stop_1)) {
                          stops.push({
                              stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
                              color: color
                          });
                      }
                  }
              }
          }
      });
      return type === 1 /* LINEAR_GRADIENT */
          ? {
              angle: (angle + deg(180)) % deg(360),
              stops: stops,
              type: type
          }
          : { size: size, shape: shape, stops: stops, position: position, type: type };
  };

  var CLOSEST_SIDE = 'closest-side';
  var FARTHEST_SIDE = 'farthest-side';
  var CLOSEST_CORNER = 'closest-corner';
  var FARTHEST_CORNER = 'farthest-corner';
  var CIRCLE = 'circle';
  var ELLIPSE = 'ellipse';
  var COVER = 'cover';
  var CONTAIN = 'contain';
  var radialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function (acc, token) {
                  if (isAtPosition_1) {
                      if (isIdentToken(token)) {
                          switch (token.value) {
                              case 'center':
                                  position.push(FIFTY_PERCENT);
                                  return acc;
                              case 'top':
                              case 'left':
                                  position.push(ZERO_LENGTH);
                                  return acc;
                              case 'right':
                              case 'bottom':
                                  position.push(HUNDRED_PERCENT);
                                  return acc;
                          }
                      }
                      else if (isLengthPercentage(token) || isLength(token)) {
                          position.push(token);
                      }
                  }
                  else if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case 'at':
                              isAtPosition_1 = true;
                              return false;
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case COVER:
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var prefixRadialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case 'center':
                              position.push(FIFTY_PERCENT);
                              return false;
                          case 'top':
                          case 'left':
                              position.push(ZERO_LENGTH);
                              return false;
                          case 'right':
                          case 'bottom':
                              position.push(HUNDRED_PERCENT);
                              return false;
                      }
                  }
                  else if (isLengthPercentage(token) || isLength(token)) {
                      position.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          else if (i === 1) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case COVER:
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var isLinearGradient = function (background) {
      return background.type === 1 /* LINEAR_GRADIENT */;
  };
  var isRadialGradient = function (background) {
      return background.type === 2 /* RADIAL_GRADIENT */;
  };
  var image = {
      name: 'image',
      parse: function (context, value) {
          if (value.type === 22 /* URL_TOKEN */) {
              var image_1 = { url: value.value, type: 0 /* URL */ };
              context.cache.addImage(value.value);
              return image_1;
          }
          if (value.type === 18 /* FUNCTION */) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
              }
              return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
      }
  };
  function isSupportedImage(value) {
      return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
          (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
  }
  var SUPPORTED_IMAGE_FUNCTIONS = {
      'linear-gradient': linearGradient,
      '-moz-linear-gradient': prefixLinearGradient,
      '-ms-linear-gradient': prefixLinearGradient,
      '-o-linear-gradient': prefixLinearGradient,
      '-webkit-linear-gradient': prefixLinearGradient,
      'radial-gradient': radialGradient,
      '-moz-radial-gradient': prefixRadialGradient,
      '-ms-radial-gradient': prefixRadialGradient,
      '-o-radial-gradient': prefixRadialGradient,
      '-webkit-radial-gradient': prefixRadialGradient,
      '-webkit-gradient': webkitGradient
  };

  var backgroundImage = {
      name: 'background-image',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens
              .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
              .map(function (value) { return image.parse(context, value); });
      }
  };

  var backgroundOrigin = {
      name: 'background-origin',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundPosition = {
      name: 'background-position',
      initialValue: '0% 0%',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) { return values.filter(isLengthPercentage); })
              .map(parseLengthPercentageTuple);
      }
  };

  var backgroundRepeat = {
      name: 'background-repeat',
      initialValue: 'repeat',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) {
              return values
                  .filter(isIdentToken)
                  .map(function (token) { return token.value; })
                  .join(' ');
          })
              .map(parseBackgroundRepeat);
      }
  };
  var parseBackgroundRepeat = function (value) {
      switch (value) {
          case 'no-repeat':
              return 1 /* NO_REPEAT */;
          case 'repeat-x':
          case 'repeat no-repeat':
              return 2 /* REPEAT_X */;
          case 'repeat-y':
          case 'no-repeat repeat':
              return 3 /* REPEAT_Y */;
          case 'repeat':
          default:
              return 0 /* REPEAT */;
      }
  };

  var BACKGROUND_SIZE;
  (function (BACKGROUND_SIZE) {
      BACKGROUND_SIZE["AUTO"] = "auto";
      BACKGROUND_SIZE["CONTAIN"] = "contain";
      BACKGROUND_SIZE["COVER"] = "cover";
  })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  var backgroundSize = {
      name: 'background-size',
      initialValue: '0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
      }
  };
  var isBackgroundSizeInfoToken = function (value) {
      return isIdentToken(value) || isLengthPercentage(value);
  };

  var borderColorForSide = function (side) { return ({
      name: "border-" + side + "-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  }); };
  var borderTopColor = borderColorForSide('top');
  var borderRightColor = borderColorForSide('right');
  var borderBottomColor = borderColorForSide('bottom');
  var borderLeftColor = borderColorForSide('left');

  var borderRadiusForSide = function (side) { return ({
      name: "border-radius-" + side,
      initialValue: '0 0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
      }
  }); };
  var borderTopLeftRadius = borderRadiusForSide('top-left');
  var borderTopRightRadius = borderRadiusForSide('top-right');
  var borderBottomRightRadius = borderRadiusForSide('bottom-right');
  var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

  var borderStyleForSide = function (side) { return ({
      name: "border-" + side + "-style",
      initialValue: 'solid',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, style) {
          switch (style) {
              case 'none':
                  return 0 /* NONE */;
              case 'dashed':
                  return 2 /* DASHED */;
              case 'dotted':
                  return 3 /* DOTTED */;
              case 'double':
                  return 4 /* DOUBLE */;
          }
          return 1 /* SOLID */;
      }
  }); };
  var borderTopStyle = borderStyleForSide('top');
  var borderRightStyle = borderStyleForSide('right');
  var borderBottomStyle = borderStyleForSide('bottom');
  var borderLeftStyle = borderStyleForSide('left');

  var borderWidthForSide = function (side) { return ({
      name: "border-" + side + "-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  }); };
  var borderTopWidth = borderWidthForSide('top');
  var borderRightWidth = borderWidthForSide('right');
  var borderBottomWidth = borderWidthForSide('bottom');
  var borderLeftWidth = borderWidthForSide('left');

  var color = {
      name: "color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var direction = {
      name: 'direction',
      initialValue: 'ltr',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, direction) {
          switch (direction) {
              case 'rtl':
                  return 1 /* RTL */;
              case 'ltr':
              default:
                  return 0 /* LTR */;
          }
      }
  };

  var display = {
      name: 'display',
      initialValue: 'inline-block',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).reduce(function (bit, token) {
              return bit | parseDisplayValue(token.value);
          }, 0 /* NONE */);
      }
  };
  var parseDisplayValue = function (display) {
      switch (display) {
          case 'block':
          case '-webkit-box':
              return 2 /* BLOCK */;
          case 'inline':
              return 4 /* INLINE */;
          case 'run-in':
              return 8 /* RUN_IN */;
          case 'flow':
              return 16 /* FLOW */;
          case 'flow-root':
              return 32 /* FLOW_ROOT */;
          case 'table':
              return 64 /* TABLE */;
          case 'flex':
          case '-webkit-flex':
              return 128 /* FLEX */;
          case 'grid':
          case '-ms-grid':
              return 256 /* GRID */;
          case 'ruby':
              return 512 /* RUBY */;
          case 'subgrid':
              return 1024 /* SUBGRID */;
          case 'list-item':
              return 2048 /* LIST_ITEM */;
          case 'table-row-group':
              return 4096 /* TABLE_ROW_GROUP */;
          case 'table-header-group':
              return 8192 /* TABLE_HEADER_GROUP */;
          case 'table-footer-group':
              return 16384 /* TABLE_FOOTER_GROUP */;
          case 'table-row':
              return 32768 /* TABLE_ROW */;
          case 'table-cell':
              return 65536 /* TABLE_CELL */;
          case 'table-column-group':
              return 131072 /* TABLE_COLUMN_GROUP */;
          case 'table-column':
              return 262144 /* TABLE_COLUMN */;
          case 'table-caption':
              return 524288 /* TABLE_CAPTION */;
          case 'ruby-base':
              return 1048576 /* RUBY_BASE */;
          case 'ruby-text':
              return 2097152 /* RUBY_TEXT */;
          case 'ruby-base-container':
              return 4194304 /* RUBY_BASE_CONTAINER */;
          case 'ruby-text-container':
              return 8388608 /* RUBY_TEXT_CONTAINER */;
          case 'contents':
              return 16777216 /* CONTENTS */;
          case 'inline-block':
              return 33554432 /* INLINE_BLOCK */;
          case 'inline-list-item':
              return 67108864 /* INLINE_LIST_ITEM */;
          case 'inline-table':
              return 134217728 /* INLINE_TABLE */;
          case 'inline-flex':
              return 268435456 /* INLINE_FLEX */;
          case 'inline-grid':
              return 536870912 /* INLINE_GRID */;
      }
      return 0 /* NONE */;
  };

  var float = {
      name: 'float',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, float) {
          switch (float) {
              case 'left':
                  return 1 /* LEFT */;
              case 'right':
                  return 2 /* RIGHT */;
              case 'inline-start':
                  return 3 /* INLINE_START */;
              case 'inline-end':
                  return 4 /* INLINE_END */;
          }
          return 0 /* NONE */;
      }
  };

  var letterSpacing = {
      name: 'letter-spacing',
      initialValue: '0',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
              return 0;
          }
          if (token.type === 17 /* NUMBER_TOKEN */) {
              return token.number;
          }
          if (token.type === 15 /* DIMENSION_TOKEN */) {
              return token.number;
          }
          return 0;
      }
  };

  var LINE_BREAK;
  (function (LINE_BREAK) {
      LINE_BREAK["NORMAL"] = "normal";
      LINE_BREAK["STRICT"] = "strict";
  })(LINE_BREAK || (LINE_BREAK = {}));
  var lineBreak = {
      name: 'line-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, lineBreak) {
          switch (lineBreak) {
              case 'strict':
                  return LINE_BREAK.STRICT;
              case 'normal':
              default:
                  return LINE_BREAK.NORMAL;
          }
      }
  };

  var lineHeight = {
      name: 'line-height',
      initialValue: 'normal',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  };
  var computeLineHeight = function (token, fontSize) {
      if (isIdentToken(token) && token.value === 'normal') {
          return 1.2 * fontSize;
      }
      else if (token.type === 17 /* NUMBER_TOKEN */) {
          return fontSize * token.number;
      }
      else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize);
      }
      return fontSize;
  };

  var listStyleImage = {
      name: 'list-style-image',
      initialValue: 'none',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          return image.parse(context, token);
      }
  };

  var listStylePosition = {
      name: 'list-style-position',
      initialValue: 'outside',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'inside':
                  return 0 /* INSIDE */;
              case 'outside':
              default:
                  return 1 /* OUTSIDE */;
          }
      }
  };

  var listStyleType = {
      name: 'list-style-type',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, type) {
          switch (type) {
              case 'disc':
                  return 0 /* DISC */;
              case 'circle':
                  return 1 /* CIRCLE */;
              case 'square':
                  return 2 /* SQUARE */;
              case 'decimal':
                  return 3 /* DECIMAL */;
              case 'cjk-decimal':
                  return 4 /* CJK_DECIMAL */;
              case 'decimal-leading-zero':
                  return 5 /* DECIMAL_LEADING_ZERO */;
              case 'lower-roman':
                  return 6 /* LOWER_ROMAN */;
              case 'upper-roman':
                  return 7 /* UPPER_ROMAN */;
              case 'lower-greek':
                  return 8 /* LOWER_GREEK */;
              case 'lower-alpha':
                  return 9 /* LOWER_ALPHA */;
              case 'upper-alpha':
                  return 10 /* UPPER_ALPHA */;
              case 'arabic-indic':
                  return 11 /* ARABIC_INDIC */;
              case 'armenian':
                  return 12 /* ARMENIAN */;
              case 'bengali':
                  return 13 /* BENGALI */;
              case 'cambodian':
                  return 14 /* CAMBODIAN */;
              case 'cjk-earthly-branch':
                  return 15 /* CJK_EARTHLY_BRANCH */;
              case 'cjk-heavenly-stem':
                  return 16 /* CJK_HEAVENLY_STEM */;
              case 'cjk-ideographic':
                  return 17 /* CJK_IDEOGRAPHIC */;
              case 'devanagari':
                  return 18 /* DEVANAGARI */;
              case 'ethiopic-numeric':
                  return 19 /* ETHIOPIC_NUMERIC */;
              case 'georgian':
                  return 20 /* GEORGIAN */;
              case 'gujarati':
                  return 21 /* GUJARATI */;
              case 'gurmukhi':
                  return 22 /* GURMUKHI */;
              case 'hebrew':
                  return 22 /* HEBREW */;
              case 'hiragana':
                  return 23 /* HIRAGANA */;
              case 'hiragana-iroha':
                  return 24 /* HIRAGANA_IROHA */;
              case 'japanese-formal':
                  return 25 /* JAPANESE_FORMAL */;
              case 'japanese-informal':
                  return 26 /* JAPANESE_INFORMAL */;
              case 'kannada':
                  return 27 /* KANNADA */;
              case 'katakana':
                  return 28 /* KATAKANA */;
              case 'katakana-iroha':
                  return 29 /* KATAKANA_IROHA */;
              case 'khmer':
                  return 30 /* KHMER */;
              case 'korean-hangul-formal':
                  return 31 /* KOREAN_HANGUL_FORMAL */;
              case 'korean-hanja-formal':
                  return 32 /* KOREAN_HANJA_FORMAL */;
              case 'korean-hanja-informal':
                  return 33 /* KOREAN_HANJA_INFORMAL */;
              case 'lao':
                  return 34 /* LAO */;
              case 'lower-armenian':
                  return 35 /* LOWER_ARMENIAN */;
              case 'malayalam':
                  return 36 /* MALAYALAM */;
              case 'mongolian':
                  return 37 /* MONGOLIAN */;
              case 'myanmar':
                  return 38 /* MYANMAR */;
              case 'oriya':
                  return 39 /* ORIYA */;
              case 'persian':
                  return 40 /* PERSIAN */;
              case 'simp-chinese-formal':
                  return 41 /* SIMP_CHINESE_FORMAL */;
              case 'simp-chinese-informal':
                  return 42 /* SIMP_CHINESE_INFORMAL */;
              case 'tamil':
                  return 43 /* TAMIL */;
              case 'telugu':
                  return 44 /* TELUGU */;
              case 'thai':
                  return 45 /* THAI */;
              case 'tibetan':
                  return 46 /* TIBETAN */;
              case 'trad-chinese-formal':
                  return 47 /* TRAD_CHINESE_FORMAL */;
              case 'trad-chinese-informal':
                  return 48 /* TRAD_CHINESE_INFORMAL */;
              case 'upper-armenian':
                  return 49 /* UPPER_ARMENIAN */;
              case 'disclosure-open':
                  return 50 /* DISCLOSURE_OPEN */;
              case 'disclosure-closed':
                  return 51 /* DISCLOSURE_CLOSED */;
              case 'none':
              default:
                  return -1 /* NONE */;
          }
      }
  };

  var marginForSide = function (side) { return ({
      name: "margin-" + side,
      initialValue: '0',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  }); };
  var marginTop = marginForSide('top');
  var marginRight = marginForSide('right');
  var marginBottom = marginForSide('bottom');
  var marginLeft = marginForSide('left');

  var overflow = {
      name: 'overflow',
      initialValue: 'visible',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (overflow) {
              switch (overflow.value) {
                  case 'hidden':
                      return 1 /* HIDDEN */;
                  case 'scroll':
                      return 2 /* SCROLL */;
                  case 'clip':
                      return 3 /* CLIP */;
                  case 'auto':
                      return 4 /* AUTO */;
                  case 'visible':
                  default:
                      return 0 /* VISIBLE */;
              }
          });
      }
  };

  var overflowWrap = {
      name: 'overflow-wrap',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'break-word':
                  return "break-word" /* BREAK_WORD */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var paddingForSide = function (side) { return ({
      name: "padding-" + side,
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length-percentage'
  }); };
  var paddingTop = paddingForSide('top');
  var paddingRight = paddingForSide('right');
  var paddingBottom = paddingForSide('bottom');
  var paddingLeft = paddingForSide('left');

  var textAlign = {
      name: 'text-align',
      initialValue: 'left',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textAlign) {
          switch (textAlign) {
              case 'right':
                  return 2 /* RIGHT */;
              case 'center':
              case 'justify':
                  return 1 /* CENTER */;
              case 'left':
              default:
                  return 0 /* LEFT */;
          }
      }
  };

  var position = {
      name: 'position',
      initialValue: 'static',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'relative':
                  return 1 /* RELATIVE */;
              case 'absolute':
                  return 2 /* ABSOLUTE */;
              case 'fixed':
                  return 3 /* FIXED */;
              case 'sticky':
                  return 4 /* STICKY */;
          }
          return 0 /* STATIC */;
      }
  };

  var textShadow = {
      name: 'text-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: COLORS.TRANSPARENT,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else {
                          shadow.blur = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var textTransform = {
      name: 'text-transform',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textTransform) {
          switch (textTransform) {
              case 'uppercase':
                  return 2 /* UPPERCASE */;
              case 'lowercase':
                  return 1 /* LOWERCASE */;
              case 'capitalize':
                  return 3 /* CAPITALIZE */;
          }
          return 0 /* NONE */;
      }
  };

  var transform$1 = {
      name: 'transform',
      initialValue: 'none',
      prefix: true,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          if (token.type === 18 /* FUNCTION */) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
              }
              return transformFunction(token.values);
          }
          return null;
      }
  };
  var matrix = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      return values.length === 6 ? values : null;
  };
  // doesn't support 3D transforms at the moment
  var matrix3d = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  };
  var SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix: matrix,
      matrix3d: matrix3d
  };

  var DEFAULT_VALUE = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  var transformOrigin = {
      name: 'transform-origin',
      initialValue: '50% 50%',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
              return DEFAULT;
          }
          return [origins[0], origins[1]];
      }
  };

  var visibility = {
      name: 'visible',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, visibility) {
          switch (visibility) {
              case 'hidden':
                  return 1 /* HIDDEN */;
              case 'collapse':
                  return 2 /* COLLAPSE */;
              case 'visible':
              default:
                  return 0 /* VISIBLE */;
          }
      }
  };

  var WORD_BREAK;
  (function (WORD_BREAK) {
      WORD_BREAK["NORMAL"] = "normal";
      WORD_BREAK["BREAK_ALL"] = "break-all";
      WORD_BREAK["KEEP_ALL"] = "keep-all";
  })(WORD_BREAK || (WORD_BREAK = {}));
  var wordBreak = {
      name: 'word-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, wordBreak) {
          switch (wordBreak) {
              case 'break-all':
                  return WORD_BREAK.BREAK_ALL;
              case 'keep-all':
                  return WORD_BREAK.KEEP_ALL;
              case 'normal':
              default:
                  return WORD_BREAK.NORMAL;
          }
      }
  };

  var zIndex = {
      name: 'z-index',
      initialValue: 'auto',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */) {
              return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
              return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
      }
  };

  var time = {
      name: 'time',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit.toLowerCase()) {
                  case 's':
                      return 1000 * value.number;
                  case 'ms':
                      return value.number;
              }
          }
          throw new Error("Unsupported time type");
      }
  };

  var opacity = {
      name: 'opacity',
      initialValue: '1',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          return 1;
      }
  };

  var textDecorationColor = {
      name: "text-decoration-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var textDecorationLine = {
      name: 'text-decoration-line',
      initialValue: 'none',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens
              .filter(isIdentToken)
              .map(function (token) {
              switch (token.value) {
                  case 'underline':
                      return 1 /* UNDERLINE */;
                  case 'overline':
                      return 2 /* OVERLINE */;
                  case 'line-through':
                      return 3 /* LINE_THROUGH */;
                  case 'none':
                      return 4 /* BLINK */;
              }
              return 0 /* NONE */;
          })
              .filter(function (line) { return line !== 0 /* NONE */; });
      }
  };

  var fontFamily = {
      name: "font-family",
      initialValue: '',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function (token) {
              switch (token.type) {
                  case 20 /* IDENT_TOKEN */:
                  case 0 /* STRING_TOKEN */:
                      accumulator.push(token.value);
                      break;
                  case 17 /* NUMBER_TOKEN */:
                      accumulator.push(token.number.toString());
                      break;
                  case 4 /* COMMA_TOKEN */:
                      results.push(accumulator.join(' '));
                      accumulator.length = 0;
                      break;
              }
          });
          if (accumulator.length) {
              results.push(accumulator.join(' '));
          }
          return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
      }
  };

  var fontSize = {
      name: "font-size",
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length'
  };

  var fontWeight = {
      name: 'font-weight',
      initialValue: 'normal',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          if (isIdentToken(token)) {
              switch (token.value) {
                  case 'bold':
                      return 700;
                  case 'normal':
                  default:
                      return 400;
              }
          }
          return 400;
      }
  };

  var fontVariant = {
      name: 'font-variant',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (token) { return token.value; });
      }
  };

  var fontStyle = {
      name: 'font-style',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'oblique':
                  return "oblique" /* OBLIQUE */;
              case 'italic':
                  return "italic" /* ITALIC */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var contains = function (bit, value) { return (bit & value) !== 0; };

  var content = {
      name: 'content',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens;
      }
  };

  var counterIncrement = {
      name: 'counter-increment',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (counter.type === 20 /* IDENT_TOKEN */) {
                  var increment = next && isNumberToken(next) ? next.number : 1;
                  increments.push({ counter: counter.value, increment: increment });
              }
          }
          return increments;
      }
  };

  var counterReset = {
      name: 'counter-reset',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (isIdentToken(counter) && counter.value !== 'none') {
                  var reset = next && isNumberToken(next) ? next.number : 0;
                  resets.push({ counter: counter.value, reset: reset });
              }
          }
          return resets;
      }
  };

  var duration = {
      name: 'duration',
      initialValue: '0s',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (context, tokens) {
          return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
      }
  };

  var quotes = {
      name: 'quotes',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var quotes = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
              return null;
          }
          for (var i = 0; i < filtered.length; i += 2) {
              var open_1 = filtered[i].value;
              var close_1 = filtered[i + 1].value;
              quotes.push({ open: open_1, close: close_1 });
          }
          return quotes;
      }
  };
  var getQuote = function (quotes, depth, open) {
      if (!quotes) {
          return '';
      }
      var quote = quotes[Math.min(depth, quotes.length - 1)];
      if (!quote) {
          return '';
      }
      return open ? quote.open : quote.close;
  };

  var boxShadow = {
      name: 'box-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: 0x000000ff,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH,
                  spread: ZERO_LENGTH,
                  inset: false
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isIdentWithValue(token, 'inset')) {
                      shadow.inset = true;
                  }
                  else if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else if (c === 2) {
                          shadow.blur = token;
                      }
                      else {
                          shadow.spread = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var paintOrder = {
      name: 'paint-order',
      initialValue: 'normal',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function (token) {
              switch (token.value) {
                  case 'stroke':
                      layers.push(1 /* STROKE */);
                      break;
                  case 'fill':
                      layers.push(0 /* FILL */);
                      break;
                  case 'markers':
                      layers.push(2 /* MARKERS */);
                      break;
              }
          });
          DEFAULT_VALUE.forEach(function (value) {
              if (layers.indexOf(value) === -1) {
                  layers.push(value);
              }
          });
          return layers;
      }
  };

  var webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: 'currentcolor',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  };

  var CSSParsedDeclaration = /** @class */ (function () {
      function CSSParsedDeclaration(context, declaration) {
          var _a, _b;
          this.animationDuration = parse(context, duration, declaration.animationDuration);
          this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
          this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
          this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
          this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
          this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
          this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
          this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
          this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
          this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
          this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
          this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
          this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
          this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
          this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
          this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
          this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
          this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
          this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
          this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
          this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
          this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
          this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
          this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
          this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
          this.color = parse(context, color, declaration.color);
          this.direction = parse(context, direction, declaration.direction);
          this.display = parse(context, display, declaration.display);
          this.float = parse(context, float, declaration.cssFloat);
          this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
          this.fontSize = parse(context, fontSize, declaration.fontSize);
          this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
          this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
          this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
          this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
          this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
          this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
          this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
          this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
          this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
          this.marginTop = parse(context, marginTop, declaration.marginTop);
          this.marginRight = parse(context, marginRight, declaration.marginRight);
          this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
          this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
          this.opacity = parse(context, opacity, declaration.opacity);
          var overflowTuple = parse(context, overflow, declaration.overflow);
          this.overflowX = overflowTuple[0];
          this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
          this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
          this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
          this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
          this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
          this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
          this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
          this.position = parse(context, position, declaration.position);
          this.textAlign = parse(context, textAlign, declaration.textAlign);
          this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
          this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
          this.textShadow = parse(context, textShadow, declaration.textShadow);
          this.textTransform = parse(context, textTransform, declaration.textTransform);
          this.transform = parse(context, transform$1, declaration.transform);
          this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
          this.visibility = parse(context, visibility, declaration.visibility);
          this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
          this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
          this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
          this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration.prototype.isVisible = function () {
          return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
      };
      CSSParsedDeclaration.prototype.isTransparent = function () {
          return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration.prototype.isTransformed = function () {
          return this.transform !== null;
      };
      CSSParsedDeclaration.prototype.isPositioned = function () {
          return this.position !== 0 /* STATIC */;
      };
      CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
          return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration.prototype.isFloating = function () {
          return this.float !== 0 /* NONE */;
      };
      CSSParsedDeclaration.prototype.isInlineLevel = function () {
          return (contains(this.display, 4 /* INLINE */) ||
              contains(this.display, 33554432 /* INLINE_BLOCK */) ||
              contains(this.display, 268435456 /* INLINE_FLEX */) ||
              contains(this.display, 536870912 /* INLINE_GRID */) ||
              contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
              contains(this.display, 134217728 /* INLINE_TABLE */));
      };
      return CSSParsedDeclaration;
  }());
  var CSSParsedPseudoDeclaration = /** @class */ (function () {
      function CSSParsedPseudoDeclaration(context, declaration) {
          this.content = parse(context, content, declaration.content);
          this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration;
  }());
  var CSSParsedCounterDeclaration = /** @class */ (function () {
      function CSSParsedCounterDeclaration(context, declaration) {
          this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
          this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration;
  }());
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parse = function (context, descriptor, style) {
      var tokenizer = new Tokenizer();
      var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser$1(tokenizer.read());
      switch (descriptor.type) {
          case 2 /* IDENT_VALUE */:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0 /* VALUE */:
              return descriptor.parse(context, parser.parseComponentValue());
          case 1 /* LIST */:
              return descriptor.parse(context, parser.parseComponentValues());
          case 4 /* TOKEN_VALUE */:
              return parser.parseComponentValue();
          case 3 /* TYPE_VALUE */:
              switch (descriptor.format) {
                  case 'angle':
                      return angle.parse(context, parser.parseComponentValue());
                  case 'color':
                      return color$1.parse(context, parser.parseComponentValue());
                  case 'image':
                      return image.parse(context, parser.parseComponentValue());
                  case 'length':
                      var length_1 = parser.parseComponentValue();
                      return isLength(length_1) ? length_1 : ZERO_LENGTH;
                  case 'length-percentage':
                      var value_1 = parser.parseComponentValue();
                      return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                  case 'time':
                      return time.parse(context, parser.parseComponentValue());
              }
              break;
      }
  };

  var elementDebuggerAttribute = 'data-html2canvas-debug';
  var getElementDebugType = function (element) {
      var attribute = element.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
          case 'all':
              return 1 /* ALL */;
          case 'clone':
              return 2 /* CLONE */;
          case 'parse':
              return 3 /* PARSE */;
          case 'render':
              return 4 /* RENDER */;
          default:
              return 0 /* NONE */;
      }
  };
  var isDebugging = function (element, type) {
      var elementType = getElementDebugType(element);
      return elementType === 1 /* ALL */ || type === elementType;
  };

  var ElementContainer = /** @class */ (function () {
      function ElementContainer(context, element) {
          this.context = context;
          this.textNodes = [];
          this.elements = [];
          this.flags = 0;
          if (isDebugging(element, 3 /* PARSE */)) {
              debugger;
          }
          this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
          if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
                  element.style.animationDuration = '0s';
              }
              if (this.styles.transform !== null) {
                  // getBoundingClientRect takes transforms into account
                  element.style.transform = 'none';
              }
          }
          this.bounds = parseBounds(this.context, element);
          if (isDebugging(element, 4 /* RENDER */)) {
              this.flags |= 16 /* DEBUG_RENDER */;
          }
      }
      return ElementContainer;
  }());

  /*
   * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {
      lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
  }
  var decode = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1[base64.charCodeAt(i)];
          encoded2 = lookup$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  var slice16 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64 = function (base64, _byteLength) {
      var buffer = decode(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16(view16, (headerLength + view32[4]) / 2)
          : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$4 = 0; i$4 < chars.length; i$4++) {
      lookup[chars.charCodeAt(i$4)] = i$4;
  }

  var Prepend = 1;
  var CR = 2;
  var LF = 3;
  var Control = 4;
  var Extend = 5;
  var SpacingMark = 7;
  var L = 8;
  var V = 9;
  var T$1 = 10;
  var LV = 11;
  var LVT = 12;
  var ZWJ = 13;
  var Extended_Pictographic = 14;
  var RI = 15;
  var toCodePoints = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var UnicodeTrie = createTrieFromBase64(base64);
  var BREAK_NOT_ALLOWED = '×';
  var BREAK_ALLOWED = '÷';
  var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
  var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
      var prevIndex = index - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index - 1];
      var next = classTypes[index];
      // GB3 Do not break between a CR and LF
      if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
      }
      // GB4 Otherwise, break before and after controls.
      if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
      }
      // GB5
      if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
      }
      // Do not break Hangul syllable sequences.
      // GB6
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
      }
      // GB7
      if ((current === LV || current === V) && (next === V || next === T$1)) {
          return BREAK_NOT_ALLOWED;
      }
      // GB8
      if ((current === LVT || current === T$1) && next === T$1) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9 Do not break before extending characters or ZWJ.
      if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
      }
      // Do not break before SpacingMarks, or after Prepend characters.
      // GB9a
      if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9a
      if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
      }
      // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
      if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
              prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
          }
      }
      // GB12 Do not break within emoji flag sequences.
      // That is, do not break between regional indicator (RI) symbols
      // if there is an odd number of RI characters before the break point.
      if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
          }
      }
      return BREAK_ALLOWED;
  };
  var GraphemeBreaker = function (str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
          next: function () {
              if (index >= length) {
                  return { done: true, value: null };
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index < length &&
                  (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
                  var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
                  lastEnd = index;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };
  var splitGraphemes = function (str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
          if (bk.value) {
              graphemes.push(bk.value.slice());
          }
      }
      return graphemes;
  };

  var testRangeBounds = function (document) {
      var TEST_HEIGHT = 123;
      if (document.createRange) {
          var range = document.createRange();
          if (range.getBoundingClientRect) {
              var testElement = document.createElement('boundtest');
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = 'block';
              document.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                  return true;
              }
          }
      }
      return false;
  };
  var testIOSLineBreak = function (document) {
      var testElement = document.createElement('boundtest');
      testElement.style.width = '50px';
      testElement.style.display = 'block';
      testElement.style.fontSize = '12px';
      testElement.style.letterSpacing = '0px';
      testElement.style.wordSpacing = '0px';
      document.body.appendChild(testElement);
      var range = document.createRange();
      testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
      var offset = 0;
      var prev = {};
      // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
      var supports = textList.every(function (text, i) {
          range.setStart(node, offset);
          range.setEnd(node, offset + text.length);
          var rect = range.getBoundingClientRect();
          offset += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i === 0) {
              return true;
          }
          return boundAhead;
      });
      document.body.removeChild(testElement);
      return supports;
  };
  var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
  var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
  var testSVG = function (document) {
      var img = new Image();
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
      }
      catch (e) {
          return false;
      }
      return true;
  };
  var isGreenPixel = function (data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  };
  var testForeignObject = function (document) {
      var canvas = document.createElement('canvas');
      var size = 100;
      canvas.width = size;
      canvas.height = size;
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return Promise.reject(false);
      }
      ctx.fillStyle = 'rgb(0, 255, 0)';
      ctx.fillRect(0, 0, size, size);
      var img = new Image();
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size, size, 0, 0, img);
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, size, size);
      return loadSerializedSVG$1(svg)
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, size, size);
          var node = document.createElement('div');
          node.style.backgroundImage = "url(" + greenImageSrc + ")";
          node.style.height = size + "px";
          // Firefox 55 does not render inline <img /> tags
          return isGreenPixel(data)
              ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
              : Promise.reject(false);
      })
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          // Edge does not render background-images
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
      })
          .catch(function () { return false; });
  };
  var createForeignObjectSVG = function (width, height, x, y, node) {
      var xmlns = 'http://www.w3.org/2000/svg';
      var svg = document.createElementNS(xmlns, 'svg');
      var foreignObject = document.createElementNS(xmlns, 'foreignObject');
      svg.setAttributeNS(null, 'width', width.toString());
      svg.setAttributeNS(null, 'height', height.toString());
      foreignObject.setAttributeNS(null, 'width', '100%');
      foreignObject.setAttributeNS(null, 'height', '100%');
      foreignObject.setAttributeNS(null, 'x', x.toString());
      foreignObject.setAttributeNS(null, 'y', y.toString());
      foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
  };
  var loadSerializedSVG$1 = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () { return resolve(img); };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };
  var FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
          return value;
      },
      get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
          return value;
      },
      get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
              ? testForeignObject(document)
              : Promise.resolve(false);
          Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
          return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
          return value;
      },
      get SUPPORT_CORS_XHR() {
          var value = 'withCredentials' in new XMLHttpRequest();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
          return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
          Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
          return value;
      }
  };

  var TextBounds = /** @class */ (function () {
      function TextBounds(text, bounds) {
          this.text = text;
          this.bounds = bounds;
      }
      return TextBounds;
  }());
  var parseTextBounds = function (context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function (text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                  var clientRects = createRange(node, offset, text.length).getClientRects();
                  if (clientRects.length > 1) {
                      var subSegments = segmentGraphemes(text);
                      var subOffset_1 = 0;
                      subSegments.forEach(function (subSegment) {
                          textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                          subOffset_1 += subSegment.length;
                      });
                  }
                  else {
                      textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
                  }
              }
              else {
                  var replacementNode = node.splitText(text.length);
                  textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
                  node = replacementNode;
              }
          }
          else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node = node.splitText(text.length);
          }
          offset += text.length;
      });
      return textBounds;
  };
  var getWrapperBounds = function (context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
          var wrapper = ownerDocument.createElement('html2canvaswrapper');
          wrapper.appendChild(node.cloneNode(true));
          var parentNode = node.parentNode;
          if (parentNode) {
              parentNode.replaceChild(wrapper, node);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                  parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
          }
      }
      return Bounds.EMPTY;
  };
  var createRange = function (node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
          throw new Error('Node has no owner document');
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
  };
  var segmentGraphemes = function (value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return splitGraphemes(value);
  };
  var segmentWords = function (value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, {
              granularity: 'word'
          });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return breakWords(value, styles);
  };
  var breakText = function (value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
  };
  // https://drafts.csswg.org/css-text/#word-separator
  var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
  var breakWords = function (str, styles) {
      var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function () {
          if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = '';
              codePoints.forEach(function (codePoint) {
                  if (wordSeparators.indexOf(codePoint) === -1) {
                      word_1 += fromCodePoint$1(codePoint);
                  }
                  else {
                      if (word_1.length) {
                          words.push(word_1);
                      }
                      words.push(fromCodePoint$1(codePoint));
                      word_1 = '';
                  }
              });
              if (word_1.length) {
                  words.push(word_1);
              }
          }
      };
      while (!(bk = breaker.next()).done) {
          _loop_1();
      }
      return words;
  };

  var TextContainer = /** @class */ (function () {
      function TextContainer(context, node, styles) {
          this.text = transform(node.data, styles.textTransform);
          this.textBounds = parseTextBounds(context, this.text, styles, node);
      }
      return TextContainer;
  }());
  var transform = function (text, transform) {
      switch (transform) {
          case 1 /* LOWERCASE */:
              return text.toLowerCase();
          case 3 /* CAPITALIZE */:
              return text.replace(CAPITALIZE, capitalize);
          case 2 /* UPPERCASE */:
              return text.toUpperCase();
          default:
              return text;
      }
  };
  var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  var capitalize = function (m, p1, p2) {
      if (m.length > 0) {
          return p1 + p2.toUpperCase();
      }
      return m;
  };

  var ImageElementContainer = /** @class */ (function (_super) {
      __extends(ImageElementContainer, _super);
      function ImageElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          _this.src = img.currentSrc || img.src;
          _this.intrinsicWidth = img.naturalWidth;
          _this.intrinsicHeight = img.naturalHeight;
          _this.context.cache.addImage(_this.src);
          return _this;
      }
      return ImageElementContainer;
  }(ElementContainer));

  var CanvasElementContainer = /** @class */ (function (_super) {
      __extends(CanvasElementContainer, _super);
      function CanvasElementContainer(context, canvas) {
          var _this = _super.call(this, context, canvas) || this;
          _this.canvas = canvas;
          _this.intrinsicWidth = canvas.width;
          _this.intrinsicHeight = canvas.height;
          return _this;
      }
      return CanvasElementContainer;
  }(ElementContainer));

  var SVGElementContainer = /** @class */ (function (_super) {
      __extends(SVGElementContainer, _super);
      function SVGElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          var s = new XMLSerializer();
          var bounds = parseBounds(context, img);
          img.setAttribute('width', bounds.width + "px");
          img.setAttribute('height', bounds.height + "px");
          _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
          _this.intrinsicWidth = img.width.baseVal.value;
          _this.intrinsicHeight = img.height.baseVal.value;
          _this.context.cache.addImage(_this.svg);
          return _this;
      }
      return SVGElementContainer;
  }(ElementContainer));

  var LIElementContainer = /** @class */ (function (_super) {
      __extends(LIElementContainer, _super);
      function LIElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return LIElementContainer;
  }(ElementContainer));

  var OLElementContainer = /** @class */ (function (_super) {
      __extends(OLElementContainer, _super);
      function OLElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.start = element.start;
          _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
          return _this;
      }
      return OLElementContainer;
  }(ElementContainer));

  var CHECKBOX_BORDER_RADIUS = [
      {
          type: 15 /* DIMENSION_TOKEN */,
          flags: 0,
          unit: 'px',
          number: 3
      }
  ];
  var RADIO_BORDER_RADIUS = [
      {
          type: 16 /* PERCENTAGE_TOKEN */,
          flags: 0,
          number: 50
      }
  ];
  var reformatInputBounds = function (bounds) {
      if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      }
      else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
  };
  var getInputValue = function (node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
      return value.length === 0 ? node.placeholder || '' : value;
  };
  var CHECKBOX = 'checkbox';
  var RADIO = 'radio';
  var PASSWORD = 'password';
  var INPUT_COLOR = 0x2a2a2aff;
  var InputElementContainer = /** @class */ (function (_super) {
      __extends(InputElementContainer, _super);
      function InputElementContainer(context, input) {
          var _this = _super.call(this, context, input) || this;
          _this.type = input.type.toLowerCase();
          _this.checked = input.checked;
          _this.value = getInputValue(input);
          if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 0xdededeff;
              _this.styles.borderTopColor =
                  _this.styles.borderRightColor =
                      _this.styles.borderBottomColor =
                          _this.styles.borderLeftColor =
                              0xa5a5a5ff;
              _this.styles.borderTopWidth =
                  _this.styles.borderRightWidth =
                      _this.styles.borderBottomWidth =
                          _this.styles.borderLeftWidth =
                              1;
              _this.styles.borderTopStyle =
                  _this.styles.borderRightStyle =
                      _this.styles.borderBottomStyle =
                          _this.styles.borderLeftStyle =
                              1 /* SOLID */;
              _this.styles.backgroundClip = [0 /* BORDER_BOX */];
              _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
              _this.bounds = reformatInputBounds(_this.bounds);
          }
          switch (_this.type) {
              case CHECKBOX:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  CHECKBOX_BORDER_RADIUS;
                  break;
              case RADIO:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  RADIO_BORDER_RADIUS;
                  break;
          }
          return _this;
      }
      return InputElementContainer;
  }(ElementContainer));

  var SelectElementContainer = /** @class */ (function (_super) {
      __extends(SelectElementContainer, _super);
      function SelectElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          var option = element.options[element.selectedIndex || 0];
          _this.value = option ? option.text || '' : '';
          return _this;
      }
      return SelectElementContainer;
  }(ElementContainer));

  var TextareaElementContainer = /** @class */ (function (_super) {
      __extends(TextareaElementContainer, _super);
      function TextareaElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return TextareaElementContainer;
  }(ElementContainer));

  var IFrameElementContainer = /** @class */ (function (_super) {
      __extends(IFrameElementContainer, _super);
      function IFrameElementContainer(context, iframe) {
          var _this = _super.call(this, context, iframe) || this;
          _this.src = iframe.src;
          _this.width = parseInt(iframe.width, 10) || 0;
          _this.height = parseInt(iframe.height, 10) || 0;
          _this.backgroundColor = _this.styles.backgroundColor;
          try {
              if (iframe.contentWindow &&
                  iframe.contentWindow.document &&
                  iframe.contentWindow.document.documentElement) {
                  _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                  // http://www.w3.org/TR/css3-background/#special-backgrounds
                  var documentBackgroundColor = iframe.contentWindow.document.documentElement
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
                      : COLORS.TRANSPARENT;
                  var bodyBackgroundColor = iframe.contentWindow.document.body
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
                      : COLORS.TRANSPARENT;
                  _this.backgroundColor = isTransparent(documentBackgroundColor)
                      ? isTransparent(bodyBackgroundColor)
                          ? _this.styles.backgroundColor
                          : bodyBackgroundColor
                      : documentBackgroundColor;
              }
          }
          catch (e) { }
          return _this;
      }
      return IFrameElementContainer;
  }(ElementContainer));

  var LIST_OWNERS = ['OL', 'UL', 'MENU'];
  var parseNodeTree = function (context, node, parent, root) {
      for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          }
          else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                  childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
              }
              else {
                  var container = createContainer(context, childNode);
                  if (container.styles.isVisible()) {
                      if (createsRealStackingContext(childNode, container, root)) {
                          container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
                      }
                      else if (createsStackingContext(container.styles)) {
                          container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
                      }
                      if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                          container.flags |= 8 /* IS_LIST_OWNER */;
                      }
                      parent.elements.push(container);
                      childNode.slot;
                      if (childNode.shadowRoot) {
                          parseNodeTree(context, childNode.shadowRoot, container, root);
                      }
                      else if (!isTextareaElement(childNode) &&
                          !isSVGElement(childNode) &&
                          !isSelectElement(childNode)) {
                          parseNodeTree(context, childNode, container, root);
                      }
                  }
              }
          }
      }
  };
  var createContainer = function (context, element) {
      if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
      }
      if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
      }
      if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
      }
      if (isLIElement(element)) {
          return new LIElementContainer(context, element);
      }
      if (isOLElement(element)) {
          return new OLElementContainer(context, element);
      }
      if (isInputElement(element)) {
          return new InputElementContainer(context, element);
      }
      if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
      }
      if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
      }
      if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
      }
      return new ElementContainer(context, element);
  };
  var parseTree = function (context, element) {
      var container = createContainer(context, element);
      container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
      parseNodeTree(context, element, container, container);
      return container;
  };
  var createsRealStackingContext = function (node, container, root) {
      return (container.styles.isPositionedWithZIndex() ||
          container.styles.opacity < 1 ||
          container.styles.isTransformed() ||
          (isBodyElement(node) && root.styles.isTransparent()));
  };
  var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
  var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
  var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
  var isHTMLElementNode = function (node) {
      return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
  };
  var isSVGElementNode = function (element) {
      return typeof element.className === 'object';
  };
  var isLIElement = function (node) { return node.tagName === 'LI'; };
  var isOLElement = function (node) { return node.tagName === 'OL'; };
  var isInputElement = function (node) { return node.tagName === 'INPUT'; };
  var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
  var isSVGElement = function (node) { return node.tagName === 'svg'; };
  var isBodyElement = function (node) { return node.tagName === 'BODY'; };
  var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
  var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
  var isImageElement = function (node) { return node.tagName === 'IMG'; };
  var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
  var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
  var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
  var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
  var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
  var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

  var CounterState = /** @class */ (function () {
      function CounterState() {
          this.counters = {};
      }
      CounterState.prototype.getCounterValue = function (name) {
          var counter = this.counters[name];
          if (counter && counter.length) {
              return counter[counter.length - 1];
          }
          return 1;
      };
      CounterState.prototype.getCounterValues = function (name) {
          var counter = this.counters[name];
          return counter ? counter : [];
      };
      CounterState.prototype.pop = function (counters) {
          var _this = this;
          counters.forEach(function (counter) { return _this.counters[counter].pop(); });
      };
      CounterState.prototype.parse = function (style) {
          var _this = this;
          var counterIncrement = style.counterIncrement;
          var counterReset = style.counterReset;
          var canReset = true;
          if (counterIncrement !== null) {
              counterIncrement.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  if (counter && entry.increment !== 0) {
                      canReset = false;
                      if (!counter.length) {
                          counter.push(1);
                      }
                      counter[Math.max(0, counter.length - 1)] += entry.increment;
                  }
              });
          }
          var counterNames = [];
          if (canReset) {
              counterReset.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  counterNames.push(entry.counter);
                  if (!counter) {
                      counter = _this.counters[entry.counter] = [];
                  }
                  counter.push(entry.reset);
              });
          }
          return counterNames;
      };
      return CounterState;
  }());
  var ROMAN_UPPER = {
      integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
  };
  var ARMENIAN = {
      integers: [
          9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
          60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'Ք',
          'Փ',
          'Ւ',
          'Ց',
          'Ր',
          'Տ',
          'Վ',
          'Ս',
          'Ռ',
          'Ջ',
          'Պ',
          'Չ',
          'Ո',
          'Շ',
          'Ն',
          'Յ',
          'Մ',
          'Ճ',
          'Ղ',
          'Ձ',
          'Հ',
          'Կ',
          'Ծ',
          'Խ',
          'Լ',
          'Ի',
          'Ժ',
          'Թ',
          'Ը',
          'Է',
          'Զ',
          'Ե',
          'Դ',
          'Գ',
          'Բ',
          'Ա'
      ]
  };
  var HEBREW = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
          19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'י׳',
          'ט׳',
          'ח׳',
          'ז׳',
          'ו׳',
          'ה׳',
          'ד׳',
          'ג׳',
          'ב׳',
          'א׳',
          'ת',
          'ש',
          'ר',
          'ק',
          'צ',
          'פ',
          'ע',
          'ס',
          'נ',
          'מ',
          'ל',
          'כ',
          'יט',
          'יח',
          'יז',
          'טז',
          'טו',
          'י',
          'ט',
          'ח',
          'ז',
          'ו',
          'ה',
          'ד',
          'ג',
          'ב',
          'א'
      ]
  };
  var GEORGIAN = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
          80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'ჵ',
          'ჰ',
          'ჯ',
          'ჴ',
          'ხ',
          'ჭ',
          'წ',
          'ძ',
          'ც',
          'ჩ',
          'შ',
          'ყ',
          'ღ',
          'ქ',
          'ფ',
          'ჳ',
          'ტ',
          'ს',
          'რ',
          'ჟ',
          'პ',
          'ო',
          'ჲ',
          'ნ',
          'მ',
          'ლ',
          'კ',
          'ი',
          'თ',
          'ჱ',
          'ზ',
          'ვ',
          'ე',
          'დ',
          'გ',
          'ბ',
          'ა'
      ]
  };
  var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
      if (value < min || value > max) {
          return createCounterText(value, fallback, suffix.length > 0);
      }
      return (symbols.integers.reduce(function (string, integer, index) {
          while (value >= integer) {
              value -= integer;
              string += symbols.values[index];
          }
          return string;
      }, '') + suffix);
  };
  var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
      var string = '';
      do {
          if (!isNumeric) {
              value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
  };
  var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return ((value < 0 ? '-' : '') +
          (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
              return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) +
              suffix));
  };
  var createCounterStyleFromSymbols = function (value, symbols, suffix) {
      if (suffix === void 0) { suffix = '. '; }
      var codePointRangeLength = symbols.length;
      return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
  };
  var CJK_ZEROS = 1 << 0;
  var CJK_TEN_COEFFICIENTS = 1 << 1;
  var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
          return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
          return numbers[0] + string;
      }
      for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
              string = numbers[coefficient] + string;
          }
          else if (coefficient > 1 ||
              (coefficient === 1 && digit === 0) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
              (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
              string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
          }
          else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : '') + string;
  };
  var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
  var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
  var JAPANESE_NEGATIVE = 'マイナス';
  var KOREAN_NEGATIVE = '마이너스';
  var createCounterText = function (value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? '. ' : '';
      var cjkSuffix = appendSuffix ? '、' : '';
      var koreanSuffix = appendSuffix ? ', ' : '';
      var spaceSuffix = appendSuffix ? ' ' : '';
      switch (type) {
          case 0 /* DISC */:
              return '•' + spaceSuffix;
          case 1 /* CIRCLE */:
              return '◦' + spaceSuffix;
          case 2 /* SQUARE */:
              return '◾' + spaceSuffix;
          case 5 /* DECIMAL_LEADING_ZERO */:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
          case 4 /* CJK_DECIMAL */:
              return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
          case 6 /* LOWER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 7 /* UPPER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
          case 8 /* LOWER_GREEK */:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9 /* LOWER_ALPHA */:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10 /* UPPER_ALPHA */:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11 /* ARABIC_INDIC */:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12 /* ARMENIAN */:
          case 49 /* UPPER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
          case 35 /* LOWER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 13 /* BENGALI */:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14 /* CAMBODIAN */:
          case 30 /* KHMER */:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15 /* CJK_EARTHLY_BRANCH */:
              return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
          case 16 /* CJK_HEAVENLY_STEM */:
              return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
          case 17 /* CJK_IDEOGRAPHIC */:
          case 48 /* TRAD_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47 /* TRAD_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42 /* SIMP_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41 /* SIMP_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26 /* JAPANESE_INFORMAL */:
              return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25 /* JAPANESE_FORMAL */:
              return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31 /* KOREAN_HANGUL_FORMAL */:
              return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33 /* KOREAN_HANJA_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32 /* KOREAN_HANJA_FORMAL */:
              return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18 /* DEVANAGARI */:
              return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
          case 20 /* GEORGIAN */:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
          case 21 /* GUJARATI */:
              return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
          case 22 /* GURMUKHI */:
              return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
          case 22 /* HEBREW */:
              return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
          case 23 /* HIRAGANA */:
              return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
          case 24 /* HIRAGANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
          case 27 /* KANNADA */:
              return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
          case 28 /* KATAKANA */:
              return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
          case 29 /* KATAKANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
          case 34 /* LAO */:
              return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
          case 37 /* MONGOLIAN */:
              return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
          case 38 /* MYANMAR */:
              return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
          case 39 /* ORIYA */:
              return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
          case 40 /* PERSIAN */:
              return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
          case 43 /* TAMIL */:
              return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
          case 44 /* TELUGU */:
              return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
          case 45 /* THAI */:
              return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
          case 46 /* TIBETAN */:
              return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
          case 3 /* DECIMAL */:
          default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
  };

  var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
  var DocumentCloner = /** @class */ (function () {
      function DocumentCloner(context, element, options) {
          this.context = context;
          this.options = options;
          this.scrolledElements = [];
          this.referenceElement = element;
          this.counters = new CounterState();
          this.quoteDepth = 0;
          if (!element.ownerDocument) {
              throw new Error('Cloned element does not have an owner document');
          }
          this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
          var _this = this;
          var iframe = createIFrameContainer(ownerDocument, windowSize);
          if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
          }
          var scrollX = ownerDocument.defaultView.pageXOffset;
          var scrollY = ownerDocument.defaultView.pageYOffset;
          var cloneWindow = iframe.contentWindow;
          var documentClone = cloneWindow.document;
          /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
           if window url is about:blank, we can assign the url to current by writing onto the document
           */
          var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
              var onclone, referenceElement;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.scrolledElements.forEach(restoreNodeScroll);
                          if (cloneWindow) {
                              cloneWindow.scrollTo(windowSize.left, windowSize.top);
                              if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
                                  (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                                  this.context.logger.warn('Unable to restore scroll position for cloned document');
                                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                              }
                          }
                          onclone = this.options.onclone;
                          referenceElement = this.clonedReferenceElement;
                          if (typeof referenceElement === 'undefined') {
                              return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                          }
                          if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
                          return [4 /*yield*/, documentClone.fonts.ready];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
                          return [4 /*yield*/, imagesReady(documentClone)];
                      case 3:
                          _a.sent();
                          _a.label = 4;
                      case 4:
                          if (typeof onclone === 'function') {
                              return [2 /*return*/, Promise.resolve()
                                      .then(function () { return onclone(documentClone, referenceElement); })
                                      .then(function () { return iframe; })];
                          }
                          return [2 /*return*/, iframe];
                  }
              });
          }); });
          documentClone.open();
          documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
          // Chrome scrolls the parent document for some reason after the write to the cloned window???
          restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
          documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
          documentClone.close();
          return iframeLoad;
      };
      DocumentCloner.prototype.createElementClone = function (node) {
          if (isDebugging(node, 2 /* CLONE */)) {
              debugger;
          }
          if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
          }
          if (isVideoElement(node)) {
              return this.createVideoClone(node);
          }
          if (isStyleElement(node)) {
              return this.createStyleClone(node);
          }
          var clone = node.cloneNode(false);
          if (isImageElement(clone)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                  clone.src = node.currentSrc;
                  clone.srcset = '';
              }
              if (clone.loading === 'lazy') {
                  clone.loading = 'eager';
              }
          }
          if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
          }
          return clone;
      };
      DocumentCloner.prototype.createCustomElementClone = function (node) {
          var clone = document.createElement('html2canvascustomelement');
          copyCSSStyles(node.style, clone);
          return clone;
      };
      DocumentCloner.prototype.createStyleClone = function (node) {
          try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                  var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
                      if (rule && typeof rule.cssText === 'string') {
                          return css + rule.cssText;
                      }
                      return css;
                  }, '');
                  var style = node.cloneNode(false);
                  style.textContent = css;
                  return style;
              }
          }
          catch (e) {
              // accessing node.sheet.cssRules throws a DOMException
              this.context.logger.error('Unable to access cssRules property', e);
              if (e.name !== 'SecurityError') {
                  throw e;
              }
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.createCanvasClone = function (canvas) {
          var _a;
          if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement('img');
              try {
                  img.src = canvas.toDataURL();
                  return img;
              }
              catch (e) {
                  this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
          }
          var clonedCanvas = canvas.cloneNode(false);
          try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext('2d');
              var clonedCtx = clonedCanvas.getContext('2d');
              if (clonedCtx) {
                  if (!this.options.allowTaint && ctx) {
                      clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                  }
                  else {
                      var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
                      if (gl) {
                          var attribs = gl.getContextAttributes();
                          if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                              this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
                          }
                      }
                      clonedCtx.drawImage(canvas, 0, 0);
                  }
              }
              return clonedCanvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
          }
          return clonedCanvas;
      };
      DocumentCloner.prototype.createVideoClone = function (video) {
          var canvas = video.ownerDocument.createElement('canvas');
          canvas.width = video.offsetWidth;
          canvas.height = video.offsetHeight;
          var ctx = canvas.getContext('2d');
          try {
              if (ctx) {
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  if (!this.options.allowTaint) {
                      ctx.getImageData(0, 0, canvas.width, canvas.height);
                  }
              }
              return canvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
          }
          var blankCanvas = video.ownerDocument.createElement('canvas');
          blankCanvas.width = video.offsetWidth;
          blankCanvas.height = video.offsetHeight;
          return blankCanvas;
      };
      DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
          if (!isElementNode(child) ||
              (!isScriptElement(child) &&
                  !child.hasAttribute(IGNORE_ATTRIBUTE) &&
                  (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                  clone.appendChild(this.cloneNode(child, copyStyles));
              }
          }
      };
      DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
          var _this = this;
          for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
                  var assignedNodes = child.assignedNodes();
                  if (assignedNodes.length) {
                      assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
                  }
              }
              else {
                  this.appendChildNode(clone, child, copyStyles);
              }
          }
      };
      DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
          if (isTextNode(node)) {
              return document.createTextNode(node.data);
          }
          if (!node.ownerDocument) {
              return node.cloneNode(false);
          }
          var window = node.ownerDocument.defaultView;
          if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone = this.createElementClone(node);
              clone.style.transitionProperty = 'none';
              var style = window.getComputedStyle(node);
              var styleBefore = window.getComputedStyle(node, ':before');
              var styleAfter = window.getComputedStyle(node, ':after');
              if (this.referenceElement === node && isHTMLElementNode(clone)) {
                  this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                  createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node)) {
                  copyStyles = true;
              }
              if (!isVideoElement(node)) {
                  this.cloneChildNodes(node, clone, copyStyles);
              }
              if (before) {
                  clone.insertBefore(before, clone.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
              if (after) {
                  clone.appendChild(after);
              }
              this.counters.pop(counters);
              if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
                  copyStyles) {
                  copyCSSStyles(style, clone);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                  this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) &&
                  (isTextareaElement(clone) || isSelectElement(clone))) {
                  clone.value = node.value;
              }
              return clone;
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
          var _this = this;
          if (!style) {
              return;
          }
          var value = style.content;
          var document = clone.ownerDocument;
          if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
              return;
          }
          this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var declaration = new CSSParsedPseudoDeclaration(this.context, style);
          var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
          copyCSSStyles(style, anonymousReplacedElement);
          declaration.content.forEach(function (token) {
              if (token.type === 0 /* STRING_TOKEN */) {
                  anonymousReplacedElement.appendChild(document.createTextNode(token.value));
              }
              else if (token.type === 22 /* URL_TOKEN */) {
                  var img = document.createElement('img');
                  img.src = token.value;
                  img.style.opacity = '1';
                  anonymousReplacedElement.appendChild(img);
              }
              else if (token.type === 18 /* FUNCTION */) {
                  if (token.name === 'attr') {
                      var attr = token.values.filter(isIdentToken);
                      if (attr.length) {
                          anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
                      }
                  }
                  else if (token.name === 'counter') {
                      var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
                      if (counter && isIdentToken(counter)) {
                          var counterState = _this.counters.getCounterValue(counter.value);
                          var counterType = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
                      }
                  }
                  else if (token.name === 'counters') {
                      var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                      if (counter && isIdentToken(counter)) {
                          var counterStates = _this.counters.getCounterValues(counter.value);
                          var counterType_1 = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
                          var text = counterStates
                              .map(function (value) { return createCounterText(value, counterType_1, false); })
                              .join(separator);
                          anonymousReplacedElement.appendChild(document.createTextNode(text));
                      }
                  }
                  else ;
              }
              else if (token.type === 20 /* IDENT_TOKEN */) {
                  switch (token.value) {
                      case 'open-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                          break;
                      case 'close-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                          break;
                      default:
                          // safari doesn't parse string tokens correctly because of lack of quotes
                          anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                  }
              }
          });
          anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          var newClassName = pseudoElt === PseudoElementType.BEFORE
              ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
              : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
          }
          else {
              clone.className += newClassName;
          }
          return anonymousReplacedElement;
      };
      DocumentCloner.destroy = function (container) {
          if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
          }
          return false;
      };
      return DocumentCloner;
  }());
  var PseudoElementType;
  (function (PseudoElementType) {
      PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
      PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
  })(PseudoElementType || (PseudoElementType = {}));
  var createIFrameContainer = function (ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement('iframe');
      cloneIframeContainer.className = 'html2canvas-container';
      cloneIframeContainer.style.visibility = 'hidden';
      cloneIframeContainer.style.position = 'fixed';
      cloneIframeContainer.style.left = '-10000px';
      cloneIframeContainer.style.top = '0px';
      cloneIframeContainer.style.border = '0';
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
  };
  var imageReady = function (img) {
      return new Promise(function (resolve) {
          if (img.complete) {
              resolve();
              return;
          }
          if (!img.src) {
              resolve();
              return;
          }
          img.onload = resolve;
          img.onerror = resolve;
      });
  };
  var imagesReady = function (document) {
      return Promise.all([].slice.call(document.images, 0).map(imageReady));
  };
  var iframeLoader = function (iframe) {
      return new Promise(function (resolve, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
              return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function () {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function () {
                  if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                      clearInterval(interval);
                      resolve(iframe);
                  }
              }, 50);
          };
      });
  };
  var ignoredStyleProperties = [
      'all',
      'd',
      'content' // Safari shows pseudoelements if content is set
  ];
  var copyCSSStyles = function (style, target) {
      // Edge does not provide value for cssText
      for (var i = style.length - 1; i >= 0; i--) {
          var property = style.item(i);
          if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
          }
      }
      return target;
  };
  var serializeDoctype = function (doctype) {
      var str = '';
      if (doctype) {
          str += '<!DOCTYPE ';
          if (doctype.name) {
              str += doctype.name;
          }
          if (doctype.internalSubset) {
              str += doctype.internalSubset;
          }
          if (doctype.publicId) {
              str += "\"" + doctype.publicId + "\"";
          }
          if (doctype.systemId) {
              str += "\"" + doctype.systemId + "\"";
          }
          str += '>';
      }
      return str;
  };
  var restoreOwnerScroll = function (ownerDocument, x, y) {
      if (ownerDocument &&
          ownerDocument.defaultView &&
          (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x, y);
      }
  };
  var restoreNodeScroll = function (_a) {
      var element = _a[0], x = _a[1], y = _a[2];
      element.scrollLeft = x;
      element.scrollTop = y;
  };
  var PSEUDO_BEFORE = ':before';
  var PSEUDO_AFTER = ':after';
  var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
  var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
  var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
  var createPseudoHideStyles = function (body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  };
  var createStyles = function (body, styles) {
      var document = body.ownerDocument;
      if (document) {
          var style = document.createElement('style');
          style.textContent = styles;
          body.appendChild(style);
      }
  };

  var CacheStorage = /** @class */ (function () {
      function CacheStorage() {
      }
      CacheStorage.getOrigin = function (url) {
          var link = CacheStorage._link;
          if (!link) {
              return 'about:blank';
          }
          link.href = url;
          link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
          return link.protocol + link.hostname + link.port;
      };
      CacheStorage.isSameOrigin = function (src) {
          return CacheStorage.getOrigin(src) === CacheStorage._origin;
      };
      CacheStorage.setContext = function (window) {
          CacheStorage._link = window.document.createElement('a');
          CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
      };
      CacheStorage._origin = 'about:blank';
      return CacheStorage;
  }());
  var Cache = /** @class */ (function () {
      function Cache(context, _options) {
          this.context = context;
          this._options = _options;
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this._cache = {};
      }
      Cache.prototype.addImage = function (src) {
          var result = Promise.resolve();
          if (this.has(src)) {
              return result;
          }
          if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function () {
                  // prevent unhandled rejection
              });
              return result;
          }
          return result;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Cache.prototype.match = function (src) {
          return this._cache[src];
      };
      Cache.prototype.loadImage = function (key) {
          return __awaiter(this, void 0, void 0, function () {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          isSameOrigin = CacheStorage.isSameOrigin(key);
                          useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                          useProxy = !isInlineImage(key) &&
                              !isSameOrigin &&
                              !isBlobImage(key) &&
                              typeof this._options.proxy === 'string' &&
                              FEATURES.SUPPORT_CORS_XHR &&
                              !useCORS;
                          if (!isSameOrigin &&
                              this._options.allowTaint === false &&
                              !isInlineImage(key) &&
                              !isBlobImage(key) &&
                              !useProxy &&
                              !useCORS) {
                              return [2 /*return*/];
                          }
                          src = key;
                          if (!useProxy) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.proxy(src)];
                      case 1:
                          src = _a.sent();
                          _a.label = 2;
                      case 2:
                          this.context.logger.debug("Added image " + key.substring(0, 256));
                          return [4 /*yield*/, new Promise(function (resolve, reject) {
                                  var img = new Image();
                                  img.onload = function () { return resolve(img); };
                                  img.onerror = reject;
                                  //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                                  if (isInlineBase64Image(src) || useCORS) {
                                      img.crossOrigin = 'anonymous';
                                  }
                                  img.src = src;
                                  if (img.complete === true) {
                                      // Inline XML images may fail to parse, throwing an Error later on
                                      setTimeout(function () { return resolve(img); }, 500);
                                  }
                                  if (_this._options.imageTimeout > 0) {
                                      setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
                                  }
                              })];
                      case 3: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      Cache.prototype.has = function (key) {
          return typeof this._cache[key] !== 'undefined';
      };
      Cache.prototype.keys = function () {
          return Promise.resolve(Object.keys(this._cache));
      };
      Cache.prototype.proxy = function (src) {
          var _this = this;
          var proxy = this._options.proxy;
          if (!proxy) {
              throw new Error('No proxy defined');
          }
          var key = src.substring(0, 256);
          return new Promise(function (resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
              var xhr = new XMLHttpRequest();
              xhr.onload = function () {
                  if (xhr.status === 200) {
                      if (responseType === 'text') {
                          resolve(xhr.response);
                      }
                      else {
                          var reader_1 = new FileReader();
                          reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
                          reader_1.addEventListener('error', function (e) { return reject(e); }, false);
                          reader_1.readAsDataURL(xhr.response);
                      }
                  }
                  else {
                      reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                  }
              };
              xhr.onerror = reject;
              var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
              xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
                  xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                  var timeout_1 = _this._options.imageTimeout;
                  xhr.timeout = timeout_1;
                  xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
              }
              xhr.send();
          });
      };
      return Cache;
  }());
  var INLINE_SVG = /^data:image\/svg\+xml/i;
  var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  var INLINE_IMG = /^data:image\/.*/i;
  var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
  var isInlineImage = function (src) { return INLINE_IMG.test(src); };
  var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
  var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
  var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

  var Vector = /** @class */ (function () {
      function Vector(x, y) {
          this.type = 0 /* VECTOR */;
          this.x = x;
          this.y = y;
      }
      Vector.prototype.add = function (deltaX, deltaY) {
          return new Vector(this.x + deltaX, this.y + deltaY);
      };
      return Vector;
  }());

  var lerp = function (a, b, t) {
      return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
  };
  var BezierCurve = /** @class */ (function () {
      function BezierCurve(start, startControl, endControl, end) {
          this.type = 1 /* BEZIER_CURVE */;
          this.start = start;
          this.startControl = startControl;
          this.endControl = endControl;
          this.end = end;
      }
      BezierCurve.prototype.subdivide = function (t, firstHalf) {
          var ab = lerp(this.start, this.startControl, t);
          var bc = lerp(this.startControl, this.endControl, t);
          var cd = lerp(this.endControl, this.end, t);
          var abbc = lerp(ab, bc, t);
          var bccd = lerp(bc, cd, t);
          var dest = lerp(abbc, bccd, t);
          return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
      };
      BezierCurve.prototype.add = function (deltaX, deltaY) {
          return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve.prototype.reverse = function () {
          return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve;
  }());
  var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

  var BoundCurves = /** @class */ (function () {
      function BoundCurves(element) {
          var styles = element.styles;
          var bounds = element.bounds;
          var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
          var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
          var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
          var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
          var factors = [];
          factors.push((tlh + trh) / bounds.width);
          factors.push((blh + brh) / bounds.width);
          factors.push((tlv + blv) / bounds.height);
          factors.push((trv + brv) / bounds.height);
          var maxFactor = Math.max.apply(Math, factors);
          if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
          }
          var topWidth = bounds.width - trh;
          var rightHeight = bounds.height - brv;
          var bottomWidth = bounds.width - brh;
          var leftHeight = bounds.height - blv;
          var borderTopWidth = styles.borderTopWidth;
          var borderRightWidth = styles.borderRightWidth;
          var borderBottomWidth = styles.borderBottomWidth;
          var borderLeftWidth = styles.borderLeftWidth;
          var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
          var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
          var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
          var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
          this.topLeftBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
          this.topRightBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
          this.bottomRightBorderDoubleOuterBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.bottomLeftBorderDoubleOuterBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.topLeftBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.topRightBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.bottomRightBorderDoubleInnerBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.bottomLeftBorderDoubleInnerBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.topLeftBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
          this.topRightBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
          this.bottomRightBorderStroke =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.bottomLeftBorderStroke =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.topLeftBorderBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
                  : new Vector(bounds.left, bounds.top);
          this.topRightBorderBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top);
          this.bottomRightBorderBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
          this.bottomLeftBorderBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left, bounds.top + bounds.height);
          this.topLeftPaddingBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
          this.topRightPaddingBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
          this.bottomRightPaddingBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
          this.bottomLeftPaddingBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
          this.topLeftContentBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
          this.topRightContentBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
          this.bottomRightContentBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
          this.bottomLeftContentBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
      }
      return BoundCurves;
  }());
  var CORNER;
  (function (CORNER) {
      CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  })(CORNER || (CORNER = {}));
  var getCurvePoints = function (x, y, r1, r2, position) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa; // control point offset horizontal
      var oy = r2 * kappa; // control point offset vertical
      var xm = x + r1; // x-middle
      var ym = y + r2; // y-middle
      switch (position) {
          case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
          case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
          case CORNER.BOTTOM_LEFT:
          default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
      }
  };
  var calculateBorderBoxPath = function (curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  };
  var calculateContentBoxPath = function (curves) {
      return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
      ];
  };
  var calculatePaddingBoxPath = function (curves) {
      return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
      ];
  };

  var TransformEffect = /** @class */ (function () {
      function TransformEffect(offsetX, offsetY, matrix) {
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          this.matrix = matrix;
          this.type = 0 /* TRANSFORM */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return TransformEffect;
  }());
  var ClipEffect = /** @class */ (function () {
      function ClipEffect(path, target) {
          this.path = path;
          this.target = target;
          this.type = 1 /* CLIP */;
      }
      return ClipEffect;
  }());
  var OpacityEffect = /** @class */ (function () {
      function OpacityEffect(opacity) {
          this.opacity = opacity;
          this.type = 2 /* OPACITY */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return OpacityEffect;
  }());
  var isTransformEffect = function (effect) {
      return effect.type === 0 /* TRANSFORM */;
  };
  var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
  var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

  var equalPath = function (a, b) {
      if (a.length === b.length) {
          return a.some(function (v, i) { return v === b[i]; });
      }
      return false;
  };
  var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function (point, index) {
          switch (index) {
              case 0:
                  return point.add(deltaX, deltaY);
              case 1:
                  return point.add(deltaX + deltaW, deltaY);
              case 2:
                  return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                  return point.add(deltaX, deltaY + deltaH);
          }
          return point;
      });
  };

  var StackingContext = /** @class */ (function () {
      function StackingContext(container) {
          this.element = container;
          this.inlineLevel = [];
          this.nonInlineLevel = [];
          this.negativeZIndex = [];
          this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
          this.positiveZIndex = [];
          this.nonPositionedFloats = [];
          this.nonPositionedInlineLevel = [];
      }
      return StackingContext;
  }());
  var ElementPaint = /** @class */ (function () {
      function ElementPaint(container, parent) {
          this.container = container;
          this.parent = parent;
          this.effects = [];
          this.curves = new BoundCurves(this.container);
          if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
          }
          if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
          }
          if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox)) {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
              }
              else {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
                  this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
              }
          }
      }
      ElementPaint.prototype.getEffects = function (target) {
          var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
          var parent = this.parent;
          var effects = this.effects.slice(0);
          while (parent) {
              var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
              if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
                  effects.unshift.apply(effects, croplessEffects);
                  inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
                  if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
                      var borderBox = calculateBorderBoxPath(parent.curves);
                      var paddingBox = calculatePaddingBoxPath(parent.curves);
                      if (!equalPath(borderBox, paddingBox)) {
                          effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                      }
                  }
              }
              else {
                  effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
          }
          return effects.filter(function (effect) { return contains(effect.target, target); });
      };
      return ElementPaint;
  }());
  var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function (child) {
          var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
          var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
          var paintContainer = new ElementPaint(child, parent);
          if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
              listItems.push(paintContainer);
          }
          var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                  var order_1 = child.styles.zIndex.order;
                  if (order_1 < 0) {
                      var index_1 = 0;
                      parentStack.negativeZIndex.some(function (current, i) {
                          if (order_1 > current.element.container.styles.zIndex.order) {
                              index_1 = i;
                              return false;
                          }
                          else if (index_1 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.negativeZIndex.splice(index_1, 0, stack);
                  }
                  else if (order_1 > 0) {
                      var index_2 = 0;
                      parentStack.positiveZIndex.some(function (current, i) {
                          if (order_1 >= current.element.container.styles.zIndex.order) {
                              index_2 = i + 1;
                              return false;
                          }
                          else if (index_2 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.positiveZIndex.splice(index_2, 0, stack);
                  }
                  else {
                      parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                  }
              }
              else {
                  if (child.styles.isFloating()) {
                      parentStack.nonPositionedFloats.push(stack);
                  }
                  else {
                      parentStack.nonPositionedInlineLevel.push(stack);
                  }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          }
          else {
              if (child.styles.isInlineLevel()) {
                  stackingContext.inlineLevel.push(paintContainer);
              }
              else {
                  stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
              processListItems(child, listOwnerItems);
          }
      });
  };
  var processListItems = function (owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i = 0; i < elements.length; i++) {
          var item = elements[i];
          if (item.container instanceof LIElementContainer &&
              typeof item.container.value === 'number' &&
              item.container.value !== 0) {
              numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
      }
  };
  var parseStackingContexts = function (container) {
      var paintContainer = new ElementPaint(container, null);
      var root = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root, root, listItems);
      processListItems(paintContainer.container, listItems);
      return root;
  };

  var parsePathForBorder = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderDoubleOuter = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
  };
  var parsePathForBorderDoubleInner = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderStroke = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
  };
  var createStrokePathFromCurves = function (outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      return path;
  };
  var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
          path.push(inner2.subdivide(0.5, true).reverse());
      }
      else {
          path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
          path.push(inner1.subdivide(0.5, false).reverse());
      }
      else {
          path.push(inner1);
      }
      return path;
  };

  var paddingBox = function (element) {
      var bounds = element.bounds;
      var styles = element.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  };
  var contentBox = function (element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
  };

  var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
      if (backgroundOrigin === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundOrigin === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundPaintingArea = function (backgroundClip, element) {
      if (backgroundClip === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundClip === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundRendering = function (container, index, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  };
  var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
  var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
  var calculateBackgroundSize = function (size, _a, bounds) {
      var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
      var first = size[0], second = size[1];
      if (!first) {
          return [0, 0];
      }
      if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
                  ? [bounds.width, bounds.width / intrinsicProportion]
                  : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      // If the background-size is auto or auto auto:
      if (isAuto(first) && (!second || isAuto(second))) {
          // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
          }
          // If the image has no intrinsic dimensions and has no intrinsic proportions,
          // it's rendered at the size of the background positioning area.
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
          }
          // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
          // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
          // The other dimension is computed using the specified dimension and the intrinsic proportions.
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth
                  ? intrinsicWidth
                  : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight
                  ? intrinsicHeight
                  : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
          }
          // If the image has only one intrinsic dimension but has no intrinsic proportions,
          // it's rendered using the specified dimension and the other dimension of the background positioning area.
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
      }
      // If the image has intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
      if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
          }
          else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
          }
          else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
      }
      // If the image has no intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
      // if there is one. If there is no such intrinsic dimension,
      // it becomes the corresponding dimension of the background positioning area.
      var width = null;
      var height = null;
      if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
      }
      else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
          height =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (width / intrinsicWidth) * intrinsicHeight
                  : bounds.height;
      }
      if (height !== null && isAuto(first)) {
          width =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (height / intrinsicHeight) * intrinsicWidth
                  : bounds.width;
      }
      if (width !== null && height !== null) {
          return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
  };
  var getBackgroundValueForIndex = function (values, index) {
      var value = values[index];
      if (typeof value === 'undefined') {
          return values[0];
      }
      return value;
  };
  var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
      var x = _a[0], y = _a[1];
      var width = _b[0], height = _b[1];
      switch (repeat) {
          case 2 /* REPEAT_X */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
              ];
          case 3 /* REPEAT_Y */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
              ];
          case 1 /* NO_REPEAT */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
              ];
          default:
              return [
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
              ];
      }
  };

  var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

  var SAMPLE_TEXT = 'Hidden Text';
  var FontMetrics = /** @class */ (function () {
      function FontMetrics(document) {
          this._data = {};
          this._document = document;
      }
      FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
          var container = this._document.createElement('div');
          var img = this._document.createElement('img');
          var span = this._document.createElement('span');
          var body = this._document.body;
          container.style.visibility = 'hidden';
          container.style.fontFamily = fontFamily;
          container.style.fontSize = fontSize;
          container.style.margin = '0';
          container.style.padding = '0';
          container.style.whiteSpace = 'nowrap';
          body.appendChild(container);
          img.src = SMALL_IMAGE;
          img.width = 1;
          img.height = 1;
          img.style.margin = '0';
          img.style.padding = '0';
          img.style.verticalAlign = 'baseline';
          span.style.fontFamily = fontFamily;
          span.style.fontSize = fontSize;
          span.style.margin = '0';
          span.style.padding = '0';
          span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.appendChild(span);
          container.appendChild(img);
          var baseline = img.offsetTop - span.offsetTop + 2;
          container.removeChild(span);
          container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.style.lineHeight = 'normal';
          img.style.verticalAlign = 'super';
          var middle = img.offsetTop - container.offsetTop + 2;
          body.removeChild(container);
          return { baseline: baseline, middle: middle };
      };
      FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
          var key = fontFamily + " " + fontSize;
          if (typeof this._data[key] === 'undefined') {
              this._data[key] = this.parseMetrics(fontFamily, fontSize);
          }
          return this._data[key];
      };
      return FontMetrics;
  }());

  var Renderer = /** @class */ (function () {
      function Renderer(context, options) {
          this.context = context;
          this.options = options;
      }
      return Renderer;
  }());

  var MASK_OFFSET = 10000;
  var CanvasRenderer = /** @class */ (function (_super) {
      __extends(CanvasRenderer, _super);
      function CanvasRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this._activeEffects = [];
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
          }
          _this.fontMetrics = new FontMetrics(document);
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.ctx.textBaseline = 'bottom';
          _this._activeEffects = [];
          _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
          return _this;
      }
      CanvasRenderer.prototype.applyEffects = function (effects) {
          var _this = this;
          while (this._activeEffects.length) {
              this.popEffect();
          }
          effects.forEach(function (effect) { return _this.applyEffect(effect); });
      };
      CanvasRenderer.prototype.applyEffect = function (effect) {
          this.ctx.save();
          if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
          }
          if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
          }
          if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
          }
          this._activeEffects.push(effect);
      };
      CanvasRenderer.prototype.popEffect = function () {
          this._activeEffects.pop();
          this.ctx.restore();
      };
      CanvasRenderer.prototype.renderStack = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var styles;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          styles = stack.element.container.styles;
                          if (!styles.isVisible()) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderStackContent(stack)];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNode = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
                      case 1:
                          _a.sent();
                          return [4 /*yield*/, this.renderNodeContent(paint)];
                      case 2:
                          _a.sent();
                          _a.label = 3;
                      case 3: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
          var _this = this;
          if (letterSpacing === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
          }
          else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function (left, letter) {
                  _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                  return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
          }
      };
      CanvasRenderer.prototype.createFontStyle = function (styles) {
          var fontVariant = styles.fontVariant
              .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
              .join('');
          var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
          var fontSize = isDimensionToken(styles.fontSize)
              ? "" + styles.fontSize.number + styles.fontSize.unit
              : styles.fontSize.number + "px";
          return [
              [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
              fontFamily,
              fontSize
          ];
      };
      CanvasRenderer.prototype.renderTextNode = function (text, styles) {
          return __awaiter(this, void 0, void 0, function () {
              var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
              var _this = this;
              return __generator(this, function (_c) {
                  _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
                  this.ctx.font = font;
                  this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
                  this.ctx.textAlign = 'left';
                  this.ctx.textBaseline = 'alphabetic';
                  _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
                  paintOrder = styles.paintOrder;
                  text.textBounds.forEach(function (text) {
                      paintOrder.forEach(function (paintOrderLayer) {
                          switch (paintOrderLayer) {
                              case 0 /* FILL */:
                                  _this.ctx.fillStyle = asString(styles.color);
                                  _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                  var textShadows = styles.textShadow;
                                  if (textShadows.length && text.text.trim().length) {
                                      textShadows
                                          .slice(0)
                                          .reverse()
                                          .forEach(function (textShadow) {
                                          _this.ctx.shadowColor = asString(textShadow.color);
                                          _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                                          _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                                          _this.ctx.shadowBlur = textShadow.blur.number;
                                          _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                      });
                                      _this.ctx.shadowColor = '';
                                      _this.ctx.shadowOffsetX = 0;
                                      _this.ctx.shadowOffsetY = 0;
                                      _this.ctx.shadowBlur = 0;
                                  }
                                  if (styles.textDecorationLine.length) {
                                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                                      styles.textDecorationLine.forEach(function (textDecorationLine) {
                                          switch (textDecorationLine) {
                                              case 1 /* UNDERLINE */:
                                                  // Draws a line at the baseline of the font
                                                  // TODO As some browsers display the line as more than 1px if the font-size is big,
                                                  // need to take that into account both in position and size
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                                                  break;
                                              case 2 /* OVERLINE */:
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                                                  break;
                                              case 3 /* LINE_THROUGH */:
                                                  // TODO try and find exact position for line-through
                                                  _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                                                  break;
                                          }
                                      });
                                  }
                                  break;
                              case 1 /* STROKE */:
                                  if (styles.webkitTextStrokeWidth && text.text.trim().length) {
                                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                      _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
                                      _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
                                  }
                                  _this.ctx.strokeStyle = '';
                                  _this.ctx.lineWidth = 0;
                                  _this.ctx.lineJoin = 'miter';
                                  break;
                          }
                      });
                  });
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
          if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
          }
      };
      CanvasRenderer.prototype.renderNodeContent = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
              return __generator(this, function (_c) {
                  switch (_c.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(4 /* CONTENT */));
                          container = paint.container;
                          curves = paint.curves;
                          styles = container.styles;
                          _i = 0, _a = container.textNodes;
                          _c.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderTextNode(child, styles)];
                      case 2:
                          _c.sent();
                          _c.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4:
                          if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
                          _c.label = 5;
                      case 5:
                          _c.trys.push([5, 7, , 8]);
                          return [4 /*yield*/, this.context.cache.match(container.src)];
                      case 6:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 8];
                      case 7:
                          _c.sent();
                          this.context.logger.error("Error loading image " + container.src);
                          return [3 /*break*/, 8];
                      case 8:
                          if (container instanceof CanvasElementContainer) {
                              this.renderReplacedElement(container, curves, container.canvas);
                          }
                          if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
                          _c.label = 9;
                      case 9:
                          _c.trys.push([9, 11, , 12]);
                          return [4 /*yield*/, this.context.cache.match(container.svg)];
                      case 10:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 12];
                      case 11:
                          _c.sent();
                          this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                          return [3 /*break*/, 12];
                      case 12:
                          if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
                          iframeRenderer = new CanvasRenderer(this.context, {
                              scale: this.options.scale,
                              backgroundColor: container.backgroundColor,
                              x: 0,
                              y: 0,
                              width: container.width,
                              height: container.height
                          });
                          return [4 /*yield*/, iframeRenderer.render(container.tree)];
                      case 13:
                          canvas = _c.sent();
                          if (container.width && container.height) {
                              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                          }
                          _c.label = 14;
                      case 14:
                          if (container instanceof InputElementContainer) {
                              size = Math.min(container.bounds.width, container.bounds.height);
                              if (container.type === CHECKBOX) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.path([
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                                          new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                                          new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                                          new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                                          new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                                          new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                                      ]);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                              else if (container.type === RADIO) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.ctx.beginPath();
                                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                          }
                          if (isTextInputElement(container) && container.value.length) {
                              _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
                              baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                              bounds = contentBox(container);
                              x = 0;
                              switch (container.styles.textAlign) {
                                  case 1 /* CENTER */:
                                      x += bounds.width / 2;
                                      break;
                                  case 2 /* RIGHT */:
                                      x += bounds.width;
                                      break;
                              }
                              textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                              this.ctx.save();
                              this.path([
                                  new Vector(bounds.left, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                                  new Vector(bounds.left, bounds.top + bounds.height)
                              ]);
                              this.ctx.clip();
                              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                              this.ctx.restore();
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = 'left';
                          }
                          if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
                          if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
                          img = container.styles.listStyleImage;
                          if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
                          image = void 0;
                          url = img.url;
                          _c.label = 15;
                      case 15:
                          _c.trys.push([15, 17, , 18]);
                          return [4 /*yield*/, this.context.cache.match(url)];
                      case 16:
                          image = _c.sent();
                          this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
                          return [3 /*break*/, 18];
                      case 17:
                          _c.sent();
                          this.context.logger.error("Error loading list-style-image " + url);
                          return [3 /*break*/, 18];
                      case 18: return [3 /*break*/, 20];
                      case 19:
                          if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
                              fontFamily = this.createFontStyle(styles)[0];
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'middle';
                              this.ctx.textAlign = 'right';
                              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                              this.ctx.textBaseline = 'bottom';
                              this.ctx.textAlign = 'left';
                          }
                          _c.label = 20;
                      case 20: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderStackContent = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function (_p) {
                  switch (_p.label) {
                      case 0:
                          if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
                      case 1:
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          _p.sent();
                          _i = 0, _a = stack.negativeZIndex;
                          _p.label = 2;
                      case 2:
                          if (!(_i < _a.length)) return [3 /*break*/, 5];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 3:
                          _p.sent();
                          _p.label = 4;
                      case 4:
                          _i++;
                          return [3 /*break*/, 2];
                      case 5: 
                      // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                      return [4 /*yield*/, this.renderNodeContent(stack.element)];
                      case 6:
                          // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                          _p.sent();
                          _b = 0, _c = stack.nonInlineLevel;
                          _p.label = 7;
                      case 7:
                          if (!(_b < _c.length)) return [3 /*break*/, 10];
                          child = _c[_b];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 8:
                          _p.sent();
                          _p.label = 9;
                      case 9:
                          _b++;
                          return [3 /*break*/, 7];
                      case 10:
                          _d = 0, _e = stack.nonPositionedFloats;
                          _p.label = 11;
                      case 11:
                          if (!(_d < _e.length)) return [3 /*break*/, 14];
                          child = _e[_d];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 12:
                          _p.sent();
                          _p.label = 13;
                      case 13:
                          _d++;
                          return [3 /*break*/, 11];
                      case 14:
                          _f = 0, _g = stack.nonPositionedInlineLevel;
                          _p.label = 15;
                      case 15:
                          if (!(_f < _g.length)) return [3 /*break*/, 18];
                          child = _g[_f];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 16:
                          _p.sent();
                          _p.label = 17;
                      case 17:
                          _f++;
                          return [3 /*break*/, 15];
                      case 18:
                          _h = 0, _j = stack.inlineLevel;
                          _p.label = 19;
                      case 19:
                          if (!(_h < _j.length)) return [3 /*break*/, 22];
                          child = _j[_h];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 20:
                          _p.sent();
                          _p.label = 21;
                      case 21:
                          _h++;
                          return [3 /*break*/, 19];
                      case 22:
                          _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                          _p.label = 23;
                      case 23:
                          if (!(_k < _l.length)) return [3 /*break*/, 26];
                          child = _l[_k];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 24:
                          _p.sent();
                          _p.label = 25;
                      case 25:
                          _k++;
                          return [3 /*break*/, 23];
                      case 26:
                          _m = 0, _o = stack.positiveZIndex;
                          _p.label = 27;
                      case 27:
                          if (!(_m < _o.length)) return [3 /*break*/, 30];
                          child = _o[_m];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 28:
                          _p.sent();
                          _p.label = 29;
                      case 29:
                          _m++;
                          return [3 /*break*/, 27];
                      case 30: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.mask = function (paths) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, 0);
          this.ctx.lineTo(this.canvas.width, 0);
          this.ctx.lineTo(this.canvas.width, this.canvas.height);
          this.ctx.lineTo(0, this.canvas.height);
          this.ctx.lineTo(0, 0);
          this.formatPath(paths.slice(0).reverse());
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.path = function (paths) {
          this.ctx.beginPath();
          this.formatPath(paths);
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.formatPath = function (paths) {
          var _this = this;
          paths.forEach(function (point, index) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                  _this.ctx.moveTo(start.x, start.y);
              }
              else {
                  _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                  _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
          });
      };
      CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
          this.path(path);
          this.ctx.fillStyle = pattern;
          this.ctx.translate(offsetX, offsetY);
          this.ctx.fill();
          this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer.prototype.resizeImage = function (image, width, height) {
          var _a;
          if (image.width === width && image.height === height) {
              return image;
          }
          var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
          var canvas = ownerDocument.createElement('canvas');
          canvas.width = Math.max(1, width);
          canvas.height = Math.max(1, height);
          var ctx = canvas.getContext('2d');
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
          return canvas;
      };
      CanvasRenderer.prototype.renderBackgroundImage = function (container) {
          return __awaiter(this, void 0, void 0, function () {
              var index, _loop_1, this_1, _i, _a, backgroundImage;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          index = container.styles.backgroundImage.length - 1;
                          _loop_1 = function (backgroundImage) {
                              var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
                              return __generator(this, function (_h) {
                                  switch (_h.label) {
                                      case 0:
                                          if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
                                          image = void 0;
                                          url = backgroundImage.url;
                                          _h.label = 1;
                                      case 1:
                                          _h.trys.push([1, 3, , 4]);
                                          return [4 /*yield*/, this_1.context.cache.match(url)];
                                      case 2:
                                          image = _h.sent();
                                          return [3 /*break*/, 4];
                                      case 3:
                                          _h.sent();
                                          this_1.context.logger.error("Error loading background-image " + url);
                                          return [3 /*break*/, 4];
                                      case 4:
                                          if (image) {
                                              _c = calculateBackgroundRendering(container, index, [
                                                  image.width,
                                                  image.height,
                                                  image.width / image.height
                                              ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                                              this_1.renderRepeat(path, pattern, x, y);
                                          }
                                          return [3 /*break*/, 6];
                                      case 5:
                                          if (isLinearGradient(backgroundImage)) {
                                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                                              _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                                              canvas = document.createElement('canvas');
                                              canvas.width = width;
                                              canvas.height = height;
                                              ctx = canvas.getContext('2d');
                                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                              processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                                                  return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                              });
                                              ctx.fillStyle = gradient_1;
                                              ctx.fillRect(0, 0, width, height);
                                              if (width > 0 && height > 0) {
                                                  pattern = this_1.ctx.createPattern(canvas, 'repeat');
                                                  this_1.renderRepeat(path, pattern, x, y);
                                              }
                                          }
                                          else if (isRadialGradient(backgroundImage)) {
                                              _f = calculateBackgroundRendering(container, index, [
                                                  null,
                                                  null,
                                                  null
                                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                                              position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                                              x = getAbsoluteValue(position[0], width);
                                              y = getAbsoluteValue(position[position.length - 1], height);
                                              _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
                                              if (rx > 0 && ry > 0) {
                                                  radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                                  processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                                                      return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                  });
                                                  this_1.path(path);
                                                  this_1.ctx.fillStyle = radialGradient_1;
                                                  if (rx !== ry) {
                                                      midX = container.bounds.left + 0.5 * container.bounds.width;
                                                      midY = container.bounds.top + 0.5 * container.bounds.height;
                                                      f = ry / rx;
                                                      invF = 1 / f;
                                                      this_1.ctx.save();
                                                      this_1.ctx.translate(midX, midY);
                                                      this_1.ctx.transform(1, 0, 0, f, 0, 0);
                                                      this_1.ctx.translate(-midX, -midY);
                                                      this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                                      this_1.ctx.restore();
                                                  }
                                                  else {
                                                      this_1.ctx.fill();
                                                  }
                                              }
                                          }
                                          _h.label = 6;
                                      case 6:
                                          index--;
                                          return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                          _b.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          backgroundImage = _a[_i];
                          return [5 /*yield**/, _loop_1(backgroundImage)];
                      case 2:
                          _b.sent();
                          _b.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.path(parsePathForBorder(curvePoints, side));
                  this.ctx.fillStyle = asString(color);
                  this.ctx.fill();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              var outerPaths, innerPaths;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(width < 3)) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                      case 2:
                          outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                          this.path(outerPaths);
                          this.ctx.fillStyle = asString(color);
                          this.ctx.fill();
                          innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                          this.path(innerPaths);
                          this.ctx.fill();
                          return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
                          styles = paint.container.styles;
                          hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                          borders = [
                              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                          ];
                          backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                          if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
                          this.ctx.save();
                          this.path(backgroundPaintingArea);
                          this.ctx.clip();
                          if (!isTransparent(styles.backgroundColor)) {
                              this.ctx.fillStyle = asString(styles.backgroundColor);
                              this.ctx.fill();
                          }
                          return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
                      case 1:
                          _a.sent();
                          this.ctx.restore();
                          styles.boxShadow
                              .slice(0)
                              .reverse()
                              .forEach(function (shadow) {
                              _this.ctx.save();
                              var borderBoxArea = calculateBorderBoxPath(paint.curves);
                              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                              if (shadow.inset) {
                                  _this.path(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.mask(shadowPaintingArea);
                              }
                              else {
                                  _this.mask(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.path(shadowPaintingArea);
                              }
                              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                              _this.ctx.shadowOffsetY = shadow.offsetY.number;
                              _this.ctx.shadowColor = asString(shadow.color);
                              _this.ctx.shadowBlur = shadow.blur.number;
                              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                              _this.ctx.fill();
                              _this.ctx.restore();
                          });
                          _a.label = 2;
                      case 2:
                          side = 0;
                          _i = 0, borders_1 = borders;
                          _a.label = 3;
                      case 3:
                          if (!(_i < borders_1.length)) return [3 /*break*/, 13];
                          border = borders_1[_i];
                          if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
                          if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
                      case 4:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 5:
                          if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
                      case 6:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 7:
                          if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
                          return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                      case 8:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
                      case 10:
                          _a.sent();
                          _a.label = 11;
                      case 11:
                          side++;
                          _a.label = 12;
                      case 12:
                          _i++;
                          return [3 /*break*/, 3];
                      case 13: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
          return __awaiter(this, void 0, void 0, function () {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function (_a) {
                  this.ctx.save();
                  strokePaths = parsePathForBorderStroke(curvePoints, side);
                  boxPaths = parsePathForBorder(curvePoints, side);
                  if (style === 2 /* DASHED */) {
                      this.path(boxPaths);
                      this.ctx.clip();
                  }
                  if (isBezierCurve(boxPaths[0])) {
                      startX = boxPaths[0].start.x;
                      startY = boxPaths[0].start.y;
                  }
                  else {
                      startX = boxPaths[0].x;
                      startY = boxPaths[0].y;
                  }
                  if (isBezierCurve(boxPaths[1])) {
                      endX = boxPaths[1].end.x;
                      endY = boxPaths[1].end.y;
                  }
                  else {
                      endX = boxPaths[1].x;
                      endY = boxPaths[1].y;
                  }
                  if (side === 0 || side === 2) {
                      length = Math.abs(startX - endX);
                  }
                  else {
                      length = Math.abs(startY - endY);
                  }
                  this.ctx.beginPath();
                  if (style === 3 /* DOTTED */) {
                      this.formatPath(strokePaths);
                  }
                  else {
                      this.formatPath(boxPaths.slice(0, 2));
                  }
                  dashLength = width < 3 ? width * 3 : width * 2;
                  spaceLength = width < 3 ? width * 2 : width;
                  if (style === 3 /* DOTTED */) {
                      dashLength = width;
                      spaceLength = width;
                  }
                  useLineDash = true;
                  if (length <= dashLength * 2) {
                      useLineDash = false;
                  }
                  else if (length <= dashLength * 2 + spaceLength) {
                      multiplier = length / (2 * dashLength + spaceLength);
                      dashLength *= multiplier;
                      spaceLength *= multiplier;
                  }
                  else {
                      numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                      minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                      maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                      spaceLength =
                          maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
                              ? minSpace
                              : maxSpace;
                  }
                  if (useLineDash) {
                      if (style === 3 /* DOTTED */) {
                          this.ctx.setLineDash([0, dashLength + spaceLength]);
                      }
                      else {
                          this.ctx.setLineDash([dashLength, spaceLength]);
                      }
                  }
                  if (style === 3 /* DOTTED */) {
                      this.ctx.lineCap = 'round';
                      this.ctx.lineWidth = width;
                  }
                  else {
                      this.ctx.lineWidth = width * 2 + 1.1;
                  }
                  this.ctx.strokeStyle = asString(color);
                  this.ctx.stroke();
                  this.ctx.setLineDash([]);
                  // dashed round edge gap
                  if (style === 2 /* DASHED */) {
                      if (isBezierCurve(boxPaths[0])) {
                          path1 = boxPaths[3];
                          path2 = boxPaths[0];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                      if (isBezierCurve(boxPaths[1])) {
                          path1 = boxPaths[1];
                          path2 = boxPaths[2];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                  }
                  this.ctx.restore();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var stack;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                          }
                          stack = parseStackingContexts(element);
                          return [4 /*yield*/, this.renderStack(stack)];
                      case 1:
                          _a.sent();
                          this.applyEffects([]);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return CanvasRenderer;
  }(Renderer));
  var isTextInputElement = function (container) {
      if (container instanceof TextareaElementContainer) {
          return true;
      }
      else if (container instanceof SelectElementContainer) {
          return true;
      }
      else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
      }
      return false;
  };
  var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
      switch (clip) {
          case 0 /* BORDER_BOX */:
              return calculateBorderBoxPath(curves);
          case 2 /* CONTENT_BOX */:
              return calculateContentBoxPath(curves);
          case 1 /* PADDING_BOX */:
          default:
              return calculatePaddingBoxPath(curves);
      }
  };
  var canvasTextAlign = function (textAlign) {
      switch (textAlign) {
          case 1 /* CENTER */:
              return 'center';
          case 2 /* RIGHT */:
              return 'right';
          case 0 /* LEFT */:
          default:
              return 'left';
      }
  };
  // see https://github.com/niklasvh/html2canvas/pull/2645
  var iOSBrokenFonts = ['-apple-system', 'system-ui'];
  var fixIOSSystemFonts = function (fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
          ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
          : fontFamilies;
  };

  var ForeignObjectRenderer = /** @class */ (function (_super) {
      __extends(ForeignObjectRenderer, _super);
      function ForeignObjectRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          _this.options = options;
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
          return _this;
      }
      ForeignObjectRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var svg, img;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                          return [4 /*yield*/, loadSerializedSVG(svg)];
                      case 1:
                          img = _a.sent();
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                          }
                          this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return ForeignObjectRenderer;
  }(Renderer));
  var loadSerializedSVG = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () {
              resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };

  var Logger = /** @class */ (function () {
      function Logger(_a) {
          var id = _a.id, enabled = _a.enabled;
          this.id = id;
          this.enabled = enabled;
          this.start = Date.now();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.debug = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
                  // eslint-disable-next-line no-console
                  console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.prototype.getTime = function () {
          return Date.now() - this.start;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.info = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
                  // eslint-disable-next-line no-console
                  console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.warn = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
                  // eslint-disable-next-line no-console
                  console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.error = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
                  // eslint-disable-next-line no-console
                  console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.instances = {};
      return Logger;
  }());

  var Context = /** @class */ (function () {
      function Context(options, windowBounds) {
          var _a;
          this.windowBounds = windowBounds;
          this.instanceName = "#" + Context.instanceCount++;
          this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
          this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
      }
      Context.instanceCount = 1;
      return Context;
  }());

  var html2canvas = function (element, options) {
      if (options === void 0) { options = {}; }
      return renderElement(element, options);
  };
  if (typeof window !== 'undefined') {
      CacheStorage.setContext(window);
  }
  var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
      var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      return __generator(this, function (_u) {
          switch (_u.label) {
              case 0:
                  if (!element || typeof element !== 'object') {
                      return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
                  }
                  ownerDocument = element.ownerDocument;
                  if (!ownerDocument) {
                      throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                      throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                      allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                      imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
                      proxy: opts.proxy,
                      useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
                  windowOptions = {
                      windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                      windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                      scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                      scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                      allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                      onclone: opts.onclone,
                      ignoreElements: opts.ignoreElements,
                      inlineImages: foreignObjectRendering,
                      copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                      return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                  container = _u.sent();
                  _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
                      ? parseDocumentSize(clonedElement.ownerDocument)
                      : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                  backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                      canvas: opts.canvas,
                      backgroundColor: backgroundColor,
                      scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                      x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                      y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                      width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                      height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering) return [3 /*break*/, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(clonedElement)];
              case 2:
                  canvas = _u.sent();
                  return [3 /*break*/, 5];
              case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor === root.styles.backgroundColor) {
                      root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(root)];
              case 4:
                  canvas = _u.sent();
                  _u.label = 5;
              case 5:
                  if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                      if (!DocumentCloner.destroy(container)) {
                          context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                      }
                  }
                  context.logger.debug("Finished rendering");
                  return [2 /*return*/, canvas];
          }
      });
  }); };
  var parseBackgroundColor = function (context, element, backgroundColorOverride) {
      var ownerDocument = element.ownerDocument;
      // http://www.w3.org/TR/css3-background/#special-backgrounds
      var documentBackgroundColor = ownerDocument.documentElement
          ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
          : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body
          ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
          : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
          ? parseColor(context, backgroundColorOverride)
          : backgroundColorOverride === null
              ? COLORS.TRANSPARENT
              : 0xffffffff;
      return element === ownerDocument.documentElement
          ? isTransparent(documentBackgroundColor)
              ? isTransparent(bodyBackgroundColor)
                  ? defaultBackgroundColor
                  : bodyBackgroundColor
              : documentBackgroundColor
          : defaultBackgroundColor;
  };

  var html2canvas_esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': html2canvas
  });

  /*! @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty$1 = Object.hasOwnProperty,
      setPrototypeOf$2 = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf$2 = Object.getPrototypeOf,
      getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create$3 = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply$4 = _ref.apply,
      construct$1 = _ref.construct;

  if (!apply$4) {
    apply$4 = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct$1) {
    construct$1 = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf$2 = unapply(String.prototype.indexOf);
  var stringTrim$1 = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply$4(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct$1(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf$2) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf$2(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create$3(null);

    var property = void 0;
    for (property in object) {
      if (apply$4(hasOwnProperty$1, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor$5(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf$2(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$3 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof$1(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.6';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$3), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */
    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Parsing of strict XHTML documents */
    var PARSER_MEDIA_TYPE = void 0;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc = void 0;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof$1(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      PARSER_MEDIA_TYPE =
      // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
        return x;
      } : stringToLowerCase;

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$3);
          addToSet(ALLOWED_ATTR, html$1$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof$1(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof$1(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = transformCaseFunc(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Mitigate a problem with templates inside select */
      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }

        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
        // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf$2(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */
    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim$1(attr.value);
        lcName = transformCaseFunc(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof$1(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Serialize doctype if allowed */
      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  var purify_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': purify
  });

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global$J =
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () { return this; })() || Function('return this')();

  var objectGetOwnPropertyDescriptor = {};

  var fails$k = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var fails$j = fails$k;

  // Detect IE8's incomplete defineProperty implementation
  var descriptors = !fails$j(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var fails$i = fails$k;

  var functionBindNative = !fails$i(function () {
    var test = (function () { /* empty */ }).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var NATIVE_BIND$3 = functionBindNative;

  var call$f = Function.prototype.call;

  var functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function () {
    return call$f.apply(call$f, arguments);
  };

  var objectPropertyIsEnumerable = {};

  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$4(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;

  var createPropertyDescriptor$4 = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var NATIVE_BIND$2 = functionBindNative;

  var FunctionPrototype$2 = Function.prototype;
  var bind$5 = FunctionPrototype$2.bind;
  var call$e = FunctionPrototype$2.call;
  var uncurryThis$q = NATIVE_BIND$2 && bind$5.bind(call$e, call$e);

  var functionUncurryThis = NATIVE_BIND$2 ? function (fn) {
    return fn && uncurryThis$q(fn);
  } : function (fn) {
    return fn && function () {
      return call$e.apply(fn, arguments);
    };
  };

  var uncurryThis$p = functionUncurryThis;

  var toString$b = uncurryThis$p({}.toString);
  var stringSlice$6 = uncurryThis$p(''.slice);

  var classofRaw$1 = function (it) {
    return stringSlice$6(toString$b(it), 8, -1);
  };

  var global$I = global$J;
  var uncurryThis$o = functionUncurryThis;
  var fails$h = fails$k;
  var classof$8 = classofRaw$1;

  var Object$5 = global$I.Object;
  var split = uncurryThis$o(''.split);

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails$h(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !Object$5('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classof$8(it) == 'String' ? split(it, '') : Object$5(it);
  } : Object$5;

  var global$H = global$J;

  var TypeError$h = global$H.TypeError;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible$a = function (it) {
    if (it == undefined) throw TypeError$h("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings
  var IndexedObject$1 = indexedObject;
  var requireObjectCoercible$9 = requireObjectCoercible$a;

  var toIndexedObject$5 = function (it) {
    return IndexedObject$1(requireObjectCoercible$9(it));
  };

  // `IsCallable` abstract operation
  // https://tc39.es/ecma262/#sec-iscallable
  var isCallable$j = function (argument) {
    return typeof argument == 'function';
  };

  var isCallable$i = isCallable$j;

  var isObject$8 = function (it) {
    return typeof it == 'object' ? it !== null : isCallable$i(it);
  };

  var global$G = global$J;
  var isCallable$h = isCallable$j;

  var aFunction = function (argument) {
    return isCallable$h(argument) ? argument : undefined;
  };

  var getBuiltIn$7 = function (namespace, method) {
    return arguments.length < 2 ? aFunction(global$G[namespace]) : global$G[namespace] && global$G[namespace][method];
  };

  var uncurryThis$n = functionUncurryThis;

  var objectIsPrototypeOf = uncurryThis$n({}.isPrototypeOf);

  var getBuiltIn$6 = getBuiltIn$7;

  var engineUserAgent = getBuiltIn$6('navigator', 'userAgent') || '';

  var global$F = global$J;
  var userAgent$3 = engineUserAgent;

  var process$4 = global$F.process;
  var Deno = global$F.Deno;
  var versions = process$4 && process$4.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }

  // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0
  if (!version && userAgent$3) {
    match = userAgent$3.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent$3.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es/no-symbol -- required for testing */

  var V8_VERSION$1 = engineV8Version;
  var fails$g = fails$k;

  // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$g(function () {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
  });

  /* eslint-disable es/no-symbol -- required for testing */

  var NATIVE_SYMBOL$1 = nativeSymbol;

  var useSymbolAsUid = NATIVE_SYMBOL$1
    && !Symbol.sham
    && typeof Symbol.iterator == 'symbol';

  var global$E = global$J;
  var getBuiltIn$5 = getBuiltIn$7;
  var isCallable$g = isCallable$j;
  var isPrototypeOf$3 = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

  var Object$4 = global$E.Object;

  var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn$5('Symbol');
    return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, Object$4(it));
  };

  var global$D = global$J;

  var String$5 = global$D.String;

  var tryToString$4 = function (argument) {
    try {
      return String$5(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var global$C = global$J;
  var isCallable$f = isCallable$j;
  var tryToString$3 = tryToString$4;

  var TypeError$g = global$C.TypeError;

  // `Assert: IsCallable(argument) is true`
  var aCallable$6 = function (argument) {
    if (isCallable$f(argument)) return argument;
    throw TypeError$g(tryToString$3(argument) + ' is not a function');
  };

  var aCallable$5 = aCallable$6;

  // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod
  var getMethod$6 = function (V, P) {
    var func = V[P];
    return func == null ? undefined : aCallable$5(func);
  };

  var global$B = global$J;
  var call$d = functionCall;
  var isCallable$e = isCallable$j;
  var isObject$7 = isObject$8;

  var TypeError$f = global$B.TypeError;

  // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive
  var ordinaryToPrimitive$1 = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input))) return val;
    if (isCallable$e(fn = input.valueOf) && !isObject$7(val = call$d(fn, input))) return val;
    if (pref !== 'string' && isCallable$e(fn = input.toString) && !isObject$7(val = call$d(fn, input))) return val;
    throw TypeError$f("Can't convert object to primitive value");
  };

  var shared$4 = {exports: {}};

  var global$A = global$J;

  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var defineProperty$2 = Object.defineProperty;

  var setGlobal$3 = function (key, value) {
    try {
      defineProperty$2(global$A, key, { value: value, configurable: true, writable: true });
    } catch (error) {
      global$A[key] = value;
    } return value;
  };

  var global$z = global$J;
  var setGlobal$2 = setGlobal$3;

  var SHARED = '__core-js_shared__';
  var store$3 = global$z[SHARED] || setGlobal$2(SHARED, {});

  var sharedStore = store$3;

  var store$2 = sharedStore;

  (shared$4.exports = function (key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.21.1',
    mode: 'global',
    copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });

  var global$y = global$J;
  var requireObjectCoercible$8 = requireObjectCoercible$a;

  var Object$3 = global$y.Object;

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject$4 = function (argument) {
    return Object$3(requireObjectCoercible$8(argument));
  };

  var uncurryThis$m = functionUncurryThis;
  var toObject$3 = toObject$4;

  var hasOwnProperty = uncurryThis$m({}.hasOwnProperty);

  // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject$3(it), key);
  };

  var uncurryThis$l = functionUncurryThis;

  var id$1 = 0;
  var postfix = Math.random();
  var toString$a = uncurryThis$l(1.0.toString);

  var uid$2 = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$a(++id$1 + postfix, 36);
  };

  var global$x = global$J;
  var shared$3 = shared$4.exports;
  var hasOwn$9 = hasOwnProperty_1;
  var uid$1 = uid$2;
  var NATIVE_SYMBOL = nativeSymbol;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;

  var WellKnownSymbolsStore = shared$3('wks');
  var Symbol$1 = global$x.Symbol;
  var symbolFor = Symbol$1 && Symbol$1['for'];
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;

  var wellKnownSymbol$i = function (name) {
    if (!hasOwn$9(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
      var description = 'Symbol.' + name;
      if (NATIVE_SYMBOL && hasOwn$9(Symbol$1, name)) {
        WellKnownSymbolsStore[name] = Symbol$1[name];
      } else if (USE_SYMBOL_AS_UID && symbolFor) {
        WellKnownSymbolsStore[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
      }
    } return WellKnownSymbolsStore[name];
  };

  var global$w = global$J;
  var call$c = functionCall;
  var isObject$6 = isObject$8;
  var isSymbol$1 = isSymbol$2;
  var getMethod$5 = getMethod$6;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$h = wellKnownSymbol$i;

  var TypeError$e = global$w.TypeError;
  var TO_PRIMITIVE = wellKnownSymbol$h('toPrimitive');

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  var toPrimitive$1 = function (input, pref) {
    if (!isObject$6(input) || isSymbol$1(input)) return input;
    var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = call$c(exoticToPrim, input, pref);
      if (!isObject$6(result) || isSymbol$1(result)) return result;
      throw TypeError$e("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  var toPrimitive = toPrimitive$1;
  var isSymbol = isSymbol$2;

  // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey
  var toPropertyKey$3 = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
  };

  var global$v = global$J;
  var isObject$5 = isObject$8;

  var document$3 = global$v.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS$1 = isObject$5(document$3) && isObject$5(document$3.createElement);

  var documentCreateElement$2 = function (it) {
    return EXISTS$1 ? document$3.createElement(it) : {};
  };

  var DESCRIPTORS$8 = descriptors;
  var fails$f = fails$k;
  var createElement$1 = documentCreateElement$2;

  // Thanks to IE8 for its funny defineProperty
  var ie8DomDefine = !DESCRIPTORS$8 && !fails$f(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(createElement$1('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  var DESCRIPTORS$7 = descriptors;
  var call$b = functionCall;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var createPropertyDescriptor$3 = createPropertyDescriptor$4;
  var toIndexedObject$4 = toIndexedObject$5;
  var toPropertyKey$2 = toPropertyKey$3;
  var hasOwn$8 = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$4(O);
    P = toPropertyKey$2(P);
    if (IE8_DOM_DEFINE$1) try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) { /* empty */ }
    if (hasOwn$8(O, P)) return createPropertyDescriptor$3(!call$b(propertyIsEnumerableModule.f, O, P), O[P]);
  };

  var objectDefineProperty = {};

  var DESCRIPTORS$6 = descriptors;
  var fails$e = fails$k;

  // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334
  var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$e(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () { /* empty */ }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var global$u = global$J;
  var isObject$4 = isObject$8;

  var String$4 = global$u.String;
  var TypeError$d = global$u.TypeError;

  // `Assert: Type(argument) is Object`
  var anObject$g = function (argument) {
    if (isObject$4(argument)) return argument;
    throw TypeError$d(String$4(argument) + ' is not an object');
  };

  var global$t = global$J;
  var DESCRIPTORS$5 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$f = anObject$g;
  var toPropertyKey$1 = toPropertyKey$3;

  var TypeError$c = global$t.TypeError;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var $defineProperty = Object.defineProperty;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE$1 = 'configurable';
  var WRITABLE = 'writable';

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
    anObject$f(O);
    P = toPropertyKey$1(P);
    anObject$f(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    } return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject$f(O);
    P = toPropertyKey$1(P);
    anObject$f(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError$c('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var DESCRIPTORS$4 = descriptors;
  var definePropertyModule$5 = objectDefineProperty;
  var createPropertyDescriptor$2 = createPropertyDescriptor$4;

  var createNonEnumerableProperty$6 = DESCRIPTORS$4 ? function (object, key, value) {
    return definePropertyModule$5.f(object, key, createPropertyDescriptor$2(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var redefine$7 = {exports: {}};

  var uncurryThis$k = functionUncurryThis;
  var isCallable$d = isCallable$j;
  var store$1 = sharedStore;

  var functionToString = uncurryThis$k(Function.toString);

  // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
  if (!isCallable$d(store$1.inspectSource)) {
    store$1.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource$4 = store$1.inspectSource;

  var global$s = global$J;
  var isCallable$c = isCallable$j;
  var inspectSource$3 = inspectSource$4;

  var WeakMap$1 = global$s.WeakMap;

  var nativeWeakMap = isCallable$c(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));

  var shared$2 = shared$4.exports;
  var uid = uid$2;

  var keys = shared$2('keys');

  var sharedKey$3 = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys$4 = {};

  var NATIVE_WEAK_MAP = nativeWeakMap;
  var global$r = global$J;
  var uncurryThis$j = functionUncurryThis;
  var isObject$3 = isObject$8;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
  var hasOwn$7 = hasOwnProperty_1;
  var shared$1 = sharedStore;
  var sharedKey$2 = sharedKey$3;
  var hiddenKeys$3 = hiddenKeys$4;

  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$b = global$r.TypeError;
  var WeakMap = global$r.WeakMap;
  var set$1, get, has;

  var enforce = function (it) {
    return has(it) ? get(it) : set$1(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject$3(it) || (state = get(it)).type !== TYPE) {
        throw TypeError$b('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (NATIVE_WEAK_MAP || shared$1.state) {
    var store = shared$1.state || (shared$1.state = new WeakMap());
    var wmget = uncurryThis$j(store.get);
    var wmhas = uncurryThis$j(store.has);
    var wmset = uncurryThis$j(store.set);
    set$1 = function (it, metadata) {
      if (wmhas(store, it)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      wmset(store, it, metadata);
      return metadata;
    };
    get = function (it) {
      return wmget(store, it) || {};
    };
    has = function (it) {
      return wmhas(store, it);
    };
  } else {
    var STATE = sharedKey$2('state');
    hiddenKeys$3[STATE] = true;
    set$1 = function (it, metadata) {
      if (hasOwn$7(it, STATE)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$5(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return hasOwn$7(it, STATE) ? it[STATE] : {};
    };
    has = function (it) {
      return hasOwn$7(it, STATE);
    };
  }

  var internalState = {
    set: set$1,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var DESCRIPTORS$3 = descriptors;
  var hasOwn$6 = hasOwnProperty_1;

  var FunctionPrototype$1 = Function.prototype;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;

  var EXISTS = hasOwn$6(FunctionPrototype$1, 'name');
  // additional protection from minified / mangled / dropped function names
  var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || (DESCRIPTORS$3 && getDescriptor(FunctionPrototype$1, 'name').configurable));

  var functionName = {
    EXISTS: EXISTS,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE
  };

  var global$q = global$J;
  var isCallable$b = isCallable$j;
  var hasOwn$5 = hasOwnProperty_1;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
  var setGlobal$1 = setGlobal$3;
  var inspectSource$2 = inspectSource$4;
  var InternalStateModule$2 = internalState;
  var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;

  var getInternalState$3 = InternalStateModule$2.get;
  var enforceInternalState = InternalStateModule$2.enforce;
  var TEMPLATE = String(String).split('String');

  (redefine$7.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var name = options && options.name !== undefined ? options.name : key;
    var state;
    if (isCallable$b(value)) {
      if (String(name).slice(0, 7) === 'Symbol(') {
        name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
      }
      if (!hasOwn$5(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name)) {
        createNonEnumerableProperty$4(value, 'name', name);
      }
      state = enforceInternalState(value);
      if (!state.source) {
        state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
      }
    }
    if (O === global$q) {
      if (simple) O[key] = value;
      else setGlobal$1(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$4(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return isCallable$b(this) && getInternalState$3(this).source || inspectSource$2(this);
  });

  var objectGetOwnPropertyNames = {};

  var ceil = Math.ceil;
  var floor$1 = Math.floor;

  // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity
  var toIntegerOrInfinity$4 = function (argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- safe
    return number !== number || number === 0 ? 0 : (number > 0 ? floor$1 : ceil)(number);
  };

  var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;

  var max$2 = Math.max;
  var min$5 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex$2 = function (index, length) {
    var integer = toIntegerOrInfinity$3(index);
    return integer < 0 ? max$2(integer + length, 0) : min$5(integer, length);
  };

  var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;

  var min$4 = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength$6 = function (argument) {
    return argument > 0 ? min$4(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var toLength$5 = toLength$6;

  // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike
  var lengthOfArrayLike$4 = function (obj) {
    return toLength$5(obj.length);
  };

  var toIndexedObject$3 = toIndexedObject$5;
  var toAbsoluteIndex$1 = toAbsoluteIndex$2;
  var lengthOfArrayLike$3 = lengthOfArrayLike$4;

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod$3 = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject$3($this);
      var length = lengthOfArrayLike$3(O);
      var index = toAbsoluteIndex$1(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare -- NaN check
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$3(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$3(false)
  };

  var uncurryThis$i = functionUncurryThis;
  var hasOwn$4 = hasOwnProperty_1;
  var toIndexedObject$2 = toIndexedObject$5;
  var indexOf$1 = arrayIncludes.indexOf;
  var hiddenKeys$2 = hiddenKeys$4;

  var push$2 = uncurryThis$i([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject$2(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O, key) && push$2(result, key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (hasOwn$4(O, key = names[i++])) {
      ~indexOf$1(result, key) || push$2(result, key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys$3 = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;

  var hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys$1);
  };

  var objectGetOwnPropertySymbols = {};

  // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

  var getBuiltIn$4 = getBuiltIn$7;
  var uncurryThis$h = functionUncurryThis;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var anObject$e = anObject$g;

  var concat$1 = uncurryThis$h([].concat);

  // all object keys, includes non-enumerable and symbols
  var ownKeys$4 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject$e(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
  };

  var hasOwn$3 = hasOwnProperty_1;
  var ownKeys$3 = ownKeys$4;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule$4 = objectDefineProperty;

  var copyConstructorProperties$1 = function (target, source, exceptions) {
    var keys = ownKeys$3(source);
    var defineProperty = definePropertyModule$4.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };

  var fails$d = fails$k;
  var isCallable$a = isCallable$j;

  var replacement = /#|\.prototype\./;

  var isForced$2 = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : isCallable$a(detection) ? fails$d(detection)
      : !!detection;
  };

  var normalize = isForced$2.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced$2.data = {};
  var NATIVE = isForced$2.NATIVE = 'N';
  var POLYFILL = isForced$2.POLYFILL = 'P';

  var isForced_1 = isForced$2;

  var global$p = global$J;
  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
  var redefine$6 = redefine$7.exports;
  var setGlobal = setGlobal$3;
  var copyConstructorProperties = copyConstructorProperties$1;
  var isForced$1 = isForced_1;

  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
    options.name        - the .name of the function if it does not match the key
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global$p;
    } else if (STATIC) {
      target = global$p[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global$p[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contained in target
      if (!FORCED && targetProperty !== undefined) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty$3(sourceProperty, 'sham', true);
      }
      // extend global
      redefine$6(target, key, sourceProperty, options);
    }
  };

  var global$o = global$J;

  var nativePromiseConstructor = global$o.Promise;

  var redefine$5 = redefine$7.exports;

  var redefineAll$1 = function (target, src, options) {
    for (var key in src) redefine$5(target, key, src[key], options);
    return target;
  };

  var global$n = global$J;
  var isCallable$9 = isCallable$j;

  var String$3 = global$n.String;
  var TypeError$a = global$n.TypeError;

  var aPossiblePrototype$1 = function (argument) {
    if (typeof argument == 'object' || isCallable$9(argument)) return argument;
    throw TypeError$a("Can't set " + String$3(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */

  var uncurryThis$g = functionUncurryThis;
  var anObject$d = anObject$g;
  var aPossiblePrototype = aPossiblePrototype$1;

  // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe
  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = uncurryThis$g(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject$d(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  var defineProperty$1 = objectDefineProperty.f;
  var hasOwn$2 = hasOwnProperty_1;
  var wellKnownSymbol$g = wellKnownSymbol$i;

  var TO_STRING_TAG$3 = wellKnownSymbol$g('toStringTag');

  var setToStringTag$3 = function (target, TAG, STATIC) {
    if (target && !STATIC) target = target.prototype;
    if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {
      defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
    }
  };

  var getBuiltIn$3 = getBuiltIn$7;
  var definePropertyModule$3 = objectDefineProperty;
  var wellKnownSymbol$f = wellKnownSymbol$i;
  var DESCRIPTORS$2 = descriptors;

  var SPECIES$3 = wellKnownSymbol$f('species');

  var setSpecies$1 = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule$3.f;

    if (DESCRIPTORS$2 && Constructor && !Constructor[SPECIES$3]) {
      defineProperty(Constructor, SPECIES$3, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var global$m = global$J;
  var isPrototypeOf$2 = objectIsPrototypeOf;

  var TypeError$9 = global$m.TypeError;

  var anInstance$1 = function (it, Prototype) {
    if (isPrototypeOf$2(Prototype, it)) return it;
    throw TypeError$9('Incorrect invocation');
  };

  var uncurryThis$f = functionUncurryThis;
  var aCallable$4 = aCallable$6;
  var NATIVE_BIND$1 = functionBindNative;

  var bind$4 = uncurryThis$f(uncurryThis$f.bind);

  // optional / simple context binding
  var functionBindContext = function (fn, that) {
    aCallable$4(fn);
    return that === undefined ? fn : NATIVE_BIND$1 ? bind$4(fn, that) : function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var iterators = {};

  var wellKnownSymbol$e = wellKnownSymbol$i;
  var Iterators$4 = iterators;

  var ITERATOR$5 = wellKnownSymbol$e('iterator');
  var ArrayPrototype$1 = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod$1 = function (it) {
    return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
  };

  var wellKnownSymbol$d = wellKnownSymbol$i;

  var TO_STRING_TAG$2 = wellKnownSymbol$d('toStringTag');
  var test$1 = {};

  test$1[TO_STRING_TAG$2] = 'z';

  var toStringTagSupport = String(test$1) === '[object z]';

  var global$l = global$J;
  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var isCallable$8 = isCallable$j;
  var classofRaw = classofRaw$1;
  var wellKnownSymbol$c = wellKnownSymbol$i;

  var TO_STRING_TAG$1 = wellKnownSymbol$c('toStringTag');
  var Object$2 = global$l.Object;

  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof$7 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = Object$2(it), TO_STRING_TAG$1)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable$8(O.callee) ? 'Arguments' : result;
  };

  var classof$6 = classof$7;
  var getMethod$4 = getMethod$6;
  var Iterators$3 = iterators;
  var wellKnownSymbol$b = wellKnownSymbol$i;

  var ITERATOR$4 = wellKnownSymbol$b('iterator');

  var getIteratorMethod$2 = function (it) {
    if (it != undefined) return getMethod$4(it, ITERATOR$4)
      || getMethod$4(it, '@@iterator')
      || Iterators$3[classof$6(it)];
  };

  var global$k = global$J;
  var call$a = functionCall;
  var aCallable$3 = aCallable$6;
  var anObject$c = anObject$g;
  var tryToString$2 = tryToString$4;
  var getIteratorMethod$1 = getIteratorMethod$2;

  var TypeError$8 = global$k.TypeError;

  var getIterator$1 = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
    if (aCallable$3(iteratorMethod)) return anObject$c(call$a(iteratorMethod, argument));
    throw TypeError$8(tryToString$2(argument) + ' is not iterable');
  };

  var call$9 = functionCall;
  var anObject$b = anObject$g;
  var getMethod$3 = getMethod$6;

  var iteratorClose$1 = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject$b(iterator);
    try {
      innerResult = getMethod$3(iterator, 'return');
      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }
      innerResult = call$9(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject$b(innerResult);
    return value;
  };

  var global$j = global$J;
  var bind$3 = functionBindContext;
  var call$8 = functionCall;
  var anObject$a = anObject$g;
  var tryToString$1 = tryToString$4;
  var isArrayIteratorMethod = isArrayIteratorMethod$1;
  var lengthOfArrayLike$2 = lengthOfArrayLike$4;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var getIterator = getIterator$1;
  var getIteratorMethod = getIteratorMethod$2;
  var iteratorClose = iteratorClose$1;

  var TypeError$7 = global$j.TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate$1 = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind$3(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject$a(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      } return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw TypeError$7(tryToString$1(iterable) + ' is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && isPrototypeOf$1(ResultPrototype, result)) return result;
        } return new Result(false);
      }
      iterator = getIterator(iterable, iterFn);
    }

    next = iterator.next;
    while (!(step = call$8(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
      if (typeof result == 'object' && result && isPrototypeOf$1(ResultPrototype, result)) return result;
    } return new Result(false);
  };

  var wellKnownSymbol$a = wellKnownSymbol$i;

  var ITERATOR$3 = wellKnownSymbol$a('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return { done: !!called++ };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$3] = function () {
      return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function () { throw 2; });
  } catch (error) { /* empty */ }

  var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$3] = function () {
        return {
          next: function () {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
  };

  var uncurryThis$e = functionUncurryThis;
  var fails$c = fails$k;
  var isCallable$7 = isCallable$j;
  var classof$5 = classof$7;
  var getBuiltIn$2 = getBuiltIn$7;
  var inspectSource$1 = inspectSource$4;

  var noop$1 = function () { /* empty */ };
  var empty = [];
  var construct = getBuiltIn$2('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec$2 = uncurryThis$e(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$1);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;
    try {
      construct(noop$1, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable$7(argument)) return false;
    switch (classof$5(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction': return false;
    }
    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true;

  // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor
  var isConstructor$1 = !construct || fails$c(function () {
    var called;
    return isConstructorModern(isConstructorModern.call)
      || !isConstructorModern(Object)
      || !isConstructorModern(function () { called = true; })
      || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var global$i = global$J;
  var isConstructor = isConstructor$1;
  var tryToString = tryToString$4;

  var TypeError$6 = global$i.TypeError;

  // `Assert: IsConstructor(argument) is true`
  var aConstructor$1 = function (argument) {
    if (isConstructor(argument)) return argument;
    throw TypeError$6(tryToString(argument) + ' is not a constructor');
  };

  var anObject$9 = anObject$g;
  var aConstructor = aConstructor$1;
  var wellKnownSymbol$9 = wellKnownSymbol$i;

  var SPECIES$2 = wellKnownSymbol$9('species');

  // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor
  var speciesConstructor$2 = function (O, defaultConstructor) {
    var C = anObject$9(O).constructor;
    var S;
    return C === undefined || (S = anObject$9(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);
  };

  var NATIVE_BIND = functionBindNative;

  var FunctionPrototype = Function.prototype;
  var apply$3 = FunctionPrototype.apply;
  var call$7 = FunctionPrototype.call;

  // eslint-disable-next-line es/no-reflect -- safe
  var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$7.bind(apply$3) : function () {
    return call$7.apply(apply$3, arguments);
  });

  var getBuiltIn$1 = getBuiltIn$7;

  var html$2 = getBuiltIn$1('document', 'documentElement');

  var uncurryThis$d = functionUncurryThis;

  var arraySlice$2 = uncurryThis$d([].slice);

  var global$h = global$J;

  var TypeError$5 = global$h.TypeError;

  var validateArgumentsLength$1 = function (passed, required) {
    if (passed < required) throw TypeError$5('Not enough arguments');
    return passed;
  };

  var userAgent$2 = engineUserAgent;

  var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);

  var classof$4 = classofRaw$1;
  var global$g = global$J;

  var engineIsNode = classof$4(global$g.process) == 'process';

  var global$f = global$J;
  var apply$2 = functionApply;
  var bind$2 = functionBindContext;
  var isCallable$6 = isCallable$j;
  var hasOwn$1 = hasOwnProperty_1;
  var fails$b = fails$k;
  var html$1 = html$2;
  var arraySlice$1 = arraySlice$2;
  var createElement = documentCreateElement$2;
  var validateArgumentsLength = validateArgumentsLength$1;
  var IS_IOS$1 = engineIsIos;
  var IS_NODE$3 = engineIsNode;

  var set = global$f.setImmediate;
  var clear = global$f.clearImmediate;
  var process$3 = global$f.process;
  var Dispatch = global$f.Dispatch;
  var Function$1 = global$f.Function;
  var MessageChannel = global$f.MessageChannel;
  var String$2 = global$f.String;
  var counter = 0;
  var queue$2 = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var location$1, defer, channel, port;

  try {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    location$1 = global$f.location;
  } catch (error) { /* empty */ }

  var run = function (id) {
    if (hasOwn$1(queue$2, id)) {
      var fn = queue$2[id];
      delete queue$2[id];
      fn();
    }
  };

  var runner = function (id) {
    return function () {
      run(id);
    };
  };

  var listener = function (event) {
    run(event.data);
  };

  var post = function (id) {
    // old engines have not location.origin
    global$f.postMessage(String$2(id), location$1.protocol + '//' + location$1.host);
  };

  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!set || !clear) {
    set = function setImmediate(handler) {
      validateArgumentsLength(arguments.length, 1);
      var fn = isCallable$6(handler) ? handler : Function$1(handler);
      var args = arraySlice$1(arguments, 1);
      queue$2[++counter] = function () {
        apply$2(fn, undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue$2[id];
    };
    // Node.js 0.8-
    if (IS_NODE$3) {
      defer = function (id) {
        process$3.nextTick(runner(id));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(runner(id));
      };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !IS_IOS$1) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = bind$2(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
      global$f.addEventListener &&
      isCallable$6(global$f.postMessage) &&
      !global$f.importScripts &&
      location$1 && location$1.protocol !== 'file:' &&
      !fails$b(post)
    ) {
      defer = post;
      global$f.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in createElement('script')) {
      defer = function (id) {
        html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
          html$1.removeChild(this);
          run(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task$1 = {
    set: set,
    clear: clear
  };

  var userAgent$1 = engineUserAgent;
  var global$e = global$J;

  var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && global$e.Pebble !== undefined;

  var userAgent = engineUserAgent;

  var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

  var global$d = global$J;
  var bind$1 = functionBindContext;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task$1.set;
  var IS_IOS = engineIsIos;
  var IS_IOS_PEBBLE = engineIsIosPebble;
  var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
  var IS_NODE$2 = engineIsNode;

  var MutationObserver = global$d.MutationObserver || global$d.WebKitMutationObserver;
  var document$2 = global$d.document;
  var process$2 = global$d.process;
  var Promise$1 = global$d.Promise;
  // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global$d, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

  var flush, head, last$1, notify$1, toggle, node$1, promise, then;

  // modern engines have queueMicrotask method
  if (!queueMicrotask) {
    flush = function () {
      var parent, fn;
      if (IS_NODE$2 && (parent = process$2.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error) {
          if (head) notify$1();
          else last$1 = undefined;
          throw error;
        }
      } last$1 = undefined;
      if (parent) parent.enter();
    };

    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
      toggle = true;
      node$1 = document$2.createTextNode('');
      new MutationObserver(flush).observe(node$1, { characterData: true });
      notify$1 = function () {
        node$1.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      // workaround of WebKit ~ iOS Safari 10.1 bug
      promise.constructor = Promise$1;
      then = bind$1(promise.then, promise);
      notify$1 = function () {
        then(flush);
      };
    // Node.js without promises
    } else if (IS_NODE$2) {
      notify$1 = function () {
        process$2.nextTick(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      // strange IE + webpack dev server bug - use .bind(global)
      macrotask = bind$1(macrotask, global$d);
      notify$1 = function () {
        macrotask(flush);
      };
    }
  }

  var microtask$1 = queueMicrotask || function (fn) {
    var task = { fn: fn, next: undefined };
    if (last$1) last$1.next = task;
    if (!head) {
      head = task;
      notify$1();
    } last$1 = task;
  };

  var newPromiseCapability$2 = {};

  var aCallable$2 = aCallable$6;

  var PromiseCapability = function (C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aCallable$2(resolve);
    this.reject = aCallable$2(reject);
  };

  // `NewPromiseCapability` abstract operation
  // https://tc39.es/ecma262/#sec-newpromisecapability
  newPromiseCapability$2.f = function (C) {
    return new PromiseCapability(C);
  };

  var anObject$8 = anObject$g;
  var isObject$2 = isObject$8;
  var newPromiseCapability$1 = newPromiseCapability$2;

  var promiseResolve$1 = function (C, x) {
    anObject$8(C);
    if (isObject$2(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$1.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var global$c = global$J;

  var hostReportErrors$1 = function (a, b) {
    var console = global$c.console;
    if (console && console.error) {
      arguments.length == 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform$1 = function (exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };

  var Queue$1 = function () {
    this.head = null;
    this.tail = null;
  };

  Queue$1.prototype = {
    add: function (item) {
      var entry = { item: item, next: null };
      if (this.head) this.tail.next = entry;
      else this.head = entry;
      this.tail = entry;
    },
    get: function () {
      var entry = this.head;
      if (entry) {
        this.head = entry.next;
        if (this.tail === entry) this.tail = null;
        return entry.item;
      }
    }
  };

  var queue$1 = Queue$1;

  var engineIsBrowser = typeof window == 'object';

  var $$9 = _export;
  var global$b = global$J;
  var getBuiltIn = getBuiltIn$7;
  var call$6 = functionCall;
  var NativePromise = nativePromiseConstructor;
  var redefine$4 = redefine$7.exports;
  var redefineAll = redefineAll$1;
  var setPrototypeOf$1 = objectSetPrototypeOf;
  var setToStringTag$2 = setToStringTag$3;
  var setSpecies = setSpecies$1;
  var aCallable$1 = aCallable$6;
  var isCallable$5 = isCallable$j;
  var isObject$1 = isObject$8;
  var anInstance = anInstance$1;
  var inspectSource = inspectSource$4;
  var iterate = iterate$1;
  var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
  var speciesConstructor$1 = speciesConstructor$2;
  var task = task$1.set;
  var microtask = microtask$1;
  var promiseResolve = promiseResolve$1;
  var hostReportErrors = hostReportErrors$1;
  var newPromiseCapabilityModule = newPromiseCapability$2;
  var perform = perform$1;
  var Queue = queue$1;
  var InternalStateModule$1 = internalState;
  var isForced = isForced_1;
  var wellKnownSymbol$8 = wellKnownSymbol$i;
  var IS_BROWSER = engineIsBrowser;
  var IS_NODE$1 = engineIsNode;
  var V8_VERSION = engineV8Version;

  var SPECIES$1 = wellKnownSymbol$8('species');
  var PROMISE = 'Promise';

  var getInternalState$2 = InternalStateModule$1.getterFor(PROMISE);
  var setInternalState$1 = InternalStateModule$1.set;
  var getInternalPromiseState = InternalStateModule$1.getterFor(PROMISE);
  var NativePromisePrototype = NativePromise && NativePromise.prototype;
  var PromiseConstructor = NativePromise;
  var PromisePrototype = NativePromisePrototype;
  var TypeError$4 = global$b.TypeError;
  var document$1 = global$b.document;
  var process$1 = global$b.process;
  var newPromiseCapability = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability;

  var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$b.dispatchEvent);
  var NATIVE_REJECTION_EVENT = isCallable$5(global$b.PromiseRejectionEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var SUBCLASSING = false;

  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  var FORCED = isForced(PROMISE, function () {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = new PromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES$1] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
  });

  var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
  });

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject$1(it) && isCallable$5(then = it.then) ? then : false;
  };

  var callReaction = function (reaction, state) {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
      if (handler) {
        if (!ok) {
          if (state.rejection === UNHANDLED) onHandleUnhandled(state);
          state.rejection = HANDLED;
        }
        if (handler === true) result = value;
        else {
          if (domain) domain.enter();
          result = handler(value); // can throw
          if (domain) {
            domain.exit();
            exited = true;
          }
        }
        if (result === reaction.promise) {
          reject(TypeError$4('Promise-chain cycle'));
        } else if (then = isThenable(result)) {
          call$6(then, result, resolve, reject);
        } else resolve(result);
      } else reject(value);
    } catch (error) {
      if (domain && !exited) domain.exit();
      reject(error);
    }
  };

  var notify = function (state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function () {
      var reactions = state.reactions;
      var reaction;
      while (reaction = reactions.get()) {
        callReaction(reaction, state);
      }
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$1.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global$b.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (!NATIVE_REJECTION_EVENT && (handler = global$b['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (state) {
    call$6(task, global$b, function () {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$1.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (state) {
    call$6(task, global$b, function () {
      var promise = state.facade;
      if (IS_NODE$1) {
        process$1.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function (fn, state, unwrap) {
    return function (value) {
      fn(state, value, unwrap);
    };
  };

  var internalReject = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
  };

  var internalResolve = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw TypeError$4("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            call$6(then, value,
              bind(internalResolve, wrapper, state),
              bind(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromisePrototype);
      aCallable$1(executor);
      call$6(Internal, this);
      var state = getInternalState$2(this);
      try {
        executor(bind(internalResolve, state), bind(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    PromisePrototype = PromiseConstructor.prototype;
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
      setInternalState$1(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: new Queue(),
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };
    Internal.prototype = redefineAll(PromisePrototype, {
      // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then
      // eslint-disable-next-line unicorn/no-thenable -- safe
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable$5(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$5(onRejected) && onRejected;
        reaction.domain = IS_NODE$1 ? process$1.domain : undefined;
        if (state.state == PENDING) state.reactions.add(reaction);
        else microtask(function () {
          callReaction(reaction, state);
        });
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.es/ecma262/#sec-promise.prototype.catch
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalState$2(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, state);
      this.reject = bind(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if (isCallable$5(NativePromise) && NativePromisePrototype !== Object.prototype) {
      nativeThen = NativePromisePrototype.then;

      if (!SUBCLASSING) {
        // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
        redefine$4(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function (resolve, reject) {
            call$6(nativeThen, that, resolve, reject);
          }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
        }, { unsafe: true });

        // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
        redefine$4(NativePromisePrototype, 'catch', PromisePrototype['catch'], { unsafe: true });
      }

      // make `.constructor === Promise` work for native promise-based APIs
      try {
        delete NativePromisePrototype.constructor;
      } catch (error) { /* empty */ }

      // make `instanceof Promise` work for native promise-based APIs
      if (setPrototypeOf$1) {
        setPrototypeOf$1(NativePromisePrototype, PromisePrototype);
      }
    }
  }

  $$9({ global: true, wrap: true, forced: FORCED }, {
    Promise: PromiseConstructor
  });

  setToStringTag$2(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);

  PromiseWrapper = getBuiltIn(PROMISE);

  // statics
  $$9({ target: PROMISE, stat: true, forced: FORCED }, {
    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      call$6(capability.reject, undefined, r);
      return capability.promise;
    }
  });

  $$9({ target: PROMISE, stat: true, forced: FORCED }, {
    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve(this, x);
    }
  });

  $$9({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          remaining++;
          call$6($promiseResolve, C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable$1(C.resolve);
        iterate(iterable, function (promise) {
          call$6($promiseResolve, C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var global$a = global$J;
  var classof$3 = classof$7;

  var String$1 = global$a.String;

  var toString$9 = function (argument) {
    if (classof$3(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return String$1(argument);
  };

  var anObject$7 = anObject$g;

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags$1 = function () {
    var that = anObject$7(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
  };

  var fails$a = fails$k;
  var global$9 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var $RegExp$2 = global$9.RegExp;

  var UNSUPPORTED_Y$2 = fails$a(function () {
    var re = $RegExp$2('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });

  // UC Browser bug
  // https://github.com/zloirock/core-js/issues/1008
  var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$a(function () {
    return !$RegExp$2('a', 'y').sticky;
  });

  var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$a(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = $RegExp$2('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });

  var regexpStickyHelpers = {
    BROKEN_CARET: BROKEN_CARET,
    MISSED_STICKY: MISSED_STICKY,
    UNSUPPORTED_Y: UNSUPPORTED_Y$2
  };

  var objectDefineProperties = {};

  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys$1 = enumBugKeys$3;

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe
  var objectKeys$1 = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys$1);
  };

  var DESCRIPTORS$1 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule$2 = objectDefineProperty;
  var anObject$6 = anObject$g;
  var toIndexedObject$1 = toIndexedObject$5;
  var objectKeys = objectKeys$1;

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe
  objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$6(O);
    var props = toIndexedObject$1(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);
    return O;
  };

  /* global ActiveXObject -- old IE, WSH */

  var anObject$5 = anObject$g;
  var definePropertiesModule = objectDefineProperties;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys = hiddenKeys$4;
  var html = html$2;
  var documentCreateElement$1 = documentCreateElement$2;
  var sharedKey$1 = sharedKey$3;

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO$1 = sharedKey$1('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement$1('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = typeof document != 'undefined'
      ? document.domain && activeXDocument
        ? NullProtoObjectViaActiveX(activeXDocument) // old IE
        : NullProtoObjectViaIFrame()
      : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO$1] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$5(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
  };

  var fails$9 = fails$k;
  var global$8 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
  var $RegExp$1 = global$8.RegExp;

  var regexpUnsupportedDotAll = fails$9(function () {
    var re = $RegExp$1('.', 's');
    return !(re.dotAll && re.exec('\n') && re.flags === 's');
  });

  var fails$8 = fails$k;
  var global$7 = global$J;

  // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
  var $RegExp = global$7.RegExp;

  var regexpUnsupportedNcg = fails$8(function () {
    var re = $RegExp('(?<a>b)', 'g');
    return re.exec('b').groups.a !== 'b' ||
      'b'.replace(re, '$<a>c') !== 'bc';
  });

  /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
  /* eslint-disable regexp/no-useless-quantifier -- testing */
  var call$5 = functionCall;
  var uncurryThis$c = functionUncurryThis;
  var toString$8 = toString$9;
  var regexpFlags = regexpFlags$1;
  var stickyHelpers$1 = regexpStickyHelpers;
  var shared = shared$4.exports;
  var create$2 = objectCreate;
  var getInternalState$1 = internalState.get;
  var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
  var UNSUPPORTED_NCG = regexpUnsupportedNcg;

  var nativeReplace = shared('native-string-replace', String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt$3 = uncurryThis$c(''.charAt);
  var indexOf = uncurryThis$c(''.indexOf);
  var replace$2 = uncurryThis$c(''.replace);
  var stringSlice$5 = uncurryThis$c(''.slice);

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    call$5(nativeExec, re1, 'a');
    call$5(nativeExec, re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

  if (PATCH) {
    patchedExec = function exec(string) {
      var re = this;
      var state = getInternalState$1(re);
      var str = toString$8(string);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i, object, group;

      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call$5(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
      }

      var groups = state.groups;
      var sticky = UNSUPPORTED_Y$1 && re.sticky;
      var flags = call$5(regexpFlags, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = replace$2(flags, 'y', '');
        if (indexOf(flags, 'g') === -1) {
          flags += 'g';
        }

        strCopy = stringSlice$5(str, re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = call$5(nativeExec, sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = stringSlice$5(match.input, charsAdded);
          match[0] = stringSlice$5(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
        call$5(nativeReplace, match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      if (match && groups) {
        match.groups = object = create$2(null);
        for (i = 0; i < groups.length; i++) {
          group = groups[i];
          object[group[0]] = match[group[1]];
        }
      }

      return match;
    };
  }

  var regexpExec$3 = patchedExec;

  var $$8 = _export;
  var exec$1 = regexpExec$3;

  // `RegExp.prototype.exec` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.exec
  $$8({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {
    exec: exec$1
  });

  // TODO: Remove from `core-js@4` since it's moved to entry points

  var uncurryThis$b = functionUncurryThis;
  var redefine$3 = redefine$7.exports;
  var regexpExec$2 = regexpExec$3;
  var fails$7 = fails$k;
  var wellKnownSymbol$7 = wellKnownSymbol$i;
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;

  var SPECIES = wellKnownSymbol$7('species');
  var RegExpPrototype$1 = RegExp.prototype;

  var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol$7(KEY);

    var DELEGATES_TO_SYMBOL = !fails$7(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$7(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES] = function () { return re; };
        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      FORCED
    ) {
      var uncurriedNativeRegExpMethod = uncurryThis$b(/./[SYMBOL]);
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        var uncurriedNativeMethod = uncurryThis$b(nativeMethod);
        var $exec = regexp.exec;
        if ($exec === regexpExec$2 || $exec === RegExpPrototype$1.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
          }
          return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
        }
        return { done: false };
      });

      redefine$3(String.prototype, KEY, methods[0]);
      redefine$3(RegExpPrototype$1, SYMBOL, methods[1]);
    }

    if (SHAM) createNonEnumerableProperty$2(RegExpPrototype$1[SYMBOL], 'sham', true);
  };

  var uncurryThis$a = functionUncurryThis;
  var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
  var toString$7 = toString$9;
  var requireObjectCoercible$7 = requireObjectCoercible$a;

  var charAt$2 = uncurryThis$a(''.charAt);
  var charCodeAt = uncurryThis$a(''.charCodeAt);
  var stringSlice$4 = uncurryThis$a(''.slice);

  var createMethod$2 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString$7(requireObjectCoercible$7($this));
      var position = toIntegerOrInfinity$1(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING
            ? charAt$2(S, position)
            : first
          : CONVERT_TO_STRING
            ? stringSlice$4(S, position, position + 2)
            : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$2(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$2(true)
  };

  var charAt$1 = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.es/ecma262/#sec-advancestringindex
  var advanceStringIndex$3 = function (S, index, unicode) {
    return index + (unicode ? charAt$1(S, index).length : 1);
  };

  var global$6 = global$J;
  var call$4 = functionCall;
  var anObject$4 = anObject$g;
  var isCallable$4 = isCallable$j;
  var classof$2 = classofRaw$1;
  var regexpExec$1 = regexpExec$3;

  var TypeError$3 = global$6.TypeError;

  // `RegExpExec` abstract operation
  // https://tc39.es/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (isCallable$4(exec)) {
      var result = call$4(exec, R, S);
      if (result !== null) anObject$4(result);
      return result;
    }
    if (classof$2(R) === 'RegExp') return call$4(regexpExec$1, R, S);
    throw TypeError$3('RegExp#exec called on incompatible receiver');
  };

  var call$3 = functionCall;
  var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
  var anObject$3 = anObject$g;
  var toLength$4 = toLength$6;
  var toString$6 = toString$9;
  var requireObjectCoercible$6 = requireObjectCoercible$a;
  var getMethod$2 = getMethod$6;
  var advanceStringIndex$2 = advanceStringIndex$3;
  var regExpExec$1 = regexpExecAbstract;

  // @@match logic
  fixRegExpWellKnownSymbolLogic$2('match', function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible$6(this);
        var matcher = regexp == undefined ? undefined : getMethod$2(regexp, MATCH);
        return matcher ? call$3(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString$6(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (string) {
        var rx = anObject$3(this);
        var S = toString$6(string);
        var res = maybeCallNative(nativeMatch, rx, S);

        if (res.done) return res.value;

        if (!rx.global) return regExpExec$1(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec$1(rx, S)) !== null) {
          var matchStr = toString$6(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex$2(S, toLength$4(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  var uncurryThis$9 = functionUncurryThis;
  var toObject$2 = toObject$4;

  var floor = Math.floor;
  var charAt = uncurryThis$9(''.charAt);
  var replace$1 = uncurryThis$9(''.replace);
  var stringSlice$3 = uncurryThis$9(''.slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

  // `GetSubstitution` abstract operation
  // https://tc39.es/ecma262/#sec-getsubstitution
  var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject$2(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace$1(replacement, symbols, function (match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return stringSlice$3(str, 0, position);
        case "'": return stringSlice$3(str, tailPos);
        case '<':
          capture = namedCaptures[stringSlice$3(ch, 1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  };

  var apply$1 = functionApply;
  var call$2 = functionCall;
  var uncurryThis$8 = functionUncurryThis;
  var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
  var fails$6 = fails$k;
  var anObject$2 = anObject$g;
  var isCallable$3 = isCallable$j;
  var toIntegerOrInfinity = toIntegerOrInfinity$4;
  var toLength$3 = toLength$6;
  var toString$5 = toString$9;
  var requireObjectCoercible$5 = requireObjectCoercible$a;
  var advanceStringIndex$1 = advanceStringIndex$3;
  var getMethod$1 = getMethod$6;
  var getSubstitution = getSubstitution$1;
  var regExpExec = regexpExecAbstract;
  var wellKnownSymbol$6 = wellKnownSymbol$i;

  var REPLACE = wellKnownSymbol$6('replace');
  var max$1 = Math.max;
  var min$3 = Math.min;
  var concat = uncurryThis$8([].concat);
  var push$1 = uncurryThis$8([].push);
  var stringIndexOf$1 = uncurryThis$8(''.indexOf);
  var stringSlice$2 = uncurryThis$8(''.slice);

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
    return 'a'.replace(/./, '$0') === '$0';
  })();

  // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }
    return false;
  })();

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails$6(function () {
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
    return ''.replace(re, '$<a>') !== '7';
  });

  // @@replace logic
  fixRegExpWellKnownSymbolLogic$1('replace', function (_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible$5(this);
        var replacer = searchValue == undefined ? undefined : getMethod$1(searchValue, REPLACE);
        return replacer
          ? call$2(replacer, searchValue, O, replaceValue)
          : call$2(nativeReplace, toString$5(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (string, replaceValue) {
        var rx = anObject$2(this);
        var S = toString$5(string);

        if (
          typeof replaceValue == 'string' &&
          stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
          stringIndexOf$1(replaceValue, '$<') === -1
        ) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }

        var functionalReplace = isCallable$3(replaceValue);
        if (!functionalReplace) replaceValue = toString$5(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;

          push$1(results, result);
          if (!global) break;

          var matchStr = toString$5(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex$1(S, toLength$3(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = toString$5(result[0]);
          var position = max$1(min$3(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) push$1(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined) push$1(replacerArgs, namedCaptures);
            var replacement = toString$5(apply$1(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice$2(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice$2(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

  var isObject = isObject$8;
  var classof$1 = classofRaw$1;
  var wellKnownSymbol$5 = wellKnownSymbol$i;

  var MATCH$1 = wellKnownSymbol$5('match');

  // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$1(it) == 'RegExp');
  };

  var global$5 = global$J;
  var isRegExp$1 = isRegexp;

  var TypeError$2 = global$5.TypeError;

  var notARegexp = function (it) {
    if (isRegExp$1(it)) {
      throw TypeError$2("The method doesn't accept regular expressions");
    } return it;
  };

  var wellKnownSymbol$4 = wellKnownSymbol$i;

  var MATCH = wellKnownSymbol$4('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) { /* empty */ }
    } return false;
  };

  var $$7 = _export;
  var uncurryThis$7 = functionUncurryThis;
  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  var toLength$2 = toLength$6;
  var toString$4 = toString$9;
  var notARegExp$2 = notARegexp;
  var requireObjectCoercible$4 = requireObjectCoercible$a;
  var correctIsRegExpLogic$2 = correctIsRegexpLogic;

  // eslint-disable-next-line es/no-string-prototype-startswith -- safe
  var un$StartsWith = uncurryThis$7(''.startsWith);
  var stringSlice$1 = uncurryThis$7(''.slice);
  var min$2 = Math.min;

  var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegExpLogic$2('startsWith');
  // https://github.com/zloirock/core-js/pull/702
  var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
    var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'startsWith');
    return descriptor && !descriptor.writable;
  }();

  // `String.prototype.startsWith` method
  // https://tc39.es/ecma262/#sec-string.prototype.startswith
  $$7({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
    startsWith: function startsWith(searchString /* , position = 0 */) {
      var that = toString$4(requireObjectCoercible$4(this));
      notARegExp$2(searchString);
      var index = toLength$2(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));
      var search = toString$4(searchString);
      return un$StartsWith
        ? un$StartsWith(that, search, index)
        : stringSlice$1(that, index, index + search.length) === search;
    }
  });

  var wellKnownSymbol$3 = wellKnownSymbol$i;
  var create$1 = objectCreate;
  var definePropertyModule$1 = objectDefineProperty;

  var UNSCOPABLES = wellKnownSymbol$3('unscopables');
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    definePropertyModule$1.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create$1(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables$1 = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var fails$5 = fails$k;

  var correctPrototypeGetter = !fails$5(function () {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var global$4 = global$J;
  var hasOwn = hasOwnProperty_1;
  var isCallable$2 = isCallable$j;
  var toObject$1 = toObject$4;
  var sharedKey = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

  var IE_PROTO = sharedKey('IE_PROTO');
  var Object$1 = global$4.Object;
  var ObjectPrototype = Object$1.prototype;

  // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function (O) {
    var object = toObject$1(O);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable$2(constructor) && object instanceof constructor) {
      return constructor.prototype;
    } return object instanceof Object$1 ? ObjectPrototype : null;
  };

  var fails$4 = fails$k;
  var isCallable$1 = isCallable$j;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var redefine$2 = redefine$7.exports;
  var wellKnownSymbol$2 = wellKnownSymbol$i;

  var ITERATOR$2 = wellKnownSymbol$2('iterator');
  var BUGGY_SAFARI_ITERATORS$1 = false;

  // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

  /* eslint-disable es/no-array-prototype-keys -- safe */
  if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$4(function () {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype$2[ITERATOR$2].call(test) !== test;
  });

  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

  // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
  if (!isCallable$1(IteratorPrototype$2[ITERATOR$2])) {
    redefine$2(IteratorPrototype$2, ITERATOR$2, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$2,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
  var create = objectCreate;
  var createPropertyDescriptor$1 = createPropertyDescriptor$4;
  var setToStringTag$1 = setToStringTag$3;
  var Iterators$2 = iterators;

  var returnThis$1 = function () { return this; };

  var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });
    setToStringTag$1(IteratorConstructor, TO_STRING_TAG, false);
    Iterators$2[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var $$6 = _export;
  var call$1 = functionCall;
  var FunctionName = functionName;
  var isCallable = isCallable$j;
  var createIteratorConstructor = createIteratorConstructor$1;
  var getPrototypeOf = objectGetPrototypeOf;
  var setPrototypeOf = objectSetPrototypeOf;
  var setToStringTag = setToStringTag$3;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
  var redefine$1 = redefine$7.exports;
  var wellKnownSymbol$1 = wellKnownSymbol$i;
  var Iterators$1 = iterators;
  var IteratorsCore = iteratorsCore;

  var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol$1('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis = function () { return this; };

  var defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
        case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
        case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
      } return function () { return new IteratorConstructor(this); };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1]
      || IterablePrototype['@@iterator']
      || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$1])) {
            redefine$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
          }
        }
        // Set @@toStringTag to native iterators
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    }

    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() { return call$1(nativeIterator, this); };
      }
    }

    // export additional methods
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine$1(IterablePrototype, KEY, methods[KEY]);
        }
      } else $$6({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }

    // define iterator
    if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
      redefine$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
    }
    Iterators$1[NAME] = defaultIterator;

    return methods;
  };

  var toIndexedObject = toIndexedObject$5;
  var addToUnscopables = addToUnscopables$1;
  var Iterators = iterators;
  var InternalStateModule = internalState;
  var defineProperty = objectDefineProperty.f;
  var defineIterator = defineIterator$1;
  var DESCRIPTORS = descriptors;

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return { value: undefined, done: true };
    }
    if (kind == 'keys') return { value: index, done: false };
    if (kind == 'values') return { value: target[index], done: false };
    return { value: [index, target[index]], done: false };
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  var values = Iterators.Arguments = Iterators.Array;

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  // V8 ~ Chrome 45- bug
  if (DESCRIPTORS && values.name !== 'values') try {
    defineProperty(values, 'name', { value: 'values' });
  } catch (error) { /* empty */ }

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
  var documentCreateElement = documentCreateElement$2;

  var classList = documentCreateElement('span').classList;
  var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;

  var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;

  var global$3 = global$J;
  var DOMIterables = domIterables;
  var DOMTokenListPrototype = domTokenListPrototype;
  var ArrayIteratorMethods = es_array_iterator;
  var createNonEnumerableProperty = createNonEnumerableProperty$6;
  var wellKnownSymbol = wellKnownSymbol$i;

  var ITERATOR = wellKnownSymbol('iterator');
  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var ArrayValues = ArrayIteratorMethods.values;

  var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
    if (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
      if (!CollectionPrototype[TO_STRING_TAG]) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
      }
      if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
        }
      }
    }
  };

  for (var COLLECTION_NAME in DOMIterables) {
    handlePrototype(global$3[COLLECTION_NAME] && global$3[COLLECTION_NAME].prototype, COLLECTION_NAME);
  }

  handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var global$2 = global$J;
  var aCallable = aCallable$6;
  var toObject = toObject$4;
  var IndexedObject = indexedObject;
  var lengthOfArrayLike$1 = lengthOfArrayLike$4;

  var TypeError$1 = global$2.TypeError;

  // `Array.prototype.{ reduce, reduceRight }` methods implementation
  var createMethod$1 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aCallable(callbackfn);
      var O = toObject(that);
      var self = IndexedObject(O);
      var length = lengthOfArrayLike$1(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw TypeError$1('Reduce of empty array with no initial value');
        }
      }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$1(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$1(true)
  };

  var fails$3 = fails$k;

  var arrayMethodIsStrict$2 = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails$3(function () {
      // eslint-disable-next-line no-useless-call -- required for testing
      method.call(null, argument || function () { return 1; }, 1);
    });
  };

  var $$5 = _export;
  var $reduce = arrayReduce.left;
  var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
  var CHROME_VERSION = engineV8Version;
  var IS_NODE = engineIsNode;

  var STRICT_METHOD$1 = arrayMethodIsStrict$1('reduce');
  // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;

  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  $$5({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {
    reduce: function reduce(callbackfn /* , initialValue */) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });

  var $$4 = _export;
  var uncurryThis$6 = functionUncurryThis;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var toLength$1 = toLength$6;
  var toString$3 = toString$9;
  var notARegExp$1 = notARegexp;
  var requireObjectCoercible$3 = requireObjectCoercible$a;
  var correctIsRegExpLogic$1 = correctIsRegexpLogic;

  // eslint-disable-next-line es/no-string-prototype-endswith -- safe
  var un$EndsWith = uncurryThis$6(''.endsWith);
  var slice = uncurryThis$6(''.slice);
  var min$1 = Math.min;

  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1('endsWith');
  // https://github.com/zloirock/core-js/pull/702
  var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
    var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
    return descriptor && !descriptor.writable;
  }();

  // `String.prototype.endsWith` method
  // https://tc39.es/ecma262/#sec-string.prototype.endswith
  $$4({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    endsWith: function endsWith(searchString /* , endPosition = @length */) {
      var that = toString$3(requireObjectCoercible$3(this));
      notARegExp$1(searchString);
      var endPosition = arguments.length > 1 ? arguments[1] : undefined;
      var len = that.length;
      var end = endPosition === undefined ? len : min$1(toLength$1(endPosition), len);
      var search = toString$3(searchString);
      return un$EndsWith
        ? un$EndsWith(that, search, end)
        : slice(that, end - search.length, end) === search;
    }
  });

  var toPropertyKey = toPropertyKey$3;
  var definePropertyModule = objectDefineProperty;
  var createPropertyDescriptor = createPropertyDescriptor$4;

  var createProperty$1 = function (object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var global$1 = global$J;
  var toAbsoluteIndex = toAbsoluteIndex$2;
  var lengthOfArrayLike = lengthOfArrayLike$4;
  var createProperty = createProperty$1;

  var Array$1 = global$1.Array;
  var max = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = Array$1(max(fin - k, 0));
    for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  };

  var apply = functionApply;
  var call = functionCall;
  var uncurryThis$5 = functionUncurryThis;
  var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
  var isRegExp = isRegexp;
  var anObject$1 = anObject$g;
  var requireObjectCoercible$2 = requireObjectCoercible$a;
  var speciesConstructor = speciesConstructor$2;
  var advanceStringIndex = advanceStringIndex$3;
  var toLength = toLength$6;
  var toString$2 = toString$9;
  var getMethod = getMethod$6;
  var arraySlice = arraySliceSimple;
  var callRegExpExec = regexpExecAbstract;
  var regexpExec = regexpExec$3;
  var stickyHelpers = regexpStickyHelpers;
  var fails$2 = fails$k;

  var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
  var MAX_UINT32 = 0xFFFFFFFF;
  var min = Math.min;
  var $push = [].push;
  var exec = uncurryThis$5(/./.exec);
  var push = uncurryThis$5($push);
  var stringSlice = uncurryThis$5(''.slice);

  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$2(function () {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  // @@split logic
  fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = toString$2(requireObjectCoercible$2(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) {
          return call(nativeSplit, string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = call(regexpExec, separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            push(output, stringSlice(string, lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !exec(separatorCopy, '')) push(output, '');
        } else push(output, stringSlice(string, lastLastIndex));
        return output.length > lim ? arraySlice(output, 0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible$2(this);
        var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
        return splitter
          ? call(splitter, separator, O, limit)
          : call(internalSplit, toString$2(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (string, limit) {
        var rx = anObject$1(this);
        var S = toString$2(string);
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

        if (res.done) return res.value;

        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (UNSUPPORTED_Y ? 'g' : 'y');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
          var e;
          if (
            z === null ||
            (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push(A, stringSlice(S, p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              push(A, z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        push(A, stringSlice(S, p));
        return A;
      }
    ];
  }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

  var raf$1 = {exports: {}};

  var performanceNow = {exports: {}};

  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      performanceNow.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      performanceNow.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(commonjsGlobal);

  var now = performanceNow.exports
    , root = typeof window === 'undefined' ? commonjsGlobal : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root['request' + suffix]
    , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for(var i$1 = 0; !raf && i$1 < vendors.length; i$1++) {
    raf = root[vendors[i$1] + 'Request' + suffix];
    caf = root[vendors[i$1] + 'Cancel' + suffix]
        || root[vendors[i$1] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = now()
          , next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  raf$1.exports = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn)
  };
  raf$1.exports.cancel = function() {
    caf.apply(root, arguments);
  };
  raf$1.exports.polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };

  var requestAnimationFrame$1 = raf$1.exports;

  // a string of all valid unicode whitespaces
  var whitespaces$2 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
    '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var uncurryThis$4 = functionUncurryThis;
  var requireObjectCoercible$1 = requireObjectCoercible$a;
  var toString$1 = toString$9;
  var whitespaces$1 = whitespaces$2;

  var replace = uncurryThis$4(''.replace);
  var whitespace = '[' + whitespaces$1 + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$');

  // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
  var createMethod = function (TYPE) {
    return function ($this) {
      var string = toString$1(requireObjectCoercible$1($this));
      if (TYPE & 1) string = replace(string, ltrim, '');
      if (TYPE & 2) string = replace(string, rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };

  var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
  var fails$1 = fails$k;
  var whitespaces = whitespaces$2;

  var non = '\u200B\u0085\u180E';

  // check that a method works with the correct list
  // of whitespaces and has a correct name
  var stringTrimForced = function (METHOD_NAME) {
    return fails$1(function () {
      return !!whitespaces[METHOD_NAME]()
        || non[METHOD_NAME]() !== non
        || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);
    });
  };

  var $$3 = _export;
  var $trim = stringTrim.trim;
  var forcedStringTrimMethod = stringTrimForced;

  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  $$3({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  /*
  	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
  	http://www.phpied.com/rgb-color-parser-in-javascript/
  */

  var rgbcolor = function(color_string) {
      this.ok = false;
      this.alpha = 1.0;

      // strip any leading #
      if (color_string.charAt(0) == '#') { // remove # if any
          color_string = color_string.substr(1,6);
      }

      color_string = color_string.replace(/ /g,'');
      color_string = color_string.toLowerCase();

      // before getting into regexps, try simple matches
      // and overwrite the input
      var simple_colors = {
          aliceblue: 'f0f8ff',
          antiquewhite: 'faebd7',
          aqua: '00ffff',
          aquamarine: '7fffd4',
          azure: 'f0ffff',
          beige: 'f5f5dc',
          bisque: 'ffe4c4',
          black: '000000',
          blanchedalmond: 'ffebcd',
          blue: '0000ff',
          blueviolet: '8a2be2',
          brown: 'a52a2a',
          burlywood: 'deb887',
          cadetblue: '5f9ea0',
          chartreuse: '7fff00',
          chocolate: 'd2691e',
          coral: 'ff7f50',
          cornflowerblue: '6495ed',
          cornsilk: 'fff8dc',
          crimson: 'dc143c',
          cyan: '00ffff',
          darkblue: '00008b',
          darkcyan: '008b8b',
          darkgoldenrod: 'b8860b',
          darkgray: 'a9a9a9',
          darkgreen: '006400',
          darkkhaki: 'bdb76b',
          darkmagenta: '8b008b',
          darkolivegreen: '556b2f',
          darkorange: 'ff8c00',
          darkorchid: '9932cc',
          darkred: '8b0000',
          darksalmon: 'e9967a',
          darkseagreen: '8fbc8f',
          darkslateblue: '483d8b',
          darkslategray: '2f4f4f',
          darkturquoise: '00ced1',
          darkviolet: '9400d3',
          deeppink: 'ff1493',
          deepskyblue: '00bfff',
          dimgray: '696969',
          dodgerblue: '1e90ff',
          feldspar: 'd19275',
          firebrick: 'b22222',
          floralwhite: 'fffaf0',
          forestgreen: '228b22',
          fuchsia: 'ff00ff',
          gainsboro: 'dcdcdc',
          ghostwhite: 'f8f8ff',
          gold: 'ffd700',
          goldenrod: 'daa520',
          gray: '808080',
          green: '008000',
          greenyellow: 'adff2f',
          honeydew: 'f0fff0',
          hotpink: 'ff69b4',
          indianred : 'cd5c5c',
          indigo : '4b0082',
          ivory: 'fffff0',
          khaki: 'f0e68c',
          lavender: 'e6e6fa',
          lavenderblush: 'fff0f5',
          lawngreen: '7cfc00',
          lemonchiffon: 'fffacd',
          lightblue: 'add8e6',
          lightcoral: 'f08080',
          lightcyan: 'e0ffff',
          lightgoldenrodyellow: 'fafad2',
          lightgrey: 'd3d3d3',
          lightgreen: '90ee90',
          lightpink: 'ffb6c1',
          lightsalmon: 'ffa07a',
          lightseagreen: '20b2aa',
          lightskyblue: '87cefa',
          lightslateblue: '8470ff',
          lightslategray: '778899',
          lightsteelblue: 'b0c4de',
          lightyellow: 'ffffe0',
          lime: '00ff00',
          limegreen: '32cd32',
          linen: 'faf0e6',
          magenta: 'ff00ff',
          maroon: '800000',
          mediumaquamarine: '66cdaa',
          mediumblue: '0000cd',
          mediumorchid: 'ba55d3',
          mediumpurple: '9370d8',
          mediumseagreen: '3cb371',
          mediumslateblue: '7b68ee',
          mediumspringgreen: '00fa9a',
          mediumturquoise: '48d1cc',
          mediumvioletred: 'c71585',
          midnightblue: '191970',
          mintcream: 'f5fffa',
          mistyrose: 'ffe4e1',
          moccasin: 'ffe4b5',
          navajowhite: 'ffdead',
          navy: '000080',
          oldlace: 'fdf5e6',
          olive: '808000',
          olivedrab: '6b8e23',
          orange: 'ffa500',
          orangered: 'ff4500',
          orchid: 'da70d6',
          palegoldenrod: 'eee8aa',
          palegreen: '98fb98',
          paleturquoise: 'afeeee',
          palevioletred: 'd87093',
          papayawhip: 'ffefd5',
          peachpuff: 'ffdab9',
          peru: 'cd853f',
          pink: 'ffc0cb',
          plum: 'dda0dd',
          powderblue: 'b0e0e6',
          purple: '800080',
          rebeccapurple: '663399',
          red: 'ff0000',
          rosybrown: 'bc8f8f',
          royalblue: '4169e1',
          saddlebrown: '8b4513',
          salmon: 'fa8072',
          sandybrown: 'f4a460',
          seagreen: '2e8b57',
          seashell: 'fff5ee',
          sienna: 'a0522d',
          silver: 'c0c0c0',
          skyblue: '87ceeb',
          slateblue: '6a5acd',
          slategray: '708090',
          snow: 'fffafa',
          springgreen: '00ff7f',
          steelblue: '4682b4',
          tan: 'd2b48c',
          teal: '008080',
          thistle: 'd8bfd8',
          tomato: 'ff6347',
          turquoise: '40e0d0',
          violet: 'ee82ee',
          violetred: 'd02090',
          wheat: 'f5deb3',
          white: 'ffffff',
          whitesmoke: 'f5f5f5',
          yellow: 'ffff00',
          yellowgreen: '9acd32'
      };
      color_string = simple_colors[color_string] || color_string;
      // emd of simple type-in colors

      // array of color definition objects
      var color_defs = [
          {
              re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
              example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
              process: function (bits){
                  return [
                      parseInt(bits[1]),
                      parseInt(bits[2]),
                      parseInt(bits[3]),
                      parseFloat(bits[4])
                  ];
              }
          },
          {
              re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
              example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
              process: function (bits){
                  return [
                      parseInt(bits[1]),
                      parseInt(bits[2]),
                      parseInt(bits[3])
                  ];
              }
          },
          {
              re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              example: ['#00ff00', '336699'],
              process: function (bits){
                  return [
                      parseInt(bits[1], 16),
                      parseInt(bits[2], 16),
                      parseInt(bits[3], 16)
                  ];
              }
          },
          {
              re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              example: ['#fb0', 'f0f'],
              process: function (bits){
                  return [
                      parseInt(bits[1] + bits[1], 16),
                      parseInt(bits[2] + bits[2], 16),
                      parseInt(bits[3] + bits[3], 16)
                  ];
              }
          }
      ];

      // search through the definitions to find a match
      for (var i = 0; i < color_defs.length; i++) {
          var re = color_defs[i].re;
          var processor = color_defs[i].process;
          var bits = re.exec(color_string);
          if (bits) {
              var channels = processor(bits);
              this.r = channels[0];
              this.g = channels[1];
              this.b = channels[2];
              if (channels.length > 3) {
                  this.alpha = channels[3];
              }
              this.ok = true;
          }

      }

      // validate/cleanup values
      this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
      this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
      this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
      this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

      // some getters
      this.toRGB = function () {
          return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
      };
      this.toRGBA = function () {
          return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
      };
      this.toHex = function () {
          var r = this.r.toString(16);
          var g = this.g.toString(16);
          var b = this.b.toString(16);
          if (r.length == 1) r = '0' + r;
          if (g.length == 1) g = '0' + g;
          if (b.length == 1) b = '0' + b;
          return '#' + r + g + b;
      };

      // help
      this.getHelpXML = function () {

          var examples = new Array();
          // add regexps
          for (var i = 0; i < color_defs.length; i++) {
              var example = color_defs[i].example;
              for (var j = 0; j < example.length; j++) {
                  examples[examples.length] = example[j];
              }
          }
          // add type-in colors
          for (var sc in simple_colors) {
              examples[examples.length] = sc;
          }

          var xml = document.createElement('ul');
          xml.setAttribute('id', 'rgbcolor-examples');
          for (var i = 0; i < examples.length; i++) {
              try {
                  var list_item = document.createElement('li');
                  var list_color = new RGBColor(examples[i]);
                  var example_div = document.createElement('div');
                  example_div.style.cssText =
                          'margin: 3px; '
                          + 'border: 1px solid black; '
                          + 'background:' + list_color.toHex() + '; '
                          + 'color:' + list_color.toHex()
                  ;
                  example_div.appendChild(document.createTextNode('test'));
                  var list_item_value = document.createTextNode(
                      ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                  );
                  list_item.appendChild(example_div);
                  list_item.appendChild(list_item_value);
                  xml.appendChild(list_item);

              } catch(e){}
          }
          return xml;

      };

  };

  /* eslint-disable es/no-array-prototype-indexof -- required for testing */
  var $$2 = _export;
  var uncurryThis$3 = functionUncurryThis;
  var $IndexOf = arrayIncludes.indexOf;
  var arrayMethodIsStrict = arrayMethodIsStrict$2;

  var un$IndexOf = uncurryThis$3([].indexOf);

  var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
  var STRICT_METHOD = arrayMethodIsStrict('indexOf');

  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  $$2({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? un$IndexOf(this, searchElement, fromIndex) || 0
        : $IndexOf(this, searchElement, fromIndex);
    }
  });

  var $$1 = _export;
  var uncurryThis$2 = functionUncurryThis;
  var notARegExp = notARegexp;
  var requireObjectCoercible = requireObjectCoercible$a;
  var toString = toString$9;
  var correctIsRegExpLogic = correctIsRegexpLogic;

  var stringIndexOf = uncurryThis$2(''.indexOf);

  // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes
  $$1({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~stringIndexOf(
        toString(requireObjectCoercible(this)),
        toString(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : undefined
      );
    }
  });

  var classof = classofRaw$1;

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe
  var isArray$1 = Array.isArray || function isArray(argument) {
    return classof(argument) == 'Array';
  };

  var $ = _export;
  var uncurryThis$1 = functionUncurryThis;
  var isArray = isArray$1;

  var un$Reverse = uncurryThis$1([].reverse);
  var test = [1, 2];

  // `Array.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-array.prototype.reverse
  // fix for Safari 12.0 bug
  // https://bugs.webkit.org/show_bug.cgi?id=188794
  $({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
    reverse: function reverse() {
      // eslint-disable-next-line no-self-assign -- dirty hack
      if (isArray(this)) this.length = this.length;
      return un$Reverse(this);
    }
  });

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var t=function(r,e){return (t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r;}||function(t,r){for(var e in r)Object.prototype.hasOwnProperty.call(r,e)&&(t[e]=r[e]);})(r,e)};function r(r,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function i(){this.constructor=r;}t(r,e),r.prototype=null===e?Object.create(e):(i.prototype=e.prototype,new i);}function e(t){var r="";Array.isArray(t)||(t=[t]);for(var e=0;e<t.length;e++){var i=t[e];if(i.type===_.CLOSE_PATH)r+="z";else if(i.type===_.HORIZ_LINE_TO)r+=(i.relative?"h":"H")+i.x;else if(i.type===_.VERT_LINE_TO)r+=(i.relative?"v":"V")+i.y;else if(i.type===_.MOVE_TO)r+=(i.relative?"m":"M")+i.x+" "+i.y;else if(i.type===_.LINE_TO)r+=(i.relative?"l":"L")+i.x+" "+i.y;else if(i.type===_.CURVE_TO)r+=(i.relative?"c":"C")+i.x1+" "+i.y1+" "+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_CURVE_TO)r+=(i.relative?"s":"S")+i.x2+" "+i.y2+" "+i.x+" "+i.y;else if(i.type===_.QUAD_TO)r+=(i.relative?"q":"Q")+i.x1+" "+i.y1+" "+i.x+" "+i.y;else if(i.type===_.SMOOTH_QUAD_TO)r+=(i.relative?"t":"T")+i.x+" "+i.y;else {if(i.type!==_.ARC)throw new Error('Unexpected command type "'+i.type+'" at index '+e+".");r+=(i.relative?"a":"A")+i.rX+" "+i.rY+" "+i.xRot+" "+ +i.lArcFlag+" "+ +i.sweepFlag+" "+i.x+" "+i.y;}}return r}function i(t,r){var e=t[0],i=t[1];return [e*Math.cos(r)-i*Math.sin(r),e*Math.sin(r)+i*Math.cos(r)]}function a(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var e=0;e<t.length;e++)if("number"!=typeof t[e])throw new Error("assertNumbers arguments["+e+"] is not a number. "+typeof t[e]+" == typeof "+t[e]);return !0}var n=Math.PI;function o(t,r,e){t.lArcFlag=0===t.lArcFlag?0:1,t.sweepFlag=0===t.sweepFlag?0:1;var a=t.rX,o=t.rY,s=t.x,u=t.y;a=Math.abs(t.rX),o=Math.abs(t.rY);var h=i([(r-s)/2,(e-u)/2],-t.xRot/180*n),c=h[0],y=h[1],p=Math.pow(c,2)/Math.pow(a,2)+Math.pow(y,2)/Math.pow(o,2);1<p&&(a*=Math.sqrt(p),o*=Math.sqrt(p)),t.rX=a,t.rY=o;var m=Math.pow(a,2)*Math.pow(y,2)+Math.pow(o,2)*Math.pow(c,2),O=(t.lArcFlag!==t.sweepFlag?1:-1)*Math.sqrt(Math.max(0,(Math.pow(a,2)*Math.pow(o,2)-m)/m)),l=a*y/o*O,T=-o*c/a*O,v=i([l,T],t.xRot/180*n);t.cX=v[0]+(r+s)/2,t.cY=v[1]+(e+u)/2,t.phi1=Math.atan2((y-T)/o,(c-l)/a),t.phi2=Math.atan2((-y-T)/o,(-c-l)/a),0===t.sweepFlag&&t.phi2>t.phi1&&(t.phi2-=2*n),1===t.sweepFlag&&t.phi2<t.phi1&&(t.phi2+=2*n),t.phi1*=180/n,t.phi2*=180/n;}function s(t,r,e){a(t,r,e);var i=t*t+r*r-e*e;if(0>i)return [];if(0===i)return [[t*e/(t*t+r*r),r*e/(t*t+r*r)]];var n=Math.sqrt(i);return [[(t*e+r*n)/(t*t+r*r),(r*e-t*n)/(t*t+r*r)],[(t*e-r*n)/(t*t+r*r),(r*e+t*n)/(t*t+r*r)]]}var u,h=Math.PI/180;function c$1(t,r,e){return (1-e)*t+e*r}function y(t,r,e,i){return t+Math.cos(i/180*n)*r+Math.sin(i/180*n)*e}function p(t,r,e,i){var a=1e-6,n=r-t,o=e-r,s=3*n+3*(i-e)-6*o,u=6*(o-n),h=3*n;return Math.abs(s)<a?[-h/u]:function(t,r,e){void 0===e&&(e=1e-6);var i=t*t/4-r;if(i<-e)return [];if(i<=e)return [-t/2];var a=Math.sqrt(i);return [-t/2-a,-t/2+a]}(u/s,h/s,a)}function m$1(t,r,e,i,a){var n=1-a;return t*(n*n*n)+r*(3*n*n*a)+e*(3*n*a*a)+i*(a*a*a)}!function(t){function r(){return u((function(t,r,e){return t.relative&&(void 0!==t.x1&&(t.x1+=r),void 0!==t.y1&&(t.y1+=e),void 0!==t.x2&&(t.x2+=r),void 0!==t.y2&&(t.y2+=e),void 0!==t.x&&(t.x+=r),void 0!==t.y&&(t.y+=e),t.relative=!1),t}))}function e(){var t=NaN,r=NaN,e=NaN,i=NaN;return u((function(a,n,o){return a.type&_.SMOOTH_CURVE_TO&&(a.type=_.CURVE_TO,t=isNaN(t)?n:t,r=isNaN(r)?o:r,a.x1=a.relative?n-t:2*n-t,a.y1=a.relative?o-r:2*o-r),a.type&_.CURVE_TO?(t=a.relative?n+a.x2:a.x2,r=a.relative?o+a.y2:a.y2):(t=NaN,r=NaN),a.type&_.SMOOTH_QUAD_TO&&(a.type=_.QUAD_TO,e=isNaN(e)?n:e,i=isNaN(i)?o:i,a.x1=a.relative?n-e:2*n-e,a.y1=a.relative?o-i:2*o-i),a.type&_.QUAD_TO?(e=a.relative?n+a.x1:a.x1,i=a.relative?o+a.y1:a.y1):(e=NaN,i=NaN),a}))}function n(){var t=NaN,r=NaN;return u((function(e,i,a){if(e.type&_.SMOOTH_QUAD_TO&&(e.type=_.QUAD_TO,t=isNaN(t)?i:t,r=isNaN(r)?a:r,e.x1=e.relative?i-t:2*i-t,e.y1=e.relative?a-r:2*a-r),e.type&_.QUAD_TO){t=e.relative?i+e.x1:e.x1,r=e.relative?a+e.y1:e.y1;var n=e.x1,o=e.y1;e.type=_.CURVE_TO,e.x1=((e.relative?0:i)+2*n)/3,e.y1=((e.relative?0:a)+2*o)/3,e.x2=(e.x+2*n)/3,e.y2=(e.y+2*o)/3;}else t=NaN,r=NaN;return e}))}function u(t){var r=0,e=0,i=NaN,a=NaN;return function(n){if(isNaN(i)&&!(n.type&_.MOVE_TO))throw new Error("path must start with moveto");var o=t(n,r,e,i,a);return n.type&_.CLOSE_PATH&&(r=i,e=a),void 0!==n.x&&(r=n.relative?r+n.x:n.x),void 0!==n.y&&(e=n.relative?e+n.y:n.y),n.type&_.MOVE_TO&&(i=r,a=e),o}}function O(t,r,e,i,n,o){return a(t,r,e,i,n,o),u((function(a,s,u,h){var c=a.x1,y=a.x2,p=a.relative&&!isNaN(h),m=void 0!==a.x?a.x:p?0:s,O=void 0!==a.y?a.y:p?0:u;function l(t){return t*t}a.type&_.HORIZ_LINE_TO&&0!==r&&(a.type=_.LINE_TO,a.y=a.relative?0:u),a.type&_.VERT_LINE_TO&&0!==e&&(a.type=_.LINE_TO,a.x=a.relative?0:s),void 0!==a.x&&(a.x=a.x*t+O*e+(p?0:n)),void 0!==a.y&&(a.y=m*r+a.y*i+(p?0:o)),void 0!==a.x1&&(a.x1=a.x1*t+a.y1*e+(p?0:n)),void 0!==a.y1&&(a.y1=c*r+a.y1*i+(p?0:o)),void 0!==a.x2&&(a.x2=a.x2*t+a.y2*e+(p?0:n)),void 0!==a.y2&&(a.y2=y*r+a.y2*i+(p?0:o));var T=t*i-r*e;if(void 0!==a.xRot&&(1!==t||0!==r||0!==e||1!==i))if(0===T)delete a.rX,delete a.rY,delete a.xRot,delete a.lArcFlag,delete a.sweepFlag,a.type=_.LINE_TO;else {var v=a.xRot*Math.PI/180,f=Math.sin(v),N=Math.cos(v),x=1/l(a.rX),d=1/l(a.rY),E=l(N)*x+l(f)*d,A=2*f*N*(x-d),C=l(f)*x+l(N)*d,M=E*i*i-A*r*i+C*r*r,R=A*(t*i+r*e)-2*(E*e*i+C*t*r),g=E*e*e-A*t*e+C*t*t,I=(Math.atan2(R,M-g)+Math.PI)%Math.PI/2,S=Math.sin(I),L=Math.cos(I);a.rX=Math.abs(T)/Math.sqrt(M*l(L)+R*S*L+g*l(S)),a.rY=Math.abs(T)/Math.sqrt(M*l(S)-R*S*L+g*l(L)),a.xRot=180*I/Math.PI;}return void 0!==a.sweepFlag&&0>T&&(a.sweepFlag=+!a.sweepFlag),a}))}function l(){return function(t){var r={};for(var e in t)r[e]=t[e];return r}}t.ROUND=function(t){function r(r){return Math.round(r*t)/t}return void 0===t&&(t=1e13),a(t),function(t){return void 0!==t.x1&&(t.x1=r(t.x1)),void 0!==t.y1&&(t.y1=r(t.y1)),void 0!==t.x2&&(t.x2=r(t.x2)),void 0!==t.y2&&(t.y2=r(t.y2)),void 0!==t.x&&(t.x=r(t.x)),void 0!==t.y&&(t.y=r(t.y)),void 0!==t.rX&&(t.rX=r(t.rX)),void 0!==t.rY&&(t.rY=r(t.rY)),t}},t.TO_ABS=r,t.TO_REL=function(){return u((function(t,r,e){return t.relative||(void 0!==t.x1&&(t.x1-=r),void 0!==t.y1&&(t.y1-=e),void 0!==t.x2&&(t.x2-=r),void 0!==t.y2&&(t.y2-=e),void 0!==t.x&&(t.x-=r),void 0!==t.y&&(t.y-=e),t.relative=!0),t}))},t.NORMALIZE_HVZ=function(t,r,e){return void 0===t&&(t=!0),void 0===r&&(r=!0),void 0===e&&(e=!0),u((function(i,a,n,o,s){if(isNaN(o)&&!(i.type&_.MOVE_TO))throw new Error("path must start with moveto");return r&&i.type&_.HORIZ_LINE_TO&&(i.type=_.LINE_TO,i.y=i.relative?0:n),e&&i.type&_.VERT_LINE_TO&&(i.type=_.LINE_TO,i.x=i.relative?0:a),t&&i.type&_.CLOSE_PATH&&(i.type=_.LINE_TO,i.x=i.relative?o-a:o,i.y=i.relative?s-n:s),i.type&_.ARC&&(0===i.rX||0===i.rY)&&(i.type=_.LINE_TO,delete i.rX,delete i.rY,delete i.xRot,delete i.lArcFlag,delete i.sweepFlag),i}))},t.NORMALIZE_ST=e,t.QT_TO_C=n,t.INFO=u,t.SANITIZE=function(t){void 0===t&&(t=0),a(t);var r=NaN,e=NaN,i=NaN,n=NaN;return u((function(a,o,s,u,h){var c=Math.abs,y=!1,p=0,m=0;if(a.type&_.SMOOTH_CURVE_TO&&(p=isNaN(r)?0:o-r,m=isNaN(e)?0:s-e),a.type&(_.CURVE_TO|_.SMOOTH_CURVE_TO)?(r=a.relative?o+a.x2:a.x2,e=a.relative?s+a.y2:a.y2):(r=NaN,e=NaN),a.type&_.SMOOTH_QUAD_TO?(i=isNaN(i)?o:2*o-i,n=isNaN(n)?s:2*s-n):a.type&_.QUAD_TO?(i=a.relative?o+a.x1:a.x1,n=a.relative?s+a.y1:a.y2):(i=NaN,n=NaN),a.type&_.LINE_COMMANDS||a.type&_.ARC&&(0===a.rX||0===a.rY||!a.lArcFlag)||a.type&_.CURVE_TO||a.type&_.SMOOTH_CURVE_TO||a.type&_.QUAD_TO||a.type&_.SMOOTH_QUAD_TO){var O=void 0===a.x?0:a.relative?a.x:a.x-o,l=void 0===a.y?0:a.relative?a.y:a.y-s;p=isNaN(i)?void 0===a.x1?p:a.relative?a.x:a.x1-o:i-o,m=isNaN(n)?void 0===a.y1?m:a.relative?a.y:a.y1-s:n-s;var T=void 0===a.x2?0:a.relative?a.x:a.x2-o,v=void 0===a.y2?0:a.relative?a.y:a.y2-s;c(O)<=t&&c(l)<=t&&c(p)<=t&&c(m)<=t&&c(T)<=t&&c(v)<=t&&(y=!0);}return a.type&_.CLOSE_PATH&&c(o-u)<=t&&c(s-h)<=t&&(y=!0),y?[]:a}))},t.MATRIX=O,t.ROTATE=function(t,r,e){void 0===r&&(r=0),void 0===e&&(e=0),a(t,r,e);var i=Math.sin(t),n=Math.cos(t);return O(n,i,-i,n,r-r*n+e*i,e-r*i-e*n)},t.TRANSLATE=function(t,r){return void 0===r&&(r=0),a(t,r),O(1,0,0,1,t,r)},t.SCALE=function(t,r){return void 0===r&&(r=t),a(t,r),O(t,0,0,r,0,0)},t.SKEW_X=function(t){return a(t),O(1,0,Math.atan(t),1,0,0)},t.SKEW_Y=function(t){return a(t),O(1,Math.atan(t),0,1,0,0)},t.X_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(-1,0,0,1,t,0)},t.Y_AXIS_SYMMETRY=function(t){return void 0===t&&(t=0),a(t),O(1,0,0,-1,0,t)},t.A_TO_C=function(){return u((function(t,r,e){return _.ARC===t.type?function(t,r,e){var a,n,s,u;t.cX||o(t,r,e);for(var y=Math.min(t.phi1,t.phi2),p=Math.max(t.phi1,t.phi2)-y,m=Math.ceil(p/90),O=new Array(m),l=r,T=e,v=0;v<m;v++){var f=c$1(t.phi1,t.phi2,v/m),N=c$1(t.phi1,t.phi2,(v+1)/m),x=N-f,d=4/3*Math.tan(x*h/4),E=[Math.cos(f*h)-d*Math.sin(f*h),Math.sin(f*h)+d*Math.cos(f*h)],A=E[0],C=E[1],M=[Math.cos(N*h),Math.sin(N*h)],R=M[0],g=M[1],I=[R+d*Math.sin(N*h),g-d*Math.cos(N*h)],S=I[0],L=I[1];O[v]={relative:t.relative,type:_.CURVE_TO};var H=function(r,e){var a=i([r*t.rX,e*t.rY],t.xRot),n=a[0],o=a[1];return [t.cX+n,t.cY+o]};a=H(A,C),O[v].x1=a[0],O[v].y1=a[1],n=H(S,L),O[v].x2=n[0],O[v].y2=n[1],s=H(R,g),O[v].x=s[0],O[v].y=s[1],t.relative&&(O[v].x1-=l,O[v].y1-=T,O[v].x2-=l,O[v].y2-=T,O[v].x-=l,O[v].y-=T),l=(u=[O[v].x,O[v].y])[0],T=u[1];}return O}(t,t.relative?0:r,t.relative?0:e):t}))},t.ANNOTATE_ARCS=function(){return u((function(t,r,e){return t.relative&&(r=0,e=0),_.ARC===t.type&&o(t,r,e),t}))},t.CLONE=l,t.CALCULATE_BOUNDS=function(){var t=function(t){var r={};for(var e in t)r[e]=t[e];return r},i=r(),a=n(),h=e(),c=u((function(r,e,n){var u=h(a(i(t(r))));function O(t){t>c.maxX&&(c.maxX=t),t<c.minX&&(c.minX=t);}function l(t){t>c.maxY&&(c.maxY=t),t<c.minY&&(c.minY=t);}if(u.type&_.DRAWING_COMMANDS&&(O(e),l(n)),u.type&_.HORIZ_LINE_TO&&O(u.x),u.type&_.VERT_LINE_TO&&l(u.y),u.type&_.LINE_TO&&(O(u.x),l(u.y)),u.type&_.CURVE_TO){O(u.x),l(u.y);for(var T=0,v=p(e,u.x1,u.x2,u.x);T<v.length;T++){0<(w=v[T])&&1>w&&O(m$1(e,u.x1,u.x2,u.x,w));}for(var f=0,N=p(n,u.y1,u.y2,u.y);f<N.length;f++){0<(w=N[f])&&1>w&&l(m$1(n,u.y1,u.y2,u.y,w));}}if(u.type&_.ARC){O(u.x),l(u.y),o(u,e,n);for(var x=u.xRot/180*Math.PI,d=Math.cos(x)*u.rX,E=Math.sin(x)*u.rX,A=-Math.sin(x)*u.rY,C=Math.cos(x)*u.rY,M=u.phi1<u.phi2?[u.phi1,u.phi2]:-180>u.phi2?[u.phi2+360,u.phi1+360]:[u.phi2,u.phi1],R=M[0],g=M[1],I=function(t){var r=t[0],e=t[1],i=180*Math.atan2(e,r)/Math.PI;return i<R?i+360:i},S=0,L=s(A,-d,0).map(I);S<L.length;S++){(w=L[S])>R&&w<g&&O(y(u.cX,d,A,w));}for(var H=0,U=s(C,-E,0).map(I);H<U.length;H++){var w;(w=U[H])>R&&w<g&&l(y(u.cY,E,C,w));}}return r}));return c.minX=1/0,c.maxX=-1/0,c.minY=1/0,c.maxY=-1/0,c};}(u||(u={}));var O,l=function(){function t(){}return t.prototype.round=function(t){return this.transform(u.ROUND(t))},t.prototype.toAbs=function(){return this.transform(u.TO_ABS())},t.prototype.toRel=function(){return this.transform(u.TO_REL())},t.prototype.normalizeHVZ=function(t,r,e){return this.transform(u.NORMALIZE_HVZ(t,r,e))},t.prototype.normalizeST=function(){return this.transform(u.NORMALIZE_ST())},t.prototype.qtToC=function(){return this.transform(u.QT_TO_C())},t.prototype.aToC=function(){return this.transform(u.A_TO_C())},t.prototype.sanitize=function(t){return this.transform(u.SANITIZE(t))},t.prototype.translate=function(t,r){return this.transform(u.TRANSLATE(t,r))},t.prototype.scale=function(t,r){return this.transform(u.SCALE(t,r))},t.prototype.rotate=function(t,r,e){return this.transform(u.ROTATE(t,r,e))},t.prototype.matrix=function(t,r,e,i,a,n){return this.transform(u.MATRIX(t,r,e,i,a,n))},t.prototype.skewX=function(t){return this.transform(u.SKEW_X(t))},t.prototype.skewY=function(t){return this.transform(u.SKEW_Y(t))},t.prototype.xSymmetry=function(t){return this.transform(u.X_AXIS_SYMMETRY(t))},t.prototype.ySymmetry=function(t){return this.transform(u.Y_AXIS_SYMMETRY(t))},t.prototype.annotateArcs=function(){return this.transform(u.ANNOTATE_ARCS())},t}(),T=function(t){return " "===t||"\t"===t||"\r"===t||"\n"===t},v=function(t){return "0".charCodeAt(0)<=t.charCodeAt(0)&&t.charCodeAt(0)<="9".charCodeAt(0)},f=function(t){function e(){var r=t.call(this)||this;return r.curNumber="",r.curCommandType=-1,r.curCommandRelative=!1,r.canParseCommandOrComma=!0,r.curNumberHasExp=!1,r.curNumberHasExpDigits=!1,r.curNumberHasDecimal=!1,r.curArgs=[],r}return r(e,t),e.prototype.finish=function(t){if(void 0===t&&(t=[]),this.parse(" ",t),0!==this.curArgs.length||!this.canParseCommandOrComma)throw new SyntaxError("Unterminated command at the path end.");return t},e.prototype.parse=function(t,r){var e=this;void 0===r&&(r=[]);for(var i=function(t){r.push(t),e.curArgs.length=0,e.canParseCommandOrComma=!0;},a=0;a<t.length;a++){var n=t[a],o=!(this.curCommandType!==_.ARC||3!==this.curArgs.length&&4!==this.curArgs.length||1!==this.curNumber.length||"0"!==this.curNumber&&"1"!==this.curNumber),s=v(n)&&("0"===this.curNumber&&"0"===n||o);if(!v(n)||s)if("e"!==n&&"E"!==n)if("-"!==n&&"+"!==n||!this.curNumberHasExp||this.curNumberHasExpDigits)if("."!==n||this.curNumberHasExp||this.curNumberHasDecimal||o){if(this.curNumber&&-1!==this.curCommandType){var u=Number(this.curNumber);if(isNaN(u))throw new SyntaxError("Invalid number ending at "+a);if(this.curCommandType===_.ARC)if(0===this.curArgs.length||1===this.curArgs.length){if(0>u)throw new SyntaxError('Expected positive number, got "'+u+'" at index "'+a+'"')}else if((3===this.curArgs.length||4===this.curArgs.length)&&"0"!==this.curNumber&&"1"!==this.curNumber)throw new SyntaxError('Expected a flag, got "'+this.curNumber+'" at index "'+a+'"');this.curArgs.push(u),this.curArgs.length===N[this.curCommandType]&&(_.HORIZ_LINE_TO===this.curCommandType?i({type:_.HORIZ_LINE_TO,relative:this.curCommandRelative,x:u}):_.VERT_LINE_TO===this.curCommandType?i({type:_.VERT_LINE_TO,relative:this.curCommandRelative,y:u}):this.curCommandType===_.MOVE_TO||this.curCommandType===_.LINE_TO||this.curCommandType===_.SMOOTH_QUAD_TO?(i({type:this.curCommandType,relative:this.curCommandRelative,x:this.curArgs[0],y:this.curArgs[1]}),_.MOVE_TO===this.curCommandType&&(this.curCommandType=_.LINE_TO)):this.curCommandType===_.CURVE_TO?i({type:_.CURVE_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x2:this.curArgs[2],y2:this.curArgs[3],x:this.curArgs[4],y:this.curArgs[5]}):this.curCommandType===_.SMOOTH_CURVE_TO?i({type:_.SMOOTH_CURVE_TO,relative:this.curCommandRelative,x2:this.curArgs[0],y2:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.QUAD_TO?i({type:_.QUAD_TO,relative:this.curCommandRelative,x1:this.curArgs[0],y1:this.curArgs[1],x:this.curArgs[2],y:this.curArgs[3]}):this.curCommandType===_.ARC&&i({type:_.ARC,relative:this.curCommandRelative,rX:this.curArgs[0],rY:this.curArgs[1],xRot:this.curArgs[2],lArcFlag:this.curArgs[3],sweepFlag:this.curArgs[4],x:this.curArgs[5],y:this.curArgs[6]})),this.curNumber="",this.curNumberHasExpDigits=!1,this.curNumberHasExp=!1,this.curNumberHasDecimal=!1,this.canParseCommandOrComma=!0;}if(!T(n))if(","===n&&this.canParseCommandOrComma)this.canParseCommandOrComma=!1;else if("+"!==n&&"-"!==n&&"."!==n)if(s)this.curNumber=n,this.curNumberHasDecimal=!1;else {if(0!==this.curArgs.length)throw new SyntaxError("Unterminated command at index "+a+".");if(!this.canParseCommandOrComma)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+". Command cannot follow comma");if(this.canParseCommandOrComma=!1,"z"!==n&&"Z"!==n)if("h"===n||"H"===n)this.curCommandType=_.HORIZ_LINE_TO,this.curCommandRelative="h"===n;else if("v"===n||"V"===n)this.curCommandType=_.VERT_LINE_TO,this.curCommandRelative="v"===n;else if("m"===n||"M"===n)this.curCommandType=_.MOVE_TO,this.curCommandRelative="m"===n;else if("l"===n||"L"===n)this.curCommandType=_.LINE_TO,this.curCommandRelative="l"===n;else if("c"===n||"C"===n)this.curCommandType=_.CURVE_TO,this.curCommandRelative="c"===n;else if("s"===n||"S"===n)this.curCommandType=_.SMOOTH_CURVE_TO,this.curCommandRelative="s"===n;else if("q"===n||"Q"===n)this.curCommandType=_.QUAD_TO,this.curCommandRelative="q"===n;else if("t"===n||"T"===n)this.curCommandType=_.SMOOTH_QUAD_TO,this.curCommandRelative="t"===n;else {if("a"!==n&&"A"!==n)throw new SyntaxError('Unexpected character "'+n+'" at index '+a+".");this.curCommandType=_.ARC,this.curCommandRelative="a"===n;}else r.push({type:_.CLOSE_PATH}),this.canParseCommandOrComma=!0,this.curCommandType=-1;}else this.curNumber=n,this.curNumberHasDecimal="."===n;}else this.curNumber+=n,this.curNumberHasDecimal=!0;else this.curNumber+=n;else this.curNumber+=n,this.curNumberHasExp=!0;else this.curNumber+=n,this.curNumberHasExpDigits=this.curNumberHasExp;}return r},e.prototype.transform=function(t){return Object.create(this,{parse:{value:function(r,e){void 0===e&&(e=[]);for(var i=0,a=Object.getPrototypeOf(this).parse.call(this,r);i<a.length;i++){var n=a[i],o=t(n);Array.isArray(o)?e.push.apply(e,o):e.push(o);}return e}}})},e}(l),_=function(t){function i(r){var e=t.call(this)||this;return e.commands="string"==typeof r?i.parse(r):r,e}return r(i,t),i.prototype.encode=function(){return i.encode(this.commands)},i.prototype.getBounds=function(){var t=u.CALCULATE_BOUNDS();return this.transform(t),t},i.prototype.transform=function(t){for(var r=[],e=0,i=this.commands;e<i.length;e++){var a=t(i[e]);Array.isArray(a)?r.push.apply(r,a):r.push(a);}return this.commands=r,this},i.encode=function(t){return e(t)},i.parse=function(t){var r=new f,e=[];return r.parse(t,e),r.finish(e),e},i.CLOSE_PATH=1,i.MOVE_TO=2,i.HORIZ_LINE_TO=4,i.VERT_LINE_TO=8,i.LINE_TO=16,i.CURVE_TO=32,i.SMOOTH_CURVE_TO=64,i.QUAD_TO=128,i.SMOOTH_QUAD_TO=256,i.ARC=512,i.LINE_COMMANDS=i.LINE_TO|i.HORIZ_LINE_TO|i.VERT_LINE_TO,i.DRAWING_COMMANDS=i.HORIZ_LINE_TO|i.VERT_LINE_TO|i.LINE_TO|i.CURVE_TO|i.SMOOTH_CURVE_TO|i.QUAD_TO|i.SMOOTH_QUAD_TO|i.ARC,i}(l),N=((O={})[_.MOVE_TO]=2,O[_.LINE_TO]=2,O[_.HORIZ_LINE_TO]=1,O[_.VERT_LINE_TO]=1,O[_.CLOSE_PATH]=0,O[_.QUAD_TO]=4,O[_.SMOOTH_QUAD_TO]=2,O[_.CURVE_TO]=6,O[_.SMOOTH_CURVE_TO]=4,O[_.ARC]=7,O);

  var uncurryThis = functionUncurryThis;
  var PROPER_FUNCTION_NAME = functionName.PROPER;
  var redefine = redefine$7.exports;
  var anObject = anObject$g;
  var isPrototypeOf = objectIsPrototypeOf;
  var $toString = toString$9;
  var fails = fails$k;
  var regExpFlags = regexpFlags$1;

  var TO_STRING = 'toString';
  var RegExpPrototype = RegExp.prototype;
  var n$ToString = RegExpPrototype[TO_STRING];
  var getFlags = uncurryThis(regExpFlags);

  var NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
  // FF44- RegExp#toString has a wrong name
  var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;

  // `RegExp.prototype.toString` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING, function toString() {
      var R = anObject(this);
      var p = $toString(R.source);
      var rf = R.flags;
      var f = $toString(rf === undefined && isPrototypeOf(RegExpPrototype, R) && !('flags' in RegExpPrototype) ? getFlags(R) : rf);
      return '/' + p + '/' + f;
    }, { unsafe: true });
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  /* eslint-disable no-bitwise -- used for calculations */

  /* eslint-disable unicorn/prefer-query-selector -- aiming at
    backward-compatibility */

  /**
  * StackBlur - a fast almost Gaussian Blur For Canvas
  *
  * In case you find this class useful - especially in commercial projects -
  * I am not totally unhappy for a small donation to my PayPal account
  * mario@quasimondo.de
  *
  * Or support me on flattr:
  * {@link https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript}.
  *
  * @module StackBlur
  * @author Mario Klingemann
  * Contact: mario@quasimondo.com
  * Website: {@link http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html}
  * Twitter: @quasimondo
  *
  * @copyright (c) 2010 Mario Klingemann
  *
  * Permission is hereby granted, free of charge, to any person
  * obtaining a copy of this software and associated documentation
  * files (the "Software"), to deal in the Software without
  * restriction, including without limitation the rights to use,
  * copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following
  * conditions:
  *
  * The above copyright notice and this permission notice shall be
  * included in all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  * OTHER DEALINGS IN THE SOFTWARE.
  */
  var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
  var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
  /**
   * @param {string|HTMLCanvasElement} canvas
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @throws {Error|TypeError}
   * @returns {ImageData} See {@link https://html.spec.whatwg.org/multipage/canvas.html#imagedata}
   */


  function getImageDataFromCanvas(canvas, topX, topY, width, height) {
    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
    }

    if (!canvas || _typeof(canvas) !== 'object' || !('getContext' in canvas)) {
      throw new TypeError('Expecting canvas with `getContext` method ' + 'in processCanvasRGB(A) calls!');
    }

    var context = canvas.getContext('2d');

    try {
      return context.getImageData(topX, topY, width, height);
    } catch (e) {
      throw new Error('unable to access image data: ' + e);
    }
  }
  /**
   * @param {HTMLCanvasElement} canvas
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @param {Float} radius
   * @returns {undefined}
   */


  function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
    if (isNaN(radius) || radius < 1) {
      return;
    }

    radius |= 0;
    var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
    imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
    canvas.getContext('2d').putImageData(imageData, topX, topY);
  }
  /**
   * @param {ImageData} imageData
   * @param {Integer} topX
   * @param {Integer} topY
   * @param {Integer} width
   * @param {Integer} height
   * @param {Float} radius
   * @returns {ImageData}
   */


  function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
    var pixels = imageData.data;
    var div = 2 * radius + 1; // const w4 = width << 2;

    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack();
    var stack = stackStart;
    var stackEnd;

    for (var i = 1; i < div; i++) {
      stack = stack.next = new BlurStack();

      if (i === radiusPlus1) {
        stackEnd = stack;
      }
    }

    stack.next = stackStart;
    var stackIn = null,
        stackOut = null,
        yw = 0,
        yi = 0;
    var mulSum = mulTable[radius];
    var shgSum = shgTable[radius];

    for (var y = 0; y < height; y++) {
      stack = stackStart;
      var pr = pixels[yi],
          pg = pixels[yi + 1],
          pb = pixels[yi + 2],
          pa = pixels[yi + 3];

      for (var _i = 0; _i < radiusPlus1; _i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      var rInSum = 0,
          gInSum = 0,
          bInSum = 0,
          aInSum = 0,
          rOutSum = radiusPlus1 * pr,
          gOutSum = radiusPlus1 * pg,
          bOutSum = radiusPlus1 * pb,
          aOutSum = radiusPlus1 * pa,
          rSum = sumFactor * pr,
          gSum = sumFactor * pg,
          bSum = sumFactor * pb,
          aSum = sumFactor * pa;

      for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
        var p = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
        var r = pixels[p],
            g = pixels[p + 1],
            b = pixels[p + 2],
            a = pixels[p + 3];
        var rbs = radiusPlus1 - _i2;
        rSum += (stack.r = r) * rbs;
        gSum += (stack.g = g) * rbs;
        bSum += (stack.b = b) * rbs;
        aSum += (stack.a = a) * rbs;
        rInSum += r;
        gInSum += g;
        bInSum += b;
        aInSum += a;
        stack = stack.next;
      }

      stackIn = stackStart;
      stackOut = stackEnd;

      for (var x = 0; x < width; x++) {
        var paInitial = aSum * mulSum >> shgSum;
        pixels[yi + 3] = paInitial;

        if (paInitial !== 0) {
          var _a2 = 255 / paInitial;

          pixels[yi] = (rSum * mulSum >> shgSum) * _a2;
          pixels[yi + 1] = (gSum * mulSum >> shgSum) * _a2;
          pixels[yi + 2] = (bSum * mulSum >> shgSum) * _a2;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }

        rSum -= rOutSum;
        gSum -= gOutSum;
        bSum -= bOutSum;
        aSum -= aOutSum;
        rOutSum -= stackIn.r;
        gOutSum -= stackIn.g;
        bOutSum -= stackIn.b;
        aOutSum -= stackIn.a;

        var _p = x + radius + 1;

        _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
        rInSum += stackIn.r = pixels[_p];
        gInSum += stackIn.g = pixels[_p + 1];
        bInSum += stackIn.b = pixels[_p + 2];
        aInSum += stackIn.a = pixels[_p + 3];
        rSum += rInSum;
        gSum += gInSum;
        bSum += bInSum;
        aSum += aInSum;
        stackIn = stackIn.next;
        var _stackOut = stackOut,
            _r = _stackOut.r,
            _g = _stackOut.g,
            _b = _stackOut.b,
            _a = _stackOut.a;
        rOutSum += _r;
        gOutSum += _g;
        bOutSum += _b;
        aOutSum += _a;
        rInSum -= _r;
        gInSum -= _g;
        bInSum -= _b;
        aInSum -= _a;
        stackOut = stackOut.next;
        yi += 4;
      }

      yw += width;
    }

    for (var _x = 0; _x < width; _x++) {
      yi = _x << 2;

      var _pr = pixels[yi],
          _pg = pixels[yi + 1],
          _pb = pixels[yi + 2],
          _pa = pixels[yi + 3],
          _rOutSum = radiusPlus1 * _pr,
          _gOutSum = radiusPlus1 * _pg,
          _bOutSum = radiusPlus1 * _pb,
          _aOutSum = radiusPlus1 * _pa,
          _rSum = sumFactor * _pr,
          _gSum = sumFactor * _pg,
          _bSum = sumFactor * _pb,
          _aSum = sumFactor * _pa;

      stack = stackStart;

      for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
        stack.r = _pr;
        stack.g = _pg;
        stack.b = _pb;
        stack.a = _pa;
        stack = stack.next;
      }

      var yp = width;
      var _gInSum = 0,
          _bInSum = 0,
          _aInSum = 0,
          _rInSum = 0;

      for (var _i4 = 1; _i4 <= radius; _i4++) {
        yi = yp + _x << 2;

        var _rbs = radiusPlus1 - _i4;

        _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
        _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
        _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
        _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
        _rInSum += _pr;
        _gInSum += _pg;
        _bInSum += _pb;
        _aInSum += _pa;
        stack = stack.next;

        if (_i4 < heightMinus1) {
          yp += width;
        }
      }

      yi = _x;
      stackIn = stackStart;
      stackOut = stackEnd;

      for (var _y = 0; _y < height; _y++) {
        var _p2 = yi << 2;

        pixels[_p2 + 3] = _pa = _aSum * mulSum >> shgSum;

        if (_pa > 0) {
          _pa = 255 / _pa;
          pixels[_p2] = (_rSum * mulSum >> shgSum) * _pa;
          pixels[_p2 + 1] = (_gSum * mulSum >> shgSum) * _pa;
          pixels[_p2 + 2] = (_bSum * mulSum >> shgSum) * _pa;
        } else {
          pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
        }

        _rSum -= _rOutSum;
        _gSum -= _gOutSum;
        _bSum -= _bOutSum;
        _aSum -= _aOutSum;
        _rOutSum -= stackIn.r;
        _gOutSum -= stackIn.g;
        _bOutSum -= stackIn.b;
        _aOutSum -= stackIn.a;
        _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
        _rSum += _rInSum += stackIn.r = pixels[_p2];
        _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
        _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
        _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
        stackIn = stackIn.next;
        _rOutSum += _pr = stackOut.r;
        _gOutSum += _pg = stackOut.g;
        _bOutSum += _pb = stackOut.b;
        _aOutSum += _pa = stackOut.a;
        _rInSum -= _pr;
        _gInSum -= _pg;
        _bInSum -= _pb;
        _aInSum -= _pa;
        stackOut = stackOut.next;
        yi += width;
      }
    }

    return imageData;
  }
  /**
   *
   */


  var BlurStack =
  /**
   * Set properties.
   */
  function BlurStack() {
    _classCallCheck(this, BlurStack);

    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  };

  /**
   * Options preset for `OffscreenCanvas`.
   * @param config - Preset requirements.
   * @param config.DOMParser - XML/HTML parser from string into DOM Document.
   * @returns Preset object.
   */
  function offscreen() {
    var {
      DOMParser: DOMParserFallback
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var preset = {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParserFallback,

      createCanvas(width, height) {
        return new OffscreenCanvas(width, height);
      },

      createImage(url) {
        return _asyncToGenerator(function* () {
          var response = yield fetch(url);
          var blob = yield response.blob();
          var img = yield createImageBitmap(blob);
          return img;
        })();
      }

    };

    if (typeof DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {
      Reflect.deleteProperty(preset, 'DOMParser');
    }

    return preset;
  }

  /**
   * Options preset for `node-canvas`.
   * @param config - Preset requirements.
   * @param config.DOMParser - XML/HTML parser from string into DOM Document.
   * @param config.canvas - `node-canvas` exports.
   * @param config.fetch - WHATWG-compatible `fetch` function.
   * @returns Preset object.
   */
  function node(_ref) {
    var {
      DOMParser,
      canvas,
      fetch
    } = _ref;
    return {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser,
      fetch,
      createCanvas: canvas.createCanvas,
      createImage: canvas.loadImage
    };
  }

  var index = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	offscreen: offscreen,
  	node: node
  });

  /**
   * HTML-safe compress white-spaces.
   * @param str - String to compress.
   * @returns String.
   */
  function compressSpaces(str) {
    return str.replace(/(?!\u3000)\s+/gm, ' ');
  }
  /**
   * HTML-safe left trim.
   * @param str - String to trim.
   * @returns String.
   */

  function trimLeft(str) {
    return str.replace(/^[\n \t]+/, '');
  }
  /**
   * HTML-safe right trim.
   * @param str - String to trim.
   * @returns String.
   */

  function trimRight(str) {
    return str.replace(/[\n \t]+$/, '');
  }
  /**
   * String to numbers array.
   * @param str - Numbers string.
   * @returns Numbers array.
   */

  function toNumbers(str) {
    var matches = (str || '').match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
    return matches.map(parseFloat);
  } // Microsoft Edge fix

  var allUppercase = /^[A-Z-]+$/;
  /**
   * Normalize attribute name.
   * @param name - Attribute name.
   * @returns Normalized attribute name.
   */

  function normalizeAttributeName(name) {
    if (allUppercase.test(name)) {
      return name.toLowerCase();
    }

    return name;
  }
  /**
   * Parse external URL.
   * @param url - CSS url string.
   * @returns Parsed URL.
   */

  function parseExternalUrl(url) {
    //                      single quotes [2]
    //                      v         double quotes [3]
    //                      v         v         no quotes [4]
    //                      v         v         v
    var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
    return urlMatch[2] || urlMatch[3] || urlMatch[4];
  }
  /**
   * Transform floats to integers in rgb colors.
   * @param color - Color to normalize.
   * @returns Normalized color.
   */

  function normalizeColor(color) {
    if (!color.startsWith('rgb')) {
      return color;
    }

    var rgbParts = 3;
    var normalizedColor = color.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
    return normalizedColor;
  }

  // slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
  var attributeRegex = /(\[[^\]]+\])/g;
  var idRegex = /(#[^\s+>~.[:]+)/g;
  var classRegex = /(\.[^\s+>~.[:]+)/g;
  var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
  var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
  var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
  var elementRegex = /([^\s+>~.[:]+)/g;

  function findSelectorMatch(selector, regex) {
    var matches = regex.exec(selector);

    if (!matches) {
      return [selector, 0];
    }

    return [selector.replace(regex, ' '), matches.length];
  }
  /**
   * Measure selector specificity.
   * @param selector - Selector to measure.
   * @returns Specificity.
   */


  function getSelectorSpecificity(selector) {
    var specificity = [0, 0, 0];
    var currentSelector = selector.replace(/:not\(([^)]*)\)/g, '     $1 ').replace(/{[\s\S]*/gm, ' ');
    var delta = 0;
    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
    specificity[0] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
    specificity[2] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
    specificity[1] += delta;
    currentSelector = currentSelector.replace(/[*\s+>~]/g, ' ').replace(/[#.]/g, ' ');
    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]

    specificity[2] += delta;
    return specificity.join('');
  }

  var PSEUDO_ZERO = .00000001;
  /**
   * Vector magnitude.
   * @param v
   * @returns Number result.
   */

  function vectorMagnitude(v) {
    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
  }
  /**
   * Ratio between two vectors.
   * @param u
   * @param v
   * @returns Number result.
   */

  function vectorsRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));
  }
  /**
   * Angle between two vectors.
   * @param u
   * @param v
   * @returns Number result.
   */

  function vectorsAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));
  }
  function CB1(t) {
    return t * t * t;
  }
  function CB2(t) {
    return 3 * t * t * (1 - t);
  }
  function CB3(t) {
    return 3 * t * (1 - t) * (1 - t);
  }
  function CB4(t) {
    return (1 - t) * (1 - t) * (1 - t);
  }
  function QB1(t) {
    return t * t;
  }
  function QB2(t) {
    return 2 * t * (1 - t);
  }
  function QB3(t) {
    return (1 - t) * (1 - t);
  }

  class Property {
    constructor(document, name, value) {
      this.document = document;
      this.name = name;
      this.value = value;
      this.isNormalizedColor = false;
    }

    static empty(document) {
      return new Property(document, 'EMPTY', '');
    }

    split() {
      var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
      var {
        document,
        name
      } = this;
      return compressSpaces(this.getString()).trim().split(separator).map(value => new Property(document, name, value));
    }

    hasValue(zeroIsValue) {
      var {
        value
      } = this;
      return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';
    }

    isString(regexp) {
      var {
        value
      } = this;
      var result = typeof value === 'string';

      if (!result || !regexp) {
        return result;
      }

      return regexp.test(value);
    }

    isUrlDefinition() {
      return this.isString(/^url\(/);
    }

    isPixels() {
      if (!this.hasValue()) {
        return false;
      }

      var asString = this.getString();

      switch (true) {
        case asString.endsWith('px'):
        case /^[0-9]+$/.test(asString):
          return true;

        default:
          return false;
      }
    }

    setValue(value) {
      this.value = value;
      return this;
    }

    getValue(def) {
      if (typeof def === 'undefined' || this.hasValue()) {
        return this.value;
      }

      return def;
    }

    getNumber(def) {
      if (!this.hasValue()) {
        if (typeof def === 'undefined') {
          return 0;
        }

        return parseFloat(def);
      }

      var {
        value
      } = this;
      var n = parseFloat(value);

      if (this.isString(/%$/)) {
        n /= 100.0;
      }

      return n;
    }

    getString(def) {
      if (typeof def === 'undefined' || this.hasValue()) {
        return typeof this.value === 'undefined' ? '' : String(this.value);
      }

      return String(def);
    }

    getColor(def) {
      var color = this.getString(def);

      if (this.isNormalizedColor) {
        return color;
      }

      this.isNormalizedColor = true;
      color = normalizeColor(color);
      this.value = color;
      return color;
    }

    getDpi() {
      return 96.0; // TODO: compute?
    }

    getRem() {
      return this.document.rootEmSize;
    }

    getEm() {
      return this.document.emSize;
    }

    getUnits() {
      return this.getString().replace(/[0-9.-]/g, '');
    }

    getPixels(axisOrIsFontSize) {
      var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.hasValue()) {
        return 0;
      }

      var [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [undefined, axisOrIsFontSize] : [axisOrIsFontSize];
      var {
        viewPort
      } = this.document.screen;

      switch (true) {
        case this.isString(/vmin$/):
          return this.getNumber() / 100.0 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));

        case this.isString(/vmax$/):
          return this.getNumber() / 100.0 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));

        case this.isString(/vw$/):
          return this.getNumber() / 100.0 * viewPort.computeSize('x');

        case this.isString(/vh$/):
          return this.getNumber() / 100.0 * viewPort.computeSize('y');

        case this.isString(/rem$/):
          return this.getNumber() * this.getRem();

        case this.isString(/em$/):
          return this.getNumber() * this.getEm();

        case this.isString(/ex$/):
          return this.getNumber() * this.getEm() / 2.0;

        case this.isString(/px$/):
          return this.getNumber();

        case this.isString(/pt$/):
          return this.getNumber() * this.getDpi() * (1.0 / 72.0);

        case this.isString(/pc$/):
          return this.getNumber() * 15;

        case this.isString(/cm$/):
          return this.getNumber() * this.getDpi() / 2.54;

        case this.isString(/mm$/):
          return this.getNumber() * this.getDpi() / 25.4;

        case this.isString(/in$/):
          return this.getNumber() * this.getDpi();

        case this.isString(/%$/) && isFontSize:
          return this.getNumber() * this.getEm();

        case this.isString(/%$/):
          return this.getNumber() * viewPort.computeSize(axis);

        default:
          {
            var n = this.getNumber();

            if (processPercent && n < 1.0) {
              return n * viewPort.computeSize(axis);
            }

            return n;
          }
      }
    }

    getMilliseconds() {
      if (!this.hasValue()) {
        return 0;
      }

      if (this.isString(/ms$/)) {
        return this.getNumber();
      }

      return this.getNumber() * 1000;
    }

    getRadians() {
      if (!this.hasValue()) {
        return 0;
      }

      switch (true) {
        case this.isString(/deg$/):
          return this.getNumber() * (Math.PI / 180.0);

        case this.isString(/grad$/):
          return this.getNumber() * (Math.PI / 200.0);

        case this.isString(/rad$/):
          return this.getNumber();

        default:
          return this.getNumber() * (Math.PI / 180.0);
      }
    }

    getDefinition() {
      var asString = this.getString();
      var name = /#([^)'"]+)/.exec(asString);

      if (name) {
        name = name[1];
      }

      if (!name) {
        name = asString;
      }

      return this.document.definitions[name];
    }

    getFillStyleDefinition(element, opacity) {
      var def = this.getDefinition();

      if (!def) {
        return null;
      } // gradient


      if (typeof def.createGradient === 'function') {
        return def.createGradient(this.document.ctx, element, opacity);
      } // pattern


      if (typeof def.createPattern === 'function') {
        if (def.getHrefAttribute().hasValue()) {
          var patternTransform = def.getAttribute('patternTransform');
          def = def.getHrefAttribute().getDefinition();

          if (patternTransform.hasValue()) {
            def.getAttribute('patternTransform', true).setValue(patternTransform.value);
          }
        }

        return def.createPattern(this.document.ctx, element, opacity);
      }

      return null;
    }

    getTextBaseline() {
      if (!this.hasValue()) {
        return null;
      }

      return Property.textBaselineMapping[this.getString()];
    }

    addOpacity(opacity) {
      var value = this.getColor();
      var len = value.length;
      var commas = 0; // Simulate old RGBColor version, which can't parse rgba.

      for (var i = 0; i < len; i++) {
        if (value[i] === ',') {
          commas++;
        }

        if (commas === 3) {
          break;
        }
      }

      if (opacity.hasValue() && this.isString() && commas !== 3) {
        var color = new rgbcolor(value);

        if (color.ok) {
          color.alpha = opacity.getNumber();
          value = color.toRGBA();
        }
      }

      return new Property(this.document, this.name, value);
    }

  }
  Property.textBaselineMapping = {
    'baseline': 'alphabetic',
    'before-edge': 'top',
    'text-before-edge': 'top',
    'middle': 'middle',
    'central': 'middle',
    'after-edge': 'bottom',
    'text-after-edge': 'bottom',
    'ideographic': 'ideographic',
    'alphabetic': 'alphabetic',
    'hanging': 'hanging',
    'mathematical': 'alphabetic'
  };

  class ViewPort {
    constructor() {
      this.viewPorts = [];
    }

    clear() {
      this.viewPorts = [];
    }

    setCurrent(width, height) {
      this.viewPorts.push({
        width,
        height
      });
    }

    removeCurrent() {
      this.viewPorts.pop();
    }

    getCurrent() {
      var {
        viewPorts
      } = this;
      return viewPorts[viewPorts.length - 1];
    }

    get width() {
      return this.getCurrent().width;
    }

    get height() {
      return this.getCurrent().height;
    }

    computeSize(d) {
      if (typeof d === 'number') {
        return d;
      }

      if (d === 'x') {
        return this.width;
      }

      if (d === 'y') {
        return this.height;
      }

      return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
    }

  }

  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    static parse(point) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var [x = defaultValue, y = defaultValue] = toNumbers(point);
      return new Point(x, y);
    }

    static parseScale(scale) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var [x = defaultValue, y = x] = toNumbers(scale);
      return new Point(x, y);
    }

    static parsePath(path) {
      var points = toNumbers(path);
      var len = points.length;
      var pathPoints = [];

      for (var i = 0; i < len; i += 2) {
        pathPoints.push(new Point(points[i], points[i + 1]));
      }

      return pathPoints;
    }

    angleTo(point) {
      return Math.atan2(point.y - this.y, point.x - this.x);
    }

    applyTransform(transform) {
      var {
        x,
        y
      } = this;
      var xp = x * transform[0] + y * transform[2] + transform[4];
      var yp = x * transform[1] + y * transform[3] + transform[5];
      this.x = xp;
      this.y = yp;
    }

  }

  class Mouse {
    constructor(screen) {
      this.screen = screen;
      this.working = false;
      this.events = [];
      this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

      this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment

      this.onMouseMove = this.onMouseMove.bind(this);
    }

    isWorking() {
      return this.working;
    }

    start() {
      if (this.working) {
        return;
      }

      var {
        screen,
        onClick,
        onMouseMove
      } = this;
      var canvas = screen.ctx.canvas;
      canvas.onclick = onClick;
      canvas.onmousemove = onMouseMove;
      this.working = true;
    }

    stop() {
      if (!this.working) {
        return;
      }

      var canvas = this.screen.ctx.canvas;
      this.working = false;
      canvas.onclick = null;
      canvas.onmousemove = null;
    }

    hasEvents() {
      return this.working && this.events.length > 0;
    }

    runEvents() {
      if (!this.working) {
        return;
      }

      var {
        screen: document,
        events,
        eventElements
      } = this;
      var {
        style
      } = document.ctx.canvas;

      if (style) {
        style.cursor = '';
      }

      events.forEach((_ref, i) => {
        var {
          run
        } = _ref;
        var element = eventElements[i];

        while (element) {
          run(element);
          element = element.parent;
        }
      }); // done running, clear

      this.events = [];
      this.eventElements = [];
    }

    checkPath(element, ctx) {
      if (!this.working || !ctx) {
        return;
      }

      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref2, i) => {
        var {
          x,
          y
        } = _ref2;

        if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {
          eventElements[i] = element;
        }
      });
    }

    checkBoundingBox(element, boundingBox) {
      if (!this.working || !boundingBox) {
        return;
      }

      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref3, i) => {
        var {
          x,
          y
        } = _ref3;

        if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {
          eventElements[i] = element;
        }
      });
    }

    mapXY(x, y) {
      var {
        window,
        ctx
      } = this.screen;
      var point = new Point(x, y);
      var element = ctx.canvas;

      while (element) {
        point.x -= element.offsetLeft;
        point.y -= element.offsetTop;
        element = element.offsetParent;
      }

      if (window.scrollX) {
        point.x += window.scrollX;
      }

      if (window.scrollY) {
        point.y += window.scrollY;
      }

      return point;
    }

    onClick(event) {
      var {
        x,
        y
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: 'onclick',
        x,
        y,

        run(eventTarget) {
          if (eventTarget.onClick) {
            eventTarget.onClick();
          }
        }

      });
    }

    onMouseMove(event) {
      var {
        x,
        y
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: 'onmousemove',
        x,
        y,

        run(eventTarget) {
          if (eventTarget.onMouseMove) {
            eventTarget.onMouseMove();
          }
        }

      });
    }

  }

  var defaultWindow = typeof window !== 'undefined' ? window : null;
  var defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.
  : null;
  class Screen {
    constructor(ctx) {
      var {
        fetch = defaultFetch$1,
        window = defaultWindow
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.ctx = ctx;
      this.FRAMERATE = 30;
      this.MAX_VIRTUAL_PIXELS = 30000;
      this.CLIENT_WIDTH = 800;
      this.CLIENT_HEIGHT = 600;
      this.viewPort = new ViewPort();
      this.mouse = new Mouse(this);
      this.animations = [];
      this.waits = [];
      this.frameDuration = 0;
      this.isReadyLock = false;
      this.isFirstRender = true;
      this.intervalId = null;
      this.window = window;
      this.fetch = fetch;
    }

    wait(checker) {
      this.waits.push(checker);
    }

    ready() {
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      if (!this.readyPromise) {
        return Promise.resolve();
      }

      return this.readyPromise;
    }

    isReady() {
      if (this.isReadyLock) {
        return true;
      }

      var isReadyLock = this.waits.every(_ => _());

      if (isReadyLock) {
        this.waits = [];

        if (this.resolveReady) {
          this.resolveReady();
        }
      }

      this.isReadyLock = isReadyLock;
      return isReadyLock;
    }

    setDefaults(ctx) {
      // initial values and defaults
      ctx.strokeStyle = 'rgba(0,0,0,0)';
      ctx.lineCap = 'butt';
      ctx.lineJoin = 'miter';
      ctx.miterLimit = 4;
    }

    setViewBox(_ref) {
      var {
        document,
        ctx,
        aspectRatio,
        width,
        desiredWidth,
        height,
        desiredHeight,
        minX = 0,
        minY = 0,
        refX,
        refY,
        clip = false,
        clipX = 0,
        clipY = 0
      } = _ref;
      // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
      var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, ''); // ignore defer

      var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');
      var align = aspectRatioAlign || 'xMidYMid';
      var meetOrSlice = aspectRatioMeetOrSlice || 'meet'; // calculate scale

      var scaleX = width / desiredWidth;
      var scaleY = height / desiredHeight;
      var scaleMin = Math.min(scaleX, scaleY);
      var scaleMax = Math.max(scaleX, scaleY);
      var finalDesiredWidth = desiredWidth;
      var finalDesiredHeight = desiredHeight;

      if (meetOrSlice === 'meet') {
        finalDesiredWidth *= scaleMin;
        finalDesiredHeight *= scaleMin;
      }

      if (meetOrSlice === 'slice') {
        finalDesiredWidth *= scaleMax;
        finalDesiredHeight *= scaleMax;
      }

      var refXProp = new Property(document, 'refX', refX);
      var refYProp = new Property(document, 'refY', refY);
      var hasRefs = refXProp.hasValue() && refYProp.hasValue();

      if (hasRefs) {
        ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));
      }

      if (clip) {
        var scaledClipX = scaleMin * clipX;
        var scaledClipY = scaleMin * clipY;
        ctx.beginPath();
        ctx.moveTo(scaledClipX, scaledClipY);
        ctx.lineTo(width, scaledClipY);
        ctx.lineTo(width, height);
        ctx.lineTo(scaledClipX, height);
        ctx.closePath();
        ctx.clip();
      }

      if (!hasRefs) {
        var isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;
        var isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;
        var isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;
        var isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;

        if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);
        }

        if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);
        }

        if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width - finalDesiredWidth, 0);
        }

        if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height - finalDesiredHeight);
        }
      } // scale


      switch (true) {
        case align === 'none':
          ctx.scale(scaleX, scaleY);
          break;

        case meetOrSlice === 'meet':
          ctx.scale(scaleMin, scaleMin);
          break;

        case meetOrSlice === 'slice':
          ctx.scale(scaleMax, scaleMax);
          break;
      } // translate


      ctx.translate(-minX, -minY);
    }

    start(element) {
      var {
        enableRedraw = false,
        ignoreMouse = false,
        ignoreAnimation = false,
        ignoreDimensions = false,
        ignoreClear = false,
        forceRedraw,
        scaleWidth,
        scaleHeight,
        offsetX,
        offsetY
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var {
        FRAMERATE,
        mouse
      } = this;
      var frameDuration = 1000 / FRAMERATE;
      this.frameDuration = frameDuration;
      this.readyPromise = new Promise(resolve => {
        this.resolveReady = resolve;
      });

      if (this.isReady()) {
        this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
      }

      if (!enableRedraw) {
        return;
      }

      var now = Date.now();
      var then = now;
      var delta = 0;

      var tick = () => {
        now = Date.now();
        delta = now - then;

        if (delta >= frameDuration) {
          then = now - delta % frameDuration;

          if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
            mouse.runEvents();
          }
        }

        this.intervalId = requestAnimationFrame$1(tick);
      };

      if (!ignoreMouse) {
        mouse.start();
      }

      this.intervalId = requestAnimationFrame$1(tick);
    }

    stop() {
      if (this.intervalId) {
        requestAnimationFrame$1.cancel(this.intervalId);
        this.intervalId = null;
      }

      this.mouse.stop();
    }

    shouldUpdate(ignoreAnimation, forceRedraw) {
      // need update from animations?
      if (!ignoreAnimation) {
        var {
          frameDuration
        } = this;
        var shouldUpdate = this.animations.reduce((shouldUpdate, animation) => animation.update(frameDuration) || shouldUpdate, false);

        if (shouldUpdate) {
          return true;
        }
      } // need update from redraw?


      if (typeof forceRedraw === 'function' && forceRedraw()) {
        return true;
      }

      if (!this.isReadyLock && this.isReady()) {
        return true;
      } // need update from mouse events?


      if (this.mouse.hasEvents()) {
        return true;
      }

      return false;
    }

    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
      var {
        CLIENT_WIDTH,
        CLIENT_HEIGHT,
        viewPort,
        ctx,
        isFirstRender
      } = this;
      var canvas = ctx.canvas;
      viewPort.clear();

      if (canvas.width && canvas.height) {
        viewPort.setCurrent(canvas.width, canvas.height);
      } else {
        viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
      }

      var widthStyle = element.getStyle('width');
      var heightStyle = element.getStyle('height');

      if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {
        // set canvas size
        if (widthStyle.hasValue()) {
          canvas.width = widthStyle.getPixels('x');

          if (canvas.style) {
            canvas.style.width = "".concat(canvas.width, "px");
          }
        }

        if (heightStyle.hasValue()) {
          canvas.height = heightStyle.getPixels('y');

          if (canvas.style) {
            canvas.style.height = "".concat(canvas.height, "px");
          }
        }
      }

      var cWidth = canvas.clientWidth || canvas.width;
      var cHeight = canvas.clientHeight || canvas.height;

      if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
        cWidth = widthStyle.getPixels('x');
        cHeight = heightStyle.getPixels('y');
      }

      viewPort.setCurrent(cWidth, cHeight);

      if (typeof offsetX === 'number') {
        element.getAttribute('x', true).setValue(offsetX);
      }

      if (typeof offsetY === 'number') {
        element.getAttribute('y', true).setValue(offsetY);
      }

      if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {
        var viewBox = toNumbers(element.getAttribute('viewBox').getString());
        var xRatio = 0;
        var yRatio = 0;

        if (typeof scaleWidth === 'number') {
          var _widthStyle = element.getStyle('width');

          if (_widthStyle.hasValue()) {
            xRatio = _widthStyle.getPixels('x') / scaleWidth;
          } else if (!isNaN(viewBox[2])) {
            xRatio = viewBox[2] / scaleWidth;
          }
        }

        if (typeof scaleHeight === 'number') {
          var _heightStyle = element.getStyle('height');

          if (_heightStyle.hasValue()) {
            yRatio = _heightStyle.getPixels('y') / scaleHeight;
          } else if (!isNaN(viewBox[3])) {
            yRatio = viewBox[3] / scaleHeight;
          }
        }

        if (!xRatio) {
          xRatio = yRatio;
        }

        if (!yRatio) {
          yRatio = xRatio;
        }

        element.getAttribute('width', true).setValue(scaleWidth);
        element.getAttribute('height', true).setValue(scaleHeight);
        var transformStyle = element.getStyle('transform', true, true);
        transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1.0 / xRatio, ", ").concat(1.0 / yRatio, ")"));
      } // clear and render


      if (!ignoreClear) {
        ctx.clearRect(0, 0, cWidth, cHeight);
      }

      element.render(ctx);

      if (isFirstRender) {
        this.isFirstRender = false;
      }
    }

  }
  Screen.defaultWindow = defaultWindow;
  Screen.defaultFetch = defaultFetch$1;

  var {
    defaultFetch
  } = Screen;
  var DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : null;
  class Parser {
    constructor() {
      var {
        fetch = defaultFetch,
        DOMParser = DefaultDOMParser
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.fetch = fetch;
      this.DOMParser = DOMParser;
    }

    parse(resource) {
      var _this = this;

      return _asyncToGenerator(function* () {
        if (resource.startsWith('<')) {
          return _this.parseFromString(resource);
        }

        return _this.load(resource);
      })();
    }

    parseFromString(xml) {
      var parser = new this.DOMParser();

      try {
        return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));
      } catch (err) {
        return this.checkDocument(parser.parseFromString(xml, 'text/xml'));
      }
    }

    checkDocument(document) {
      var parserError = document.getElementsByTagName('parsererror')[0];

      if (parserError) {
        throw new Error(parserError.textContent);
      }

      return document;
    }

    load(url) {
      var _this2 = this;

      return _asyncToGenerator(function* () {
        var response = yield _this2.fetch(url);
        var xml = yield response.text();
        return _this2.parseFromString(xml);
      })();
    }

  }

  class Translate {
    constructor(_, point) {
      this.type = 'translate';
      this.point = null;
      this.point = Point.parse(point);
    }

    apply(ctx) {
      var {
        x,
        y
      } = this.point;
      ctx.translate(x || 0.0, y || 0.0);
    }

    unapply(ctx) {
      var {
        x,
        y
      } = this.point;
      ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);
    }

    applyToPoint(point) {
      var {
        x,
        y
      } = this.point;
      point.applyTransform([1, 0, 0, 1, x || 0.0, y || 0.0]);
    }

  }

  class Rotate {
    constructor(document, rotate, transformOrigin) {
      this.type = 'rotate';
      this.angle = null;
      this.originX = null;
      this.originY = null;
      this.cx = 0;
      this.cy = 0;
      var numbers = toNumbers(rotate);
      this.angle = new Property(document, 'angle', numbers[0]);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
      this.cx = numbers[1] || 0;
      this.cy = numbers[2] || 0;
    }

    apply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle
      } = this;
      var tx = cx + originX.getPixels('x');
      var ty = cy + originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.rotate(angle.getRadians());
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle
      } = this;
      var tx = cx + originX.getPixels('x');
      var ty = cy + originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.rotate(-1.0 * angle.getRadians());
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      var {
        cx,
        cy,
        angle
      } = this;
      var rad = angle.getRadians();
      point.applyTransform([1, 0, 0, 1, cx || 0.0, cy || 0.0 // this.p.y
      ]);
      point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
      point.applyTransform([1, 0, 0, 1, -cx || 0.0, -cy || 0.0 // -this.p.y
      ]);
    }

  }

  class Scale {
    constructor(_, scale, transformOrigin) {
      this.type = 'scale';
      this.scale = null;
      this.originX = null;
      this.originY = null;
      var scaleSize = Point.parseScale(scale); // Workaround for node-canvas

      if (scaleSize.x === 0 || scaleSize.y === 0) {
        scaleSize.x = PSEUDO_ZERO;
        scaleSize.y = PSEUDO_ZERO;
      }

      this.scale = scaleSize;
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }

    apply(ctx) {
      var {
        scale: {
          x,
          y
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.scale(x, y || x);
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        scale: {
          x,
          y
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.scale(1.0 / x, 1.0 / y || x);
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      var {
        x,
        y
      } = this.scale;
      point.applyTransform([x || 0.0, 0, 0, y || 0.0, 0, 0]);
    }

  }

  class Matrix {
    constructor(_, matrix, transformOrigin) {
      this.type = 'matrix';
      this.matrix = [];
      this.originX = null;
      this.originY = null;
      this.matrix = toNumbers(matrix);
      this.originX = transformOrigin[0];
      this.originY = transformOrigin[1];
    }

    apply(ctx) {
      var {
        originX,
        originY,
        matrix
      } = this;
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      ctx.translate(-tx, -ty);
    }

    unapply(ctx) {
      var {
        originX,
        originY,
        matrix
      } = this;
      var a = matrix[0];
      var b = matrix[2];
      var c = matrix[4];
      var d = matrix[1];
      var e = matrix[3];
      var f = matrix[5];
      var g = 0.0;
      var h = 0.0;
      var i = 1.0;
      var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));
      var tx = originX.getPixels('x');
      var ty = originY.getPixels('y');
      ctx.translate(tx, ty);
      ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));
      ctx.translate(-tx, -ty);
    }

    applyToPoint(point) {
      point.applyTransform(this.matrix);
    }

  }

  class Skew extends Matrix {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skew';
      this.angle = null;
      this.angle = new Property(document, 'angle', skew);
    }

  }

  class SkewX extends Skew {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skewX';
      this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
    }

  }

  class SkewY extends Skew {
    constructor(document, skew, transformOrigin) {
      super(document, skew, transformOrigin);
      this.type = 'skewY';
      this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
    }

  }

  function parseTransforms(transform) {
    return compressSpaces(transform).trim().replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
  }

  function parseTransform(transform) {
    var [type, value] = transform.split('(');
    return [type.trim(), value.trim().replace(')', '')];
  }

  class Transform {
    constructor(document, transform, transformOrigin) {
      this.document = document;
      this.transforms = [];
      var data = parseTransforms(transform);
      data.forEach(transform => {
        if (transform === 'none') {
          return;
        }

        var [type, value] = parseTransform(transform);
        var TransformType = Transform.transformTypes[type];

        if (typeof TransformType !== 'undefined') {
          this.transforms.push(new TransformType(this.document, value, transformOrigin));
        }
      });
    }

    static fromElement(document, element) {
      var transformStyle = element.getStyle('transform', false, true);
      var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();
      var transformOrigin = [transformOriginXProperty, transformOriginYProperty];

      if (transformStyle.hasValue()) {
        return new Transform(document, transformStyle.getString(), transformOrigin);
      }

      return null;
    }

    apply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = 0; i < len; i++) {
        transforms[i].apply(ctx);
      }
    }

    unapply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = len - 1; i >= 0; i--) {
        transforms[i].unapply(ctx);
      }
    } // TODO: applyToPoint unused ... remove?


    applyToPoint(point) {
      var {
        transforms
      } = this;
      var len = transforms.length;

      for (var i = 0; i < len; i++) {
        transforms[i].applyToPoint(point);
      }
    }

  }
  Transform.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
  };

  class Element$1 {
    constructor(document, node) {
      var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.document = document;
      this.node = node;
      this.captureTextNodes = captureTextNodes;
      this.attributes = {};
      this.styles = {};
      this.stylesSpecificity = {};
      this.animationFrozen = false;
      this.animationFrozenValue = '';
      this.parent = null;
      this.children = [];

      if (!node || node.nodeType !== 1) {
        // ELEMENT_NODE
        return;
      } // add attributes


      Array.from(node.attributes).forEach(attribute => {
        var nodeName = normalizeAttributeName(attribute.nodeName);
        this.attributes[nodeName] = new Property(document, nodeName, attribute.value);
      });
      this.addStylesFromStyleDefinition(); // add inline styles

      if (this.getAttribute('style').hasValue()) {
        var styles = this.getAttribute('style').getString().split(';').map(_ => _.trim());
        styles.forEach(style => {
          if (!style) {
            return;
          }

          var [name, value] = style.split(':').map(_ => _.trim());
          this.styles[name] = new Property(document, name, value);
        });
      }

      var {
        definitions
      } = document;
      var id = this.getAttribute('id'); // add id

      if (id.hasValue()) {
        if (!definitions[id.getString()]) {
          definitions[id.getString()] = this;
        }
      }

      Array.from(node.childNodes).forEach(childNode => {
        if (childNode.nodeType === 1) {
          this.addChild(childNode); // ELEMENT_NODE
        } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
          var textNode = document.createTextNode(childNode);

          if (textNode.getText().length > 0) {
            this.addChild(textNode); // TEXT_NODE
          }
        }
      });
    }

    getAttribute(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var attr = this.attributes[name];

      if (!attr && createIfNotExists) {
        var _attr = new Property(this.document, name, '');

        this.attributes[name] = _attr;
        return _attr;
      }

      return attr || Property.empty(this.document);
    }

    getHrefAttribute() {
      for (var key in this.attributes) {
        if (key === 'href' || key.endsWith(':href')) {
          return this.attributes[key];
        }
      }

      return Property.empty(this.document);
    }

    getStyle(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var style = this.styles[name];

      if (style) {
        return style;
      }

      var attr = this.getAttribute(name);

      if (attr !== null && attr !== void 0 && attr.hasValue()) {
        this.styles[name] = attr; // move up to me to cache

        return attr;
      }

      if (!skipAncestors) {
        var {
          parent
        } = this;

        if (parent) {
          var parentStyle = parent.getStyle(name);

          if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
            return parentStyle;
          }
        }
      }

      if (createIfNotExists) {
        var _style = new Property(this.document, name, '');

        this.styles[name] = _style;
        return _style;
      }

      return style || Property.empty(this.document);
    }

    render(ctx) {
      // don't render display=none
      // don't render visibility=hidden
      if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {
        return;
      }

      ctx.save();

      if (this.getStyle('mask').hasValue()) {
        // mask
        var mask = this.getStyle('mask').getDefinition();

        if (mask) {
          this.applyEffects(ctx);
          mask.apply(ctx, this);
        }
      } else if (this.getStyle('filter').getValue('none') !== 'none') {
        // filter
        var filter = this.getStyle('filter').getDefinition();

        if (filter) {
          this.applyEffects(ctx);
          filter.apply(ctx, this);
        }
      } else {
        this.setContext(ctx);
        this.renderChildren(ctx);
        this.clearContext(ctx);
      }

      ctx.restore();
    }

    setContext(_) {// NO RENDER
    }

    applyEffects(ctx) {
      // transform
      var transform = Transform.fromElement(this.document, this);

      if (transform) {
        transform.apply(ctx);
      } // clip


      var clipPathStyleProp = this.getStyle('clip-path', false, true);

      if (clipPathStyleProp.hasValue()) {
        var clip = clipPathStyleProp.getDefinition();

        if (clip) {
          clip.apply(ctx);
        }
      }
    }

    clearContext(_) {// NO RENDER
    }

    renderChildren(ctx) {
      this.children.forEach(child => {
        child.render(ctx);
      });
    }

    addChild(childNode) {
      var child = childNode instanceof Element$1 ? childNode : this.document.createElement(childNode);
      child.parent = this;

      if (!Element$1.ignoreChildTypes.includes(child.type)) {
        this.children.push(child);
      }
    }

    matchesSelector(selector) {
      var _node$getAttribute;

      var {
        node
      } = this;

      if (typeof node.matches === 'function') {
        return node.matches(selector);
      }

      var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'class');

      if (!styleClasses || styleClasses === '') {
        return false;
      }

      return styleClasses.split(' ').some(styleClass => ".".concat(styleClass) === selector);
    }

    addStylesFromStyleDefinition() {
      var {
        styles,
        stylesSpecificity
      } = this.document;

      for (var selector in styles) {
        if (!selector.startsWith('@') && this.matchesSelector(selector)) {
          var style = styles[selector];
          var specificity = stylesSpecificity[selector];

          if (style) {
            for (var name in style) {
              var existingSpecificity = this.stylesSpecificity[name];

              if (typeof existingSpecificity === 'undefined') {
                existingSpecificity = '000';
              }

              if (specificity >= existingSpecificity) {
                this.styles[name] = style[name];
                this.stylesSpecificity[name] = specificity;
              }
            }
          }
        }
      }
    }

    removeStyles(element, ignoreStyles) {
      var toRestore = ignoreStyles.reduce((toRestore, name) => {
        var styleProp = element.getStyle(name);

        if (!styleProp.hasValue()) {
          return toRestore;
        }

        var value = styleProp.getString();
        styleProp.setValue('');
        return [...toRestore, [name, value]];
      }, []);
      return toRestore;
    }

    restoreStyles(element, styles) {
      styles.forEach(_ref => {
        var [name, value] = _ref;
        element.getStyle(name, true).setValue(value);
      });
    }

    isFirstChild() {
      var _this$parent;

      return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
    }

  }
  Element$1.ignoreChildTypes = ['title'];

  class UnknownElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
    }

  }

  function wrapFontFamily(fontFamily) {
    var trimmed = fontFamily.trim();
    return /^('|")/.test(trimmed) ? trimmed : "\"".concat(trimmed, "\"");
  }

  function prepareFontFamily(fontFamily) {
    return typeof process === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
   * @param fontStyle
   * @returns CSS font style.
   */


  function prepareFontStyle(fontStyle) {
    if (!fontStyle) {
      return '';
    }

    var targetFontStyle = fontStyle.trim().toLowerCase();

    switch (targetFontStyle) {
      case 'normal':
      case 'italic':
      case 'oblique':
      case 'inherit':
      case 'initial':
      case 'unset':
        return targetFontStyle;

      default:
        if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
          return targetFontStyle;
        }

        return '';
    }
  }
  /**
   * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
   * @param fontWeight
   * @returns CSS font weight.
   */


  function prepareFontWeight(fontWeight) {
    if (!fontWeight) {
      return '';
    }

    var targetFontWeight = fontWeight.trim().toLowerCase();

    switch (targetFontWeight) {
      case 'normal':
      case 'bold':
      case 'lighter':
      case 'bolder':
      case 'inherit':
      case 'initial':
      case 'unset':
        return targetFontWeight;

      default:
        if (/^[\d.]+$/.test(targetFontWeight)) {
          return targetFontWeight;
        }

        return '';
    }
  }

  class Font {
    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
      var inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};
      this.fontFamily = fontFamily || inheritFont.fontFamily;
      this.fontSize = fontSize || inheritFont.fontSize;
      this.fontStyle = fontStyle || inheritFont.fontStyle;
      this.fontWeight = fontWeight || inheritFont.fontWeight;
      this.fontVariant = fontVariant || inheritFont.fontVariant;
    }

    static parse() {
      var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var inherit = arguments.length > 1 ? arguments[1] : undefined;
      var fontStyle = '';
      var fontVariant = '';
      var fontWeight = '';
      var fontSize = '';
      var fontFamily = '';
      var parts = compressSpaces(font).trim().split(' ');
      var set = {
        fontSize: false,
        fontStyle: false,
        fontWeight: false,
        fontVariant: false
      };
      parts.forEach(part => {
        switch (true) {
          case !set.fontStyle && Font.styles.includes(part):
            if (part !== 'inherit') {
              fontStyle = part;
            }

            set.fontStyle = true;
            break;

          case !set.fontVariant && Font.variants.includes(part):
            if (part !== 'inherit') {
              fontVariant = part;
            }

            set.fontStyle = true;
            set.fontVariant = true;
            break;

          case !set.fontWeight && Font.weights.includes(part):
            if (part !== 'inherit') {
              fontWeight = part;
            }

            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            break;

          case !set.fontSize:
            if (part !== 'inherit') {
              [fontSize] = part.split('/');
            }

            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            set.fontSize = true;
            break;

          default:
            if (part !== 'inherit') {
              fontFamily += part;
            }

        }
      });
      return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);
    }

    toString() {
      return [prepareFontStyle(this.fontStyle), this.fontVariant, prepareFontWeight(this.fontWeight), this.fontSize, // Wrap fontFamily only on nodejs and only for canvas.ctx
      prepareFontFamily(this.fontFamily)].join(' ').trim();
    }

  }
  Font.styles = 'normal|italic|oblique|inherit';
  Font.variants = 'normal|small-caps|inherit';
  Font.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

  class BoundingBox {
    constructor() {
      var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;
      var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;
      var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;
      var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }

    get x() {
      return this.x1;
    }

    get y() {
      return this.y1;
    }

    get width() {
      return this.x2 - this.x1;
    }

    get height() {
      return this.y2 - this.y1;
    }

    addPoint(x, y) {
      if (typeof x !== 'undefined') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = x;
          this.x2 = x;
        }

        if (x < this.x1) {
          this.x1 = x;
        }

        if (x > this.x2) {
          this.x2 = x;
        }
      }

      if (typeof y !== 'undefined') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = y;
          this.y2 = y;
        }

        if (y < this.y1) {
          this.y1 = y;
        }

        if (y > this.y2) {
          this.y2 = y;
        }
      }
    }

    addX(x) {
      this.addPoint(x, null);
    }

    addY(y) {
      this.addPoint(null, y);
    }

    addBoundingBox(boundingBox) {
      if (!boundingBox) {
        return;
      }

      var {
        x1,
        y1,
        x2,
        y2
      } = boundingBox;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }

    sumCubic(t, p0, p1, p2, p3) {
      return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;
    }

    bezierCurveAdd(forX, p0, p1, p2, p3) {
      var b = 6 * p0 - 12 * p1 + 6 * p2;
      var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
      var c = 3 * p1 - 3 * p0;

      if (a === 0) {
        if (b === 0) {
          return;
        }

        var t = -c / b;

        if (0 < t && t < 1) {
          if (forX) {
            this.addX(this.sumCubic(t, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t, p0, p1, p2, p3));
          }
        }

        return;
      }

      var b2ac = Math.pow(b, 2) - 4 * c * a;

      if (b2ac < 0) {
        return;
      }

      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);

      if (0 < t1 && t1 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t1, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t1, p0, p1, p2, p3));
        }
      }

      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);

      if (0 < t2 && t2 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t2, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t2, p0, p1, p2, p3));
        }
      }
    } // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html


    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
      this.addPoint(p0x, p0y);
      this.addPoint(p3x, p3y);
      this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
      this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
    }

    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
      var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)

      var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)

      var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)

      var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)

      this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
    }

    isPointInBox(x, y) {
      var {
        x1,
        y1,
        x2,
        y2
      } = this;
      return x1 <= x && x <= x2 && y1 <= y && y <= y2;
    }

  }

  class PathParser extends _ {
    constructor(path) {
      super(path // Fix spaces after signs.
      .replace(/([+\-.])\s+/gm, '$1') // Remove invalid part.
      .replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ''));
      this.control = null;
      this.start = null;
      this.current = null;
      this.command = null;
      this.commands = this.commands;
      this.i = -1;
      this.previousCommand = null;
      this.points = [];
      this.angles = [];
    }

    reset() {
      this.i = -1;
      this.command = null;
      this.previousCommand = null;
      this.start = new Point(0, 0);
      this.control = new Point(0, 0);
      this.current = new Point(0, 0);
      this.points = [];
      this.angles = [];
    }

    isEnd() {
      var {
        i,
        commands
      } = this;
      return i >= commands.length - 1;
    }

    next() {
      var command = this.commands[++this.i];
      this.previousCommand = this.command;
      this.command = command;
      return command;
    }

    getPoint() {
      var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';
      var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';
      var point = new Point(this.command[xProp], this.command[yProp]);
      return this.makeAbsolute(point);
    }

    getAsControlPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.control = point;
      return point;
    }

    getAsCurrentPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.current = point;
      return point;
    }

    getReflectedControlPoint() {
      var previousCommand = this.previousCommand.type;

      if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
        return this.current;
      } // reflect point


      var {
        current: {
          x: cx,
          y: cy
        },
        control: {
          x: ox,
          y: oy
        }
      } = this;
      var point = new Point(2 * cx - ox, 2 * cy - oy);
      return point;
    }

    makeAbsolute(point) {
      if (this.command.relative) {
        var {
          x,
          y
        } = this.current;
        point.x += x;
        point.y += y;
      }

      return point;
    }

    addMarker(point, from, priorTo) {
      var {
        points,
        angles
      } = this; // if the last angle isn't filled in because we didn't have this point yet ...

      if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
        angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
      }

      this.addMarkerAngle(point, from ? from.angleTo(point) : null);
    }

    addMarkerAngle(point, angle) {
      this.points.push(point);
      this.angles.push(angle);
    }

    getMarkerPoints() {
      return this.points;
    }

    getMarkerAngles() {
      var {
        angles
      } = this;
      var len = angles.length;

      for (var i = 0; i < len; i++) {
        if (!angles[i]) {
          for (var j = i + 1; j < len; j++) {
            if (angles[j]) {
              angles[i] = angles[j];
              break;
            }
          }
        }
      }

      return angles;
    }

  }

  class RenderedElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.modifiedEmSizeStack = false;
    }

    calculateOpacity() {
      var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this

      var element = this;

      while (element) {
        var opacityStyle = element.getStyle('opacity', false, true); // no ancestors on style call

        if (opacityStyle.hasValue(true)) {
          opacity *= opacityStyle.getNumber();
        }

        element = element.parent;
      }

      return opacity;
    }

    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!fromMeasure) {
        // causes stack overflow when measuring text with gradients
        // fill
        var fillStyleProp = this.getStyle('fill');
        var fillOpacityStyleProp = this.getStyle('fill-opacity');
        var strokeStyleProp = this.getStyle('stroke');
        var strokeOpacityProp = this.getStyle('stroke-opacity');

        if (fillStyleProp.isUrlDefinition()) {
          var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);

          if (fillStyle) {
            ctx.fillStyle = fillStyle;
          }
        } else if (fillStyleProp.hasValue()) {
          if (fillStyleProp.getString() === 'currentColor') {
            fillStyleProp.setValue(this.getStyle('color').getColor());
          }

          var _fillStyle = fillStyleProp.getColor();

          if (_fillStyle !== 'inherit') {
            ctx.fillStyle = _fillStyle === 'none' ? 'rgba(0,0,0,0)' : _fillStyle;
          }
        }

        if (fillOpacityStyleProp.hasValue()) {
          var _fillStyle2 = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();

          ctx.fillStyle = _fillStyle2;
        } // stroke


        if (strokeStyleProp.isUrlDefinition()) {
          var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);

          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
          }
        } else if (strokeStyleProp.hasValue()) {
          if (strokeStyleProp.getString() === 'currentColor') {
            strokeStyleProp.setValue(this.getStyle('color').getColor());
          }

          var _strokeStyle = strokeStyleProp.getString();

          if (_strokeStyle !== 'inherit') {
            ctx.strokeStyle = _strokeStyle === 'none' ? 'rgba(0,0,0,0)' : _strokeStyle;
          }
        }

        if (strokeOpacityProp.hasValue()) {
          var _strokeStyle2 = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();

          ctx.strokeStyle = _strokeStyle2;
        }

        var strokeWidthStyleProp = this.getStyle('stroke-width');

        if (strokeWidthStyleProp.hasValue()) {
          var newLineWidth = strokeWidthStyleProp.getPixels();
          ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)
          : newLineWidth;
        }

        var strokeLinecapStyleProp = this.getStyle('stroke-linecap');
        var strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');
        var strokeMiterlimitProp = this.getStyle('stroke-miterlimit'); // NEED TEST
        // const pointOrderStyleProp = this.getStyle('paint-order');

        var strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');
        var strokeDashoffsetProp = this.getStyle('stroke-dashoffset');

        if (strokeLinecapStyleProp.hasValue()) {
          ctx.lineCap = strokeLinecapStyleProp.getString();
        }

        if (strokeLinejoinStyleProp.hasValue()) {
          ctx.lineJoin = strokeLinejoinStyleProp.getString();
        }

        if (strokeMiterlimitProp.hasValue()) {
          ctx.miterLimit = strokeMiterlimitProp.getNumber();
        } // NEED TEST
        // if (pointOrderStyleProp.hasValue()) {
        // 	// ?
        // 	ctx.paintOrder = pointOrderStyleProp.getValue();
        // }


        if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {
          var gaps = toNumbers(strokeDasharrayStyleProp.getString());

          if (typeof ctx.setLineDash !== 'undefined') {
            ctx.setLineDash(gaps);
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.webkitLineDash !== 'undefined') {
              // @ts-expect-error Handle browser prefix.
              ctx.webkitLineDash = gaps;
            } else // @ts-expect-error Handle browser prefix.
              if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {
                // @ts-expect-error Handle browser prefix.
                ctx.mozDash = gaps;
              }

          var offset = strokeDashoffsetProp.getPixels();

          if (typeof ctx.lineDashOffset !== 'undefined') {
            ctx.lineDashOffset = offset;
          } else // @ts-expect-error Handle browser prefix.
            if (typeof ctx.webkitLineDashOffset !== 'undefined') {
              // @ts-expect-error Handle browser prefix.
              ctx.webkitLineDashOffset = offset;
            } else // @ts-expect-error Handle browser prefix.
              if (typeof ctx.mozDashOffset !== 'undefined') {
                // @ts-expect-error Handle browser prefix.
                ctx.mozDashOffset = offset;
              }
        }
      } // font


      this.modifiedEmSizeStack = false;

      if (typeof ctx.font !== 'undefined') {
        var fontStyleProp = this.getStyle('font');
        var fontStyleStyleProp = this.getStyle('font-style');
        var fontVariantStyleProp = this.getStyle('font-variant');
        var fontWeightStyleProp = this.getStyle('font-weight');
        var fontSizeStyleProp = this.getStyle('font-size');
        var fontFamilyStyleProp = this.getStyle('font-family');
        var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
        fontStyleStyleProp.setValue(font.fontStyle);
        fontVariantStyleProp.setValue(font.fontVariant);
        fontWeightStyleProp.setValue(font.fontWeight);
        fontSizeStyleProp.setValue(font.fontSize);
        fontFamilyStyleProp.setValue(font.fontFamily);
        ctx.font = font.toString();

        if (fontSizeStyleProp.isPixels()) {
          this.document.emSize = fontSizeStyleProp.getPixels();
          this.modifiedEmSizeStack = true;
        }
      }

      if (!fromMeasure) {
        // effects
        this.applyEffects(ctx); // opacity

        ctx.globalAlpha = this.calculateOpacity();
      }
    }

    clearContext(ctx) {
      super.clearContext(ctx);

      if (this.modifiedEmSizeStack) {
        this.document.popEmSize();
      }
    }

  }

  class PathElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'path';
      this.pathParser = null;
      this.pathParser = new PathParser(this.getAttribute('d').getString());
    }

    path(ctx) {
      var {
        pathParser
      } = this;
      var boundingBox = new BoundingBox();
      pathParser.reset();

      if (ctx) {
        ctx.beginPath();
      }

      while (!pathParser.isEnd()) {
        switch (pathParser.next().type) {
          case PathParser.MOVE_TO:
            this.pathM(ctx, boundingBox);
            break;

          case PathParser.LINE_TO:
            this.pathL(ctx, boundingBox);
            break;

          case PathParser.HORIZ_LINE_TO:
            this.pathH(ctx, boundingBox);
            break;

          case PathParser.VERT_LINE_TO:
            this.pathV(ctx, boundingBox);
            break;

          case PathParser.CURVE_TO:
            this.pathC(ctx, boundingBox);
            break;

          case PathParser.SMOOTH_CURVE_TO:
            this.pathS(ctx, boundingBox);
            break;

          case PathParser.QUAD_TO:
            this.pathQ(ctx, boundingBox);
            break;

          case PathParser.SMOOTH_QUAD_TO:
            this.pathT(ctx, boundingBox);
            break;

          case PathParser.ARC:
            this.pathA(ctx, boundingBox);
            break;

          case PathParser.CLOSE_PATH:
            this.pathZ(ctx, boundingBox);
            break;
        }
      }

      return boundingBox;
    }

    getBoundingBox(_) {
      return this.path();
    }

    getMarkers() {
      var {
        pathParser
      } = this;
      var points = pathParser.getMarkerPoints();
      var angles = pathParser.getMarkerAngles();
      var markers = points.map((point, i) => [point, angles[i]]);
      return markers;
    }

    renderChildren(ctx) {
      this.path(ctx);
      this.document.screen.mouse.checkPath(this, ctx);
      var fillRuleStyleProp = this.getStyle('fill-rule');

      if (ctx.fillStyle !== '') {
        if (fillRuleStyleProp.getString('inherit') !== 'inherit') {
          ctx.fill(fillRuleStyleProp.getString());
        } else {
          ctx.fill();
        }
      }

      if (ctx.strokeStyle !== '') {
        if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.stroke();
        }
      }

      var markers = this.getMarkers();

      if (markers) {
        var markersLastIndex = markers.length - 1;
        var markerStartStyleProp = this.getStyle('marker-start');
        var markerMidStyleProp = this.getStyle('marker-mid');
        var markerEndStyleProp = this.getStyle('marker-end');

        if (markerStartStyleProp.isUrlDefinition()) {
          var marker = markerStartStyleProp.getDefinition();
          var [point, angle] = markers[0];
          marker.render(ctx, point, angle);
        }

        if (markerMidStyleProp.isUrlDefinition()) {
          var _marker = markerMidStyleProp.getDefinition();

          for (var i = 1; i < markersLastIndex; i++) {
            var [_point, _angle] = markers[i];

            _marker.render(ctx, _point, _angle);
          }
        }

        if (markerEndStyleProp.isUrlDefinition()) {
          var _marker2 = markerEndStyleProp.getDefinition();

          var [_point2, _angle2] = markers[markersLastIndex];

          _marker2.render(ctx, _point2, _angle2);
        }
      }
    }

    static pathM(pathParser) {
      var point = pathParser.getAsCurrentPoint();
      pathParser.start = pathParser.current;
      return {
        point
      };
    }

    pathM(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        point
      } = PathElement.pathM(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.moveTo(x, y);
      }
    }

    static pathL(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getAsCurrentPoint();
      return {
        current,
        point
      };
    }

    pathL(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathL(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathH(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }

    pathH(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathH(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathV(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }

    pathV(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathV(pathParser);
      var {
        x,
        y
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x, y);

      if (ctx) {
        ctx.lineTo(x, y);
      }
    }

    static pathC(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getPoint('x1', 'y1');
      var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }

    pathC(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathS(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getReflectedControlPoint();
      var controlPoint = pathParser.getAsControlPoint('x2', 'y2');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }

    pathS(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathQ(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getAsControlPoint('x1', 'y1');
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }

    pathQ(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathT(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getReflectedControlPoint();
      pathParser.control = controlPoint;
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }

    pathT(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);

      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }

    static pathA(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var {
        rX,
        rY,
        xRot,
        lArcFlag,
        sweepFlag
      } = command;
      var xAxisRotation = xRot * (Math.PI / 180.0);
      var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization
      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
      // x1', y1'

      var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii

      var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);

      if (l > 1) {
        rX *= Math.sqrt(l);
        rY *= Math.sqrt(l);
      } // cx', cy'


      var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));

      if (isNaN(s)) {
        s = 0;
      }

      var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy

      var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle

      var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]); // θ1
      // angle delta

      var u = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
      var v = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
      var ad = vectorsAngle(u, v); // Δθ

      if (vectorsRatio(u, v) <= -1) {
        ad = Math.PI;
      }

      if (vectorsRatio(u, v) >= 1) {
        ad = 0;
      }

      return {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      };
    }

    pathA(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser); // for markers

      var dir = 1 - sweepFlag ? 1.0 : -1.0;
      var ah = a1 + dir * (ad / 2.0);
      var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
      pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
      pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
      boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better

      if (ctx && !isNaN(a1) && !isNaN(ad)) {
        var r = rX > rY ? rX : rY;
        var sx = rX > rY ? 1 : rX / rY;
        var sy = rX > rY ? rY / rX : 1;
        ctx.translate(centp.x, centp.y);
        ctx.rotate(xAxisRotation);
        ctx.scale(sx, sy);
        ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));
        ctx.scale(1 / sx, 1 / sy);
        ctx.rotate(-xAxisRotation);
        ctx.translate(-centp.x, -centp.y);
      }
    }

    static pathZ(pathParser) {
      pathParser.current = pathParser.start;
    }

    pathZ(ctx, boundingBox) {
      PathElement.pathZ(this.pathParser);

      if (ctx) {
        // only close path if it is not a straight line
        if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
          ctx.closePath();
        }
      }
    }

  }

  class GlyphElement extends PathElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'glyph';
      this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
      this.unicode = this.getAttribute('unicode').getString();
      this.arabicForm = this.getAttribute('arabic-form').getString();
    }

  }

  class TextElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, new.target === TextElement ? true : captureTextNodes);
      this.type = 'text';
      this.x = 0;
      this.y = 0;
      this.measureCache = -1;
    }

    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      super.setContext(ctx, fromMeasure);
      var textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();

      if (textBaseline) {
        ctx.textBaseline = textBaseline;
      }
    }

    initializeCoordinates() {
      this.x = 0;
      this.y = 0;
      this.leafTexts = [];
      this.textChunkStart = 0;
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
    }

    getBoundingBox(ctx) {
      if (this.type !== 'text') {
        return this.getTElementBoundingBox(ctx);
      } // first, calculate child positions


      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      var boundingBox = null; // then calculate bounding box

      this.children.forEach((_, i) => {
        var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);

        if (!boundingBox) {
          boundingBox = childBoundingBox;
        } else {
          boundingBox.addBoundingBox(childBoundingBox);
        }
      });
      return boundingBox;
    }

    getFontSize() {
      var {
        document,
        parent
      } = this;
      var inheritFontSize = Font.parse(document.ctx.font).fontSize;
      var fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);
      return fontSize;
    }

    getTElementBoundingBox(ctx) {
      var fontSize = this.getFontSize();
      return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);
    }

    getGlyph(font, text, i) {
      var char = text[i];
      var glyph = null;

      if (font.isArabic) {
        var len = text.length;
        var prevChar = text[i - 1];
        var nextChar = text[i + 1];
        var arabicForm = 'isolated';

        if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {
          arabicForm = 'terminal';
        }

        if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {
          arabicForm = 'medial';
        }

        if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {
          arabicForm = 'initial';
        }

        if (typeof font.glyphs[char] !== 'undefined') {
          // NEED TEST
          var maybeGlyph = font.glyphs[char];
          glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
        }
      } else {
        glyph = font.glyphs[char];
      }

      if (!glyph) {
        glyph = font.missingGlyph;
      }

      return glyph;
    }

    getText() {
      return '';
    }

    getTextFromNode(node) {
      var textNode = node || this.node;
      var childNodes = Array.from(textNode.parentNode.childNodes);
      var index = childNodes.indexOf(textNode);
      var lastIndex = childNodes.length - 1;
      var text = compressSpaces( // textNode.value
      // || textNode.text
      textNode.textContent || '');

      if (index === 0) {
        text = trimLeft(text);
      }

      if (index === lastIndex) {
        text = trimRight(text);
      }

      return text;
    }

    renderChildren(ctx) {
      if (this.type !== 'text') {
        this.renderTElementChildren(ctx);
        return;
      } // first, calculate child positions


      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx); // then render

      this.children.forEach((_, i) => {
        this.renderChild(ctx, this, this, i);
      });
      var {
        mouse
      } = this.document.screen; // Do not calc bounding box if mouse is not working.

      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
      }
    }

    renderTElementChildren(ctx) {
      var {
        document,
        parent
      } = this;
      var renderText = this.getText();
      var customFont = parent.getStyle('font-family').getDefinition();

      if (customFont) {
        var {
          unitsPerEm
        } = customFont.fontFace;
        var ctxFont = Font.parse(document.ctx.font);
        var fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);
        var fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);
        var scale = fontSize / unitsPerEm;
        var text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;
        var dx = toNumbers(parent.getAttribute('dx').getString());
        var len = text.length;

        for (var i = 0; i < len; i++) {
          var glyph = this.getGlyph(customFont, text, i);
          ctx.translate(this.x, this.y);
          ctx.scale(scale, -scale);
          var lw = ctx.lineWidth;
          ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;

          if (fontStyle === 'italic') {
            ctx.transform(1, 0, .4, 1, 0, 0);
          }

          glyph.render(ctx);

          if (fontStyle === 'italic') {
            ctx.transform(1, 0, -.4, 1, 0, 0);
          }

          ctx.lineWidth = lw;
          ctx.scale(1 / scale, -1 / scale);
          ctx.translate(-this.x, -this.y);
          this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;

          if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
            this.x += dx[i];
          }
        }

        return;
      }

      var {
        x,
        y
      } = this; // NEED TEST
      // if (ctx.paintOrder === 'stroke') {
      // 	if (ctx.strokeStyle) {
      // 		ctx.strokeText(renderText, x, y);
      // 	}
      // 	if (ctx.fillStyle) {
      // 		ctx.fillText(renderText, x, y);
      // 	}
      // } else {

      if (ctx.fillStyle) {
        ctx.fillText(renderText, x, y);
      }

      if (ctx.strokeStyle) {
        ctx.strokeText(renderText, x, y);
      } // }

    }

    applyAnchoring() {
      if (this.textChunkStart >= this.leafTexts.length) {
        return;
      } // This is basically the "Apply anchoring" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.
      // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.
      // Vertical text is not supported.


      var firstElement = this.leafTexts[this.textChunkStart];
      var textAnchor = firstElement.getStyle('text-anchor').getString('start');
      var isRTL = false; // we treat RTL like LTR

      var shift = 0;

      if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {
        shift = firstElement.x - this.minX;
      } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {
        shift = firstElement.x - this.maxX;
      } else {
        shift = firstElement.x - (this.minX + this.maxX) / 2;
      }

      for (var i = this.textChunkStart; i < this.leafTexts.length; i++) {
        this.leafTexts[i].x += shift;
      } // start new chunk


      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.textChunkStart = this.leafTexts.length;
    }

    adjustChildCoordinatesRecursive(ctx) {
      this.children.forEach((_, i) => {
        this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);
      });
      this.applyAnchoring();
    }

    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {
      var child = parent.children[i];

      if (child.children.length > 0) {
        child.children.forEach((_, i) => {
          textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);
        });
      } else {
        // only leafs are relevant
        this.adjustChildCoordinates(ctx, textParent, parent, i);
      }
    }

    adjustChildCoordinates(ctx, textParent, parent, i) {
      var child = parent.children[i];

      if (typeof child.measureText !== 'function') {
        return child;
      }

      ctx.save();
      child.setContext(ctx, true);
      var xAttr = child.getAttribute('x');
      var yAttr = child.getAttribute('y');
      var dxAttr = child.getAttribute('dx');
      var dyAttr = child.getAttribute('dy');
      var customFont = child.getStyle('font-family').getDefinition();
      var isRTL = Boolean(customFont) && customFont.isRTL;

      if (i === 0) {
        // First children inherit attributes from parent(s). Positional attributes
        // are only inherited from a parent to it's first child.
        if (!xAttr.hasValue()) {
          xAttr.setValue(child.getInheritedAttribute('x'));
        }

        if (!yAttr.hasValue()) {
          yAttr.setValue(child.getInheritedAttribute('y'));
        }

        if (!dxAttr.hasValue()) {
          dxAttr.setValue(child.getInheritedAttribute('dx'));
        }

        if (!dyAttr.hasValue()) {
          dyAttr.setValue(child.getInheritedAttribute('dy'));
        }
      }

      var width = child.measureText(ctx);

      if (isRTL) {
        textParent.x -= width;
      }

      if (xAttr.hasValue()) {
        // an "x" attribute marks the start of a new chunk
        textParent.applyAnchoring();
        child.x = xAttr.getPixels('x');

        if (dxAttr.hasValue()) {
          child.x += dxAttr.getPixels('x');
        }
      } else {
        if (dxAttr.hasValue()) {
          textParent.x += dxAttr.getPixels('x');
        }

        child.x = textParent.x;
      }

      textParent.x = child.x;

      if (!isRTL) {
        textParent.x += width;
      }

      if (yAttr.hasValue()) {
        child.y = yAttr.getPixels('y');

        if (dyAttr.hasValue()) {
          child.y += dyAttr.getPixels('y');
        }
      } else {
        if (dyAttr.hasValue()) {
          textParent.y += dyAttr.getPixels('y');
        }

        child.y = textParent.y;
      }

      textParent.y = child.y; // update the current chunk and it's bounds

      textParent.leafTexts.push(child);
      textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
      textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
      child.clearContext(ctx);
      ctx.restore();
      return child;
    }

    getChildBoundingBox(ctx, textParent, parent, i) {
      var child = parent.children[i]; // not a text node?

      if (typeof child.getBoundingBox !== 'function') {
        return null;
      }

      var boundingBox = child.getBoundingBox(ctx);

      if (!boundingBox) {
        return null;
      }

      child.children.forEach((_, i) => {
        var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);
        boundingBox.addBoundingBox(childBoundingBox);
      });
      return boundingBox;
    }

    renderChild(ctx, textParent, parent, i) {
      var child = parent.children[i];
      child.render(ctx);
      child.children.forEach((_, i) => {
        textParent.renderChild(ctx, textParent, child, i);
      });
    }

    measureText(ctx) {
      var {
        measureCache
      } = this;

      if (~measureCache) {
        return measureCache;
      }

      var renderText = this.getText();
      var measure = this.measureTargetText(ctx, renderText);
      this.measureCache = measure;
      return measure;
    }

    measureTargetText(ctx, targetText) {
      if (!targetText.length) {
        return 0;
      }

      var {
        parent
      } = this;
      var customFont = parent.getStyle('font-family').getDefinition();

      if (customFont) {
        var fontSize = this.getFontSize();
        var text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;
        var dx = toNumbers(parent.getAttribute('dx').getString());
        var len = text.length;
        var _measure = 0;

        for (var i = 0; i < len; i++) {
          var glyph = this.getGlyph(customFont, text, i);
          _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;

          if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {
            _measure += dx[i];
          }
        }

        return _measure;
      }

      if (!ctx.measureText) {
        return targetText.length * 10;
      }

      ctx.save();
      this.setContext(ctx, true);
      var {
        width: measure
      } = ctx.measureText(targetText);
      this.clearContext(ctx);
      ctx.restore();
      return measure;
    }
    /**
     * Inherits positional attributes from {@link TextElement} parent(s). Attributes
     * are only inherited from a parent to its first child.
     * @param name - The attribute name.
     * @returns The attribute value or null.
     */


    getInheritedAttribute(name) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
      var current = this;

      while (current instanceof TextElement && current.isFirstChild()) {
        var parentAttr = current.parent.getAttribute(name);

        if (parentAttr.hasValue(true)) {
          return parentAttr.getValue('0');
        }

        current = current.parent;
      }

      return null;
    }

  }

  class TSpanElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, new.target === TSpanElement ? true : captureTextNodes);
      this.type = 'tspan'; // if this node has children, then they own the text

      this.text = this.children.length > 0 ? '' : this.getTextFromNode();
    }

    getText() {
      return this.text;
    }

  }

  class TextNode extends TSpanElement {
    constructor() {
      super(...arguments);
      this.type = 'textNode';
    }

  }

  class SVGElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'svg';
      this.root = false;
    }

    setContext(ctx) {
      var _this$node$parentNode;

      var {
        document
      } = this;
      var {
        screen,
        window
      } = document;
      var canvas = ctx.canvas;
      screen.setDefaults(ctx);

      if (canvas.style && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {
        ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');
        var fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);

        if (fontSizeProp.hasValue()) {
          document.rootEmSize = fontSizeProp.getPixels('y');
          document.emSize = document.rootEmSize;
        }
      } // create new view port


      if (!this.getAttribute('x').hasValue()) {
        this.getAttribute('x', true).setValue(0);
      }

      if (!this.getAttribute('y').hasValue()) {
        this.getAttribute('y', true).setValue(0);
      }

      var {
        width,
        height
      } = screen.viewPort;

      if (!this.getStyle('width').hasValue()) {
        this.getStyle('width', true).setValue('100%');
      }

      if (!this.getStyle('height').hasValue()) {
        this.getStyle('height', true).setValue('100%');
      }

      if (!this.getStyle('color').hasValue()) {
        this.getStyle('color', true).setValue('black');
      }

      var refXAttr = this.getAttribute('refX');
      var refYAttr = this.getAttribute('refY');
      var viewBoxAttr = this.getAttribute('viewBox');
      var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
      var clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';
      var minX = 0;
      var minY = 0;
      var clipX = 0;
      var clipY = 0;

      if (viewBox) {
        minX = viewBox[0];
        minY = viewBox[1];
      }

      if (!this.root) {
        width = this.getStyle('width').getPixels('x');
        height = this.getStyle('height').getPixels('y');

        if (this.type === 'marker') {
          clipX = minX;
          clipY = minY;
          minX = 0;
          minY = 0;
        }
      }

      screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements
      // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin

      if (this.node // is not temporary SVGElement
      && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {
        this.getStyle('transform-origin', true, true).setValue('50% 50%');
      }

      super.setContext(ctx);
      ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));

      if (viewBox) {
        width = viewBox[2];
        height = viewBox[3];
      }

      document.setViewBox({
        ctx,
        aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
        width: screen.viewPort.width,
        desiredWidth: width,
        height: screen.viewPort.height,
        desiredHeight: height,
        minX,
        minY,
        refX: refXAttr.getValue(),
        refY: refYAttr.getValue(),
        clip,
        clipX,
        clipY
      });

      if (viewBox) {
        screen.viewPort.removeCurrent();
        screen.viewPort.setCurrent(width, height);
      }
    }

    clearContext(ctx) {
      super.clearContext(ctx);
      this.document.screen.viewPort.removeCurrent();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */


    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var widthAttr = this.getAttribute('width', true);
      var heightAttr = this.getAttribute('height', true);
      var viewBoxAttr = this.getAttribute('viewBox');
      var styleAttr = this.getAttribute('style');
      var originWidth = widthAttr.getNumber(0);
      var originHeight = heightAttr.getNumber(0);

      if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === 'string') {
          this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);
        } else {
          var preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');

          if (preserveAspectRatioAttr.hasValue()) {
            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, '$1'));
          }
        }
      }

      widthAttr.setValue(width);
      heightAttr.setValue(height);

      if (!viewBoxAttr.hasValue()) {
        viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
      }

      if (styleAttr.hasValue()) {
        var widthStyle = this.getStyle('width');
        var heightStyle = this.getStyle('height');

        if (widthStyle.hasValue()) {
          widthStyle.setValue("".concat(width, "px"));
        }

        if (heightStyle.hasValue()) {
          heightStyle.setValue("".concat(height, "px"));
        }
      }
    }

  }

  class RectElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'rect';
    }

    path(ctx) {
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width', false, true).getPixels('x');
      var height = this.getStyle('height', false, true).getPixels('y');
      var rxAttr = this.getAttribute('rx');
      var ryAttr = this.getAttribute('ry');
      var rx = rxAttr.getPixels('x');
      var ry = ryAttr.getPixels('y');

      if (rxAttr.hasValue() && !ryAttr.hasValue()) {
        ry = rx;
      }

      if (ryAttr.hasValue() && !rxAttr.hasValue()) {
        rx = ry;
      }

      rx = Math.min(rx, width / 2.0);
      ry = Math.min(ry, height / 2.0);

      if (ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        ctx.beginPath(); // always start the path so we don't fill prior paths

        if (height > 0 && width > 0) {
          ctx.moveTo(x + rx, y);
          ctx.lineTo(x + width - rx, y);
          ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);
          ctx.lineTo(x + width, y + height - ry);
          ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);
          ctx.lineTo(x + rx, y + height);
          ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);
          ctx.lineTo(x, y + ry);
          ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);
          ctx.closePath();
        }
      }

      return new BoundingBox(x, y, x + width, y + height);
    }

    getMarkers() {
      return null;
    }

  }

  class CircleElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'circle';
    }

    path(ctx) {
      var cx = this.getAttribute('cx').getPixels('x');
      var cy = this.getAttribute('cy').getPixels('y');
      var r = this.getAttribute('r').getPixels();

      if (ctx && r > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2, false);
        ctx.closePath();
      }

      return new BoundingBox(cx - r, cy - r, cx + r, cy + r);
    }

    getMarkers() {
      return null;
    }

  }

  class EllipseElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'ellipse';
    }

    path(ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      var rx = this.getAttribute('rx').getPixels('x');
      var ry = this.getAttribute('ry').getPixels('y');
      var cx = this.getAttribute('cx').getPixels('x');
      var cy = this.getAttribute('cy').getPixels('y');

      if (ctx && rx > 0 && ry > 0) {
        ctx.beginPath();
        ctx.moveTo(cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
        ctx.closePath();
      }

      return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }

    getMarkers() {
      return null;
    }

  }

  class LineElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'line';
    }

    getPoints() {
      return [new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')), new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))];
    }

    path(ctx) {
      var [{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }] = this.getPoints();

      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
      }

      return new BoundingBox(x0, y0, x1, y1);
    }

    getMarkers() {
      var [p0, p1] = this.getPoints();
      var a = p0.angleTo(p1);
      return [[p0, a], [p1, a]];
    }

  }

  class PolylineElement extends PathElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'polyline';
      this.points = [];
      this.points = Point.parsePath(this.getAttribute('points').getString());
    }

    path(ctx) {
      var {
        points
      } = this;
      var [{
        x: x0,
        y: y0
      }] = points;
      var boundingBox = new BoundingBox(x0, y0);

      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
      }

      points.forEach(_ref => {
        var {
          x,
          y
        } = _ref;
        boundingBox.addPoint(x, y);

        if (ctx) {
          ctx.lineTo(x, y);
        }
      });
      return boundingBox;
    }

    getMarkers() {
      var {
        points
      } = this;
      var lastIndex = points.length - 1;
      var markers = [];
      points.forEach((point, i) => {
        if (i === lastIndex) {
          return;
        }

        markers.push([point, point.angleTo(points[i + 1])]);
      });

      if (markers.length > 0) {
        markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
      }

      return markers;
    }

  }

  class PolygonElement extends PolylineElement {
    constructor() {
      super(...arguments);
      this.type = 'polygon';
    }

    path(ctx) {
      var boundingBox = super.path(ctx);
      var [{
        x,
        y
      }] = this.points;

      if (ctx) {
        ctx.lineTo(x, y);
        ctx.closePath();
      }

      return boundingBox;
    }

  }

  class PatternElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'pattern';
    }

    createPattern(ctx, _, parentOpacityProp) {
      var width = this.getStyle('width').getPixels('x', true);
      var height = this.getStyle('height').getPixels('y', true); // render me using a temporary svg element

      var patternSvg = new SVGElement(this.document, null);
      patternSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
      patternSvg.attributes.width = new Property(this.document, 'width', "".concat(width, "px"));
      patternSvg.attributes.height = new Property(this.document, 'height', "".concat(height, "px"));
      patternSvg.attributes.transform = new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue());
      patternSvg.children = this.children;
      var patternCanvas = this.document.createCanvas(width, height);
      var patternCtx = patternCanvas.getContext('2d');
      var xAttr = this.getAttribute('x');
      var yAttr = this.getAttribute('y');

      if (xAttr.hasValue() && yAttr.hasValue()) {
        patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));
      }

      if (parentOpacityProp.hasValue()) {
        this.styles['fill-opacity'] = parentOpacityProp;
      } else {
        Reflect.deleteProperty(this.styles, 'fill-opacity');
      } // render 3x3 grid so when we transform there's no white space on edges


      for (var x = -1; x <= 1; x++) {
        for (var y = -1; y <= 1; y++) {
          patternCtx.save();
          patternSvg.attributes.x = new Property(this.document, 'x', x * patternCanvas.width);
          patternSvg.attributes.y = new Property(this.document, 'y', y * patternCanvas.height);
          patternSvg.render(patternCtx);
          patternCtx.restore();
        }
      }

      var pattern = ctx.createPattern(patternCanvas, 'repeat');
      return pattern;
    }

  }

  class MarkerElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'marker';
    }

    render(ctx, point, angle) {
      if (!point) {
        return;
      }

      var {
        x,
        y
      } = point;
      var orient = this.getAttribute('orient').getString('auto');
      var markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');
      ctx.translate(x, y);

      if (orient === 'auto') {
        ctx.rotate(angle);
      }

      if (markerUnits === 'strokeWidth') {
        ctx.scale(ctx.lineWidth, ctx.lineWidth);
      }

      ctx.save(); // render me using a temporary svg element

      var markerSvg = new SVGElement(this.document, null);
      markerSvg.type = this.type;
      markerSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());
      markerSvg.attributes.refX = new Property(this.document, 'refX', this.getAttribute('refX').getValue());
      markerSvg.attributes.refY = new Property(this.document, 'refY', this.getAttribute('refY').getValue());
      markerSvg.attributes.width = new Property(this.document, 'width', this.getAttribute('markerWidth').getValue());
      markerSvg.attributes.height = new Property(this.document, 'height', this.getAttribute('markerHeight').getValue());
      markerSvg.attributes.overflow = new Property(this.document, 'overflow', this.getAttribute('overflow').getValue());
      markerSvg.attributes.fill = new Property(this.document, 'fill', this.getAttribute('fill').getColor('black'));
      markerSvg.attributes.stroke = new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none'));
      markerSvg.children = this.children;
      markerSvg.render(ctx);
      ctx.restore();

      if (markerUnits === 'strokeWidth') {
        ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
      }

      if (orient === 'auto') {
        ctx.rotate(-angle);
      }

      ctx.translate(-x, -y);
    }

  }

  class DefsElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'defs';
    }

    render() {// NOOP
    }

  }

  class GElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'g';
    }

    getBoundingBox(ctx) {
      var boundingBox = new BoundingBox();
      this.children.forEach(child => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      return boundingBox;
    }

  }

  class GradientElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.attributesToInherit = ['gradientUnits'];
      this.stops = [];
      var {
        stops,
        children
      } = this;
      children.forEach(child => {
        if (child.type === 'stop') {
          stops.push(child);
        }
      });
    }

    getGradientUnits() {
      return this.getAttribute('gradientUnits').getString('objectBoundingBox');
    }

    createGradient(ctx, element, parentOpacityProp) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this
      var stopsContainer = this;

      if (this.getHrefAttribute().hasValue()) {
        stopsContainer = this.getHrefAttribute().getDefinition();
        this.inheritStopContainer(stopsContainer);
      }

      var {
        stops
      } = stopsContainer;
      var gradient = this.getGradient(ctx, element);

      if (!gradient) {
        return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
      }

      stops.forEach(stop => {
        gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
      });

      if (this.getAttribute('gradientTransform').hasValue()) {
        // render as transformed pattern on temporary canvas
        var {
          document
        } = this;
        var {
          MAX_VIRTUAL_PIXELS,
          viewPort
        } = document.screen;
        var [rootView] = viewPort.viewPorts;
        var rect = new RectElement(document, null);
        rect.attributes.x = new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3.0);
        rect.attributes.y = new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3.0);
        rect.attributes.width = new Property(document, 'width', MAX_VIRTUAL_PIXELS);
        rect.attributes.height = new Property(document, 'height', MAX_VIRTUAL_PIXELS);
        var group = new GElement(document, null);
        group.attributes.transform = new Property(document, 'transform', this.getAttribute('gradientTransform').getValue());
        group.children = [rect];
        var patternSvg = new SVGElement(document, null);
        patternSvg.attributes.x = new Property(document, 'x', 0);
        patternSvg.attributes.y = new Property(document, 'y', 0);
        patternSvg.attributes.width = new Property(document, 'width', rootView.width);
        patternSvg.attributes.height = new Property(document, 'height', rootView.height);
        patternSvg.children = [group];
        var patternCanvas = document.createCanvas(rootView.width, rootView.height);
        var patternCtx = patternCanvas.getContext('2d');
        patternCtx.fillStyle = gradient;
        patternSvg.render(patternCtx);
        return patternCtx.createPattern(patternCanvas, 'no-repeat');
      }

      return gradient;
    }

    inheritStopContainer(stopsContainer) {
      this.attributesToInherit.forEach(attributeToInherit => {
        if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
          this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
        }
      });
    }

    addParentOpacity(parentOpacityProp, color) {
      if (parentOpacityProp.hasValue()) {
        var colorProp = new Property(this.document, 'color', color);
        return colorProp.addOpacity(parentOpacityProp).getColor();
      }

      return color;
    }

  }

  class LinearGradientElement extends GradientElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'linearGradient';
      this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');
    }

    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
      var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;

      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }

      if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {
        this.getAttribute('x1', true).setValue(0);
        this.getAttribute('y1', true).setValue(0);
        this.getAttribute('x2', true).setValue(1);
        this.getAttribute('y2', true).setValue(0);
      }

      var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');
      var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');
      var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');
      var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');

      if (x1 === x2 && y1 === y2) {
        return null;
      }

      return ctx.createLinearGradient(x1, y1, x2, y2);
    }

  }

  class RadialGradientElement extends GradientElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'radialGradient';
      this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');
    }

    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';
      var boundingBox = element.getBoundingBox(ctx);

      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }

      if (!this.getAttribute('cx').hasValue()) {
        this.getAttribute('cx', true).setValue('50%');
      }

      if (!this.getAttribute('cy').hasValue()) {
        this.getAttribute('cy', true).setValue('50%');
      }

      if (!this.getAttribute('r').hasValue()) {
        this.getAttribute('r', true).setValue('50%');
      }

      var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');
      var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');
      var fx = cx;
      var fy = cy;

      if (this.getAttribute('fx').hasValue()) {
        fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');
      }

      if (this.getAttribute('fy').hasValue()) {
        fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');
      }

      var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();
      var fr = this.getAttribute('fr').getPixels();
      return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);
    }

  }

  class StopElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'stop';
      var offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));
      var stopOpacity = this.getStyle('stop-opacity');
      var stopColor = this.getStyle('stop-color', true);

      if (stopColor.getString() === '') {
        stopColor.setValue('#000');
      }

      if (stopOpacity.hasValue()) {
        stopColor = stopColor.addOpacity(stopOpacity);
      }

      this.offset = offset;
      this.color = stopColor.getColor();
    }

  }

  class AnimateElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'animate';
      this.duration = 0;
      this.initialValue = null;
      this.initialUnits = '';
      this.removed = false;
      this.frozen = false;
      document.screen.animations.push(this);
      this.begin = this.getAttribute('begin').getMilliseconds();
      this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();
      this.from = this.getAttribute('from');
      this.to = this.getAttribute('to');
      this.values = new Property(document, 'values', null);
      var valuesAttr = this.getAttribute('values');

      if (valuesAttr.hasValue()) {
        this.values.setValue(valuesAttr.getString().split(';'));
      }
    }

    getProperty() {
      var attributeType = this.getAttribute('attributeType').getString();
      var attributeName = this.getAttribute('attributeName').getString();

      if (attributeType === 'CSS') {
        return this.parent.getStyle(attributeName, true);
      }

      return this.parent.getAttribute(attributeName, true);
    }

    calcValue() {
      var {
        initialUnits
      } = this;
      var {
        progress,
        from,
        to
      } = this.getProgress(); // tween value linearly

      var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;

      if (initialUnits === '%') {
        newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100
      }

      return "".concat(newValue).concat(initialUnits);
    }

    update(delta) {
      var {
        parent
      } = this;
      var prop = this.getProperty(); // set initial value

      if (!this.initialValue) {
        this.initialValue = prop.getString();
        this.initialUnits = prop.getUnits();
      } // if we're past the end time


      if (this.duration > this.maxDuration) {
        var fill = this.getAttribute('fill').getString('remove'); // loop for indefinitely repeating animations

        if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {
          this.duration = 0;
        } else if (fill === 'freeze' && !this.frozen) {
          this.frozen = true;
          parent.animationFrozen = true;
          parent.animationFrozenValue = prop.getString();
        } else if (fill === 'remove' && !this.removed) {
          this.removed = true;
          prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
          return true;
        }

        return false;
      }

      this.duration += delta; // if we're past the begin time

      var updated = false;

      if (this.begin < this.duration) {
        var newValue = this.calcValue(); // tween

        var typeAttr = this.getAttribute('type');

        if (typeAttr.hasValue()) {
          // for transform, etc.
          var type = typeAttr.getString();
          newValue = "".concat(type, "(").concat(newValue, ")");
        }

        prop.setValue(newValue);
        updated = true;
      }

      return updated;
    }

    getProgress() {
      var {
        document,
        values
      } = this;
      var result = {
        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
      };

      if (values.hasValue()) {
        var p = result.progress * (values.getValue().length - 1);
        var lb = Math.floor(p);
        var ub = Math.ceil(p);
        result.from = new Property(document, 'from', parseFloat(values.getValue()[lb]));
        result.to = new Property(document, 'to', parseFloat(values.getValue()[ub]));
        result.progress = (p - lb) / (ub - lb);
      } else {
        result.from = this.from;
        result.to = this.to;
      }

      return result;
    }

  }

  class AnimateColorElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = 'animateColor';
    }

    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var colorFrom = new rgbcolor(from.getColor());
      var colorTo = new rgbcolor(to.getColor());

      if (colorFrom.ok && colorTo.ok) {
        // tween color linearly
        var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
        var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
        var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha

        return "rgb(".concat(Math.floor(r), ", ").concat(Math.floor(g), ", ").concat(Math.floor(b), ")");
      }

      return this.getAttribute('from').getColor();
    }

  }

  class AnimateTransformElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = 'animateTransform';
    }

    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress(); // tween value linearly

      var transformFrom = toNumbers(from.getString());
      var transformTo = toNumbers(to.getString());
      var newValue = transformFrom.map((from, i) => {
        var to = transformTo[i];
        return from + (to - from) * progress;
      }).join(' ');
      return newValue;
    }

  }

  class FontElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'font';
      this.glyphs = {};
      this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();
      var {
        definitions
      } = document;
      var {
        children
      } = this;

      for (var child of children) {
        switch (child.type) {
          case 'font-face':
            {
              this.fontFace = child;
              var fontFamilyStyle = child.getStyle('font-family');

              if (fontFamilyStyle.hasValue()) {
                definitions[fontFamilyStyle.getString()] = this;
              }

              break;
            }

          case 'missing-glyph':
            this.missingGlyph = child;
            break;

          case 'glyph':
            {
              var glyph = child;

              if (glyph.arabicForm) {
                this.isRTL = true;
                this.isArabic = true;

                if (typeof this.glyphs[glyph.unicode] === 'undefined') {
                  this.glyphs[glyph.unicode] = {};
                }

                this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
              } else {
                this.glyphs[glyph.unicode] = glyph;
              }

              break;
            }
        }
      }
    }

    render() {// NO RENDER
    }

  }

  class FontFaceElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'font-face';
      this.ascent = this.getAttribute('ascent').getNumber();
      this.descent = this.getAttribute('descent').getNumber();
      this.unitsPerEm = this.getAttribute('units-per-em').getNumber();
    }

  }

  class MissingGlyphElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = 'missing-glyph';
      this.horizAdvX = 0;
    }

  }

  class TRefElement extends TextElement {
    constructor() {
      super(...arguments);
      this.type = 'tref';
    }

    getText() {
      var element = this.getHrefAttribute().getDefinition();

      if (element) {
        var firstChild = element.children[0];

        if (firstChild) {
          return firstChild.getText();
        }
      }

      return '';
    }

  }

  class AElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'a';
      var {
        childNodes
      } = node;
      var firstChild = childNodes[0];
      var hasText = childNodes.length > 0 && Array.from(childNodes).every(node => node.nodeType === 3);
      this.hasText = hasText;
      this.text = hasText ? this.getTextFromNode(firstChild) : '';
    }

    getText() {
      return this.text;
    }

    renderChildren(ctx) {
      if (this.hasText) {
        // render as text element
        super.renderChildren(ctx);
        var {
          document,
          x,
          y
        } = this;
        var {
          mouse
        } = document.screen;
        var fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.

        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));
        }
      } else if (this.children.length > 0) {
        // render as temporary group
        var g = new GElement(this.document, null);
        g.children = this.children;
        g.parent = this;
        g.render(ctx);
      }
    }

    onClick() {
      var {
        window
      } = this.document;

      if (window) {
        window.open(this.getHrefAttribute().getString());
      }
    }

    onMouseMove() {
      var ctx = this.document.ctx;
      ctx.canvas.style.cursor = 'pointer';
    }

  }

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  class TextPathElement extends TextElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'textPath';
      this.textWidth = 0;
      this.textHeight = 0;
      this.pathLength = -1;
      this.glyphInfo = null;
      this.letterSpacingCache = [];
      this.measuresCache = new Map([['', 0]]);
      var pathElement = this.getHrefAttribute().getDefinition();
      this.text = this.getTextFromNode();
      this.dataArray = this.parsePathData(pathElement);
    }

    getText() {
      return this.text;
    }

    path(ctx) {
      var {
        dataArray
      } = this;

      if (ctx) {
        ctx.beginPath();
      }

      dataArray.forEach(_ref => {
        var {
          type,
          points
        } = _ref;

        switch (type) {
          case PathParser.LINE_TO:
            if (ctx) {
              ctx.lineTo(points[0], points[1]);
            }

            break;

          case PathParser.MOVE_TO:
            if (ctx) {
              ctx.moveTo(points[0], points[1]);
            }

            break;

          case PathParser.CURVE_TO:
            if (ctx) {
              ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
            }

            break;

          case PathParser.QUAD_TO:
            if (ctx) {
              ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
            }

            break;

          case PathParser.ARC:
            {
              var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;

              if (ctx) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              }

              break;
            }

          case PathParser.CLOSE_PATH:
            if (ctx) {
              ctx.closePath();
            }

            break;
        }
      });
    }

    renderChildren(ctx) {
      this.setTextData(ctx);
      ctx.save();
      var textDecoration = this.parent.getStyle('text-decoration').getString();
      var fontSize = this.getFontSize();
      var {
        glyphInfo
      } = this;
      var fill = ctx.fillStyle;

      if (textDecoration === 'underline') {
        ctx.beginPath();
      }

      glyphInfo.forEach((glyph, i) => {
        var {
          p0,
          p1,
          rotation,
          text: partialText
        } = glyph;
        ctx.save();
        ctx.translate(p0.x, p0.y);
        ctx.rotate(rotation);

        if (ctx.fillStyle) {
          ctx.fillText(partialText, 0, 0);
        }

        if (ctx.strokeStyle) {
          ctx.strokeText(partialText, 0, 0);
        }

        ctx.restore();

        if (textDecoration === 'underline') {
          if (i === 0) {
            ctx.moveTo(p0.x, p0.y + fontSize / 8);
          }

          ctx.lineTo(p1.x, p1.y + fontSize / 5);
        } // // To assist with debugging visually, uncomment following
        //
        // ctx.beginPath();
        // if (i % 2)
        // 	ctx.strokeStyle = 'red';
        // else
        // 	ctx.strokeStyle = 'green';
        // ctx.moveTo(p0.x, p0.y);
        // ctx.lineTo(p1.x, p1.y);
        // ctx.stroke();
        // ctx.closePath();

      });

      if (textDecoration === 'underline') {
        ctx.lineWidth = fontSize / 20;
        ctx.strokeStyle = fill;
        ctx.stroke();
        ctx.closePath();
      }

      ctx.restore();
    }

    getLetterSpacingAt() {
      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.letterSpacingCache[idx] || 0;
    }

    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {
      var offset = inputOffset;
      var glyphWidth = this.measureText(ctx, c);

      if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {
        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
      }

      if (charI > -1) {
        offset += this.getLetterSpacingAt(charI);
      }

      var splineStep = this.textHeight / 20;
      var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
      var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
      var segment = {
        p0,
        p1
      };
      var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;

      if (dy) {
        var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
        var dyY = Math.cos(-rotation) * dy;
        segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
          x: p0.x + dyX,
          y: p0.y + dyY
        });
        segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
          x: p1.x + dyX,
          y: p1.y + dyY
        });
      }

      offset += glyphWidth;
      return {
        offset,
        segment,
        rotation
      };
    }

    measureText(ctx, text) {
      var {
        measuresCache
      } = this;
      var targetText = text || this.getText();

      if (measuresCache.has(targetText)) {
        return measuresCache.get(targetText);
      }

      var measure = this.measureTargetText(ctx, targetText);
      measuresCache.set(targetText, measure);
      return measure;
    } // This method supposes what all custom fonts already loaded.
    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
    // You need to call this method manually to update glyphs cache.


    setTextData(ctx) {
      if (this.glyphInfo) {
        return;
      }

      var renderText = this.getText();
      var chars = renderText.split('');
      var spacesNumber = renderText.split(' ').length - 1;
      var dx = this.parent.getAttribute('dx').split().map(_ => _.getPixels('x'));
      var dy = this.parent.getAttribute('dy').getPixels('y');
      var anchor = this.parent.getStyle('text-anchor').getString('start');
      var thisSpacing = this.getStyle('letter-spacing');
      var parentSpacing = this.parent.getStyle('letter-spacing');
      var letterSpacing = 0;

      if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {
        letterSpacing = parentSpacing.getPixels();
      } else if (thisSpacing.hasValue()) {
        if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {
          letterSpacing = thisSpacing.getPixels();
        }
      } // fill letter-spacing cache


      var letterSpacingCache = [];
      var textLen = renderText.length;
      this.letterSpacingCache = letterSpacingCache;

      for (var i = 0; i < textLen; i++) {
        letterSpacingCache.push(typeof dx[i] !== 'undefined' ? dx[i] : letterSpacing);
      }

      var dxSum = letterSpacingCache.reduce((acc, cur, i) => i === 0 ? 0 : acc + cur || 0, 0);
      var textWidth = this.measureText(ctx);
      var textFullWidth = Math.max(textWidth + dxSum, 0);
      this.textWidth = textWidth;
      this.textHeight = this.getFontSize();
      this.glyphInfo = [];
      var fullPathWidth = this.getPathLength();
      var startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;
      var offset = 0;

      if (anchor === 'middle' || anchor === 'center') {
        offset = -textFullWidth / 2;
      }

      if (anchor === 'end' || anchor === 'right') {
        offset = -textFullWidth;
      }

      offset += startOffset;
      chars.forEach((char, i) => {
        // Find such segment what distance between p0 and p1 is approx. width of glyph
        var {
          offset: nextOffset,
          segment,
          rotation
        } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);
        offset = nextOffset;

        if (!segment.p0 || !segment.p1) {
          return;
        } // const width = this.getLineLength(
        // 	segment.p0.x,
        // 	segment.p0.y,
        // 	segment.p1.x,
        // 	segment.p1.y
        // );
        // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
        // Can foresee having a rough pair table built in that the developer can override as needed.
        // Or use "dx" attribute of the <text> node as a naive replacement
        // const kern = 0;
        // placeholder for future implementation
        // const midpoint = this.getPointOnLine(
        // 	kern + width / 2.0,
        // 	segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y
        // );


        this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: chars[i],
          p0: segment.p0,
          p1: segment.p1,
          rotation
        });
      });
    }

    parsePathData(path) {
      this.pathLength = -1; // reset path length

      if (!path) {
        return [];
      }

      var pathCommands = [];
      var {
        pathParser
      } = path;
      pathParser.reset(); // convert l, H, h, V, and v to L

      while (!pathParser.isEnd()) {
        var {
          current
        } = pathParser;
        var startX = current ? current.x : 0;
        var startY = current ? current.y : 0;
        var command = pathParser.next();
        var nextCommandType = command.type;
        var points = [];

        switch (command.type) {
          case PathParser.MOVE_TO:
            this.pathM(pathParser, points);
            break;

          case PathParser.LINE_TO:
            nextCommandType = this.pathL(pathParser, points);
            break;

          case PathParser.HORIZ_LINE_TO:
            nextCommandType = this.pathH(pathParser, points);
            break;

          case PathParser.VERT_LINE_TO:
            nextCommandType = this.pathV(pathParser, points);
            break;

          case PathParser.CURVE_TO:
            this.pathC(pathParser, points);
            break;

          case PathParser.SMOOTH_CURVE_TO:
            nextCommandType = this.pathS(pathParser, points);
            break;

          case PathParser.QUAD_TO:
            this.pathQ(pathParser, points);
            break;

          case PathParser.SMOOTH_QUAD_TO:
            nextCommandType = this.pathT(pathParser, points);
            break;

          case PathParser.ARC:
            points = this.pathA(pathParser);
            break;

          case PathParser.CLOSE_PATH:
            PathElement.pathZ(pathParser);
            break;
        }

        if (command.type !== PathParser.CLOSE_PATH) {
          pathCommands.push({
            type: nextCommandType,
            points,
            start: {
              x: startX,
              y: startY
            },
            pathLength: this.calcLength(startX, startY, nextCommandType, points)
          });
        } else {
          pathCommands.push({
            type: PathParser.CLOSE_PATH,
            points: [],
            pathLength: 0
          });
        }
      }

      return pathCommands;
    }

    pathM(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathM(pathParser).point;
      points.push(x, y);
    }

    pathL(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathL(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathH(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathH(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathV(pathParser, points) {
      var {
        x,
        y
      } = PathElement.pathV(pathParser).point;
      points.push(x, y);
      return PathParser.LINE_TO;
    }

    pathC(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }

    pathS(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.CURVE_TO;
    }

    pathQ(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }

    pathT(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.QUAD_TO;
    }

    pathA(pathParser) {
      var {
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);

      if (sweepFlag === 0 && ad > 0) {
        ad -= 2 * Math.PI;
      }

      if (sweepFlag === 1 && ad < 0) {
        ad += 2 * Math.PI;
      }

      return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
    }

    calcLength(x, y, commandType, points) {
      var len = 0;
      var p1 = null;
      var p2 = null;
      var t = 0;

      switch (commandType) {
        case PathParser.LINE_TO:
          return this.getLineLength(x, y, points[0], points[1]);

        case PathParser.CURVE_TO:
          // Approximates by breaking curve into 100 line segments
          len = 0.0;
          p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);

          for (t = 0.01; t <= 1; t += 0.01) {
            p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }

          return len;

        case PathParser.QUAD_TO:
          // Approximates by breaking curve into 100 line segments
          len = 0.0;
          p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);

          for (t = 0.01; t <= 1; t += 0.01) {
            p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }

          return len;

        case PathParser.ARC:
          {
            // Approximates by breaking curve into line segments
            len = 0.0;
            var start = points[4]; // 4 = theta

            var dTheta = points[5]; // 5 = dTheta

            var end = points[4] + dTheta;
            var inc = Math.PI / 180.0; // 1 degree resolution

            if (Math.abs(start - end) < inc) {
              inc = Math.abs(start - end);
            } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi


            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);

            if (dTheta < 0) {
              // clockwise
              for (t = start - inc; t > end; t -= inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            } else {
              // counter-clockwise
              for (t = start + inc; t < end; t += inc) {
                p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
                len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
                p1 = p2;
              }
            }

            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            return len;
          }
      }

      return 0;
    }

    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
      var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;
      var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;
      var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
      var run = Math.sqrt(dist * dist / (1 + m * m));

      if (p2x < p1x) {
        run *= -1;
      }

      var rise = m * run;
      var pt = null;

      if (p2x === p1x) {
        // vertical line
        pt = {
          x: fromX,
          y: fromY + rise
        };
      } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {
        pt = {
          x: fromX + run,
          y: fromY + rise
        };
      } else {
        var ix = 0;
        var iy = 0;
        var len = this.getLineLength(p1x, p1y, p2x, p2y);

        if (len < PSEUDO_ZERO) {
          return null;
        }

        var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
        u /= len * len;
        ix = p1x + u * (p2x - p1x);
        iy = p1y + u * (p2y - p1y);
        var pRise = this.getLineLength(fromX, fromY, ix, iy);
        var pRun = Math.sqrt(dist * dist - pRise * pRise);
        run = Math.sqrt(pRun * pRun / (1 + m * m));

        if (p2x < p1x) {
          run *= -1;
        }

        rise = m * run;
        pt = {
          x: ix + run,
          y: iy + rise
        };
      }

      return pt;
    }

    getPointOnPath(distance) {
      var fullLen = this.getPathLength();
      var cumulativePathLength = 0;
      var p = null;

      if (distance < -0.00005 || distance - 0.00005 > fullLen) {
        return null;
      }

      var {
        dataArray
      } = this;

      for (var command of dataArray) {
        if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {
          cumulativePathLength += command.pathLength;
          continue;
        }

        var delta = distance - cumulativePathLength;
        var currentT = 0;

        switch (command.type) {
          case PathParser.LINE_TO:
            p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
            break;

          case PathParser.ARC:
            {
              var start = command.points[4]; // 4 = theta

              var dTheta = command.points[5]; // 5 = dTheta

              var end = command.points[4] + dTheta;
              currentT = start + delta / command.pathLength * dTheta;

              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
                break;
              }

              p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
              break;
            }

          case PathParser.CURVE_TO:
            currentT = delta / command.pathLength;

            if (currentT > 1) {
              currentT = 1;
            }

            p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
            break;

          case PathParser.QUAD_TO:
            currentT = delta / command.pathLength;

            if (currentT > 1) {
              currentT = 1;
            }

            p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
            break;
        }

        if (p) {
          return p;
        }

        break;
      }

      return null;
    }

    getLineLength(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    getPathLength() {
      if (this.pathLength === -1) {
        this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
      }

      return this.pathLength;
    }

    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
      var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
      return {
        x,
        y
      };
    }

    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
      var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
      var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
      return {
        x,
        y
      };
    }

    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
      var cosPsi = Math.cos(psi);
      var sinPsi = Math.sin(psi);
      var pt = {
        x: rx * Math.cos(theta),
        y: ry * Math.sin(theta)
      };
      return {
        x: cx + (pt.x * cosPsi - pt.y * sinPsi),
        y: cy + (pt.x * sinPsi + pt.y * cosPsi)
      };
    } // TODO need some optimisations. possibly build cache only for curved segments?


    buildEquidistantCache(inputStep, inputPrecision) {
      var fullLen = this.getPathLength();
      var precision = inputPrecision || 0.25; // accuracy vs performance

      var step = inputStep || fullLen / 100;

      if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
        // Prepare cache
        this.equidistantCache = {
          step,
          precision,
          points: []
        }; // Calculate points

        var s = 0;

        for (var l = 0; l <= fullLen; l += precision) {
          var p0 = this.getPointOnPath(l);
          var p1 = this.getPointOnPath(l + precision);

          if (!p0 || !p1) {
            continue;
          }

          s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);

          if (s >= step) {
            this.equidistantCache.points.push({
              x: p0.x,
              y: p0.y,
              distance: l
            });
            s -= step;
          }
        }
      }
    }

    getEquidistantPointOnPath(targetDistance, step, precision) {
      this.buildEquidistantCache(step, precision);

      if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {
        return null;
      }

      var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
      return this.equidistantCache.points[idx] || null;
    }

  }

  var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
  class ImageElement extends RenderedElement {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'image';
      this.loaded = false;
      var href = this.getHrefAttribute().getString();

      if (!href) {
        return;
      }

      var isSvg = href.endsWith('.svg') || /^\s*data:image\/svg\+xml/i.test(href);
      document.images.push(this);

      if (!isSvg) {
        void this.loadImage(href);
      } else {
        void this.loadSvg(href);
      }

      this.isSvg = isSvg;
    }

    loadImage(href) {
      var _this = this;

      return _asyncToGenerator(function* () {
        try {
          var image = yield _this.document.createImage(href);
          _this.image = image;
        } catch (err) {
          console.error("Error while loading image \"".concat(href, "\":"), err);
        }

        _this.loaded = true;
      })();
    }

    loadSvg(href) {
      var _this2 = this;

      return _asyncToGenerator(function* () {
        var match = dataUriRegex.exec(href);

        if (match) {
          var data = match[5];

          if (match[4] === 'base64') {
            _this2.image = atob(data);
          } else {
            _this2.image = decodeURIComponent(data);
          }
        } else {
          try {
            var response = yield _this2.document.fetch(href);
            var svg = yield response.text();
            _this2.image = svg;
          } catch (err) {
            console.error("Error while loading image \"".concat(href, "\":"), err);
          }
        }

        _this2.loaded = true;
      })();
    }

    renderChildren(ctx) {
      var {
        document,
        image,
        loaded
      } = this;
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');

      if (!loaded || !image || !width || !height) {
        return;
      }

      ctx.save();
      ctx.translate(x, y);

      if (this.isSvg) {
        var subDocument = document.canvg.forkString(ctx, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: width,
          scaleHeight: height
        });
        subDocument.document.documentElement.parent = this;
        void subDocument.render();
      } else {
        var _image = this.image;
        document.setViewBox({
          ctx,
          aspectRatio: this.getAttribute('preserveAspectRatio').getString(),
          width,
          desiredWidth: _image.width,
          height,
          desiredHeight: _image.height
        });

        if (this.loaded) {
          if (typeof _image.complete === 'undefined' || _image.complete) {
            ctx.drawImage(_image, 0, 0);
          }
        }
      }

      ctx.restore();
    }

    getBoundingBox() {
      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');
      return new BoundingBox(x, y, x + width, y + height);
    }

  }

  class SymbolElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'symbol';
    }

    render(_) {// NO RENDER
    }

  }

  class SVGFontLoader {
    constructor(document) {
      this.document = document;
      this.loaded = false;
      document.fonts.push(this);
    }

    load(fontFamily, url) {
      var _this = this;

      return _asyncToGenerator(function* () {
        try {
          var {
            document
          } = _this;
          var svgDocument = yield document.canvg.parser.load(url);
          var fonts = svgDocument.getElementsByTagName('font');
          Array.from(fonts).forEach(fontNode => {
            var font = document.createElement(fontNode);
            document.definitions[fontFamily] = font;
          });
        } catch (err) {
          console.error("Error while loading font \"".concat(url, "\":"), err);
        }

        _this.loaded = true;
      })();
    }

  }

  class StyleElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'style';
      var css = compressSpaces(Array.from(node.childNodes) // NEED TEST
      .map(_ => _.textContent).join('').replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '') // remove comments
      .replace(/@import.*;/g, '') // remove imports
      );
      var cssDefs = css.split('}');
      cssDefs.forEach(_ => {
        var def = _.trim();

        if (!def) {
          return;
        }

        var cssParts = def.split('{');
        var cssClasses = cssParts[0].split(',');
        var cssProps = cssParts[1].split(';');
        cssClasses.forEach(_ => {
          var cssClass = _.trim();

          if (!cssClass) {
            return;
          }

          var props = document.styles[cssClass] || {};
          cssProps.forEach(cssProp => {
            var prop = cssProp.indexOf(':');
            var name = cssProp.substr(0, prop).trim();
            var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();

            if (name && value) {
              props[name] = new Property(document, name, value);
            }
          });
          document.styles[cssClass] = props;
          document.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);

          if (cssClass === '@font-face') {
            //  && !nodeEnv
            var fontFamily = props['font-family'].getString().replace(/"|'/g, '');
            var srcs = props.src.getString().split(',');
            srcs.forEach(src => {
              if (src.indexOf('format("svg")') > 0) {
                var url = parseExternalUrl(src);

                if (url) {
                  void new SVGFontLoader(document).load(fontFamily, url);
                }
              }
            });
          }
        });
      });
    }

  }
  StyleElement.parseExternalUrl = parseExternalUrl;

  class UseElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = 'use';
    }

    setContext(ctx) {
      super.setContext(ctx);
      var xAttr = this.getAttribute('x');
      var yAttr = this.getAttribute('y');

      if (xAttr.hasValue()) {
        ctx.translate(xAttr.getPixels('x'), 0);
      }

      if (yAttr.hasValue()) {
        ctx.translate(0, yAttr.getPixels('y'));
      }
    }

    path(ctx) {
      var {
        element
      } = this;

      if (element) {
        element.path(ctx);
      }
    }

    renderChildren(ctx) {
      var {
        document,
        element
      } = this;

      if (element) {
        var tempSvg = element;

        if (element.type === 'symbol') {
          // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
          tempSvg = new SVGElement(document, null);
          tempSvg.attributes.viewBox = new Property(document, 'viewBox', element.getAttribute('viewBox').getString());
          tempSvg.attributes.preserveAspectRatio = new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString());
          tempSvg.attributes.overflow = new Property(document, 'overflow', element.getAttribute('overflow').getString());
          tempSvg.children = element.children; // element is still the parent of the children

          element.styles.opacity = new Property(document, 'opacity', this.calculateOpacity());
        }

        if (tempSvg.type === 'svg') {
          var widthStyle = this.getStyle('width', false, true);
          var heightStyle = this.getStyle('height', false, true); // if symbol or svg, inherit width/height from me

          if (widthStyle.hasValue()) {
            tempSvg.attributes.width = new Property(document, 'width', widthStyle.getString());
          }

          if (heightStyle.hasValue()) {
            tempSvg.attributes.height = new Property(document, 'height', heightStyle.getString());
          }
        }

        var oldParent = tempSvg.parent;
        tempSvg.parent = this;
        tempSvg.render(ctx);
        tempSvg.parent = oldParent;
      }
    }

    getBoundingBox(ctx) {
      var {
        element
      } = this;

      if (element) {
        return element.getBoundingBox(ctx);
      }

      return null;
    }

    elementTransform() {
      var {
        document,
        element
      } = this;
      return Transform.fromElement(document, element);
    }

    get element() {
      if (!this.cachedElement) {
        this.cachedElement = this.getHrefAttribute().getDefinition();
      }

      return this.cachedElement;
    }

  }

  function imGet(img, x, y, width, _height, rgba) {
    return img[y * width * 4 + x * 4 + rgba];
  }

  function imSet(img, x, y, width, _height, rgba, val) {
    img[y * width * 4 + x * 4 + rgba] = val;
  }

  function m(matrix, i, v) {
    var mi = matrix[i];
    return mi * v;
  }

  function c(a, m1, m2, m3) {
    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;
  }

  class FeColorMatrixElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feColorMatrix';
      var matrix = toNumbers(this.getAttribute('values').getString());

      switch (this.getAttribute('type').getString('matrix')) {
        // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
        case 'saturate':
          {
            var s = matrix[0];
            /* eslint-disable array-element-newline */

            matrix = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            /* eslint-enable array-element-newline */

            break;
          }

        case 'hueRotate':
          {
            var a = matrix[0] * Math.PI / 180.0;
            /* eslint-disable array-element-newline */

            matrix = [c(a, 0.213, 0.787, -0.213), c(a, 0.715, -0.715, -0.715), c(a, 0.072, -0.072, 0.928), 0, 0, c(a, 0.213, -0.213, 0.143), c(a, 0.715, 0.285, 0.140), c(a, 0.072, -0.072, -0.283), 0, 0, c(a, 0.213, -0.213, -0.787), c(a, 0.715, -0.715, 0.715), c(a, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
            /* eslint-enable array-element-newline */

            break;
          }

        case 'luminanceToAlpha':
          /* eslint-disable array-element-newline */
          matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
          /* eslint-enable array-element-newline */

          break;
      }

      this.matrix = matrix;
      this.includeOpacity = this.getAttribute('includeOpacity').hasValue();
    }

    apply(ctx, _x, _y, width, height) {
      // assuming x==0 && y==0 for now
      var {
        includeOpacity,
        matrix
      } = this;
      var srcData = ctx.getImageData(0, 0, width, height);

      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var r = imGet(srcData.data, x, y, width, height, 0);
          var g = imGet(srcData.data, x, y, width, height, 1);
          var b = imGet(srcData.data, x, y, width, height, 2);
          var a = imGet(srcData.data, x, y, width, height, 3);
          var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);
          var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);
          var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);
          var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);

          if (includeOpacity) {
            nr = 0;
            ng = 0;
            nb = 0;
            na *= a / 255;
          }

          imSet(srcData.data, x, y, width, height, 0, nr);
          imSet(srcData.data, x, y, width, height, 1, ng);
          imSet(srcData.data, x, y, width, height, 2, nb);
          imSet(srcData.data, x, y, width, height, 3, na);
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.putImageData(srcData, 0, 0);
    }

  }

  class MaskElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'mask';
    }

    apply(ctx, element) {
      var {
        document
      } = this; // render as temp svg

      var x = this.getAttribute('x').getPixels('x');
      var y = this.getAttribute('y').getPixels('y');
      var width = this.getStyle('width').getPixels('x');
      var height = this.getStyle('height').getPixels('y');

      if (!width && !height) {
        var boundingBox = new BoundingBox();
        this.children.forEach(child => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        x = Math.floor(boundingBox.x1);
        y = Math.floor(boundingBox.y1);
        width = Math.floor(boundingBox.width);
        height = Math.floor(boundingBox.height);
      }

      var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
      var maskCanvas = document.createCanvas(x + width, y + height);
      var maskCtx = maskCanvas.getContext('2d');
      document.screen.setDefaults(maskCtx);
      this.renderChildren(maskCtx); // convert mask to alpha with a fake node
      // TODO: refactor out apply from feColorMatrix

      new FeColorMatrixElement(document, {
        nodeType: 1,
        childNodes: [],
        attributes: [{
          nodeName: 'type',
          value: 'luminanceToAlpha'
        }, {
          nodeName: 'includeOpacity',
          value: 'true'
        }]
      }).apply(maskCtx, 0, 0, x + width, y + height);
      var tmpCanvas = document.createCanvas(x + width, y + height);
      var tmpCtx = tmpCanvas.getContext('2d');
      document.screen.setDefaults(tmpCtx);
      element.render(tmpCtx);
      tmpCtx.globalCompositeOperation = 'destination-in';
      tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');
      tmpCtx.fillRect(0, 0, x + width, y + height);
      ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');
      ctx.fillRect(0, 0, x + width, y + height); // reassign mask

      this.restoreStyles(element, ignoredStyles);
    }

    render(_) {// NO RENDER
    }

  }
  MaskElement.ignoreStyles = ['mask', 'transform', 'clip-path'];

  var noop = () => {// NOOP
  };

  class ClipPathElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'clipPath';
    }

    apply(ctx) {
      var {
        document
      } = this;
      var contextProto = Reflect.getPrototypeOf(ctx);
      var {
        beginPath,
        closePath
      } = ctx;

      if (contextProto) {
        contextProto.beginPath = noop;
        contextProto.closePath = noop;
      }

      Reflect.apply(beginPath, ctx, []);
      this.children.forEach(child => {
        if (typeof child.path === 'undefined') {
          return;
        }

        var transform = typeof child.elementTransform !== 'undefined' ? child.elementTransform() : null; // handle <use />

        if (!transform) {
          transform = Transform.fromElement(document, child);
        }

        if (transform) {
          transform.apply(ctx);
        }

        child.path(ctx);

        if (contextProto) {
          contextProto.closePath = closePath;
        }

        if (transform) {
          transform.unapply(ctx);
        }
      });
      Reflect.apply(closePath, ctx, []);
      ctx.clip();

      if (contextProto) {
        contextProto.beginPath = beginPath;
        contextProto.closePath = closePath;
      }
    }

    render(_) {// NO RENDER
    }

  }

  class FilterElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'filter';
    }

    apply(ctx, element) {
      // render as temp svg
      var {
        document,
        children
      } = this;
      var boundingBox = element.getBoundingBox(ctx);

      if (!boundingBox) {
        return;
      }

      var px = 0;
      var py = 0;
      children.forEach(child => {
        var efd = child.extraFilterDistance || 0;
        px = Math.max(px, efd);
        py = Math.max(py, efd);
      });
      var width = Math.floor(boundingBox.width);
      var height = Math.floor(boundingBox.height);
      var tmpCanvasWidth = width + 2 * px;
      var tmpCanvasHeight = height + 2 * py;

      if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
        return;
      }

      var x = Math.floor(boundingBox.x);
      var y = Math.floor(boundingBox.y);
      var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
      var tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
      var tmpCtx = tmpCanvas.getContext('2d');
      document.screen.setDefaults(tmpCtx);
      tmpCtx.translate(-x + px, -y + py);
      element.render(tmpCtx); // apply filters

      children.forEach(child => {
        if (typeof child.apply === 'function') {
          child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
        }
      }); // render on me

      ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);
      this.restoreStyles(element, ignoredStyles);
    }

    render(_) {// NO RENDER
    }

  }
  FilterElement.ignoreStyles = ['filter', 'transform', 'clip-path'];

  class FeDropShadowElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feDropShadow';
      this.addStylesFromStyleDefinition();
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeMorphologyElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'feMorphology';
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeCompositeElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'feComposite';
    }

    apply(_, _x, _y, _width, _height) {// TODO: implement
    }

  }

  class FeGaussianBlurElement extends Element$1 {
    constructor(document, node, captureTextNodes) {
      super(document, node, captureTextNodes);
      this.type = 'feGaussianBlur';
      this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());
      this.extraFilterDistance = this.blurRadius;
    }

    apply(ctx, x, y, width, height) {
      var {
        document,
        blurRadius
      } = this;
      var body = document.window ? document.window.document.body : null;
      var canvas = ctx.canvas; // StackBlur requires canvas be on document

      canvas.id = document.getUniqueId();

      if (body) {
        canvas.style.display = 'none';
        body.appendChild(canvas);
      }

      processCanvasRGBA(canvas, x, y, width, height, blurRadius);

      if (body) {
        body.removeChild(canvas);
      }
    }

  }

  class TitleElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'title';
    }

  }

  class DescElement extends Element$1 {
    constructor() {
      super(...arguments);
      this.type = 'desc';
    }

  }

  var elements = {
    'svg': SVGElement,
    'rect': RectElement,
    'circle': CircleElement,
    'ellipse': EllipseElement,
    'line': LineElement,
    'polyline': PolylineElement,
    'polygon': PolygonElement,
    'path': PathElement,
    'pattern': PatternElement,
    'marker': MarkerElement,
    'defs': DefsElement,
    'linearGradient': LinearGradientElement,
    'radialGradient': RadialGradientElement,
    'stop': StopElement,
    'animate': AnimateElement,
    'animateColor': AnimateColorElement,
    'animateTransform': AnimateTransformElement,
    'font': FontElement,
    'font-face': FontFaceElement,
    'missing-glyph': MissingGlyphElement,
    'glyph': GlyphElement,
    'text': TextElement,
    'tspan': TSpanElement,
    'tref': TRefElement,
    'a': AElement,
    'textPath': TextPathElement,
    'image': ImageElement,
    'g': GElement,
    'symbol': SymbolElement,
    'style': StyleElement,
    'use': UseElement,
    'mask': MaskElement,
    'clipPath': ClipPathElement,
    'filter': FilterElement,
    'feDropShadow': FeDropShadowElement,
    'feMorphology': FeMorphologyElement,
    'feComposite': FeCompositeElement,
    'feColorMatrix': FeColorMatrixElement,
    'feGaussianBlur': FeGaussianBlurElement,
    'title': TitleElement,
    'desc': DescElement
  };

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function createCanvas(width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

  function createImage(_x) {
    return _createImage.apply(this, arguments);
  }

  function _createImage() {
    _createImage = _asyncToGenerator(function* (src) {
      var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var image = document.createElement('img');

      if (anonymousCrossOrigin) {
        image.crossOrigin = 'Anonymous';
      }

      return new Promise((resolve, reject) => {
        image.onload = () => {
          resolve(image);
        };

        image.onerror = (_event, _source, _lineno, _colno, error) => {
          reject(error);
        };

        image.src = src;
      });
    });
    return _createImage.apply(this, arguments);
  }

  class Document {
    constructor(canvg) {
      var {
        rootEmSize = 12,
        emSize = 12,
        createCanvas = Document.createCanvas,
        createImage = Document.createImage,
        anonymousCrossOrigin
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.canvg = canvg;
      this.definitions = {};
      this.styles = {};
      this.stylesSpecificity = {};
      this.images = [];
      this.fonts = [];
      this.emSizeStack = [];
      this.uniqueId = 0;
      this.screen = canvg.screen;
      this.rootEmSize = rootEmSize;
      this.emSize = emSize;
      this.createCanvas = createCanvas;
      this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);
      this.screen.wait(this.isImagesLoaded.bind(this));
      this.screen.wait(this.isFontsLoaded.bind(this));
    }

    bindCreateImage(createImage, anonymousCrossOrigin) {
      if (typeof anonymousCrossOrigin === 'boolean') {
        return (source, forceAnonymousCrossOrigin) => createImage(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
      }

      return createImage;
    }

    get window() {
      return this.screen.window;
    }

    get fetch() {
      return this.screen.fetch;
    }

    get ctx() {
      return this.screen.ctx;
    }

    get emSize() {
      var {
        emSizeStack
      } = this;
      return emSizeStack[emSizeStack.length - 1];
    }

    set emSize(value) {
      var {
        emSizeStack
      } = this;
      emSizeStack.push(value);
    }

    popEmSize() {
      var {
        emSizeStack
      } = this;
      emSizeStack.pop();
    }

    getUniqueId() {
      return "canvg".concat(++this.uniqueId);
    }

    isImagesLoaded() {
      return this.images.every(_ => _.loaded);
    }

    isFontsLoaded() {
      return this.fonts.every(_ => _.loaded);
    }

    createDocumentElement(document) {
      var documentElement = this.createElement(document.documentElement);
      documentElement.root = true;
      documentElement.addStylesFromStyleDefinition();
      this.documentElement = documentElement;
      return documentElement;
    }

    createElement(node) {
      var elementType = node.nodeName.replace(/^[^:]+:/, '');
      var ElementType = Document.elementTypes[elementType];

      if (typeof ElementType !== 'undefined') {
        return new ElementType(this, node);
      }

      return new UnknownElement(this, node);
    }

    createTextNode(node) {
      return new TextNode(this, node);
    }

    setViewBox(config) {
      this.screen.setViewBox(_objectSpread$1({
        document: this
      }, config));
    }

  }
  Document.createCanvas = createCanvas;
  Document.createImage = createImage;
  Document.elementTypes = elements;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * SVG renderer on canvas.
   */

  class Canvg {
    /**
     * Main constructor.
     * @param ctx - Rendering context.
     * @param svg - SVG Document.
     * @param options - Rendering options.
     */
    constructor(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.parser = new Parser(options);
      this.screen = new Screen(ctx, options);
      this.options = options;
      var document = new Document(this, options);
      var documentElement = document.createDocumentElement(svg);
      this.document = document;
      this.documentElement = documentElement;
    }
    /**
     * Create Canvg instance from SVG source string or URL.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    static from(ctx, svg) {
      var _arguments = arguments;
      return _asyncToGenerator(function* () {
        var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
        var parser = new Parser(options);
        var svgDocument = yield parser.parse(svg);
        return new Canvg(ctx, svgDocument, options);
      })();
    }
    /**
     * Create Canvg instance from SVG source string.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    static fromString(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = parser.parseFromString(svg);
      return new Canvg(ctx, svgDocument, options);
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    fork(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */


    forkString(ctx, svg) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Document is ready promise.
     * @returns Ready promise.
     */


    ready() {
      return this.screen.ready();
    }
    /**
     * Document is ready value.
     * @returns Is ready or not.
     */


    isReady() {
      return this.screen.isReady();
    }
    /**
     * Render only first frame, ignoring animations and mouse.
     * @param options - Rendering options.
     */


    render() {
      var _arguments2 = arguments,
          _this = this;

      return _asyncToGenerator(function* () {
        var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};

        _this.start(_objectSpread({
          enableRedraw: true,
          ignoreAnimation: true,
          ignoreMouse: true
        }, options));

        yield _this.ready();

        _this.stop();
      })();
    }
    /**
     * Start rendering.
     * @param options - Render options.
     */


    start() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var {
        documentElement,
        screen,
        options: baseOptions
      } = this;
      screen.start(documentElement, _objectSpread(_objectSpread({
        enableRedraw: true
      }, baseOptions), options));
    }
    /**
     * Stop rendering.
     */


    stop() {
      this.screen.stop();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */


    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.documentElement.resize(width, height, preserveAspectRatio);
    }

  }

  var index_es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AElement: AElement,
    AnimateColorElement: AnimateColorElement,
    AnimateElement: AnimateElement,
    AnimateTransformElement: AnimateTransformElement,
    BoundingBox: BoundingBox,
    CB1: CB1,
    CB2: CB2,
    CB3: CB3,
    CB4: CB4,
    Canvg: Canvg,
    CircleElement: CircleElement,
    ClipPathElement: ClipPathElement,
    DefsElement: DefsElement,
    DescElement: DescElement,
    Document: Document,
    Element: Element$1,
    EllipseElement: EllipseElement,
    FeColorMatrixElement: FeColorMatrixElement,
    FeCompositeElement: FeCompositeElement,
    FeDropShadowElement: FeDropShadowElement,
    FeGaussianBlurElement: FeGaussianBlurElement,
    FeMorphologyElement: FeMorphologyElement,
    FilterElement: FilterElement,
    Font: Font,
    FontElement: FontElement,
    FontFaceElement: FontFaceElement,
    GElement: GElement,
    GlyphElement: GlyphElement,
    GradientElement: GradientElement,
    ImageElement: ImageElement,
    LineElement: LineElement,
    LinearGradientElement: LinearGradientElement,
    MarkerElement: MarkerElement,
    MaskElement: MaskElement,
    Matrix: Matrix,
    MissingGlyphElement: MissingGlyphElement,
    Mouse: Mouse,
    PSEUDO_ZERO: PSEUDO_ZERO,
    Parser: Parser,
    PathElement: PathElement,
    PathParser: PathParser,
    PatternElement: PatternElement,
    Point: Point,
    PolygonElement: PolygonElement,
    PolylineElement: PolylineElement,
    Property: Property,
    QB1: QB1,
    QB2: QB2,
    QB3: QB3,
    RadialGradientElement: RadialGradientElement,
    RectElement: RectElement,
    RenderedElement: RenderedElement,
    Rotate: Rotate,
    SVGElement: SVGElement,
    SVGFontLoader: SVGFontLoader,
    Scale: Scale,
    Screen: Screen,
    Skew: Skew,
    SkewX: SkewX,
    SkewY: SkewY,
    StopElement: StopElement,
    StyleElement: StyleElement,
    SymbolElement: SymbolElement,
    TRefElement: TRefElement,
    TSpanElement: TSpanElement,
    TextElement: TextElement,
    TextPathElement: TextPathElement,
    TitleElement: TitleElement,
    Transform: Transform,
    Translate: Translate,
    UnknownElement: UnknownElement,
    UseElement: UseElement,
    ViewPort: ViewPort,
    compressSpaces: compressSpaces,
    'default': Canvg,
    getSelectorSpecificity: getSelectorSpecificity,
    normalizeAttributeName: normalizeAttributeName,
    normalizeColor: normalizeColor,
    parseExternalUrl: parseExternalUrl,
    presets: index,
    toNumbers: toNumbers,
    trimLeft: trimLeft,
    trimRight: trimRight,
    vectorMagnitude: vectorMagnitude,
    vectorsAngle: vectorsAngle,
    vectorsRatio: vectorsRatio
  });

  exports.Map = Map$1;
  exports.component = index$2;
  exports.config = index$7;
  exports.feature = index$4;
  exports.geojson = GeoJSON;
  exports.layer = index$5;
  exports.model = index$1;
  exports.name = name;
  exports.overlay = index$3;
  exports.proj = ProjUtil;
  exports.style = Style;
  exports.util = index$6;
  exports.version = version$1;
  exports.wkt = WKT;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=mti-gis-ol-src.js.map
